36cf18b54e708d275c2060938a05b1a29475bbea
==================================================
Use same handling for incomplete reads now all InputBuffers support
==================================================
Mark Thomas
==================================================
Tue Jan 13 15:48:01 2015 +0000
==================================================
AbstractHttp11Processor.java
Use same handling for incomplete reads now all InputBuffers support
non-blcoking reading of request line and headers. Pull method up into
base class to reduce duplication.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1651388 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Http11AprProcessor.java
index 9724099513..556fba7308 100644
--- a/java/org/apache/coyote/http11/AbstractHttp11Processor.java
+++ b/java/org/apache/coyote/http11/AbstractHttp11Processor.java
@@ -901,15 +901,6 @@ public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
     abstract void actionInternal(ActionCode actionCode, Object param);
 
 
-    /**
-     * Defines how a connector handles an incomplete request line read.
-     *
-     * @return <code>true</code> if the processor should break out of the
-     *         processing loop, otherwise <code>false</code>.
-     */
-    protected abstract boolean handleIncompleteRequestLineRead();
-
-
     /**
      * Set the socket timeout.
      */
@@ -1145,6 +1136,39 @@ public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
     }
 
 
+    private boolean handleIncompleteRequestLineRead() {
+        // Haven't finished reading the request so keep the socket
+        // open
+        openSocket = true;
+        // Check to see if we have read any of the request line yet
+        if (getInputBuffer().getParsingRequestLinePhase() < 1) {
+            if (keptAlive) {
+                // Haven't read the request line and have previously processed a
+                // request. Must be keep-alive. Make sure poller uses keepAlive.
+                socketWrapper.setTimeout(endpoint.getKeepAliveTimeout());
+            }
+        } else {
+            // Started to read request line.
+            if (request.getStartTime() < 0) {
+                request.setStartTime(System.currentTimeMillis());
+            }
+            if (endpoint.isPaused()) {
+                // Partially processed the request so need to respond
+                response.setStatus(503);
+                setErrorState(ErrorState.CLOSE_CLEAN, null);
+                getAdapter().log(request, response, 0);
+                return false;
+            } else {
+                // Need to keep processor associated with socket
+                readComplete = false;
+                // Make sure poller uses soTimeout from here onwards
+                socketWrapper.setTimeout(endpoint.getSoTimeout());
+            }
+        }
+        return true;
+    }
+
+
     private void checkExpectationAndResponseStatus() {
         if (expectation && (response.getStatus() < 200 || response.getStatus() > 299)) {
             // Client sent Expect: 100-continue but received a

==================================================
Http11Nio2Processor.java
index 3878d9ff46..9fa1c6df07 100644
--- a/java/org/apache/coyote/http11/Http11AprProcessor.java
+++ b/java/org/apache/coyote/http11/Http11AprProcessor.java
@@ -92,17 +92,6 @@ public class Http11AprProcessor extends AbstractHttp11Processor<Long> {
 
     // --------------------------------------------------------- Public Methods
 
-
-    @Override
-    protected boolean handleIncompleteRequestLineRead() {
-        // This means that no data is available right now
-        // (long keepalive), so that the processor should be recycled
-        // and the method should return true
-        openSocket = true;
-        return true;
-    }
-
-
     @Override
     protected void setSocketTimeout(int timeout) {
         Socket.timeoutSet(socketWrapper.getSocket().longValue(), timeout * 1000);

==================================================
Http11NioProcessor.java
index 9973c6c15b..77dde16029 100644
--- a/java/org/apache/coyote/http11/Http11Nio2Processor.java
+++ b/java/org/apache/coyote/http11/Http11Nio2Processor.java
@@ -121,41 +121,6 @@ public class Http11Nio2Processor extends AbstractHttp11Processor<Nio2Channel> {
     }
 
 
-    @Override
-    protected boolean handleIncompleteRequestLineRead() {
-        // Haven't finished reading the request so keep the socket
-        // open
-        openSocket = true;
-        // Check to see if we have read any of the request line yet
-        if (((InternalNio2InputBuffer)
-                getInputBuffer()).getParsingRequestLinePhase() < 1) {
-            if (keptAlive) {
-                // Haven't read the request line and have previously processed a
-                // request. Must be keep-alive. Make sure poller uses keepAlive.
-                socketWrapper.setTimeout(endpoint.getKeepAliveTimeout());
-            }
-        } else {
-            // Started to read request line.
-            if (request.getStartTime() < 0) {
-                request.setStartTime(System.currentTimeMillis());
-            }
-            if (endpoint.isPaused()) {
-                // Partially processed the request so need to respond
-                response.setStatus(503);
-                setErrorState(ErrorState.CLOSE_CLEAN, null);
-                getAdapter().log(request, response, 0);
-                return false;
-            } else {
-                // Need to keep processor associated with socket
-                readComplete = false;
-                // Make sure poller uses soTimeout from here onwards
-                socketWrapper.setTimeout(endpoint.getSoTimeout());
-            }
-        }
-        return true;
-    }
-
-
     @Override
     protected void setSocketTimeout(int timeout) throws IOException {
         socketWrapper.setTimeout(timeout);

==================================================
