d5176b0fdfa1e0c09d44913a2a9a4e1fa372598b
==================================================
Fix https://bz.apache.org/bugzilla/show_bug.cgi?id=61351
==================================================
Mark Thomas
==================================================
Thu Jul 27 18:45:49 2017 +0000
==================================================
UDecoder.java
index 6df7da329c..c8a8d3b447 100644
--- a/java/org/apache/tomcat/util/buf/LocalStrings.properties
+++ b/java/org/apache/tomcat/util/buf/LocalStrings.properties
@@ -19,7 +19,8 @@ c2bConverter.recycleFailed=Failed to recycle the C2B Converter. Creating new Buf
 hexUtils.fromHex.oddDigits=The input must consist of an even number of hex digits
 hexUtils.fromHex.nonHex=The input must consist only of hex digits
 
-uDecoder.urlDecode.missingDigit=The % character must be followed by two hexademical digits
+uDecoder.urlDecode.conversionError=Failed to decode [{0}] using character set [{1}]
+uDecoder.urlDecode.missingDigit=Failed to decode [{0}] because the % character must be followed by two hexademical digits
 uDecoder.convertHexDigit.notHex=[{0}] is not a hexadecimal digit
 
 byteBufferUtils.cleaner=Cannot use direct ByteBuffer cleaner, memory leaking may occur

==================================================
TestUDecoder.java
index 9d1d6fa1a1..d94e8d8bf9 100644
--- a/java/org/apache/tomcat/util/buf/UDecoder.java
+++ b/java/org/apache/tomcat/util/buf/UDecoder.java
@@ -16,8 +16,10 @@
  */
 package org.apache.tomcat.util.buf;
 
+import java.io.ByteArrayOutputStream;
 import java.io.CharConversionException;
 import java.io.IOException;
+import java.io.OutputStreamWriter;
 import java.nio.charset.Charset;
 import java.nio.charset.StandardCharsets;
 
@@ -317,39 +319,68 @@ public final class UDecoder {
             return null;
         }
 
-        byte[] bytes = str.getBytes(StandardCharsets.US_ASCII);
+        int index = str.indexOf('%');
+        if (index == -1) {
+            // No %nn sequences, so return string unchanged
+            return str;
+        }
 
         if (charset == null) {
             charset = StandardCharsets.UTF_8;
         }
 
-        int len = bytes.length;
+        /*
+         * Decoding is required.
+         *
+         * Potential complications:
+         * - The source String may be partially decoded so it is not valid to
+         *   assume that the source String is ASCII.
+         * - Have to process as characters since there is no guarantee that the
+         *   byte sequence for '%' is going to be the same in all character
+         *   sets.
+         * - We don't know how many '%nn' sequences are required for a single
+         *   character. It varies between character sets and some use a variable
+         *   length.
+         */
+
+        // This isn't perfect but it is a reasonable guess for the size of the
+        // array required
+        ByteArrayOutputStream baos = new ByteArrayOutputStream(str.length() * 2);
+
+        OutputStreamWriter osw = new OutputStreamWriter(baos, charset);
+
+        char[] sourceChars = str.toCharArray();
+        int len = sourceChars.length;
         int ix = 0;
-        int ox = 0;
-        while (ix < len) {
-            byte b = bytes[ix++];     // Get byte to test
-            if (b == '%') {
-                if (ix + 2 > len) {
-                    throw new IllegalArgumentException(
-                            sm.getString("uDecoder.urlDecode.missingDigit"));
+
+        try {
+            while (ix < len) {
+                char c = sourceChars[ix++];
+                if (c == '%') {
+                    osw.flush();
+                    if (ix + 2 > len) {
+                        throw new IllegalArgumentException(
+                                sm.getString("uDecoder.urlDecode.missingDigit", str));
+                    }
+                    char c1 = sourceChars[ix++];
+                    char c2 = sourceChars[ix++];
+                    if (isHexDigit(c1) && isHexDigit(c2)) {
+                        baos.write(x2c(c1, c2));
+                    } else {
+                        throw new IllegalArgumentException(
+                                sm.getString("uDecoder.urlDecode.missingDigit", str));
+                    }
+                } else {
+                    osw.append(c);
                 }
-                b = (byte) ((convertHexDigit(bytes[ix++]) << 4)
-                            + convertHexDigit(bytes[ix++]));
             }
-            bytes[ox++] = b;
-        }
+            osw.flush();
 
-        return new String(bytes, 0, ox, charset);
-    }
-
-
-    private static byte convertHexDigit( byte b ) {
-        if ((b >= '0') && (b <= '9')) return (byte)(b - '0');
-        if ((b >= 'a') && (b <= 'f')) return (byte)(b - 'a' + 10);
-        if ((b >= 'A') && (b <= 'F')) return (byte)(b - 'A' + 10);
-        throw new IllegalArgumentException(
-                sm.getString("uDecoder.convertHexDigit.notHex",
-                        Character.valueOf((char)b)));
+            return baos.toString(charset.name());
+        } catch (IOException ioe) {
+            throw new IllegalArgumentException(
+                    sm.getString("uDecoder.urlDecode.conversionError", str, charset.name()), ioe);
+        }
     }
 
 

==================================================
