69185da91148782c5b5360dd8ae0364d67d55618
==================================================
Remove unused code.
==================================================
Mark Thomas
==================================================
Fri Jan 16 12:15:18 2015 +0000
==================================================
AbstractProtocol.java
Remove unused code.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1652396 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AjpAprProtocol.java
index 270f33628e..f7df3f922b 100644
--- a/java/org/apache/coyote/AbstractProtocol.java
+++ b/java/org/apache/coyote/AbstractProtocol.java
@@ -673,7 +673,7 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
                         // Retrieve leftover input
                         ByteBuffer leftoverInput = processor.getLeftoverInput();
                         // Release the Http11 processor to be re-used
-                        release(wrapper, processor, false, false);
+                        release(wrapper, processor, false);
                         // Create the upgrade processor
                         processor = createUpgradeProcessor(
                                 wrapper, leftoverInput, httpUpgradeHandler);
@@ -713,13 +713,13 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
                     // In keep-alive but between requests. OK to recycle
                     // processor. Continue to poll for the next request.
                     connections.remove(socket);
-                    release(wrapper, processor, false, true);
+                    release(wrapper, processor, true);
                 } else if (state == SocketState.SENDFILE) {
                     // Sendfile in progress. If it fails, the socket will be
                     // closed. If it works, the socket will be re-added to the
                     // poller
                     connections.remove(socket);
-                    release(wrapper, processor, false, false);
+                    release(wrapper, processor, false);
                 } else if (state == SocketState.UPGRADED) {
                     // Don't add sockets back to the poller if this was a
                     // non-blocking write otherwise the poller may trigger
@@ -736,7 +736,7 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
                     if (processor.isUpgrade()) {
                         processor.getHttpUpgradeHandler().destroy();
                     } else {
-                        release(wrapper, processor, true, false);
+                        release(wrapper, processor, false);
                     }
                 }
                 return state;
@@ -768,7 +768,7 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
             connections.remove(socket);
             // Don't try to add upgrade processors back into the pool
             if (processor !=null && !processor.isUpgrade()) {
-                release(wrapper, processor, true, false);
+                release(wrapper, processor, false);
             }
             return SocketState.CLOSED;
         }
@@ -778,9 +778,20 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
                 Processor<S> processor);
         protected abstract void longPoll(SocketWrapperBase<S> socket,
                 Processor<S> processor);
+
+        /**
+         * Expected to be used by the handler once the processor is no longer
+         * required.
+         *
+         * @param socket    Socket being released (that was associated with the
+         *                  processor)
+         * @param processor Processor being released (that was associated with
+         *                  the socket)
+         * @param addToPoller Should the socket be added to the poller for
+         *                    reading
+         */
         protected abstract void release(SocketWrapperBase<S> socket,
-                Processor<S> processor, boolean socketClosing,
-                boolean addToPoller);
+                Processor<S> processor, boolean addToPoller);
         protected abstract Processor<S> createUpgradeProcessor(
                 SocketWrapperBase<S> socket, ByteBuffer leftoverInput,
                 HttpUpgradeHandler httpUpgradeHandler) throws IOException;

==================================================
AjpNio2Protocol.java
index badc366313..d27cd58c47 100644
--- a/java/org/apache/coyote/ajp/AjpAprProtocol.java
+++ b/java/org/apache/coyote/ajp/AjpAprProtocol.java
@@ -84,14 +84,9 @@ public class AjpAprProtocol extends AbstractAjpProtocol<Long> {
             return log;
         }
 
-        /**
-         * Expected to be used by the handler once the processor is no longer
-         * required.
-         */
         @Override
         public void release(SocketWrapperBase<Long> socket,
-                Processor<Long> processor, boolean isSocketClosing,
-                boolean addToPoller) {
+                Processor<Long> processor, boolean addToPoller) {
             processor.recycle();
             recycledProcessors.push(processor);
             if (addToPoller) {

==================================================
AjpNioProtocol.java
index d7b818073e..9a24db7e4f 100644
--- a/java/org/apache/coyote/ajp/AjpNio2Protocol.java
+++ b/java/org/apache/coyote/ajp/AjpNio2Protocol.java
@@ -92,17 +92,11 @@ public class AjpNio2Protocol extends AbstractAjpProtocol<Nio2Channel> {
             }
         }
 
-        /**
-         * Expected to be used by the handler once the processor is no longer
-         * required.
-         */
         @Override
         public void release(SocketWrapperBase<Nio2Channel> socket,
-                Processor<Nio2Channel> processor, boolean isSocketClosing,
-                boolean addToPoller) {
+                Processor<Nio2Channel> processor, boolean addToPoller) {
             if (getLog().isDebugEnabled()) {
                 log.debug("Socket: [" + socket + "], Processor: [" + processor +
-                        "], isSocketClosing: [" + isSocketClosing +
                         "], addToPoller: [" + addToPoller + "]");
             }
             processor.recycle();

==================================================
Http11AprProtocol.java
index f30074f191..43dda78673 100644
--- a/java/org/apache/coyote/ajp/AjpNioProtocol.java
+++ b/java/org/apache/coyote/ajp/AjpNioProtocol.java
@@ -106,6 +106,7 @@ public class AjpNioProtocol extends AbstractAjpProtocol<NioChannel> {
                         socket, Boolean.valueOf(released)));
         }
 
+
         /**
          * Expected to be used by the Poller to release resources on socket
          * close, errors etc.
@@ -120,14 +121,10 @@ public class AjpNioProtocol extends AbstractAjpProtocol<NioChannel> {
             }
         }
 
-        /**
-         * Expected to be used by the handler once the processor is no longer
-         * required.
-         */
+
         @Override
         public void release(SocketWrapperBase<NioChannel> socket,
-                Processor<NioChannel> processor, boolean isSocketClosing,
-                boolean addToPoller) {
+               Processor<NioChannel> processor,  boolean addToPoller) {
             processor.recycle();
             recycledProcessors.push(processor);
             if (addToPoller) {

==================================================
Http11Nio2Protocol.java
index 895912b4f6..7c71b56014 100644
--- a/java/org/apache/coyote/http11/Http11AprProtocol.java
+++ b/java/org/apache/coyote/http11/Http11AprProtocol.java
@@ -229,19 +229,9 @@ public class Http11AprProtocol extends AbstractHttp11Protocol<Long> {
             return log;
         }
 
-        /**
-         * Expected to be used by the handler once the processor is no longer
-         * required.
-         *
-         * @param socket
-         * @param processor
-         * @param isSocketClosing   Not used in HTTP
-         * @param addToPoller
-         */
         @Override
         public void release(SocketWrapperBase<Long> socket,
-                Processor<Long> processor, boolean isSocketClosing,
-                boolean addToPoller) {
+                Processor<Long> processor, boolean addToPoller) {
             processor.recycle();
             recycledProcessors.push(processor);
             if (addToPoller && proto.getEndpoint().isRunning()) {
@@ -291,7 +281,7 @@ public class Http11AprProtocol extends AbstractHttp11Protocol<Long> {
                 Poller p = ((AprEndpoint) proto.getEndpoint()).getPoller();
                 if (p == null) {
                     // Connector has been stopped
-                    release(socket, processor, true, false);
+                    release(socket, processor, false);
                 } else {
                     p.add(socket.getSocket().longValue(), -1, true, false);
                 }

==================================================
Http11NioProtocol.java
index 2acae23b36..3565c82c05 100644
--- a/java/org/apache/coyote/http11/Http11Nio2Protocol.java
+++ b/java/org/apache/coyote/http11/Http11Nio2Protocol.java
@@ -152,19 +152,9 @@ public class Http11Nio2Protocol extends AbstractHttp11JsseProtocol<Nio2Channel>
         }
 
 
-        /**
-         * Expected to be used by the handler once the processor is no longer
-         * required.
-         *
-         * @param socket
-         * @param processor
-         * @param isSocketClosing   Not used in HTTP
-         * @param addToPoller
-         */
         @Override
         public void release(SocketWrapperBase<Nio2Channel> socket,
-                Processor<Nio2Channel> processor, boolean isSocketClosing,
-                boolean addToPoller) {
+                Processor<Nio2Channel> processor, boolean addToPoller) {
             processor.recycle();
             recycledProcessors.push(processor);
             if (socket.isAsync()) {

==================================================
