ead55a4713f53beab63f95b419f5b82de77c72a4
==================================================
Review comments from kkolinko for parameter parsing improvements
==================================================
Mark Emlyn
==================================================
Sat Oct 29 16:11:02 2011 +0000
==================================================
B2CConverter.java
Review comments from kkolinko for parameter parsing improvements

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1194915 13f79535-47bb-0310-9956-ffa450edef68



==================================================
ByteChunk.java
index e1b77f42b3..25b887c380 100644
--- a/java/org/apache/tomcat/util/buf/B2CConverter.java
+++ b/java/org/apache/tomcat/util/buf/B2CConverter.java
@@ -104,6 +104,14 @@ public class B2CConverter {
     static final int BUFFER_SIZE=8192;
     char result[]=new char[BUFFER_SIZE];
 
+    /**
+     * Convert a buffer of bytes into a chars.
+     *
+     * @param bb    Input byte buffer
+     * @param cb    Output char buffer
+     * @param limit Number of bytes to convert
+     * @throws IOException
+     */
     public void convert( ByteChunk bb, CharChunk cb, int limit)
         throws IOException
     {
@@ -111,7 +119,7 @@ public class B2CConverter {
         try {
             // read from the reader
             int bbLengthBeforeRead = 0;
-            while( limit > 0 ) { // conv.ready() ) {
+            while( limit > 0 ) {
                 int size = limit < BUFFER_SIZE ? limit : BUFFER_SIZE;
                 bbLengthBeforeRead = bb.getLength();
                 int cnt=conv.read( result, 0, size );

==================================================
Parameters.java
index edcdc7fb58..07f56fbcc0 100644
--- a/java/org/apache/tomcat/util/buf/ByteChunk.java
+++ b/java/org/apache/tomcat/util/buf/ByteChunk.java
@@ -535,7 +535,7 @@ public final class ByteChunk implements Cloneable, Serializable {
         // bytes will be used. The code below is from Apache Harmony.
         CharBuffer cb;
         cb = charset.decode(ByteBuffer.wrap(buff, start, end-start));
-        return new String(cb.array());
+        return new String(cb.array(), cb.arrayOffset(), cb.length());
     }
 
     public int getInt()

==================================================
TestParameters.java
index 8270e1e55b..65a8bc704c 100644
--- a/java/org/apache/tomcat/util/http/Parameters.java
+++ b/java/org/apache/tomcat/util/http/Parameters.java
@@ -99,20 +99,18 @@ public final class Parameters {
     // Access to the current name/values, no side effect ( processing ).
     // You must explicitly call handleQueryParameters and the post methods.
 
-    // This is the original data representation ( hash of String->String[])
-
-    public void addParameterValues( String key, String[] newValues) {
-        if ( key==null ) {
+    public void addParameterValues(String key, String[] newValues) {
+        if (key == null) {
             return;
         }
         ArrayList<String> values;
         if (paramHashValues.containsKey(key)) {
-             values = paramHashValues.get(key);
+            values = paramHashValues.get(key);
+            values.ensureCapacity(values.size() + newValues.length);
         } else {
-            values = new ArrayList<String>(1);
+            values = new ArrayList<String>(newValues.length);
             paramHashValues.put(key, values);
         }
-        values.ensureCapacity(values.size() + newValues.length);
         for (String newValue : newValues) {
             values.add(newValue);
         }
@@ -173,8 +171,7 @@ public final class Parameters {
         processParameters( decodedQuery, queryStringEncoding );
     }
 
-    // incredibly inefficient data representation for parameters,
-    // until we test the new one
+
     private void addParam( String key, String value ) {
         if( key==null ) {
             return;
@@ -202,7 +199,7 @@ public final class Parameters {
     private final ByteChunk origValue=new ByteChunk();
     CharChunk tmpNameC=new CharChunk(1024);
     public static final String DEFAULT_ENCODING = "ISO-8859-1";
-    public static final Charset DEFAULT_CHARSET =
+    private static final Charset DEFAULT_CHARSET =
         Charset.forName(DEFAULT_ENCODING);
 
 
@@ -210,7 +207,7 @@ public final class Parameters {
         processParameters(bytes, start, len, getCharset(encoding));
     }
 
-    public void processParameters(byte bytes[], int start, int len,
+    private void processParameters(byte bytes[], int start, int len,
                                   Charset charset) {
 
         if(log.isDebugEnabled()) {
@@ -411,21 +408,21 @@ public final class Parameters {
         }
     }
 
-    /** Debug purpose
+    /**
+     * Debug purpose
      */
     public String paramsAsString() {
-        StringBuilder sb=new StringBuilder();
-        Enumeration<String> en= paramHashValues.keys();
-        while( en.hasMoreElements() ) {
+        StringBuilder sb = new StringBuilder();
+        Enumeration<String> en = paramHashValues.keys();
+        while (en.hasMoreElements()) {
             String k = en.nextElement();
-            sb.append( k ).append("=");
+            sb.append(k).append('=');
             ArrayList<String> values = paramHashValues.get(k);
             for(String value : values) {
-                sb.append(value).append(",");
+                sb.append(value).append(',');
             }
-            sb.append("\n");
+            sb.append('\n');
         }
         return sb.toString();
     }
-
 }

==================================================
