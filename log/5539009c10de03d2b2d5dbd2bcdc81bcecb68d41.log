5539009c10de03d2b2d5dbd2bcdc81bcecb68d41
==================================================
- Improve comet keepalive cleanup (if a read pending it is not possible to interrupt it), and do the same for async.
==================================================
Remy Maucherat
==================================================
Thu May 8 13:27:56 2014 +0000
==================================================
Http11Nio2Processor.java
- Improve comet keepalive cleanup (if a read pending it is not possible to interrupt it), and do the same for async.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1593273 13f79535-47bb-0310-9956-ffa450edef68



==================================================
InternalNio2InputBuffer.java
index 39a600a08f..06f90310c0 100644
--- a/java/org/apache/coyote/http11/Http11Nio2Processor.java
+++ b/java/org/apache/coyote/http11/Http11Nio2Processor.java
@@ -132,9 +132,13 @@ public class Http11Nio2Processor extends AbstractHttp11Processor<Nio2Channel> {
             if (keepAlive) {
                 inputBuffer.nextRequest();
                 outputBuffer.nextRequest();
-                // Following Comet processing, a read is still pending, so
-                // keep the processor associated
-                return SocketState.LONG;
+                if (((InternalNio2InputBuffer) inputBuffer).isPending()) {
+                    // Following comet processing, a read is still pending, so
+                    // keep the processor associated
+                    return SocketState.LONG;
+                } else {
+                    return SocketState.OPEN;
+                }
             } else {
                 return SocketState.CLOSED;
             }
@@ -143,6 +147,18 @@ public class Http11Nio2Processor extends AbstractHttp11Processor<Nio2Channel> {
         }
     }
 
+    @Override
+    public SocketState asyncDispatch(SocketStatus status) {
+        SocketState state = super.asyncDispatch(status);
+        if (state == SocketState.OPEN && ((InternalNio2InputBuffer) inputBuffer).isPending()) {
+            // Following async processing, a read is still pending, so
+            // keep the processor associated
+            return SocketState.LONG;
+        } else {
+            return state;
+        }
+    }
+
     @Override
     protected void registerForEvent(boolean read, boolean write) {
         if (read) {

==================================================
