af391ff5548b13ccebede4455b623ac2755928ad
==================================================
Pull up common code from the authenticate() method to reduce duplication.
==================================================
Mark Thomas
==================================================
Tue Mar 17 12:39:04 2015 +0000
==================================================
AuthenticatorBase.java
Pull up common code from the authenticate() method to reduce duplication.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1667292 13f79535-47bb-0310-9956-ffa450edef68



==================================================
BasicAuthenticator.java
index 43cacca651..a92abee21f 100644
--- a/java/org/apache/catalina/authenticator/AuthenticatorBase.java
+++ b/java/org/apache/catalina/authenticator/AuthenticatorBase.java
@@ -685,6 +685,57 @@ public abstract class AuthenticatorBase extends ValveBase implements Authenticat
             HttpServletResponse response) throws IOException;
 
 
+    /**
+     * Check to see if the user has already been authenticated earlier in the
+     * processing chain or if there is enough information available to
+     * authenticate the user without requiring further user interaction.
+     *
+     * @param request The current request
+     * @param useSSO  Should information available from SSO be used to attempt
+     *                to authenticate the current user?
+     *
+     * @return <code>true</code> if the user was authenticated via the cache,
+     *         otherwise <code>false</code>
+     */
+    protected boolean checkForCachedAuthentication(Request request, boolean useSSO) {
+
+        // Has the user already been authenticated?
+        Principal principal = request.getUserPrincipal();
+        String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE);
+        if (principal != null) {
+            if (log.isDebugEnabled()) {
+                log.debug("Already authenticated '" + principal.getName() + "'");
+            }
+            // Associate the session with any existing SSO session. Even if
+            // useSSO is false, this will ensure coordinated session
+            // invalidation at log out.
+            if (ssoId != null) {
+                associate(ssoId, request.getSessionInternal(true));
+            }
+            return true;
+        }
+
+        // Is there an SSO session against which we can try to reauthenticate?
+        if (useSSO && ssoId != null) {
+            if (log.isDebugEnabled()) {
+                log.debug("SSO Id " + ssoId + " set; attempting " +
+                          "reauthentication");
+            }
+            /* Try to reauthenticate using data cached by SSO.  If this fails,
+               either the original SSO logon was of DIGEST or SSL (which
+               we can't reauthenticate ourselves because there is no
+               cached username and password), or the realm denied
+               the user's reauthentication for some reason.
+               In either case we have to prompt the user for a logon */
+            if (reauthenticateFromSSO(ssoId, request)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+
     /**
      * Attempts reauthentication to the <code>Realm</code> using
      * the credentials included in argument <code>entry</code>.

==================================================
DigestAuthenticator.java
index c0e96d1076..a8100ccb98 100644
--- a/java/org/apache/catalina/authenticator/BasicAuthenticator.java
+++ b/java/org/apache/catalina/authenticator/BasicAuthenticator.java
@@ -63,35 +63,8 @@ public class BasicAuthenticator extends AuthenticatorBase {
     public boolean authenticate(Request request, HttpServletResponse response)
             throws IOException {
 
-        // Have we already authenticated someone?
-        Principal principal = request.getUserPrincipal();
-        String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE);
-        if (principal != null) {
-            if (log.isDebugEnabled()) {
-                log.debug("Already authenticated '" + principal.getName() + "'");
-            }
-            // Associate the session with any existing SSO session
-            if (ssoId != null) {
-                associate(ssoId, request.getSessionInternal(true));
-            }
-            return (true);
-        }
-
-        // Is there an SSO session against which we can try to reauthenticate?
-        if (ssoId != null) {
-            if (log.isDebugEnabled()) {
-                log.debug("SSO Id " + ssoId + " set; attempting " +
-                          "reauthentication");
-            }
-            /* Try to reauthenticate using data cached by SSO.  If this fails,
-               either the original SSO logon was of DIGEST or SSL (which
-               we can't reauthenticate ourselves because there is no
-               cached username and password), or the realm denied
-               the user's reauthentication for some reason.
-               In either case we have to prompt the user for a logon */
-            if (reauthenticateFromSSO(ssoId, request)) {
-                return true;
-            }
+        if (checkForCachedAuthentication(request, true)) {
+            return true;
         }
 
         // Validate any credentials already included with this request
@@ -108,7 +81,7 @@ public class BasicAuthenticator extends AuthenticatorBase {
                 String username = credentials.getUsername();
                 String password = credentials.getPassword();
 
-                principal = context.getRealm().authenticate(username, password);
+                Principal principal = context.getRealm().authenticate(username, password);
                 if (principal != null) {
                     register(request, response, principal,
                         HttpServletRequest.BASIC_AUTH, username, password);

==================================================
FormAuthenticator.java
index 14bd2ed474..1b62024233 100644
--- a/java/org/apache/catalina/authenticator/DigestAuthenticator.java
+++ b/java/org/apache/catalina/authenticator/DigestAuthenticator.java
@@ -197,48 +197,20 @@ public class DigestAuthenticator extends AuthenticatorBase {
     public boolean authenticate(Request request, HttpServletResponse response)
             throws IOException {
 
-        // Have we already authenticated someone?
-        Principal principal = request.getUserPrincipal();
-        //String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE);
-        if (principal != null) {
-            if (log.isDebugEnabled()) {
-                log.debug("Already authenticated '" + principal.getName() + "'");
-            }
-            // Associate the session with any existing SSO session in order
-            // to get coordinated session invalidation at logout
-            String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE);
-            if (ssoId != null) {
-                associate(ssoId, request.getSessionInternal(true));
-            }
-            return (true);
-        }
-
         // NOTE: We don't try to reauthenticate using any existing SSO session,
         // because that will only work if the original authentication was
         // BASIC or FORM, which are less secure than the DIGEST auth-type
         // specified for this webapp
         //
-        // Uncomment below to allow previous FORM or BASIC authentications
+        // Change to true below to allow previous FORM or BASIC authentications
         // to authenticate users for this webapp
         // TODO make this a configurable attribute (in SingleSignOn??)
-        /*
-        // Is there an SSO session against which we can try to reauthenticate?
-        if (ssoId != null) {
-            if (log.isDebugEnabled())
-                log.debug("SSO Id " + ssoId + " set; attempting " +
-                          "reauthentication");
-            // Try to reauthenticate using data cached by SSO.  If this fails,
-            // either the original SSO logon was of DIGEST or SSL (which
-            // we can't reauthenticate ourselves because there is no
-            // cached username and password), or the realm denied
-            // the user's reauthentication for some reason.
-            // In either case we have to prompt the user for a logon
-            if (reauthenticateFromSSO(ssoId, request))
-                return true;
+        if (checkForCachedAuthentication(request, false)) {
+            return true;
         }
-        */
 
         // Validate any credentials already included with this request
+        Principal principal = null;
         String authorization = request.getHeader("authorization");
         DigestInfo digestInfo = new DigestInfo(getOpaque(), getNonceValidity(),
                 getKey(), nonces, isValidateUri());

==================================================
SSLAuthenticator.java
index 29444bde0d..9bfac7eae4 100644
--- a/java/org/apache/catalina/authenticator/FormAuthenticator.java
+++ b/java/org/apache/catalina/authenticator/FormAuthenticator.java
@@ -134,40 +134,13 @@ public class FormAuthenticator
     public boolean authenticate(Request request, HttpServletResponse response)
             throws IOException {
 
-        // References to objects we will need later
-        Session session = null;
-
-        // Have we already authenticated someone?
-        Principal principal = request.getUserPrincipal();
-        String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE);
-        if (principal != null) {
-            if (log.isDebugEnabled()) {
-                log.debug("Already authenticated '" +
-                    principal.getName() + "'");
-            }
-            // Associate the session with any existing SSO session
-            if (ssoId != null) {
-                associate(ssoId, request.getSessionInternal(true));
-            }
+        if (checkForCachedAuthentication(request, true)) {
             return true;
         }
 
-        // Is there an SSO session against which we can try to reauthenticate?
-        if (ssoId != null) {
-            if (log.isDebugEnabled()) {
-                log.debug("SSO Id " + ssoId + " set; attempting " +
-                          "reauthentication");
-            }
-            // Try to reauthenticate using data cached by SSO.  If this fails,
-            // either the original SSO logon was of DIGEST or SSL (which
-            // we can't reauthenticate ourselves because there is no
-            // cached username and password), or the realm denied
-            // the user's reauthentication for some reason.
-            // In either case we have to prompt the user for a logon */
-            if (reauthenticateFromSSO(ssoId, request)) {
-                return true;
-            }
-        }
+        // References to objects we will need later
+        Session session = null;
+        Principal principal = null;
 
         // Have we authenticated this user before but have caching disabled?
         if (!cache) {

==================================================
SpnegoAuthenticator.java
index 0269ee4b9d..2d184bbb8f 100644
--- a/java/org/apache/catalina/authenticator/SSLAuthenticator.java
+++ b/java/org/apache/catalina/authenticator/SSLAuthenticator.java
@@ -49,46 +49,17 @@ public class SSLAuthenticator extends AuthenticatorBase {
     public boolean authenticate(Request request, HttpServletResponse response)
             throws IOException {
 
-        // Have we already authenticated someone?
-        Principal principal = request.getUserPrincipal();
-        //String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE);
-        if (principal != null) {
-            if (containerLog.isDebugEnabled()) {
-                containerLog.debug("Already authenticated '" + principal.getName() + "'");
-            }
-            // Associate the session with any existing SSO session in order
-            // to get coordinated session invalidation at logout
-            String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE);
-            if (ssoId != null) {
-                associate(ssoId, request.getSessionInternal(true));
-            }
-            return (true);
-        }
-
         // NOTE: We don't try to reauthenticate using any existing SSO session,
         // because that will only work if the original authentication was
-        // BASIC or FORM, which are less secure than the CLIENT_CERT auth-type
+        // BASIC or FORM, which are less secure than the CLIENT-CERT auth-type
         // specified for this webapp
         //
-        // Uncomment below to allow previous FORM or BASIC authentications
+        // Change to true below to allow previous FORM or BASIC authentications
         // to authenticate users for this webapp
         // TODO make this a configurable attribute (in SingleSignOn??)
-        /*
-        // Is there an SSO session against which we can try to reauthenticate?
-        if (ssoId != null) {
-            if (log.isDebugEnabled())
-                log.debug("SSO Id " + ssoId + " set; attempting " +
-                          "reauthentication");
-            // Try to reauthenticate using data cached by SSO.  If this fails,
-            // either the original SSO logon was of DIGEST or SSL (which
-            // we can't reauthenticate ourselves because there is no
-            // cached username and password), or the realm denied
-            // the user's reauthentication for some reason.
-            // In either case we have to prompt the user for a logon
-            if (reauthenticateFromSSO(ssoId, request))
-                return true;
+        if (checkForCachedAuthentication(request, false)) {
+            return true;
         }
-        */
 
         // Retrieve the certificate chain for this client
         if (containerLog.isDebugEnabled()) {
@@ -107,7 +78,7 @@ public class SSLAuthenticator extends AuthenticatorBase {
         }
 
         // Authenticate the specified certificate chain
-        principal = context.getRealm().authenticate(certs);
+        Principal principal = context.getRealm().authenticate(certs);
         if (principal == null) {
             if (containerLog.isDebugEnabled()) {
                 containerLog.debug("  Realm.authenticate() returned false");

==================================================
