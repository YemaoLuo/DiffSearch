075920d486ca37e0286586a9f017b4159ac63d65
==================================================
Servlet 4.0
==================================================
Mark Thomas
==================================================
Thu May 25 20:05:55 2017 +0000
==================================================
HttpServletResponse.java
Servlet 4.0
Implement writing trailer headers where the protocol supports it

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1796186 13f79535-47bb-0310-9956-ffa450edef68



==================================================
HttpServletResponseWrapper.java
index 9d406d9d7f..8e31664277 100644
--- a/java/javax/servlet/http/HttpServletResponse.java
+++ b/java/javax/servlet/http/HttpServletResponse.java
@@ -18,6 +18,8 @@ package javax.servlet.http;
 
 import java.io.IOException;
 import java.util.Collection;
+import java.util.Map;
+import java.util.function.Supplier;
 
 import javax.servlet.ServletResponse;
 
@@ -340,6 +342,25 @@ public interface HttpServletResponse extends ServletResponse {
      */
     public Collection<String> getHeaderNames();
 
+    /**
+     * Configure the supplier of the trailer headers. The supplier will be
+     * called in the scope of the thread that completes the response.
+     * <b>
+     * Trailers that don't meet the requirements of RFC 7230, section 4.1.2 will
+     * be ignored.
+     *
+     * @param supplier The supplier for the trailer headers
+     *
+     * @throws IllegalStateException if this method is called when the
+     *         underlying protocol does not support trailer headers or if using
+     *         HTTP/1.1 and the response has already been committed
+     *
+     * @since Servlet 4.0
+     */
+    public default void setTrailerFields(Supplier<Map<String, String>> supplier) {
+        // NO-OP
+    }
+
     /*
      * Server status codes; see RFC 2068.
      */

==================================================
Response.java
index 90faa6380f..0855a37a54 100644
--- a/java/javax/servlet/http/HttpServletResponseWrapper.java
+++ b/java/javax/servlet/http/HttpServletResponseWrapper.java
@@ -18,6 +18,8 @@ package javax.servlet.http;
 
 import java.io.IOException;
 import java.util.Collection;
+import java.util.Map;
+import java.util.function.Supplier;
 
 import javax.servlet.ServletResponseWrapper;
 
@@ -266,4 +268,18 @@ public class HttpServletResponseWrapper extends ServletResponseWrapper
     public Collection<String> getHeaderNames() {
         return this._getHttpServletResponse().getHeaderNames();
     }
+
+    /**
+     * {@inheritDoc}
+     * <p>
+     * The default implementation is to call
+     * {@link HttpServletResponse#setTrailerFields(Supplier)}
+     * on the wrapper {@link HttpServletResponse}.
+     *
+     * @since Servlet 4.0
+     */
+    @Override
+    public void setTrailerFields(Supplier<Map<String, String>> supplier) {
+        this._getHttpServletResponse().setTrailerFields(supplier);
+    }
 }

==================================================
ResponseFacade.java
index 637c0ba965..a26ae098cc 100644
--- a/java/org/apache/catalina/connector/Response.java
+++ b/java/org/apache/catalina/connector/Response.java
@@ -33,9 +33,11 @@ import java.util.Collection;
 import java.util.Enumeration;
 import java.util.List;
 import java.util.Locale;
+import java.util.Map;
 import java.util.TimeZone;
 import java.util.Vector;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Supplier;
 
 import javax.servlet.ServletOutputStream;
 import javax.servlet.ServletResponse;
@@ -1152,6 +1154,12 @@ public class Response implements HttpServletResponse {
     }
 
 
+    @Override
+    public void setTrailerFields(Supplier<Map<String, String>> supplier) {
+        getCoyoteResponse().setTrailerFields(supplier);
+    }
+
+
     /**
      * Encode the session identifier associated with this response
      * into the specified redirect URL, if necessary.

==================================================
AbstractProcessor.java
index 4656076a00..2efb02fe0e 100644
--- a/java/org/apache/catalina/connector/ResponseFacade.java
+++ b/java/org/apache/catalina/connector/ResponseFacade.java
@@ -24,6 +24,8 @@ import java.security.PrivilegedActionException;
 import java.security.PrivilegedExceptionAction;
 import java.util.Collection;
 import java.util.Locale;
+import java.util.Map;
+import java.util.function.Supplier;
 
 import javax.servlet.ServletOutputStream;
 import javax.servlet.http.Cookie;
@@ -640,4 +642,10 @@ public class ResponseFacade implements HttpServletResponse {
     public Collection<String> getHeaders(String name) {
         return response.getHeaders(name);
     }
+
+
+    @Override
+    public void setTrailerFields(Supplier<Map<String, String>> supplier) {
+        response.setTrailerFields(supplier);
+    }
 }

==================================================
ActionCode.java
index 6d9d0635a1..57d44e8bc9 100644
--- a/java/org/apache/coyote/AbstractProcessor.java
+++ b/java/org/apache/coyote/AbstractProcessor.java
@@ -492,6 +492,11 @@ public abstract class AbstractProcessor extends AbstractProcessorLight implement
             result.set(isTrailerFieldsReady());
             break;
         }
+        case IS_TRAILER_FIELDS_SUPPORTED: {
+            AtomicBoolean result = (AtomicBoolean) param;
+            result.set(isTrailerFieldsSupported());
+            break;
+        }
         }
     }
 
@@ -769,6 +774,18 @@ public abstract class AbstractProcessor extends AbstractProcessorLight implement
     protected abstract boolean isTrailerFieldsReady();
 
 
+    /**
+     * Protocols that support trailer fields should override this method and
+     * return {@code true}.
+     *
+     * @return {@code true} if trailer fields are supported by this processor,
+     *         otherwise {@code false}.
+     */
+    protected boolean isTrailerFieldsSupported() {
+        return false;
+    }
+
+
     /**
      * Flush any pending writes. Used during non-blocking writes to flush any
      * remaining data from a previous incomplete write.

==================================================
Response.java
index 7883f74e5f..8c2e926f4b 100644
--- a/java/org/apache/coyote/LocalStrings.properties
+++ b/java/org/apache/coyote/LocalStrings.properties
@@ -49,5 +49,6 @@ request.readListenerSet=The non-blocking read listener has already been set
 response.encoding.invalid=The encoding [{0}] is not recognised by the JRE
 response.notAsync=It is only valid to switch to non-blocking IO within async processing or HTTP upgrade processing
 response.notNonBlocking=It is invalid to call isReady() when the response has not been put into non-blocking mode
+response.noTrailers.notSupported=A trailer fields supplier may not be set for this response. Either the underlying protocol does not support trailer fields or the protocol requires that the supplier is set before the response is committed
 response.nullWriteListener=The listener passed to setWriteListener() may not be null
 response.writeListenerSet=The non-blocking write listener has already been set

==================================================
Http11OutputBuffer.java
index 257bd3caf8..7559a92979 100644
--- a/java/org/apache/coyote/Response.java
+++ b/java/org/apache/coyote/Response.java
@@ -22,7 +22,9 @@ import java.io.UnsupportedEncodingException;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
 import java.util.Locale;
+import java.util.Map;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.Supplier;
 
 import javax.servlet.WriteListener;
 
@@ -78,6 +80,8 @@ public final class Response {
     final MimeHeaders headers = new MimeHeaders();
 
 
+    private Supplier<Map<String,String>> trailerFieldsSupplier = null;
+
     /**
      * Associated output buffer.
      */
@@ -322,6 +326,22 @@ public final class Response {
     }
 
 
+    public void setTrailerFields(Supplier<Map<String, String>> supplier) {
+        AtomicBoolean trailerFieldsSupported = new AtomicBoolean(false);
+        action(ActionCode.IS_TRAILER_FIELDS_SUPPORTED, trailerFieldsSupported);
+        if (!trailerFieldsSupported.get()) {
+            throw new IllegalStateException(sm.getString("response.noTrailers.notSupported"));
+        }
+
+        this.trailerFieldsSupplier = supplier;
+    }
+
+
+    public Supplier<Map<String, String>> getTrailerFields() {
+        return trailerFieldsSupplier;
+    }
+
+
     /**
      * Set internal fields for special header names.
      * Called from set/addHeader.
@@ -530,6 +550,7 @@ public final class Response {
         commitTime = -1;
         errorException = null;
         headers.clear();
+        trailerFieldsSupplier = null;
         // Servlet 3.1 non-blocking write listener
         listener = null;
         fireListener = false;

==================================================
Http11Processor.java
index a12d11f264..4d02c3e628 100644
--- a/java/org/apache/coyote/http11/Http11OutputBuffer.java
+++ b/java/org/apache/coyote/http11/Http11OutputBuffer.java
@@ -524,6 +524,16 @@ public class Http11OutputBuffer implements OutputBuffer {
     }
 
 
+    boolean isChunking() {
+        for (int i = 0; i < lastActiveFilter; i++) {
+            if (activeFilters[i] == filterLibrary[Constants.CHUNKED_FILTER]) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+
     // ------------------------------------------ SocketOutputBuffer Inner Class
 
     /**

==================================================
ChunkedOutputFilter.java
index a16ddaef2e..1c6784db80 100644
--- a/java/org/apache/coyote/http11/Http11Processor.java
+++ b/java/org/apache/coyote/http11/Http11Processor.java
@@ -900,23 +900,25 @@ public class Http11Processor extends AbstractProcessor {
 
         long contentLength = response.getContentLengthLong();
         boolean connectionClosePresent = false;
-        if (contentLength != -1) {
+        if (http11 && response.getTrailerFields() != null) {
+            // If trailer fields are set, always use chunking
+            outputBuffer.addActiveFilter(outputFilters[Constants.CHUNKED_FILTER]);
+            contentDelimitation = true;
+            headers.addValue(Constants.TRANSFERENCODING).setString(Constants.CHUNKED);
+        } else if (contentLength != -1) {
             headers.setValue("Content-Length").setLong(contentLength);
-            outputBuffer.addActiveFilter
-                (outputFilters[Constants.IDENTITY_FILTER]);
+            outputBuffer.addActiveFilter(outputFilters[Constants.IDENTITY_FILTER]);
             contentDelimitation = true;
         } else {
             // If the response code supports an entity body and we're on
             // HTTP 1.1 then we chunk unless we have a Connection: close header
             connectionClosePresent = isConnectionClose(headers);
-            if (entityBody && http11 && !connectionClosePresent) {
-                outputBuffer.addActiveFilter
-                    (outputFilters[Constants.CHUNKED_FILTER]);
+            if (http11 && entityBody && !connectionClosePresent) {
+                outputBuffer.addActiveFilter(outputFilters[Constants.CHUNKED_FILTER]);
                 contentDelimitation = true;
                 headers.addValue(Constants.TRANSFERENCODING).setString(Constants.CHUNKED);
             } else {
-                outputBuffer.addActiveFilter
-                    (outputFilters[Constants.IDENTITY_FILTER]);
+                outputBuffer.addActiveFilter(outputFilters[Constants.IDENTITY_FILTER]);
             }
         }
 
@@ -1317,6 +1319,24 @@ public class Http11Processor extends AbstractProcessor {
     }
 
 
+    @Override
+    protected boolean isTrailerFieldsSupported() {
+        // Request must be HTTP/1.1 to support trailer fields
+        if (!http11) {
+            return false;
+        }
+
+        // If the response is not yet committed, chunked encoding can be used
+        // and the trailer fields sent
+        if (!response.isCommitted()) {
+            return true;
+        }
+
+        // Response has been committed - need to see if chunked is being used
+        return outputBuffer.isChunking();
+    }
+
+
     /**
      * Trigger sendfile processing if required.
      *

==================================================
Http2AsyncUpgradeHandler.java
index 1285bc9127..1612b0f11f 100644
--- a/java/org/apache/coyote/http11/filters/ChunkedOutputFilter.java
+++ b/java/org/apache/coyote/http11/filters/ChunkedOutputFilter.java
@@ -17,12 +17,20 @@
 package org.apache.coyote.http11.filters;
 
 import java.io.IOException;
+import java.io.OutputStreamWriter;
 import java.nio.ByteBuffer;
+import java.nio.charset.StandardCharsets;
+import java.util.HashSet;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Set;
+import java.util.function.Supplier;
 
 import org.apache.coyote.OutputBuffer;
 import org.apache.coyote.Response;
 import org.apache.coyote.http11.OutputFilter;
 import org.apache.tomcat.util.buf.HexUtils;
+import org.apache.tomcat.util.http.fileupload.ByteArrayOutputStream;
 
 /**
  * Chunked output filter.
@@ -31,9 +39,30 @@ import org.apache.tomcat.util.buf.HexUtils;
  */
 public class ChunkedOutputFilter implements OutputFilter {
 
+    private static final byte[] LAST_CHUNK_BYTES = {(byte) '0', (byte) '\r', (byte) '\n'};
+    private static final byte[] CRLF_BYTES = {(byte) '\r', (byte) '\n'};
     private static final byte[] END_CHUNK_BYTES =
         {(byte) '0', (byte) '\r', (byte) '\n', (byte) '\r', (byte) '\n'};
 
+    private static final Set<String> disallowedTrailerFieldNames = new HashSet<>();
+
+    static {
+        // Always add these in lower case
+        disallowedTrailerFieldNames.add("age");
+        disallowedTrailerFieldNames.add("cache-control");
+        disallowedTrailerFieldNames.add("content-length");
+        disallowedTrailerFieldNames.add("content-encoding");
+        disallowedTrailerFieldNames.add("content-range");
+        disallowedTrailerFieldNames.add("content-type");
+        disallowedTrailerFieldNames.add("date");
+        disallowedTrailerFieldNames.add("expires");
+        disallowedTrailerFieldNames.add("location");
+        disallowedTrailerFieldNames.add("retry-after");
+        disallowedTrailerFieldNames.add("trailer");
+        disallowedTrailerFieldNames.add("transfer-encoding");
+        disallowedTrailerFieldNames.add("vary");
+        disallowedTrailerFieldNames.add("warning");
+    }
 
     /**
      * Next buffer in the pipeline.
@@ -47,12 +76,17 @@ public class ChunkedOutputFilter implements OutputFilter {
     protected final ByteBuffer chunkHeader = ByteBuffer.allocate(10);
 
 
+    protected final ByteBuffer lastChunk = ByteBuffer.wrap(LAST_CHUNK_BYTES);
+    protected final ByteBuffer crlfChunk = ByteBuffer.wrap(CRLF_BYTES);
     /**
      * End chunk.
      */
     protected final ByteBuffer endChunk = ByteBuffer.wrap(END_CHUNK_BYTES);
 
 
+    private Response response;
+
+
     public ChunkedOutputFilter() {
         chunkHeader.put(8, (byte) '\r');
         chunkHeader.put(9, (byte) '\n');
@@ -112,7 +146,7 @@ public class ChunkedOutputFilter implements OutputFilter {
      */
     @Override
     public void setResponse(Response response) {
-        // NOOP: No need for parameters from response in this filter
+        this.response = response;
     }
 
 
@@ -132,9 +166,40 @@ public class ChunkedOutputFilter implements OutputFilter {
     @Override
     public long end() throws IOException {
 
-        // Write end chunk
-        buffer.doWrite(endChunk);
-        endChunk.position(0).limit(endChunk.capacity());
+        Supplier<Map<String,String>> trailerFieldsSupplier = response.getTrailerFields();
+        Map<String,String> trailerFields = null;
+
+        if (trailerFieldsSupplier != null) {
+            trailerFields = trailerFieldsSupplier.get();
+        }
+
+        if (trailerFields == null) {
+            // Write end chunk
+            buffer.doWrite(endChunk);
+            endChunk.position(0).limit(endChunk.capacity());
+        } else {
+            buffer.doWrite(lastChunk);
+            lastChunk.position(0).limit(lastChunk.capacity());
+
+           ByteArrayOutputStream baos = new ByteArrayOutputStream(1024);
+           OutputStreamWriter osw = new OutputStreamWriter(baos, StandardCharsets.ISO_8859_1);
+            for (Map.Entry<String,String> trailerField : trailerFields.entrySet()) {
+                // Ignore disallowed headers
+                if (disallowedTrailerFieldNames.contains(
+                        trailerField.getKey().toLowerCase(Locale.ENGLISH))) {
+                    continue;
+                }
+                osw.write(trailerField.getKey());
+                osw.write(':');
+                osw.write(trailerField.getValue());
+                osw.write("\r\n");
+            }
+            osw.close();
+            buffer.doWrite(ByteBuffer.wrap(baos.toByteArray()));
+
+            buffer.doWrite(crlfChunk);
+            crlfChunk.position(0).limit(crlfChunk.capacity());
+        }
 
         return 0;
     }
@@ -145,6 +210,6 @@ public class ChunkedOutputFilter implements OutputFilter {
      */
     @Override
     public void recycle() {
-        // NOOP: Nothing to recycle
+        response = null;
     }
 }

==================================================
Http2UpgradeHandler.java
index 7fb26b1ced..3932884b59 100644
--- a/java/org/apache/coyote/http2/Http2AsyncUpgradeHandler.java
+++ b/java/org/apache/coyote/http2/Http2AsyncUpgradeHandler.java
@@ -136,6 +136,9 @@ public class Http2AsyncUpgradeHandler extends Http2UpgradeHandler {
     void writeHeaders(Stream stream, int pushedStreamId, MimeHeaders mimeHeaders,
             boolean endOfStream, int payloadSize) throws IOException {
         doWriteHeaders(stream, pushedStreamId, mimeHeaders, endOfStream, payloadSize);
+        if (endOfStream) {
+            stream.sentEndOfStream();
+        }
     }
 
 

==================================================
Stream.java
index afa882a5e5..e17008413c 100644
--- a/java/org/apache/coyote/http2/LocalStrings.properties
+++ b/java/org/apache/coyote/http2/LocalStrings.properties
@@ -143,7 +143,7 @@ upgradeHandler.windowSizeTooBig=Connection [{0}], Stream [{1}], Window size too
 upgradeHandler.windowSizeReservationInterrupted=Connection [{0}], Stream [{1}], reservation for [{2}] bytes
 upgradeHandler.writeBody=Connection [{0}], Stream [{1}], Data length [{2}]
 upgradeHandler.writeHeaders=Connection [{0}], Stream [{1}]
-upgradeHandler.writePushHeaders=Connection [{0}], Stream [{1}], Pushed stream [{2}]
+upgradeHandler.writePushHeaders=Connection [{0}], Stream [{1}], Pushed stream [{2}], EndOfStream [{3}]
 
 writeStateMachine.endWrite.ise=It is illegal to specify [{0}] for the new state once a write has completed
 writeStateMachine.ise=It is illegal to call [{0}()] in state [{1}]
\ No newline at end of file

==================================================
StreamProcessor.java
index 0a0e208f0c..2477f11a82 100644
--- a/java/org/apache/coyote/http2/Stream.java
+++ b/java/org/apache/coyote/http2/Stream.java
@@ -22,8 +22,11 @@ import java.nio.charset.StandardCharsets;
 import java.security.AccessController;
 import java.security.PrivilegedActionException;
 import java.security.PrivilegedExceptionAction;
+import java.util.Collections;
 import java.util.Iterator;
 import java.util.Locale;
+import java.util.Map;
+import java.util.function.Supplier;
 
 import org.apache.coyote.ActionCode;
 import org.apache.coyote.CloseNowException;
@@ -35,6 +38,7 @@ import org.apache.coyote.http2.HpackDecoder.HeaderEmitter;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.buf.ByteChunk;
+import org.apache.tomcat.util.buf.MessageBytes;
 import org.apache.tomcat.util.http.FastHttpDateFormat;
 import org.apache.tomcat.util.http.MimeHeaders;
 import org.apache.tomcat.util.net.ApplicationBufferHandler;
@@ -392,11 +396,42 @@ class Stream extends AbstractStream implements HeaderEmitter {
 
     final void writeHeaders() throws IOException {
         prepareHeaders(coyoteResponse);
-        boolean endOfStream = getOutputBuffer().hasNoBody();
+        boolean endOfStream = getOutputBuffer().hasNoBody() &&
+                coyoteResponse.getTrailerFields() == null;
         // TODO: Is 1k the optimal value?
         handler.writeHeaders(this, 0, coyoteResponse.getMimeHeaders(), endOfStream, 1024);
     }
 
+
+    final void writeTrailers() throws IOException {
+        Supplier<Map<String,String>> supplier = coyoteResponse.getTrailerFields();
+        if (supplier == null) {
+            // No supplier was set, end of stream will already have been sent
+            return;
+        }
+
+        // We can re-use the MimeHeaders from the response since they have
+        // already been processed by the encoder at this point
+        MimeHeaders mimeHeaders = coyoteResponse.getMimeHeaders();
+        mimeHeaders.recycle();
+
+        Map<String,String> headerMap = supplier.get();
+        if (headerMap == null) {
+            headerMap = Collections.emptyMap();
+        }
+
+        // Copy the contents of the Map to the MimeHeaders
+        // TODO: Is there benefit in refactoring this? Is MimeHeaders too
+        //       heavyweight? Can we reduce the copy/conversions?
+        for (Map.Entry<String, String> headerEntry : headerMap.entrySet()) {
+            MessageBytes mb = mimeHeaders.addValue(headerEntry.getKey());
+            mb.setString(headerEntry.getValue());
+        }
+
+        handler.writeHeaders(this, 0, mimeHeaders, true, 1024);
+    }
+
+
     final void writeAck() throws IOException {
         // TODO: Is 64 too big? Just the status header with compression
         handler.writeHeaders(this, 0, ACK_HEADERS, false, 64);
@@ -586,12 +621,17 @@ class Stream extends AbstractStream implements HeaderEmitter {
     }
 
 
-    public boolean isTrailerFieldsReady() {
+    boolean isTrailerFieldsReady() {
         // Once EndOfStream has been received, canRead will be false
         return !state.canRead();
     }
 
 
+    boolean isTrailerFieldsSupported() {
+        return !getOutputBuffer().endOfStreamSent;
+    }
+
+
     private static void push(final Http2UpgradeHandler handler, final Request request,
             final Stream stream) throws IOException {
         if (org.apache.coyote.Constants.IS_SECURITY_ENABLED) {
@@ -716,7 +756,8 @@ class Stream extends AbstractStream implements HeaderEmitter {
                 if (closed && !endOfStreamSent) {
                     // Handling this special case here is simpler than trying
                     // to modify the following code to handle it.
-                    handler.writeBody(Stream.this, buffer, 0, true);
+                    handler.writeBody(Stream.this, buffer, 0,
+                            coyoteResponse.getTrailerFields() == null);
                 }
                 // Buffer is empty. Nothing to do.
                 return false;
@@ -735,7 +776,8 @@ class Stream extends AbstractStream implements HeaderEmitter {
                                 handler.reserveWindowSize(Stream.this, streamReservation);
                     // Do the write
                     handler.writeBody(Stream.this, buffer, connectionReservation,
-                            !writeInProgress && closed && left == connectionReservation);
+                            !writeInProgress && closed && left == connectionReservation &&
+                            coyoteResponse.getTrailerFields() == null);
                     streamReservation -= connectionReservation;
                     left -= connectionReservation;
                 }
@@ -760,6 +802,7 @@ class Stream extends AbstractStream implements HeaderEmitter {
         final void close() throws IOException {
             closed = true;
             flushData();
+            writeTrailers();
         }
 
         /**

==================================================
TesterHttpServletResponse.java
index 1df6d00e88..909e30ff6e 100644
--- a/java/org/apache/coyote/http2/StreamProcessor.java
+++ b/java/org/apache/coyote/http2/StreamProcessor.java
@@ -190,7 +190,7 @@ class StreamProcessor extends AbstractProcessor {
         synchronized (this) {
             /*
              * TODO Check if this sync is necessary.
-             *      Compare with superrclass that uses SocketWrapper
+             *      Compare with superclass that uses SocketWrapper
              */
             while (dispatches != null && dispatches.hasNext()) {
                 DispatchType dispatchType = dispatches.next();
@@ -223,6 +223,12 @@ class StreamProcessor extends AbstractProcessor {
     }
 
 
+    @Override
+    protected boolean isTrailerFieldsSupported() {
+        return stream.isTrailerFieldsSupported();
+    }
+
+
     @Override
     public final void recycle() {
         // StreamProcessor instances are not re-used.

==================================================
TestStream.java
index 9357dd1881..5bbefad4bc 100644
--- a/test/org/apache/catalina/filters/TesterHttpServletResponse.java
+++ b/test/org/apache/catalina/filters/TesterHttpServletResponse.java
@@ -24,6 +24,8 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 import java.util.Locale;
+import java.util.Map;
+import java.util.function.Supplier;
 
 import javax.servlet.ServletOutputStream;
 import javax.servlet.ServletResponse;
@@ -247,4 +249,6 @@ public class TesterHttpServletResponse implements HttpServletResponse {
     public void setStatus(int status, String message) {/* NOOP */}
     @Override
     public void setContentLengthLong(long length) {/* NOOP */}
+    @Override
+    public void setTrailerFields(Supplier<Map<String, String>> supplier) { /* NOOP */ }
 }

==================================================
ResponseTrailers.java
index 4cd571f542..c2e7233d65 100644
--- a/webapps/docs/changelog.xml
+++ b/webapps/docs/changelog.xml
@@ -61,6 +61,10 @@
         <bug>61101</bug>: CORS filter should set Vary header in response.
         Submitted by Rick Riemer. (remm)
       </fix>
+      <update>
+        Update the Servlet 4.0 implementation to add support for setting
+        trailer fields for HTTP responses. (markt)
+      </update>
     </changelog>
   </subsection>
   <subsection name="Coyote">

==================================================
