bc8ecc002255166414c9e76267c062c641081f2f
==================================================
Avoid doing anything if the endpoint is not running (avoids possible NPE with the caches (?) ) and create caches first in start (just in case).
==================================================
Remy Maucherat
==================================================
Tue Jul 8 11:55:24 2014 +0000
==================================================
Nio2Endpoint.java
Avoid doing anything if the endpoint is not running (avoids possible NPE with the caches (?) ) and create caches first in start (just in case).
Note: I still don't see much real benefit in these caches, and their configuration is even more questionable (but it is there and documented).

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1608737 13f79535-47bb-0310-9956-ffa450edef68



==================================================
NioEndpoint.java
index 49fb7d26d8..a653409dc9 100644
--- a/java/org/apache/tomcat/util/net/Nio2Endpoint.java
+++ b/java/org/apache/tomcat/util/net/Nio2Endpoint.java
@@ -345,11 +345,6 @@ public class Nio2Endpoint extends AbstractEndpoint<Nio2Channel> {
             running = true;
             paused = false;
 
-            // Create worker collection
-            if ( getExecutor() == null ) {
-                createExecutor();
-            }
-
             if (useCaches) {
                 processorCache = new SynchronizedStack<>(SynchronizedStack.DEFAULT_SIZE,
                         socketProperties.getProcessorCache());
@@ -359,6 +354,11 @@ public class Nio2Endpoint extends AbstractEndpoint<Nio2Channel> {
                         socketProperties.getBufferPool());
             }
 
+            // Create worker collection
+            if ( getExecutor() == null ) {
+                createExecutor();
+            }
+
             initializeConnectionLatch();
             startAcceptorThreads();
 
@@ -384,30 +384,30 @@ public class Nio2Endpoint extends AbstractEndpoint<Nio2Channel> {
             running = false;
             getAsyncTimeout().stop();
             unlockAccept();
-        }
-        // Use the executor to avoid binding the main thread if something bad
-        // occurs and unbind will also wait for a bit for it to complete
-        getExecutor().execute(new Runnable() {
-            @Override
-            public void run() {
-                // Timeout any pending async request
-                for (SocketWrapper<Nio2Channel> socket : waitingRequests) {
-                    processSocket(socket, SocketStatus.TIMEOUT, false);
-                }
-                // Then close all active connections if any remains
-                try {
-                    handler.closeAll();
-                } catch (Throwable t) {
-                    ExceptionUtils.handleThrowable(t);
-                } finally {
-                    allClosed = true;
+            // Use the executor to avoid binding the main thread if something bad
+            // occurs and unbind will also wait for a bit for it to complete
+            getExecutor().execute(new Runnable() {
+                @Override
+                public void run() {
+                    // Timeout any pending async request
+                    for (SocketWrapper<Nio2Channel> socket : waitingRequests) {
+                        processSocket(socket, SocketStatus.TIMEOUT, false);
+                    }
+                    // Then close all active connections if any remains
+                    try {
+                        handler.closeAll();
+                    } catch (Throwable t) {
+                        ExceptionUtils.handleThrowable(t);
+                    } finally {
+                        allClosed = true;
+                    }
                 }
+            });
+            if (useCaches) {
+                socketWrapperCache.clear();
+                nioChannels.clear();
+                processorCache.clear();
             }
-        });
-        if (useCaches) {
-            socketWrapperCache.clear();
-            nioChannels.clear();
-            processorCache.clear();
         }
     }
 

==================================================
