71bec45668949c016d34093e6a3784412361d64e
==================================================
Java 7 <>
==================================================
Mark Emlyn
==================================================
Fri Oct 26 21:28:07 2012 +0000
==================================================
ConnectionPool.java
Java 7 <>

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1402669 13f79535-47bb-0310-9956-ffa450edef68



==================================================
FairBlockingQueue.java
index a95f6a5912..47a8d90dae 100644
--- a/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java
+++ b/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java
@@ -440,16 +440,16 @@ public class ConnectionPool {
         }
 
         //make space for 10 extra in case we flow over a bit
-        busy = new ArrayBlockingQueue<PooledConnection>(properties.getMaxActive(),false);
+        busy = new ArrayBlockingQueue<>(properties.getMaxActive(),false);
         //busy = new FairBlockingQueue<PooledConnection>();
         //make space for 10 extra in case we flow over a bit
         if (properties.isFairQueue()) {
-            idle = new FairBlockingQueue<PooledConnection>();
+            idle = new FairBlockingQueue<>();
             //idle = new MultiLockFairBlockingQueue<PooledConnection>();
             //idle = new LinkedTransferQueue<PooledConnection>();
             //idle = new ArrayBlockingQueue<PooledConnection>(properties.getMaxActive(),false);
         } else {
-            idle = new ArrayBlockingQueue<PooledConnection>(properties.getMaxActive(),properties.isFairQueue());
+            idle = new ArrayBlockingQueue<>(properties.getMaxActive(),properties.isFairQueue());
         }
 
         initializePoolCleaner(properties);
@@ -1271,7 +1271,7 @@ public class ConnectionPool {
 
 
     private static volatile Timer poolCleanTimer = null;
-    private static HashSet<PoolCleaner> cleaners = new HashSet<PoolCleaner>();
+    private static HashSet<PoolCleaner> cleaners = new HashSet<>();
 
     private static synchronized void registerCleaner(PoolCleaner cleaner) {
         unregisterCleaner(cleaner);

==================================================
MultiLockFairBlockingQueue.java
index 8511c2aac5..2ea76c9234 100644
--- a/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java
+++ b/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java
@@ -77,8 +77,8 @@ public class FairBlockingQueue<E> implements BlockingQueue<E> {
      * Creates a new fair blocking queue.
      */
     public FairBlockingQueue() {
-        items = new LinkedList<E>();
-        waiters = new LinkedList<ExchangeCountDownLatch<E>>();
+        items = new LinkedList<>();
+        waiters = new LinkedList<>();
     }
 
     //------------------------------------------------------------------
@@ -142,7 +142,7 @@ public class FairBlockingQueue<E> implements BlockingQueue<E> {
             result = items.poll();
             if (result==null && timeout>0) {
                 //the queue is empty we will wait for an object
-                ExchangeCountDownLatch<E> c = new ExchangeCountDownLatch<E>(1);
+                ExchangeCountDownLatch<E> c = new ExchangeCountDownLatch<>(1);
                 //add to the bottom of the wait list
                 waiters.addLast(c);
                 //unlock the global lock
@@ -184,15 +184,15 @@ public class FairBlockingQueue<E> implements BlockingQueue<E> {
             E item = items.poll();
             if (item==null) {
                 //queue is empty, add ourselves as waiters
-                ExchangeCountDownLatch<E> c = new ExchangeCountDownLatch<E>(1);
+                ExchangeCountDownLatch<E> c = new ExchangeCountDownLatch<>(1);
                 waiters.addLast(c);
                 lock.unlock();
                 //return a future that will wait for the object
-                result = new ItemFuture<E>(c);
+                result = new ItemFuture<>(c);
             } else {
                 lock.unlock();
                 //return a future with the item
-                result = new ItemFuture<E>(item);
+                result = new ItemFuture<>(item);
             }
             error = false;
         } finally {

==================================================
PooledConnection.java
index e7d87ceefd..cb8a260f69 100644
--- a/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java
+++ b/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java
@@ -84,8 +84,8 @@ public class MultiLockFairBlockingQueue<E> implements BlockingQueue<E> {
         items = new LinkedList[LOCK_COUNT];
         waiters = new LinkedList[LOCK_COUNT];
         for (int i=0; i<LOCK_COUNT; i++) {
-            items[i] = new LinkedList<E>();
-            waiters[i] = new LinkedList<ExchangeCountDownLatch<E>>();
+            items[i] = new LinkedList<>();
+            waiters[i] = new LinkedList<>();
             locks[i] = new ReentrantLock(false);
         }
     }
@@ -152,7 +152,7 @@ public class MultiLockFairBlockingQueue<E> implements BlockingQueue<E> {
             result = items[idx].poll();
             if (result==null && timeout>0) {
                 //the queue is empty we will wait for an object
-                ExchangeCountDownLatch<E> c = new ExchangeCountDownLatch<E>(1);
+                ExchangeCountDownLatch<E> c = new ExchangeCountDownLatch<>(1);
                 //add to the bottom of the wait list
                 waiters[idx].addLast(c);
                 //unlock the global lock
@@ -195,15 +195,15 @@ public class MultiLockFairBlockingQueue<E> implements BlockingQueue<E> {
             E item = items[idx].poll();
             if (item==null) {
                 //queue is empty, add ourselves as waiters
-                ExchangeCountDownLatch<E> c = new ExchangeCountDownLatch<E>(1);
+                ExchangeCountDownLatch<E> c = new ExchangeCountDownLatch<>(1);
                 waiters[idx].addLast(c);
                 lock.unlock();
                 //return a future that will wait for the object
-                result = new ItemFuture<E>(c);
+                result = new ItemFuture<>(c);
             } else {
                 lock.unlock();
                 //return a future with the item
-                result = new ItemFuture<E>(item);
+                result = new ItemFuture<>(item);
             }
             error = false;
         } finally {
@@ -521,7 +521,7 @@ public class MultiLockFairBlockingQueue<E> implements BlockingQueue<E> {
         E element = null;
 
         public FairIterator() {
-            ArrayList<E> list = new ArrayList<E>(MultiLockFairBlockingQueue.this.size());
+            ArrayList<E> list = new ArrayList<>(MultiLockFairBlockingQueue.this.size());
             for (int idx=0; idx<LOCK_COUNT; idx++) {
                 final ReentrantLock lock = MultiLockFairBlockingQueue.this.locks[idx];
                 lock.lock();

==================================================
ConnectionPool.java
index 2f9c721725..410a74ac4d 100644
--- a/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PooledConnection.java
+++ b/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PooledConnection.java
@@ -102,7 +102,7 @@ public class PooledConnection {
      */
     protected ConnectionPool parent;
 
-    private HashMap<Object, Object> attributes = new HashMap<Object, Object>();
+    private HashMap<Object, Object> attributes = new HashMap<>();
 
     private volatile long connectionVersion=0;
 

==================================================
