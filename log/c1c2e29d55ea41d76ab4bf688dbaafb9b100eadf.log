c1c2e29d55ea41d76ab4bf688dbaafb9b100eadf
==================================================
Refactor parameter parsing for performance.
==================================================
Mark Emlyn
==================================================
Thu Oct 27 17:34:58 2011 +0000
==================================================
Connector.java
Refactor parameter parsing for performance.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1189882 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Request.java
index 7227a35265..396600f721 100644
--- a/java/org/apache/catalina/connector/Connector.java
+++ b/java/org/apache/catalina/connector/Connector.java
@@ -162,6 +162,13 @@ public class Connector extends LifecycleMBeanBase  {
         StringManager.getManager(Constants.Package);
 
 
+    /**
+     * The maximum number of parameters (GET plus POST) which will be
+     * automatically parsed by the container. 10000 by default. A value of less
+     * than 0 means no limit.
+     */
+    protected int maxParameterCount = 10000;
+
     /**
      * Maximum size of a POST which will be automatically parsed by the
      * container. 2MB by default.
@@ -381,14 +388,34 @@ public class Connector extends LifecycleMBeanBase  {
     }
 
 
-     /**
-      * Return the mapper.
-      */
-     public Mapper getMapper() {
+    /**
+     * Return the mapper.
+     */
+    public Mapper getMapper() {
+        return (mapper);
+    }
 
-         return (mapper);
 
-     }
+    /**
+     * Return the maximum number of parameters (GET plus POST) that will be
+     * automatically parsed by the container. A value of less than 0 means no
+     * limit.
+     */
+    public int getMaxParameterCount() {
+        return maxParameterCount;
+    }
+
+
+    /**
+     * Set the maximum number of parameters (GET plus POST) that will be
+     * automatically parsed by the container. A value of less than 0 means no
+     * limit.
+     *
+     * @param maxParameterCount The new setting
+     */
+    public void setMaxParameterCount(int maxParameterCount) {
+        this.maxParameterCount = maxParameterCount;
+    }
 
 
     /**

==================================================
ByteChunk.java
index 3b72148417..29be89966c 100644
--- a/java/org/apache/catalina/connector/mbeans-descriptors.xml
+++ b/java/org/apache/catalina/connector/mbeans-descriptors.xml
@@ -81,6 +81,10 @@
           description="Maximum number of Keep-Alive requests to honor per connection"
                  type="int"/>
 
+    <attribute   name="maxParameterCount"
+          description="The maximum number of parameters (GET plus POST) which will be automatically parsed by the container. 10000 by default. A value of less than 0 means no limit."
+                 type="int"/>
+
     <attribute   name="maxPostSize"
           description="Maximum size in bytes of a POST which will be handled by the servlet API provided features"
                  type="int"/>

==================================================
MessageBytes.java
index 6771b84196..1680851980 100644
--- a/java/org/apache/tomcat/util/buf/ByteChunk.java
+++ b/java/org/apache/tomcat/util/buf/ByteChunk.java
@@ -18,6 +18,10 @@ package org.apache.tomcat.util.buf;
 
 import java.io.IOException;
 import java.io.Serializable;
+import java.io.UnsupportedEncodingException;
+import java.nio.ByteBuffer;
+import java.nio.CharBuffer;
+import java.nio.charset.Charset;
 
 /*
  * In a server it is very important to be able to operate on
@@ -96,7 +100,15 @@ public final class ByteChunk implements Cloneable, Serializable {
         as most standards seem to converge, but the servlet API requires
         8859_1, and this object is used mostly for servlets.
     */
-    public static final String DEFAULT_CHARACTER_ENCODING="ISO-8859-1";
+    public static Charset DEFAULT_CHARSET = null;
+
+    static {
+        try {
+            DEFAULT_CHARSET = B2CConverter.getCharset("ISO-8859-1");
+        } catch (UnsupportedEncodingException e) {
+            // Should never happen since all JVMs must support ISO-8859-1
+        }
+    }
 
     // byte[]
     private byte[] buff;
@@ -104,7 +116,7 @@ public final class ByteChunk implements Cloneable, Serializable {
     private int start=0;
     private int end;
 
-    private String enc;
+    private Charset charset;
 
     private boolean isSet=false; // XXX
 
@@ -145,7 +157,7 @@ public final class ByteChunk implements Cloneable, Serializable {
      */
     public void recycle() {
         //        buff = null;
-        enc=null;
+        charset=null;
         start=0;
         end=0;
         isSet=false;
@@ -185,14 +197,15 @@ public final class ByteChunk implements Cloneable, Serializable {
         this.optimizedWrite = optimizedWrite;
     }
 
-    public void setEncoding( String enc ) {
-        this.enc=enc;
+    public void setCharset(Charset charset) {
+        this.charset = charset;
     }
-    public String getEncoding() {
-        if (enc == null) {
-            enc=DEFAULT_CHARACTER_ENCODING;
+
+    public Charset getCharset() {
+        if (charset == null) {
+            charset = DEFAULT_CHARSET;
         }
-        return enc;
+        return charset;
     }
 
     /**
@@ -512,31 +525,15 @@ public final class ByteChunk implements Cloneable, Serializable {
     }
 
     public String toStringInternal() {
-        String strValue=null;
-        try {
-            if (enc == null) {
-                enc = DEFAULT_CHARACTER_ENCODING;
-            }
-            strValue = new String(buff, start, end-start,
-                    B2CConverter.getCharset(enc));
-            /*
-             Does not improve the speed too much on most systems,
-             it's safer to use the "classical" new String().
-
-             Most overhead is in creating char[] and copying,
-             the internal implementation of new String() is very close to
-             what we do. The decoder is nice for large buffers and if
-             we don't go to String ( so we can take advantage of reduced GC)
-
-             // Method is commented out, in:
-              return B2CConverter.decodeString( enc );
-              */
-        } catch (java.io.UnsupportedEncodingException e) {
-            // Use the platform encoding in that case; the usage of a bad
-            // encoding will have been logged elsewhere already
-            strValue = new String(buff, start, end-start);
-        }
-        return strValue;
+        if (charset == null) {
+            charset = DEFAULT_CHARSET;
+        }
+        // new String(byte[], int, int, Charset) takes a defensive copy of the
+        // entire byte array. This is expensive if only a small subset of the
+        // bytes will be used. The code below is from Apache Harmony.
+        CharBuffer cb;
+        cb = charset.decode(ByteBuffer.wrap(buff, start, end-start));
+        return new String(cb.array());
     }
 
     public int getInt()

==================================================
StringCache.java
index c689bb30aa..8668f0b504 100644
--- a/java/org/apache/tomcat/util/buf/MessageBytes.java
+++ b/java/org/apache/tomcat/util/buf/MessageBytes.java
@@ -129,13 +129,13 @@ public final class MessageBytes implements Cloneable, Serializable {
      *  previous conversion is reset.
      *  If no encoding is set, we'll use 8859-1.
      */
-    public void setEncoding( String enc ) {
+    public void setCharset(Charset charset) {
         if( !byteC.isNull() ) {
             // if the encoding changes we need to reset the conversion results
             charC.recycle();
             hasStrValue=false;
         }
-        byteC.setEncoding(enc);
+        byteC.setCharset(charset);
     }
 
     /**

==================================================
Parameters.java
new file mode 100644
index 0000000000..f9d19daf7e
--- /dev/null
+++ b/java/org/apache/tomcat/util/http/LocalStrings.properties
@@ -0,0 +1,23 @@
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+parameters.bytes=Start processing with input [{0}]
+paramerers.copyFail=Failed to create copy of original parameter values for debug logging purposes
+parameters.decodeFail.debug=Character decoding failed. Parameter [{0}] with value [{1}] has been ignored.
+parameters.decodeFail.info=Character decoding failed. Parameter [{0}] with value [{1}] has been ignored. Note that the name and value quoted here may be corrupted due to the failed decoding. Use debug level logging to see the original, non-corrupted values.
+parameters.invalidChunk=Invalid chunk starting at byte [{0}] and ending at byte [{1}] with a value of [{2}] ignored
+parameters.maxCountFail=More than the maximum number of request parameters (GET plus POST) for a single request ([{0}]) were detected. Any parameters beyond this limit have been ignored. To change this limit, set the maxParameterCount attribute on the Connector.
+parameters.multipleDecodingFail=Character decoding failed. A total of [{0}] failures were detected but only the first was logged. Enable debug level logging for this logger to log all failures.
+parameters.noequal=Parameter starting at position [{0}] and ending at position [{1}] with a value of [{0}] was not followed by an '=' character

==================================================
