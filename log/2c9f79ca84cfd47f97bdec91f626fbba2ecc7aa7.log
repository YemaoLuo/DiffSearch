2c9f79ca84cfd47f97bdec91f626fbba2ecc7aa7
==================================================
improve the executor, keep a count on active thread, as Executor.getActiveCount loops through all of them each time
==================================================
Filip Hanik
==================================================
Fri Aug 31 20:24:38 2007 +0000
==================================================
StandardThreadExecutor.java
improve the executor, keep a count on active thread, as Executor.getActiveCount loops through all of them each time



git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@571562 13f79535-47bb-0310-9956-ffa450edef68



==================================================
NioEndpoint.java
index d8b62ff9fa..02ef819402 100644
--- a/java/org/apache/catalina/core/StandardThreadExecutor.java
+++ b/java/org/apache/catalina/core/StandardThreadExecutor.java
@@ -49,6 +49,8 @@ public class StandardThreadExecutor implements Executor {
     
     protected String name;
     
+    protected AtomicInteger activeCount = new AtomicInteger(0);
+    
     private LifecycleSupport lifecycle = new LifecycleSupport(this);
     // ---------------------------------------------- Constructors
     public StandardThreadExecutor() {
@@ -63,7 +65,15 @@ public class StandardThreadExecutor implements Executor {
         TaskQueue taskqueue = new TaskQueue();
         TaskThreadFactory tf = new TaskThreadFactory(namePrefix);
         lifecycle.fireLifecycleEvent(START_EVENT, null);
-        executor = new ThreadPoolExecutor(getMinSpareThreads(), getMaxThreads(), maxIdleTime, TimeUnit.MILLISECONDS,taskqueue, tf);
+        executor = new ThreadPoolExecutor(getMinSpareThreads(), getMaxThreads(), maxIdleTime, TimeUnit.MILLISECONDS,taskqueue, tf) {
+            protected void beforeExecute(Thread t,Runnable r) {
+                activeCount.addAndGet(1);
+            }
+            
+            protected void afterExecute(Runnable r,Throwable t) {
+                activeCount.addAndGet(-1);
+            }
+        };
         taskqueue.setParent( (ThreadPoolExecutor) executor);
         lifecycle.fireLifecycleEvent(AFTER_START_EVENT, null);
     }
@@ -74,6 +84,7 @@ public class StandardThreadExecutor implements Executor {
         if ( executor != null ) executor.shutdown();
         executor = null;
         lifecycle.fireLifecycleEvent(AFTER_STOP_EVENT, null);
+        activeCount.set(0);
     }
     
     public void execute(Runnable command) {
@@ -174,7 +185,7 @@ public class StandardThreadExecutor implements Executor {
 
     // Statistics from the thread pool
     public int getActiveCount() {
-        return (executor != null) ? executor.getActiveCount() : 0;
+        return activeCount.get();
     }
 
     public long getCompletedTaskCount() {
@@ -225,7 +236,7 @@ public class StandardThreadExecutor implements Executor {
             if (parent.getPoolSize() == parent.getMaximumPoolSize()) return super.offer(o);
             //we have idle threads, just add it to the queue
             //this is an approximation, so it could use some tuning
-            if (parent.getActiveCount()<(parent.getPoolSize())) return super.offer(o);
+            if (activeCount.get()<(parent.getPoolSize())) return super.offer(o);
             //if we have less threads than maximum force creation of a new thread
             if (parent.getPoolSize()<parent.getMaximumPoolSize()) return false;
             //if we reached here, we need to add it to the queue

==================================================
