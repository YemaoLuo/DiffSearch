559bf35a3caa0a303ed33bd0a443bc47cd99c966
==================================================
Implement client and server async timeout
==================================================
Mark Emlyn
==================================================
Wed Jan 30 19:51:47 2013 +0000
==================================================
RemoteEndpoint.java
Implement client and server async timeout
Note this doesn't work for BIO as it always blocks and only pretends to do async writes.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1440622 13f79535-47bb-0310-9956-ffa450edef68



==================================================
WebSocketContainer.java
index 7d32610954..862e80daa3 100644
--- a/java/javax/websocket/RemoteEndpoint.java
+++ b/java/javax/websocket/RemoteEndpoint.java
@@ -28,7 +28,20 @@ public interface RemoteEndpoint {
     void setBatchingAllowed(boolean batchingAllowed);
     boolean getBatchingAllowed();
     void flushBatch();
+
+    /**
+     * Obtain the timeout (in milliseconds) for sending a message
+     * asynchronously. A non-positive value means an infinite timeout. The
+     * default value is determined by
+     * {@link WebSocketContainer#getDefaultAsyncSendTimeout()}.
+     */
     long getAsyncSendTimeout();
+
+    /**
+     * Set the timeout (in milliseconds) for sending a message asynchronously. A
+     * non-positive value means an infinite timeout. The default value is
+     * determined by {@link WebSocketContainer#getDefaultAsyncSendTimeout()}.
+     */
     void setAsyncSendTimeout(long timeout);
 
     /**

==================================================
WebappClassLoader.java
index bff1b7f006..4deebb33af 100644
--- a/java/javax/websocket/WebSocketContainer.java
+++ b/java/javax/websocket/WebSocketContainer.java
@@ -21,8 +21,16 @@ import java.util.Set;
 
 public interface WebSocketContainer {
 
+    /**
+     * Obtain the default timeout (in milliseconds) for sending a message
+     * asynchronously. A non-positive value means an infinite timeout.
+     */
     long getDefaultAsyncSendTimeout();
 
+    /**
+     * Set the default timeout (in milliseconds) for sending a message
+     * asynchronously. A non-positive value means an infinite timeout.
+     */
     void setAsyncSendTimeout(long timeout);
 
     Session connectToServer(Class<?> annotatedEndpointClass, URI path)

==================================================
WsRemoteEndpointBase.java
index 5a2981c04f..95cc61aaec 100644
--- a/java/org/apache/catalina/loader/WebappClassLoader.java
+++ b/java/org/apache/catalina/loader/WebappClassLoader.java
@@ -2233,18 +2233,19 @@ public class WebappClassLoader
             Object[] table = (Object[]) internalTableField.get(map);
             if (table != null) {
                 for (int j =0; j < table.length; j++) {
-                    if (table[j] != null) {
+                    Object obj = table[j];
+                    if (obj != null) {
                         boolean potentialLeak = false;
                         // Check the key
-                        Object key = ((Reference<?>) table[j]).get();
+                        Object key = ((Reference<?>) obj).get();
                         if (this.equals(key) || loadedByThisOrChild(key)) {
                             potentialLeak = true;
                         }
                         // Check the value
                         Field valueField =
-                            table[j].getClass().getDeclaredField("value");
+                                obj.getClass().getDeclaredField("value");
                         valueField.setAccessible(true);
-                        Object value = valueField.get(table[j]);
+                        Object value = valueField.get(obj);
                         if (this.equals(value) || loadedByThisOrChild(value)) {
                             potentialLeak = true;
                         }

==================================================
WsRemoteEndpointClient.java
index 1fe1da6dc7..e8894c91de 100644
--- a/java/org/apache/tomcat/websocket/WsRemoteEndpointBase.java
+++ b/java/org/apache/tomcat/websocket/WsRemoteEndpointBase.java
@@ -49,41 +49,42 @@ public abstract class WsRemoteEndpointBase implements RemoteEndpoint {
     private final AtomicBoolean toBytesInProgress = new AtomicBoolean(false);
     private final CharsetEncoder encoder = Charset.forName("UTF8").newEncoder();
     private final MessageSendStateMachine state = new MessageSendStateMachine();
+
+    private volatile long asyncSendTimeout = -1;
+
     // Max length for WebSocket frame header is 14 bytes
     protected final ByteBuffer header = ByteBuffer.allocate(14);
     protected ByteBuffer payload = null;
 
 
     @Override
-    public void setBatchingAllowed(boolean batchingAllowed) {
-        // TODO Auto-generated method stub
-
+    public long getAsyncSendTimeout() {
+        return asyncSendTimeout;
     }
 
 
     @Override
-    public boolean getBatchingAllowed() {
-        // TODO Auto-generated method stub
-        return false;
+    public void setAsyncSendTimeout(long timeout) {
+        this.asyncSendTimeout = timeout;
     }
 
 
     @Override
-    public void flushBatch() {
+    public void setBatchingAllowed(boolean batchingAllowed) {
         // TODO Auto-generated method stub
 
     }
 
 
     @Override
-    public long getAsyncSendTimeout() {
+    public boolean getBatchingAllowed() {
         // TODO Auto-generated method stub
-        return 0;
+        return false;
     }
 
 
     @Override
-    public void setAsyncSendTimeout(long timeout) {
+    public void flushBatch() {
         // TODO Auto-generated method stub
 
     }

==================================================
WsSession.java
index ccd3ed38fc..f13fc60854 100644
--- a/java/org/apache/tomcat/websocket/WsRemoteEndpointClient.java
+++ b/java/org/apache/tomcat/websocket/WsRemoteEndpointClient.java
@@ -38,8 +38,13 @@ public class WsRemoteEndpointClient extends WsRemoteEndpointBase {
 
     @Override
     protected void sendMessage(WsCompletionHandler handler) {
-        channel.write(new ByteBuffer[] {header, payload}, 0, 2, Long.MAX_VALUE,
-                TimeUnit.DAYS, null, handler);
+        long timeout = getAsyncSendTimeout();
+        if (timeout < 1) {
+            timeout = Long.MAX_VALUE;
+
+        }
+        channel.write(new ByteBuffer[] {header, payload}, 0, 2,
+                getAsyncSendTimeout(), TimeUnit.MILLISECONDS, null, handler);
     }
 
     @Override

==================================================
WsWebSocketContainer.java
index 9c758e08ad..01b329cb1c 100644
--- a/java/org/apache/tomcat/websocket/WsSession.java
+++ b/java/org/apache/tomcat/websocket/WsSession.java
@@ -76,6 +76,8 @@ public class WsSession implements Session {
         this.wsRemoteEndpoint = wsRemoteEndpoint;
         this.webSocketContainer = webSocketContainer;
         applicationClassLoader = Thread.currentThread().getContextClassLoader();
+        wsRemoteEndpoint.setAsyncSendTimeout(
+                webSocketContainer.getDefaultAsyncSendTimeout());
     }
 
 

==================================================
ServerContainerImpl.java
index 88fb18cd44..d7fadda05a 100644
--- a/java/org/apache/tomcat/websocket/WsWebSocketContainer.java
+++ b/java/org/apache/tomcat/websocket/WsWebSocketContainer.java
@@ -54,6 +54,7 @@ public class WsWebSocketContainer implements WebSocketContainer {
     private static final byte[] crlf = new byte[] {13, 10};
     private static final int defaultBufferSize = 8 * 1024;
 
+    private long defaultAsyncTimeout = -1;
     private int binaryBufferSize = defaultBufferSize;
     private int textBufferSize = defaultBufferSize;
 
@@ -399,16 +400,25 @@ public class WsWebSocketContainer implements WebSocketContainer {
     }
 
 
+    /**
+     * {@inheritDoc}
+     *
+     * The default value for this implementation is -1.
+     */
     @Override
     public long getDefaultAsyncSendTimeout() {
-        // TODO Auto-generated method stub
-        return 0;
+        return defaultAsyncTimeout;
     }
 
 
+    /**
+     * {@inheritDoc}
+     *
+     * The default value for this implementation is -1.
+     */
     @Override
     public void setAsyncSendTimeout(long timeout) {
-        // TODO Auto-generated method stub
+        this.defaultAsyncTimeout = timeout;
     }
 
     private static class WsHandshakeResponse implements HandshakeResponse {

==================================================
WsListener.java
index 471e01fa74..6ce2edd254 100644
--- a/java/org/apache/tomcat/websocket/server/ServerContainerImpl.java
+++ b/java/org/apache/tomcat/websocket/server/ServerContainerImpl.java
@@ -70,6 +70,8 @@ public class ServerContainerImpl extends WsWebSocketContainer {
         return result;
     }
 
+    private final WsTimeout wsTimeout;
+    private final Thread timeoutThread;
 
     private volatile ServletContext servletContext = null;
     private Map<String,ServerEndpointConfiguration> configMap =
@@ -80,11 +82,18 @@ public class ServerContainerImpl extends WsWebSocketContainer {
 
 
     private ServerContainerImpl() {
-        // Hide default constructor
+        wsTimeout = new WsTimeout();
+        timeoutThread = new Thread(wsTimeout);
+        timeoutThread.setName(WsTimeout.THREAD_NAME_PREFIX + this);
+        timeoutThread.start();
     }
 
 
     public void setServletContext(ServletContext servletContext) {
+        if (this.servletContext == servletContext) {
+            return;
+        }
+
         this.servletContext = servletContext;
 
         // Configure servlet context wide defaults
@@ -99,6 +108,10 @@ public class ServerContainerImpl extends WsWebSocketContainer {
         if (value != null) {
             setMaxTextMessageBufferSize(Long.parseLong(value));
         }
+
+        // Update the timeout thread name
+        timeoutThread.setName(
+                WsTimeout.THREAD_NAME_PREFIX + servletContext.getContextPath());
     }
 
 
@@ -212,6 +225,25 @@ public class ServerContainerImpl extends WsWebSocketContainer {
     }
 
 
+    protected WsTimeout getTimeout() {
+        return wsTimeout;
+    }
+
+
+    protected void stop() {
+        wsTimeout.stop();
+        int count = 0;
+        while (count < 50 && timeoutThread.isAlive()) {
+            count ++;
+            try {
+                Thread.sleep(100);
+            } catch (InterruptedException e) {
+                // Ignore
+            }
+        }
+    }
+
+
     /**
      * Converts a path defined for a WebSocket endpoint into a path that can be
      * used as a servlet mapping.

==================================================
WsProtocolHandler.java
new file mode 100644
index 0000000000..0ccdf7788c
--- /dev/null
+++ b/java/org/apache/tomcat/websocket/server/WsListener.java
@@ -0,0 +1,41 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.tomcat.websocket.server;
+
+import javax.servlet.ServletContextEvent;
+import javax.servlet.ServletContextListener;
+
+/**
+ * This will be added automatically to a {@link javax.servlet.ServletContext} by
+ * the {@link WsSci}. If the {@link WsSci} is disabled, this listener must be
+ * added manually to every {@link javax.servlet.ServletContext} that uses
+ * WebSocket.
+ */
+public class WsListener implements ServletContextListener {
+
+    @Override
+    public void contextInitialized(ServletContextEvent sce) {
+        ServerContainerImpl sc = ServerContainerImpl.getServerContainer();
+        sc.setServletContext(sce.getServletContext());
+    }
+
+    @Override
+    public void contextDestroyed(ServletContextEvent sce) {
+        ServerContainerImpl sc = ServerContainerImpl.getServerContainer();
+        sc.stop();
+    }
+}

==================================================
WsRemoteEndpointServer.java
index dd922bebc6..9da7a0d247 100644
--- a/java/org/apache/tomcat/websocket/server/WsProtocolHandler.java
+++ b/java/org/apache/tomcat/websocket/server/WsProtocolHandler.java
@@ -29,7 +29,6 @@ import javax.websocket.CloseReason;
 import javax.websocket.CloseReason.CloseCodes;
 import javax.websocket.Endpoint;
 import javax.websocket.EndpointConfiguration;
-import javax.websocket.WebSocketContainer;
 
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
@@ -50,14 +49,14 @@ public class WsProtocolHandler implements ProtocolHandler {
     private final Endpoint ep;
     private final EndpointConfiguration endpointConfig;
     private final ClassLoader applicationClassLoader;
-    private final WebSocketContainer webSocketContainer;
+    private final ServerContainerImpl webSocketContainer;
 
     private WsSession wsSession;
 
 
     public WsProtocolHandler(Endpoint ep,
             EndpointConfiguration endpointConfig,
-            WebSocketContainer wsc) {
+            ServerContainerImpl wsc) {
         this.ep = ep;
         this.endpointConfig = endpointConfig;
         this.webSocketContainer = wsc;
@@ -84,7 +83,7 @@ public class WsProtocolHandler implements ProtocolHandler {
         t.setContextClassLoader(applicationClassLoader);
         try {
             WsRemoteEndpointServer wsRemoteEndpointServer =
-                    new WsRemoteEndpointServer(sos);
+                    new WsRemoteEndpointServer(sos, webSocketContainer);
             wsSession = new WsSession(
                     ep, wsRemoteEndpointServer, webSocketContainer);
             WsFrameServer wsFrame = new WsFrameServer(

==================================================
WsSci.java
index afd7bd9f6b..f4457a63aa 100644
--- a/java/org/apache/tomcat/websocket/server/WsRemoteEndpointServer.java
+++ b/java/org/apache/tomcat/websocket/server/WsRemoteEndpointServer.java
@@ -17,6 +17,7 @@
 package org.apache.tomcat.websocket.server;
 
 import java.io.IOException;
+import java.net.SocketTimeoutException;
 
 import javax.servlet.ServletOutputStream;
 
@@ -38,15 +39,19 @@ public class WsRemoteEndpointServer extends WsRemoteEndpointBase {
             LogFactory.getLog(WsProtocolHandler.class);
 
     private final ServletOutputStream sos;
+    private final WsTimeout wsTimeout;
     private volatile WsCompletionHandler handler = null;
+    private volatile long timeoutExpiry = -1;
     private volatile boolean close;
     private volatile Long size = null;
     private volatile boolean headerWritten = false;
     private volatile boolean payloadWritten = false;
 
 
-    public WsRemoteEndpointServer(ServletOutputStream sos) {
+    public WsRemoteEndpointServer(ServletOutputStream sos,
+            ServerContainerImpl serverContainer) {
         this.sos = sos;
+        this.wsTimeout = serverContainer.getTimeout();
     }
 
 
@@ -79,19 +84,29 @@ public class WsRemoteEndpointServer extends WsRemoteEndpointBase {
                     sos.write(payload.array(), payload.arrayOffset(),
                             payload.limit());
                 } else {
+                    wsTimeout.unregister(this);
                     if (close) {
-                        sos.close();
+                        close();
                     }
                     handler.completed(size, null);
-                    size = null;
-                    handler = null;
-                    headerWritten = false;
-                    payloadWritten = false;
+                    nextWrite();
                     break;
                 }
             }
         } catch (IOException ioe) {
+            wsTimeout.unregister(this);
+            close();
             handler.failed(ioe, null);
+            nextWrite();
+        }
+        if (handler != null) {
+            // Async write is in progress
+
+            timeoutExpiry = getAsyncSendTimeout() + System.currentTimeMillis();
+            if (timeoutExpiry > 0) {
+                // Register with timeout thread
+                wsTimeout.register(this);
+            }
         }
     }
 
@@ -105,5 +120,26 @@ public class WsRemoteEndpointServer extends WsRemoteEndpointBase {
                 log.info(sm.getString("wsRemoteEndpointServer.closeFailed"), e);
             }
         }
+        wsTimeout.unregister(this);
+    }
+
+
+    protected long getTimeoutExpiry() {
+        return timeoutExpiry;
+    }
+
+
+    protected void onTimeout() {
+        close();
+        handler.failed(new SocketTimeoutException(), null);
+        nextWrite();
+    }
+
+
+    private void nextWrite() {
+        handler = null;
+        size = null;
+        headerWritten = false;
+        payloadWritten = false;
     }
 }

==================================================
WsTimeout.java
index 7967d7e925..a8363b6601 100644
--- a/java/org/apache/tomcat/websocket/server/WsSci.java
+++ b/java/org/apache/tomcat/websocket/server/WsSci.java
@@ -35,12 +35,14 @@ public class WsSci implements ServletContainerInitializer {
     @Override
     public void onStartup(Set<Class<?>> clazzes, ServletContext ctx)
             throws ServletException {
-        // Need to configure the ServletContext in all cases
-        ServerContainerImpl sc = ServerContainerImpl.getServerContainer();
-        sc.setServletContext(ctx);
+
+        ctx.addListener(WsListener.class);
+
         if (clazzes == null || clazzes.size() == 0) {
             return;
         }
+
+        ServerContainerImpl sc = ServerContainerImpl.getServerContainer();
         for (Class<?> clazz : clazzes) {
             WebSocketEndpoint annotation =
                     clazz.getAnnotation(WebSocketEndpoint.class);

==================================================
TestWsWebSocketContainer.java
new file mode 100644
index 0000000000..b8638baf69
--- /dev/null
+++ b/java/org/apache/tomcat/websocket/server/WsTimeout.java
@@ -0,0 +1,108 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.tomcat.websocket.server;
+
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.Set;
+import java.util.concurrent.ConcurrentSkipListSet;
+
+/**
+ * Provides timeouts for asynchronous web socket writes. On the server side we
+ * only have access to {@link javax.servlet.ServletOutputStream} and
+ * {@link javax.servlet.ServletInputStream} so there is no way to set a timeout
+ * for writes to the client. Hence the separate thread.
+ */
+public class WsTimeout implements Runnable {
+
+    public static final String THREAD_NAME_PREFIX = "Websocket Timeout - ";
+
+    private final Set<WsRemoteEndpointServer> endpoints =
+            new ConcurrentSkipListSet<>(new EndpointComparator());
+    private volatile boolean running = true;
+
+    public void stop() {
+        running = false;
+        synchronized (this) {
+            this.notify();
+        }
+    }
+
+
+    @Override
+    public void run() {
+        while (running) {
+            // Wait for one second - no need for timeouts more frequently than
+            // that
+            synchronized (this) {
+                try {
+                    wait(1000);
+                } catch (InterruptedException e) {
+                    // Ignore
+                }
+            }
+
+            long now = System.currentTimeMillis();
+            Iterator<WsRemoteEndpointServer> iter = endpoints.iterator();
+            while (iter.hasNext()) {
+                WsRemoteEndpointServer endpoint = iter.next();
+                if (endpoint.getTimeoutExpiry() < now) {
+                    System.out.println(now);
+                    endpoint.onTimeout();
+                } else {
+                    // Endpoints are ordered by timeout expiry so we reach this
+                    // point there is no need to check the remaining endpoints
+                    break;
+                }
+            }
+        }
+    }
+
+
+    public void register(WsRemoteEndpointServer endpoint) {
+        endpoints.add(endpoint);
+    }
+
+
+    public void unregister(WsRemoteEndpointServer endpoint) {
+        endpoints.remove(endpoint);
+    }
+
+
+    /**
+     * Note: this comparator imposes orderings that are inconsistent with equals
+     */
+    private static class EndpointComparator implements
+            Comparator<WsRemoteEndpointServer> {
+
+        @Override
+        public int compare(WsRemoteEndpointServer o1,
+                WsRemoteEndpointServer o2) {
+
+            long t1 = o1.getTimeoutExpiry();
+            long t2 = o2.getTimeoutExpiry();
+
+            if (t1 < t2) {
+                return -1;
+            } else if (t1 == t2) {
+                return 0;
+            } else {
+                return 1;
+            }
+        }
+    }
+}

==================================================
