cdf5e4020634aeb273d5edc24e3340d34dec458b
==================================================
Rename SocketStatus to SocketEvent. It has needed a better name since creation and the connector refactoring is a good point to do it.
==================================================
Mark Thomas
==================================================
Mon Dec 14 13:50:25 2015 +0000
==================================================
CoyoteAdapter.java
Rename SocketStatus to SocketEvent. It has needed a better name since creation and the connector refactoring is a good point to do it.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1719912 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AbstractProcessor.java
index 8104de156a..71f1c5f355 100644
--- a/java/org/apache/catalina/connector/CoyoteAdapter.java
+++ b/java/org/apache/catalina/connector/CoyoteAdapter.java
@@ -50,7 +50,7 @@ import org.apache.tomcat.util.buf.MessageBytes;
 import org.apache.tomcat.util.http.ServerCookie;
 import org.apache.tomcat.util.http.ServerCookies;
 import org.apache.tomcat.util.net.SSLSupport;
-import org.apache.tomcat.util.net.SocketStatus;
+import org.apache.tomcat.util.net.SocketEvent;
 import org.apache.tomcat.util.res.StringManager;
 
 
@@ -127,7 +127,7 @@ public class CoyoteAdapter implements Adapter {
 
     @Override
     public boolean asyncDispatch(org.apache.coyote.Request req,
-            org.apache.coyote.Response res, SocketStatus status) throws Exception {
+            org.apache.coyote.Response res, SocketEvent status) throws Exception {
         Request request = (Request) req.getNote(ADAPTER_NOTES);
         Response response = (Response) res.getNote(ADAPTER_NOTES);
 
@@ -153,11 +153,11 @@ public class CoyoteAdapter implements Adapter {
                 response.setSuspended(false);
             }
 
-            if (status==SocketStatus.TIMEOUT) {
+            if (status==SocketEvent.TIMEOUT) {
                 if (!asyncConImpl.timeout()) {
                     asyncConImpl.setErrorState(null, false);
                 }
-            } else if (status==SocketStatus.ASYNC_READ_ERROR) {
+            } else if (status==SocketEvent.ASYNC_READ_ERROR) {
                 // A async read error is an IO error which means the socket
                 // needs to be closed so set success to false to trigger a
                 // close
@@ -178,7 +178,7 @@ public class CoyoteAdapter implements Adapter {
                 if (t != null) {
                     asyncConImpl.setErrorState(t, true);
                 }
-            } else if (status==SocketStatus.ASYNC_WRITE_ERROR) {
+            } else if (status==SocketEvent.ASYNC_WRITE_ERROR) {
                 // A async write error is an IO error which means the socket
                 // needs to be closed so set success to false to trigger a
                 // close
@@ -204,7 +204,7 @@ public class CoyoteAdapter implements Adapter {
             if (!request.isAsyncDispatching() && request.isAsync()) {
                 WriteListener writeListener = res.getWriteListener();
                 ReadListener readListener = req.getReadListener();
-                if (writeListener != null && status == SocketStatus.OPEN_WRITE) {
+                if (writeListener != null && status == SocketEvent.OPEN_WRITE) {
                     ClassLoader oldCL = null;
                     try {
                         oldCL = request.getContext().bind(false, null);
@@ -220,7 +220,7 @@ public class CoyoteAdapter implements Adapter {
                     } finally {
                         request.getContext().unbind(false, oldCL);
                     }
-                } else if (readListener != null && status == SocketStatus.OPEN_READ) {
+                } else if (readListener != null && status == SocketEvent.OPEN_READ) {
                     ClassLoader oldCL = null;
                     try {
                         oldCL = request.getContext().bind(false, null);

==================================================
AbstractProcessorLight.java
index c731d6504a..5279a6f114 100644
--- a/java/org/apache/coyote/AbstractProcessor.java
+++ b/java/org/apache/coyote/AbstractProcessor.java
@@ -26,7 +26,7 @@ import org.apache.tomcat.util.ExceptionUtils;
 import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.SSLSupport;
-import org.apache.tomcat.util.net.SocketStatus;
+import org.apache.tomcat.util.net.SocketEvent;
 import org.apache.tomcat.util.net.SocketWrapperBase;
 import org.apache.tomcat.util.res.StringManager;
 
@@ -97,7 +97,7 @@ public abstract class AbstractProcessor extends AbstractProcessorLight implement
                 response.setStatus(500);
             }
             getLog().info(sm.getString("abstractProcessor.nonContainerThreadError"), t);
-            socketWrapper.processSocket(SocketStatus.CLOSE_NOW, true);
+            socketWrapper.processSocket(SocketEvent.CLOSE_NOW, true);
         }
     }
 
@@ -181,9 +181,9 @@ public abstract class AbstractProcessor extends AbstractProcessorLight implement
 
 
     @Override
-    public final SocketState dispatch(SocketStatus status) {
+    public final SocketState dispatch(SocketEvent status) {
 
-        if (status == SocketStatus.OPEN_WRITE && response.getWriteListener() != null) {
+        if (status == SocketEvent.OPEN_WRITE && response.getWriteListener() != null) {
             asyncStateMachine.asyncOperation();
             try {
                 if (flushBufferedWrite()) {
@@ -193,10 +193,10 @@ public abstract class AbstractProcessor extends AbstractProcessorLight implement
                 if (getLog().isDebugEnabled()) {
                     getLog().debug("Unable to write async data.", ioe);
                 }
-                status = SocketStatus.ASYNC_WRITE_ERROR;
+                status = SocketEvent.ASYNC_WRITE_ERROR;
                 request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, ioe);
             }
-        } else if (status == SocketStatus.OPEN_READ && request.getReadListener() != null) {
+        } else if (status == SocketEvent.OPEN_READ && request.getReadListener() != null) {
             dispatchNonBlockingRead();
         }
 
@@ -256,7 +256,7 @@ public abstract class AbstractProcessor extends AbstractProcessorLight implement
     private void doTimeoutAsync() {
         // Avoid multiple timeouts
         setAsyncTimeout(-1);
-        socketWrapper.processSocket(SocketStatus.TIMEOUT, true);
+        socketWrapper.processSocket(SocketEvent.TIMEOUT, true);
     }
 
 

==================================================
AbstractProtocol.java
index cf84422d56..4bf3c8e3f1 100644
--- a/java/org/apache/coyote/AbstractProcessorLight.java
+++ b/java/org/apache/coyote/AbstractProcessorLight.java
@@ -24,7 +24,7 @@ import java.util.concurrent.CopyOnWriteArraySet;
 import org.apache.juli.logging.Log;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.DispatchType;
-import org.apache.tomcat.util.net.SocketStatus;
+import org.apache.tomcat.util.net.SocketEvent;
 import org.apache.tomcat.util.net.SocketWrapperBase;
 
 /**
@@ -38,19 +38,19 @@ public abstract class AbstractProcessorLight implements Processor {
 
 
     @Override
-    public SocketState process(SocketWrapperBase<?> socketWrapper, SocketStatus status)
+    public SocketState process(SocketWrapperBase<?> socketWrapper, SocketEvent status)
             throws IOException {
 
         SocketState state = SocketState.CLOSED;
         Iterator<DispatchType> dispatches = null;
         do {
-            if (status == SocketStatus.CLOSE_NOW) {
+            if (status == SocketEvent.CLOSE_NOW) {
                 errorDispatch();
                 state = SocketState.CLOSED;
             } else if (dispatches != null) {
                 DispatchType nextDispatch = dispatches.next();
                 state = dispatch(nextDispatch.getSocketStatus());
-            } else if (status == SocketStatus.DISCONNECT) {
+            } else if (status == SocketEvent.DISCONNECT) {
                 // Do nothing here, just wait for it to get recycled
             } else if (isAsync() || isUpgrade() || state == SocketState.ASYNC_END) {
                 state = dispatch(status);
@@ -62,7 +62,7 @@ public abstract class AbstractProcessorLight implements Processor {
                     // process it now.
                     state = service(socketWrapper);
                 }
-            } else if (status == SocketStatus.OPEN_WRITE) {
+            } else if (status == SocketEvent.OPEN_WRITE) {
                 // Extra write event likely after async, ignore
                 state = SocketState.LONG;
             } else {
@@ -130,7 +130,7 @@ public abstract class AbstractProcessorLight implements Processor {
      * or HTTP headers. Once the headers have been fully read this method is not
      * called again until there is a new HTTP request to process. Note that the
      * request type may change during processing which may result in one or more
-     * calls to {@link #dispatch(SocketStatus)}. Requests may be pipe-lined.
+     * calls to {@link #dispatch(SocketEvent)}. Requests may be pipe-lined.
      *
      * @param socketWrapper The connection to process
      *
@@ -148,7 +148,7 @@ public abstract class AbstractProcessorLight implements Processor {
      * Further uses may be added in the future. These will typically start as
      * HTTP requests.
      */
-    protected abstract SocketState dispatch(SocketStatus status);
+    protected abstract SocketState dispatch(SocketEvent status);
 
     protected abstract SocketState asyncPostProcess();
 

==================================================
Adapter.java
index c5c77f727f..1228b58849 100644
--- a/java/org/apache/coyote/AbstractProtocol.java
+++ b/java/org/apache/coyote/AbstractProtocol.java
@@ -42,7 +42,7 @@ import org.apache.tomcat.util.collections.SynchronizedStack;
 import org.apache.tomcat.util.modeler.Registry;
 import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler;
-import org.apache.tomcat.util.net.SocketStatus;
+import org.apache.tomcat.util.net.SocketEvent;
 import org.apache.tomcat.util.net.SocketWrapperBase;
 import org.apache.tomcat.util.res.StringManager;
 
@@ -691,7 +691,7 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
 
 
         @Override
-        public SocketState process(SocketWrapperBase<S> wrapper, SocketStatus status) {
+        public SocketState process(SocketWrapperBase<S> wrapper, SocketEvent status) {
             if (getLog().isDebugEnabled()) {
                 getLog().debug(sm.getString("abstractConnectionHandler.process",
                         wrapper.getSocket(), status));
@@ -708,7 +708,7 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
             }
 
             Processor processor = connections.get(socket);
-            if (status == SocketStatus.DISCONNECT && processor == null) {
+            if (status == SocketEvent.DISCONNECT && processor == null) {
                 // Nothing to do. Endpoint requested a close and there is no
                 // longer a processor associated with this socket.
                 return SocketState.CLOSED;
@@ -816,7 +816,7 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
                     // multiple read events which may lead to thread starvation
                     // in the connector. The write() method will add this socket
                     // to the poller if necessary.
-                    if (status != SocketStatus.OPEN_WRITE) {
+                    if (status != SocketEvent.OPEN_WRITE) {
                         longPoll(wrapper, processor);
                     }
                 } else {

==================================================
Processor.java
index ecae1d9447..28aa27cb62 100644
--- a/java/org/apache/coyote/Adapter.java
+++ b/java/org/apache/coyote/Adapter.java
@@ -16,7 +16,7 @@
  */
 package org.apache.coyote;
 
-import org.apache.tomcat.util.net.SocketStatus;
+import org.apache.tomcat.util.net.SocketEvent;
 
 /**
  * Adapter. This represents the entry point in a coyote-based servlet container.
@@ -63,7 +63,7 @@ public interface Adapter {
      */
     public boolean prepare(Request req, Response res) throws Exception;
 
-    public boolean asyncDispatch(Request req,Response res, SocketStatus status)
+    public boolean asyncDispatch(Request req,Response res, SocketEvent status)
             throws Exception;
 
     public void errorDispatch(Request request, Response response);

==================================================
AjpProcessor.java
index aa8c8fee08..d3f6726c0c 100644
--- a/java/org/apache/coyote/Processor.java
+++ b/java/org/apache/coyote/Processor.java
@@ -21,7 +21,7 @@ import java.nio.ByteBuffer;
 
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.SSLSupport;
-import org.apache.tomcat.util.net.SocketStatus;
+import org.apache.tomcat.util.net.SocketEvent;
 import org.apache.tomcat.util.net.SocketWrapperBase;
 
 /**
@@ -44,7 +44,7 @@ public interface Processor {
      * @throws IOException If an I/O error occurs during the processing of the
      *         request
      */
-    SocketState process(SocketWrapperBase<?> socketWrapper, SocketStatus status) throws IOException;
+    SocketState process(SocketWrapperBase<?> socketWrapper, SocketEvent status) throws IOException;
 
     UpgradeToken getUpgradeToken();
 

==================================================
Http11Processor.java
index cfa6a560a8..b219919992 100644
--- a/java/org/apache/coyote/ajp/AjpProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpProcessor.java
@@ -48,7 +48,7 @@ import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.DispatchType;
 import org.apache.tomcat.util.net.SSLSupport;
-import org.apache.tomcat.util.net.SocketStatus;
+import org.apache.tomcat.util.net.SocketEvent;
 import org.apache.tomcat.util.net.SocketWrapperBase;
 import org.apache.tomcat.util.res.StringManager;
 
@@ -493,13 +493,13 @@ public class AjpProcessor extends AbstractProcessor {
         case ASYNC_COMPLETE: {
             clearDispatches();
             if (asyncStateMachine.asyncComplete()) {
-                socketWrapper.processSocket(SocketStatus.OPEN_READ, true);
+                socketWrapper.processSocket(SocketEvent.OPEN_READ, true);
             }
             break;
         }
         case ASYNC_DISPATCH: {
             if (asyncStateMachine.asyncDispatch()) {
-                socketWrapper.processSocket(SocketStatus.OPEN_READ, true);
+                socketWrapper.processSocket(SocketEvent.OPEN_READ, true);
             }
             break;
         }

==================================================
InternalHttpUpgradeHandler.java
index b34c5a9ee9..9131ff9c40 100644
--- a/java/org/apache/coyote/http11/Http11Processor.java
+++ b/java/org/apache/coyote/http11/Http11Processor.java
@@ -61,7 +61,7 @@ import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.DispatchType;
 import org.apache.tomcat.util.net.SSLSupport;
 import org.apache.tomcat.util.net.SendfileDataBase;
-import org.apache.tomcat.util.net.SocketStatus;
+import org.apache.tomcat.util.net.SocketEvent;
 import org.apache.tomcat.util.net.SocketWrapperBase;
 import org.apache.tomcat.util.res.StringManager;
 
@@ -758,7 +758,7 @@ public class Http11Processor extends AbstractProcessor {
         case ASYNC_COMPLETE: {
             clearDispatches();
             if (asyncStateMachine.asyncComplete()) {
-                socketWrapper.processSocket(SocketStatus.OPEN_READ, true);
+                socketWrapper.processSocket(SocketEvent.OPEN_READ, true);
             }
             break;
         }
@@ -772,7 +772,7 @@ public class Http11Processor extends AbstractProcessor {
         }
         case ASYNC_DISPATCH: {
             if (asyncStateMachine.asyncDispatch()) {
-                socketWrapper.processSocket(SocketStatus.OPEN_READ, true);
+                socketWrapper.processSocket(SocketEvent.OPEN_READ, true);
             }
             break;
         }

==================================================
UpgradeProcessorExternal.java
index 86fbbef110..936784e20c 100644
--- a/java/org/apache/coyote/http11/upgrade/InternalHttpUpgradeHandler.java
+++ b/java/org/apache/coyote/http11/upgrade/InternalHttpUpgradeHandler.java
@@ -20,7 +20,7 @@ import javax.servlet.http.HttpUpgradeHandler;
 
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.SSLSupport;
-import org.apache.tomcat.util.net.SocketStatus;
+import org.apache.tomcat.util.net.SocketEvent;
 import org.apache.tomcat.util.net.SocketWrapperBase;
 
 
@@ -30,7 +30,7 @@ import org.apache.tomcat.util.net.SocketWrapperBase;
  */
 public interface InternalHttpUpgradeHandler extends HttpUpgradeHandler {
 
-    SocketState upgradeDispatch(SocketStatus status);
+    SocketState upgradeDispatch(SocketEvent status);
 
     void setSocketWrapper(SocketWrapperBase<?> wrapper);
 

==================================================
UpgradeProcessorInternal.java
index 643a7bd535..9ae620a6fc 100644
--- a/java/org/apache/coyote/http11/upgrade/UpgradeProcessorExternal.java
+++ b/java/org/apache/coyote/http11/upgrade/UpgradeProcessorExternal.java
@@ -27,7 +27,7 @@ import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.SSLSupport;
-import org.apache.tomcat.util.net.SocketStatus;
+import org.apache.tomcat.util.net.SocketEvent;
 import org.apache.tomcat.util.net.SocketWrapperBase;
 import org.apache.tomcat.util.res.StringManager;
 
@@ -86,12 +86,12 @@ public class UpgradeProcessorExternal extends UpgradeProcessorBase {
     // ------------------------------------------- Implemented Processor methods
 
     @Override
-    public final SocketState dispatch(SocketStatus status) {
-        if (status == SocketStatus.OPEN_READ) {
+    public final SocketState dispatch(SocketEvent status) {
+        if (status == SocketEvent.OPEN_READ) {
             upgradeServletInputStream.onDataAvailable();
-        } else if (status == SocketStatus.OPEN_WRITE) {
+        } else if (status == SocketEvent.OPEN_WRITE) {
             upgradeServletOutputStream.onWritePossible();
-        } else if (status == SocketStatus.STOP) {
+        } else if (status == SocketEvent.STOP) {
             if (log.isDebugEnabled()) {
                 log.debug(sm.getString("upgradeProcessor.stop"));
             }

==================================================
Http2UpgradeHandler.java
index 0708aae44a..f2a2e64030 100644
--- a/java/org/apache/coyote/http11/upgrade/UpgradeProcessorInternal.java
+++ b/java/org/apache/coyote/http11/upgrade/UpgradeProcessorInternal.java
@@ -27,7 +27,7 @@ import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.SSLSupport;
-import org.apache.tomcat.util.net.SocketStatus;
+import org.apache.tomcat.util.net.SocketEvent;
 import org.apache.tomcat.util.net.SocketWrapperBase;
 
 public class UpgradeProcessorInternal extends UpgradeProcessorBase {
@@ -51,7 +51,7 @@ public class UpgradeProcessorInternal extends UpgradeProcessorBase {
 
 
     @Override
-    public SocketState dispatch(SocketStatus status) {
+    public SocketState dispatch(SocketEvent status) {
         return internalHttpUpgradeHandler.upgradeDispatch(status);
     }
 

==================================================
StreamProcessor.java
index 789b3d1225..d5e7e68913 100644
--- a/java/org/apache/coyote/http2/Http2UpgradeHandler.java
+++ b/java/org/apache/coyote/http2/Http2UpgradeHandler.java
@@ -51,7 +51,7 @@ import org.apache.tomcat.util.http.FastHttpDateFormat;
 import org.apache.tomcat.util.http.MimeHeaders;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.SSLSupport;
-import org.apache.tomcat.util.net.SocketStatus;
+import org.apache.tomcat.util.net.SocketEvent;
 import org.apache.tomcat.util.net.SocketWrapperBase;
 import org.apache.tomcat.util.res.StringManager;
 
@@ -264,7 +264,7 @@ public class Http2UpgradeHandler extends AbstractStream implements InternalHttpU
 
 
     @Override
-    public SocketState upgradeDispatch(SocketStatus status) {
+    public SocketState upgradeDispatch(SocketEvent status) {
         if (log.isDebugEnabled()) {
             log.debug(sm.getString("upgradeHandler.upgradeDispatch.entry", connectionId, status));
         }

==================================================
AbstractEndpoint.java
index 81c2a8b4bb..3ee201198a 100644
--- a/java/org/apache/coyote/http2/StreamProcessor.java
+++ b/java/org/apache/coyote/http2/StreamProcessor.java
@@ -34,7 +34,7 @@ import org.apache.tomcat.util.buf.ByteChunk;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.DispatchType;
 import org.apache.tomcat.util.net.SSLSupport;
-import org.apache.tomcat.util.net.SocketStatus;
+import org.apache.tomcat.util.net.SocketEvent;
 import org.apache.tomcat.util.net.SocketWrapperBase;
 import org.apache.tomcat.util.res.StringManager;
 
@@ -63,7 +63,7 @@ public class StreamProcessor extends AbstractProcessor implements Runnable {
         ContainerThreadMarker.set();
         SocketState state = SocketState.CLOSED;
         try {
-            state = process(socketWrapper, SocketStatus.OPEN_READ);
+            state = process(socketWrapper, SocketEvent.OPEN_READ);
 
             if (state == SocketState.CLOSED) {
                 if (!getErrorState().isConnectionIoAllowed()) {

==================================================
AprEndpoint.java
index 3904d311b0..92dfe5c2c9 100644
--- a/java/org/apache/tomcat/util/net/AbstractEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AbstractEndpoint.java
@@ -71,7 +71,7 @@ public abstract class AbstractEndpoint<S> {
          * @return The state of the socket after processing
          */
         public SocketState process(SocketWrapperBase<S> socket,
-                SocketStatus status);
+                SocketEvent status);
 
 
         /**
@@ -768,7 +768,7 @@ public abstract class AbstractEndpoint<S> {
      *                          container thread
      */
     public abstract void processSocket(SocketWrapperBase<S> socketWrapper,
-            SocketStatus socketStatus, boolean dispatch);
+            SocketEvent socketStatus, boolean dispatch);
 
 
     // ------------------------------------------------------- Lifecycle methods

==================================================
DispatchType.java
index a84216a3ec..6c9025edc9 100644
--- a/java/org/apache/tomcat/util/net/AprEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AprEndpoint.java
@@ -824,7 +824,7 @@ public class AprEndpoint extends AbstractEndpoint<Long> implements SNICallBack {
      *         <code>false</code> which indicates an error occurred and that the
      *         socket should be closed
      */
-    public boolean processSocket(long socket, SocketStatus status) {
+    public boolean processSocket(long socket, SocketEvent status) {
         try {
             Executor executor = getExecutor();
             if (executor == null) {
@@ -853,7 +853,7 @@ public class AprEndpoint extends AbstractEndpoint<Long> implements SNICallBack {
 
 
     @Override
-    public void processSocket(SocketWrapperBase<Long> socket, SocketStatus status,
+    public void processSocket(SocketWrapperBase<Long> socket, SocketEvent status,
             boolean dispatch) {
         try {
             // Synchronisation is required here as this code may be called as a
@@ -1720,27 +1720,27 @@ public class AprEndpoint extends AbstractEndpoint<Long> implements SNICallBack {
                                     // was registered for
                                     if ((desc[n*2] & Poll.APR_POLLIN) == Poll.APR_POLLIN) {
                                         // Error probably occurred during a non-blocking read
-                                        if (!processSocket(desc[n*2+1], SocketStatus.OPEN_READ)) {
+                                        if (!processSocket(desc[n*2+1], SocketEvent.OPEN_READ)) {
                                             // Close socket and clear pool
                                             closeSocket(desc[n*2+1]);
                                         }
                                     } else if ((desc[n*2] & Poll.APR_POLLOUT) == Poll.APR_POLLOUT) {
                                         // Error probably occurred during a non-blocking write
-                                        if (!processSocket(desc[n*2+1], SocketStatus.OPEN_WRITE)) {
+                                        if (!processSocket(desc[n*2+1], SocketEvent.OPEN_WRITE)) {
                                             // Close socket and clear pool
                                             closeSocket(desc[n*2+1]);
                                         }
                                     } else if ((wrapper.pollerFlags & Poll.APR_POLLIN) == Poll.APR_POLLIN) {
                                         // Can't tell what was happening when the error occurred but the
                                         // socket is registered for non-blocking read so use that
-                                        if (!processSocket(desc[n*2+1], SocketStatus.OPEN_READ)) {
+                                        if (!processSocket(desc[n*2+1], SocketEvent.OPEN_READ)) {
                                             // Close socket and clear pool
                                             closeSocket(desc[n*2+1]);
                                         }
                                     } else if ((wrapper.pollerFlags & Poll.APR_POLLOUT) == Poll.APR_POLLOUT) {
                                         // Can't tell what was happening when the error occurred but the
                                         // socket is registered for non-blocking write so use that
-                                        if (!processSocket(desc[n*2+1], SocketStatus.OPEN_WRITE)) {
+                                        if (!processSocket(desc[n*2+1], SocketEvent.OPEN_WRITE)) {
                                             // Close socket and clear pool
                                             closeSocket(desc[n*2+1]);
                                         }
@@ -1752,14 +1752,14 @@ public class AprEndpoint extends AbstractEndpoint<Long> implements SNICallBack {
                                         || ((desc[n*2] & Poll.APR_POLLOUT) == Poll.APR_POLLOUT)) {
                                     boolean error = false;
                                     if (((desc[n*2] & Poll.APR_POLLIN) == Poll.APR_POLLIN) &&
-                                            !processSocket(desc[n*2+1], SocketStatus.OPEN_READ)) {
+                                            !processSocket(desc[n*2+1], SocketEvent.OPEN_READ)) {
                                         error = true;
                                         // Close socket and clear pool
                                         closeSocket(desc[n*2+1]);
                                     }
                                     if (!error &&
                                             ((desc[n*2] & Poll.APR_POLLOUT) == Poll.APR_POLLOUT) &&
-                                            !processSocket(desc[n*2+1], SocketStatus.OPEN_WRITE)) {
+                                            !processSocket(desc[n*2+1], SocketEvent.OPEN_WRITE)) {
                                         // Close socket and clear pool
                                         error = true;
                                         closeSocket(desc[n*2+1]);
@@ -2245,7 +2245,7 @@ public class AprEndpoint extends AbstractEndpoint<Long> implements SNICallBack {
                     }
                     // Process the request from this socket
                     Handler.SocketState state = getHandler().process(socket,
-                            SocketStatus.OPEN_READ);
+                            SocketEvent.OPEN_READ);
                     if (state == Handler.SocketState.CLOSED) {
                         // Close socket and pool
                         closeSocket(socket.getSocket().longValue());
@@ -2267,10 +2267,10 @@ public class AprEndpoint extends AbstractEndpoint<Long> implements SNICallBack {
     protected class SocketProcessor implements Runnable {
 
         private final SocketWrapperBase<Long> socket;
-        private final SocketStatus status;
+        private final SocketEvent status;
 
         public SocketProcessor(SocketWrapperBase<Long> socket,
-                SocketStatus status) {
+                SocketEvent status) {
             this.socket = socket;
             if (status == null) {
                 // Should never happen

==================================================
Nio2Endpoint.java
index cd104b26bd..9b8a07808c 100644
--- a/java/org/apache/tomcat/util/net/DispatchType.java
+++ b/java/org/apache/tomcat/util/net/DispatchType.java
@@ -23,16 +23,16 @@ package org.apache.tomcat.util.net;
  */
 public enum DispatchType {
 
-    NON_BLOCKING_READ(SocketStatus.OPEN_READ),
-    NON_BLOCKING_WRITE(SocketStatus.OPEN_WRITE);
+    NON_BLOCKING_READ(SocketEvent.OPEN_READ),
+    NON_BLOCKING_WRITE(SocketEvent.OPEN_WRITE);
 
-    private final SocketStatus status;
+    private final SocketEvent status;
 
-    private DispatchType(SocketStatus status) {
+    private DispatchType(SocketEvent status) {
         this.status = status;
     }
 
-    public SocketStatus getSocketStatus() {
+    public SocketEvent getSocketStatus() {
         return status;
     }
 }

==================================================
NioEndpoint.java
index 0162a81e41..492c12b8d0 100644
--- a/java/org/apache/tomcat/util/net/Nio2Endpoint.java
+++ b/java/org/apache/tomcat/util/net/Nio2Endpoint.java
@@ -354,7 +354,7 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel> {
             socketWrapper.setReadTimeout(getSoTimeout());
             socketWrapper.setWriteTimeout(getSoTimeout());
             // Continue processing on another thread
-            return processSocket0(socketWrapper, SocketStatus.OPEN_READ, true);
+            return processSocket0(socketWrapper, SocketEvent.OPEN_READ, true);
         } catch (Throwable t) {
             ExceptionUtils.handleThrowable(t);
             log.error("",t);
@@ -374,11 +374,11 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel> {
 
     @Override
     public void processSocket(SocketWrapperBase<Nio2Channel> socketWrapper,
-            SocketStatus socketStatus, boolean dispatch) {
+            SocketEvent socketStatus, boolean dispatch) {
         processSocket0(socketWrapper, socketStatus, dispatch);
     }
 
-    protected boolean processSocket0(SocketWrapperBase<Nio2Channel> socketWrapper, SocketStatus status, boolean dispatch) {
+    protected boolean processSocket0(SocketWrapperBase<Nio2Channel> socketWrapper, SocketEvent status, boolean dispatch) {
         try {
             SocketProcessor sc = processorCache.pop();
             if (sc == null) {
@@ -574,12 +574,12 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel> {
                     failed(new ClosedChannelException(), attachment);
                     return;
                 }
-                getEndpoint().processSocket(attachment, SocketStatus.OPEN_READ, Nio2Endpoint.isInline());
+                getEndpoint().processSocket(attachment, SocketEvent.OPEN_READ, Nio2Endpoint.isInline());
             }
 
             @Override
             public void failed(Throwable exc, SocketWrapperBase<Nio2Channel> attachment) {
-                getEndpoint().processSocket(attachment, SocketStatus.DISCONNECT, true);
+                getEndpoint().processSocket(attachment, SocketEvent.DISCONNECT, true);
             }
         };
 
@@ -611,7 +611,7 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel> {
                             }
                         } else {
                             if (!isInline()) {
-                                getEndpoint().processSocket(Nio2SocketWrapper.this, SocketStatus.DISCONNECT, false);
+                                getEndpoint().processSocket(Nio2SocketWrapper.this, SocketEvent.DISCONNECT, false);
                             } else {
                                 attachment.doneInline = true;
                             }
@@ -649,7 +649,7 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel> {
                     // Ignore
                 }
                 if (!isInline()) {
-                    getEndpoint().processSocket(Nio2SocketWrapper.this, SocketStatus.ERROR, false);
+                    getEndpoint().processSocket(Nio2SocketWrapper.this, SocketEvent.ERROR, false);
                 } else {
                     attachment.doneInline = true;
                     attachment.error = true;
@@ -683,7 +683,7 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel> {
                         }
                     }
                     if (notify) {
-                        getEndpoint().processSocket(attachment, SocketStatus.OPEN_READ, false);
+                        getEndpoint().processSocket(attachment, SocketEvent.OPEN_READ, false);
                     }
                 }
                 @Override
@@ -702,7 +702,7 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel> {
                         // If already closed, don't call onError and close again
                         return;
                     }
-                    getEndpoint().processSocket(attachment, SocketStatus.ERROR, true);
+                    getEndpoint().processSocket(attachment, SocketEvent.ERROR, true);
                 }
             };
 
@@ -747,7 +747,7 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel> {
                         }
                     }
                     if (writeNotify && nestedWriteCompletionCount.get().get() == 0) {
-                        endpoint.processSocket(Nio2SocketWrapper.this, SocketStatus.OPEN_WRITE, Nio2Endpoint.isInline());
+                        endpoint.processSocket(Nio2SocketWrapper.this, SocketEvent.OPEN_WRITE, Nio2Endpoint.isInline());
                     }
                 }
 
@@ -761,7 +761,7 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel> {
                     }
                     Nio2SocketWrapper.this.setError(ioe);
                     writePending.release();
-                    endpoint.processSocket(Nio2SocketWrapper.this, SocketStatus.OPEN_WRITE, true);
+                    endpoint.processSocket(Nio2SocketWrapper.this, SocketEvent.OPEN_WRITE, true);
                 }
             };
 
@@ -801,7 +801,7 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel> {
                         }
                     }
                     if (writeNotify && nestedWriteCompletionCount.get().get() == 0) {
-                        endpoint.processSocket(Nio2SocketWrapper.this, SocketStatus.OPEN_WRITE, Nio2Endpoint.isInline());
+                        endpoint.processSocket(Nio2SocketWrapper.this, SocketEvent.OPEN_WRITE, Nio2Endpoint.isInline());
                     }
                 }
 
@@ -815,7 +815,7 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel> {
                     }
                     Nio2SocketWrapper.this.setError(ioe);
                     writePending.release();
-                    endpoint.processSocket(Nio2SocketWrapper.this, SocketStatus.OPEN_WRITE, true);
+                    endpoint.processSocket(Nio2SocketWrapper.this, SocketEvent.OPEN_WRITE, true);
                }
             };
 
@@ -1368,7 +1368,7 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel> {
                     writeInterest = true;
                 } else {
                     // If no write is pending, notify
-                    getEndpoint().processSocket(this, SocketStatus.OPEN_WRITE, true);
+                    getEndpoint().processSocket(this, SocketEvent.OPEN_WRITE, true);
                 }
             }
         }
@@ -1607,13 +1607,13 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel> {
     protected class SocketProcessor implements Runnable {
 
         private SocketWrapperBase<Nio2Channel> socket = null;
-        private SocketStatus status = null;
+        private SocketEvent status = null;
 
-        public SocketProcessor(SocketWrapperBase<Nio2Channel> socket, SocketStatus status) {
+        public SocketProcessor(SocketWrapperBase<Nio2Channel> socket, SocketEvent status) {
             reset(socket,status);
         }
 
-        public void reset(SocketWrapperBase<Nio2Channel> socket, SocketStatus status) {
+        public void reset(SocketWrapperBase<Nio2Channel> socket, SocketEvent status) {
             this.socket = socket;
             this.status = status;
         }
@@ -1621,7 +1621,7 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel> {
         @Override
         public void run() {
             synchronized (socket) {
-                if (SocketStatus.OPEN_WRITE != status) {
+                if (SocketEvent.OPEN_WRITE != status) {
                     // Anything other than OPEN_WRITE is a genuine read or an
                     // error condition so for all of those release the semaphore
                     ((Nio2SocketWrapper) socket).releaseReadPending();
@@ -1635,9 +1635,9 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel> {
                             // For STOP there is no point trying to handshake as the
                             // Poller has been stopped.
                             if (socket.getSocket().isHandshakeComplete() ||
-                                    status == SocketStatus.STOP) {
+                                    status == SocketEvent.STOP) {
                                 handshake = 0;
-                            } else if (status == SocketStatus.ERROR) {
+                            } else if (status == SocketEvent.ERROR) {
                                 handshake = -1;
                             } else {
                                 handshake = socket.getSocket().handshake();
@@ -1648,7 +1648,7 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel> {
                                 // must always be OPEN_READ after it completes. It
                                 // is OK to always set this as it is only used if
                                 // the handshake completes.
-                                status = SocketStatus.OPEN_READ;
+                                status = SocketEvent.OPEN_READ;
                             }
                         }
                     } catch (IOException x) {
@@ -1657,11 +1657,11 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel> {
                             log.debug(sm.getString("endpoint.err.handshake"), x);
                         }
                     }
-                    if (handshake == 0 || status == SocketStatus.ERROR) {
+                    if (handshake == 0 || status == SocketEvent.ERROR) {
                         SocketState state = SocketState.OPEN;
                         // Process the request from this socket
                         if (status == null) {
-                            state = getHandler().process(socket, SocketStatus.OPEN_READ);
+                            state = getHandler().process(socket, SocketEvent.OPEN_READ);
                         } else {
                             state = getHandler().process(socket, status);
                         }
@@ -1695,7 +1695,7 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel> {
                 } finally {
                     if (launch) {
                         try {
-                            getExecutor().execute(new SocketProcessor(socket, SocketStatus.OPEN_READ));
+                            getExecutor().execute(new SocketProcessor(socket, SocketEvent.OPEN_READ));
                         } catch (NullPointerException npe) {
                             if (running) {
                                 log.error(sm.getString("endpoint.launch.fail"),

==================================================
SecureNio2Channel.java
index 287aae6b19..35cab2c257 100644
--- a/java/org/apache/tomcat/util/net/NioEndpoint.java
+++ b/java/org/apache/tomcat/util/net/NioEndpoint.java
@@ -432,11 +432,11 @@ public class NioEndpoint extends AbstractJsseEndpoint<NioChannel> {
 
     @Override
     public void processSocket(SocketWrapperBase<NioChannel> socketWrapper,
-            SocketStatus socketStatus, boolean dispatch) {
+            SocketEvent socketStatus, boolean dispatch) {
         processSocket((NioSocketWrapper) socketWrapper, socketStatus, dispatch);
     }
 
-    protected boolean processSocket(NioSocketWrapper attachment, SocketStatus status, boolean dispatch) {
+    protected boolean processSocket(NioSocketWrapper attachment, SocketEvent status, boolean dispatch) {
         try {
             if (attachment == null) {
                 return false;
@@ -707,7 +707,7 @@ public class NioEndpoint extends AbstractJsseEndpoint<NioChannel> {
             addEvent(r);
             if (close) {
                 NioEndpoint.NioSocketWrapper ka = (NioEndpoint.NioSocketWrapper)socket.getAttachment();
-                processSocket(ka, SocketStatus.STOP, false);
+                processSocket(ka, SocketEvent.STOP, false);
             }
         }
 
@@ -903,12 +903,12 @@ public class NioEndpoint extends AbstractJsseEndpoint<NioChannel> {
                                 boolean closeSocket = false;
                                 // Read goes before write
                                 if (sk.isReadable()) {
-                                    if (!processSocket(attachment, SocketStatus.OPEN_READ, true)) {
+                                    if (!processSocket(attachment, SocketEvent.OPEN_READ, true)) {
                                         closeSocket = true;
                                     }
                                 }
                                 if (!closeSocket && sk.isWritable()) {
-                                    if (!processSocket(attachment, SocketStatus.OPEN_WRITE, true)) {
+                                    if (!processSocket(attachment, SocketEvent.OPEN_WRITE, true)) {
                                         closeSocket = true;
                                     }
                                 }
@@ -1461,13 +1461,13 @@ public class NioEndpoint extends AbstractJsseEndpoint<NioChannel> {
     protected class SocketProcessor implements Runnable {
 
         private NioSocketWrapper ka = null;
-        private SocketStatus status = null;
+        private SocketEvent status = null;
 
-        public SocketProcessor(NioSocketWrapper ka, SocketStatus status) {
+        public SocketProcessor(NioSocketWrapper ka, SocketEvent status) {
             reset(ka, status);
         }
 
-        public void reset(NioSocketWrapper ka, SocketStatus status) {
+        public void reset(NioSocketWrapper ka, SocketEvent status) {
             this.ka = ka;
             this.status = status;
         }
@@ -1490,7 +1490,7 @@ public class NioEndpoint extends AbstractJsseEndpoint<NioChannel> {
                             // For STOP there is no point trying to handshake as the
                             // Poller has been stopped.
                             if (socket.isHandshakeComplete() ||
-                                    status == SocketStatus.STOP) {
+                                    status == SocketEvent.STOP) {
                                 handshake = 0;
                             } else {
                                 handshake = socket.handshake(
@@ -1502,7 +1502,7 @@ public class NioEndpoint extends AbstractJsseEndpoint<NioChannel> {
                                 // must always be OPEN_READ after it completes. It
                                 // is OK to always set this as it is only used if
                                 // the handshake completes.
-                                status = SocketStatus.OPEN_READ;
+                                status = SocketEvent.OPEN_READ;
                             }
                         }
                     } catch (IOException x) {
@@ -1515,7 +1515,7 @@ public class NioEndpoint extends AbstractJsseEndpoint<NioChannel> {
                         SocketState state = SocketState.OPEN;
                         // Process the request from this socket
                         if (status == null) {
-                            state = getHandler().process(ka, SocketStatus.OPEN_READ);
+                            state = getHandler().process(ka, SocketEvent.OPEN_READ);
                         } else {
                             state = getHandler().process(ka, status);
                         }

==================================================
SocketEvent.java
index 9864445582..62b8b4e2c1 100644
--- a/java/org/apache/tomcat/util/net/SecureNio2Channel.java
+++ b/java/org/apache/tomcat/util/net/SecureNio2Channel.java
@@ -95,12 +95,12 @@ public class SecureNio2Channel extends Nio2Channel  {
             if (result.intValue() < 0) {
                 failed(new EOFException(), attachment);
             } else {
-                endpoint.processSocket(attachment, SocketStatus.OPEN_READ, false);
+                endpoint.processSocket(attachment, SocketEvent.OPEN_READ, false);
             }
         }
         @Override
         public void failed(Throwable exc, SocketWrapperBase<Nio2Channel> attachment) {
-            endpoint.processSocket(attachment, SocketStatus.ERROR, false);
+            endpoint.processSocket(attachment, SocketEvent.ERROR, false);
         }
     }
 
@@ -112,12 +112,12 @@ public class SecureNio2Channel extends Nio2Channel  {
             if (result.intValue() < 0) {
                 failed(new EOFException(), attachment);
             } else {
-                endpoint.processSocket(attachment, SocketStatus.OPEN_WRITE, false);
+                endpoint.processSocket(attachment, SocketEvent.OPEN_WRITE, false);
             }
         }
         @Override
         public void failed(Throwable exc, SocketWrapperBase<Nio2Channel> attachment) {
-            endpoint.processSocket(attachment, SocketStatus.ERROR, false);
+            endpoint.processSocket(attachment, SocketEvent.ERROR, false);
         }
     }
 

==================================================
SocketWrapperBase.java
similarity index 80%
rename from java/org/apache/tomcat/util/net/SocketStatus.java
rename to java/org/apache/tomcat/util/net/SocketEvent.java
index ca4735a857..818a5ebd44 100644
--- a/java/org/apache/tomcat/util/net/SocketStatus.java
+++ b/java/org/apache/tomcat/util/net/SocketEvent.java
@@ -14,14 +14,13 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
 package org.apache.tomcat.util.net;
 
 /**
- * Someone, please change the enum name.
- *
- * @author remm
+ * Defines events that occur per socket that require further processing by the
+ * container. Usually these events are triggered by the socket implementation
+ * but they may be triggered by the container.
  */
-public enum SocketStatus {
+public enum SocketEvent {
     OPEN_READ, OPEN_WRITE, STOP, TIMEOUT, DISCONNECT, ERROR, ASYNC_WRITE_ERROR, ASYNC_READ_ERROR, CLOSE_NOW
 }

==================================================
WsHttpUpgradeHandler.java
index 6c2a29a33b..f84befb6f6 100644
--- a/java/org/apache/tomcat/util/net/SocketWrapperBase.java
+++ b/java/org/apache/tomcat/util/net/SocketWrapperBase.java
@@ -501,7 +501,7 @@ public abstract class SocketWrapperBase<E> {
     }
 
 
-    public void processSocket(SocketStatus socketStatus, boolean dispatch) {
+    public void processSocket(SocketEvent socketStatus, boolean dispatch) {
         endpoint.processSocket(this, socketStatus, dispatch);
     }
 

==================================================
TestUpgradeInternalHandler.java
index 944ac6c6da..f75506141a 100644
--- a/java/org/apache/tomcat/websocket/server/WsHttpUpgradeHandler.java
+++ b/java/org/apache/tomcat/websocket/server/WsHttpUpgradeHandler.java
@@ -35,7 +35,7 @@ import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.SSLSupport;
-import org.apache.tomcat.util.net.SocketStatus;
+import org.apache.tomcat.util.net.SocketEvent;
 import org.apache.tomcat.util.net.SocketWrapperBase;
 import org.apache.tomcat.util.res.StringManager;
 import org.apache.tomcat.websocket.Transformation;
@@ -141,7 +141,7 @@ public class WsHttpUpgradeHandler implements InternalHttpUpgradeHandler {
 
 
     @Override
-    public SocketState upgradeDispatch(SocketStatus status) {
+    public SocketState upgradeDispatch(SocketEvent status) {
         switch (status) {
             case OPEN_READ:
                 try {

==================================================
