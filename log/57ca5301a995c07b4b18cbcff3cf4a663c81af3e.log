57ca5301a995c07b4b18cbcff3cf4a663c81af3e
==================================================
Fix BZ 66548 - Add validation of Sec-Websocket-Key header
==================================================
Mark Thomas
==================================================
Tue Apr 11 08:18:43 2023 +0100
==================================================
Base64.java
Fix BZ 66548 - Add validation of Sec-Websocket-Key header

Note that the validation isn't perfect. It aims to be good enough.
https://bz.apache.org/bugzilla/show_bug.cgi?id=66548


==================================================
UpgradeUtil.java
index dc11167a16..9129650bfd 100644
--- a/java/org/apache/tomcat/util/codec/binary/Base64.java
+++ b/java/org/apache/tomcat/util/codec/binary/Base64.java
@@ -279,6 +279,15 @@ public class Base64 extends BaseNCodec {
     }
 
 
+    public static boolean isInAlphabet(char c) {
+        // Fast for valid data. May be slow for invalid data.
+        try {
+            return STANDARD_DECODE_TABLE[c] != -1;
+        } catch (ArrayIndexOutOfBoundsException ex) {
+            return false;
+        }
+    }
+
     /**
      * Encode table to use: either STANDARD or URL_SAFE. Note: the DECODE_TABLE above remains static because it is able
      * to decode both STANDARD and URL_SAFE streams, but the encodeTable must be a member variable so we can switch

==================================================
TestKeyHeader.java
index ac4021fd00..814587390f 100644
--- a/java/org/apache/tomcat/websocket/server/UpgradeUtil.java
+++ b/java/org/apache/tomcat/websocket/server/UpgradeUtil.java
@@ -95,7 +95,7 @@ public class UpgradeUtil {
             return;
         }
         key = req.getHeader(Constants.WS_KEY_HEADER_NAME);
-        if (key == null) {
+        if (!validateKey(key)) {
             resp.sendError(HttpServletResponse.SC_BAD_REQUEST);
             return;
         }
@@ -224,6 +224,43 @@ public class UpgradeUtil {
     }
 
 
+    /*
+     * Validate the key. It should be the base64 encoding of a random 16-byte value. 16-bytes are encoded in 24 base64
+     * characters, the last two of which must be ==.
+     *
+     * The validation isn't perfect:
+     *
+     * - it doesn't check the final non-'=' character is valid in the context of the number of bits it is meant to be
+     * encoding.
+     *
+     * - it doesn't check that the value is random and changes for each connection.
+     *
+     * Given that this header is for the benefit of the client, not the server, this should be good enough.
+     */
+    private static boolean validateKey(String key) {
+        if (key == null) {
+            return false;
+        }
+
+        if (key.length() != 24) {
+            return false;
+        }
+
+        char[] keyChars = key.toCharArray();
+        if (keyChars[22] != '=' || keyChars[23] != '=') {
+            return false;
+        }
+
+        for (int i = 0; i < 22; i++) {
+            if (!Base64.isInAlphabet(keyChars[i])) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+
     private static List<Transformation> createTransformations(List<Extension> negotiatedExtensions) {
 
         TransformationFactory factory = TransformationFactory.getInstance();

==================================================
TesterWsClient.java
new file mode 100644
index 0000000000..8db0bd2cc8
--- /dev/null
+++ b/test/org/apache/tomcat/websocket/server/TestKeyHeader.java
@@ -0,0 +1,87 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.tomcat.websocket.server;
+
+import java.nio.charset.StandardCharsets;
+
+import jakarta.servlet.http.HttpServletResponse;
+import jakarta.websocket.CloseReason.CloseCodes;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import org.apache.tomcat.websocket.TesterEchoServer;
+import org.apache.tomcat.websocket.WebSocketBaseTest;
+
+public class TestKeyHeader extends WebSocketBaseTest {
+
+    @Test
+    public void testEmptyString() throws Exception {
+        doTest("", HttpServletResponse.SC_BAD_REQUEST);
+    }
+
+
+    @Test
+    public void testValid() throws Exception {
+        // "0123456789012345" encoded with base64
+        doTest("MDEyMzQ1Njc4OTAxMjM0NQ==", HttpServletResponse.SC_SWITCHING_PROTOCOLS);
+    }
+
+
+    @Test
+    public void testInvalidCharacter() throws Exception {
+        // "0123456789012345" encoded with base64
+        doTest("MDEy(zQ1Njc4OTAxMjM0NQ==", HttpServletResponse.SC_BAD_REQUEST);
+    }
+
+
+    @Test
+    public void testTooShort() throws Exception {
+        // "012345678901234" encoded with base64
+        doTest("MDEyMzQ1Njc4OTAxMjM0", HttpServletResponse.SC_BAD_REQUEST);
+    }
+
+
+    @Test
+    public void testTooLong01() throws Exception {
+        // "01234567890123456" encoded with base64
+        doTest("MDEyMzQ1Njc4OTAxMjM0NTY=", HttpServletResponse.SC_BAD_REQUEST);
+    }
+
+
+    @Test
+    public void testTooLong02() throws Exception {
+        // "012345678901234678" encoded with base64
+        doTest("MDEyMzQ1Njc4OTAxMjM0NTY3OA==", HttpServletResponse.SC_BAD_REQUEST);
+    }
+
+    private void doTest(String keyHeaderValue, int expectedStatusCode) throws Exception {
+        startServer(TesterEchoServer.Config.class);
+
+        TesterWsClient client = new TesterWsClient("localhost", getPort(), keyHeaderValue);
+        String req = client.createUpgradeRequest(TesterEchoServer.Config.PATH_BASIC);
+        client.write(req.getBytes(StandardCharsets.UTF_8));
+        int rc = client.readUpgradeResponse();
+
+        Assert.assertEquals(expectedStatusCode, rc);
+
+        if (expectedStatusCode == HttpServletResponse.SC_SWITCHING_PROTOCOLS) {
+            client.sendCloseFrame(CloseCodes.NORMAL_CLOSURE);
+        }
+        client.closeSocket();
+    }
+}

==================================================
