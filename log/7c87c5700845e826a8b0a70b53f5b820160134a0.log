7c87c5700845e826a8b0a70b53f5b820160134a0
==================================================
Make SocketWrapper abstract
==================================================
Mark Emlyn
==================================================
Mon Nov 10 16:45:04 2014 +0000
==================================================
AbstractProcessor.java
Make SocketWrapper abstract
Rename SocketWrapper and sub-classes for consistency

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1637917 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AbstractProtocol.java
index be45c5c405..9dcfad65e0 100644
--- a/java/org/apache/coyote/AbstractProcessor.java
+++ b/java/org/apache/coyote/AbstractProcessor.java
@@ -25,7 +25,7 @@ import org.apache.juli.logging.Log;
 import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.SocketStatus;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 import org.apache.tomcat.util.res.StringManager;
 
 /**
@@ -41,7 +41,7 @@ public abstract class AbstractProcessor<S> implements ActionHook, Processor<S> {
     protected final AbstractEndpoint<S> endpoint;
     protected final Request request;
     protected final Response response;
-    protected SocketWrapper<S> socketWrapper = null;
+    protected SocketWrapperBase<S> socketWrapper = null;
 
     /**
      * Error state for the request/response currently being processed.
@@ -140,7 +140,7 @@ public abstract class AbstractProcessor<S> implements ActionHook, Processor<S> {
     /**
      * Set the socket wrapper being used.
      */
-    protected final void setSocketWrapper(SocketWrapper<S> socketWrapper) {
+    protected final void setSocketWrapper(SocketWrapperBase<S> socketWrapper) {
         this.socketWrapper = socketWrapper;
     }
 
@@ -148,7 +148,7 @@ public abstract class AbstractProcessor<S> implements ActionHook, Processor<S> {
     /**
      * Get the socket wrapper being used.
      */
-    protected final SocketWrapper<S> getSocketWrapper() {
+    protected final SocketWrapperBase<S> getSocketWrapper() {
         return socketWrapper;
     }
 
@@ -186,7 +186,7 @@ public abstract class AbstractProcessor<S> implements ActionHook, Processor<S> {
      * with although they may change type during processing.
      */
     @Override
-    public abstract SocketState process(SocketWrapper<S> socket) throws IOException;
+    public abstract SocketState process(SocketWrapperBase<S> socket) throws IOException;
 
     /**
      * Process in-progress Servlet 3.0 Async requests. These will start as HTTP

==================================================
Processor.java
index bfed8cc39e..13108200c9 100644
--- a/java/org/apache/coyote/AbstractProtocol.java
+++ b/java/org/apache/coyote/AbstractProtocol.java
@@ -42,7 +42,7 @@ import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler;
 import org.apache.tomcat.util.net.DispatchType;
 import org.apache.tomcat.util.net.SocketStatus;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 import org.apache.tomcat.util.res.StringManager;
 
 public abstract class AbstractProtocol<S> implements ProtocolHandler,
@@ -577,7 +577,7 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
         }
 
 
-        public SocketState process(SocketWrapper<S> wrapper,
+        public SocketState process(SocketWrapperBase<S> wrapper,
                 SocketStatus status) {
             if (wrapper == null) {
                 // Nothing to do. Socket has been closed.
@@ -754,15 +754,15 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
         }
 
         protected abstract P createProcessor();
-        protected abstract void initSsl(SocketWrapper<S> socket,
+        protected abstract void initSsl(SocketWrapperBase<S> socket,
                 Processor<S> processor);
-        protected abstract void longPoll(SocketWrapper<S> socket,
+        protected abstract void longPoll(SocketWrapperBase<S> socket,
                 Processor<S> processor);
-        protected abstract void release(SocketWrapper<S> socket,
+        protected abstract void release(SocketWrapperBase<S> socket,
                 Processor<S> processor, boolean socketClosing,
                 boolean addToPoller);
         protected abstract Processor<S> createUpgradeProcessor(
-                SocketWrapper<S> socket, ByteBuffer leftoverInput,
+                SocketWrapperBase<S> socket, ByteBuffer leftoverInput,
                 HttpUpgradeHandler httpUpgradeProcessor) throws IOException;
 
         protected void register(AbstractProcessor<S> processor) {

==================================================
AbstractAjpProcessor.java
index 991af90e4e..32dd298c5e 100644
--- a/java/org/apache/coyote/Processor.java
+++ b/java/org/apache/coyote/Processor.java
@@ -25,7 +25,7 @@ import javax.servlet.http.HttpUpgradeHandler;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.SSLSupport;
 import org.apache.tomcat.util.net.SocketStatus;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 
 /**
@@ -34,7 +34,7 @@ import org.apache.tomcat.util.net.SocketWrapper;
 public interface Processor<S> {
     Executor getExecutor();
 
-    SocketState process(SocketWrapper<S> socketWrapper) throws IOException;
+    SocketState process(SocketWrapperBase<S> socketWrapper) throws IOException;
 
     SocketState asyncDispatch(SocketStatus status);
     SocketState asyncPostProcess();

==================================================
AbstractAjpProtocol.java
index 3feff79f0e..3fbd40033d 100644
--- a/java/org/apache/coyote/ajp/AbstractAjpProcessor.java
+++ b/java/org/apache/coyote/ajp/AbstractAjpProcessor.java
@@ -53,7 +53,7 @@ import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.DispatchType;
 import org.apache.tomcat.util.net.SSLSupport;
 import org.apache.tomcat.util.net.SocketStatus;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 import org.apache.tomcat.util.res.StringManager;
 
 /**
@@ -716,7 +716,7 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
      * @throws IOException error during an I/O operation
      */
     @Override
-    public SocketState process(SocketWrapper<S> socket) throws IOException {
+    public SocketState process(SocketWrapperBase<S> socket) throws IOException {
 
         RequestInfo rp = request.getRequestProcessor();
         rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);
@@ -934,10 +934,10 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
             boolean block) throws IOException;
 
     // Methods called by process()
-    protected abstract void setupSocket(SocketWrapper<S> socketWrapper)
+    protected abstract void setupSocket(SocketWrapperBase<S> socketWrapper)
             throws IOException;
 
-    protected abstract void setTimeout(SocketWrapper<S> socketWrapper,
+    protected abstract void setTimeout(SocketWrapperBase<S> socketWrapper,
             int timeout) throws IOException;
 
     // Methods used by readMessage

==================================================
AjpAprProcessor.java
index 0612cb2413..f7418553b6 100644
--- a/java/org/apache/coyote/ajp/AbstractAjpProtocol.java
+++ b/java/org/apache/coyote/ajp/AbstractAjpProtocol.java
@@ -22,7 +22,7 @@ import javax.servlet.http.HttpUpgradeHandler;
 
 import org.apache.coyote.AbstractProtocol;
 import org.apache.coyote.Processor;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 import org.apache.tomcat.util.res.StringManager;
 
 public abstract class AbstractAjpProtocol<S> extends AbstractProtocol<S> {
@@ -89,19 +89,19 @@ public abstract class AbstractAjpProtocol<S> extends AbstractProtocol<S> {
             extends AbstractConnectionHandler<S, P> {
 
         @Override
-        protected void initSsl(SocketWrapper<S> socket, Processor<S> processor) {
+        protected void initSsl(SocketWrapperBase<S> socket, Processor<S> processor) {
             // NOOP for AJP
         }
 
         @Override
-        protected void longPoll(SocketWrapper<S> socket,
+        protected void longPoll(SocketWrapperBase<S> socket,
                 Processor<S> processor) {
             // Same requirements for all AJP connectors
             socket.setAsync(true);
         }
 
         @Override
-        protected P createUpgradeProcessor(SocketWrapper<S> socket, ByteBuffer leftoverInput,
+        protected P createUpgradeProcessor(SocketWrapperBase<S> socket, ByteBuffer leftoverInput,
                 HttpUpgradeHandler httpUpgradeHandler) {
             // TODO should fail - throw IOE
             return null;

==================================================
AjpAprProtocol.java
index ac7640c658..1fa8cddc85 100644
--- a/java/org/apache/coyote/ajp/AjpAprProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpAprProcessor.java
@@ -27,7 +27,7 @@ import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.jni.Socket;
 import org.apache.tomcat.jni.Status;
 import org.apache.tomcat.util.net.AprEndpoint;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 /**
  * Processes AJP requests.
@@ -87,7 +87,7 @@ public class AjpAprProcessor extends AbstractAjpProcessor<Long> {
 
 
     @Override
-    protected void setupSocket(SocketWrapper<Long> socketWrapper) {
+    protected void setupSocket(SocketWrapperBase<Long> socketWrapper) {
         long socketRef = socketWrapper.getSocket().longValue();
         Socket.setrbb(socketRef, inputBuffer);
         Socket.setsbb(socketRef, outputBuffer);
@@ -95,7 +95,7 @@ public class AjpAprProcessor extends AbstractAjpProcessor<Long> {
 
 
     @Override
-    protected void setTimeout(SocketWrapper<Long> socketWrapper,
+    protected void setTimeout(SocketWrapperBase<Long> socketWrapper,
             int timeout) throws IOException {
         Socket.timeoutSet(
                 socketWrapper.getSocket().longValue(), timeout * 1000);

==================================================
AjpNio2Processor.java
index 1a3ecb6735..3e1478e684 100644
--- a/java/org/apache/coyote/ajp/AjpAprProtocol.java
+++ b/java/org/apache/coyote/ajp/AjpAprProtocol.java
@@ -23,7 +23,7 @@ import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.AprEndpoint;
 import org.apache.tomcat.util.net.AprEndpoint.Handler;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 
 /**
@@ -127,7 +127,7 @@ public class AjpAprProtocol extends AbstractAjpProtocol<Long> {
          * required.
          */
         @Override
-        public void release(SocketWrapper<Long> socket,
+        public void release(SocketWrapperBase<Long> socket,
                 Processor<Long> processor, boolean isSocketClosing,
                 boolean addToPoller) {
             processor.recycle(isSocketClosing);

==================================================
AjpNio2Protocol.java
index 45a0cb19d8..3e9acc7b8f 100644
--- a/java/org/apache/coyote/ajp/AjpNio2Processor.java
+++ b/java/org/apache/coyote/ajp/AjpNio2Processor.java
@@ -28,7 +28,7 @@ import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.net.Nio2Channel;
 import org.apache.tomcat.util.net.Nio2Endpoint;
 import org.apache.tomcat.util.net.SocketStatus;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 /**
  * Processes AJP requests using NIO2.
@@ -44,7 +44,7 @@ public class AjpNio2Processor extends AbstractAjpProcessor<Nio2Channel> {
     /**
      * The completion handler used for asynchronous write operations
      */
-    protected CompletionHandler<Integer, SocketWrapper<Nio2Channel>> writeCompletionHandler;
+    protected CompletionHandler<Integer, SocketWrapperBase<Nio2Channel>> writeCompletionHandler;
 
     /**
      * Flipped flag for read buffer.
@@ -59,9 +59,9 @@ public class AjpNio2Processor extends AbstractAjpProcessor<Nio2Channel> {
     public AjpNio2Processor(int packetSize, Nio2Endpoint endpoint0) {
         super(packetSize, endpoint0);
         response.setOutputBuffer(new SocketOutputBuffer());
-        this.writeCompletionHandler = new CompletionHandler<Integer, SocketWrapper<Nio2Channel>>() {
+        this.writeCompletionHandler = new CompletionHandler<Integer, SocketWrapperBase<Nio2Channel>>() {
             @Override
-            public void completed(Integer nBytes, SocketWrapper<Nio2Channel> attachment) {
+            public void completed(Integer nBytes, SocketWrapperBase<Nio2Channel> attachment) {
                 boolean notify = false;
                 synchronized (writeCompletionHandler) {
                     if (nBytes.intValue() < 0) {
@@ -78,7 +78,7 @@ public class AjpNio2Processor extends AbstractAjpProcessor<Nio2Channel> {
                 }
             }
             @Override
-            public void failed(Throwable exc, SocketWrapper<Nio2Channel> attachment) {
+            public void failed(Throwable exc, SocketWrapperBase<Nio2Channel> attachment) {
                 attachment.setError(true);
                 writePending = false;
                 endpoint.processSocket(attachment, SocketStatus.DISCONNECT, true);
@@ -120,14 +120,14 @@ public class AjpNio2Processor extends AbstractAjpProcessor<Nio2Channel> {
 
 
     @Override
-    protected void setupSocket(SocketWrapper<Nio2Channel> socketWrapper)
+    protected void setupSocket(SocketWrapperBase<Nio2Channel> socketWrapper)
             throws IOException {
         // NO-OP
     }
 
 
     @Override
-    protected void setTimeout(SocketWrapper<Nio2Channel> socketWrapper,
+    protected void setTimeout(SocketWrapperBase<Nio2Channel> socketWrapper,
             int timeout) throws IOException {
         socketWrapper.setTimeout(timeout);
     }

==================================================
AjpNioProcessor.java
index d5ca5506be..9d3c3619bd 100644
--- a/java/org/apache/coyote/ajp/AjpNio2Protocol.java
+++ b/java/org/apache/coyote/ajp/AjpNio2Protocol.java
@@ -27,7 +27,7 @@ import org.apache.tomcat.util.net.Nio2Channel;
 import org.apache.tomcat.util.net.Nio2Endpoint;
 import org.apache.tomcat.util.net.Nio2Endpoint.Handler;
 import org.apache.tomcat.util.net.SSLImplementation;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 
 /**
@@ -116,7 +116,7 @@ public class AjpNio2Protocol extends AbstractAjpProtocol<Nio2Channel> {
          * close, errors etc.
          */
         @Override
-        public void release(SocketWrapper<Nio2Channel> socket) {
+        public void release(SocketWrapperBase<Nio2Channel> socket) {
             Processor<Nio2Channel> processor =
                     connections.remove(socket.getSocket());
             if (processor != null) {
@@ -130,7 +130,7 @@ public class AjpNio2Protocol extends AbstractAjpProtocol<Nio2Channel> {
          * required.
          */
         @Override
-        public void release(SocketWrapper<Nio2Channel> socket,
+        public void release(SocketWrapperBase<Nio2Channel> socket,
                 Processor<Nio2Channel> processor, boolean isSocketClosing,
                 boolean addToPoller) {
             processor.recycle(isSocketClosing);

==================================================
AjpNioProtocol.java
index de549c7220..0a5d33c683 100644
--- a/java/org/apache/coyote/ajp/AjpNioProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpNioProcessor.java
@@ -27,7 +27,7 @@ import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.net.NioChannel;
 import org.apache.tomcat.util.net.NioEndpoint;
 import org.apache.tomcat.util.net.NioSelectorPool;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 /**
  * Processes AJP requests using NIO.
@@ -60,8 +60,8 @@ public class AjpNioProcessor extends AbstractAjpProcessor<NioChannel> {
     @Override
     protected void registerForEvent(boolean read, boolean write) {
         final NioChannel socket = socketWrapper.getSocket();
-        final NioEndpoint.KeyAttachment attach =
-                (NioEndpoint.KeyAttachment) socket.getAttachment(false);
+        final NioEndpoint.NioSocketWrapper attach =
+                (NioEndpoint.NioSocketWrapper) socket.getAttachment(false);
         if (attach == null) {
             return;
         }
@@ -82,8 +82,8 @@ public class AjpNioProcessor extends AbstractAjpProcessor<NioChannel> {
         // The NIO connector uses the timeout configured on the wrapper in the
         // poller. Therefore, it needs to be reset once asycn processing has
         // finished.
-        final NioEndpoint.KeyAttachment attach =
-                (NioEndpoint.KeyAttachment)socketWrapper.getSocket().getAttachment(false);
+        final NioEndpoint.NioSocketWrapper attach =
+                (NioEndpoint.NioSocketWrapper)socketWrapper.getSocket().getAttachment(false);
         if (!getErrorState().isError() && attach != null &&
                 asyncStateMachine.isAsyncDispatching()) {
             long soTimeout = endpoint.getSoTimeout();
@@ -100,14 +100,14 @@ public class AjpNioProcessor extends AbstractAjpProcessor<NioChannel> {
 
 
     @Override
-    protected void setupSocket(SocketWrapper<NioChannel> socketWrapper)
+    protected void setupSocket(SocketWrapperBase<NioChannel> socketWrapper)
             throws IOException {
         // NO-OP
     }
 
 
     @Override
-    protected void setTimeout(SocketWrapper<NioChannel> socketWrapper,
+    protected void setTimeout(SocketWrapperBase<NioChannel> socketWrapper,
             int timeout) throws IOException {
         socketWrapper.setTimeout(timeout);
     }
@@ -117,8 +117,8 @@ public class AjpNioProcessor extends AbstractAjpProcessor<NioChannel> {
     protected int output(byte[] src, int offset, int length, boolean block)
             throws IOException {
 
-        NioEndpoint.KeyAttachment att =
-                (NioEndpoint.KeyAttachment) socketWrapper.getSocket().getAttachment(false);
+        NioEndpoint.NioSocketWrapper att =
+                (NioEndpoint.NioSocketWrapper) socketWrapper.getSocket().getAttachment(false);
         if ( att == null ) throw new IOException("Key must be cancelled");
 
         ByteBuffer writeBuffer =
@@ -185,8 +185,8 @@ public class AjpNioProcessor extends AbstractAjpProcessor<NioChannel> {
                 // Ignore
             }
             try {
-                NioEndpoint.KeyAttachment att =
-                        (NioEndpoint.KeyAttachment) socketWrapper.getSocket().getAttachment(false);
+                NioEndpoint.NioSocketWrapper att =
+                        (NioEndpoint.NioSocketWrapper) socketWrapper.getSocket().getAttachment(false);
                 if ( att == null ) throw new IOException("Key must be cancelled.");
                 nRead = pool.read(readBuffer, socketWrapper.getSocket(),
                         selector, att.getTimeout());

==================================================
AbstractHttp11Processor.java
index 35a239a7c0..a79013eb8d 100644
--- a/java/org/apache/coyote/ajp/AjpNioProtocol.java
+++ b/java/org/apache/coyote/ajp/AjpNioProtocol.java
@@ -30,7 +30,7 @@ import org.apache.tomcat.util.net.NioChannel;
 import org.apache.tomcat.util.net.NioEndpoint;
 import org.apache.tomcat.util.net.NioEndpoint.Handler;
 import org.apache.tomcat.util.net.SSLImplementation;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 
 /**
@@ -145,7 +145,7 @@ public class AjpNioProtocol extends AbstractAjpProtocol<NioChannel> {
          * close, errors etc.
          */
         @Override
-        public void release(SocketWrapper<NioChannel> socket) {
+        public void release(SocketWrapperBase<NioChannel> socket) {
             Processor<NioChannel> processor =
                     connections.remove(socket.getSocket());
             if (processor != null) {
@@ -159,7 +159,7 @@ public class AjpNioProtocol extends AbstractAjpProtocol<NioChannel> {
          * required.
          */
         @Override
-        public void release(SocketWrapper<NioChannel> socket,
+        public void release(SocketWrapperBase<NioChannel> socket,
                 Processor<NioChannel> processor, boolean isSocketClosing,
                 boolean addToPoller) {
             processor.recycle(isSocketClosing);

==================================================
AbstractInputBuffer.java
index f22e556ac7..d803bf3e3e 100644
--- a/java/org/apache/coyote/http11/AbstractHttp11Processor.java
+++ b/java/org/apache/coyote/http11/AbstractHttp11Processor.java
@@ -54,7 +54,7 @@ import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.DispatchType;
 import org.apache.tomcat.util.net.SocketStatus;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 import org.apache.tomcat.util.res.StringManager;
 
 public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
@@ -897,7 +897,7 @@ public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
             break;
         }
         case DISPATCH_EXECUTE: {
-            SocketWrapper<S> wrapper = socketWrapper;
+            SocketWrapperBase<S> wrapper = socketWrapper;
             if (wrapper != null) {
                 getEndpoint().executeNonBlockingDispatches(wrapper);
             }
@@ -958,7 +958,7 @@ public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
      * @throws IOException error during an I/O operation
      */
     @Override
-    public SocketState process(SocketWrapper<S> socketWrapper)
+    public SocketState process(SocketWrapperBase<S> socketWrapper)
         throws IOException {
         RequestInfo rp = request.getRequestProcessor();
         rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);
@@ -1766,7 +1766,7 @@ public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
      * @return true if the keep-alive loop should be broken
      */
     protected abstract boolean breakKeepAliveLoop(
-            SocketWrapper<S> socketWrapper);
+            SocketWrapperBase<S> socketWrapper);
 
 
     @Override

==================================================
AbstractOutputBuffer.java
index 92ffd1f8a6..bfdec61799 100644
--- a/java/org/apache/coyote/http11/AbstractInputBuffer.java
+++ b/java/org/apache/coyote/http11/AbstractInputBuffer.java
@@ -25,7 +25,7 @@ import org.apache.juli.logging.Log;
 import org.apache.tomcat.util.buf.ByteChunk;
 import org.apache.tomcat.util.http.MimeHeaders;
 import org.apache.tomcat.util.net.AbstractEndpoint;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 import org.apache.tomcat.util.res.StringManager;
 
 public abstract class AbstractInputBuffer<S> implements InputBuffer{
@@ -246,7 +246,7 @@ public abstract class AbstractInputBuffer<S> implements InputBuffer{
      */
     protected abstract boolean fill(boolean block) throws IOException;
 
-    protected abstract void init(SocketWrapper<S> socketWrapper,
+    protected abstract void init(SocketWrapperBase<S> socketWrapper,
             AbstractEndpoint<S> endpoint) throws IOException;
 
     protected abstract Log getLog();

==================================================
Http11AprProcessor.java
index 401174bf06..53cdb6500c 100644
--- a/java/org/apache/coyote/http11/AbstractOutputBuffer.java
+++ b/java/org/apache/coyote/http11/AbstractOutputBuffer.java
@@ -31,7 +31,7 @@ import org.apache.tomcat.util.buf.ByteChunk;
 import org.apache.tomcat.util.buf.MessageBytes;
 import org.apache.tomcat.util.http.HttpMessages;
 import org.apache.tomcat.util.net.AbstractEndpoint;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 import org.apache.tomcat.util.res.StringManager;
 
 public abstract class AbstractOutputBuffer<S> implements OutputBuffer {
@@ -381,7 +381,7 @@ public abstract class AbstractOutputBuffer<S> implements OutputBuffer {
     }
 
 
-    public abstract void init(SocketWrapper<S> socketWrapper,
+    public abstract void init(SocketWrapperBase<S> socketWrapper,
             AbstractEndpoint<S> endpoint) throws IOException;
 
     public abstract void sendAck() throws IOException;

==================================================
Http11AprProtocol.java
index 9241f07c96..1324224653 100644
--- a/java/org/apache/coyote/http11/Http11AprProcessor.java
+++ b/java/org/apache/coyote/http11/Http11AprProcessor.java
@@ -33,7 +33,7 @@ import org.apache.tomcat.jni.Sockaddr;
 import org.apache.tomcat.jni.Socket;
 import org.apache.tomcat.util.net.AprEndpoint;
 import org.apache.tomcat.util.net.SSLSupport;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 
 /**
@@ -140,7 +140,7 @@ public class Http11AprProcessor extends AbstractHttp11Processor<Long> {
 
 
     @Override
-    protected boolean breakKeepAliveLoop(SocketWrapper<Long> socketWrapper) {
+    protected boolean breakKeepAliveLoop(SocketWrapperBase<Long> socketWrapper) {
         openSocket = keepAlive;
         // Do sendfile as needed: add socket to sendfile and end
         if (sendfileData != null && !getErrorState().isError()) {

==================================================
Http11Nio2Processor.java
index 7783553308..829f2e9933 100644
--- a/java/org/apache/coyote/http11/Http11AprProtocol.java
+++ b/java/org/apache/coyote/http11/Http11AprProtocol.java
@@ -31,7 +31,7 @@ import org.apache.tomcat.util.net.AprEndpoint;
 import org.apache.tomcat.util.net.AprEndpoint.Handler;
 import org.apache.tomcat.util.net.AprEndpoint.Poller;
 import org.apache.tomcat.util.net.SocketStatus;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 
 /**
@@ -248,7 +248,7 @@ public class Http11AprProtocol extends AbstractHttp11Protocol<Long> {
          * @param addToPoller
          */
         @Override
-        public void release(SocketWrapper<Long> socket,
+        public void release(SocketWrapperBase<Long> socket,
                 Processor<Long> processor, boolean isSocketClosing,
                 boolean addToPoller) {
             processor.recycle(isSocketClosing);
@@ -261,7 +261,7 @@ public class Http11AprProtocol extends AbstractHttp11Protocol<Long> {
         }
 
         @Override
-        public SocketState process(SocketWrapper<Long> socket,
+        public SocketState process(SocketWrapperBase<Long> socket,
                 SocketStatus status) {
             if (proto.npnHandler != null) {
                 Processor<Long> processor = null;
@@ -283,13 +283,13 @@ public class Http11AprProtocol extends AbstractHttp11Protocol<Long> {
         }
 
         @Override
-        protected void initSsl(SocketWrapper<Long> socket,
+        protected void initSsl(SocketWrapperBase<Long> socket,
                 Processor<Long> processor) {
             // NOOP for APR
         }
 
         @Override
-        protected void longPoll(SocketWrapper<Long> socket,
+        protected void longPoll(SocketWrapperBase<Long> socket,
                 Processor<Long> processor) {
 
             if (processor.isAsync()) {
@@ -322,7 +322,7 @@ public class Http11AprProtocol extends AbstractHttp11Protocol<Long> {
 
         @Override
         protected Processor<Long> createUpgradeProcessor(
-                SocketWrapper<Long> socket, ByteBuffer leftoverInput,
+                SocketWrapperBase<Long> socket, ByteBuffer leftoverInput,
                 HttpUpgradeHandler httpUpgradeProcessor)
                 throws IOException {
             return new AprProcessor(socket, leftoverInput,

==================================================
Http11Nio2Protocol.java
index 6e3df5d531..bc7fc8de76 100644
--- a/java/org/apache/coyote/http11/Http11Nio2Processor.java
+++ b/java/org/apache/coyote/http11/Http11Nio2Processor.java
@@ -33,7 +33,7 @@ import org.apache.tomcat.util.net.Nio2Endpoint;
 import org.apache.tomcat.util.net.SSLSupport;
 import org.apache.tomcat.util.net.SecureNio2Channel;
 import org.apache.tomcat.util.net.SocketStatus;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 
 /**
@@ -190,7 +190,7 @@ public class Http11Nio2Processor extends AbstractHttp11Processor<Nio2Channel> {
 
     @Override
     protected boolean breakKeepAliveLoop(
-            SocketWrapper<Nio2Channel> socketWrapper) {
+            SocketWrapperBase<Nio2Channel> socketWrapper) {
         openSocket = keepAlive;
         // Do sendfile as needed: add socket to sendfile and end
         if (sendfileData != null && !getErrorState().isError()) {

==================================================
Http11NioProcessor.java
index a62d08625c..111f80f52a 100644
--- a/java/org/apache/coyote/http11/Http11Nio2Protocol.java
+++ b/java/org/apache/coyote/http11/Http11Nio2Protocol.java
@@ -36,7 +36,7 @@ import org.apache.tomcat.util.net.Nio2Endpoint.Nio2SocketWrapper;
 import org.apache.tomcat.util.net.SSLImplementation;
 import org.apache.tomcat.util.net.SecureNio2Channel;
 import org.apache.tomcat.util.net.SocketStatus;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 
 /**
@@ -160,7 +160,7 @@ public class Http11Nio2Protocol extends AbstractHttp11JsseProtocol<Nio2Channel>
          * close, errors etc.
          */
         @Override
-        public void release(SocketWrapper<Nio2Channel> socket) {
+        public void release(SocketWrapperBase<Nio2Channel> socket) {
             Processor<Nio2Channel> processor =
                 connections.remove(socket.getSocket());
             if (processor != null) {
@@ -170,7 +170,7 @@ public class Http11Nio2Protocol extends AbstractHttp11JsseProtocol<Nio2Channel>
         }
 
         @Override
-        public SocketState process(SocketWrapper<Nio2Channel> socket,
+        public SocketState process(SocketWrapperBase<Nio2Channel> socket,
                 SocketStatus status) {
             if (proto.npnHandler != null) {
                 SocketState ss = proto.npnHandler.process(socket, status);
@@ -192,7 +192,7 @@ public class Http11Nio2Protocol extends AbstractHttp11JsseProtocol<Nio2Channel>
          * @param addToPoller
          */
         @Override
-        public void release(SocketWrapper<Nio2Channel> socket,
+        public void release(SocketWrapperBase<Nio2Channel> socket,
                 Processor<Nio2Channel> processor, boolean isSocketClosing,
                 boolean addToPoller) {
             processor.recycle(isSocketClosing);
@@ -207,7 +207,7 @@ public class Http11Nio2Protocol extends AbstractHttp11JsseProtocol<Nio2Channel>
 
 
         @Override
-        protected void initSsl(SocketWrapper<Nio2Channel> socket,
+        protected void initSsl(SocketWrapperBase<Nio2Channel> socket,
                 Processor<Nio2Channel> processor) {
             if (proto.isSSLEnabled() &&
                     (proto.sslImplementation != null)
@@ -223,7 +223,7 @@ public class Http11Nio2Protocol extends AbstractHttp11JsseProtocol<Nio2Channel>
         }
 
         @Override
-        protected void longPoll(SocketWrapper<Nio2Channel> socket,
+        protected void longPoll(SocketWrapperBase<Nio2Channel> socket,
                 Processor<Nio2Channel> processor) {
             if (processor.isAsync()) {
                 socket.setAsync(true);
@@ -261,7 +261,7 @@ public class Http11Nio2Protocol extends AbstractHttp11JsseProtocol<Nio2Channel>
 
         @Override
         protected Processor<Nio2Channel> createUpgradeProcessor(
-                SocketWrapper<Nio2Channel> socket, ByteBuffer leftoverInput,
+                SocketWrapperBase<Nio2Channel> socket, ByteBuffer leftoverInput,
                 HttpUpgradeHandler httpUpgradeProcessor)
                 throws IOException {
             return new Nio2Processor(proto.endpoint, socket, leftoverInput,

==================================================
Http11NioProtocol.java
index c9b358d14d..717f4d498b 100644
--- a/java/org/apache/coyote/http11/Http11NioProcessor.java
+++ b/java/org/apache/coyote/http11/Http11NioProcessor.java
@@ -29,10 +29,10 @@ import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.net.NioChannel;
 import org.apache.tomcat.util.net.NioEndpoint;
-import org.apache.tomcat.util.net.NioEndpoint.KeyAttachment;
+import org.apache.tomcat.util.net.NioEndpoint.NioSocketWrapper;
 import org.apache.tomcat.util.net.SSLSupport;
 import org.apache.tomcat.util.net.SecureNioChannel;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 
 /**
@@ -99,7 +99,7 @@ public class Http11NioProcessor extends AbstractHttp11Processor<NioChannel> {
 
     @Override
     protected void resetTimeouts() {
-        final NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment)socketWrapper.getSocket().getAttachment(false);
+        final NioEndpoint.NioSocketWrapper attach = (NioEndpoint.NioSocketWrapper)socketWrapper.getSocket().getAttachment(false);
         if (!getErrorState().isError() && attach != null &&
                 asyncStateMachine.isAsyncDispatching()) {
             long soTimeout = endpoint.getSoTimeout();
@@ -179,17 +179,17 @@ public class Http11NioProcessor extends AbstractHttp11Processor<NioChannel> {
 
 
     @Override
-    protected boolean breakKeepAliveLoop(SocketWrapper<NioChannel> socketWrapper) {
+    protected boolean breakKeepAliveLoop(SocketWrapperBase<NioChannel> socketWrapper) {
         openSocket = keepAlive;
         // Do sendfile as needed: add socket to sendfile and end
         if (sendfileData != null && !getErrorState().isError()) {
-            ((KeyAttachment) socketWrapper).setSendfileData(sendfileData);
+            ((NioSocketWrapper) socketWrapper).setSendfileData(sendfileData);
             sendfileData.keepAlive = keepAlive;
             SelectionKey key = socketWrapper.getSocket().getIOChannel().keyFor(
                     socketWrapper.getSocket().getPoller().getSelector());
             //do the first write on this thread, might as well
             if (socketWrapper.getSocket().getPoller().processSendfile(key,
-                    (KeyAttachment) socketWrapper, true)) {
+                    (NioSocketWrapper) socketWrapper, true)) {
                 sendfileInProgress = true;
             } else {
                 // Write failed

==================================================
InternalAprInputBuffer.java
index 43f445513c..23d71f1a08 100644
--- a/java/org/apache/coyote/http11/Http11NioProtocol.java
+++ b/java/org/apache/coyote/http11/Http11NioProtocol.java
@@ -36,7 +36,7 @@ import org.apache.tomcat.util.net.NioEndpoint.Handler;
 import org.apache.tomcat.util.net.SSLImplementation;
 import org.apache.tomcat.util.net.SecureNioChannel;
 import org.apache.tomcat.util.net.SocketStatus;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 
 /**
@@ -206,7 +206,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol<NioChannel> {
          * close, errors etc.
          */
         @Override
-        public void release(SocketWrapper<NioChannel> socket) {
+        public void release(SocketWrapperBase<NioChannel> socket) {
             Processor<NioChannel> processor =
                 connections.remove(socket.getSocket());
             if (processor != null) {
@@ -216,7 +216,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol<NioChannel> {
         }
 
         @Override
-        public SocketState process(SocketWrapper<NioChannel> socket,
+        public SocketState process(SocketWrapperBase<NioChannel> socket,
                 SocketStatus status) {
             if (proto.npnHandler != null) {
                 SocketState ss = proto.npnHandler.process(socket, status);
@@ -238,7 +238,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol<NioChannel> {
          * @param addToPoller
          */
         @Override
-        public void release(SocketWrapper<NioChannel> socket,
+        public void release(SocketWrapperBase<NioChannel> socket,
                 Processor<NioChannel> processor, boolean isSocketClosing,
                 boolean addToPoller) {
             processor.recycle(isSocketClosing);
@@ -250,7 +250,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol<NioChannel> {
 
 
         @Override
-        protected void initSsl(SocketWrapper<NioChannel> socket,
+        protected void initSsl(SocketWrapperBase<NioChannel> socket,
                 Processor<NioChannel> processor) {
             if (proto.isSSLEnabled() &&
                     (proto.sslImplementation != null)
@@ -266,7 +266,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol<NioChannel> {
         }
 
         @Override
-        protected void longPoll(SocketWrapper<NioChannel> socket,
+        protected void longPoll(SocketWrapperBase<NioChannel> socket,
                 Processor<NioChannel> processor) {
 
             if (processor.isAsync()) {
@@ -293,7 +293,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol<NioChannel> {
 
         @Override
         protected Processor<NioChannel> createUpgradeProcessor(
-                SocketWrapper<NioChannel> socket, ByteBuffer leftoverInput,
+                SocketWrapperBase<NioChannel> socket, ByteBuffer leftoverInput,
                 HttpUpgradeHandler httpUpgradeProcessor)
                 throws IOException {
             return new NioProcessor(socket, leftoverInput, httpUpgradeProcessor,

==================================================
InternalAprOutputBuffer.java
index cf8ab1c358..f9f20d970c 100644
--- a/java/org/apache/coyote/http11/InternalAprInputBuffer.java
+++ b/java/org/apache/coyote/http11/InternalAprInputBuffer.java
@@ -33,7 +33,7 @@ import org.apache.tomcat.jni.Status;
 import org.apache.tomcat.util.buf.ByteChunk;
 import org.apache.tomcat.util.buf.MessageBytes;
 import org.apache.tomcat.util.net.AbstractEndpoint;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 /**
  * Implementation of InputBuffer which provides HTTP request header parsing as
@@ -91,7 +91,7 @@ public class InternalAprInputBuffer extends AbstractInputBuffer<Long> {
     private long socket;
 
 
-    private SocketWrapper<Long> wrapper;
+    private SocketWrapperBase<Long> wrapper;
 
 
     // --------------------------------------------------------- Public Methods
@@ -547,7 +547,7 @@ public class InternalAprInputBuffer extends AbstractInputBuffer<Long> {
     // ------------------------------------------------------ Protected Methods
 
     @Override
-    protected void init(SocketWrapper<Long> socketWrapper,
+    protected void init(SocketWrapperBase<Long> socketWrapper,
             AbstractEndpoint<Long> endpoint) throws IOException {
 
         socket = socketWrapper.getSocket().longValue();

==================================================
InternalNio2InputBuffer.java
index 73a323ead5..392f146302 100644
--- a/java/org/apache/coyote/http11/InternalAprOutputBuffer.java
+++ b/java/org/apache/coyote/http11/InternalAprOutputBuffer.java
@@ -31,7 +31,7 @@ import org.apache.tomcat.jni.Status;
 import org.apache.tomcat.util.buf.ByteChunk;
 import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.AprEndpoint;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 /**
  * Output buffer.
@@ -68,7 +68,7 @@ public class InternalAprOutputBuffer extends AbstractOutputBuffer<Long> {
     private long socket;
 
 
-    private SocketWrapper<Long> wrapper;
+    private SocketWrapperBase<Long> wrapper;
 
 
     /**
@@ -90,7 +90,7 @@ public class InternalAprOutputBuffer extends AbstractOutputBuffer<Long> {
     // --------------------------------------------------------- Public Methods
 
     @Override
-    public void init(SocketWrapper<Long> socketWrapper,
+    public void init(SocketWrapperBase<Long> socketWrapper,
             AbstractEndpoint<Long> endpoint) throws IOException {
 
         wrapper = socketWrapper;

==================================================
InternalNio2OutputBuffer.java
index 3b81d4f2e0..ae87b3d62f 100644
--- a/java/org/apache/coyote/http11/InternalNio2InputBuffer.java
+++ b/java/org/apache/coyote/http11/InternalNio2InputBuffer.java
@@ -36,7 +36,7 @@ import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.Nio2Channel;
 import org.apache.tomcat.util.net.Nio2Endpoint;
 import org.apache.tomcat.util.net.SocketStatus;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 /**
  * Output buffer implementation for NIO2.
@@ -57,7 +57,7 @@ public class InternalNio2InputBuffer extends AbstractNioInputBuffer<Nio2Channel>
     /**
      * Underlying socket.
      */
-    private SocketWrapper<Nio2Channel> socket;
+    private SocketWrapperBase<Nio2Channel> socket;
 
     /**
      * Track write interest
@@ -67,7 +67,7 @@ public class InternalNio2InputBuffer extends AbstractNioInputBuffer<Nio2Channel>
     /**
      * The completion handler used for asynchronous read operations
      */
-    private CompletionHandler<Integer, SocketWrapper<Nio2Channel>> completionHandler;
+    private CompletionHandler<Integer, SocketWrapperBase<Nio2Channel>> completionHandler;
 
     /**
      * The associated endpoint.
@@ -131,7 +131,7 @@ public class InternalNio2InputBuffer extends AbstractNioInputBuffer<Nio2Channel>
     // ------------------------------------------------------ Protected Methods
 
     @Override
-    protected void init(SocketWrapper<Nio2Channel> socketWrapper,
+    protected void init(SocketWrapperBase<Nio2Channel> socketWrapper,
             AbstractEndpoint<Nio2Channel> associatedEndpoint) throws IOException {
 
         endpoint = associatedEndpoint;
@@ -149,10 +149,10 @@ public class InternalNio2InputBuffer extends AbstractNioInputBuffer<Nio2Channel>
         }
 
         // Initialize the completion handler
-        this.completionHandler = new CompletionHandler<Integer, SocketWrapper<Nio2Channel>>() {
+        this.completionHandler = new CompletionHandler<Integer, SocketWrapperBase<Nio2Channel>>() {
 
             @Override
-            public void completed(Integer nBytes, SocketWrapper<Nio2Channel> attachment) {
+            public void completed(Integer nBytes, SocketWrapperBase<Nio2Channel> attachment) {
                 boolean notify = false;
                 synchronized (completionHandler) {
                     if (nBytes.intValue() < 0) {
@@ -171,7 +171,7 @@ public class InternalNio2InputBuffer extends AbstractNioInputBuffer<Nio2Channel>
             }
 
             @Override
-            public void failed(Throwable exc, SocketWrapper<Nio2Channel> attachment) {
+            public void failed(Throwable exc, SocketWrapperBase<Nio2Channel> attachment) {
                 attachment.setError(true);
                 if (exc instanceof IOException) {
                     e = (IOException) exc;

==================================================
InternalNioInputBuffer.java
index 555570b60e..05ee47202e 100644
--- a/java/org/apache/coyote/http11/InternalNio2OutputBuffer.java
+++ b/java/org/apache/coyote/http11/InternalNio2OutputBuffer.java
@@ -37,7 +37,7 @@ import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.Nio2Channel;
 import org.apache.tomcat.util.net.Nio2Endpoint;
 import org.apache.tomcat.util.net.SocketStatus;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 /**
  * Output buffer implementation for NIO2.
@@ -59,7 +59,7 @@ public class InternalNio2OutputBuffer extends AbstractOutputBuffer<Nio2Channel>
     /**
      * Underlying socket.
      */
-    private SocketWrapper<Nio2Channel> socket;
+    private SocketWrapperBase<Nio2Channel> socket;
 
     /**
      * Track write interest
@@ -104,7 +104,7 @@ public class InternalNio2OutputBuffer extends AbstractOutputBuffer<Nio2Channel>
     // --------------------------------------------------------- Public Methods
 
     @Override
-    public void init(SocketWrapper<Nio2Channel> socketWrapper,
+    public void init(SocketWrapperBase<Nio2Channel> socketWrapper,
             AbstractEndpoint<Nio2Channel> associatedEndpoint) throws IOException {
         this.socket = socketWrapper;
         this.endpoint = associatedEndpoint;

==================================================
InternalNioOutputBuffer.java
index bdc84c0c5d..fad0e057f8 100644
--- a/java/org/apache/coyote/http11/InternalNioInputBuffer.java
+++ b/java/org/apache/coyote/http11/InternalNioInputBuffer.java
@@ -30,7 +30,7 @@ import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.NioChannel;
 import org.apache.tomcat.util.net.NioEndpoint;
 import org.apache.tomcat.util.net.NioSelectorPool;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 /**
  * Implementation of InputBuffer which provides HTTP request header parsing as
@@ -84,7 +84,7 @@ public class InternalNioInputBuffer extends AbstractNioInputBuffer<NioChannel> {
     // ------------------------------------------------------ Protected Methods
 
     @Override
-    protected void init(SocketWrapper<NioChannel> socketWrapper,
+    protected void init(SocketWrapperBase<NioChannel> socketWrapper,
             AbstractEndpoint<NioChannel> endpoint) throws IOException {
 
         socket = socketWrapper.getSocket();
@@ -125,8 +125,8 @@ public class InternalNioInputBuffer extends AbstractNioInputBuffer<NioChannel> {
                 // Ignore
             }
             try {
-                NioEndpoint.KeyAttachment att =
-                        (NioEndpoint.KeyAttachment) socket.getAttachment(false);
+                NioEndpoint.NioSocketWrapper att =
+                        (NioEndpoint.NioSocketWrapper) socket.getAttachment(false);
                 if (att == null) {
                     throw new IOException("Key must be cancelled.");
                 }

==================================================
NpnHandler.java
index 6a1474b413..1231e90a4b 100644
--- a/java/org/apache/coyote/http11/InternalNioOutputBuffer.java
+++ b/java/org/apache/coyote/http11/InternalNioOutputBuffer.java
@@ -31,7 +31,7 @@ import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.NioChannel;
 import org.apache.tomcat.util.net.NioEndpoint;
 import org.apache.tomcat.util.net.NioSelectorPool;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 /**
  * Output buffer.
@@ -72,7 +72,7 @@ public class InternalNioOutputBuffer extends AbstractOutputBuffer<NioChannel> {
     // --------------------------------------------------------- Public Methods
 
     @Override
-    public void init(SocketWrapper<NioChannel> socketWrapper,
+    public void init(SocketWrapperBase<NioChannel> socketWrapper,
             AbstractEndpoint<NioChannel> endpoint) throws IOException {
 
         socket = socketWrapper.getSocket();
@@ -126,7 +126,7 @@ public class InternalNioOutputBuffer extends AbstractOutputBuffer<NioChannel> {
         }
 
         int written = 0;
-        NioEndpoint.KeyAttachment att = (NioEndpoint.KeyAttachment)socket.getAttachment(false);
+        NioEndpoint.NioSocketWrapper att = (NioEndpoint.NioSocketWrapper)socket.getAttachment(false);
         if ( att == null ) throw new IOException("Key must be cancelled");
         long writeTimeout = att.getWriteTimeout();
         Selector selector = null;
@@ -203,7 +203,7 @@ public class InternalNioOutputBuffer extends AbstractOutputBuffer<NioChannel> {
             }
         }
 
-        NioEndpoint.KeyAttachment ka = (NioEndpoint.KeyAttachment)socket.getAttachment(false);
+        NioEndpoint.NioSocketWrapper ka = (NioEndpoint.NioSocketWrapper)socket.getAttachment(false);
         if (ka != null) ka.access();//prevent timeouts for just doing client writes
 
         if (!isBlocking() && length > 0) {
@@ -233,7 +233,7 @@ public class InternalNioOutputBuffer extends AbstractOutputBuffer<NioChannel> {
         //prevent timeout for async,
         SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());
         if (key != null) {
-            NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment) key.attachment();
+            NioEndpoint.NioSocketWrapper attach = (NioEndpoint.NioSocketWrapper) key.attachment();
             attach.access();
         }
 
@@ -275,7 +275,7 @@ public class InternalNioOutputBuffer extends AbstractOutputBuffer<NioChannel> {
 
     @Override
     protected void registerWriteInterest() throws IOException {
-        NioEndpoint.KeyAttachment att = (NioEndpoint.KeyAttachment)socket.getAttachment(false);
+        NioEndpoint.NioSocketWrapper att = (NioEndpoint.NioSocketWrapper)socket.getAttachment(false);
         if (att == null) {
             throw new IOException("Key must be cancelled");
         }

==================================================
AbstractProcessor.java
index 5c002990b4..884be85813 100644
--- a/java/org/apache/coyote/http11/NpnHandler.java
+++ b/java/org/apache/coyote/http11/NpnHandler.java
@@ -21,7 +21,7 @@ import org.apache.coyote.Adapter;
 import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.SocketStatus;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 /**
  * Interface specific for protocols that negotiate at NPN level, like
@@ -37,7 +37,7 @@ public interface NpnHandler<S> {
      * @return OPEN if the socket doesn't have the right npn.
      *    CLOSE if processing is done. LONG to request read polling.
      */
-    SocketState process(SocketWrapper<S> socket, SocketStatus status);
+    SocketState process(SocketWrapperBase<S> socket, SocketStatus status);
 
     /**
      * Initialize the npn handler.

==================================================
AbstractServletOutputStream.java
index 68cf01531c..b62a9fbc3b 100644
--- a/java/org/apache/coyote/http11/upgrade/AbstractProcessor.java
+++ b/java/org/apache/coyote/http11/upgrade/AbstractProcessor.java
@@ -31,7 +31,7 @@ import org.apache.juli.logging.Log;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.SSLSupport;
 import org.apache.tomcat.util.net.SocketStatus;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 import org.apache.tomcat.util.res.StringManager;
 
 public abstract class AbstractProcessor<S>
@@ -135,7 +135,7 @@ public abstract class AbstractProcessor<S>
     }
 
     @Override
-    public final SocketState process(SocketWrapper<S> socketWrapper)
+    public final SocketState process(SocketWrapperBase<S> socketWrapper)
             throws IOException {
         return null;
     }

==================================================
AprProcessor.java
index 94742fdac4..8d77c4ffe2 100644
--- a/java/org/apache/coyote/http11/upgrade/AbstractServletOutputStream.java
+++ b/java/org/apache/coyote/http11/upgrade/AbstractServletOutputStream.java
@@ -23,7 +23,7 @@ import javax.servlet.WriteListener;
 
 import org.apache.tomcat.util.ExceptionUtils;
 import org.apache.tomcat.util.net.DispatchType;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 import org.apache.tomcat.util.res.StringManager;
 
 public abstract class AbstractServletOutputStream<S> extends ServletOutputStream {
@@ -31,7 +31,7 @@ public abstract class AbstractServletOutputStream<S> extends ServletOutputStream
     protected static final StringManager sm =
             StringManager.getManager(Constants.Package);
 
-    protected final SocketWrapper<S> socketWrapper;
+    protected final SocketWrapperBase<S> socketWrapper;
 
     // Used to ensure that isReady() and onWritePossible() have a consistent
     // view of buffer and fireListener when determining if the listener should
@@ -62,7 +62,7 @@ public abstract class AbstractServletOutputStream<S> extends ServletOutputStream
     private final int asyncWriteBufferSize;
 
 
-    public AbstractServletOutputStream(SocketWrapper<S> socketWrapper,
+    public AbstractServletOutputStream(SocketWrapperBase<S> socketWrapper,
             int asyncWriteBufferSize) {
         this.socketWrapper = socketWrapper;
         this.asyncWriteBufferSize = asyncWriteBufferSize;

==================================================
AprServletInputStream.java
index 2dd619cffb..a5fbeeea32 100644
--- a/java/org/apache/coyote/http11/upgrade/AprProcessor.java
+++ b/java/org/apache/coyote/http11/upgrade/AprProcessor.java
@@ -24,7 +24,7 @@ import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.jni.Socket;
 import org.apache.tomcat.util.net.AprEndpoint;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 public class AprProcessor extends AbstractProcessor<Long> {
 
@@ -34,7 +34,7 @@ public class AprProcessor extends AbstractProcessor<Long> {
 
     private static final int INFINITE_TIMEOUT = -1;
 
-    public AprProcessor(SocketWrapper<Long> wrapper, ByteBuffer leftoverInput,
+    public AprProcessor(SocketWrapperBase<Long> wrapper, ByteBuffer leftoverInput,
             HttpUpgradeHandler httpUpgradeProcessor, AprEndpoint endpoint,
             int asyncWriteBufferSize) {
         super(httpUpgradeProcessor,

==================================================
AprServletOutputStream.java
index add50ef214..9680340516 100644
--- a/java/org/apache/coyote/http11/upgrade/AprServletInputStream.java
+++ b/java/org/apache/coyote/http11/upgrade/AprServletInputStream.java
@@ -27,20 +27,20 @@ import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.jni.OS;
 import org.apache.tomcat.jni.Socket;
 import org.apache.tomcat.jni.Status;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 public class AprServletInputStream extends AbstractServletInputStream {
 
     private static final Log log = LogFactory.getLog(AprServletInputStream.class);
 
-    private final SocketWrapper<Long> wrapper;
+    private final SocketWrapperBase<Long> wrapper;
     private final long socket;
     private ByteBuffer leftoverInput;
     private volatile boolean eagain = false;
     private volatile boolean closed = false;
 
 
-    public AprServletInputStream(SocketWrapper<Long> wrapper, ByteBuffer leftoverInput) {
+    public AprServletInputStream(SocketWrapperBase<Long> wrapper, ByteBuffer leftoverInput) {
         this.wrapper = wrapper;
         this.socket = wrapper.getSocket().longValue();
         if (leftoverInput != null) {

==================================================
Nio2Processor.java
index e4a66ea371..aff2ce8c8f 100644
--- a/java/org/apache/coyote/http11/upgrade/AprServletOutputStream.java
+++ b/java/org/apache/coyote/http11/upgrade/AprServletOutputStream.java
@@ -26,7 +26,7 @@ import org.apache.tomcat.jni.OS;
 import org.apache.tomcat.jni.Socket;
 import org.apache.tomcat.jni.Status;
 import org.apache.tomcat.util.net.AprEndpoint;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 public class AprServletOutputStream extends AbstractServletOutputStream<Long> {
 
@@ -37,7 +37,7 @@ public class AprServletOutputStream extends AbstractServletOutputStream<Long> {
     private volatile boolean closed = false;
     private final ByteBuffer sslOutputBuffer;
 
-    public AprServletOutputStream(SocketWrapper<Long> socketWrapper,
+    public AprServletOutputStream(SocketWrapperBase<Long> socketWrapper,
             int asyncWriteBufferSize, AprEndpoint endpoint) {
         super(socketWrapper, asyncWriteBufferSize);
         this.endpoint = endpoint;

==================================================
Nio2ServletInputStream.java
index 8fe5af7d31..1245785994 100644
--- a/java/org/apache/coyote/http11/upgrade/Nio2Processor.java
+++ b/java/org/apache/coyote/http11/upgrade/Nio2Processor.java
@@ -24,7 +24,7 @@ import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.Nio2Channel;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 public class Nio2Processor extends AbstractProcessor<Nio2Channel> {
 
@@ -35,7 +35,7 @@ public class Nio2Processor extends AbstractProcessor<Nio2Channel> {
     private static final int INFINITE_TIMEOUT = -1;
 
     public Nio2Processor(AbstractEndpoint<Nio2Channel> endpoint,
-            SocketWrapper<Nio2Channel> wrapper, ByteBuffer leftoverInput,
+            SocketWrapperBase<Nio2Channel> wrapper, ByteBuffer leftoverInput,
             HttpUpgradeHandler httpUpgradeProcessor,
             int asyncWriteBufferSize) {
         super(httpUpgradeProcessor,

==================================================
Nio2ServletOutputStream.java
index b7e5e2e2e0..940b5d98b1 100644
--- a/java/org/apache/coyote/http11/upgrade/Nio2ServletInputStream.java
+++ b/java/org/apache/coyote/http11/upgrade/Nio2ServletInputStream.java
@@ -30,25 +30,25 @@ import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.Nio2Channel;
 import org.apache.tomcat.util.net.Nio2Endpoint;
 import org.apache.tomcat.util.net.SocketStatus;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 public class Nio2ServletInputStream extends AbstractServletInputStream {
 
     private final AbstractEndpoint<Nio2Channel> endpoint;
-    private final SocketWrapper<Nio2Channel> wrapper;
+    private final SocketWrapperBase<Nio2Channel> wrapper;
     private final Nio2Channel channel;
-    private final CompletionHandler<Integer, SocketWrapper<Nio2Channel>> completionHandler;
+    private final CompletionHandler<Integer, SocketWrapperBase<Nio2Channel>> completionHandler;
     private boolean flipped = false;
     private volatile boolean readPending = false;
     private volatile boolean interest = true;
 
-    public Nio2ServletInputStream(SocketWrapper<Nio2Channel> wrapper, AbstractEndpoint<Nio2Channel> endpoint0) {
+    public Nio2ServletInputStream(SocketWrapperBase<Nio2Channel> wrapper, AbstractEndpoint<Nio2Channel> endpoint0) {
         this.endpoint = endpoint0;
         this.wrapper = wrapper;
         this.channel = wrapper.getSocket();
-        this.completionHandler = new CompletionHandler<Integer, SocketWrapper<Nio2Channel>>() {
+        this.completionHandler = new CompletionHandler<Integer, SocketWrapperBase<Nio2Channel>>() {
             @Override
-            public void completed(Integer nBytes, SocketWrapper<Nio2Channel> attachment) {
+            public void completed(Integer nBytes, SocketWrapperBase<Nio2Channel> attachment) {
                 boolean notify = false;
                 synchronized (completionHandler) {
                     if (nBytes.intValue() < 0) {
@@ -66,7 +66,7 @@ public class Nio2ServletInputStream extends AbstractServletInputStream {
                 }
             }
             @Override
-            public void failed(Throwable exc, SocketWrapper<Nio2Channel> attachment) {
+            public void failed(Throwable exc, SocketWrapperBase<Nio2Channel> attachment) {
                 attachment.setError(true);
                 readPending = false;
                 if (exc instanceof AsynchronousCloseException) {

==================================================
NioProcessor.java
index 8de562ea98..a02e7dd971 100644
--- a/java/org/apache/coyote/http11/upgrade/Nio2ServletOutputStream.java
+++ b/java/org/apache/coyote/http11/upgrade/Nio2ServletOutputStream.java
@@ -31,7 +31,7 @@ import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.Nio2Channel;
 import org.apache.tomcat.util.net.Nio2Endpoint;
 import org.apache.tomcat.util.net.SocketStatus;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 public class Nio2ServletOutputStream extends AbstractServletOutputStream<Nio2Channel> {
 
@@ -41,7 +41,7 @@ public class Nio2ServletOutputStream extends AbstractServletOutputStream<Nio2Cha
     private final CompletionHandler<Integer, ByteBuffer> completionHandler;
     private final Semaphore writePending = new Semaphore(1);
 
-    public Nio2ServletOutputStream(SocketWrapper<Nio2Channel> socketWrapper0,
+    public Nio2ServletOutputStream(SocketWrapperBase<Nio2Channel> socketWrapper0,
             int asyncWriteBufferSize, AbstractEndpoint<Nio2Channel> endpoint0) {
         super(socketWrapper0, asyncWriteBufferSize);
         this.endpoint = endpoint0;

==================================================
NioServletInputStream.java
index 407029c5bb..8c5762cf6e 100644
--- a/java/org/apache/coyote/http11/upgrade/NioProcessor.java
+++ b/java/org/apache/coyote/http11/upgrade/NioProcessor.java
@@ -24,7 +24,7 @@ import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.net.NioChannel;
 import org.apache.tomcat.util.net.NioSelectorPool;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 public class NioProcessor extends AbstractProcessor<NioChannel> {
 
@@ -34,7 +34,7 @@ public class NioProcessor extends AbstractProcessor<NioChannel> {
 
     private static final int INFINITE_TIMEOUT = -1;
 
-    public NioProcessor(SocketWrapper<NioChannel> wrapper, ByteBuffer leftoverInput,
+    public NioProcessor(SocketWrapperBase<NioChannel> wrapper, ByteBuffer leftoverInput,
             HttpUpgradeHandler httpUpgradeProcessor, NioSelectorPool pool,
             int asyncWriteBufferSize) {
         super(httpUpgradeProcessor,

==================================================
NioServletOutputStream.java
index 2af62b9653..a40d3cd694 100644
--- a/java/org/apache/coyote/http11/upgrade/NioServletInputStream.java
+++ b/java/org/apache/coyote/http11/upgrade/NioServletInputStream.java
@@ -24,14 +24,14 @@ import java.nio.channels.Selector;
 import org.apache.tomcat.util.net.NioChannel;
 import org.apache.tomcat.util.net.NioEndpoint;
 import org.apache.tomcat.util.net.NioSelectorPool;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 public class NioServletInputStream extends AbstractServletInputStream {
 
     private final NioChannel channel;
     private final NioSelectorPool pool;
 
-    public NioServletInputStream(SocketWrapper<NioChannel> wrapper,
+    public NioServletInputStream(SocketWrapperBase<NioChannel> wrapper,
             NioSelectorPool pool) {
         this.channel = wrapper.getSocket();
         this.pool = pool;
@@ -118,8 +118,8 @@ public class NioServletInputStream extends AbstractServletInputStream {
                 // Ignore
             }
             try {
-                NioEndpoint.KeyAttachment att =
-                        (NioEndpoint.KeyAttachment) channel.getAttachment(false);
+                NioEndpoint.NioSocketWrapper att =
+                        (NioEndpoint.NioSocketWrapper) channel.getAttachment(false);
                 if (att == null) {
                     throw new IOException("Key must be cancelled.");
                 }

==================================================
SpdyAprNpnHandler.java
index 97914ddc6c..d6839a0bb0 100644
--- a/java/org/apache/coyote/http11/upgrade/NioServletOutputStream.java
+++ b/java/org/apache/coyote/http11/upgrade/NioServletOutputStream.java
@@ -23,7 +23,7 @@ import java.nio.channels.Selector;
 import org.apache.tomcat.util.net.NioChannel;
 import org.apache.tomcat.util.net.NioEndpoint;
 import org.apache.tomcat.util.net.NioSelectorPool;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 public class NioServletOutputStream extends AbstractServletOutputStream<NioChannel> {
 
@@ -32,7 +32,7 @@ public class NioServletOutputStream extends AbstractServletOutputStream<NioChann
     private final int maxWrite;
 
 
-    public NioServletOutputStream(SocketWrapper<NioChannel> socketWrapper,
+    public NioServletOutputStream(SocketWrapperBase<NioChannel> socketWrapper,
             int asyncWriteBufferSize, NioSelectorPool pool) {
         super(socketWrapper, asyncWriteBufferSize);
         channel = socketWrapper.getSocket();
@@ -78,8 +78,8 @@ public class NioServletOutputStream extends AbstractServletOutputStream<NioChann
         channel.getBufHandler().getWriteBuffer().flip();
 
         int written = 0;
-        NioEndpoint.KeyAttachment att =
-                (NioEndpoint.KeyAttachment) channel.getAttachment(false);
+        NioEndpoint.NioSocketWrapper att =
+                (NioEndpoint.NioSocketWrapper) channel.getAttachment(false);
         if (att == null) {
             throw new IOException("Key must be cancelled");
         }
@@ -107,8 +107,8 @@ public class NioServletOutputStream extends AbstractServletOutputStream<NioChann
 
     @Override
     protected void doFlush() throws IOException {
-        NioEndpoint.KeyAttachment att =
-                (NioEndpoint.KeyAttachment) channel.getAttachment(false);
+        NioEndpoint.NioSocketWrapper att =
+                (NioEndpoint.NioSocketWrapper) channel.getAttachment(false);
         if (att == null) {
             throw new IOException("Key must be cancelled");
         }

==================================================
SpdyProcessor.java
index 8507617045..e1d5f83901 100644
--- a/java/org/apache/coyote/spdy/SpdyAprNpnHandler.java
+++ b/java/org/apache/coyote/spdy/SpdyAprNpnHandler.java
@@ -32,7 +32,7 @@ import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.AprEndpoint;
 import org.apache.tomcat.util.net.SocketStatus;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 /**
  * Plugin for APR connector providing SPDY support via NPN negotiation.
@@ -90,7 +90,7 @@ public class SpdyAprNpnHandler implements NpnHandler<Long> {
     }
 
     @Override
-    public SocketState process(SocketWrapper<Long> socketWrapper,
+    public SocketState process(SocketWrapperBase<Long> socketWrapper,
             SocketStatus status) {
 
         long socket = socketWrapper.getSocket().longValue();

==================================================
SpdyProxyProtocol.java
index f35de64c37..c2fd216f8d 100644
--- a/java/org/apache/coyote/spdy/SpdyProcessor.java
+++ b/java/org/apache/coyote/spdy/SpdyProcessor.java
@@ -50,7 +50,7 @@ import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.SSLSupport;
 import org.apache.tomcat.util.net.SocketStatus;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 /**
  * A spdy stream ( multiplexed over a spdy tcp connection ) processed by a
@@ -507,7 +507,7 @@ public class SpdyProcessor<S> extends AbstractProcessor<S> implements Runnable {
     }
 
     @Override
-    public SocketState process(SocketWrapper<S> socket)
+    public SocketState process(SocketWrapperBase<S> socket)
             throws IOException {
         throw new IOException("Unimplemented");
     }

==================================================
AbstractEndpoint.java
index 3b0b559125..3f035cc67c 100644
--- a/java/org/apache/coyote/spdy/SpdyProxyProtocol.java
+++ b/java/org/apache/coyote/spdy/SpdyProxyProtocol.java
@@ -35,7 +35,7 @@ import org.apache.tomcat.util.net.NioChannel;
 import org.apache.tomcat.util.net.NioEndpoint;
 import org.apache.tomcat.util.net.SSLImplementation;
 import org.apache.tomcat.util.net.SocketStatus;
-import org.apache.tomcat.util.net.SocketWrapper;
+import org.apache.tomcat.util.net.SocketWrapperBase;
 
 /**
  * SPDY in 'proxy' mode - no SSL and no header compression.
@@ -130,7 +130,7 @@ public class SpdyProxyProtocol extends AbstractProtocol<NioChannel> {
         }
 
         @Override
-        public SocketState process(SocketWrapper<NioChannel> socket,
+        public SocketState process(SocketWrapperBase<NioChannel> socket,
                 SocketStatus status) {
 
             spdyContext.getNetSupport().onAccept(socket.getSocket());
@@ -143,7 +143,7 @@ public class SpdyProxyProtocol extends AbstractProtocol<NioChannel> {
         }
 
         @Override
-        public void release(SocketWrapper<NioChannel> socket) {
+        public void release(SocketWrapperBase<NioChannel> socket) {
             // TODO Auto-generated method stub
         }
 

==================================================
AprEndpoint.java
index 0b650c98b4..d5cdb7d66d 100644
--- a/java/org/apache/tomcat/util/net/AbstractEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AbstractEndpoint.java
@@ -127,7 +127,7 @@ public abstract class AbstractEndpoint<S> {
                     // Ignore
                 }
                 long now = System.currentTimeMillis();
-                for (SocketWrapper<S> socket : waitingRequests) {
+                for (SocketWrapperBase<S> socket : waitingRequests) {
                     long access = socket.getLastAccess();
                     if (socket.getTimeout() > 0 && (now - access) > socket.getTimeout()) {
                         processSocket(socket, SocketStatus.TIMEOUT, true);
@@ -678,11 +678,11 @@ public abstract class AbstractEndpoint<S> {
      * @param dispatch      Should the processing be performed on a new
      *                          container thread
      */
-    public abstract void processSocket(SocketWrapper<S> socketWrapper,
+    public abstract void processSocket(SocketWrapperBase<S> socketWrapper,
             SocketStatus socketStatus, boolean dispatch);
 
 
-    public void executeNonBlockingDispatches(SocketWrapper<S> socketWrapper) {
+    public void executeNonBlockingDispatches(SocketWrapperBase<S> socketWrapper) {
         /*
          * This method is called when non-blocking IO is initiated by defining
          * a read and/or write listener in a non-container thread. It is called
@@ -1027,8 +1027,8 @@ public abstract class AbstractEndpoint<S> {
     }
 
 
-    protected final Set<SocketWrapper<S>> waitingRequests = Collections
-            .newSetFromMap(new ConcurrentHashMap<SocketWrapper<S>, Boolean>());
+    protected final Set<SocketWrapperBase<S>> waitingRequests = Collections
+            .newSetFromMap(new ConcurrentHashMap<SocketWrapperBase<S>, Boolean>());
 
 
     /**

==================================================
Nio2Channel.java
index 8d7942442a..3148476ee0 100644
--- a/java/org/apache/tomcat/util/net/AprEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AprEndpoint.java
@@ -853,7 +853,7 @@ public class AprEndpoint extends AbstractEndpoint<Long> {
                 log.warn(sm.getString("endpoint.warn.noExector",
                         Long.valueOf(socket), null));
             } else {
-                SocketWrapper<Long> wrapper =
+                SocketWrapperBase<Long> wrapper =
                         connections.get(Long.valueOf(socket));
                 // Make sure connection hasn't been closed
                 if (wrapper != null) {
@@ -875,7 +875,7 @@ public class AprEndpoint extends AbstractEndpoint<Long> {
 
 
     @Override
-    public void processSocket(SocketWrapper<Long> socket, SocketStatus status,
+    public void processSocket(SocketWrapperBase<Long> socket, SocketStatus status,
             boolean dispatch) {
         try {
             // Synchronisation is required here as this code may be called as a
@@ -2218,7 +2218,7 @@ public class AprEndpoint extends AbstractEndpoint<Long> {
      * thread local fields.
      */
     public interface Handler extends AbstractEndpoint.Handler {
-        public SocketState process(SocketWrapper<Long> socket,
+        public SocketState process(SocketWrapperBase<Long> socket,
                 SocketStatus status);
     }
 
@@ -2234,10 +2234,10 @@ public class AprEndpoint extends AbstractEndpoint<Long> {
      */
     protected class SocketWithOptionsProcessor implements Runnable {
 
-        protected SocketWrapper<Long> socket = null;
+        protected SocketWrapperBase<Long> socket = null;
 
 
-        public SocketWithOptionsProcessor(SocketWrapper<Long> socket) {
+        public SocketWithOptionsProcessor(SocketWrapperBase<Long> socket) {
             this.socket = socket;
         }
 
@@ -2290,10 +2290,10 @@ public class AprEndpoint extends AbstractEndpoint<Long> {
      */
     protected class SocketProcessor implements Runnable {
 
-        private final SocketWrapper<Long> socket;
+        private final SocketWrapperBase<Long> socket;
         private final SocketStatus status;
 
-        public SocketProcessor(SocketWrapper<Long> socket,
+        public SocketProcessor(SocketWrapperBase<Long> socket,
                 SocketStatus status) {
             this.socket = socket;
             if (status == null) {
@@ -2346,7 +2346,7 @@ public class AprEndpoint extends AbstractEndpoint<Long> {
     }
 
 
-    private static class AprSocketWrapper extends SocketWrapper<Long> {
+    private static class AprSocketWrapper extends SocketWrapperBase<Long> {
 
         // This field should only be used by Poller#run()
         private int pollerFlags = 0;

==================================================
Nio2Endpoint.java
index 7b44936a62..d740c3d9fc 100644
--- a/java/org/apache/tomcat/util/net/Nio2Channel.java
+++ b/java/org/apache/tomcat/util/net/Nio2Channel.java
@@ -38,7 +38,7 @@ public class Nio2Channel implements AsynchronousByteChannel {
     protected static ByteBuffer emptyBuf = ByteBuffer.allocate(0);
 
     protected AsynchronousSocketChannel sc = null;
-    protected SocketWrapper<Nio2Channel> socket = null;
+    protected SocketWrapperBase<Nio2Channel> socket = null;
     protected ApplicationBufferHandler bufHandler;
 
     public Nio2Channel(ApplicationBufferHandler bufHandler) {
@@ -50,7 +50,7 @@ public class Nio2Channel implements AsynchronousByteChannel {
      *
      * @throws IOException If a problem was encountered resetting the channel
      */
-    public void reset(AsynchronousSocketChannel channel, SocketWrapper<Nio2Channel> socket)
+    public void reset(AsynchronousSocketChannel channel, SocketWrapperBase<Nio2Channel> socket)
             throws IOException {
         this.sc = channel;
         this.socket = socket;
@@ -58,7 +58,7 @@ public class Nio2Channel implements AsynchronousByteChannel {
         bufHandler.getWriteBuffer().clear();
     }
 
-    public SocketWrapper<Nio2Channel> getSocket() {
+    public SocketWrapperBase<Nio2Channel> getSocket() {
         return socket;
     }
 

==================================================
NioBlockingSelector.java
index dd8e8e7f5b..3daf96c1a3 100644
--- a/java/org/apache/tomcat/util/net/Nio2Endpoint.java
+++ b/java/org/apache/tomcat/util/net/Nio2Endpoint.java
@@ -378,7 +378,7 @@ public class Nio2Endpoint extends AbstractEndpoint<Nio2Channel> {
                 @Override
                 public void run() {
                     // Timeout any pending async request
-                    for (SocketWrapper<Nio2Channel> socket : waitingRequests) {
+                    for (SocketWrapperBase<Nio2Channel> socket : waitingRequests) {
                         processSocket(socket, SocketStatus.TIMEOUT, false);
                     }
                     // Then close all active connections if any remains
@@ -566,12 +566,12 @@ public class Nio2Endpoint extends AbstractEndpoint<Nio2Channel> {
 
 
     @Override
-    public void processSocket(SocketWrapper<Nio2Channel> socketWrapper,
+    public void processSocket(SocketWrapperBase<Nio2Channel> socketWrapper,
             SocketStatus socketStatus, boolean dispatch) {
         processSocket0(socketWrapper, socketStatus, dispatch);
     }
 
-    protected boolean processSocket0(SocketWrapper<Nio2Channel> socketWrapper, SocketStatus status, boolean dispatch) {
+    protected boolean processSocket0(SocketWrapperBase<Nio2Channel> socketWrapper, SocketStatus status, boolean dispatch) {
         try {
             SocketProcessor sc = (useCaches) ? processorCache.pop() : null;
             if (sc == null) {
@@ -598,7 +598,7 @@ public class Nio2Endpoint extends AbstractEndpoint<Nio2Channel> {
         return true;
     }
 
-    public void closeSocket(SocketWrapper<Nio2Channel> socket) {
+    public void closeSocket(SocketWrapperBase<Nio2Channel> socket) {
         if (socket == null) {
             return;
         }
@@ -727,7 +727,7 @@ public class Nio2Endpoint extends AbstractEndpoint<Nio2Channel> {
     }
 
 
-    public static class Nio2SocketWrapper extends SocketWrapper<Nio2Channel> {
+    public static class Nio2SocketWrapper extends SocketWrapperBase<Nio2Channel> {
 
         private SendfileData sendfileData = null;
         private boolean upgradeInit = false;
@@ -799,9 +799,9 @@ public class Nio2Endpoint extends AbstractEndpoint<Nio2Channel> {
      * thread local fields.
      */
     public interface Handler extends AbstractEndpoint.Handler {
-        public SocketState process(SocketWrapper<Nio2Channel> socket,
+        public SocketState process(SocketWrapperBase<Nio2Channel> socket,
                 SocketStatus status);
-        public void release(SocketWrapper<Nio2Channel> socket);
+        public void release(SocketWrapperBase<Nio2Channel> socket);
         public void closeAll();
         public SSLImplementation getSslImplementation();
         public void onCreateSSLEngine(SSLEngine engine);
@@ -810,11 +810,11 @@ public class Nio2Endpoint extends AbstractEndpoint<Nio2Channel> {
     /**
      * The completion handler used for asynchronous read operations
      */
-    private CompletionHandler<Integer, SocketWrapper<Nio2Channel>> awaitBytes
-            = new CompletionHandler<Integer, SocketWrapper<Nio2Channel>>() {
+    private CompletionHandler<Integer, SocketWrapperBase<Nio2Channel>> awaitBytes
+            = new CompletionHandler<Integer, SocketWrapperBase<Nio2Channel>>() {
 
         @Override
-        public synchronized void completed(Integer nBytes, SocketWrapper<Nio2Channel> attachment) {
+        public synchronized void completed(Integer nBytes, SocketWrapperBase<Nio2Channel> attachment) {
             if (nBytes.intValue() < 0) {
                 failed(new ClosedChannelException(), attachment);
                 return;
@@ -823,16 +823,16 @@ public class Nio2Endpoint extends AbstractEndpoint<Nio2Channel> {
         }
 
         @Override
-        public void failed(Throwable exc, SocketWrapper<Nio2Channel> attachment) {
+        public void failed(Throwable exc, SocketWrapperBase<Nio2Channel> attachment) {
             processSocket0(attachment, SocketStatus.DISCONNECT, true);
         }
     };
 
-    public void addTimeout(SocketWrapper<Nio2Channel> socket) {
+    public void addTimeout(SocketWrapperBase<Nio2Channel> socket) {
         waitingRequests.add(socket);
     }
 
-    public boolean removeTimeout(SocketWrapper<Nio2Channel> socket) {
+    public boolean removeTimeout(SocketWrapperBase<Nio2Channel> socket) {
         return waitingRequests.remove(socket);
     }
 
@@ -853,7 +853,7 @@ public class Nio2Endpoint extends AbstractEndpoint<Nio2Channel> {
         }
     }
 
-    public void awaitBytes(SocketWrapper<Nio2Channel> socket) {
+    public void awaitBytes(SocketWrapperBase<Nio2Channel> socket) {
         if (socket == null || socket.getSocket() == null) {
             return;
         }
@@ -996,14 +996,14 @@ public class Nio2Endpoint extends AbstractEndpoint<Nio2Channel> {
      */
     protected class SocketProcessor implements Runnable {
 
-        private SocketWrapper<Nio2Channel> socket = null;
+        private SocketWrapperBase<Nio2Channel> socket = null;
         private SocketStatus status = null;
 
-        public SocketProcessor(SocketWrapper<Nio2Channel> socket, SocketStatus status) {
+        public SocketProcessor(SocketWrapperBase<Nio2Channel> socket, SocketStatus status) {
             reset(socket,status);
         }
 
-        public void reset(SocketWrapper<Nio2Channel> socket, SocketStatus status) {
+        public void reset(SocketWrapperBase<Nio2Channel> socket, SocketStatus status) {
             this.socket = socket;
             this.status = status;
         }

==================================================
NioEndpoint.java
index 2f87e4c1f3..3a5b04e7bc 100644
--- a/java/org/apache/tomcat/util/net/NioBlockingSelector.java
+++ b/java/org/apache/tomcat/util/net/NioBlockingSelector.java
@@ -35,7 +35,7 @@ import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.ExceptionUtils;
 import org.apache.tomcat.util.collections.SynchronizedQueue;
 import org.apache.tomcat.util.collections.SynchronizedStack;
-import org.apache.tomcat.util.net.NioEndpoint.KeyAttachment;
+import org.apache.tomcat.util.net.NioEndpoint.NioSocketWrapper;
 
 public class NioBlockingSelector {
 
@@ -90,7 +90,7 @@ public class NioBlockingSelector {
         if (reference == null) {
             reference = new KeyReference();
         }
-        KeyAttachment att = (KeyAttachment) key.attachment();
+        NioSocketWrapper att = (NioSocketWrapper) key.attachment();
         int written = 0;
         boolean timedout = false;
         int keycount = 1; //assume we can write
@@ -162,7 +162,7 @@ public class NioBlockingSelector {
         if (reference == null) {
             reference = new KeyReference();
         }
-        KeyAttachment att = (KeyAttachment) key.attachment();
+        NioSocketWrapper att = (NioSocketWrapper) key.attachment();
         int read = 0;
         boolean timedout = false;
         int keycount = 1; //assume we can read
@@ -234,7 +234,7 @@ public class NioBlockingSelector {
             if (wakeupCounter.addAndGet(1)==0) selector.wakeup();
         }
 
-        public void cancel(SelectionKey sk, KeyAttachment key, int ops){
+        public void cancel(SelectionKey sk, NioSocketWrapper key, int ops){
             if (sk!=null) {
                 sk.cancel();
                 sk.attach(null);
@@ -243,7 +243,7 @@ public class NioBlockingSelector {
             }
         }
 
-        public void add(final KeyAttachment key, final int ops, final KeyReference ref) {
+        public void add(final NioSocketWrapper key, final int ops, final KeyReference ref) {
             if ( key == null ) return;
             NioChannel nch = key.getSocket();
             if ( nch == null ) return;
@@ -274,7 +274,7 @@ public class NioBlockingSelector {
             wakeup();
         }
 
-        public void remove(final KeyAttachment key, final int ops) {
+        public void remove(final NioSocketWrapper key, final int ops) {
             if ( key == null ) return;
             NioChannel nch = key.getSocket();
             if ( nch == null ) return;
@@ -364,7 +364,7 @@ public class NioBlockingSelector {
                     // any active event.
                     while (run && iterator != null && iterator.hasNext()) {
                         SelectionKey sk = iterator.next();
-                        KeyAttachment attachment = (KeyAttachment)sk.attachment();
+                        NioSocketWrapper attachment = (NioSocketWrapper)sk.attachment();
                         try {
                             attachment.access();
                             iterator.remove();

==================================================
SecureNio2Channel.java
index 0cb68171d7..34838c50fd 100644
--- a/java/org/apache/tomcat/util/net/NioEndpoint.java
+++ b/java/org/apache/tomcat/util/net/NioEndpoint.java
@@ -132,7 +132,7 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
     /**
      * Cache for key attachment objects
      */
-    private SynchronizedStack<KeyAttachment> keyCache;
+    private SynchronizedStack<NioSocketWrapper> keyCache;
 
     /**
      * Cache for poller events
@@ -590,17 +590,17 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
 
 
     @Override
-    public void processSocket(SocketWrapper<NioChannel> socketWrapper,
+    public void processSocket(SocketWrapperBase<NioChannel> socketWrapper,
             SocketStatus socketStatus, boolean dispatch) {
         NioChannel socket = socketWrapper.getSocket();
         if (socket.isOpen() && dispatch && socketStatus == SocketStatus.OPEN_READ) {
             socket.getPoller().add(socket, OP_CALLBACK);
         } else {
-            processSocket((KeyAttachment) socketWrapper, socketStatus, dispatch);
+            processSocket((NioSocketWrapper) socketWrapper, socketStatus, dispatch);
         }
     }
 
-    protected boolean processSocket(KeyAttachment attachment, SocketStatus status, boolean dispatch) {
+    protected boolean processSocket(NioSocketWrapper attachment, SocketStatus status, boolean dispatch) {
         try {
             if (attachment == null) {
                 return false;
@@ -756,13 +756,13 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
 
         private NioChannel socket;
         private int interestOps;
-        private KeyAttachment key;
+        private NioSocketWrapper key;
 
-        public PollerEvent(NioChannel ch, KeyAttachment k, int intOps) {
+        public PollerEvent(NioChannel ch, NioSocketWrapper k, int intOps) {
             reset(ch, k, intOps);
         }
 
-        public void reset(NioChannel ch, KeyAttachment k, int intOps) {
+        public void reset(NioChannel ch, NioSocketWrapper k, int intOps) {
             socket = ch;
             interestOps = intOps;
             key = k;
@@ -785,7 +785,7 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
                 try {
                     boolean cancel = false;
                     if (key != null) {
-                        final KeyAttachment att = (KeyAttachment) key.attachment();
+                        final NioSocketWrapper att = (NioSocketWrapper) key.attachment();
                         if ( att!=null ) {
                             //handle callback flag
                             if ((interestOps & OP_CALLBACK) == OP_CALLBACK ) {
@@ -887,7 +887,7 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
             }
             addEvent(r);
             if (close) {
-                NioEndpoint.KeyAttachment ka = (NioEndpoint.KeyAttachment)socket.getAttachment(false);
+                NioEndpoint.NioSocketWrapper ka = (NioEndpoint.NioSocketWrapper)socket.getAttachment(false);
                 processSocket(ka, SocketStatus.STOP, false);
             }
         }
@@ -925,8 +925,8 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
          */
         public void register(final NioChannel socket) {
             socket.setPoller(this);
-            KeyAttachment key = keyCache.pop();
-            final KeyAttachment ka = key!=null?key:new KeyAttachment(socket);
+            NioSocketWrapper key = keyCache.pop();
+            final NioSocketWrapper ka = key!=null?key:new NioSocketWrapper(socket);
             ka.reset(this,socket,getSocketProperties().getSoTimeout());
             ka.setKeepAliveLeft(NioEndpoint.this.getMaxKeepAliveRequests());
             ka.setSecure(isSSLEnabled());
@@ -940,7 +940,7 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
         public void cancelledKey(SelectionKey key) {
             try {
                 if ( key == null ) return;//nothing to do
-                KeyAttachment ka = (KeyAttachment) key.attachment();
+                NioSocketWrapper ka = (NioSocketWrapper) key.attachment();
                 key.attach(null);
                 if (ka!=null) handler.release(ka);
                 else handler.release((SocketChannel)key.channel());
@@ -1052,7 +1052,7 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
                     // any active event.
                     while (iterator != null && iterator.hasNext()) {
                         SelectionKey sk = iterator.next();
-                        KeyAttachment attachment = (KeyAttachment)sk.attachment();
+                        NioSocketWrapper attachment = (NioSocketWrapper)sk.attachment();
                         // Attachment may be null if another thread has called
                         // cancelledKey()
                         if (attachment == null) {
@@ -1086,7 +1086,7 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
             stopLatch.countDown();
         }
 
-        protected boolean processKey(SelectionKey sk, KeyAttachment attachment) {
+        protected boolean processKey(SelectionKey sk, NioSocketWrapper attachment) {
             boolean result = true;
             try {
                 if ( close ) {
@@ -1132,7 +1132,7 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
             return result;
         }
 
-        public boolean processSendfile(SelectionKey sk, KeyAttachment attachment, boolean event) {
+        public boolean processSendfile(SelectionKey sk, NioSocketWrapper attachment, boolean event) {
             NioChannel sc = null;
             try {
                 unreg(sk, attachment, sk.readyOps());
@@ -1229,12 +1229,12 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
             return true;
         }
 
-        protected void unreg(SelectionKey sk, KeyAttachment attachment, int readyOps) {
+        protected void unreg(SelectionKey sk, NioSocketWrapper attachment, int readyOps) {
             //this is a must, so that we don't have multiple threads messing with the socket
             reg(sk,attachment,sk.interestOps()& (~readyOps));
         }
 
-        protected void reg(SelectionKey sk, KeyAttachment attachment, int intops) {
+        protected void reg(SelectionKey sk, NioSocketWrapper attachment, int intops) {
             sk.interestOps(intops);
             attachment.interestOps(intops);
         }
@@ -1258,7 +1258,7 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
                 SelectionKey key = iter.next();
                 keycount++;
                 try {
-                    KeyAttachment ka = (KeyAttachment) key.attachment();
+                    NioSocketWrapper ka = (NioSocketWrapper) key.attachment();
                     if ( ka == null ) {
                         cancelledKey(key); //we don't support any keys without attachments
                     } else if ( ka.getError() ) {
@@ -1319,9 +1319,9 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
     }
 
 // ----------------------------------------------------- Key Attachment Class
-    public static class KeyAttachment extends SocketWrapper<NioChannel> {
+    public static class NioSocketWrapper extends SocketWrapperBase<NioChannel> {
 
-        public KeyAttachment(NioChannel channel) {
+        public NioSocketWrapper(NioChannel channel) {
             super(channel);
         }
 
@@ -1443,9 +1443,9 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
      * thread local fields.
      */
     public interface Handler extends AbstractEndpoint.Handler {
-        public SocketState process(SocketWrapper<NioChannel> socket,
+        public SocketState process(SocketWrapperBase<NioChannel> socket,
                 SocketStatus status);
-        public void release(SocketWrapper<NioChannel> socket);
+        public void release(SocketWrapperBase<NioChannel> socket);
         public void release(SocketChannel socket);
         public SSLImplementation getSslImplementation();
         public void onCreateSSLEngine(SSLEngine engine);
@@ -1459,14 +1459,14 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
      */
     protected class SocketProcessor implements Runnable {
 
-        private KeyAttachment ka = null;
+        private NioSocketWrapper ka = null;
         private SocketStatus status = null;
 
-        public SocketProcessor(KeyAttachment ka, SocketStatus status) {
+        public SocketProcessor(NioSocketWrapper ka, SocketStatus status) {
             reset(ka, status);
         }
 
-        public void reset(KeyAttachment ka, SocketStatus status) {
+        public void reset(NioSocketWrapper ka, SocketStatus status) {
             this.ka = ka;
             this.status = status;
         }
@@ -1491,7 +1491,7 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
             }
         }
 
-        private void doRun(SelectionKey key, KeyAttachment ka) {
+        private void doRun(SelectionKey key, NioSocketWrapper ka) {
             NioChannel socket = ka.getSocket();
 
             try {

==================================================
SocketWrapperBase.java
index ec51f75ec8..1e53050a36 100644
--- a/java/org/apache/tomcat/util/net/SecureNio2Channel.java
+++ b/java/org/apache/tomcat/util/net/SecureNio2Channel.java
@@ -57,8 +57,8 @@ public class SecureNio2Channel extends Nio2Channel  {
     protected volatile boolean readPending;
     protected volatile boolean writePending;
 
-    private CompletionHandler<Integer, SocketWrapper<Nio2Channel>> handshakeReadCompletionHandler;
-    private CompletionHandler<Integer, SocketWrapper<Nio2Channel>> handshakeWriteCompletionHandler;
+    private CompletionHandler<Integer, SocketWrapperBase<Nio2Channel>> handshakeReadCompletionHandler;
+    private CompletionHandler<Integer, SocketWrapperBase<Nio2Channel>> handshakeWriteCompletionHandler;
 
     public SecureNio2Channel(SSLEngine engine, ApplicationBufferHandler bufHandler,
             Nio2Endpoint endpoint0) {
@@ -73,9 +73,9 @@ public class SecureNio2Channel extends Nio2Channel  {
             netInBuffer = ByteBuffer.allocate(netBufSize);
             netOutBuffer = ByteBuffer.allocate(netBufSize);
         }
-        handshakeReadCompletionHandler = new CompletionHandler<Integer, SocketWrapper<Nio2Channel>>() {
+        handshakeReadCompletionHandler = new CompletionHandler<Integer, SocketWrapperBase<Nio2Channel>>() {
             @Override
-            public void completed(Integer result, SocketWrapper<Nio2Channel> attachment) {
+            public void completed(Integer result, SocketWrapperBase<Nio2Channel> attachment) {
                 if (result.intValue() < 0) {
                     failed(new EOFException(), attachment);
                     return;
@@ -83,13 +83,13 @@ public class SecureNio2Channel extends Nio2Channel  {
                 endpoint.processSocket(attachment, SocketStatus.OPEN_READ, false);
             }
             @Override
-            public void failed(Throwable exc, SocketWrapper<Nio2Channel> attachment) {
+            public void failed(Throwable exc, SocketWrapperBase<Nio2Channel> attachment) {
                 endpoint.closeSocket(attachment);
             }
         };
-        handshakeWriteCompletionHandler = new CompletionHandler<Integer, SocketWrapper<Nio2Channel>>() {
+        handshakeWriteCompletionHandler = new CompletionHandler<Integer, SocketWrapperBase<Nio2Channel>>() {
             @Override
-            public void completed(Integer result, SocketWrapper<Nio2Channel> attachment) {
+            public void completed(Integer result, SocketWrapperBase<Nio2Channel> attachment) {
                 if (result.intValue() < 0) {
                     failed(new EOFException(), attachment);
                     return;
@@ -97,7 +97,7 @@ public class SecureNio2Channel extends Nio2Channel  {
                 endpoint.processSocket(attachment, SocketStatus.OPEN_WRITE, false);
             }
             @Override
-            public void failed(Throwable exc, SocketWrapper<Nio2Channel> attachment) {
+            public void failed(Throwable exc, SocketWrapperBase<Nio2Channel> attachment) {
                 endpoint.closeSocket(attachment);
             }
         };
@@ -108,7 +108,7 @@ public class SecureNio2Channel extends Nio2Channel  {
     }
 
     @Override
-    public void reset(AsynchronousSocketChannel channel, SocketWrapper<Nio2Channel> socket)
+    public void reset(AsynchronousSocketChannel channel, SocketWrapperBase<Nio2Channel> socket)
             throws IOException {
         super.reset(channel, socket);
         netOutBuffer.position(0);

==================================================
TesterOutputBuffer.java
similarity index 98%
rename from java/org/apache/tomcat/util/net/SocketWrapper.java
rename to java/org/apache/tomcat/util/net/SocketWrapperBase.java
index 9ebf87c0d2..725de18a3d 100644
--- a/java/org/apache/tomcat/util/net/SocketWrapper.java
+++ b/java/org/apache/tomcat/util/net/SocketWrapperBase.java
@@ -23,7 +23,7 @@ import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;
 
-public class SocketWrapper<E> {
+public abstract class SocketWrapperBase<E> {
 
     private volatile E socket;
 
@@ -64,7 +64,7 @@ public class SocketWrapper<E> {
 
     private Set<DispatchType> dispatches = new CopyOnWriteArraySet<>();
 
-    public SocketWrapper(E socket) {
+    public SocketWrapperBase(E socket) {
         this.socket = socket;
         ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
         this.blockingStatusReadLock = lock.readLock();

==================================================
