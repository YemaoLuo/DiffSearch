b4775eec749ea15117719900346cf2563137db9e
==================================================
Update Commons FileUpload - cosmetic only
==================================================
Mark Thomas
==================================================
Fri Jan 15 14:35:16 2021 +0000
==================================================
FileItemIterator.java
index 1c449c7c16..80710168f1 100644
--- a/MERGE.txt
+++ b/MERGE.txt
@@ -51,7 +51,7 @@ FileUpload
 Sub-tree:
 src/main/java/org/apache/commons/fileupload2
 The SHA1 ID / tag for the most recent commit to be merged to Tomcat is:
-c25a4e33553a5f098ab6065a54e1ae7985025d26 (2020-08-26)
+ee0a7131b6b87586b28542de354951414dedac3f (2021-01-15)
 
 Note: Tomcat's copy of fileupload also includes classes copied manually from
       Commons IO.

==================================================
FileItemStream.java
index 59a81f49b4..53ec2d4861 100644
--- a/java/org/apache/tomcat/util/http/fileupload/FileItemIterator.java
+++ b/java/org/apache/tomcat/util/http/fileupload/FileItemIterator.java
@@ -34,7 +34,7 @@ public interface FileItemIterator {
      * request specific value by invoking {@link #setFileSizeMax(long)} on this object.
      * @return The maximum size of a single, uploaded file. The value -1 indicates "unlimited".
      */
-    public long getFileSizeMax();
+    long getFileSizeMax();
 
     /** Sets the maximum size of a single file. An {@link FileSizeLimitExceededException}
      * will be thrown, if there is an uploaded file, which is exceeding this value.
@@ -45,7 +45,7 @@ public interface FileItemIterator {
      * <em>Note:</em>Changing this value doesn't affect files, that have already been uploaded.
      * @param pFileSizeMax The maximum size of a single, uploaded file. The value -1 indicates "unlimited".
      */
-    public void setFileSizeMax(long pFileSizeMax);
+    void setFileSizeMax(long pFileSizeMax);
 
     /** Returns the maximum size of the complete HTTP request. A {@link SizeLimitExceededException}
      * will be thrown, if the HTTP request will exceed this value.
@@ -54,7 +54,7 @@ public interface FileItemIterator {
      * request specific value by invoking {@link #setSizeMax(long)} on this object.
      * @return The maximum size of the complete HTTP request. The value -1 indicates "unlimited".
      */
-    public long getSizeMax();
+    long getSizeMax();
 
     /** Returns the maximum size of the complete HTTP request. A {@link SizeLimitExceededException}
      * will be thrown, if the HTTP request will exceed this value.
@@ -66,7 +66,7 @@ public interface FileItemIterator {
      * yet been invoked.
      * @param pSizeMax The maximum size of the complete HTTP request. The value -1 indicates "unlimited".
      */
-    public void setSizeMax(long pSizeMax);
+    void setSizeMax(long pSizeMax);
 
     /**
      * Returns, whether another instance of {@link FileItemStream}
@@ -78,7 +78,7 @@ public interface FileItemIterator {
      * @return True, if one or more additional file items
      *   are available, otherwise false.
      */
-    public boolean hasNext() throws FileUploadException, IOException;
+    boolean hasNext() throws FileUploadException, IOException;
 
     /**
      * Returns the next available {@link FileItemStream}.
@@ -91,7 +91,7 @@ public interface FileItemIterator {
      * @return FileItemStream instance, which provides
      *   access to the next file item.
      */
-    public FileItemStream next() throws FileUploadException, IOException;
+    FileItemStream next() throws FileUploadException, IOException;
 
-    public List<FileItem> getFileItems() throws FileUploadException, IOException;
+    List<FileItem> getFileItems() throws FileUploadException, IOException;
 }

==================================================
FileUpload.java
index 0dc5804296..c31d9eb13b 100644
--- a/java/org/apache/tomcat/util/http/fileupload/FileItemStream.java
+++ b/java/org/apache/tomcat/util/http/fileupload/FileItemStream.java
@@ -40,7 +40,7 @@ public interface FileItemStream extends FileItemHeadersSupport {
      * {@link java.util.Iterator#hasNext()} has been invoked on the
      * iterator, which created the {@link FileItemStream}.
      */
-    public static class ItemSkippedException extends IOException {
+    class ItemSkippedException extends IOException {
 
         /**
          * The exceptions serial version UID, which is being used

==================================================
FileUploadBase.java
index eb3305d97e..9be9caaa08 100644
--- a/java/org/apache/tomcat/util/http/fileupload/FileUpload.java
+++ b/java/org/apache/tomcat/util/http/fileupload/FileUpload.java
@@ -52,7 +52,6 @@ public class FileUpload
      * @see #FileUpload(FileItemFactory)
      */
     public FileUpload() {
-        super();
     }
 
     /**
@@ -62,8 +61,7 @@ public class FileUpload
      * @see #FileUpload()
      * @param fileItemFactory The factory to use for creating file items.
      */
-    public FileUpload(FileItemFactory fileItemFactory) {
-        super();
+    public FileUpload(final FileItemFactory fileItemFactory) {
         this.fileItemFactory = fileItemFactory;
     }
 
@@ -85,7 +83,7 @@ public class FileUpload
      * @param factory The factory class for new file items.
      */
     @Override
-    public void setFileItemFactory(FileItemFactory factory) {
+    public void setFileItemFactory(final FileItemFactory factory) {
         this.fileItemFactory = factory;
     }
 

==================================================
FileUploadException.java
index d68192a39f..30a582ca4c 100644
--- a/java/org/apache/tomcat/util/http/fileupload/FileUploadBase.java
+++ b/java/org/apache/tomcat/util/http/fileupload/FileUploadBase.java
@@ -65,8 +65,8 @@ public abstract class FileUploadBase {
      * @return {@code true} if the request is multipart;
      *         {@code false} otherwise.
      */
-    public static final boolean isMultipartContent(RequestContext ctx) {
-        String contentType = ctx.getContentType();
+    public static final boolean isMultipartContent(final RequestContext ctx) {
+        final String contentType = ctx.getContentType();
         if (contentType == null) {
             return false;
         }
@@ -182,7 +182,7 @@ public abstract class FileUploadBase {
      * @see #getSizeMax()
      *
      */
-    public void setSizeMax(long sizeMax) {
+    public void setSizeMax(final long sizeMax) {
         this.sizeMax = sizeMax;
     }
 
@@ -204,7 +204,7 @@ public abstract class FileUploadBase {
      * @see #getFileSizeMax()
      * @param fileSizeMax Maximum size of a single uploaded file.
      */
-    public void setFileSizeMax(long fileSizeMax) {
+    public void setFileSizeMax(final long fileSizeMax) {
         this.fileSizeMax = fileSizeMax;
     }
 
@@ -228,7 +228,7 @@ public abstract class FileUploadBase {
      *
      * @param encoding The encoding used to read part headers.
      */
-    public void setHeaderEncoding(String encoding) {
+    public void setHeaderEncoding(final String encoding) {
         headerEncoding = encoding;
     }
 
@@ -250,11 +250,11 @@ public abstract class FileUploadBase {
      *   error while communicating with the client or a problem while
      *   storing the uploaded content.
      */
-    public FileItemIterator getItemIterator(RequestContext ctx)
+    public FileItemIterator getItemIterator(final RequestContext ctx)
     throws FileUploadException, IOException {
         try {
             return new FileItemIteratorImpl(this, ctx);
-        } catch (FileUploadIOException e) {
+        } catch (final FileUploadIOException e) {
             // unwrap encapsulated SizeException
             throw (FileUploadException) e.getCause();
         }
@@ -272,26 +272,26 @@ public abstract class FileUploadBase {
      * @throws FileUploadException if there are problems reading/parsing
      *                             the request or storing files.
      */
-    public List<FileItem> parseRequest(RequestContext ctx)
+    public List<FileItem> parseRequest(final RequestContext ctx)
             throws FileUploadException {
-        List<FileItem> items = new ArrayList<>();
+        final List<FileItem> items = new ArrayList<>();
         boolean successful = false;
         try {
-            FileItemIterator iter = getItemIterator(ctx);
-            FileItemFactory fileItemFactory = Objects.requireNonNull(getFileItemFactory(), "No FileItemFactory has been set.");
+            final FileItemIterator iter = getItemIterator(ctx);
+            final FileItemFactory fileItemFactory = Objects.requireNonNull(getFileItemFactory(), "No FileItemFactory has been set.");
             final byte[] buffer = new byte[Streams.DEFAULT_BUFFER_SIZE];
             while (iter.hasNext()) {
                 final FileItemStream item = iter.next();
                 // Don't use getName() here to prevent an InvalidFileNameException.
                 final String fileName = ((FileItemStreamImpl) item).getName();
-                FileItem fileItem = fileItemFactory.createItem(item.getFieldName(), item.getContentType(),
+                final FileItem fileItem = fileItemFactory.createItem(item.getFieldName(), item.getContentType(),
                                                    item.isFormField(), fileName);
                 items.add(fileItem);
                 try {
                     Streams.copy(item.openStream(), fileItem.getOutputStream(), true, buffer);
-                } catch (FileUploadIOException e) {
+                } catch (final FileUploadIOException e) {
                     throw (FileUploadException) e.getCause();
-                } catch (IOException e) {
+                } catch (final IOException e) {
                     throw new IOFileUploadException(String.format("Processing of %s request failed. %s",
                                                            MULTIPART_FORM_DATA, e.getMessage()), e);
                 }
@@ -300,16 +300,16 @@ public abstract class FileUploadBase {
             }
             successful = true;
             return items;
-        } catch (FileUploadException e) {
+        } catch (final FileUploadException e) {
             throw e;
-        } catch (IOException e) {
+        } catch (final IOException e) {
             throw new FileUploadException(e.getMessage(), e);
         } finally {
             if (!successful) {
-                for (FileItem fileItem : items) {
+                for (final FileItem fileItem : items) {
                     try {
                         fileItem.delete();
-                    } catch (Exception ignored) {
+                    } catch (final Exception ignored) {
                         // ignored TODO perhaps add to tracker delete failure list somehow?
                     }
                 }
@@ -330,13 +330,13 @@ public abstract class FileUploadBase {
      *
      * @since 1.3
      */
-    public Map<String, List<FileItem>> parseParameterMap(RequestContext ctx)
+    public Map<String, List<FileItem>> parseParameterMap(final RequestContext ctx)
             throws FileUploadException {
         final List<FileItem> items = parseRequest(ctx);
         final Map<String, List<FileItem>> itemsMap = new HashMap<>(items.size());
 
-        for (FileItem fileItem : items) {
-            String fieldName = fileItem.getFieldName();
+        for (final FileItem fileItem : items) {
+            final String fieldName = fileItem.getFieldName();
             List<FileItem> mappedItems = itemsMap.get(fieldName);
 
             if (mappedItems == null) {
@@ -360,12 +360,12 @@ public abstract class FileUploadBase {
      *
      * @return The boundary, as a byte array.
      */
-    public byte[] getBoundary(String contentType) {
-        ParameterParser parser = new ParameterParser();
+    public byte[] getBoundary(final String contentType) {
+        final ParameterParser parser = new ParameterParser();
         parser.setLowerCaseNames(true);
         // Parameter parser can handle null input
-        Map<String, String> params = parser.parse(contentType, new char[] {';', ','});
-        String boundaryStr = params.get("boundary");
+        final Map<String, String> params = parser.parse(contentType, new char[] {';', ','});
+        final String boundaryStr = params.get("boundary");
 
         if (boundaryStr == null) {
             return null;
@@ -383,7 +383,7 @@ public abstract class FileUploadBase {
      *
      * @return The file name for the current {@code encapsulation}.
      */
-    public String getFileName(FileItemHeaders headers) {
+    public String getFileName(final FileItemHeaders headers) {
         return getFileName(headers.getHeader(CONTENT_DISPOSITION));
     }
 
@@ -392,15 +392,15 @@ public abstract class FileUploadBase {
      * @param pContentDisposition The content-disposition headers value.
      * @return The file name
      */
-    private String getFileName(String pContentDisposition) {
+    private String getFileName(final String pContentDisposition) {
         String fileName = null;
         if (pContentDisposition != null) {
-            String cdl = pContentDisposition.toLowerCase(Locale.ENGLISH);
+            final String cdl = pContentDisposition.toLowerCase(Locale.ENGLISH);
             if (cdl.startsWith(FORM_DATA) || cdl.startsWith(ATTACHMENT)) {
-                ParameterParser parser = new ParameterParser();
+                final ParameterParser parser = new ParameterParser();
                 parser.setLowerCaseNames(true);
                 // Parameter parser can handle null input
-                Map<String, String> params = parser.parse(pContentDisposition, ';');
+                final Map<String, String> params = parser.parse(pContentDisposition, ';');
                 if (params.containsKey("filename")) {
                     fileName = params.get("filename");
                     if (fileName != null) {
@@ -425,7 +425,7 @@ public abstract class FileUploadBase {
      *
      * @return The field name for the current {@code encapsulation}.
      */
-    public String getFieldName(FileItemHeaders headers) {
+    public String getFieldName(final FileItemHeaders headers) {
         return getFieldName(headers.getHeader(CONTENT_DISPOSITION));
     }
 
@@ -435,14 +435,14 @@ public abstract class FileUploadBase {
      * @param pContentDisposition The content-dispositions header value.
      * @return The field jake
      */
-    private String getFieldName(String pContentDisposition) {
+    private String getFieldName(final String pContentDisposition) {
         String fieldName = null;
         if (pContentDisposition != null
                 && pContentDisposition.toLowerCase(Locale.ENGLISH).startsWith(FORM_DATA)) {
-            ParameterParser parser = new ParameterParser();
+            final ParameterParser parser = new ParameterParser();
             parser.setLowerCaseNames(true);
             // Parameter parser can handle null input
-            Map<String, String> params = parser.parse(pContentDisposition, ';');
+            final Map<String, String> params = parser.parse(pContentDisposition, ';');
             fieldName = params.get("name");
             if (fieldName != null) {
                 fieldName = fieldName.trim();
@@ -463,21 +463,21 @@ public abstract class FileUploadBase {
      *
      * @return A {@code Map} containing the parsed HTTP request headers.
      */
-    public FileItemHeaders getParsedHeaders(String headerPart) {
+    public FileItemHeaders getParsedHeaders(final String headerPart) {
         final int len = headerPart.length();
-        FileItemHeadersImpl headers = newFileItemHeaders();
+        final FileItemHeadersImpl headers = newFileItemHeaders();
         int start = 0;
         for (;;) {
             int end = parseEndOfLine(headerPart, start);
             if (start == end) {
                 break;
             }
-            StringBuilder header = new StringBuilder(headerPart.substring(start, end));
+            final StringBuilder header = new StringBuilder(headerPart.substring(start, end));
             start = end + 2;
             while (start < len) {
                 int nonWs = start;
                 while (nonWs < len) {
-                    char c = headerPart.charAt(nonWs);
+                    final char c = headerPart.charAt(nonWs);
                     if (c != ' '  &&  c != '\t') {
                         break;
                     }
@@ -512,10 +512,10 @@ public abstract class FileUploadBase {
      * @return Index of the \r\n sequence, which indicates
      *   end of line.
      */
-    private int parseEndOfLine(String headerPart, int end) {
+    private int parseEndOfLine(final String headerPart, final int end) {
         int index = end;
         for (;;) {
-            int offset = headerPart.indexOf('\r', index);
+            final int offset = headerPart.indexOf('\r', index);
             if (offset == -1  ||  offset + 1 >= headerPart.length()) {
                 throw new IllegalStateException(
                     "Expected headers to be terminated by an empty line.");
@@ -532,15 +532,15 @@ public abstract class FileUploadBase {
      * @param headers String with all headers.
      * @param header Map where to store the current header.
      */
-    private void parseHeaderLine(FileItemHeadersImpl headers, String header) {
+    private void parseHeaderLine(final FileItemHeadersImpl headers, final String header) {
         final int colonOffset = header.indexOf(':');
         if (colonOffset == -1) {
             // This header line is malformed, skip it.
             return;
         }
-        String headerName = header.substring(0, colonOffset).trim();
-        String headerValue =
-            header.substring(header.indexOf(':') + 1).trim();
+        final String headerName = header.substring(0, colonOffset).trim();
+        final String headerValue =
+            header.substring(colonOffset + 1).trim();
         headers.addHeader(headerName, headerValue);
     }
 
@@ -558,7 +558,7 @@ public abstract class FileUploadBase {
      *
      * @param pListener The progress listener, if any. Defaults to null.
      */
-    public void setProgressListener(ProgressListener pListener) {
+    public void setProgressListener(final ProgressListener pListener) {
         listener = pListener;
     }
 

==================================================
InvalidFileNameException.java
index 211275cac3..47b8230217 100644
--- a/java/org/apache/tomcat/util/http/fileupload/FileUploadException.java
+++ b/java/org/apache/tomcat/util/http/fileupload/FileUploadException.java
@@ -38,7 +38,7 @@ public class FileUploadException extends IOException {
      *
      * @param msg the error message.
      */
-    public FileUploadException(String msg) {
+    public FileUploadException(final String msg) {
         super(msg);
     }
 
@@ -49,7 +49,7 @@ public class FileUploadException extends IOException {
      * @param msg The exceptions detail message.
      * @param cause The exceptions cause.
      */
-    public FileUploadException(String msg, Throwable cause) {
+    public FileUploadException(final String msg, final Throwable cause) {
         super(msg, cause);
     }
 
@@ -59,7 +59,7 @@ public class FileUploadException extends IOException {
      *
      * @param cause The exceptions cause.
      */
-    public FileUploadException(Throwable cause) {
+    public FileUploadException(final Throwable cause) {
         super(cause);
     }
 }

==================================================
MultipartStream.java
index a81bee8595..5018620fac 100644
--- a/java/org/apache/tomcat/util/http/fileupload/InvalidFileNameException.java
+++ b/java/org/apache/tomcat/util/http/fileupload/InvalidFileNameException.java
@@ -45,7 +45,7 @@ public class InvalidFileNameException extends RuntimeException {
      * @param pName The file name causing the exception.
      * @param pMessage A human readable error message.
      */
-    public InvalidFileNameException(String pName, String pMessage) {
+    public InvalidFileNameException(final String pName, final String pMessage) {
         super(pMessage);
         name = pName;
     }

==================================================
ParameterParser.java
index 07cdc70563..595a975a4f 100644
--- a/java/org/apache/tomcat/util/http/fileupload/MultipartStream.java
+++ b/java/org/apache/tomcat/util/http/fileupload/MultipartStream.java
@@ -115,7 +115,7 @@ public class MultipartStream {
          * @param pListener The listener to invoke.
          * @param pContentLength The expected content length.
          */
-        public ProgressNotifier(ProgressListener pListener, long pContentLength) {
+        public ProgressNotifier(final ProgressListener pListener, final long pContentLength) {
             listener = pListener;
             contentLength = pContentLength;
         }
@@ -125,7 +125,7 @@ public class MultipartStream {
          *
          * @param pBytes Number of bytes, which have been read.
          */
-        void noteBytesRead(int pBytes) {
+        void noteBytesRead(final int pBytes) {
             /* Indicates, that the given number of bytes have been read from
              * the input stream.
              */
@@ -286,10 +286,10 @@ public class MultipartStream {
      *
      * @since 1.3.1
      */
-    public MultipartStream(InputStream input,
-            byte[] boundary,
-            int bufSize,
-            ProgressNotifier pNotifier) {
+    public MultipartStream(final InputStream input,
+            final byte[] boundary,
+            final int bufSize,
+            final ProgressNotifier pNotifier) {
 
         if (boundary == null) {
             throw new IllegalArgumentException("boundary may not be null");
@@ -332,9 +332,9 @@ public class MultipartStream {
      *
      * @see #MultipartStream(InputStream, byte[], int, ProgressNotifier)
      */
-    public MultipartStream(InputStream input,
-            byte[] boundary,
-            ProgressNotifier pNotifier) {
+    public MultipartStream(final InputStream input,
+            final byte[] boundary,
+            final ProgressNotifier pNotifier) {
         this(input, boundary, DEFAULT_BUFSIZE, pNotifier);
     }
 
@@ -358,7 +358,7 @@ public class MultipartStream {
      *
      * @param encoding The encoding used to read part headers.
      */
-    public void setHeaderEncoding(String encoding) {
+    public void setHeaderEncoding(final String encoding) {
         headerEncoding = encoding;
     }
 
@@ -400,7 +400,7 @@ public class MultipartStream {
      */
     public boolean readBoundary()
             throws FileUploadIOException, MalformedStreamException {
-        byte[] marker = new byte[2];
+        final byte[] marker = new byte[2];
         boolean nextChunk = false;
 
         head += boundaryLength;
@@ -425,10 +425,10 @@ public class MultipartStream {
                 throw new MalformedStreamException(
                 "Unexpected characters follow a boundary");
             }
-        } catch (FileUploadIOException e) {
+        } catch (final FileUploadIOException e) {
             // wraps a SizeException, re-throw as it will be unwrapped later
             throw e;
-        } catch (IOException e) {
+        } catch (final IOException e) {
             throw new MalformedStreamException("Stream ended unexpectedly");
         }
         return nextChunk;
@@ -453,7 +453,7 @@ public class MultipartStream {
      *                                  has a different length than the one
      *                                  being currently parsed.
      */
-    public void setBoundary(byte[] boundary)
+    public void setBoundary(final byte[] boundary)
             throws IllegalBoundaryException {
         if (boundary.length != boundaryLength - BOUNDARY_PREFIX.length) {
             throw new IllegalBoundaryException(
@@ -508,15 +508,15 @@ public class MultipartStream {
         int i = 0;
         byte b;
         // to support multi-byte characters
-        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        final ByteArrayOutputStream baos = new ByteArrayOutputStream();
         int size = 0;
         while (i < HEADER_SEPARATOR.length) {
             try {
                 b = readByte();
-            } catch (FileUploadIOException e) {
+            } catch (final FileUploadIOException e) {
                 // wraps a SizeException, re-throw as it will be unwrapped later
                 throw e;
-            } catch (IOException e) {
+            } catch (final IOException e) {
                 throw new MalformedStreamException("Stream ended unexpectedly");
             }
             if (++size > HEADER_PART_SIZE_MAX) {
@@ -536,7 +536,7 @@ public class MultipartStream {
         if (headerEncoding != null) {
             try {
                 headers = baos.toString(headerEncoding);
-            } catch (UnsupportedEncodingException e) {
+            } catch (final UnsupportedEncodingException e) {
                 // Fall back to platform default if specified encoding is not
                 // supported.
                 headers = baos.toString();
@@ -567,7 +567,7 @@ public class MultipartStream {
      * @throws MalformedStreamException if the stream ends unexpectedly.
      * @throws IOException              if an i/o error occurs.
      */
-    public int readBodyData(OutputStream output)
+    public int readBodyData(final OutputStream output)
             throws MalformedStreamException, IOException {
         return (int) Streams.copy(newInputStream(), output, false); // N.B. Streams.copy closes the input stream
     }
@@ -616,7 +616,7 @@ public class MultipartStream {
             // Read boundary - if succeeded, the stream contains an
             // encapsulation.
             return readBoundary();
-        } catch (MalformedStreamException e) {
+        } catch (final MalformedStreamException e) {
             return false;
         } finally {
             // Restore delimiter.
@@ -639,9 +639,9 @@ public class MultipartStream {
      * @return {@code true} if {@code count} first bytes in arrays
      *         {@code a} and {@code b} are equal.
      */
-    public static boolean arrayequals(byte[] a,
-            byte[] b,
-            int count) {
+    public static boolean arrayequals(final byte[] a,
+            final byte[] b,
+            final int count) {
         for (int i = 0; i < count; i++) {
             if (a[i] != b[i]) {
                 return false;
@@ -660,8 +660,8 @@ public class MultipartStream {
      * @return The position of byte found, counting from beginning of the
      *         {@code buffer}, or {@code -1} if not found.
      */
-    protected int findByte(byte value,
-            int pos) {
+    protected int findByte(final byte value,
+            final int pos) {
         for (int i = pos; i < tail; i++) {
             if (buffer[i] == value) {
                 return i;
@@ -713,7 +713,6 @@ public class MultipartStream {
          * detail message.
          */
         public MalformedStreamException() {
-            super();
         }
 
         /**
@@ -722,7 +721,7 @@ public class MultipartStream {
          *
          * @param message The detail message.
          */
-        public MalformedStreamException(String message) {
+        public MalformedStreamException(final String message) {
             super(message);
         }
 
@@ -743,7 +742,6 @@ public class MultipartStream {
          * detail message.
          */
         public IllegalBoundaryException() {
-            super();
         }
 
         /**
@@ -752,7 +750,7 @@ public class MultipartStream {
          *
          * @param message The detail message.
          */
-        public IllegalBoundaryException(String message) {
+        public IllegalBoundaryException(final String message) {
             super(message);
         }
 
@@ -851,7 +849,7 @@ public class MultipartStream {
                 return -1;
             }
             ++total;
-            int b = buffer[head++];
+            final int b = buffer[head++];
             if (b >= 0) {
                 return b;
             }
@@ -869,7 +867,7 @@ public class MultipartStream {
          * @throws IOException An I/O error occurred.
          */
         @Override
-        public int read(byte[] b, int off, int len) throws IOException {
+        public int read(final byte[] b, final int off, final int len) throws IOException {
             if (closed) {
                 throw new FileItemStream.ItemSkippedException();
             }
@@ -907,7 +905,7 @@ public class MultipartStream {
          *   (hard close)
          * @throws IOException An I/O error occurred.
          */
-        public void close(boolean pCloseUnderlying) throws IOException {
+        public void close(final boolean pCloseUnderlying) throws IOException {
             if (closed) {
                 return;
             }
@@ -938,7 +936,7 @@ public class MultipartStream {
          * @throws IOException An I/O error occurred.
          */
         @Override
-        public long skip(long bytes) throws IOException {
+        public long skip(final long bytes) throws IOException {
             if (closed) {
                 throw new FileItemStream.ItemSkippedException();
             }
@@ -949,7 +947,7 @@ public class MultipartStream {
                     return 0;
                 }
             }
-            long res = Math.min(av, bytes);
+            final long res = Math.min(av, bytes);
             head += res;
             return res;
         }
@@ -974,7 +972,7 @@ public class MultipartStream {
             tail = pad;
 
             for (;;) {
-                int bytesRead = input.read(buffer, tail, bufSize - tail);
+                final int bytesRead = input.read(buffer, tail, bufSize - tail);
                 if (bytesRead == -1) {
                     // The last pad amount is left in the buffer.
                     // Boundary can't be in there so signal an error
@@ -988,7 +986,7 @@ public class MultipartStream {
                 tail += bytesRead;
 
                 findSeparator();
-                int av = available();
+                final int av = available();
 
                 if (av > 0 || pos != -1) {
                     return av;

==================================================
DiskFileItem.java
index 943733c991..d5b90c2393 100644
--- a/java/org/apache/tomcat/util/http/fileupload/ParameterParser.java
+++ b/java/org/apache/tomcat/util/http/fileupload/ParameterParser.java
@@ -71,7 +71,6 @@ public class ParameterParser {
      * Default ParameterParser constructor.
      */
     public ParameterParser() {
-        super();
     }
 
     /**
@@ -93,7 +92,7 @@ public class ParameterParser {
      *               {@code false} otherwise.
      * @return the token
      */
-    private String getToken(boolean quoted) {
+    private String getToken(final boolean quoted) {
         // Trim leading white spaces
         while ((i1 < i2) && (Character.isWhitespace(chars[i1]))) {
             i1++;
@@ -126,9 +125,9 @@ public class ParameterParser {
      * @return {@code true} if the character is present in the array of
      *   characters, {@code false} otherwise.
      */
-    private boolean isOneOf(char ch, final char[] charray) {
+    private boolean isOneOf(final char ch, final char[] charray) {
         boolean result = false;
-        for (char element : charray) {
+        for (final char element : charray) {
             if (ch == element) {
                 result = true;
                 break;
@@ -213,7 +212,7 @@ public class ParameterParser {
      * converted to lower case when name/value pairs are parsed.
      * {@code false} otherwise.
      */
-    public void setLowerCaseNames(boolean b) {
+    public void setLowerCaseNames(final boolean b) {
         this.lowerCaseNames = b;
     }
 
@@ -227,7 +226,7 @@ public class ParameterParser {
      *
      * @return a map of name/value pairs
      */
-    public Map<String, String> parse(final String str, char[] separators) {
+    public Map<String, String> parse(final String str, final char[] separators) {
         if (separators == null || separators.length == 0) {
             return new HashMap<>();
         }
@@ -254,7 +253,7 @@ public class ParameterParser {
      *
      * @return a map of name/value pairs
      */
-    public Map<String, String> parse(final String str, char separator) {
+    public Map<String, String> parse(final String str, final char separator) {
         if (str == null) {
             return new HashMap<>();
         }
@@ -271,7 +270,7 @@ public class ParameterParser {
      *
      * @return a map of name/value pairs
      */
-    public Map<String, String> parse(final char[] charArray, char separator) {
+    public Map<String, String> parse(final char[] charArray, final char separator) {
         if (charArray == null) {
             return new HashMap<>();
         }
@@ -292,14 +291,14 @@ public class ParameterParser {
      */
     public Map<String, String> parse(
         final char[] charArray,
-        int offset,
-        int length,
-        char separator) {
+        final int offset,
+        final int length,
+        final char separator) {
 
         if (charArray == null) {
             return new HashMap<>();
         }
-        HashMap<String, String> params = new HashMap<>();
+        final HashMap<String, String> params = new HashMap<>();
         this.chars = charArray;
         this.pos = offset;
         this.len = length;
@@ -319,7 +318,7 @@ public class ParameterParser {
                     try {
                         paramValue = RFC2231Utility.hasEncodedValue(paramName) ? RFC2231Utility.decodeText(paramValue)
                                 : MimeUtility.decodeText(paramValue);
-                    } catch (UnsupportedEncodingException e) {
+                    } catch (final UnsupportedEncodingException e) {
                         // let's keep the original value in this case
                     }
                 }

==================================================
DiskFileItemFactory.java
index 4be597f9e0..2f2c25da85 100644
--- a/java/org/apache/tomcat/util/http/fileupload/disk/DiskFileItem.java
+++ b/java/org/apache/tomcat/util/http/fileupload/disk/DiskFileItem.java
@@ -165,9 +165,9 @@ public class DiskFileItem
      *                      which files will be created, should the item size
      *                      exceed the threshold.
      */
-    public DiskFileItem(String fieldName,
-            String contentType, boolean isFormField, String fileName,
-            int sizeThreshold, File repository) {
+    public DiskFileItem(final String fieldName,
+            final String contentType, final boolean isFormField, final String fileName,
+            final int sizeThreshold, final File repository) {
         this.fieldName = fieldName;
         this.contentType = contentType;
         this.isFormField = isFormField;
@@ -220,10 +220,10 @@ public class DiskFileItem
      *         not defined.
      */
     public String getCharSet() {
-        ParameterParser parser = new ParameterParser();
+        final ParameterParser parser = new ParameterParser();
         parser.setLowerCaseNames(true);
         // Parameter parser can handle null input
-        Map<String, String> params = parser.parse(getContentType(), ';');
+        final Map<String, String> params = parser.parse(getContentType(), ';');
         return params.get("charset");
     }
 
@@ -300,7 +300,7 @@ public class DiskFileItem
         try {
             fis = new FileInputStream(dfos.getFile());
             IOUtils.readFully(fis, fileData);
-        } catch (IOException e) {
+        } catch (final IOException e) {
             fileData = null;
         } finally {
             IOUtils.closeQuietly(fis);
@@ -338,14 +338,14 @@ public class DiskFileItem
      */
     @Override
     public String getString() {
-        byte[] rawdata = get();
+        final byte[] rawdata = get();
         String charset = getCharSet();
         if (charset == null) {
             charset = defaultCharset;
         }
         try {
             return new String(rawdata, charset);
-        } catch (UnsupportedEncodingException e) {
+        } catch (final UnsupportedEncodingException e) {
             return new String(rawdata);
         }
     }
@@ -371,7 +371,7 @@ public class DiskFileItem
      * @throws Exception if an error occurs.
      */
     @Override
-    public void write(File file) throws Exception {
+    public void write(final File file) throws Exception {
         if (isInMemory()) {
             FileOutputStream fout = null;
             try {
@@ -382,7 +382,7 @@ public class DiskFileItem
                 IOUtils.closeQuietly(fout);
             }
         } else {
-            File outputFile = getStoreLocation();
+            final File outputFile = getStoreLocation();
             if (outputFile != null) {
                 // Save the length of the file
                 size = outputFile.length();
@@ -433,7 +433,7 @@ public class DiskFileItem
     @Override
     public void delete() {
         cachedContent = null;
-        File outputFile = getStoreLocation();
+        final File outputFile = getStoreLocation();
         if (outputFile != null && !isInMemory() && outputFile.exists()) {
             outputFile.delete();
         }
@@ -462,7 +462,7 @@ public class DiskFileItem
      *
      */
     @Override
-    public void setFieldName(String fieldName) {
+    public void setFieldName(final String fieldName) {
         this.fieldName = fieldName;
     }
 
@@ -492,7 +492,7 @@ public class DiskFileItem
      *
      */
     @Override
-    public void setFormField(boolean state) {
+    public void setFormField(final boolean state) {
         isFormField = state;
     }
 
@@ -509,7 +509,7 @@ public class DiskFileItem
     public OutputStream getOutputStream()
         throws IOException {
         if (dfos == null) {
-            File outputFile = getTempFile();
+            final File outputFile = getTempFile();
             dfos = new DeferredFileOutputStream(sizeThreshold, outputFile);
         }
         return dfos;
@@ -550,7 +550,7 @@ public class DiskFileItem
         if (dfos == null || dfos.isInMemory()) {
             return;
         }
-        File outputFile = dfos.getFile();
+        final File outputFile = dfos.getFile();
 
         if (outputFile != null && outputFile.exists()) {
             outputFile.delete();
@@ -576,7 +576,7 @@ public class DiskFileItem
                 tempDir = new File(System.getProperty("java.io.tmpdir"));
             }
 
-            String tempFileName = String.format("upload_%s_%s.tmp", UID, getUniqueId());
+            final String tempFileName = String.format("upload_%s_%s.tmp", UID, getUniqueId());
 
             tempFile = new File(tempDir, tempFileName);
         }
@@ -593,7 +593,7 @@ public class DiskFileItem
      */
     private static String getUniqueId() {
         final int limit = 100000000;
-        int current = COUNTER.getAndIncrement();
+        final int current = COUNTER.getAndIncrement();
         String id = Integer.toString(current);
 
         // If you manage to get more than 100 million of ids, you'll
@@ -630,7 +630,7 @@ public class DiskFileItem
      * @param pHeaders The file items headers.
      */
     @Override
-    public void setHeaders(FileItemHeaders pHeaders) {
+    public void setHeaders(final FileItemHeaders pHeaders) {
         headers = pHeaders;
     }
 
@@ -648,7 +648,7 @@ public class DiskFileItem
      * parameter is provided by the sender.
      * @param charset the default charset
      */
-    public void setDefaultCharset(String charset) {
+    public void setDefaultCharset(final String charset) {
         defaultCharset = charset;
     }
 }

==================================================
FileItemIteratorImpl.java
index 90e8ac8801..67a2ed17bc 100644
--- a/java/org/apache/tomcat/util/http/fileupload/disk/DiskFileItemFactory.java
+++ b/java/org/apache/tomcat/util/http/fileupload/disk/DiskFileItemFactory.java
@@ -103,7 +103,7 @@ public class DiskFileItemFactory implements FileItemFactory {
      *                      which files will be created, should the item size
      *                      exceed the threshold.
      */
-    public DiskFileItemFactory(int sizeThreshold, File repository) {
+    public DiskFileItemFactory(final int sizeThreshold, final File repository) {
         this.sizeThreshold = sizeThreshold;
         this.repository = repository;
     }
@@ -132,7 +132,7 @@ public class DiskFileItemFactory implements FileItemFactory {
      * @see #getRepository()
      *
      */
-    public void setRepository(File repository) {
+    public void setRepository(final File repository) {
         this.repository = repository;
     }
 
@@ -156,7 +156,7 @@ public class DiskFileItemFactory implements FileItemFactory {
      * @see #getSizeThreshold()
      *
      */
-    public void setSizeThreshold(int sizeThreshold) {
+    public void setSizeThreshold(final int sizeThreshold) {
         this.sizeThreshold = sizeThreshold;
     }
 
@@ -177,9 +177,9 @@ public class DiskFileItemFactory implements FileItemFactory {
      * @return The newly created file item.
      */
     @Override
-    public FileItem createItem(String fieldName, String contentType,
-            boolean isFormField, String fileName) {
-        DiskFileItem result = new DiskFileItem(fieldName, contentType,
+    public FileItem createItem(final String fieldName, final String contentType,
+                final boolean isFormField, final String fileName) {
+        final DiskFileItem result = new DiskFileItem(fieldName, contentType,
                 isFormField, fileName, sizeThreshold, repository);
         result.setDefaultCharset(defaultCharset);
         return result;
@@ -199,7 +199,7 @@ public class DiskFileItemFactory implements FileItemFactory {
      * parameter is provided by the sender.
      * @param pCharset the default charset
      */
-    public void setDefaultCharset(String pCharset) {
+    public void setDefaultCharset(final String pCharset) {
         defaultCharset = pCharset;
     }
 }

==================================================
FileItemStreamImpl.java
index 7755f5da1c..6e2d574eb7 100644
--- a/java/org/apache/tomcat/util/http/fileupload/impl/FileItemIteratorImpl.java
+++ b/java/org/apache/tomcat/util/http/fileupload/impl/FileItemIteratorImpl.java
@@ -53,7 +53,7 @@ public class FileItemIteratorImpl implements FileItemIterator {
     }
 
     @Override
-    public void setSizeMax(long sizeMax) {
+    public void setSizeMax(final long sizeMax) {
         this.sizeMax = sizeMax;
     }
 
@@ -63,7 +63,7 @@ public class FileItemIteratorImpl implements FileItemIterator {
     }
 
     @Override
-    public void setFileSizeMax(long fileSizeMax) {
+    public void setFileSizeMax(final long fileSizeMax) {
         this.fileSizeMax = fileSizeMax;
     }
 
@@ -117,7 +117,7 @@ public class FileItemIteratorImpl implements FileItemIterator {
      *   parsing the request.
      * @throws IOException An I/O error occurred.
      */
-    public FileItemIteratorImpl(FileUploadBase fileUploadBase, RequestContext requestContext)
+    public FileItemIteratorImpl(final FileUploadBase fileUploadBase, final RequestContext requestContext)
         throws FileUploadException, IOException {
         this.fileUploadBase = fileUploadBase;
         sizeMax = fileUploadBase.getSizeMax();
@@ -127,9 +127,9 @@ public class FileItemIteratorImpl implements FileItemIterator {
         findNextItem();
     }
 
-    protected void init(FileUploadBase fileUploadBase, @SuppressWarnings("unused") RequestContext pRequestContext)
+    protected void init(final FileUploadBase fileUploadBase, @SuppressWarnings("unused") final RequestContext pRequestContext)
             throws FileUploadException, IOException {
-        String contentType = ctx.getContentType();
+        final String contentType = ctx.getContentType();
         if ((null == contentType)
                 || (!contentType.toLowerCase(Locale.ENGLISH).startsWith(FileUploadBase.MULTIPART))) {
             throw new InvalidContentTypeException(
@@ -139,7 +139,7 @@ public class FileItemIteratorImpl implements FileItemIterator {
 
         final long requestSize = ((UploadContext) ctx).contentLength();
 
-        InputStream input; // N.B. this is eventually closed in MultipartStream processing
+        final InputStream input; // N.B. this is eventually closed in MultipartStream processing
         if (sizeMax >= 0) {
             if (requestSize != -1 && requestSize > sizeMax) {
                 throw new SizeLimitExceededException(
@@ -150,9 +150,9 @@ public class FileItemIteratorImpl implements FileItemIterator {
             // N.B. this is eventually closed in MultipartStream processing
             input = new LimitedInputStream(ctx.getInputStream(), sizeMax) {
                 @Override
-                protected void raiseError(long pSizeMax, long pCount)
+                protected void raiseError(final long pSizeMax, final long pCount)
                         throws IOException {
-                    FileUploadException ex = new SizeLimitExceededException(
+                    final FileUploadException ex = new SizeLimitExceededException(
                     String.format("the request was rejected because its size (%s) exceeds the configured maximum (%s)",
                             Long.valueOf(pCount), Long.valueOf(pSizeMax)),
                            pCount, pSizeMax);
@@ -177,7 +177,7 @@ public class FileItemIteratorImpl implements FileItemIterator {
         progressNotifier = new MultipartStream.ProgressNotifier(fileUploadBase.getProgressListener(), requestSize);
         try {
             multiPartStream = new MultipartStream(input, multiPartBoundary, progressNotifier);
-        } catch (IllegalArgumentException iae) {
+        } catch (final IllegalArgumentException iae) {
             IOUtils.closeQuietly(input); // avoid possible resource leak
             throw new InvalidContentTypeException(
                     String.format("The boundary specified in the %s header is too long", FileUploadBase.CONTENT_TYPE), iae);
@@ -208,7 +208,7 @@ public class FileItemIteratorImpl implements FileItemIterator {
         }
         final MultipartStream multi = getMultiPartStream();
         for (;;) {
-            boolean nextPart;
+            final boolean nextPart;
             if (skipPreamble) {
                 nextPart = multi.skipPreamble();
             } else {
@@ -225,23 +225,23 @@ public class FileItemIteratorImpl implements FileItemIterator {
                 currentFieldName = null;
                 continue;
             }
-            FileItemHeaders headers = fileUploadBase.getParsedHeaders(multi.readHeaders());
+            final FileItemHeaders headers = fileUploadBase.getParsedHeaders(multi.readHeaders());
             if (currentFieldName == null) {
                 // We're parsing the outer multipart
-                String fieldName = fileUploadBase.getFieldName(headers);
+                final String fieldName = fileUploadBase.getFieldName(headers);
                 if (fieldName != null) {
-                    String subContentType = headers.getHeader(FileUploadBase.CONTENT_TYPE);
+                    final String subContentType = headers.getHeader(FileUploadBase.CONTENT_TYPE);
                     if (subContentType != null
                             &&  subContentType.toLowerCase(Locale.ENGLISH)
                                     .startsWith(FileUploadBase.MULTIPART_MIXED)) {
                         currentFieldName = fieldName;
                         // Multiple files associated with this field name
-                        byte[] subBoundary = fileUploadBase.getBoundary(subContentType);
+                        final byte[] subBoundary = fileUploadBase.getBoundary(subContentType);
                         multi.setBoundary(subBoundary);
                         skipPreamble = true;
                         continue;
                     }
-                    String fileName = fileUploadBase.getFileName(headers);
+                    final String fileName = fileUploadBase.getFileName(headers);
                     currentItem = new FileItemStreamImpl(this, fileName,
                             fieldName, headers.getHeader(FileUploadBase.CONTENT_TYPE),
                             fileName == null, getContentLength(headers));
@@ -251,7 +251,7 @@ public class FileItemIteratorImpl implements FileItemIterator {
                     return true;
                 }
             } else {
-                String fileName = fileUploadBase.getFileName(headers);
+                final String fileName = fileUploadBase.getFileName(headers);
                 if (fileName != null) {
                     currentItem = new FileItemStreamImpl(this, fileName,
                             currentFieldName,
@@ -267,10 +267,10 @@ public class FileItemIteratorImpl implements FileItemIterator {
         }
     }
 
-    private long getContentLength(FileItemHeaders pHeaders) {
+    private long getContentLength(final FileItemHeaders pHeaders) {
         try {
             return Long.parseLong(pHeaders.getHeader(FileUploadBase.CONTENT_LENGTH));
-        } catch (Exception e) {
+        } catch (final Exception e) {
             return -1;
         }
     }
@@ -295,7 +295,7 @@ public class FileItemIteratorImpl implements FileItemIterator {
         }
         try {
             return findNextItem();
-        } catch (FileUploadIOException e) {
+        } catch (final FileUploadIOException e) {
             // unwrap encapsulated SizeException
             throw (FileUploadException) e.getCause();
         }

==================================================
FileSizeLimitExceededException.java
index a65b896a76..dd02e6db9a 100644
--- a/java/org/apache/tomcat/util/http/fileupload/impl/FileItemStreamImpl.java
+++ b/java/org/apache/tomcat/util/http/fileupload/impl/FileItemStreamImpl.java
@@ -78,9 +78,9 @@ public class FileItemStreamImpl implements FileItemStream {
      * @throws IOException Creating the file item failed.
      * @throws FileUploadException Parsing the incoming data stream failed.
      */
-    public FileItemStreamImpl(FileItemIteratorImpl pFileItemIterator, String pName, String pFieldName,
-            String pContentType, boolean pFormField,
-            long pContentLength) throws FileUploadException, IOException {
+    public FileItemStreamImpl(final FileItemIteratorImpl pFileItemIterator, final String pName, final String pFieldName,
+            final String pContentType, final boolean pFormField,
+            final long pContentLength) throws FileUploadException, IOException {
         fileItemIteratorImpl = pFileItemIterator;
         name = pName;
         fieldName = pFieldName;
@@ -90,7 +90,7 @@ public class FileItemStreamImpl implements FileItemStream {
         if (fileSizeMax != -1) { // Check if limit is already exceeded
             if (pContentLength != -1
                     && pContentLength > fileSizeMax) {
-                FileSizeLimitExceededException e =
+                final FileSizeLimitExceededException e =
                         new FileSizeLimitExceededException(
                                 String.format("The field %s exceeds its maximum permitted size of %s bytes.",
                                         fieldName, Long.valueOf(fileSizeMax)),
@@ -106,10 +106,10 @@ public class FileItemStreamImpl implements FileItemStream {
         if (fileSizeMax != -1) {
             istream = new LimitedInputStream(istream, fileSizeMax) {
                 @Override
-                protected void raiseError(long pSizeMax, long pCount)
+                protected void raiseError(final long pSizeMax, final long pCount)
                         throws IOException {
                     itemStream.close(true);
-                    FileSizeLimitExceededException e =
+                    final FileSizeLimitExceededException e =
                         new FileSizeLimitExceededException(
                             String.format("The field %s exceeds its maximum permitted size of %s bytes.",
                                    fieldName, Long.valueOf(pSizeMax)),
@@ -208,7 +208,7 @@ public class FileItemStreamImpl implements FileItemStream {
      * @param pHeaders The items header object
      */
     @Override
-    public void setHeaders(FileItemHeaders pHeaders) {
+    public void setHeaders(final FileItemHeaders pHeaders) {
         headers = pHeaders;
     }
 

==================================================
FileUploadIOException.java
index 2ccac425c7..dba9715ecb 100644
--- a/java/org/apache/tomcat/util/http/fileupload/impl/FileSizeLimitExceededException.java
+++ b/java/org/apache/tomcat/util/http/fileupload/impl/FileSizeLimitExceededException.java
@@ -45,8 +45,8 @@ public class FileSizeLimitExceededException
      * @param actual    The actual request size.
      * @param permitted The maximum permitted request size.
      */
-    public FileSizeLimitExceededException(String message, long actual,
-            long permitted) {
+    public FileSizeLimitExceededException(final String message, final long actual,
+            final long permitted) {
         super(message, actual, permitted);
     }
 
@@ -66,7 +66,7 @@ public class FileSizeLimitExceededException
      *
      * @param pFileName the file name of the item, which caused the exception.
      */
-    public void setFileName(String pFileName) {
+    public void setFileName(final String pFileName) {
         fileName = pFileName;
     }
 
@@ -87,7 +87,7 @@ public class FileSizeLimitExceededException
      * @param pFieldName the field name of the item,
      *        which caused the exception.
      */
-    public void setFieldName(String pFieldName) {
+    public void setFieldName(final String pFieldName) {
         fieldName = pFieldName;
     }
 

==================================================
IOFileUploadException.java
index a5b99d8b31..3ac5988310 100644
--- a/java/org/apache/tomcat/util/http/fileupload/impl/FileUploadIOException.java
+++ b/java/org/apache/tomcat/util/http/fileupload/impl/FileUploadIOException.java
@@ -44,7 +44,7 @@ public class FileUploadIOException extends IOException {
      *
      * @param pCause The exceptions cause, if any, or null.
      */
-    public FileUploadIOException(FileUploadException pCause) {
+    public FileUploadIOException(final FileUploadException pCause) {
         // We're not doing super(pCause) cause of 1.3 compatibility.
         cause = pCause;
     }

==================================================
InvalidContentTypeException.java
index 90f259dc36..397be973cb 100644
--- a/java/org/apache/tomcat/util/http/fileupload/impl/IOFileUploadException.java
+++ b/java/org/apache/tomcat/util/http/fileupload/impl/IOFileUploadException.java
@@ -43,7 +43,7 @@ public class IOFileUploadException extends FileUploadException {
      * @param pMsg The detail message.
      * @param pException The exceptions cause.
      */
-    public IOFileUploadException(String pMsg, IOException pException) {
+    public IOFileUploadException(final String pMsg, final IOException pException) {
         super(pMsg);
         cause = pException;
     }

==================================================
SizeException.java
index f095ef012f..547349feb2 100644
--- a/java/org/apache/tomcat/util/http/fileupload/impl/InvalidContentTypeException.java
+++ b/java/org/apache/tomcat/util/http/fileupload/impl/InvalidContentTypeException.java
@@ -34,7 +34,6 @@ public class InvalidContentTypeException
      * detail message.
      */
     public InvalidContentTypeException() {
-        super();
     }
 
     /**
@@ -43,7 +42,7 @@ public class InvalidContentTypeException
      *
      * @param message The detail message.
      */
-    public InvalidContentTypeException(String message) {
+    public InvalidContentTypeException(final String message) {
         super(message);
     }
 
@@ -56,7 +55,7 @@ public class InvalidContentTypeException
      *
      * @since 1.3.1
      */
-    public InvalidContentTypeException(String msg, Throwable cause) {
+    public InvalidContentTypeException(final String msg, final Throwable cause) {
         super(msg, cause);
     }
 }
\ No newline at end of file

==================================================
SizeLimitExceededException.java
index 7928f2dbe2..eaed75fd3a 100644
--- a/java/org/apache/tomcat/util/http/fileupload/impl/SizeException.java
+++ b/java/org/apache/tomcat/util/http/fileupload/impl/SizeException.java
@@ -46,7 +46,7 @@ public abstract class SizeException extends FileUploadException {
      * @param actual The actual number of bytes in the request.
      * @param permitted The requests size limit, in bytes.
      */
-    protected SizeException(String message, long actual, long permitted) {
+    protected SizeException(final String message, final long actual, final long permitted) {
         super(message);
         this.actual = actual;
         this.permitted = permitted;

==================================================
ServletFileUpload.java
index 6289dab06d..6a7da5d5d9 100644
--- a/java/org/apache/tomcat/util/http/fileupload/impl/SizeLimitExceededException.java
+++ b/java/org/apache/tomcat/util/http/fileupload/impl/SizeLimitExceededException.java
@@ -35,8 +35,8 @@ public class SizeLimitExceededException
      * @param actual    The actual request size.
      * @param permitted The maximum permitted request size.
      */
-    public SizeLimitExceededException(String message, long actual,
-            long permitted) {
+    public SizeLimitExceededException(final String message, final long actual,
+            final long permitted) {
         super(message, actual, permitted);
     }
 

==================================================
ServletRequestContext.java
index 71ec1ca62e..bfb871d055 100644
--- a/java/org/apache/tomcat/util/http/fileupload/servlet/ServletFileUpload.java
+++ b/java/org/apache/tomcat/util/http/fileupload/servlet/ServletFileUpload.java
@@ -63,7 +63,7 @@ public class ServletFileUpload extends FileUpload {
      *         {@code false} otherwise.
      */
     public static final boolean isMultipartContent(
-            HttpServletRequest request) {
+            final HttpServletRequest request) {
         if (!POST_METHOD.equalsIgnoreCase(request.getMethod())) {
             return false;
         }
@@ -80,7 +80,6 @@ public class ServletFileUpload extends FileUpload {
      * @see FileUpload#FileUpload(FileItemFactory)
      */
     public ServletFileUpload() {
-        super();
     }
 
     /**
@@ -90,7 +89,7 @@ public class ServletFileUpload extends FileUpload {
      * @see FileUpload#FileUpload()
      * @param fileItemFactory The factory to use for creating file items.
      */
-    public ServletFileUpload(FileItemFactory fileItemFactory) {
+    public ServletFileUpload(final FileItemFactory fileItemFactory) {
         super(fileItemFactory);
     }
 
@@ -109,7 +108,7 @@ public class ServletFileUpload extends FileUpload {
      *
      * @since 1.3
      */
-    public Map<String, List<FileItem>> parseParameterMap(HttpServletRequest request)
+    public Map<String, List<FileItem>> parseParameterMap(final HttpServletRequest request)
             throws FileUploadException {
         return parseParameterMap(new ServletRequestContext(request));
     }
@@ -130,7 +129,7 @@ public class ServletFileUpload extends FileUpload {
      *   error while communicating with the client or a problem while
      *   storing the uploaded content.
      */
-    public FileItemIterator getItemIterator(HttpServletRequest request)
+    public FileItemIterator getItemIterator(final HttpServletRequest request)
     throws FileUploadException, IOException {
         return super.getItemIterator(new ServletRequestContext(request));
     }

==================================================
FileItemHeadersImpl.java
index 7e6c5338b0..e43440c8ec 100644
--- a/java/org/apache/tomcat/util/http/fileupload/servlet/ServletRequestContext.java
+++ b/java/org/apache/tomcat/util/http/fileupload/servlet/ServletRequestContext.java
@@ -47,7 +47,7 @@ public class ServletRequestContext implements UploadContext {
      *
      * @param request The request to which this context applies.
      */
-    public ServletRequestContext(HttpServletRequest request) {
+    public ServletRequestContext(final HttpServletRequest request) {
         this.request = request;
     }
 
@@ -84,7 +84,7 @@ public class ServletRequestContext implements UploadContext {
         long size;
         try {
             size = Long.parseLong(request.getHeader(FileUploadBase.CONTENT_LENGTH));
-        } catch (NumberFormatException e) {
+        } catch (final NumberFormatException e) {
             size = request.getContentLength();
         }
         return size;

==================================================
LimitedInputStream.java
index 079a7b399e..1047dc38ce 100644
--- a/java/org/apache/tomcat/util/http/fileupload/util/FileItemHeadersImpl.java
+++ b/java/org/apache/tomcat/util/http/fileupload/util/FileItemHeadersImpl.java
@@ -49,9 +49,9 @@ public class FileItemHeadersImpl implements FileItemHeaders, Serializable {
      * {@inheritDoc}
      */
     @Override
-    public String getHeader(String name) {
-        String nameLower = name.toLowerCase(Locale.ENGLISH);
-        List<String> headerValueList = headerNameToValueListMap.get(nameLower);
+    public String getHeader(final String name) {
+        final String nameLower = name.toLowerCase(Locale.ENGLISH);
+        final List<String> headerValueList = headerNameToValueListMap.get(nameLower);
         if (null == headerValueList) {
             return null;
         }
@@ -70,8 +70,8 @@ public class FileItemHeadersImpl implements FileItemHeaders, Serializable {
      * {@inheritDoc}
      */
     @Override
-    public Iterator<String> getHeaders(String name) {
-        String nameLower = name.toLowerCase(Locale.ENGLISH);
+    public Iterator<String> getHeaders(final String name) {
+        final String nameLower = name.toLowerCase(Locale.ENGLISH);
         List<String> headerValueList = headerNameToValueListMap.get(nameLower);
         if (null == headerValueList) {
             headerValueList = Collections.emptyList();
@@ -85,8 +85,8 @@ public class FileItemHeadersImpl implements FileItemHeaders, Serializable {
      * @param name name of this header
      * @param value value of this header
      */
-    public synchronized void addHeader(String name, String value) {
-        String nameLower = name.toLowerCase(Locale.ENGLISH);
+    public synchronized void addHeader(final String name, final String value) {
+        final String nameLower = name.toLowerCase(Locale.ENGLISH);
         List<String> headerValueList = headerNameToValueListMap.get(nameLower);
         if (null == headerValueList) {
             headerValueList = new ArrayList<>();

==================================================
Streams.java
index 0679314427..def25ca125 100644
--- a/java/org/apache/tomcat/util/http/fileupload/util/LimitedInputStream.java
+++ b/java/org/apache/tomcat/util/http/fileupload/util/LimitedInputStream.java
@@ -48,7 +48,7 @@ public abstract class LimitedInputStream extends FilterInputStream implements Cl
      * @param pSizeMax The limit; no more than this number of bytes
      *   shall be returned by the source stream.
      */
-    public LimitedInputStream(InputStream inputStream, long pSizeMax) {
+    public LimitedInputStream(final InputStream inputStream, final long pSizeMax) {
         super(inputStream);
         sizeMax = pSizeMax;
     }
@@ -96,7 +96,7 @@ public abstract class LimitedInputStream extends FilterInputStream implements Cl
      */
     @Override
     public int read() throws IOException {
-        int res = super.read();
+        final int res = super.read();
         if (res != -1) {
             count++;
             checkLimit();
@@ -128,8 +128,8 @@ public abstract class LimitedInputStream extends FilterInputStream implements Cl
      * @see        java.io.FilterInputStream#in
      */
     @Override
-    public int read(byte[] b, int off, int len) throws IOException {
-        int res = super.read(b, off, len);
+    public int read(final byte[] b, final int off, final int len) throws IOException {
+        final int res = super.read(b, off, len);
         if (res > 0) {
             count += res;
             checkLimit();

==================================================
MimeUtility.java
index e7afa72f07..1ba61064c9 100644
--- a/java/org/apache/tomcat/util/http/fileupload/util/Streams.java
+++ b/java/org/apache/tomcat/util/http/fileupload/util/Streams.java
@@ -63,7 +63,7 @@ public final class Streams {
      * @return Number of bytes, which have been copied.
      * @throws IOException An I/O error occurred.
      */
-    public static long copy(InputStream inputStream, OutputStream outputStream, boolean closeOutputStream)
+    public static long copy(final InputStream inputStream, final OutputStream outputStream, final boolean closeOutputStream)
             throws IOException {
         return copy(inputStream, outputStream, closeOutputStream, new byte[DEFAULT_BUFFER_SIZE]);
     }
@@ -86,16 +86,16 @@ public final class Streams {
      * @return Number of bytes, which have been copied.
      * @throws IOException An I/O error occurred.
      */
-    public static long copy(InputStream inputStream,
-            OutputStream outputStream, boolean closeOutputStream,
-            byte[] buffer)
+    public static long copy(final InputStream inputStream,
+            final OutputStream outputStream, final boolean closeOutputStream,
+            final byte[] buffer)
     throws IOException {
         OutputStream out = outputStream;
         InputStream in = inputStream;
         try {
             long total = 0;
             for (;;) {
-                int res = in.read(buffer);
+                final int res = in.read(buffer);
                 if (res == -1) {
                     break;
                 }
@@ -136,8 +136,8 @@ public final class Streams {
      * @return The streams contents, as a string.
      * @throws IOException An I/O error occurred.
      */
-    public static String asString(InputStream inputStream) throws IOException {
-        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+    public static String asString(final InputStream inputStream) throws IOException {
+        final ByteArrayOutputStream baos = new ByteArrayOutputStream();
         copy(inputStream, baos, true);
         return baos.toString();
     }
@@ -155,7 +155,7 @@ public final class Streams {
      */
     public static String asString(final InputStream inputStream, final String encoding)
             throws IOException {
-        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        final ByteArrayOutputStream baos = new ByteArrayOutputStream();
         copy(inputStream, baos, true);
         return baos.toString(encoding);
     }
@@ -170,12 +170,12 @@ public final class Streams {
      * @return Unmodified file name, if valid.
      * @throws InvalidFileNameException The file name was found to be invalid.
      */
-    public static String checkFileName(String fileName) {
+    public static String checkFileName(final String fileName) {
         if (fileName != null  &&  fileName.indexOf('\u0000') != -1) {
             // pFileName.replace("\u0000", "\\0")
             final StringBuilder sb = new StringBuilder();
             for (int i = 0;  i < fileName.length();  i++) {
-                char c = fileName.charAt(i);
+                final char c = fileName.charAt(i);
                 switch (c) {
                     case 0:
                         sb.append("\\0");

==================================================
ParseException.java
index a6200ca760..a4da181299 100644
--- a/java/org/apache/tomcat/util/http/fileupload/util/mime/MimeUtility.java
+++ b/java/org/apache/tomcat/util/http/fileupload/util/mime/MimeUtility.java
@@ -91,7 +91,7 @@ public final class MimeUtility {
      * @return The decoded text string.
      * @throws UnsupportedEncodingException if the detected encoding in the input text is not supported.
      */
-    public static String decodeText(String text) throws UnsupportedEncodingException {
+    public static String decodeText(final String text) throws UnsupportedEncodingException {
         // if the text contains any encoded tokens, those tokens will be marked with "=?".  If the
         // source string doesn't contain that sequent, no decoding is required.
         if (!text.contains(ENCODED_TOKEN_MARKER)) {
@@ -99,12 +99,12 @@ public final class MimeUtility {
         }
 
         int offset = 0;
-        int endOffset = text.length();
+        final int endOffset = text.length();
 
         int startWhiteSpace = -1;
         int endWhiteSpace = -1;
 
-        StringBuilder decodedText = new StringBuilder(text.length());
+        final StringBuilder decodedText = new StringBuilder(text.length());
 
         boolean previousTokenEncoded = false;
 
@@ -128,7 +128,7 @@ public final class MimeUtility {
                 }
             } else {
                 // we have a word token.  We need to scan over the word and then try to parse it.
-                int wordStart = offset;
+                final int wordStart = offset;
 
                 while (offset < endOffset) {
                     // step over the non white space characters.
@@ -142,12 +142,12 @@ public final class MimeUtility {
                     //NB:  Trailing whitespace on these header strings will just be discarded.
                 }
                 // pull out the word token.
-                String word = text.substring(wordStart, offset);
+                final String word = text.substring(wordStart, offset);
                 // is the token encoded?  decode the word
                 if (word.startsWith(ENCODED_TOKEN_MARKER)) {
                     try {
                         // if this gives a parsing failure, treat it like a non-encoded word.
-                        String decodedWord = decodeWord(word);
+                        final String decodedWord = decodeWord(word);
 
                         // are any whitespace characters significant?  Append 'em if we've got 'em.
                         if (!previousTokenEncoded && startWhiteSpace != -1) {
@@ -162,7 +162,7 @@ public final class MimeUtility {
                         // and get handled as normal text.
                         continue;
 
-                    } catch (ParseException e) {
+                    } catch (final ParseException e) {
                         // just ignore it, skip to next word
                     }
                 }
@@ -193,7 +193,7 @@ public final class MimeUtility {
      * @throws ParseException
      * @throws UnsupportedEncodingException
      */
-    private static String decodeWord(String word) throws ParseException, UnsupportedEncodingException {
+    private static String decodeWord(final String word) throws ParseException, UnsupportedEncodingException {
         // encoded words start with the characters "=?".  If this not an encoded word, we throw a
         // ParseException for the caller.
 
@@ -201,29 +201,29 @@ public final class MimeUtility {
             throw new ParseException("Invalid RFC 2047 encoded-word: " + word);
         }
 
-        int charsetPos = word.indexOf('?', 2);
+        final int charsetPos = word.indexOf('?', 2);
         if (charsetPos == -1) {
             throw new ParseException("Missing charset in RFC 2047 encoded-word: " + word);
         }
 
         // pull out the character set information (this is the MIME name at this point).
-        String charset = word.substring(2, charsetPos).toLowerCase(Locale.ENGLISH);
+        final String charset = word.substring(2, charsetPos).toLowerCase(Locale.ENGLISH);
 
         // now pull out the encoding token the same way.
-        int encodingPos = word.indexOf('?', charsetPos + 1);
+        final int encodingPos = word.indexOf('?', charsetPos + 1);
         if (encodingPos == -1) {
             throw new ParseException("Missing encoding in RFC 2047 encoded-word: " + word);
         }
 
-        String encoding = word.substring(charsetPos + 1, encodingPos);
+        final String encoding = word.substring(charsetPos + 1, encodingPos);
 
         // and finally the encoded text.
-        int encodedTextPos = word.indexOf(ENCODED_TOKEN_FINISHER, encodingPos + 1);
+        final int encodedTextPos = word.indexOf(ENCODED_TOKEN_FINISHER, encodingPos + 1);
         if (encodedTextPos == -1) {
             throw new ParseException("Missing encoded text in RFC 2047 encoded-word: " + word);
         }
 
-        String encodedText = word.substring(encodingPos + 1, encodedTextPos);
+        final String encodedText = word.substring(encodingPos + 1, encodedTextPos);
 
         // seems a bit silly to encode a null string, but easy to deal with.
         if (encodedText.length() == 0) {
@@ -232,7 +232,7 @@ public final class MimeUtility {
 
         try {
             // the decoder writes directly to an output stream.
-            ByteArrayOutputStream out = new ByteArrayOutputStream(encodedText.length());
+            final ByteArrayOutputStream out = new ByteArrayOutputStream(encodedText.length());
 
             byte[] decodedData;
             // Base64 encoded?
@@ -247,7 +247,7 @@ public final class MimeUtility {
             }
             // Convert decoded byte data into a string.
             return new String(decodedData, javaCharset(charset));
-        } catch (IOException e) {
+        } catch (final IOException e) {
             throw new UnsupportedEncodingException("Invalid RFC 2047 encoding");
         }
     }
@@ -260,13 +260,13 @@ public final class MimeUtility {
      *
      * @return The Java equivalent for this name.
      */
-    private static String javaCharset(String charset) {
+    private static String javaCharset(final String charset) {
         // nothing in, nothing out.
         if (charset == null) {
             return null;
         }
 
-        String mappedCharset = MIME2JAVA.get(charset.toLowerCase(Locale.ENGLISH));
+        final String mappedCharset = MIME2JAVA.get(charset.toLowerCase(Locale.ENGLISH));
         // if there is no mapping, then the original name is used.  Many of the MIME character set
         // names map directly back into Java.  The reverse isn't necessarily true.
         if (mappedCharset == null) {

==================================================
QuotedPrintableDecoder.java
index 304f49e8b3..ea102a9430 100644
--- a/java/org/apache/tomcat/util/http/fileupload/util/mime/ParseException.java
+++ b/java/org/apache/tomcat/util/http/fileupload/util/mime/ParseException.java
@@ -31,7 +31,7 @@ final class ParseException extends Exception {
      *
      * @param message the detail message.
      */
-    public ParseException(String message) {
+    public ParseException(final String message) {
         super(message);
     }
 

==================================================
RFC2231Utility.java
index 16b7cd0e53..b7a75de4e9 100644
--- a/java/org/apache/tomcat/util/http/fileupload/util/mime/QuotedPrintableDecoder.java
+++ b/java/org/apache/tomcat/util/http/fileupload/util/mime/QuotedPrintableDecoder.java
@@ -47,14 +47,14 @@ final class QuotedPrintableDecoder {
      * @throws IOException if a problem occurs during either decoding or
      *            writing to the stream
      */
-    public static int decode(byte[] data, OutputStream out) throws IOException {
+    public static int decode(final byte[] data, final OutputStream out) throws IOException {
         int off = 0;
-        int length = data.length;
-        int endOffset = off + length;
+        final int length = data.length;
+        final int endOffset = off + length;
         int bytesWritten = 0;
 
         while (off < endOffset) {
-            byte ch = data[off++];
+            final byte ch = data[off++];
 
             // space characters were translated to '_' on encode, so we need to translate them back.
             if (ch == '_') {
@@ -66,8 +66,8 @@ final class QuotedPrintableDecoder {
                     throw new IOException("Invalid quoted printable encoding; truncated escape sequence");
                 }
 
-                byte b1 = data[off++];
-                byte b2 = data[off++];
+                final byte b1 = data[off++];
+                final byte b2 = data[off++];
 
                 // we've found an encoded carriage return.  The next char needs to be a newline
                 if (b1 == '\r') {
@@ -78,8 +78,8 @@ final class QuotedPrintableDecoder {
                     // on decode.
                 } else {
                     // this is a hex pair we need to convert back to a single byte.
-                    int c1 = hexToBinary(b1);
-                    int c2 = hexToBinary(b2);
+                    final int c1 = hexToBinary(b1);
+                    final int c2 = hexToBinary(b2);
                     out.write((c1 << UPPER_NIBBLE_SHIFT) | c2);
                     // 3 bytes in, one byte out
                     bytesWritten++;

==================================================
