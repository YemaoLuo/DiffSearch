2244cd6fb4fd0db708856806ca85d1d3ec1d10ff
==================================================
Clean-up. No functional change.
==================================================
Mark Emlyn
==================================================
Sat Oct 22 19:21:08 2011 +0000
==================================================
ClientAbortException.java
Clean-up. No functional change.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1187753 13f79535-47bb-0310-9956-ffa450edef68



==================================================
CometEventImpl.java
index d8fc212536..c39f0aa333 100644
--- a/java/org/apache/catalina/connector/ClientAbortException.java
+++ b/java/org/apache/catalina/connector/ClientAbortException.java
@@ -5,17 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-
 package org.apache.catalina.connector;
 
 import java.io.IOException;
@@ -32,7 +30,7 @@ public final class ClientAbortException extends IOException {
 
     private static final long serialVersionUID = 1L;
 
-    
+
     //------------------------------------------------------------ Constructors
 
     /**
@@ -119,12 +117,12 @@ public final class ClientAbortException extends IOException {
      */
     @Override
     public Throwable getCause() {
-        
+
         return (throwable);
-        
+
     }
 
-    
+
     /**
      * Return a formatted string that describes this exception.
      */

==================================================
Connector.java
index 6b35139c4b..a5d20ac53e 100644
--- a/java/org/apache/catalina/connector/CometEventImpl.java
+++ b/java/org/apache/catalina/connector/CometEventImpl.java
@@ -5,17 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-
 package org.apache.catalina.connector;
 
 import java.io.IOException;
@@ -45,7 +43,7 @@ public class CometEventImpl implements CometEvent {
 
     // ----------------------------------------------------- Instance Variables
 
-    
+
     /**
      * Associated request.
      */
@@ -57,18 +55,18 @@ public class CometEventImpl implements CometEvent {
      */
     protected Response response = null;
 
-    
+
     /**
      * Event type.
      */
     protected EventType eventType = EventType.BEGIN;
-    
+
 
     /**
      * Event sub type.
      */
     protected EventSubType eventSubType = null;
-    
+
 
     // --------------------------------------------------------- Public Methods
 
@@ -83,11 +81,11 @@ public class CometEventImpl implements CometEvent {
     public void setEventType(EventType eventType) {
         this.eventType = eventType;
     }
-    
+
     public void setEventSubType(EventSubType eventSubType) {
         this.eventSubType = eventSubType;
     }
-    
+
     @Override
     public void close() throws IOException {
         if (request == null) {
@@ -125,12 +123,14 @@ public class CometEventImpl implements CometEvent {
             UnsupportedOperationException {
         if (request.getAttribute("org.apache.tomcat.comet.timeout.support") == Boolean.TRUE) {
             request.setAttribute("org.apache.tomcat.comet.timeout", Integer.valueOf(timeout));
-            if (request.isComet()) request.setCometTimeout(timeout);
+            if (request.isComet()) {
+                request.setCometTimeout(timeout);
+            }
         } else {
             throw new UnsupportedOperationException();
         }
     }
-    
+
     @Override
     public String toString() {
         StringBuilder buf = new StringBuilder();

==================================================
Constants.java
index a83719d368..67902a9952 100644
--- a/java/org/apache/catalina/connector/Connector.java
+++ b/java/org/apache/catalina/connector/Connector.java
@@ -14,8 +14,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-
 package org.apache.catalina.connector;
 
 import java.util.Arrays;
@@ -343,7 +341,7 @@ public class Connector extends LifecycleMBeanBase  {
 
     }
 
-    
+
     /**
      * Return the default timeout for async requests in ms.
      */
@@ -366,7 +364,7 @@ public class Connector extends LifecycleMBeanBase  {
 
     }
 
-    
+
     /**
      * Return the "enable DNS lookups" flag.
      */
@@ -469,11 +467,13 @@ public class Connector extends LifecycleMBeanBase  {
 
         HashSet<String> methodSet = new HashSet<String>();
 
-        if( null != methods )
+        if( null != methods ) {
             methodSet.addAll(Arrays.asList(methods.split("\\s*,\\s*")));
+        }
 
-        if( methodSet.contains("TRACE") )
+        if( methodSet.contains("TRACE") ) {
             throw new IllegalArgumentException(sm.getString("coyoteConnector.parseBodyMethodNoTrace"));
+        }
 
         this.parseBodyMethods = methods;
         this.parseBodyMethodsSet = methodSet;
@@ -528,7 +528,7 @@ public class Connector extends LifecycleMBeanBase  {
         return getProtocolHandlerClassName();
 
     }
-    
+
 
     /**
      * Set the Coyote protocol which will be used by the connector.
@@ -848,7 +848,7 @@ public class Connector extends LifecycleMBeanBase  {
 
 
     protected String createObjectNameKeyProperties(String type) {
-        
+
         Object addressObj = getProperty("address");
 
         StringBuilder sb = new StringBuilder("type=");
@@ -896,14 +896,15 @@ public class Connector extends LifecycleMBeanBase  {
     protected void initInternal() throws LifecycleException {
 
         super.initInternal();
-        
+
         // Initialize adapter
         adapter = new CoyoteAdapter(this);
         protocolHandler.setAdapter(adapter);
 
         // Make sure parseBodyMethodsSet has a default
-        if( null == parseBodyMethodsSet )
+        if( null == parseBodyMethodsSet ) {
             setParseBodyMethods(getParseBodyMethods());
+        }
 
         try {
             protocolHandler.init();
@@ -976,7 +977,7 @@ public class Connector extends LifecycleMBeanBase  {
     @Override
     protected void destroyInternal() throws LifecycleException {
         mapperListener.destroy();
-        
+
         try {
             protocolHandler.destroy();
         } catch (Exception e) {
@@ -988,7 +989,7 @@ public class Connector extends LifecycleMBeanBase  {
         if (getService() != null) {
             getService().removeConnector(this);
         }
-        
+
         super.destroyInternal();
     }
 

==================================================
CoyoteAdapter.java
index 34fd656447..3130be4d5c 100644
--- a/java/org/apache/catalina/connector/Constants.java
+++ b/java/org/apache/catalina/connector/Constants.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
CoyoteInputStream.java
index e38fcdcb86..91f61c6b1d 100644
--- a/java/org/apache/catalina/connector/CoyoteAdapter.java
+++ b/java/org/apache/catalina/connector/CoyoteAdapter.java
@@ -14,8 +14,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-
 package org.apache.catalina.connector;
 
 import java.io.IOException;

==================================================
CoyoteOutputStream.java
index dfdca5b041..bfe32cf204 100644
--- a/java/org/apache/catalina/connector/CoyoteInputStream.java
+++ b/java/org/apache/catalina/connector/CoyoteInputStream.java
@@ -5,17 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
-
-
+ */
 package org.apache.catalina.connector;
 
 import java.io.IOException;
@@ -29,7 +27,7 @@ import org.apache.catalina.security.SecurityUtil;
 
 /**
  * This class handles reading bytes.
- * 
+ *
  * @author Remy Maucherat
  * @author Jean-Francois Arcand
  */
@@ -80,11 +78,11 @@ public class CoyoteInputStream
 
     @Override
     public int read()
-        throws IOException {    
+        throws IOException {
         if (SecurityUtil.isPackageProtectionEnabled()){
-            
+
             try{
-                Integer result = 
+                Integer result =
                     AccessController.doPrivileged(
                         new PrivilegedExceptionAction<Integer>(){
 
@@ -111,10 +109,10 @@ public class CoyoteInputStream
 
     @Override
     public int available() throws IOException {
-        
+
         if (SecurityUtil.isPackageProtectionEnabled()){
             try{
-                Integer result = 
+                Integer result =
                     AccessController.doPrivileged(
                         new PrivilegedExceptionAction<Integer>(){
 
@@ -136,21 +134,21 @@ public class CoyoteInputStream
             }
         } else {
            return ib.available();
-        }    
+        }
     }
 
     @Override
     public int read(final byte[] b) throws IOException {
-        
+
         if (SecurityUtil.isPackageProtectionEnabled()){
             try{
-                Integer result = 
+                Integer result =
                     AccessController.doPrivileged(
                         new PrivilegedExceptionAction<Integer>(){
 
                             @Override
                             public Integer run() throws IOException{
-                                Integer integer = 
+                                Integer integer =
                                     Integer.valueOf(ib.read(b, 0, b.length));
                                 return integer;
                             }
@@ -167,23 +165,23 @@ public class CoyoteInputStream
             }
         } else {
             return ib.read(b, 0, b.length);
-         }        
+         }
     }
 
 
     @Override
     public int read(final byte[] b, final int off, final int len)
         throws IOException {
-            
+
         if (SecurityUtil.isPackageProtectionEnabled()){
             try{
-                Integer result = 
+                Integer result =
                     AccessController.doPrivileged(
                         new PrivilegedExceptionAction<Integer>(){
 
                             @Override
                             public Integer run() throws IOException{
-                                Integer integer = 
+                                Integer integer =
                                     Integer.valueOf(ib.read(b, off, len));
                                 return integer;
                             }
@@ -200,7 +198,7 @@ public class CoyoteInputStream
             }
         } else {
             return ib.read(b, off, len);
-        }            
+        }
     }
 
 
@@ -210,14 +208,14 @@ public class CoyoteInputStream
     }
 
 
-    /** 
+    /**
      * Close the stream
      * Since we re-cycle, we can't allow the call to super.close()
      * which would permanently disable us.
      */
     @Override
     public void close() throws IOException {
-        
+
         if (SecurityUtil.isPackageProtectionEnabled()){
             try{
                 AccessController.doPrivileged(

==================================================
CoyotePrincipal.java
index b264634b12..3c7bd410ab 100644
--- a/java/org/apache/catalina/connector/CoyoteOutputStream.java
+++ b/java/org/apache/catalina/connector/CoyoteOutputStream.java
@@ -5,17 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
-
-
+ */
 package org.apache.catalina.connector;
 
 import java.io.IOException;
@@ -24,11 +22,11 @@ import javax.servlet.ServletOutputStream;
 
 /**
  * Coyote implementation of the servlet output stream.
- * 
+ *
  * @author Costin Manolache
  * @author Remy Maucherat
  */
-public class CoyoteOutputStream 
+public class CoyoteOutputStream
     extends ServletOutputStream {
 
 

==================================================
CoyoteReader.java
index 54373dacb3..e3b3f9bd54 100644
--- a/java/org/apache/catalina/connector/CoyotePrincipal.java
+++ b/java/org/apache/catalina/connector/CoyotePrincipal.java
@@ -5,17 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-
 package org.apache.catalina.connector;
 
 import java.io.Serializable;

==================================================
CoyoteWriter.java
index eb24dd83d5..45ce8f7938 100644
--- a/java/org/apache/catalina/connector/CoyoteReader.java
+++ b/java/org/apache/catalina/connector/CoyoteReader.java
@@ -5,17 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
-
-
+ */
 package org.apache.catalina.connector;
 
 import java.io.BufferedReader;
@@ -24,7 +22,7 @@ import java.io.IOException;
 
 /**
  * Coyote implementation of the buffered reader.
- * 
+ *
  * @author Remy Maucherat
  */
 public class CoyoteReader

==================================================
InputBuffer.java
index fbf2d90e59..57b619700f 100644
--- a/java/org/apache/catalina/connector/CoyoteWriter.java
+++ b/java/org/apache/catalina/connector/CoyoteWriter.java
@@ -5,17 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
-
-
+ */
 package org.apache.catalina.connector;
 
 import java.io.IOException;
@@ -23,7 +21,7 @@ import java.io.PrintWriter;
 
 /**
  * Coyote implementation of the servlet writer.
- * 
+ *
  * @author Remy Maucherat
  */
 public class CoyoteWriter
@@ -92,8 +90,9 @@ public class CoyoteWriter
     @Override
     public void flush() {
 
-        if (error)
+        if (error) {
             return;
+        }
 
         try {
             ob.flush();
@@ -129,8 +128,9 @@ public class CoyoteWriter
     @Override
     public void write(int c) {
 
-        if (error)
+        if (error) {
             return;
+        }
 
         try {
             ob.write(c);
@@ -144,8 +144,9 @@ public class CoyoteWriter
     @Override
     public void write(char buf[], int off, int len) {
 
-        if (error)
+        if (error) {
             return;
+        }
 
         try {
             ob.write(buf, off, len);
@@ -165,8 +166,9 @@ public class CoyoteWriter
     @Override
     public void write(String s, int off, int len) {
 
-        if (error)
+        if (error) {
             return;
+        }
 
         try {
             ob.write(s, off, len);

==================================================
MapperListener.java
index 4d03bb2b6c..0a4631015c 100644
--- a/java/org/apache/catalina/connector/InputBuffer.java
+++ b/java/org/apache/catalina/connector/InputBuffer.java
@@ -5,16 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
-
+ */
 package org.apache.catalina.connector;
 
 import java.io.IOException;
@@ -35,7 +34,7 @@ import org.apache.tomcat.util.res.StringManager;
 
 /**
  * The buffer used by Tomcat request. This is a derivative of the Tomcat 3.3
- * OutputBuffer, adapted to handle input instead of output. This allows 
+ * OutputBuffer, adapted to handle input instead of output. This allows
  * complete recycling of the facade objects (the ServletInputStream and the
  * BufferedReader).
  *
@@ -55,7 +54,7 @@ public class InputBuffer extends Reader
     // -------------------------------------------------------------- Constants
 
 
-    public static final String DEFAULT_ENCODING = 
+    public static final String DEFAULT_ENCODING =
         org.apache.coyote.Constants.DEFAULT_CHARACTER_ENCODING;
     public static final int DEFAULT_BUFFER_SIZE = 8*1024;
 
@@ -71,7 +70,7 @@ public class InputBuffer extends Reader
     /**
      * The byte buffer.
      */
-    private ByteChunk bb;
+    private final ByteChunk bb;
 
 
     /**
@@ -150,7 +149,7 @@ public class InputBuffer extends Reader
 
     /**
      * Alternate constructor which allows specifying the initial buffer size.
-     * 
+     *
      * @param size Buffer size to use
      */
     public InputBuffer(int size) {
@@ -173,7 +172,7 @@ public class InputBuffer extends Reader
 
     /**
      * Associated Coyote request.
-     * 
+     *
      * @param coyoteRequest Associated Coyote request
      */
     public void setRequest(Request coyoteRequest) {
@@ -183,7 +182,7 @@ public class InputBuffer extends Reader
 
     /**
      * Get associated Coyote request.
-     * 
+     *
      * @return the associated Coyote request
      */
     public Request getRequest() {
@@ -198,9 +197,9 @@ public class InputBuffer extends Reader
      * Recycle the output buffer.
      */
     public void recycle() {
-        
+
         state = INITIAL_STATE;
-        
+
         // If usage of mark made the buffer too big, reallocate it
         if (cb.getChars().length > size) {
             cb = new CharChunk(size);
@@ -212,16 +211,16 @@ public class InputBuffer extends Reader
             cb.recycle();
         }
         markPos = -1;
-        bb.recycle(); 
+        bb.recycle();
         closed = false;
-        
+
         if (conv != null) {
             conv.recycle();
         }
-        
+
         gotEnc = false;
         enc = null;
-        
+
     }
 
 
@@ -231,11 +230,11 @@ public class InputBuffer extends Reader
     public void clearEncoders() {
         encoders.clear();
     }
-    
-    
+
+
     /**
      * Close the input buffer.
-     * 
+     *
      * @throws IOException An underlying IOException occurred
      */
     @Override
@@ -263,26 +262,29 @@ public class InputBuffer extends Reader
     // ------------------------------------------------- Bytes Handling Methods
 
 
-    /** 
+    /**
      * Reads new bytes in the byte chunk.
-     * 
+     *
      * @param cbuf Byte buffer to be written to the response
      * @param off Offset
      * @param len Length
-     * 
+     *
      * @throws IOException An underlying IOException occurred
      */
     @Override
     public int realReadBytes(byte cbuf[], int off, int len)
             throws IOException {
 
-        if (closed)
+        if (closed) {
             return -1;
-        if (coyoteRequest == null)
+        }
+        if (coyoteRequest == null) {
             return -1;
+        }
 
-        if(state == INITIAL_STATE)
+        if(state == INITIAL_STATE) {
             state = BYTE_STATE;
+        }
 
         int result = coyoteRequest.doRead(bb);
 
@@ -294,8 +296,9 @@ public class InputBuffer extends Reader
     public int readByte()
         throws IOException {
 
-        if (closed)
+        if (closed) {
             throw new IOException(sm.getString("inputBuffer.streamClosed"));
+        }
 
         return bb.substract();
     }
@@ -304,8 +307,9 @@ public class InputBuffer extends Reader
     public int read(byte[] b, int off, int len)
         throws IOException {
 
-        if (closed)
+        if (closed) {
             throw new IOException(sm.getString("inputBuffer.streamClosed"));
+        }
 
         return bb.substract(b, off, len);
     }
@@ -321,7 +325,7 @@ public class InputBuffer extends Reader
      * mark is lost.
      */
     @Override
-    public void realWriteChars(char c[], int off, int len) 
+    public void realWriteChars(char c[], int off, int len)
         throws IOException {
         markPos = -1;
         cb.setOffset(0);
@@ -338,8 +342,9 @@ public class InputBuffer extends Reader
     public int realReadChars(char cbuf[], int off, int len)
         throws IOException {
 
-        if (!gotEnc)
+        if (!gotEnc) {
             setConverter();
+        }
 
         if (bb.getLength() <= 0) {
             int nRead = realReadBytes(bb.getBytes(), 0, bb.getBytes().length);
@@ -353,8 +358,9 @@ public class InputBuffer extends Reader
             cb.setEnd(0);
         }
         int limit = bb.getLength()+cb.getStart();
-        if ( cb.getLimit() < limit )
+        if ( cb.getLimit() < limit ) {
             cb.setLimit(limit);
+        }
         state = CHAR_STATE;
         conv.convert(bb, cb, bb.getLength());
         bb.setOffset(bb.getEnd());
@@ -368,8 +374,9 @@ public class InputBuffer extends Reader
     public int read()
         throws IOException {
 
-        if (closed)
+        if (closed) {
             throw new IOException(sm.getString("inputBuffer.streamClosed"));
+        }
 
         return cb.substract();
     }
@@ -379,8 +386,9 @@ public class InputBuffer extends Reader
     public int read(char[] cbuf)
         throws IOException {
 
-        if (closed)
+        if (closed) {
             throw new IOException(sm.getString("inputBuffer.streamClosed"));
+        }
 
         return read(cbuf, 0, cbuf.length);
     }
@@ -390,8 +398,9 @@ public class InputBuffer extends Reader
     public int read(char[] cbuf, int off, int len)
         throws IOException {
 
-        if (closed)
+        if (closed) {
             throw new IOException(sm.getString("inputBuffer.streamClosed"));
+        }
 
         return cb.substract(cbuf, off, len);
     }
@@ -402,8 +411,9 @@ public class InputBuffer extends Reader
         throws IOException {
 
 
-        if (closed)
+        if (closed) {
             throw new IOException(sm.getString("inputBuffer.streamClosed"));
+        }
 
         if (n < 0) {
             throw new IllegalArgumentException();
@@ -424,8 +434,9 @@ public class InputBuffer extends Reader
                     toRead = (int) (n - nRead);
                 }
                 int nb = realReadChars(cb.getChars(), 0, toRead);
-                if (nb < 0)
+                if (nb < 0) {
                     break;
+                }
             }
         }
 
@@ -438,8 +449,9 @@ public class InputBuffer extends Reader
     public boolean ready()
         throws IOException {
 
-        if (closed)
+        if (closed) {
             throw new IOException(sm.getString("inputBuffer.streamClosed"));
+        }
 
         return (available() > 0);
     }
@@ -455,16 +467,17 @@ public class InputBuffer extends Reader
     public void mark(int readAheadLimit)
         throws IOException {
 
-        if (closed)
+        if (closed) {
             throw new IOException(sm.getString("inputBuffer.streamClosed"));
+        }
 
         if (cb.getLength() <= 0) {
             cb.setOffset(0);
             cb.setEnd(0);
         } else {
-            if ((cb.getBuffer().length > (2 * size)) 
+            if ((cb.getBuffer().length > (2 * size))
                 && (cb.getLength()) < (cb.getStart())) {
-                System.arraycopy(cb.getBuffer(), cb.getStart(), 
+                System.arraycopy(cb.getBuffer(), cb.getStart(),
                                  cb.getBuffer(), 0, cb.getLength());
                 cb.setEnd(cb.getLength());
                 cb.setOffset(0);
@@ -479,8 +492,9 @@ public class InputBuffer extends Reader
     public void reset()
         throws IOException {
 
-        if (closed)
+        if (closed) {
             throw new IOException(sm.getString("inputBuffer.streamClosed"));
+        }
 
         if (state == CHAR_STATE) {
             if (markPos < 0) {
@@ -496,11 +510,12 @@ public class InputBuffer extends Reader
     }
 
 
-    public void checkConverter() 
+    public void checkConverter()
         throws IOException {
 
-        if (!gotEnc)
+        if (!gotEnc) {
             setConverter();
+        }
 
     }
 
@@ -508,12 +523,14 @@ public class InputBuffer extends Reader
     protected void setConverter()
         throws IOException {
 
-        if (coyoteRequest != null)
+        if (coyoteRequest != null) {
             enc = coyoteRequest.getCharacterEncoding();
+        }
 
         gotEnc = true;
-        if (enc == null)
+        if (enc == null) {
             enc = DEFAULT_ENCODING;
+        }
         conv = encoders.get(enc);
         if (conv == null) {
             if (SecurityUtil.isPackageProtectionEnabled()){
@@ -527,11 +544,12 @@ public class InputBuffer extends Reader
                                 }
 
                             }
-                    );              
+                    );
                 }catch(PrivilegedActionException ex){
                     Exception e = ex.getException();
-                    if (e instanceof IOException)
-                        throw (IOException)e; 
+                    if (e instanceof IOException) {
+                        throw (IOException)e;
+                    }
                 }
             } else {
                 conv = new B2CConverter(enc);

==================================================
OutputBuffer.java
index 9bb2f3d823..758e99e8d5 100644
--- a/java/org/apache/catalina/connector/MapperListener.java
+++ b/java/org/apache/catalina/connector/MapperListener.java
@@ -5,15 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
+ */
 package org.apache.catalina.connector;
 
 import org.apache.catalina.Container;
@@ -53,7 +53,7 @@ public class MapperListener extends LifecycleMBeanBase
      * Associated mapper.
      */
     private Mapper mapper = null;
-    
+
     /**
      * Associated connector
      */
@@ -69,7 +69,7 @@ public class MapperListener extends LifecycleMBeanBase
     /**
      * The domain (effectively the engine) this mapper is associated with
      */
-    private String domain = null;
+    private final String domain = null;
 
     // ----------------------------------------------------------- Constructors
 
@@ -89,7 +89,7 @@ public class MapperListener extends LifecycleMBeanBase
         return this.connector.toString();
     }
 
-    
+
     // ------------------------------------------------------- Lifecycle Methods
 
     @Override
@@ -101,10 +101,10 @@ public class MapperListener extends LifecycleMBeanBase
         // MBean listener won't be notified as those components will have
         // already registered their MBeans
         findDefaultHost();
-        
+
         Engine engine = (Engine) connector.getService().getContainer();
         addListeners(engine);
-        
+
         Container[] conHosts = engine.findChildren();
         for (Container conHost : conHosts) {
             Host host = (Host) conHost;
@@ -114,7 +114,7 @@ public class MapperListener extends LifecycleMBeanBase
             }
         }
     }
-        
+
 
     @Override
     public void stopInternal() throws LifecycleException {
@@ -194,55 +194,55 @@ public class MapperListener extends LifecycleMBeanBase
             String hostName = wrapper.getParent().getParent().getName();
 
             String mapping = (String) event.getData();
-            
+
             mapper.removeWrapper(hostName, contextPath, version, mapping);
         } else if (Context.ADD_WELCOME_FILE_EVENT.equals(event.getType())) {
             // Handle dynamically adding welcome files
             Context context = (Context) event.getSource();
-            
+
             String hostName = context.getParent().getName();
 
             String contextPath = context.getPath();
             if ("/".equals(contextPath)) {
                 contextPath = "";
             }
-            
+
             String welcomeFile = (String) event.getData();
-            
+
             mapper.addWelcomeFile(hostName, contextPath,
                     context.getWebappVersion(), welcomeFile);
         } else if (Context.REMOVE_WELCOME_FILE_EVENT.equals(event.getType())) {
             // Handle dynamically removing welcome files
             Context context = (Context) event.getSource();
-            
+
             String hostName = context.getParent().getName();
 
             String contextPath = context.getPath();
             if ("/".equals(contextPath)) {
                 contextPath = "";
             }
-            
+
             String welcomeFile = (String) event.getData();
-            
+
             mapper.removeWelcomeFile(hostName, contextPath,
                     context.getWebappVersion(), welcomeFile);
         } else if (Context.CLEAR_WELCOME_FILES_EVENT.equals(event.getType())) {
             // Handle dynamically clearing welcome files
             Context context = (Context) event.getSource();
-            
+
             String hostName = context.getParent().getName();
 
             String contextPath = context.getPath();
             if ("/".equals(contextPath)) {
                 contextPath = "";
             }
-            
+
             mapper.clearWelcomeFiles(hostName, contextPath,
                     context.getWebappVersion());
         }
     }
 
-    
+
     // ------------------------------------------------------ Protected Methods
 
     private void findDefaultHost() {
@@ -254,14 +254,14 @@ public class MapperListener extends LifecycleMBeanBase
 
         if (defaultHost != null && defaultHost.length() >0) {
             Container[] containers = engine.findChildren();
-            
+
             for (Container container : containers) {
                 Host host = (Host) container;
                 if (defaultHost.equalsIgnoreCase(host.getName())) {
                     found = true;
                     break;
                 }
-                
+
                 String[] aliases = host.findAliases();
                 for (String alias : aliases) {
                     if (defaultHost.equalsIgnoreCase(alias)) {
@@ -280,15 +280,15 @@ public class MapperListener extends LifecycleMBeanBase
         }
     }
 
-    
+
     /**
      * Register host.
      */
     private void registerHost(Host host) {
-        
+
         String[] aliases = host.findAliases();
         mapper.addHost(host.getName(), aliases, host);
-        
+
         for (Container container : host.findChildren()) {
             if (container.getState().isAvailable()) {
                 registerContext((Context) container);
@@ -307,15 +307,16 @@ public class MapperListener extends LifecycleMBeanBase
     private void unregisterHost(Host host) {
 
         String hostname = host.getName();
-        
+
         mapper.removeHost(hostname);
 
-        if(log.isDebugEnabled())
+        if(log.isDebugEnabled()) {
             log.debug(sm.getString("mapperListener.unregisterHost", hostname,
                     domain, connector));
+        }
     }
 
-    
+
     /**
      * Unregister wrapper.
      */
@@ -331,18 +332,18 @@ public class MapperListener extends LifecycleMBeanBase
         String hostName = wrapper.getParent().getParent().getName();
 
         String[] mappings = wrapper.findMappings();
-        
+
         for (String mapping : mappings) {
             mapper.removeWrapper(hostName, contextPath, version,  mapping);
         }
-        
+
         if(log.isDebugEnabled()) {
             log.debug(sm.getString("mapperListener.unregisterWrapper",
                     wrapperName, contextPath, connector));
         }
     }
 
-    
+
     /**
      * Register context.
      */
@@ -353,7 +354,7 @@ public class MapperListener extends LifecycleMBeanBase
             contextPath = "";
         }
         Container host = context.getParent();
-        
+
         javax.naming.Context resources = context.getResources();
         String[] welcomeFiles = context.findWelcomeFiles();
 
@@ -387,9 +388,10 @@ public class MapperListener extends LifecycleMBeanBase
         }
         String hostName = context.getParent().getName();
 
-        if(log.isDebugEnabled())
+        if(log.isDebugEnabled()) {
             log.debug(sm.getString("mapperListener.unregisterContext",
                     contextPath, connector));
+        }
 
         mapper.removeContextVersion(hostName, contextPath,
                 context.getWebappVersion());
@@ -409,7 +411,7 @@ public class MapperListener extends LifecycleMBeanBase
         }
         String version = ((Context) wrapper.getParent()).getWebappVersion();
         String hostName = context.getParent().getName();
-        
+
         String[] mappings = wrapper.findMappings();
 
         for (String mapping : mappings) {
@@ -452,7 +454,7 @@ public class MapperListener extends LifecycleMBeanBase
 
     /**
      * Add this mapper to the container and all child containers
-     * 
+     *
      * @param container
      */
     private void addListeners(Container container) {
@@ -466,7 +468,7 @@ public class MapperListener extends LifecycleMBeanBase
 
     /**
      * Remove this mapper from the container and all child containers
-     * 
+     *
      * @param container
      */
     private void removeListeners(Container container) {

==================================================
Request.java
index f3d59efa8c..72cffc7fcc 100644
--- a/java/org/apache/catalina/connector/OutputBuffer.java
+++ b/java/org/apache/catalina/connector/OutputBuffer.java
@@ -5,16 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
-
+ */
 package org.apache.catalina.connector;
 
 
@@ -34,7 +33,7 @@ import org.apache.tomcat.util.buf.C2BConverter;
 
 /**
  * The buffer used by Tomcat response. This is a derivative of the Tomcat 3.3
- * OutputBuffer, with the removal of some of the state handling (which in 
+ * OutputBuffer, with the removal of some of the state handling (which in
  * Coyote is mostly the Processor's responsibility).
  *
  * @author Costin Manolache
@@ -47,7 +46,7 @@ public class OutputBuffer extends Writer
     // -------------------------------------------------------------- Constants
 
 
-    public static final String DEFAULT_ENCODING = 
+    public static final String DEFAULT_ENCODING =
         org.apache.coyote.Constants.DEFAULT_CHARACTER_ENCODING;
     public static final int DEFAULT_BUFFER_SIZE = 8*1024;
 
@@ -58,7 +57,7 @@ public class OutputBuffer extends Writer
     /**
      * The byte buffer.
      */
-    private ByteChunk bb;
+    private final ByteChunk bb;
 
 
     /**
@@ -94,7 +93,7 @@ public class OutputBuffer extends Writer
     /**
      * Byte chunk used to output bytes.
      */
-    private ByteChunk outputChunk = new ByteChunk();
+    private final ByteChunk outputChunk = new ByteChunk();
 
 
     /**
@@ -149,7 +148,7 @@ public class OutputBuffer extends Writer
 
     /**
      * Alternate constructor which allows specifying the initial buffer size.
-     * 
+     *
      * @param size Buffer size to use
      */
     public OutputBuffer(int size) {
@@ -166,7 +165,7 @@ public class OutputBuffer extends Writer
 
     /**
      * Associated Coyote response.
-     * 
+     *
      * @param coyoteResponse Associated Coyote response
      */
     public void setResponse(Response coyoteResponse) {
@@ -176,7 +175,7 @@ public class OutputBuffer extends Writer
 
     /**
      * Get associated Coyote response.
-     * 
+     *
      * @return the associated Coyote response
      */
     public Response getResponse() {
@@ -186,7 +185,7 @@ public class OutputBuffer extends Writer
 
     /**
      * Is the response output suspended ?
-     * 
+     *
      * @return suspended flag value
      */
     public boolean isSuspended() {
@@ -196,7 +195,7 @@ public class OutputBuffer extends Writer
 
     /**
      * Set the suspended flag.
-     * 
+     *
      * @param suspended New suspended flag value
      */
     public void setSuspended(boolean suspended) {
@@ -206,7 +205,7 @@ public class OutputBuffer extends Writer
 
     /**
      * Is the response output closed ?
-     * 
+     *
      * @return closed flag value
      */
     public boolean isClosed() {
@@ -221,23 +220,23 @@ public class OutputBuffer extends Writer
      * Recycle the output buffer.
      */
     public void recycle() {
-        
+
         initial = true;
         bytesWritten = 0;
         charsWritten = 0;
-        
-        bb.recycle(); 
+
+        bb.recycle();
         closed = false;
         doFlush = false;
         suspended = false;
-        
+
         if (conv!= null) {
             conv.recycle();
         }
-        
+
         gotEnc = false;
         enc = null;
-        
+
     }
 
 
@@ -247,24 +246,26 @@ public class OutputBuffer extends Writer
     public void clearEncoders() {
         encoders.clear();
     }
-    
-    
+
+
     /**
-     * Close the output buffer. This tries to calculate the response size if 
+     * Close the output buffer. This tries to calculate the response size if
      * the response has not been committed yet.
-     * 
+     *
      * @throws IOException An underlying IOException occurred
      */
     @Override
     public void close()
         throws IOException {
 
-        if (closed)
+        if (closed) {
             return;
-        if (suspended)
+        }
+        if (suspended) {
             return;
+        }
 
-        if ((!coyoteResponse.isCommitted()) 
+        if ((!coyoteResponse.isCommitted())
             && (coyoteResponse.getContentLengthLong() == -1)) {
             // If this didn't cause a commit of the response, the final content
             // length can be calculated
@@ -282,7 +283,7 @@ public class OutputBuffer extends Writer
         Request req = (Request) coyoteResponse.getRequest().getNote(
                 CoyoteAdapter.ADAPTER_NOTES);
         req.inputBuffer.close();
-        
+
         coyoteResponse.finish();
 
     }
@@ -290,7 +291,7 @@ public class OutputBuffer extends Writer
 
     /**
      * Flush bytes or chars contained in the buffer.
-     * 
+     *
      * @throws IOException An underlying IOException occurred
      */
     @Override
@@ -302,14 +303,15 @@ public class OutputBuffer extends Writer
 
     /**
      * Flush bytes or chars contained in the buffer.
-     * 
+     *
      * @throws IOException An underlying IOException occurred
      */
     protected void doFlush(boolean realFlush)
         throws IOException {
 
-        if (suspended)
+        if (suspended) {
             return;
+        }
 
         try {
             doFlush = true;
@@ -325,7 +327,7 @@ public class OutputBuffer extends Writer
         }
 
         if (realFlush) {
-            coyoteResponse.action(ActionCode.CLIENT_FLUSH, 
+            coyoteResponse.action(ActionCode.CLIENT_FLUSH,
                                   coyoteResponse);
             // If some exception occurred earlier, or if some IOE occurred
             // here, notify the servlet with an IOE
@@ -341,24 +343,26 @@ public class OutputBuffer extends Writer
     // ------------------------------------------------- Bytes Handling Methods
 
 
-    /** 
+    /**
      * Sends the buffer data to the client output, checking the
      * state of Response and calling the right interceptors.
-     * 
+     *
      * @param buf Byte buffer to be written to the response
      * @param off Offset
      * @param cnt Length
-     * 
+     *
      * @throws IOException An underlying IOException occurred
      */
     @Override
     public void realWriteBytes(byte buf[], int off, int cnt)
             throws IOException {
 
-        if (closed)
+        if (closed) {
             return;
-        if (coyoteResponse == null)
+        }
+        if (coyoteResponse == null) {
             return;
+        }
 
         // If we really have something to write
         if (cnt > 0) {
@@ -379,19 +383,21 @@ public class OutputBuffer extends Writer
 
     public void write(byte b[], int off, int len) throws IOException {
 
-        if (suspended)
+        if (suspended) {
             return;
+        }
 
         writeBytes(b, off, len);
 
     }
 
 
-    private void writeBytes(byte b[], int off, int len) 
+    private void writeBytes(byte b[], int off, int len)
         throws IOException {
 
-        if (closed)
+        if (closed) {
             return;
+        }
 
         bb.append(b, off, len);
         bytesWritten += len;
@@ -408,8 +414,9 @@ public class OutputBuffer extends Writer
     public void writeByte(int b)
         throws IOException {
 
-        if (suspended)
+        if (suspended) {
             return;
+        }
 
         bb.append((byte) b);
         bytesWritten++;
@@ -424,13 +431,14 @@ public class OutputBuffer extends Writer
     public void write(int c)
         throws IOException {
 
-        if (suspended)
+        if (suspended) {
             return;
+        }
 
         conv.convert((char) c);
         conv.flushBuffer();
         charsWritten++;
-        
+
     }
 
 
@@ -438,8 +446,9 @@ public class OutputBuffer extends Writer
     public void write(char c[])
         throws IOException {
 
-        if (suspended)
+        if (suspended) {
             return;
+        }
 
         write(c, 0, c.length);
 
@@ -450,8 +459,9 @@ public class OutputBuffer extends Writer
     public void write(char c[], int off, int len)
         throws IOException {
 
-        if (suspended)
+        if (suspended) {
             return;
+        }
 
         conv.convert(c, off, len);
         conv.flushBuffer();
@@ -467,12 +477,14 @@ public class OutputBuffer extends Writer
     public void write(String s, int off, int len)
         throws IOException {
 
-        if (suspended)
+        if (suspended) {
             return;
+        }
 
         charsWritten += len;
-        if (s == null)
+        if (s == null) {
             s = "null";
+        }
         conv.convert(s, off, len);
         conv.flushBuffer();
 
@@ -483,15 +495,17 @@ public class OutputBuffer extends Writer
     public void write(String s)
         throws IOException {
 
-        if (suspended)
+        if (suspended) {
             return;
+        }
 
-        if (s == null)
+        if (s == null) {
             s = "null";
+        }
         conv.convert(s);
         conv.flushBuffer();
 
-    } 
+    }
 
 
     public void setEncoding(String s) {
@@ -499,27 +513,30 @@ public class OutputBuffer extends Writer
     }
 
 
-    public void checkConverter() 
+    public void checkConverter()
         throws IOException {
 
-        if (!gotEnc)
+        if (!gotEnc) {
             setConverter();
+        }
 
     }
 
 
-    protected void setConverter() 
+    protected void setConverter()
         throws IOException {
 
-        if (coyoteResponse != null)
+        if (coyoteResponse != null) {
             enc = coyoteResponse.getCharacterEncoding();
+        }
 
         gotEnc = true;
-        if (enc == null)
+        if (enc == null) {
             enc = DEFAULT_ENCODING;
+        }
         conv = encoders.get(enc);
         if (conv == null) {
-            
+
             if (Globals.IS_SECURITY_ENABLED){
                 try{
                     conv = AccessController.doPrivileged(
@@ -531,32 +548,33 @@ public class OutputBuffer extends Writer
                                 }
 
                             }
-                    );              
+                    );
                 }catch(PrivilegedActionException ex){
                     Exception e = ex.getException();
-                    if (e instanceof IOException)
-                        throw (IOException)e; 
+                    if (e instanceof IOException) {
+                        throw (IOException)e;
+                    }
                 }
             } else {
                 conv = new C2BConverter(bb, enc);
             }
-            
+
             encoders.put(enc, conv);
 
         }
     }
 
-    
+
     // --------------------  BufferedOutputStream compatibility
 
 
     public long getContentWritten() {
         return bytesWritten + charsWritten;
     }
-    
-    /** 
+
+    /**
      * True if this buffer hasn't been used ( since recycle() ) -
-     * i.e. no chars or bytes have been added to the buffer.  
+     * i.e. no chars or bytes have been added to the buffer.
      */
     public boolean isNew() {
         return (bytesWritten == 0) && (charsWritten == 0);
@@ -578,7 +596,7 @@ public class OutputBuffer extends Writer
         gotEnc = false;
         enc = null;
         initial = true;
-        
+
     }
 
 

==================================================
RequestFacade.java
index 5be7ef4216..5714b0e3a2 100644
--- a/java/org/apache/catalina/connector/Request.java
+++ b/java/org/apache/catalina/connector/Request.java
@@ -5,17 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-
 package org.apache.catalina.connector;
 
 
@@ -107,7 +105,7 @@ public class Request
     implements HttpServletRequest {
 
     private static final Log log = LogFactory.getLog(Request.class);
-    
+
     // ----------------------------------------------------------- Constructors
 
 
@@ -130,7 +128,7 @@ public class Request
 
     /**
      * Set the Coyote request.
-     * 
+     *
      * @param coyoteRequest The Coyote request
      */
     public void setCoyoteRequest(org.apache.coyote.Request coyoteRequest) {
@@ -201,7 +199,7 @@ public class Request
     /**
      * List of read only attributes for this Request.
      */
-    private HashMap<String,Object> readOnlyAttributes =
+    private final HashMap<String,Object> readOnlyAttributes =
         new HashMap<String,Object>();
 
 
@@ -223,19 +221,19 @@ public class Request
      */
     protected String authType = null;
 
-    
+
     /**
      * Associated event.
      */
     protected CometEventImpl event = null;
-    
+
 
     /**
      * Comet state
      */
     protected boolean comet = false;
-    
-    
+
+
     /**
      * The current dispatcher type.
      */
@@ -251,7 +249,7 @@ public class Request
     /**
      * ServletInputStream.
      */
-    protected CoyoteInputStream inputStream = 
+    protected CoyoteInputStream inputStream =
         new CoyoteInputStream(inputBuffer);
 
 
@@ -302,7 +300,7 @@ public class Request
      */
     protected boolean secure = false;
 
-    
+
     /**
      * The Subject associated with the current AccessControllerContext
      */
@@ -326,14 +324,14 @@ public class Request
      * The parts, if any, uploaded with this request.
      */
     protected Collection<Part> parts = null;
-    
-    
+
+
     /**
      * The exception thrown, if any when parsing the parts.
      */
     protected Exception partsParseException = null;
-    
-    
+
+
     /**
      * The currently active session for this request.
      */
@@ -379,7 +377,7 @@ public class Request
     /**
      * The string parser we will use for parsing request lines.
      */
-    private StringParser parser = new StringParser();
+    private final StringParser parser = new StringParser();
 
 
     /**
@@ -398,31 +396,31 @@ public class Request
      */
     protected String remoteHost = null;
 
-    
+
     /**
      * Remote port
      */
     protected int remotePort = -1;
-    
+
     /**
      * Local address
      */
     protected String localAddr = null;
 
-    
+
     /**
      * Local address
      */
     protected String localName = null;
-    
+
     /**
-     * AsyncContext 
+     * AsyncContext
      */
     protected volatile AsyncContextImpl asyncContext = null;
-    
+
     protected Boolean asyncSupported = null;
-    
-    
+
+
     /**
      * Path parameters
      */
@@ -430,7 +428,7 @@ public class Request
 
     // --------------------------------------------------------- Public Methods
 
-    
+
     protected void addPathParameter(String name, String value) {
         pathParameters.put(name, value);
     }
@@ -460,7 +458,7 @@ public class Request
             event.clear();
             event = null;
         }
-        
+
         authType = null;
         inputBuffer.recycle();
         usingInputStream = false;
@@ -523,9 +521,11 @@ public class Request
                 reader = null;
             }
         }
-        
+
         asyncSupported = null;
-        if (asyncContext!=null) asyncContext.recycle();
+        if (asyncContext!=null) {
+            asyncContext.recycle();
+        }
         asyncContext = null;
 
         pathParameters.clear();
@@ -540,7 +540,7 @@ public class Request
     public void clearEncoders() {
         inputBuffer.clearEncoders();
     }
-    
+
 
     /**
      * Clear cached encoders (to save memory for Comet requests).
@@ -549,7 +549,7 @@ public class Request
         throws IOException {
         return (inputBuffer.realReadBytes(null, 0, 0) > 0);
     }
-    
+
 
     // -------------------------------------------------------- Request Methods
 
@@ -616,7 +616,7 @@ public class Request
 
     /**
      * Set filter chain associated with the request.
-     * 
+     *
      * @param filterChain new filter chain
      */
     public void setFilterChain(FilterChain filterChain) {
@@ -685,7 +685,7 @@ public class Request
     public HttpServletRequest getRequest() {
         if (facade == null) {
             facade = new RequestFacade(this);
-        } 
+        }
         return facade;
     }
 
@@ -735,7 +735,7 @@ public class Request
 
     /**
      * Set the URI converter.
-     * 
+     *
      * @param URIConverter the new URI converter
      */
     protected void setURIConverter(B2CConverter URIConverter) {
@@ -776,7 +776,7 @@ public class Request
      *
      * @exception IOException if an input/output error occurs
      */
-    public ServletInputStream createInputStream() 
+    public ServletInputStream createInputStream()
         throws IOException {
         if (inputStream == null) {
             inputStream = new CoyoteInputStream(inputBuffer);
@@ -919,15 +919,15 @@ public class Request
     public Object getAttribute(String name) {
 
         if (name.equals(Globals.DISPATCHER_TYPE_ATTR)) {
-            return (internalDispatcherType == null) 
+            return (internalDispatcherType == null)
                 ? DispatcherType.REQUEST
                 : internalDispatcherType;
         } else if (name.equals(Globals.DISPATCHER_REQUEST_PATH_ATTR)) {
-            return (requestDispatcherPath == null) 
+            return (requestDispatcherPath == null)
                 ? getRequestPathMB().toString()
                 : requestDispatcherPath.toString();
         }
-        
+
         if (name.equals(Globals.ASYNC_SUPPORTED_ATTR)) {
             return asyncSupported;
         }
@@ -941,14 +941,16 @@ public class Request
 
         Object attr=attributes.get(name);
 
-        if(attr!=null)
+        if(attr!=null) {
             return(attr);
+        }
 
         attr =  coyoteRequest.getAttribute(name);
-        if(attr != null)
+        if(attr != null) {
             return attr;
+        }
         if( isSSLAttribute(name) ) {
-            coyoteRequest.action(ActionCode.REQ_SSL_ATTRIBUTE, 
+            coyoteRequest.action(ActionCode.REQ_SSL_ATTRIBUTE,
                                  coyoteRequest);
             attr = coyoteRequest.getAttribute(Globals.CERTIFICATES_ATTR);
             if( attr != null) {
@@ -1063,9 +1065,10 @@ public class Request
     @Override
     public ServletInputStream getInputStream() throws IOException {
 
-        if (usingReader)
+        if (usingReader) {
             throw new IllegalStateException
                 (sm.getString("coyoteRequest.getInputStream.ise"));
+        }
 
         usingInputStream = true;
         if (inputStream == null) {
@@ -1085,8 +1088,9 @@ public class Request
     @Override
     public Locale getLocale() {
 
-        if (!localesParsed)
+        if (!localesParsed) {
             parseLocales();
+        }
 
         if (locales.size() > 0) {
             return locales.get(0);
@@ -1105,11 +1109,13 @@ public class Request
     @Override
     public Enumeration<Locale> getLocales() {
 
-        if (!localesParsed)
+        if (!localesParsed) {
             parseLocales();
+        }
 
-        if (locales.size() > 0)
+        if (locales.size() > 0) {
             return (new Enumerator<Locale>(locales));
+        }
         ArrayList<Locale> results = new ArrayList<Locale>();
         results.add(defaultLocale);
         return new Enumerator<Locale>(results);
@@ -1127,8 +1133,9 @@ public class Request
     @Override
     public String getParameter(String name) {
 
-        if (!parametersParsed)
+        if (!parametersParsed) {
             parseParameters();
+        }
 
         return coyoteRequest.getParameters().getParameter(name);
 
@@ -1148,8 +1155,9 @@ public class Request
     @Override
     public Map<String, String[]> getParameterMap() {
 
-        if (parameterMap.isLocked())
+        if (parameterMap.isLocked()) {
             return parameterMap;
+        }
 
         Enumeration<String> enumeration = getParameterNames();
         while (enumeration.hasMoreElements()) {
@@ -1171,8 +1179,9 @@ public class Request
     @Override
     public Enumeration<String> getParameterNames() {
 
-        if (!parametersParsed)
+        if (!parametersParsed) {
             parseParameters();
+        }
 
         return coyoteRequest.getParameters().getParameterNames();
 
@@ -1188,8 +1197,9 @@ public class Request
     @Override
     public String[] getParameterValues(String name) {
 
-        if (!parametersParsed)
+        if (!parametersParsed) {
             parseParameters();
+        }
 
         return coyoteRequest.getParameters().getParameterValues(name);
 
@@ -1217,9 +1227,10 @@ public class Request
     @Override
     public BufferedReader getReader() throws IOException {
 
-        if (usingInputStream)
+        if (usingInputStream) {
             throw new IllegalStateException
                 (sm.getString("coyoteRequest.getReader.ise"));
+        }
 
         usingReader = true;
         inputBuffer.checkConverter();
@@ -1243,8 +1254,9 @@ public class Request
     @Deprecated
     public String getRealPath(String path) {
 
-        if (context == null)
+        if (context == null) {
             return null;
+        }
         ServletContext servletContext = context.getServletContext();
         if (servletContext == null) {
             return null;
@@ -1292,7 +1304,7 @@ public class Request
     /**
      * Returns the Internet Protocol (IP) source port of the client
      * or last proxy that sent the request.
-     */    
+     */
     @Override
     public int getRemotePort(){
         if (remotePort == -1) {
@@ -1300,7 +1312,7 @@ public class Request
                 (ActionCode.REQ_REMOTEPORT_ATTRIBUTE, coyoteRequest);
             remotePort = coyoteRequest.getRemotePort();
         }
-        return remotePort;    
+        return remotePort;
     }
 
     /**
@@ -1320,7 +1332,7 @@ public class Request
     /**
      * Returns the Internet Protocol (IP) address of the interface on
      * which the request  was received.
-     */       
+     */
     @Override
     public String getLocalAddr(){
         if (localAddr == null) {
@@ -1328,7 +1340,7 @@ public class Request
                 (ActionCode.REQ_LOCAL_ADDR_ATTRIBUTE, coyoteRequest);
             localAddr = coyoteRequest.localAddr().toString();
         }
-        return localAddr;    
+        return localAddr;
     }
 
 
@@ -1345,7 +1357,7 @@ public class Request
         }
         return localPort;
     }
-    
+
     /**
      * Return a RequestDispatcher that wraps the resource at the specified
      * path, which may be interpreted as relative to the current request path.
@@ -1355,20 +1367,23 @@ public class Request
     @Override
     public RequestDispatcher getRequestDispatcher(String path) {
 
-        if (context == null)
+        if (context == null) {
             return null;
+        }
 
         // If the path is already context-relative, just pass it through
-        if (path == null)
+        if (path == null) {
             return null;
-        else if (path.startsWith("/"))
+        } else if (path.startsWith("/")) {
             return (context.getServletContext().getRequestDispatcher(path));
+        }
 
         // Convert a request-relative path to a context-relative one
         String servletPath = (String) getAttribute(
                 RequestDispatcher.INCLUDE_SERVLET_PATH);
-        if (servletPath == null)
+        if (servletPath == null) {
             servletPath = getServletPath();
+        }
 
         // Add the path info, if there is any
         String pathInfo = getPathInfo();
@@ -1458,17 +1473,19 @@ public class Request
         } else {
             return;
         }
-        
+
         // Notify interested application event listeners
         Object listeners[] = context.getApplicationEventListeners();
-        if ((listeners == null) || (listeners.length == 0))
+        if ((listeners == null) || (listeners.length == 0)) {
             return;
+        }
         ServletRequestAttributeEvent event =
           new ServletRequestAttributeEvent(context.getServletContext(),
                                            getRequest(), name, value);
         for (int i = 0; i < listeners.length; i++) {
-            if (!(listeners[i] instanceof ServletRequestAttributeListener))
+            if (!(listeners[i] instanceof ServletRequestAttributeListener)) {
                 continue;
+            }
             ServletRequestAttributeListener listener =
                 (ServletRequestAttributeListener) listeners[i];
             try {
@@ -1493,9 +1510,10 @@ public class Request
     public void setAttribute(String name, Object value) {
 
         // Name cannot be null
-        if (name == null)
+        if (name == null) {
             throw new IllegalArgumentException
                 (sm.getString("coyoteRequest.setAttribute.namenull"));
+        }
 
         // Null value is the same as removeAttribute()
         if (value == null) {
@@ -1510,7 +1528,7 @@ public class Request
             requestDispatcherPath = value;
             return;
         }
-        
+
         if (name.equals(Globals.ASYNC_SUPPORTED_ATTR)) {
             this.asyncSupported = (Boolean)value;
         }
@@ -1554,24 +1572,27 @@ public class Request
         if (name.startsWith("org.apache.tomcat.")) {
             coyoteRequest.setAttribute(name, value);
         }
-        
+
         // Notify interested application event listeners
         Object listeners[] = context.getApplicationEventListeners();
-        if ((listeners == null) || (listeners.length == 0))
+        if ((listeners == null) || (listeners.length == 0)) {
             return;
+        }
         ServletRequestAttributeEvent event = null;
-        if (replaced)
+        if (replaced) {
             event =
                 new ServletRequestAttributeEvent(context.getServletContext(),
                                                  getRequest(), name, oldValue);
-        else
+        } else {
             event =
                 new ServletRequestAttributeEvent(context.getServletContext(),
                                                  getRequest(), name, value);
+        }
 
         for (int i = 0; i < listeners.length; i++) {
-            if (!(listeners[i] instanceof ServletRequestAttributeListener))
+            if (!(listeners[i] instanceof ServletRequestAttributeListener)) {
                 continue;
+            }
             ServletRequestAttributeListener listener =
                 (ServletRequestAttributeListener) listeners[i];
             try {
@@ -1606,16 +1627,17 @@ public class Request
     public void setCharacterEncoding(String enc)
         throws UnsupportedEncodingException {
 
-        if (usingReader)
+        if (usingReader) {
             return;
-        
+        }
+
         // Ensure that the specified encoding is valid
         byte buffer[] = new byte[1];
         buffer[0] = (byte) 'a';
 
         // Confirm that the encoding name is valid
         B2CConverter.getCharset(enc);
-        
+
         // Save the validated encoding
         coyoteRequest.setCharacterEncoding(enc);
     }
@@ -1637,15 +1659,15 @@ public class Request
         if (!isAsyncSupported()) {
             throw new IllegalStateException("Not supported.");
         }
-        
+
         if (asyncContext == null) {
             asyncContext = new AsyncContextImpl(this);
         }
-        
+
         asyncContext.setStarted(getContext(), request, response,
                 request==getRequest() && response==getResponse().getResponse());
         asyncContext.setTimeout(getConnector().getAsyncTimeout());
-        
+
         return asyncContext;
     }
 
@@ -1654,7 +1676,7 @@ public class Request
         if (asyncContext == null) {
             return false;
         }
-        
+
         return asyncContext.isStarted();
     }
 
@@ -1680,7 +1702,7 @@ public class Request
 
     @Override
     public boolean isAsyncSupported() {
-        if (this.asyncSupported == null) { 
+        if (this.asyncSupported == null) {
             return true;
         }
 
@@ -1694,7 +1716,7 @@ public class Request
 
     @Override
     public DispatcherType getDispatcherType() {
-        if (internalDispatcherType == null) { 
+        if (internalDispatcherType == null) {
             return DispatcherType.REQUEST;
         }
 
@@ -1711,8 +1733,9 @@ public class Request
      */
     public void addCookie(Cookie cookie) {
 
-        if (!cookiesParsed)
+        if (!cookiesParsed) {
             parseCookies();
+        }
 
         int size = 0;
         if (cookies != null) {
@@ -1886,7 +1909,7 @@ public class Request
 
     /**
      * Get the decoded request URI.
-     * 
+     *
      * @return the URL decoded request URI
      */
     public String getDecodedRequestURI() {
@@ -1896,7 +1919,7 @@ public class Request
 
     /**
      * Get the decoded request URI.
-     * 
+     *
      * @return the URL decoded request URI
      */
     public MessageBytes getDecodedRequestURIMB() {
@@ -1912,8 +1935,9 @@ public class Request
      * @param path The servlet path
      */
     public void setServletPath(String path) {
-        if (path != null)
+        if (path != null) {
             mappingData.wrapperPath.setString(path);
+        }
     }
 
 
@@ -1928,18 +1952,18 @@ public class Request
 
         if (Globals.IS_SECURITY_ENABLED){
             HttpSession session = getSession(false);
-            if ( (subject != null) && 
+            if ( (subject != null) &&
                  (!subject.getPrincipals().contains(principal)) ){
-                subject.getPrincipals().add(principal);         
+                subject.getPrincipals().add(principal);
             } else if (session != null &&
                         session.getAttribute(Globals.SUBJECT_ATTR) == null) {
                 subject = new Subject();
-                subject.getPrincipals().add(principal);         
+                subject.getPrincipals().add(principal);
             }
             if (session != null){
                 session.setAttribute(Globals.SUBJECT_ATTR, subject);
             }
-        } 
+        }
 
         this.userPrincipal = principal;
     }
@@ -1969,7 +1993,7 @@ public class Request
 
     /**
      * Get the context path.
-     * 
+     *
      * @return the context path
      */
     public MessageBytes getContextPathMB() {
@@ -1983,8 +2007,9 @@ public class Request
     @Override
     public Cookie[] getCookies() {
 
-        if (!cookiesParsed)
+        if (!cookiesParsed) {
             parseCookies();
+        }
 
         return cookies;
 
@@ -2014,8 +2039,9 @@ public class Request
     public long getDateHeader(String name) {
 
         String value = getHeader(name);
-        if (value == null)
+        if (value == null) {
             return (-1L);
+        }
 
         // Attempt to convert the date header in a variety of formats
         long result = FastHttpDateFormat.parseDate(value, formats);
@@ -2101,7 +2127,7 @@ public class Request
 
     /**
      * Get the path info.
-     * 
+     *
      * @return the path info
      */
     public MessageBytes getPathInfoMB() {
@@ -2116,8 +2142,9 @@ public class Request
     @Override
     public String getPathTranslated() {
 
-        if (context == null)
+        if (context == null) {
             return null;
+        }
 
         if (getPathInfo() == null) {
             return null;
@@ -2146,14 +2173,14 @@ public class Request
         if (userPrincipal == null) {
             return null;
         }
-     
+
         return userPrincipal.getName();
     }
 
 
     /**
      * Get the request path.
-     * 
+     *
      * @return the request path
      */
     public MessageBytes getRequestPathMB() {
@@ -2202,7 +2229,9 @@ public class Request
         String scheme = getScheme();
         int port = getServerPort();
         if (port < 0)
+         {
             port = 80; // Work around java.net.URL bug
+        }
 
         url.append(scheme);
         url.append("://");
@@ -2230,7 +2259,7 @@ public class Request
 
     /**
      * Get the servlet path.
-     * 
+     *
      * @return the servlet path
      */
     public MessageBytes getServletPathMB() {
@@ -2248,7 +2277,7 @@ public class Request
         if (session == null) {
             return null;
         }
-     
+
         return session.getSession();
     }
 
@@ -2265,7 +2294,7 @@ public class Request
         if (session == null) {
             return null;
         }
-        
+
         return session.getSession();
     }
 
@@ -2280,7 +2309,7 @@ public class Request
         if (requestedSessionId == null) {
             return false;
         }
-            
+
         return requestedSessionCookie;
     }
 
@@ -2295,7 +2324,7 @@ public class Request
         if (requestedSessionId == null) {
             return false;
         }
-        
+
         return requestedSessionURL;
     }
 
@@ -2324,23 +2353,23 @@ public class Request
         if (requestedSessionId == null) {
             return false;
         }
-        
+
         if (context == null) {
             return false;
         }
-        
+
         Manager manager = context.getManager();
         if (manager == null) {
             return false;
         }
-        
+
         Session session = null;
         try {
             session = manager.findSession(requestedSessionId);
         } catch (IOException e) {
-            // Can't find the session 
+            // Can't find the session
         }
-        
+
         if ((session == null) || !session.isValid()) {
             // Check for parallel deployment contexts
             if (getMappingData().contexts == null) {
@@ -2375,16 +2404,19 @@ public class Request
     public boolean isUserInRole(String role) {
 
         // Have we got an authenticated principal at all?
-        if (userPrincipal == null)
+        if (userPrincipal == null) {
             return false;
+        }
 
         // Identify the Realm we will use for checking role assignments
-        if (context == null)
+        if (context == null) {
             return false;
-        
+        }
+
         Realm realm = context.getRealm();
-        if (realm == null)
+        if (realm == null) {
             return false;
+        }
 
         // Check for a role defined directly as a <security-role>
         return (realm.hasRole(wrapper, userPrincipal, role));
@@ -2426,7 +2458,7 @@ public class Request
      * are several things that may trigger an ID change. These include moving
      * between nodes in a cluster and session fixation prevention during the
      * authentication process.
-     * 
+     *
      * @param newSessionId   The session to change the session ID for
      */
     public void changeSessionId(String newSessionId) {
@@ -2435,12 +2467,13 @@ public class Request
         if (requestedSessionId != null && requestedSessionId.length() > 0) {
             requestedSessionId = newSessionId;
         }
-        
+
         if (context != null && !context.getServletContext()
                 .getEffectiveSessionTrackingModes().contains(
-                        SessionTrackingMode.COOKIE))
+                        SessionTrackingMode.COOKIE)) {
             return;
-        
+        }
+
         if (response != null) {
             Cookie newCookie =
                 ApplicationSessionCookieConfig.createSessionCookie(context,
@@ -2449,7 +2482,7 @@ public class Request
         }
     }
 
-    
+
     /**
      * Return the session associated with this Request, creating one
      * if necessary and requested.
@@ -2471,8 +2504,8 @@ public class Request
         }
         return event;
     }
-    
-    
+
+
     /**
      * Return true if the current request is handling Comet traffic.
      */
@@ -2480,7 +2513,7 @@ public class Request
         return comet;
     }
 
-    
+
     /**
      * Set comet state.
      */
@@ -2493,8 +2526,8 @@ public class Request
      */
     public boolean isParametersParsed() {
         return parametersParsed;
-    }    
-    
+    }
+
     /**
      * Return true if bytes are available.
      */
@@ -2511,16 +2544,16 @@ public class Request
             coyoteRequest.action(ActionCode.DISABLE_SWALLOW_INPUT, null);
         }
     }
-    
+
     public void cometClose() {
         coyoteRequest.action(ActionCode.COMET_CLOSE,getEvent());
         setComet(false);
     }
-    
+
     public void setCometTimeout(long timeout) {
         coyoteRequest.action(ActionCode.COMET_SETTIMEOUT, Long.valueOf(timeout));
     }
-    
+
     /**
      * Not part of Servlet 3 spec but probably should be.
      * @return true if the requested session ID was obtained from the SSL session
@@ -2528,7 +2561,7 @@ public class Request
     public boolean isRequestedSessionIdFromSSL() {
         return requestedSessionSSL;
     }
-    
+
     /**
      * @throws IOException If an I/O error occurs
      * @throws IllegalStateException If the response has been committed
@@ -2536,7 +2569,7 @@ public class Request
      *         error and the container has NOT set the HTTP response code etc.
      */
     @Override
-    public boolean authenticate(HttpServletResponse response) 
+    public boolean authenticate(HttpServletResponse response)
     throws IOException, ServletException {
         if (response.isCommitted()) {
             throw new IllegalStateException(
@@ -2544,14 +2577,14 @@ public class Request
         }
 
         LoginConfig config = context.getLoginConfig();
-        
+
         if (config == null) {
             throw new ServletException(
                     sm.getString("coyoteRequest.noLoginConfig"));
         }
         return context.getAuthenticator().authenticate(this, response, config);
     }
-    
+
     /**
      * {@inheritDoc}
      */
@@ -2563,11 +2596,11 @@ public class Request
             throw new ServletException(
                     sm.getString("coyoteRequest.alreadyAuthenticated"));
         }
-        
+
         if (context.getAuthenticator() == null) {
             throw new ServletException("no authenticator");
         }
-        
+
         context.getAuthenticator().login(username, password, this);
     }
 
@@ -2578,18 +2611,18 @@ public class Request
     public void logout() throws ServletException {
         context.getAuthenticator().logout(this);
     }
-    
+
     /**
      * {@inheritDoc}
      */
     @Override
     public Collection<Part> getParts() throws IOException, IllegalStateException,
             ServletException {
-        
+
         parseParts();
-        
+
         if (partsParseException != null) {
-            if (partsParseException instanceof IOException) { 
+            if (partsParseException instanceof IOException) {
                 throw (IOException) partsParseException;
             } else if (partsParseException instanceof IllegalStateException) {
                 throw (IllegalStateException) partsParseException;
@@ -2597,15 +2630,16 @@ public class Request
                 throw (ServletException) partsParseException;
             }
         }
-        
+
         return parts;
     }
 
     private void parseParts() {
 
         // Return immediately if the parts have already been parsed
-        if (parts != null || partsParseException != null)
+        if (parts != null || partsParseException != null) {
             return;
+        }
 
         MultipartConfigElement mce = getWrapper().getMultipartConfigElement();
 
@@ -2620,7 +2654,7 @@ public class Request
                 return;
             }
         }
-        
+
         Parameters parameters = coyoteRequest.getParameters();
 
         File location;
@@ -2631,14 +2665,14 @@ public class Request
         } else {
             location = new File(locationStr);
         }
-        
+
         if (!location.isAbsolute() || !location.isDirectory()) {
             partsParseException = new IOException(
                     sm.getString("coyoteRequest.uploadLocationInvalid",
                             location));
             return;
         }
-        
+
         // Create a new file upload handler
         DiskFileItemFactory factory = new DiskFileItemFactory();
         try {
@@ -2648,7 +2682,7 @@ public class Request
             return;
         }
         factory.setSizeThreshold(mce.getFileSizeThreshold());
-        
+
         ServletFileUpload upload = new ServletFileUpload();
         upload.setFileItemFactory(factory);
         upload.setFileSizeMax(mce.getMaxFileSize());
@@ -2688,7 +2722,7 @@ public class Request
         } catch (FileUploadException e) {
             partsParseException = new IOException(e);
         }
-        
+
         return;
     }
 
@@ -2716,29 +2750,36 @@ public class Request
     protected Session doGetSession(boolean create) {
 
         // There cannot be a session if no context has been assigned yet
-        if (context == null)
+        if (context == null) {
             return (null);
+        }
 
         // Return the current session if it exists and is valid
-        if ((session != null) && !session.isValid())
+        if ((session != null) && !session.isValid()) {
             session = null;
-        if (session != null)
+        }
+        if (session != null) {
             return (session);
+        }
 
         // Return the requested session if it exists and is valid
         Manager manager = null;
-        if (context != null)
+        if (context != null) {
             manager = context.getManager();
+        }
         if (manager == null)
+         {
             return (null);      // Sessions are not supported
+        }
         if (requestedSessionId != null) {
             try {
                 session = manager.findSession(requestedSessionId);
             } catch (IOException e) {
                 session = null;
             }
-            if ((session != null) && !session.isValid())
+            if ((session != null) && !session.isValid()) {
                 session = null;
+            }
             if (session != null) {
                 session.access();
                 return (session);
@@ -2746,8 +2787,9 @@ public class Request
         }
 
         // Create a new session if requested and the response is not committed
-        if (!create)
+        if (!create) {
             return (null);
+        }
         if ((context != null) && (response != null) &&
             context.getServletContext().getEffectiveSessionTrackingModes().
                     contains(SessionTrackingMode.COOKIE) &&
@@ -2759,8 +2801,8 @@ public class Request
         // Attempt to reuse session id if one was submitted in a cookie
         // Do not reuse the session id if it is from a URL, to prevent possible
         // phishing attacks
-        // Use the SSL session ID if one is present. 
-        if (("/".equals(context.getSessionCookiePath()) 
+        // Use the SSL session ID if one is present.
+        if (("/".equals(context.getSessionCookiePath())
                 && isRequestedSessionIdFromCookie()) || requestedSessionSSL ) {
             session = manager.createSession(getRequestedSessionId());
         } else {
@@ -2775,27 +2817,35 @@ public class Request
             Cookie cookie =
                 ApplicationSessionCookieConfig.createSessionCookie(
                         context, session.getIdInternal(), isSecure());
-            
+
             response.addSessionCookieInternal(cookie);
         }
 
         if (session == null) {
             return null;
         }
-        
+
         session.access();
         return session;
     }
 
     protected String unescape(String s) {
-        if (s==null) return null;
-        if (s.indexOf('\\') == -1) return s;
+        if (s==null) {
+            return null;
+        }
+        if (s.indexOf('\\') == -1) {
+            return s;
+        }
         StringBuilder buf = new StringBuilder();
         for (int i=0; i<s.length(); i++) {
             char c = s.charAt(i);
-            if (c!='\\') buf.append(c);
-            else {
-                if (++i >= s.length()) throw new IllegalArgumentException();//invalid escape, hence invalid cookie
+            if (c!='\\') {
+                buf.append(c);
+            } else {
+                if (++i >= s.length())
+                 {
+                    throw new IllegalArgumentException();//invalid escape, hence invalid cookie
+                }
                 c = s.charAt(i);
                 buf.append(c);
             }
@@ -2812,8 +2862,9 @@ public class Request
 
         Cookies serverCookies = coyoteRequest.getCookies();
         int count = serverCookies.getCookieCount();
-        if (count <= 0)
+        if (count <= 0) {
             return;
+        }
 
         cookies = new Cookie[count];
 
@@ -2830,7 +2881,10 @@ public class Request
                 cookie.setValue(unescape(scookie.getValue().toString()));
                 cookie.setPath(unescape(scookie.getPath().toString()));
                 String domain = scookie.getDomain().toString();
-                if (domain!=null) cookie.setDomain(unescape(domain));//avoid NPE
+                if (domain!=null)
+                 {
+                    cookie.setDomain(unescape(domain));//avoid NPE
+                }
                 String comment = scookie.getComment().toString();
                 cookie.setComment(version==1?unescape(comment):null);
                 cookies[idx++] = cookie;
@@ -2876,29 +2930,33 @@ public class Request
 
         parameters.handleQueryParameters();
 
-        if (usingInputStream || usingReader)
+        if (usingInputStream || usingReader) {
             return;
+        }
 
-        if( !getConnector().isParseBodyMethod(getMethod()) )
+        if( !getConnector().isParseBodyMethod(getMethod()) ) {
             return;
+        }
 
         String contentType = getContentType();
-        if (contentType == null)
+        if (contentType == null) {
             contentType = "";
+        }
         int semicolon = contentType.indexOf(';');
         if (semicolon >= 0) {
             contentType = contentType.substring(0, semicolon).trim();
         } else {
             contentType = contentType.trim();
         }
-        
+
         if ("multipart/form-data".equals(contentType)) {
             parseParts();
             return;
         }
-        
-        if (!("application/x-www-form-urlencoded".equals(contentType)))
+
+        if (!("application/x-www-form-urlencoded".equals(contentType))) {
             return;
+        }
 
         int len = getContentLength();
 
@@ -2914,8 +2972,9 @@ public class Request
             }
             byte[] formData = null;
             if (len < CACHED_POST_LEN) {
-                if (postData == null)
+                if (postData == null) {
                     postData = new byte[CACHED_POST_LEN];
+                }
                 formData = postData;
             } else {
                 formData = new byte[len];
@@ -2978,9 +3037,9 @@ public class Request
      */
     protected byte[] readChunkedPostBody() throws IOException {
         ByteChunk body = new ByteChunk();
-        
+
         byte[] buffer = new byte[CACHED_POST_LEN];
-        
+
         int len = 0;
         while (len > -1) {
             len = getStream().read(buffer, 0, CACHED_POST_LEN);
@@ -3004,11 +3063,11 @@ public class Request
             System.arraycopy(body.getBuffer(), 0, result, 0, length);
             return result;
         }
-        
+
         return body.getBuffer();
     }
-    
-    
+
+
     /**
      * Parse request locales.
      */
@@ -3039,15 +3098,17 @@ public class Request
 
         // Preprocess the value to remove all whitespace
         int white = value.indexOf(' ');
-        if (white < 0)
+        if (white < 0) {
             white = value.indexOf('\t');
+        }
         if (white >= 0) {
             StringBuilder sb = new StringBuilder();
             int len = value.length();
             for (int i = 0; i < len; i++) {
                 char ch = value.charAt(i);
-                if ((ch != ' ') && (ch != '\t'))
+                if ((ch != ' ') && (ch != '\t')) {
                     sb.append(ch);
+                }
             }
             parser.setString(sb.toString());
         } else {
@@ -3060,8 +3121,9 @@ public class Request
 
             // Extract the next comma-delimited entry
             int start = parser.getIndex();
-            if (start >= length)
+            if (start >= length) {
                 break;
+            }
             int end = parser.findChar(',');
             String entry = parser.extract(start, end).trim();
             parser.advance();   // For the following entry
@@ -3085,9 +3147,13 @@ public class Request
 
             // Skip entries we are not going to keep track of
             if (quality < 0.00005)
+             {
                 continue;       // Zero (or effectively zero) quality factors
+            }
             if ("*".equals(entry))
+             {
                 continue;       // FIXME - "*" entries are not handled
+            }
 
             // Extract the language and country for this entry
             String language = null;
@@ -3136,7 +3202,7 @@ public class Request
 
     }
 
-    
+
     protected static final boolean isAlpha(String value) {
         for (int i = 0; i < value.length(); i++) {
             char c = value.charAt(i);

==================================================
Response.java
index 139f0b7442..83dc39f497 100644
--- a/java/org/apache/catalina/connector/RequestFacade.java
+++ b/java/org/apache/catalina/connector/RequestFacade.java
@@ -5,17 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-
 package org.apache.catalina.connector;
 
 import java.io.BufferedReader;
@@ -46,7 +44,7 @@ import org.apache.catalina.security.SecurityUtil;
 import org.apache.tomcat.util.res.StringManager;
 
 /**
- * Facade class that wraps a Coyote request object.  
+ * Facade class that wraps a Coyote request object.
  * All methods are delegated to the wrapped request.
  *
  * @author Craig R. McClanahan
@@ -57,46 +55,46 @@ import org.apache.tomcat.util.res.StringManager;
 
 @SuppressWarnings("deprecation")
 public class RequestFacade implements HttpServletRequest {
-        
-        
+
+
     // ----------------------------------------------------------- DoPrivileged
-    
+
     private final class GetAttributePrivilegedAction
             implements PrivilegedAction<Enumeration<String>> {
-        
+
         @Override
         public Enumeration<String> run() {
             return request.getAttributeNames();
-        }            
+        }
     }
-     
-    
+
+
     private final class GetParameterMapPrivilegedAction
             implements PrivilegedAction<Map<String,String[]>> {
-        
+
         @Override
         public Map<String,String[]> run() {
             return request.getParameterMap();
-        }        
-    }    
-    
-    
+        }
+    }
+
+
     private final class GetRequestDispatcherPrivilegedAction
             implements PrivilegedAction<RequestDispatcher> {
 
-        private String path;
+        private final String path;
 
         public GetRequestDispatcherPrivilegedAction(String path){
             this.path = path;
         }
-        
+
         @Override
-        public RequestDispatcher run() {   
+        public RequestDispatcher run() {
             return request.getRequestDispatcher(path);
-        }           
-    }    
-    
-    
+        }
+    }
+
+
     private final class GetParameterPrivilegedAction
             implements PrivilegedAction<String> {
 
@@ -107,22 +105,22 @@ public class RequestFacade implements HttpServletRequest {
         }
 
         @Override
-        public String run() {       
+        public String run() {
             return request.getParameter(name);
-        }           
-    }    
-    
-     
+        }
+    }
+
+
     private final class GetParameterNamesPrivilegedAction
             implements PrivilegedAction<Enumeration<String>> {
-        
+
         @Override
-        public Enumeration<String> run() {          
+        public Enumeration<String> run() {
             return request.getParameterNames();
-        }           
-    } 
-    
-    
+        }
+    }
+
+
     private final class GetParameterValuePrivilegedAction
             implements PrivilegedAction<String[]> {
 
@@ -133,90 +131,90 @@ public class RequestFacade implements HttpServletRequest {
         }
 
         @Override
-        public String[] run() {       
+        public String[] run() {
             return request.getParameterValues(name);
-        }           
-    }    
-  
-    
+        }
+    }
+
+
     private final class GetCookiesPrivilegedAction
             implements PrivilegedAction<Cookie[]> {
-        
+
         @Override
-        public Cookie[] run() {       
+        public Cookie[] run() {
             return request.getCookies();
-        }           
-    }      
-    
-    
+        }
+    }
+
+
     private final class GetCharacterEncodingPrivilegedAction
             implements PrivilegedAction<String> {
-        
+
         @Override
-        public String run() {       
+        public String run() {
             return request.getCharacterEncoding();
-        }           
-    }   
-        
-    
+        }
+    }
+
+
     private final class GetHeadersPrivilegedAction
             implements PrivilegedAction<Enumeration<String>> {
 
-        private String name;
+        private final String name;
 
         public GetHeadersPrivilegedAction(String name){
             this.name = name;
         }
-        
+
         @Override
-        public Enumeration<String> run() {       
+        public Enumeration<String> run() {
             return request.getHeaders(name);
-        }           
-    }    
-        
-    
+        }
+    }
+
+
     private final class GetHeaderNamesPrivilegedAction
             implements PrivilegedAction<Enumeration<String>> {
 
         @Override
-        public Enumeration<String> run() {       
+        public Enumeration<String> run() {
             return request.getHeaderNames();
-        }           
-    }  
-            
-    
+        }
+    }
+
+
     private final class GetLocalePrivilegedAction
             implements PrivilegedAction<Locale> {
 
         @Override
-        public Locale run() {       
+        public Locale run() {
             return request.getLocale();
-        }           
-    }    
-            
-    
+        }
+    }
+
+
     private final class GetLocalesPrivilegedAction
             implements PrivilegedAction<Enumeration<Locale>> {
 
         @Override
-        public Enumeration<Locale> run() {       
+        public Enumeration<Locale> run() {
             return request.getLocales();
-        }           
-    }    
-    
+        }
+    }
+
     private final class GetSessionPrivilegedAction
             implements PrivilegedAction<HttpSession> {
 
-        private boolean create;
-        
+        private final boolean create;
+
         public GetSessionPrivilegedAction(boolean create){
             this.create = create;
         }
-                
+
         @Override
-        public HttpSession run() {  
+        public HttpSession run() {
             return request.getSession(create);
-        }           
+        }
     }
 
     // ----------------------------------------------------------- Constructors
@@ -260,7 +258,7 @@ public class RequestFacade implements HttpServletRequest {
         request = null;
     }
 
-    
+
     /**
      * Prevent cloning the facade.
      */
@@ -296,7 +294,7 @@ public class RequestFacade implements HttpServletRequest {
 
         if (Globals.IS_SECURITY_ENABLED){
             return AccessController.doPrivileged(
-                new GetAttributePrivilegedAction());        
+                new GetAttributePrivilegedAction());
         } else {
             return request.getAttributeNames();
         }
@@ -316,7 +314,7 @@ public class RequestFacade implements HttpServletRequest {
                 new GetCharacterEncodingPrivilegedAction());
         } else {
             return request.getCharacterEncoding();
-        }         
+        }
     }
 
 
@@ -441,7 +439,7 @@ public class RequestFacade implements HttpServletRequest {
 
         if (Globals.IS_SECURITY_ENABLED){
             return AccessController.doPrivileged(
-                new GetParameterMapPrivilegedAction());        
+                new GetParameterMapPrivilegedAction());
         } else {
             return request.getParameterMap();
         }
@@ -569,7 +567,7 @@ public class RequestFacade implements HttpServletRequest {
                 new GetLocalePrivilegedAction());
         } else {
             return request.getLocale();
-        }        
+        }
     }
 
 
@@ -586,7 +584,7 @@ public class RequestFacade implements HttpServletRequest {
                 new GetLocalesPrivilegedAction());
         } else {
             return request.getLocales();
-        }        
+        }
     }
 
 
@@ -707,7 +705,7 @@ public class RequestFacade implements HttpServletRequest {
                 new GetHeadersPrivilegedAction(name));
         } else {
             return request.getHeaders(name);
-        }         
+        }
     }
 
 
@@ -724,7 +722,7 @@ public class RequestFacade implements HttpServletRequest {
                 new GetHeaderNamesPrivilegedAction());
         } else {
             return request.getHeaderNames();
-        }             
+        }
     }
 
 
@@ -1043,7 +1041,7 @@ public class RequestFacade implements HttpServletRequest {
         return request.isAsyncSupported();
     }
 
-    
+
     @Override
     public AsyncContext getAsyncContext() {
         return request.getAsyncContext();
@@ -1053,7 +1051,7 @@ public class RequestFacade implements HttpServletRequest {
     public DispatcherType getDispatcherType() {
         return request.getDispatcherType();
     }
-    
+
     @Override
     public boolean authenticate(HttpServletResponse response)
     throws IOException, ServletException {
@@ -1065,18 +1063,18 @@ public class RequestFacade implements HttpServletRequest {
     throws ServletException {
         request.login(username, password);
     }
-    
+
     @Override
     public void logout() throws ServletException {
         request.logout();
     }
-    
+
     @Override
     public Collection<Part> getParts() throws IllegalStateException,
             IOException, ServletException {
         return request.getParts();
     }
-    
+
     @Override
     public Part getPart(String name) throws IllegalStateException, IOException,
             ServletException {
@@ -1086,5 +1084,5 @@ public class RequestFacade implements HttpServletRequest {
     public boolean getAllowTrace() {
         return request.getConnector().getAllowTrace();
     }
-    
+
 }

==================================================
ResponseFacade.java
index 014d8e136a..f8bb4a8fde 100644
--- a/java/org/apache/catalina/connector/Response.java
+++ b/java/org/apache/catalina/connector/Response.java
@@ -5,17 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-
 package org.apache.catalina.connector;
 
 
@@ -159,7 +157,7 @@ public class Response
 
     /**
      * Set the Coyote response.
-     * 
+     *
      * @param coyoteResponse The Coyote response
      */
     public void setCoyoteResponse(org.apache.coyote.Response coyoteResponse) {
@@ -224,12 +222,12 @@ public class Response
      */
     protected boolean included = false;
 
-    
+
     /**
      * The characterEncoding flag
      */
     private boolean isCharacterEncodingSet = false;
-    
+
     /**
      * The error flag.
      */
@@ -276,7 +274,7 @@ public class Response
         included = false;
         error = false;
         isCharacterEncodingSet = false;
-        
+
         if (Globals.IS_SECURITY_ENABLED || Connector.RECYCLE_FACADES) {
             if (facade != null) {
                 facade.clear();
@@ -303,7 +301,7 @@ public class Response
     public void clearEncoders() {
         outputBuffer.clearEncoders();
     }
-    
+
 
     // ------------------------------------------------------- Response Methods
 
@@ -335,7 +333,7 @@ public class Response
 
     /**
      * Set the application commit flag.
-     * 
+     *
      * @param appCommitted The new application committed flag value
      */
     public void setAppCommitted(boolean appCommitted) {
@@ -348,7 +346,7 @@ public class Response
      */
     public boolean isAppCommitted() {
         return (this.appCommitted || isCommitted() || isSuspended()
-                || ((getContentLength() > 0) 
+                || ((getContentLength() > 0)
                     && (getContentWritten() >= getContentLength())));
     }
 
@@ -434,7 +432,7 @@ public class Response
 
     /**
      * Set the suspended flag.
-     * 
+     *
      * @param suspended The new suspended flag value
      */
     public void setSuspended(boolean suspended) {
@@ -480,7 +478,7 @@ public class Response
      *
      * @exception IOException if an input/output error occurs
      */
-    public ServletOutputStream createOutputStream() 
+    public ServletOutputStream createOutputStream()
         throws IOException {
         // Probably useless
         if (outputStream == null) {
@@ -496,7 +494,7 @@ public class Response
      *
      * @exception IOException if an input/output error occurs
      */
-    public void finishResponse() 
+    public void finishResponse()
         throws IOException {
         // Writing leftover bytes
         outputBuffer.close();
@@ -555,7 +553,7 @@ public class Response
      * @exception IOException if an input/output error occurs
      */
     @Override
-    public void flushBuffer() 
+    public void flushBuffer()
         throws IOException {
         outputBuffer.flush();
     }
@@ -587,12 +585,13 @@ public class Response
      * @exception IOException if an input/output error occurs
      */
     @Override
-    public ServletOutputStream getOutputStream() 
+    public ServletOutputStream getOutputStream()
         throws IOException {
 
-        if (usingWriter)
+        if (usingWriter) {
             throw new IllegalStateException
                 (sm.getString("coyoteResponse.getOutputStream.ise"));
+        }
 
         usingOutputStream = true;
         if (outputStream == null) {
@@ -620,12 +619,13 @@ public class Response
      * @exception IOException if an input/output error occurs
      */
     @Override
-    public PrintWriter getWriter() 
+    public PrintWriter getWriter()
         throws IOException {
 
-        if (usingOutputStream)
+        if (usingOutputStream) {
             throw new IllegalStateException
                 (sm.getString("coyoteResponse.getWriter.ise"));
+        }
 
         if (ENFORCE_ENCODING_IN_GET_WRITER) {
             /*
@@ -672,7 +672,9 @@ public class Response
     public void reset() {
 
         if (included)
+         {
             return;     // Ignore any call from an included servlet
+        }
 
         coyoteResponse.reset();
         outputBuffer.reset();
@@ -693,7 +695,7 @@ public class Response
         resetBuffer(false);
     }
 
-    
+
     /**
      * Reset the data buffer and the using Writer/Stream flags but not any
      * status or header information.
@@ -701,18 +703,19 @@ public class Response
      * @param resetWriterStreamFlags <code>true</code> if the internal
      *        <code>usingWriter</code>, <code>usingOutputStream</code>,
      *        <code>isCharacterEncodingSet</code> flags should also be reset
-     * 
+     *
      * @exception IllegalStateException if the response has already
      *  been committed
      */
     public void resetBuffer(boolean resetWriterStreamFlags) {
 
-        if (isCommitted())
+        if (isCommitted()) {
             throw new IllegalStateException
                 (sm.getString("coyoteResponse.resetBuffer.ise"));
+        }
 
         outputBuffer.reset();
-        
+
         if(resetWriterStreamFlags) {
             usingOutputStream = false;
             usingWriter = false;
@@ -721,7 +724,7 @@ public class Response
 
     }
 
-    
+
     /**
      * Set the buffer size to be used for this Response.
      *
@@ -733,9 +736,10 @@ public class Response
     @Override
     public void setBufferSize(int size) {
 
-        if (isCommitted() || !outputBuffer.isNew())
+        if (isCommitted() || !outputBuffer.isNew()) {
             throw new IllegalStateException
                 (sm.getString("coyoteResponse.setBufferSize.ise"));
+        }
 
         outputBuffer.setBufferSize(size);
 
@@ -750,13 +754,15 @@ public class Response
     @Override
     public void setContentLength(int length) {
 
-        if (isCommitted())
+        if (isCommitted()) {
             return;
+        }
 
         // Ignore any call from an included servlet
-        if (included)
+        if (included) {
             return;
-        
+        }
+
         coyoteResponse.setContentLength(length);
 
     }
@@ -771,12 +777,14 @@ public class Response
     @SuppressWarnings("deprecation") // isSpace (deprecated) cannot be replaced by isWhiteSpace
     public void setContentType(String type) {
 
-        if (isCommitted())
+        if (isCommitted()) {
             return;
+        }
 
         // Ignore any call from an included servlet
-        if (included)
+        if (included) {
             return;
+        }
 
         // Ignore charset if getWriter() has already been called
         if (usingWriter) {
@@ -826,17 +834,20 @@ public class Response
     @Override
     public void setCharacterEncoding(String charset) {
 
-        if (isCommitted())
+        if (isCommitted()) {
             return;
-        
+        }
+
         // Ignore any call from an included servlet
-        if (included)
-            return;     
-        
+        if (included) {
+            return;
+        }
+
         // Ignore any call made after the getWriter has been invoked
         // The default should be used
-        if (usingWriter)
+        if (usingWriter) {
             return;
+        }
 
         coyoteResponse.setCharacterEncoding(charset);
         isCharacterEncodingSet = true;
@@ -852,19 +863,22 @@ public class Response
     @Override
     public void setLocale(Locale locale) {
 
-        if (isCommitted())
+        if (isCommitted()) {
             return;
+        }
 
         // Ignore any call from an included servlet
-        if (included)
+        if (included) {
             return;
+        }
 
         coyoteResponse.setLocale(locale);
 
         // Ignore any call made after the getWriter has been invoked.
         // The default should be used
-        if (usingWriter)
+        if (usingWriter) {
             return;
+        }
 
         if (isCharacterEncodingSet) {
             return;
@@ -976,8 +990,9 @@ public class Response
     public void addCookie(final Cookie cookie) {
 
         // Ignore any call from an included servlet
-        if (included || isCommitted())
+        if (included || isCommitted()) {
             return;
+        }
 
         final StringBuffer sb = generateCookieString(cookie);
         //if we reached here, no exception, cookie is valid
@@ -988,14 +1003,15 @@ public class Response
     }
 
     /**
-     * Special method for adding a session cookie as we should be overriding 
-     * any previous 
+     * Special method for adding a session cookie as we should be overriding
+     * any previous
      * @param cookie
      */
     public void addSessionCookieInternal(final Cookie cookie) {
-        if (isCommitted())
+        if (isCommitted()) {
             return;
-        
+        }
+
         String name = cookie.getName();
         final String headername = "Set-Cookie";
         final String startsWith = name + "=";
@@ -1014,22 +1030,22 @@ public class Response
         if (!set) {
             addHeader(headername, sb.toString());
         }
-        
-        
+
+
     }
 
     public StringBuffer generateCookieString(final Cookie cookie) {
         final StringBuffer sb = new StringBuffer();
-        //web application code can receive a IllegalArgumentException 
+        //web application code can receive a IllegalArgumentException
         //from the appendCookieValue invocation
         if (SecurityUtil.isPackageProtectionEnabled()) {
             AccessController.doPrivileged(new PrivilegedAction<Void>() {
                 @Override
                 public Void run(){
                     ServerCookie.appendCookieValue
-                        (sb, cookie.getVersion(), cookie.getName(), 
-                         cookie.getValue(), cookie.getPath(), 
-                         cookie.getDomain(), cookie.getComment(), 
+                        (sb, cookie.getVersion(), cookie.getName(),
+                         cookie.getValue(), cookie.getPath(),
+                         cookie.getDomain(), cookie.getComment(),
                          cookie.getMaxAge(), cookie.getSecure(),
                          cookie.isHttpOnly());
                     return null;
@@ -1038,7 +1054,7 @@ public class Response
         } else {
             ServerCookie.appendCookieValue
                 (sb, cookie.getVersion(), cookie.getName(), cookie.getValue(),
-                     cookie.getPath(), cookie.getDomain(), cookie.getComment(), 
+                     cookie.getPath(), cookie.getDomain(), cookie.getComment(),
                      cookie.getMaxAge(), cookie.getSecure(),
                      cookie.isHttpOnly());
         }
@@ -1059,8 +1075,9 @@ public class Response
             return;
         }
 
-        if (isCommitted())
+        if (isCommitted()) {
             return;
+        }
 
         // Ignore any call from an included servlet
         if (included) {
@@ -1091,12 +1108,14 @@ public class Response
             return;
         }
 
-        if (isCommitted())
+        if (isCommitted()) {
             return;
+        }
 
         // Ignore any call from an included servlet
-        if (included)
+        if (included) {
             return;
+        }
 
         coyoteResponse.addHeader(name, value);
 
@@ -1116,12 +1135,14 @@ public class Response
             return;
         }
 
-        if (isCommitted())
+        if (isCommitted()) {
             return;
+        }
 
         // Ignore any call from an included servlet
-        if (included)
+        if (included) {
             return;
+        }
 
         addHeader(name, "" + value);
 
@@ -1195,10 +1216,10 @@ public class Response
      */
     @Override
     public String encodeURL(String url) {
-        
+
         String absolute = toAbsolute(url);
         if (isEncodeable(absolute)) {
-            // W3c spec clearly said 
+            // W3c spec clearly said
             if (url.equalsIgnoreCase("")) {
                 url = absolute;
             } else if (url.equals(absolute) && !hasPath(url)) {
@@ -1230,18 +1251,20 @@ public class Response
 
     /**
      * Send an acknowledgment of a request.
-     * 
+     *
      * @exception IOException if an input/output error occurs
      */
     public void sendAcknowledgement()
         throws IOException {
 
-        if (isCommitted())
+        if (isCommitted()) {
             return;
+        }
 
         // Ignore any call from an included servlet
-        if (included)
-            return; 
+        if (included) {
+            return;
+        }
 
         coyoteResponse.acknowledge();
 
@@ -1259,7 +1282,7 @@ public class Response
      * @exception IOException if an input/output error occurs
      */
     @Override
-    public void sendError(int status) 
+    public void sendError(int status)
         throws IOException {
         sendError(status, null);
     }
@@ -1276,21 +1299,23 @@ public class Response
      * @exception IOException if an input/output error occurs
      */
     @Override
-    public void sendError(int status, String message) 
+    public void sendError(int status, String message)
         throws IOException {
 
-        if (isCommitted())
+        if (isCommitted()) {
             throw new IllegalStateException
                 (sm.getString("coyoteResponse.sendError.ise"));
+        }
 
         // Ignore any call from an included servlet
-        if (included)
-            return; 
+        if (included) {
+            return;
+        }
 
         Wrapper wrapper = getRequest().getWrapper();
         if (wrapper != null) {
             wrapper.incrementErrorCount();
-        } 
+        }
 
         setError();
 
@@ -1316,16 +1341,18 @@ public class Response
      * @exception IOException if an input/output error occurs
      */
     @Override
-    public void sendRedirect(String location) 
+    public void sendRedirect(String location)
         throws IOException {
 
-        if (isCommitted())
+        if (isCommitted()) {
             throw new IllegalStateException
                 (sm.getString("coyoteResponse.sendRedirect.ise"));
+        }
 
         // Ignore any call from an included servlet
-        if (included)
-            return; 
+        if (included) {
+            return;
+        }
 
         // Clear any data content that has been buffered
         resetBuffer(true);
@@ -1364,8 +1391,9 @@ public class Response
             return;
         }
 
-        if (isCommitted())
+        if (isCommitted()) {
             return;
+        }
 
         // Ignore any call from an included servlet
         if (included) {
@@ -1396,12 +1424,14 @@ public class Response
             return;
         }
 
-        if (isCommitted())
+        if (isCommitted()) {
             return;
+        }
 
         // Ignore any call from an included servlet
-        if (included)
+        if (included) {
             return;
+        }
 
         coyoteResponse.setHeader(name, value);
 
@@ -1421,12 +1451,14 @@ public class Response
             return;
         }
 
-        if (isCommitted())
+        if (isCommitted()) {
             return;
+        }
 
         // Ignore any call from an included servlet
-        if (included)
+        if (included) {
             return;
+        }
 
         setHeader(name, "" + value);
 
@@ -1458,12 +1490,14 @@ public class Response
     @Deprecated
     public void setStatus(int status, String message) {
 
-        if (isCommitted())
+        if (isCommitted()) {
             return;
+        }
 
         // Ignore any call from an included servlet
-        if (included)
+        if (included) {
             return;
+        }
 
         coyoteResponse.setStatus(status);
         coyoteResponse.setMessage(message);
@@ -1489,25 +1523,30 @@ public class Response
      */
     protected boolean isEncodeable(final String location) {
 
-        if (location == null)
+        if (location == null) {
             return (false);
+        }
 
         // Is this an intra-document reference?
-        if (location.startsWith("#"))
+        if (location.startsWith("#")) {
             return (false);
+        }
 
         // Are we in a valid session that is not using cookies?
         final Request hreq = request;
         final Session session = hreq.getSessionInternal(false);
-        if (session == null)
+        if (session == null) {
             return (false);
-        if (hreq.isRequestedSessionIdFromCookie())
+        }
+        if (hreq.isRequestedSessionIdFromCookie()) {
             return (false);
-        
+        }
+
         // Is URL encoding permitted
         if (!hreq.getServletContext().getEffectiveSessionTrackingModes().
-                contains(SessionTrackingMode.URL))
+                contains(SessionTrackingMode.URL)) {
             return false;
+        }
 
         if (SecurityUtil.isPackageProtectionEnabled()) {
             return (
@@ -1523,7 +1562,7 @@ public class Response
         }
     }
 
-    private boolean doIsEncodeable(Request hreq, Session session, 
+    private boolean doIsEncodeable(Request hreq, Session session,
                                    String location) {
         // Is this a valid absolute URL?
         URL url = null;
@@ -1534,38 +1573,45 @@ public class Response
         }
 
         // Does this URL match down to (and including) the context path?
-        if (!hreq.getScheme().equalsIgnoreCase(url.getProtocol()))
+        if (!hreq.getScheme().equalsIgnoreCase(url.getProtocol())) {
             return (false);
-        if (!hreq.getServerName().equalsIgnoreCase(url.getHost()))
+        }
+        if (!hreq.getServerName().equalsIgnoreCase(url.getHost())) {
             return (false);
+        }
         int serverPort = hreq.getServerPort();
         if (serverPort == -1) {
-            if ("https".equals(hreq.getScheme()))
+            if ("https".equals(hreq.getScheme())) {
                 serverPort = 443;
-            else
+            } else {
                 serverPort = 80;
+            }
         }
         int urlPort = url.getPort();
         if (urlPort == -1) {
-            if ("https".equals(url.getProtocol()))
+            if ("https".equals(url.getProtocol())) {
                 urlPort = 443;
-            else
+            } else {
                 urlPort = 80;
+            }
         }
-        if (serverPort != urlPort)
+        if (serverPort != urlPort) {
             return (false);
+        }
 
         String contextPath = getContext().getPath();
         if (contextPath != null) {
             String file = url.getFile();
-            if ((file == null) || !file.startsWith(contextPath))
+            if ((file == null) || !file.startsWith(contextPath)) {
                 return (false);
+            }
             String tok = ";" +
                     ApplicationSessionCookieConfig.getSessionUriParamName(
                                 request.getContext()) +
                     "=" + session.getIdInternal();
-            if( file.indexOf(tok, contextPath.length()) >= 0 )
+            if( file.indexOf(tok, contextPath.length()) >= 0 ) {
                 return (false);
+            }
         }
 
         // This URL belongs to our web application, so it is encodeable
@@ -1586,8 +1632,9 @@ public class Response
      */
     protected String toAbsolute(String location) {
 
-        if (location == null)
+        if (location == null) {
             return (location);
+        }
 
         boolean leadingSlash = location.startsWith("/");
 
@@ -1630,18 +1677,18 @@ public class Response
                     String relativePath = request.getDecodedRequestURI();
                     int pos = relativePath.lastIndexOf('/');
                     relativePath = relativePath.substring(0, pos);
-                    
+
                     String encodedURI = null;
                     final String frelativePath = relativePath;
                     if (SecurityUtil.isPackageProtectionEnabled() ){
                         try{
-                            encodedURI = AccessController.doPrivileged( 
-                                new PrivilegedExceptionAction<String>(){                                
+                            encodedURI = AccessController.doPrivileged(
+                                new PrivilegedExceptionAction<String>(){
                                     @Override
                                     public String run() throws IOException{
                                         return urlEncoder.encodeURL(frelativePath);
                                     }
-                           });   
+                           });
                         } catch (PrivilegedActionException pae){
                             IllegalArgumentException iae =
                                 new IllegalArgumentException(location);
@@ -1713,8 +1760,9 @@ public class Response
      */
     protected String toEncoded(String url, String sessionId) {
 
-        if ((url == null) || (sessionId == null))
+        if ((url == null) || (sessionId == null)) {
             return (url);
+        }
 
         String path = url;
         String query = "";

==================================================
Ascii.java
index 13a7c046d9..a8d94dbf97 100644
--- a/java/org/apache/catalina/connector/ResponseFacade.java
+++ b/java/org/apache/catalina/connector/ResponseFacade.java
@@ -5,17 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-
 package org.apache.catalina.connector;
 
 import java.io.IOException;
@@ -36,7 +34,7 @@ import org.apache.catalina.security.SecurityUtil;
 import org.apache.tomcat.util.res.StringManager;
 
 /**
- * Facade class that wraps a Coyote response object. 
+ * Facade class that wraps a Coyote response object.
  * All methods are delegated to the wrapped response.
  *
  * @author Remy Maucherat
@@ -44,34 +42,34 @@ import org.apache.tomcat.util.res.StringManager;
  * @version $Id$
  */
 @SuppressWarnings("deprecation")
-public class ResponseFacade 
+public class ResponseFacade
     implements HttpServletResponse {
 
 
     // ----------------------------------------------------------- DoPrivileged
-    
+
     private final class SetContentTypePrivilegedAction
             implements PrivilegedAction<Void> {
 
-        private String contentType;
+        private final String contentType;
 
         public SetContentTypePrivilegedAction(String contentType){
             this.contentType = contentType;
         }
-        
+
         @Override
         public Void run() {
             response.setContentType(contentType);
             return null;
-        }            
+        }
     }
 
     private final class DateHeaderPrivilegedAction
             implements PrivilegedAction<Void> {
 
-        private String name;
-        private long value;
-        private boolean add;
+        private final String name;
+        private final long value;
+        private final boolean add;
 
         DateHeaderPrivilegedAction(String name, long value, boolean add) {
             this.name = name;
@@ -89,7 +87,7 @@ public class ResponseFacade
             return null;
         }
     }
-    
+
     // ----------------------------------------------------------- Constructors
 
 
@@ -197,8 +195,9 @@ public class ResponseFacade
         //                (/*sm.getString("responseFacade.finished")*/);
 
         ServletOutputStream sos = response.getOutputStream();
-        if (isFinished())
+        if (isFinished()) {
             response.setSuspended(true);
+        }
         return (sos);
 
     }
@@ -213,8 +212,9 @@ public class ResponseFacade
         //                (/*sm.getString("responseFacade.finished")*/);
 
         PrintWriter writer = response.getWriter();
-        if (isFinished())
+        if (isFinished()) {
             response.setSuspended(true);
+        }
         return (writer);
 
     }
@@ -223,8 +223,9 @@ public class ResponseFacade
     @Override
     public void setContentLength(int len) {
 
-        if (isCommitted())
+        if (isCommitted()) {
             return;
+        }
 
         response.setContentLength(len);
 
@@ -234,13 +235,14 @@ public class ResponseFacade
     @Override
     public void setContentType(String type) {
 
-        if (isCommitted())
+        if (isCommitted()) {
             return;
-        
+        }
+
         if (SecurityUtil.isPackageProtectionEnabled()){
             AccessController.doPrivileged(new SetContentTypePrivilegedAction(type));
         } else {
-            response.setContentType(type);            
+            response.setContentType(type);
         }
     }
 
@@ -248,9 +250,10 @@ public class ResponseFacade
     @Override
     public void setBufferSize(int size) {
 
-        if (isCommitted())
+        if (isCommitted()) {
             throw new IllegalStateException
                 (sm.getString("coyoteResponse.setBufferSize.ise"));
+        }
 
         response.setBufferSize(size);
 
@@ -273,10 +276,11 @@ public class ResponseFacade
     public void flushBuffer()
         throws IOException {
 
-        if (isFinished())
+        if (isFinished()) {
             //            throw new IllegalStateException
             //                (/*sm.getString("responseFacade.finished")*/);
             return;
+        }
 
         if (SecurityUtil.isPackageProtectionEnabled()){
             try{
@@ -300,7 +304,7 @@ public class ResponseFacade
         } else {
             response.setAppCommitted(true);
 
-            response.flushBuffer();            
+            response.flushBuffer();
         }
 
     }
@@ -309,9 +313,10 @@ public class ResponseFacade
     @Override
     public void resetBuffer() {
 
-        if (isCommitted())
+        if (isCommitted()) {
             throw new IllegalStateException
                 (sm.getString("coyoteResponse.resetBuffer.ise"));
+        }
 
         response.resetBuffer();
 
@@ -333,9 +338,10 @@ public class ResponseFacade
     @Override
     public void reset() {
 
-        if (isCommitted())
+        if (isCommitted()) {
             throw new IllegalStateException
                 (sm.getString("coyoteResponse.reset.ise"));
+        }
 
         response.reset();
 
@@ -345,8 +351,9 @@ public class ResponseFacade
     @Override
     public void setLocale(Locale loc) {
 
-        if (isCommitted())
+        if (isCommitted()) {
             return;
+        }
 
         response.setLocale(loc);
     }
@@ -367,8 +374,9 @@ public class ResponseFacade
     @Override
     public void addCookie(Cookie cookie) {
 
-        if (isCommitted())
+        if (isCommitted()) {
             return;
+        }
 
         response.addCookie(cookie);
 
@@ -439,9 +447,10 @@ public class ResponseFacade
     public void sendError(int sc, String msg)
         throws IOException {
 
-        if (isCommitted())
+        if (isCommitted()) {
             throw new IllegalStateException
                 (sm.getString("coyoteResponse.sendError.ise"));
+        }
 
         response.setAppCommitted(true);
 
@@ -454,9 +463,10 @@ public class ResponseFacade
     public void sendError(int sc)
         throws IOException {
 
-        if (isCommitted())
+        if (isCommitted()) {
             throw new IllegalStateException
                 (sm.getString("coyoteResponse.sendError.ise"));
+        }
 
         response.setAppCommitted(true);
 
@@ -469,9 +479,10 @@ public class ResponseFacade
     public void sendRedirect(String location)
         throws IOException {
 
-        if (isCommitted())
+        if (isCommitted()) {
             throw new IllegalStateException
                 (sm.getString("coyoteResponse.sendRedirect.ise"));
+        }
 
         response.setAppCommitted(true);
 
@@ -483,8 +494,9 @@ public class ResponseFacade
     @Override
     public void setDateHeader(String name, long date) {
 
-        if (isCommitted())
+        if (isCommitted()) {
             return;
+        }
 
         if(Globals.IS_SECURITY_ENABLED) {
             AccessController.doPrivileged(new DateHeaderPrivilegedAction
@@ -499,8 +511,9 @@ public class ResponseFacade
     @Override
     public void addDateHeader(String name, long date) {
 
-        if (isCommitted())
+        if (isCommitted()) {
             return;
+        }
 
         if(Globals.IS_SECURITY_ENABLED) {
             AccessController.doPrivileged(new DateHeaderPrivilegedAction
@@ -515,8 +528,9 @@ public class ResponseFacade
     @Override
     public void setHeader(String name, String value) {
 
-        if (isCommitted())
+        if (isCommitted()) {
             return;
+        }
 
         response.setHeader(name, value);
 
@@ -526,8 +540,9 @@ public class ResponseFacade
     @Override
     public void addHeader(String name, String value) {
 
-        if (isCommitted())
+        if (isCommitted()) {
             return;
+        }
 
         response.addHeader(name, value);
 
@@ -537,8 +552,9 @@ public class ResponseFacade
     @Override
     public void setIntHeader(String name, int value) {
 
-        if (isCommitted())
+        if (isCommitted()) {
             return;
+        }
 
         response.setIntHeader(name, value);
 
@@ -548,8 +564,9 @@ public class ResponseFacade
     @Override
     public void addIntHeader(String name, int value) {
 
-        if (isCommitted())
+        if (isCommitted()) {
             return;
+        }
 
         response.addIntHeader(name, value);
 
@@ -559,8 +576,9 @@ public class ResponseFacade
     @Override
     public void setStatus(int sc) {
 
-        if (isCommitted())
+        if (isCommitted()) {
             return;
+        }
 
         response.setStatus(sc);
 
@@ -570,8 +588,9 @@ public class ResponseFacade
     @Override
     public void setStatus(int sc, String sm) {
 
-        if (isCommitted())
+        if (isCommitted()) {
             return;
+        }
 
         response.setStatus(sc, sm);
     }
@@ -604,17 +623,17 @@ public class ResponseFacade
     public int getStatus() {
         return response.getStatus();
     }
-    
+
     @Override
     public String getHeader(String name) {
         return response.getHeader(name);
     }
-    
+
     @Override
     public Collection<String> getHeaderNames() {
         return response.getHeaderNames();
     }
-    
+
     @Override
     public Collection<String> getHeaders(String name) {
         return response.getHeaders(name);

==================================================
B2CConverter.java
index 25bb51528e..9b1341c21e 100644
--- a/java/org/apache/tomcat/util/buf/Ascii.java
+++ b/java/org/apache/tomcat/util/buf/Ascii.java
@@ -14,7 +14,6 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
 package org.apache.tomcat.util.buf;
 
 /**
@@ -197,7 +196,7 @@ public final class Ascii {
 
         long n = c - '0';
         long m;
-        
+
         while (--len > 0) {
             if (!isDigit(c = b[off++])) {
                 throw new NumberFormatException();

==================================================
ByteChunk.java
index d59162b583..e1b77f42b3 100644
--- a/java/org/apache/tomcat/util/buf/B2CConverter.java
+++ b/java/org/apache/tomcat/util/buf/B2CConverter.java
@@ -14,8 +14,6 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
-
 package org.apache.tomcat.util.buf;
 
 import java.io.IOException;
@@ -30,7 +28,7 @@ import java.util.Map;
 import org.apache.tomcat.util.res.StringManager;
 
 /** Efficient conversion of bytes  to character .
- *  
+ *
  *  This uses the standard JDK mechanism - a reader - but provides mechanisms
  *  to recycle all the objects that are used. It is compatible with JDK1.1
  *  and up,
@@ -41,11 +39,11 @@ import org.apache.tomcat.util.res.StringManager;
  *  be used in a later version or after the remaining optimizations.
  */
 public class B2CConverter {
-    
-    
+
+
     private static final org.apache.juli.logging.Log log=
         org.apache.juli.logging.LogFactory.getLog( B2CConverter.class );
-    
+
     private static final StringManager sm =
         StringManager.getManager(Constants.Package);
 
@@ -70,7 +68,7 @@ public class B2CConverter {
         String lowerCaseEnc = enc.toLowerCase(Locale.US);
 
         Charset charset = encodingToCharsetCache.get(lowerCaseEnc);
-        
+
         if (charset == null) {
             // Pre-population of the cache means this must be invalid
             throw new UnsupportedEncodingException(
@@ -78,14 +76,14 @@ public class B2CConverter {
         }
         return charset;
     }
-    
+
     private IntermediateInputStream iis;
     private ReadConvertor conv;
     private String encoding;
 
     protected B2CConverter() {
     }
-    
+
     /** Create a converter, with bytes going to a byte buffer
      */
     public B2CConverter(String encoding)
@@ -95,7 +93,7 @@ public class B2CConverter {
         reset();
     }
 
-    
+
     /** Reset the internal state, empty the buffers.
      *  The encoding remain in effect, the internal buffers remain allocated.
      */
@@ -106,7 +104,7 @@ public class B2CConverter {
     static final int BUFFER_SIZE=8192;
     char result[]=new char[BUFFER_SIZE];
 
-    public void convert( ByteChunk bb, CharChunk cb, int limit) 
+    public void convert( ByteChunk bb, CharChunk cb, int limit)
         throws IOException
     {
         iis.setByteChunk( bb );
@@ -119,19 +117,22 @@ public class B2CConverter {
                 int cnt=conv.read( result, 0, size );
                 if( cnt <= 0 ) {
                     // End of stream ! - we may be in a bad state
-                    if(log.isDebugEnabled())
+                    if(log.isDebugEnabled()) {
                         log.debug("B2CConverter: EOF");
+                    }
                     return;
                 }
-                if(log.isDebugEnabled())
+                if(log.isDebugEnabled()) {
                     log.debug("B2CConverter: Converted: " +
                             new String(result, 0, cnt));
+                }
                 cb.append( result, 0, cnt );
                 limit = limit - (bbLengthBeforeRead - bb.getLength());
             }
         } catch( IOException ex) {
-            if(log.isDebugEnabled())
+            if(log.isDebugEnabled()) {
                 log.debug("B2CConverter: Reseting the converter " + ex.toString());
+            }
             reset();
             throw ex;
         }
@@ -153,16 +154,16 @@ public class B2CConverter {
 
 
 /**
- * 
+ *
  */
 final class  ReadConvertor extends InputStreamReader {
-    
+
     /** Create a converter.
      */
     public ReadConvertor(IntermediateInputStream in, Charset charset) {
         super(in, charset);
     }
-    
+
     /** Overridden - will do nothing but reset internal state.
      */
     @Override
@@ -170,7 +171,7 @@ final class  ReadConvertor extends InputStreamReader {
         // NOTHING
         // Calling super.close() would reset out and cb.
     }
-    
+
     @Override
     public  final int read(char cbuf[], int off, int len)
         throws IOException
@@ -178,7 +179,7 @@ final class  ReadConvertor extends InputStreamReader {
         // will do the conversion and call write on the output stream
         return super.read( cbuf, off, len );
     }
-    
+
     /** Reset the buffer
      */
     public  final void recycle() {
@@ -196,27 +197,27 @@ final class  ReadConvertor extends InputStreamReader {
 
 /** Special output stream where close() is overridden, so super.close()
     is never called.
-    
+
     This allows recycling. It can also be disabled, so callbacks will
     not be called if recycling the converter and if data was not flushed.
 */
 final class IntermediateInputStream extends InputStream {
     ByteChunk bc = null;
-    
+
     public IntermediateInputStream() {
     }
-    
+
     @Override
     public  final void close() throws IOException {
         // shouldn't be called - we filter it out in writer
         throw new IOException("close() called - shouldn't happen ");
     }
-    
+
     @Override
     public  final  int read(byte cbuf[], int off, int len) throws IOException {
         return bc.substract(cbuf, off, len);
     }
-    
+
     @Override
     public  final int read() throws IOException {
         return bc.substract();

==================================================
C2BConverter.java
index 42aaf985fc..6771b84196 100644
--- a/java/org/apache/tomcat/util/buf/ByteChunk.java
+++ b/java/org/apache/tomcat/util/buf/ByteChunk.java
@@ -14,7 +14,6 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
 package org.apache.tomcat.util.buf;
 
 import java.io.IOException;
@@ -71,9 +70,9 @@ public final class ByteChunk implements Cloneable, Serializable {
      * Same as java.nio.channel.ReadableByteChannel
      */
     public static interface ByteInputChannel {
-        /** 
+        /**
          * Read new bytes ( usually the internal conversion buffer ).
-         * The implementation is allowed to ignore the parameters, 
+         * The implementation is allowed to ignore the parameters,
          * and mutate the chunk if it wishes to implement its own buffering.
          */
         public int realReadBytes(byte cbuf[], int off, int len)
@@ -83,7 +82,7 @@ public final class ByteChunk implements Cloneable, Serializable {
     /** Same as java.nio.channel.WrittableByteChannel.
      */
     public static interface ByteOutputChannel {
-        /** 
+        /**
          * Send the bytes ( usually the internal conversion buffer ).
          * Expect 8k output if the buffer is full.
          */
@@ -95,10 +94,10 @@ public final class ByteChunk implements Cloneable, Serializable {
 
     /** Default encoding used to convert to strings. It should be UTF8,
         as most standards seem to converge, but the servlet API requires
-        8859_1, and this object is used mostly for servlets. 
+        8859_1, and this object is used mostly for servlets.
     */
     public static final String DEFAULT_CHARACTER_ENCODING="ISO-8859-1";
-        
+
     // byte[]
     private byte[] buff;
 
@@ -116,7 +115,7 @@ public final class ByteChunk implements Cloneable, Serializable {
     private ByteOutputChannel out = null;
 
     private boolean optimizedWrite=true;
-    
+
     /**
      * Creates a new, uninitialized ByteChunk object.
      */
@@ -140,7 +139,7 @@ public final class ByteChunk implements Cloneable, Serializable {
     public boolean isNull() {
         return ! isSet; // buff==null;
     }
-    
+
     /**
      * Resets the message buff to an uninitialized state.
      */
@@ -161,7 +160,7 @@ public final class ByteChunk implements Cloneable, Serializable {
     public void allocate( int initial, int limit  ) {
         if( buff==null || buff.length < initial ) {
             buff=new byte[initial];
-        }    
+        }
         this.limit=limit;
         start=0;
         end=0;
@@ -170,7 +169,7 @@ public final class ByteChunk implements Cloneable, Serializable {
 
     /**
      * Sets the message bytes to the specified subarray of bytes.
-     * 
+     *
      * @param b the ascii bytes
      * @param off the start offset of the bytes
      * @param len the length of the bytes
@@ -190,8 +189,9 @@ public final class ByteChunk implements Cloneable, Serializable {
         this.enc=enc;
     }
     public String getEncoding() {
-        if (enc == null)
+        if (enc == null) {
             enc=DEFAULT_CHARACTER_ENCODING;
+        }
         return enc;
     }
 
@@ -222,7 +222,9 @@ public final class ByteChunk implements Cloneable, Serializable {
     }
 
     public void setOffset(int off) {
-        if (end < off ) end=off;
+        if (end < off ) {
+            end=off;
+        }
         start=off;
     }
 
@@ -244,7 +246,7 @@ public final class ByteChunk implements Cloneable, Serializable {
     public void setLimit(int limit) {
         this.limit=limit;
     }
-    
+
     public int getLimit() {
         return limit;
     }
@@ -369,11 +371,13 @@ public final class ByteChunk implements Cloneable, Serializable {
         throws IOException {
 
         if ((end - start) == 0) {
-            if (in == null)
+            if (in == null) {
                 return -1;
+            }
             int n = in.realReadBytes( buff, 0, buff.length );
-            if (n < 0)
+            if (n < 0) {
                 return -1;
+            }
         }
 
         return (buff[start++] & 0xFF);
@@ -384,11 +388,13 @@ public final class ByteChunk implements Cloneable, Serializable {
         throws IOException {
 
         if ((end - start) == 0) {
-            if (in == null)
+            if (in == null) {
                 return -1;
+            }
             int n = in.realReadBytes( buff, 0, buff.length );
-            if (n < 0)
+            if (n < 0) {
                 return -1;
+            }
         }
 
         int len = getLength();
@@ -402,11 +408,13 @@ public final class ByteChunk implements Cloneable, Serializable {
         throws IOException {
 
         if ((end - start) == 0) {
-            if (in == null)
+            if (in == null) {
                 return -1;
+            }
             int n = in.realReadBytes( buff, 0, buff.length );
-            if (n < 0)
+            if (n < 0) {
                 return -1;
+            }
         }
 
         int n = len;
@@ -455,10 +463,13 @@ public final class ByteChunk implements Cloneable, Serializable {
         }
 
         if( buff==null ) {
-            if( desiredSize < 256 ) desiredSize=256; // take a minimum
+            if( desiredSize < 256 )
+             {
+                desiredSize=256; // take a minimum
+            }
             buff=new byte[desiredSize];
         }
-        
+
         // limit < buf.length ( the buffer is already big )
         // or we already have space XXX
         if( desiredSize <= buff.length ) {
@@ -468,22 +479,26 @@ public final class ByteChunk implements Cloneable, Serializable {
         if( desiredSize < 2 * buff.length ) {
             newSize= buff.length * 2;
             if( limit >0 &&
-                newSize > limit ) newSize=limit;
+                newSize > limit ) {
+                newSize=limit;
+            }
             tmp=new byte[newSize];
         } else {
             newSize= buff.length * 2 + count ;
             if( limit > 0 &&
-                newSize > limit ) newSize=limit;
+                newSize > limit ) {
+                newSize=limit;
+            }
             tmp=new byte[newSize];
         }
-        
+
         System.arraycopy(buff, start, tmp, 0, end-start);
         buff = tmp;
         tmp = null;
         end=end-start;
         start=0;
     }
-    
+
     // -------------------- Conversion and getters --------------------
 
     @Override
@@ -495,7 +510,7 @@ public final class ByteChunk implements Cloneable, Serializable {
         }
         return StringCache.toString(this);
     }
-    
+
     public String toStringInternal() {
         String strValue=null;
         try {
@@ -507,12 +522,12 @@ public final class ByteChunk implements Cloneable, Serializable {
             /*
              Does not improve the speed too much on most systems,
              it's safer to use the "classical" new String().
-             
+
              Most overhead is in creating char[] and copying,
              the internal implementation of new String() is very close to
              what we do. The decoder is nice for large buffers and if
              we don't go to String ( so we can take advantage of reduced GC)
-             
+
              // Method is commented out, in:
               return B2CConverter.decodeString( enc );
               */
@@ -544,7 +559,7 @@ public final class ByteChunk implements Cloneable, Serializable {
     public boolean equals(String s) {
         // XXX ENCODING - this only works if encoding is UTF8-compat
         // ( ok for tomcat, where we compare ascii - header names, etc )!!!
-        
+
         byte[] b = buff;
         int blen = end-start;
         if (b == null || blen != s.length()) {
@@ -582,15 +597,18 @@ public final class ByteChunk implements Cloneable, Serializable {
     public boolean equals( ByteChunk bb ) {
         return equals( bb.getBytes(), bb.getStart(), bb.getLength());
     }
-    
+
     public boolean equals( byte b2[], int off2, int len2) {
         byte b1[]=buff;
-        if( b1==null && b2==null ) return true;
+        if( b1==null && b2==null ) {
+            return true;
+        }
 
         int len=end-start;
-        if ( len2 != len || b1==null || b2==null ) 
+        if ( len2 != len || b1==null || b2==null ) {
             return false;
-                
+        }
+
         int off1 = start;
 
         while ( len-- > 0) {
@@ -604,18 +622,20 @@ public final class ByteChunk implements Cloneable, Serializable {
     public boolean equals( CharChunk cc ) {
         return equals( cc.getChars(), cc.getStart(), cc.getLength());
     }
-    
+
     public boolean equals( char c2[], int off2, int len2) {
         // XXX works only for enc compatible with ASCII/UTF !!!
         byte b1[]=buff;
-        if( c2==null && b1==null ) return true;
-        
+        if( c2==null && b1==null ) {
+            return true;
+        }
+
         if (b1== null || c2==null || end-start != len2 ) {
             return false;
         }
         int off1 = start;
         int len=end-start;
-        
+
         while ( len-- > 0) {
             if ( (char)b1[off1++] != c2[off2++]) {
                 return false;
@@ -656,8 +676,9 @@ public final class ByteChunk implements Cloneable, Serializable {
             return false;
         }
         for (int i = start, j = 0; i < end && j < b2.length;) {
-            if (b1[i++] != b2[j++]) 
+            if (b1[i++] != b2[j++]) {
                 return false;
+            }
         }
         return true;
     }
@@ -685,17 +706,20 @@ public final class ByteChunk implements Cloneable, Serializable {
     public int indexOf( String src, int srcOff, int srcLen, int myOff ) {
         char first=src.charAt( srcOff );
 
-        // Look for first char 
+        // Look for first char
         int srcEnd = srcOff + srcLen;
-        
+
         mainLoop:
         for( int i=myOff+start; i <= (end - srcLen); i++ ) {
-            if( buff[i] != first ) continue;
+            if( buff[i] != first ) {
+                continue;
+            }
             // found first char, now look for a match
             int myPos=i+1;
             for( int srcPos=srcOff + 1; srcPos< srcEnd;) {
-                if( buff[myPos++] != src.charAt( srcPos++ ))
+                if( buff[myPos++] != src.charAt( srcPos++ )) {
                     continue mainLoop;
+                }
             }
             return i-start; // found it
         }
@@ -704,7 +728,7 @@ public final class ByteChunk implements Cloneable, Serializable {
 
     // -------------------- Hash code  --------------------
 
-    // normal hash. 
+    // normal hash.
     public int hash() {
         return hashBytes( buff, start, end-start);
     }
@@ -742,7 +766,7 @@ public final class ByteChunk implements Cloneable, Serializable {
      * returned.
      * <br/>
      * NOTE: This only works for characters in the range 0-127.
-     * 
+     *
      * @param c         The character
      * @param starting  The start position
      * @return          The position of the first instance of the character or
@@ -758,21 +782,22 @@ public final class ByteChunk implements Cloneable, Serializable {
      * between the specified start and end.
      * <br/>
      * NOTE: This only works for characters in the range 0-127.
-     * 
+     *
      * @param bytes The byte array to search
      * @param start The point to start searching from in the byte array
      * @param end   The point to stop searching in the byte array
-     * @param c     The character to search for 
+     * @param c     The character to search for
      * @return      The position of the first instance of the character or -1
      *                  if the character is not found.
      */
     public static int indexOf(byte bytes[], int start, int end, char c) {
         int offset = start;
-        
+
         while (offset < end) {
             byte b=bytes[offset];
-            if (b == c)
+            if (b == c) {
                 return offset;
+            }
             offset++;
         }
         return -1;
@@ -781,11 +806,11 @@ public final class ByteChunk implements Cloneable, Serializable {
     /**
      * Returns the first instance of the given byte in the byte array between
      * the specified start and end.
-     * 
+     *
      * @param bytes The byte array to search
      * @param start The point to start searching from in the byte array
      * @param end   The point to stop searching in the byte array
-     * @param b     The byte to search for 
+     * @param b     The byte to search for
      * @return      The position of the first instance of the byte or -1 if the
      *                  byte is not found.
      */
@@ -803,11 +828,11 @@ public final class ByteChunk implements Cloneable, Serializable {
     /**
      * Returns the first instance of any of the given bytes in the byte array
      * between the specified start and end.
-     * 
+     *
      * @param bytes The byte array to search
      * @param start The point to start searching from in the byte array
      * @param end   The point to stop searching in the byte array
-     * @param b     The array of bytes to search for 
+     * @param b     The array of bytes to search for
      * @return      The position of the first instance of the byte or -1 if the
      *                  byte is not found.
      */
@@ -815,10 +840,11 @@ public final class ByteChunk implements Cloneable, Serializable {
         int blen = b.length;
         int offset = start;
         while (offset < end) {
-            for (int i = 0;  i < blen; i++) 
+            for (int i = 0;  i < blen; i++) {
                 if (bytes[offset] == b[i]) {
                     return offset;
                 }
+            }
             offset++;
         }
         return -1;
@@ -827,11 +853,11 @@ public final class ByteChunk implements Cloneable, Serializable {
     /**
      * Returns the first instance of any byte that is not one of the given bytes
      * in the byte array between the specified start and end.
-     * 
+     *
      * @param bytes The byte array to search
      * @param start The point to start searching from in the byte array
      * @param end   The point to stop searching in the byte array
-     * @param b     The list of bytes to search for 
+     * @param b     The list of bytes to search for
      * @return      The position of the first instance a byte that is not
      *                  in the list of bytes to search for or -1 if no such byte
      *                  is found.
@@ -840,7 +866,7 @@ public final class ByteChunk implements Cloneable, Serializable {
         int blen = b.length;
         int offset = start;
         boolean found;
-                
+
         while (offset < end) {
             found = true;
             for (int i = 0; i < blen; i++) {
@@ -861,7 +887,7 @@ public final class ByteChunk implements Cloneable, Serializable {
     /**
      * Convert specified String to a byte array. This ONLY WORKS for ascii, UTF
      * chars will be truncated.
-     * 
+     *
      * @param value to convert to byte array
      * @return the byte array value
      */

==================================================
CharChunk.java
index ab4ef1bde6..d0f6d5b5ae 100644
--- a/java/org/apache/tomcat/util/buf/C2BConverter.java
+++ b/java/org/apache/tomcat/util/buf/C2BConverter.java
@@ -14,7 +14,6 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
 package org.apache.tomcat.util.buf;
 
 import java.io.IOException;
@@ -23,22 +22,22 @@ import java.io.OutputStreamWriter;
 import java.nio.charset.Charset;
 
 /** Efficient conversion of character to bytes.
- *  
+ *
  *  This uses the standard JDK mechanism - a writer - but provides mechanisms
  *  to recycle all the objects that are used. It is compatible with JDK1.1 and up,
  *  ( nio is better, but it's not available even in 1.2 or 1.3 )
- * 
+ *
  */
 public final class C2BConverter {
-    
+
     private static final org.apache.juli.logging.Log log=
         org.apache.juli.logging.LogFactory.getLog(C2BConverter.class );
-    
-    private IntermediateOutputStream ios;
-    private WriteConvertor conv;
+
+    private final IntermediateOutputStream ios;
+    private final WriteConvertor conv;
     private ByteChunk bb;
-    private String enc;
-    
+    private final String enc;
+
     /** Create a converter, with bytes going to a byte buffer
      */
     public C2BConverter(ByteChunk output, String encoding) throws IOException {
@@ -103,13 +102,14 @@ public final class C2BConverter {
      */
     public final void convert(MessageBytes mb ) throws IOException {
         int type=mb.getType();
-        if( type==MessageBytes.T_BYTES )
+        if( type==MessageBytes.T_BYTES ) {
             return;
+        }
         ByteChunk orig=bb;
         setByteChunk( mb.getByteChunk());
         bb.recycle();
         bb.allocate( 32, -1 );
-        
+
         if( type==MessageBytes.T_STR ) {
             convert( mb.getString() );
             // System.out.println("XXX Converting " + mb.getString() );
@@ -119,11 +119,12 @@ public final class C2BConverter {
                                 charC.getOffset(), charC.getLength());
             //System.out.println("XXX Converting " + mb.getCharChunk() );
         } else {
-            if (log.isDebugEnabled())
+            if (log.isDebugEnabled()) {
                 log.debug("XXX unknowon type " + type );
+            }
         }
         flushBuffer();
-        //System.out.println("C2B: XXX " + bb.getBuffer() + bb.getLength()); 
+        //System.out.println("C2B: XXX " + bb.getBuffer() + bb.getLength());
         setByteChunk(orig);
     }
 
@@ -142,13 +143,13 @@ public final class C2BConverter {
 
 /**
  *  Special writer class, where close() is overridden. The default implementation
- *  would set byteOutputter to null, and the writer can't be recycled. 
+ *  would set byteOutputter to null, and the writer can't be recycled.
  *
  *  Note that the flush method will empty the internal buffers _and_ call
  *  flush on the output stream - that's why we use an intermediary output stream
  *  that overrides flush(). The idea is to  have full control: flushing the
  *  char->byte converter should be independent of flushing the OutputStream.
- * 
+ *
  *  When a WriteConverter is created, it'll allocate one or 2 byte buffers,
  *  with a 8k size that can't be changed ( at least in JDK1.1 -> 1.4 ). It would
  *  also allocate a ByteOutputter or equivalent - again some internal buffers.
@@ -156,23 +157,23 @@ public final class C2BConverter {
  *  It is essential to keep  this object around and reuse it. You can use either
  *  pools or per thread data - but given that in most cases a converter will be
  *  needed for every thread and most of the time only 1 ( or 2 ) encodings will
- *  be used, it is far better to keep it per thread and eliminate the pool 
+ *  be used, it is far better to keep it per thread and eliminate the pool
  *  overhead too.
- * 
+ *
  */
  final class WriteConvertor extends OutputStreamWriter {
     // stream with flush() and close(). overridden.
-    private IntermediateOutputStream ios;
-    
+    private final IntermediateOutputStream ios;
+
     // Has a private, internal byte[8192]
-    
+
     /** Create a converter.
      */
     public WriteConvertor(IntermediateOutputStream out, Charset charset) {
         super(out, charset);
         ios=out;
     }
-    
+
     /** Overridden - will do nothing but reset internal state.
      */
     @Override
@@ -180,23 +181,23 @@ public final class C2BConverter {
         // NOTHING
         // Calling super.close() would reset out and cb.
     }
-    
+
     /**
      *  Flush the characters only
-     */ 
+     */
     @Override
     public  final void flush() throws IOException {
         // Will flushBuffer and out()
-        // flushBuffer put any remaining chars in the byte[] 
+        // flushBuffer put any remaining chars in the byte[]
         super.flush();
     }
-    
+
     @Override
     public  final void write(char cbuf[], int off, int len) throws IOException {
         // will do the conversion and call write on the output stream
         super.write( cbuf, off, len );
     }
-    
+
     /** Reset the buffer
      */
     public  final void recycle() {
@@ -209,36 +210,36 @@ public final class C2BConverter {
         }
         ios.enable();
     }
-    
+
 }
 
 
 /** Special output stream where close() is overridden, so super.close()
     is never called.
-    
+
     This allows recycling. It can also be disabled, so callbacks will
     not be called if recycling the converter and if data was not flushed.
 */
 final class IntermediateOutputStream extends OutputStream {
     private ByteChunk tbuff;
     private boolean enabled=true;
-    
+
     public IntermediateOutputStream(ByteChunk tbuff) {
         this.tbuff=tbuff;
     }
-    
+
     @Override
     public  final void close() throws IOException {
         // shouldn't be called - we filter it out in writer
         throw new IOException("close() called - shouldn't happen ");
     }
-    
+
     @Override
     public  final void flush() throws IOException {
         // nothing - write will go directly to the buffer,
         // we don't keep any state
     }
-    
+
     @Override
     public  final  void write(byte cbuf[], int off, int len) throws IOException {
         // will do the conversion and call write on the output stream
@@ -246,7 +247,7 @@ final class IntermediateOutputStream extends OutputStream {
             tbuff.append( cbuf, off, len );
         }
     }
-    
+
     @Override
     public  final void write( int i ) throws IOException {
         throw new IOException("write( int ) called - shouldn't happen ");
@@ -257,7 +258,7 @@ final class IntermediateOutputStream extends OutputStream {
     void setByteChunk( ByteChunk bb ) {
         tbuff=bb;
     }
-    
+
     /** Temporary disable - this is used to recycle the converter without
      *  generating an output if the buffers were not flushed
      */

==================================================
Constants.java
index 27948cf2ab..fde8c7f1ee 100644
--- a/java/org/apache/tomcat/util/buf/CharChunk.java
+++ b/java/org/apache/tomcat/util/buf/CharChunk.java
@@ -14,7 +14,6 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
 package org.apache.tomcat.util.buf;
 
 import java.io.IOException;
@@ -25,7 +24,7 @@ import java.io.Serializable;
  * the easiest way to manipulate chars ( search, substrings, etc),
  * it is known to not be the most efficient solution - Strings are
  * designed as immutable and secure objects.
- * 
+ *
  * @author dac@sun.com
  * @author James Todd [gonzo@sun.com]
  * @author Costin Manolache
@@ -37,9 +36,9 @@ public final class CharChunk implements Cloneable, Serializable, CharSequence {
 
     // Input interface, used when the buffer is emptied.
     public static interface CharInputChannel {
-        /** 
+        /**
          * Read new bytes ( usually the internal conversion buffer ).
-         * The implementation is allowed to ignore the parameters, 
+         * The implementation is allowed to ignore the parameters,
          * and mutate the chunk if it wishes to implement its own buffering.
          */
         public int realReadChars(char cbuf[], int off, int len)
@@ -56,15 +55,15 @@ public final class CharChunk implements Cloneable, Serializable, CharSequence {
         public void realWriteChars(char cbuf[], int off, int len)
             throws IOException;
     }
-    
-    // -------------------- 
+
+    // --------------------
     // char[]
     private char buff[];
 
     private int start;
     private int end;
 
-    private boolean isSet=false;  // XXX 
+    private boolean isSet=false;  // XXX
 
     // -1: grow indefinitely
     // maximum amount to be cached
@@ -72,7 +71,7 @@ public final class CharChunk implements Cloneable, Serializable, CharSequence {
 
     private CharInputChannel in = null;
     private CharOutputChannel out = null;
-    
+
     private boolean optimizedWrite=true;
 
     /**
@@ -86,7 +85,7 @@ public final class CharChunk implements Cloneable, Serializable, CharSequence {
     }
 
     // --------------------
-    
+
     public CharChunk getClone() {
         try {
             return (CharChunk)this.clone();
@@ -96,10 +95,12 @@ public final class CharChunk implements Cloneable, Serializable, CharSequence {
     }
 
     public boolean isNull() {
-        if( end > 0 ) return false;
-        return !isSet; //XXX 
+        if( end > 0 ) {
+            return false;
+        }
+        return !isSet; //XXX
     }
-    
+
     /**
      * Resets the message bytes to an uninitialized state.
      */
@@ -148,7 +149,7 @@ public final class CharChunk implements Cloneable, Serializable, CharSequence {
     public void setLimit(int limit) {
         this.limit=limit;
     }
-    
+
     public int getLimit() {
         return limit;
     }
@@ -169,17 +170,17 @@ public final class CharChunk implements Cloneable, Serializable, CharSequence {
         this.out=out;
     }
 
-    // compat 
+    // compat
     public char[] getChars()
     {
         return getBuffer();
     }
-    
+
     public char[] getBuffer()
     {
         return buff;
     }
-    
+
     /**
      * Returns the start offset of the bytes.
      * For output this is the end of the buffer.
@@ -187,7 +188,7 @@ public final class CharChunk implements Cloneable, Serializable, CharSequence {
     public int getStart() {
         return start;
     }
-    
+
     public int getOffset() {
         return start;
     }
@@ -216,7 +217,7 @@ public final class CharChunk implements Cloneable, Serializable, CharSequence {
     }
 
     // -------------------- Adding data --------------------
-    
+
     public void append( char b )
         throws IOException
     {
@@ -228,7 +229,7 @@ public final class CharChunk implements Cloneable, Serializable, CharSequence {
         }
         buff[end++]=b;
     }
-    
+
     public void append( CharChunk src )
         throws IOException
     {
@@ -258,13 +259,13 @@ public final class CharChunk implements Cloneable, Serializable, CharSequence {
             out.realWriteChars( src, off, len );
             return;
         }
-        
+
         // if we have limit and we're below
         if( len <= limit - end ) {
             // makeSpace will grow the buffer to the limit,
             // so we have space
             System.arraycopy( src, off, buff, end, len );
-            
+
             end+=len;
             return;
         }
@@ -273,7 +274,7 @@ public final class CharChunk implements Cloneable, Serializable, CharSequence {
         // buffer
 
         // the buffer is already at ( or bigger than ) limit
-        
+
         // Optimization:
         // If len-avail < length ( i.e. after we fill the buffer with
         // what we can, the remaining will fit in the buffer ) we'll just
@@ -289,17 +290,17 @@ public final class CharChunk implements Cloneable, Serializable, CharSequence {
             int avail=limit-end;
             System.arraycopy(src, off, buff, end, avail);
             end += avail;
-            
+
             flushBuffer();
-            
+
             System.arraycopy(src, off+avail, buff, end, len - avail);
             end+= len - avail;
-            
+
         } else {        // len > buf.length + avail
             // long write - flush the buffer and write the rest
             // directly from source
             flushBuffer();
-            
+
             out.realWriteChars( src, off, len );
         }
     }
@@ -331,8 +332,9 @@ public final class CharChunk implements Cloneable, Serializable, CharSequence {
             sb.getChars( sbOff, sbOff+d, buff, end);
             sbOff += d;
             end += d;
-            if (end >= limit)
+            if (end >= limit) {
                 flushBuffer();
+            }
         }
     }
 
@@ -341,12 +343,14 @@ public final class CharChunk implements Cloneable, Serializable, CharSequence {
     public void append(String s) throws IOException {
         append(s, 0, s.length());
     }
-    
+
     /** Append a string to the buffer
      */
     public void append(String s, int off, int len) throws IOException {
-        if (s==null) return;
-        
+        if (s==null) {
+            return;
+        }
+
         // will grow, up to limit
         makeSpace( len );
 
@@ -365,22 +369,25 @@ public final class CharChunk implements Cloneable, Serializable, CharSequence {
             s.getChars( sOff, sOff+d, buff, end);
             sOff += d;
             end += d;
-            if (end >= limit)
+            if (end >= limit) {
                 flushBuffer();
+            }
         }
     }
-    
+
     // -------------------- Removing data from the buffer --------------------
 
     public int substract()
         throws IOException {
 
         if ((end - start) == 0) {
-            if (in == null)
+            if (in == null) {
                 return -1;
+            }
             int n = in.realReadChars(buff, end, buff.length - end);
-            if (n < 0)
+            if (n < 0) {
                 return -1;
+            }
         }
 
         return (buff[start++]);
@@ -391,11 +398,13 @@ public final class CharChunk implements Cloneable, Serializable, CharSequence {
         throws IOException {
 
         if ((end - start) == 0) {
-            if (in == null)
+            if (in == null) {
                 return -1;
+            }
             int n = in.realReadChars( buff, end, buff.length - end);
-            if (n < 0)
+            if (n < 0) {
                 return -1;
+            }
         }
 
         int len = getLength();
@@ -409,11 +418,13 @@ public final class CharChunk implements Cloneable, Serializable, CharSequence {
         throws IOException {
 
         if ((end - start) == 0) {
-            if (in == null)
+            if (in == null) {
                 return -1;
+            }
             int n = in.realReadChars( buff, end, buff.length - end);
-            if (n < 0)
+            if (n < 0) {
                 return -1;
+            }
         }
 
         int n = len;
@@ -456,7 +467,10 @@ public final class CharChunk implements Cloneable, Serializable, CharSequence {
         }
 
         if( buff==null ) {
-            if( desiredSize < 256 ) desiredSize=256; // take a minimum
+            if( desiredSize < 256 )
+             {
+                desiredSize=256; // take a minimum
+            }
             buff=new char[desiredSize];
         }
 
@@ -469,20 +483,24 @@ public final class CharChunk implements Cloneable, Serializable, CharSequence {
         if( desiredSize < 2 * buff.length ) {
             newSize= buff.length * 2;
             if( limit >0 &&
-                newSize > limit ) newSize=limit;
+                newSize > limit ) {
+                newSize=limit;
+            }
             tmp=new char[newSize];
         } else {
             newSize= buff.length * 2 + count ;
             if( limit > 0 &&
-                newSize > limit ) newSize=limit;
+                newSize > limit ) {
+                newSize=limit;
+            }
             tmp=new char[newSize];
         }
-        
+
         System.arraycopy(buff, 0, tmp, 0, end);
         buff = tmp;
         tmp = null;
     }
-    
+
     // -------------------- Conversion and getters --------------------
 
     @Override
@@ -494,7 +512,7 @@ public final class CharChunk implements Cloneable, Serializable, CharSequence {
         }
         return StringCache.toString(this);
     }
-    
+
     public String toStringInternal() {
         return new String(buff, start, end-start);
     }
@@ -504,7 +522,7 @@ public final class CharChunk implements Cloneable, Serializable, CharSequence {
         return Ascii.parseInt(buff, start,
                                 end-start);
     }
-    
+
     // -------------------- equals --------------------
 
     /**
@@ -553,8 +571,10 @@ public final class CharChunk implements Cloneable, Serializable, CharSequence {
 
     public boolean equals(char b2[], int off2, int len2) {
         char b1[]=buff;
-        if( b1==null && b2==null ) return true;
-        
+        if( b1==null && b2==null ) {
+            return true;
+        }
+
         if (b1== null || b2==null || end-start != len2) {
             return false;
         }
@@ -570,14 +590,16 @@ public final class CharChunk implements Cloneable, Serializable, CharSequence {
 
     public boolean equals(byte b2[], int off2, int len2) {
         char b1[]=buff;
-        if( b2==null && b1==null ) return true;
+        if( b2==null && b1==null ) {
+            return true;
+        }
 
         if (b1== null || b2==null || end-start != len2) {
             return false;
         }
         int off1 = start;
         int len=end-start;
-        
+
         while ( len-- > 0) {
             if ( b1[off1++] != (char)b2[off2++]) {
                 return false;
@@ -585,7 +607,7 @@ public final class CharChunk implements Cloneable, Serializable, CharSequence {
         }
         return true;
     }
-    
+
     /**
      * Returns true if the message bytes starts with the specified string.
      * @param s the string
@@ -604,7 +626,7 @@ public final class CharChunk implements Cloneable, Serializable, CharSequence {
         }
         return true;
     }
-    
+
     /**
      * Returns true if the message bytes starts with the specified string.
      * @param s the string
@@ -623,11 +645,11 @@ public final class CharChunk implements Cloneable, Serializable, CharSequence {
         }
         return true;
     }
-    
+
 
     // -------------------- Hash code  --------------------
 
-    // normal hash. 
+    // normal hash.
     public int hash() {
         int code=0;
         for (int i = start; i < start + end-start; i++) {
@@ -648,7 +670,7 @@ public final class CharChunk implements Cloneable, Serializable, CharSequence {
     public int indexOf(char c) {
         return indexOf( c, start);
     }
-    
+
     /**
      * Returns true if the message bytes starts with the specified string.
      * @param c the character
@@ -662,28 +684,35 @@ public final class CharChunk implements Cloneable, Serializable, CharSequence {
     {
         while( off < cend ) {
             char b=chars[off];
-            if( b==qq )
+            if( b==qq ) {
                 return off;
+            }
             off++;
         }
         return -1;
     }
-    
+
 
     public int indexOf( String src, int srcOff, int srcLen, int myOff ) {
         char first=src.charAt( srcOff );
 
-        // Look for first char 
+        // Look for first char
         int srcEnd = srcOff + srcLen;
-        
+
         for( int i=myOff+start; i <= (end - srcLen); i++ ) {
-            if( buff[i] != first ) continue;
+            if( buff[i] != first ) {
+                continue;
+            }
             // found first char, now look for a match
             int myPos=i+1;
             for( int srcPos=srcOff + 1; srcPos< srcEnd;) {
-                if( buff[myPos++] != src.charAt( srcPos++ ))
+                if( buff[myPos++] != src.charAt( srcPos++ )) {
                     break;
-                if( srcPos==srcEnd ) return i-start; // found it
+                }
+                if( srcPos==srcEnd )
+                 {
+                    return i-start; // found it
+                }
             }
         }
         return -1;
@@ -691,7 +720,9 @@ public final class CharChunk implements Cloneable, Serializable, CharSequence {
 
     // -------------------- utils
     private int min(int a, int b) {
-        if (a < b) return a;
+        if (a < b) {
+            return a;
+        }
         return b;
     }
 
@@ -719,5 +750,5 @@ public final class CharChunk implements Cloneable, Serializable, CharSequence {
     public int length() {
         return end - start;
     }
-    
+
 }

==================================================
HexUtils.java
index 7f9fc1f611..c594de0263 100644
--- a/java/org/apache/tomcat/util/buf/Constants.java
+++ b/java/org/apache/tomcat/util/buf/Constants.java
@@ -5,16 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package org.apache.tomcat.util.buf;
 
 /**

==================================================
MessageBytes.java
index 3afe9043ff..a27494ec1f 100644
--- a/java/org/apache/tomcat/util/buf/HexUtils.java
+++ b/java/org/apache/tomcat/util/buf/HexUtils.java
@@ -14,7 +14,6 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
 package org.apache.tomcat.util.buf;
 
 /**
@@ -57,9 +56,9 @@ public final class HexUtils {
     /**
      * Table for DEC to HEX byte translation.
      */
-    private static final byte[] HEX = 
-    { (byte) '0', (byte) '1', (byte) '2', (byte) '3', (byte) '4', (byte) '5', 
-      (byte) '6', (byte) '7', (byte) '8', (byte) '9', (byte) 'a', (byte) 'b', 
+    private static final byte[] HEX =
+    { (byte) '0', (byte) '1', (byte) '2', (byte) '3', (byte) '4', (byte) '5',
+      (byte) '6', (byte) '7', (byte) '8', (byte) '9', (byte) 'a', (byte) 'b',
       (byte) 'c', (byte) 'd', (byte) 'e', (byte) 'f' };
 
 
@@ -72,7 +71,7 @@ public final class HexUtils {
 
 
     /**
-     * Provide a mechanism for ensuring this class is loaded. 
+     * Provide a mechanism for ensuring this class is loaded.
      */
     public static void load() {
         // Nothing to do
@@ -88,14 +87,17 @@ public final class HexUtils {
 
     public static String toHexString(byte[] bytes)
     {
-        if(null == bytes) return null;
+        if(null == bytes) {
+            return null;
+        }
 
         StringBuilder sb = new StringBuilder(bytes.length << 1);
 
-        for(int i=0; i<bytes.length; ++i)
+        for(int i=0; i<bytes.length; ++i) {
             sb.append(hex[(bytes[i] & 0xf0) >> 4])
                 .append(hex[(bytes[i] & 0x0f)])
                 ;
+        }
 
         return sb.toString();
     }

==================================================
StringCache.java
index f50e27bea4..c689bb30aa 100644
--- a/java/org/apache/tomcat/util/buf/MessageBytes.java
+++ b/java/org/apache/tomcat/util/buf/MessageBytes.java
@@ -14,7 +14,6 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
 package org.apache.tomcat.util.buf;
 
 import java.io.IOException;
@@ -45,20 +44,20 @@ public final class MessageBytes implements Cloneable, Serializable {
         was a String */
     public static final int T_STR  = 1;
     /** getType() is T_STR if the the object used to create the MessageBytes
-        was a byte[] */ 
+        was a byte[] */
     public static final int T_BYTES = 2;
     /** getType() is T_STR if the the object used to create the MessageBytes
-        was a char[] */ 
+        was a char[] */
     public static final int T_CHARS = 3;
 
     private int hashCode=0;
-    // did we computed the hashcode ? 
+    // did we computed the hashcode ?
     private boolean hasHashCode=false;
 
     // Internal objects to represent array + offset, and specific methods
-    private ByteChunk byteC=new ByteChunk();
-    private CharChunk charC=new CharChunk();
-    
+    private final ByteChunk byteC=new ByteChunk();
+    private final CharChunk charC=new CharChunk();
+
     // String
     private String strValue;
     // true if a String value was computed. Probably not needed,
@@ -92,7 +91,7 @@ public final class MessageBytes implements Cloneable, Serializable {
         return byteC.isNull() && charC.isNull() && ! hasStrValue;
         // bytes==null && strValue==null;
     }
-    
+
     /**
      * Resets the message bytes to an uninitialized (NULL) state.
      */
@@ -139,7 +138,7 @@ public final class MessageBytes implements Cloneable, Serializable {
         byteC.setEncoding(enc);
     }
 
-    /** 
+    /**
      * Sets the content to be a char[]
      *
      * @param c the bytes
@@ -155,7 +154,7 @@ public final class MessageBytes implements Cloneable, Serializable {
         hasLongValue=false;
     }
 
-    /** 
+    /**
      * Set the content to be a string
      */
     public void setString( String s ) {
@@ -178,8 +177,10 @@ public final class MessageBytes implements Cloneable, Serializable {
      */
     @Override
     public String toString() {
-        if( hasStrValue ) return strValue;
-        
+        if( hasStrValue ) {
+            return strValue;
+        }
+
         switch (type) {
         case T_CHARS:
             strValue=charC.toString();
@@ -200,7 +201,7 @@ public final class MessageBytes implements Cloneable, Serializable {
     public int getType() {
         return type;
     }
-    
+
     /**
      * Returns the byte chunk, representing the byte[] and offset/length.
      * Valid only if T_BYTES or after a conversion was made.
@@ -252,7 +253,7 @@ public final class MessageBytes implements Cloneable, Serializable {
         char cc[]=strValue.toCharArray();
         charC.setChars(cc, 0, cc.length);
     }
-    
+
 
     /**
      * Returns the length of the original buffer.
@@ -260,15 +261,19 @@ public final class MessageBytes implements Cloneable, Serializable {
      * in chars.
      */
     public int getLength() {
-        if(type==T_BYTES)
+        if(type==T_BYTES) {
             return byteC.getLength();
+        }
         if(type==T_CHARS) {
             return charC.getLength();
         }
-        if(type==T_STR)
+        if(type==T_STR) {
             return strValue.length();
+        }
         toString();
-        if( strValue==null ) return 0;
+        if( strValue==null ) {
+            return 0;
+        }
         return strValue.length();
     }
 
@@ -282,7 +287,9 @@ public final class MessageBytes implements Cloneable, Serializable {
     public boolean equals(String s) {
         switch (type) {
         case T_STR:
-            if (strValue == null) return s == null;
+            if (strValue == null) {
+                return s == null;
+            }
             return strValue.equals( s );
         case T_CHARS:
             return charC.equals( s );
@@ -301,7 +308,9 @@ public final class MessageBytes implements Cloneable, Serializable {
     public boolean equalsIgnoreCase(String s) {
         switch (type) {
         case T_STR:
-            if (strValue == null) return s == null;
+            if (strValue == null) {
+                return s == null;
+            }
             return strValue.equalsIgnoreCase( s );
         case T_CHARS:
             return charC.equalsIgnoreCase( s );
@@ -335,10 +344,10 @@ public final class MessageBytes implements Cloneable, Serializable {
         // mb is either CHARS or BYTES.
         // this is either CHARS or BYTES
         // Deal with the 4 cases ( in fact 3, one is symmetric)
-        
+
         if( mb.type == T_CHARS && type==T_CHARS ) {
             return charC.equals( mb.charC );
-        } 
+        }
         if( mb.type==T_BYTES && type== T_BYTES ) {
             return byteC.equals( mb.byteC );
         }
@@ -352,7 +361,7 @@ public final class MessageBytes implements Cloneable, Serializable {
         return true;
     }
 
-    
+
     /**
      * Returns true if the message bytes starts with the specified string.
      * @param s the string
@@ -378,9 +387,13 @@ public final class MessageBytes implements Cloneable, Serializable {
     public boolean startsWithIgnoreCase(String s, int pos) {
         switch (type) {
         case T_STR:
-            if( strValue==null ) return false;
-            if( strValue.length() < pos + s.length() ) return false;
-            
+            if( strValue==null ) {
+                return false;
+            }
+            if( strValue.length() < pos + s.length() ) {
+                return false;
+            }
+
             for( int i=0; i<s.length(); i++ ) {
                 if( Ascii.toLower( s.charAt( i ) ) !=
                     Ascii.toLower( strValue.charAt( pos + i ))) {
@@ -401,16 +414,18 @@ public final class MessageBytes implements Cloneable, Serializable {
     // -------------------- Hash code  --------------------
     @Override
     public  int hashCode() {
-        if( hasHashCode ) return hashCode;
+        if( hasHashCode ) {
+            return hashCode;
+        }
         int code = 0;
 
-        code=hash(); 
+        code=hash();
         hashCode=code;
         hasHashCode=true;
         return code;
     }
 
-    // normal hash. 
+    // normal hash.
     private int hash() {
         int code=0;
         switch (type) {
@@ -439,20 +454,20 @@ public final class MessageBytes implements Cloneable, Serializable {
         toString();
         return strValue.indexOf( s, starting );
     }
-    
+
     // Inefficient initial implementation. Will be replaced on the next
     // round of tune-up
     public int indexOf(String s) {
         return indexOf( s, 0 );
     }
-    
+
     public int indexOfIgnoreCase(String s, int starting) {
         toString();
         String upper=strValue.toUpperCase(Locale.ENGLISH);
         String sU=s.toUpperCase(Locale.ENGLISH);
         return upper.indexOf( sU, starting );
     }
-    
+
     /**
      * Returns true if the message bytes starts with the specified string.
      * @param c the character
@@ -505,7 +520,7 @@ public final class MessageBytes implements Cloneable, Serializable {
     private boolean hasIntValue=false;
     private long longValue;
     private boolean hasLongValue=false;
-    
+
     /** Set the buffer to the representation of an int
      */
     public void setInt(int i) {
@@ -592,12 +607,13 @@ public final class MessageBytes implements Cloneable, Serializable {
 
     // Used for headers conversion
     /** Convert the buffer to an int, cache the value
-     */ 
-    public int getInt() 
+     */
+    public int getInt()
     {
-        if( hasIntValue )
+        if( hasIntValue ) {
             return intValue;
-        
+        }
+
         switch (type) {
         case T_BYTES:
             intValue=byteC.getInt();
@@ -611,11 +627,12 @@ public final class MessageBytes implements Cloneable, Serializable {
 
     // Used for headers conversion
     /** Convert the buffer to an long, cache the value
-     */ 
+     */
     public long getLong() {
-        if( hasLongValue )
+        if( hasLongValue ) {
             return longValue;
-        
+        }
+
         switch (type) {
         case T_BYTES:
             longValue=byteC.getLong();
@@ -630,13 +647,13 @@ public final class MessageBytes implements Cloneable, Serializable {
      }
 
     // -------------------- Future may be different --------------------
-    
+
     private static MessageBytesFactory factory=new MessageBytesFactory();
 
     public static void setFactory( MessageBytesFactory mbf ) {
         factory=mbf;
     }
-    
+
     public static class MessageBytesFactory {
         protected MessageBytesFactory() {
         }

==================================================
UDecoder.java
index 23cd270b61..0c2bcbb74f 100644
--- a/java/org/apache/tomcat/util/buf/StringCache.java
+++ b/java/org/apache/tomcat/util/buf/StringCache.java
@@ -14,7 +14,6 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
 package org.apache.tomcat.util.buf;
 
 import java.util.ArrayList;
@@ -32,33 +31,33 @@ public class StringCache {
 
     private static final org.apache.juli.logging.Log log=
         org.apache.juli.logging.LogFactory.getLog( StringCache.class );
-    
-    
+
+
     // ------------------------------------------------------- Static Variables
 
-    
+
     /**
      * Enabled ?
      */
     protected static boolean byteEnabled = ("true".equals(System.getProperty(
             "tomcat.util.buf.StringCache.byte.enabled", "false")));
 
-    
+
     protected static boolean charEnabled = ("true".equals(System.getProperty(
             "tomcat.util.buf.StringCache.char.enabled", "false")));
 
-    
+
     protected static int trainThreshold = Integer.parseInt(System.getProperty(
             "tomcat.util.buf.StringCache.trainThreshold", "20000"));
-    
+
 
     protected static int cacheSize = Integer.parseInt(System.getProperty(
             "tomcat.util.buf.StringCache.cacheSize", "200"));
-    
+
 
     protected static int maxStringSize = Integer.parseInt(System.getProperty(
             "tomcat.util.buf.StringCache.maxStringSize", "128"));
-    
+
 
    /**
      * Statistics hash map for byte chunk.
@@ -66,18 +65,18 @@ public class StringCache {
     protected static HashMap<ByteEntry,int[]> bcStats =
         new HashMap<ByteEntry,int[]>(cacheSize);
 
-    
+
     /**
      * toString count for byte chunk.
      */
     protected static int bcCount = 0;
-    
-    
+
+
     /**
      * Cache for byte chunk.
      */
     protected static ByteEntry[] bcCache = null;
-    
+
 
     /**
      * Statistics hash map for char chunk.
@@ -89,38 +88,38 @@ public class StringCache {
     /**
      * toString count for char chunk.
      */
-    protected static int ccCount = 0; 
-    
+    protected static int ccCount = 0;
+
 
     /**
      * Cache for char chunk.
      */
     protected static CharEntry[] ccCache = null;
 
-    
+
     /**
      * Access count.
      */
     protected static int accessCount = 0;
-    
+
 
     /**
      * Hit count.
      */
     protected static int hitCount = 0;
-    
+
 
     // ------------------------------------------------------------ Properties
 
-    
+
     /**
      * @return Returns the cacheSize.
      */
     public int getCacheSize() {
         return cacheSize;
     }
-    
-    
+
+
     /**
      * @param cacheSize The cacheSize to set.
      */
@@ -128,47 +127,47 @@ public class StringCache {
         StringCache.cacheSize = cacheSize;
     }
 
-    
+
     /**
      * @return Returns the enabled.
      */
     public boolean getByteEnabled() {
         return byteEnabled;
     }
-    
-    
+
+
     /**
      * @param byteEnabled The enabled to set.
      */
     public void setByteEnabled(boolean byteEnabled) {
         StringCache.byteEnabled = byteEnabled;
     }
-    
-    
+
+
     /**
      * @return Returns the enabled.
      */
     public boolean getCharEnabled() {
         return charEnabled;
     }
-    
-    
+
+
     /**
      * @param charEnabled The enabled to set.
      */
     public void setCharEnabled(boolean charEnabled) {
         StringCache.charEnabled = charEnabled;
     }
-    
-    
+
+
     /**
      * @return Returns the trainThreshold.
      */
     public int getTrainThreshold() {
         return trainThreshold;
     }
-    
-    
+
+
     /**
      * @param trainThreshold The trainThreshold to set.
      */
@@ -176,15 +175,15 @@ public class StringCache {
         StringCache.trainThreshold = trainThreshold;
     }
 
-    
+
     /**
      * @return Returns the accessCount.
      */
     public int getAccessCount() {
         return accessCount;
     }
-    
-    
+
+
     /**
      * @return Returns the hitCount.
      */
@@ -192,10 +191,10 @@ public class StringCache {
         return hitCount;
     }
 
-    
+
     // -------------------------------------------------- Public Static Methods
 
-    
+
     public void reset() {
         hitCount = 0;
         accessCount = 0;
@@ -208,8 +207,8 @@ public class StringCache {
             ccCount = 0;
         }
     }
-    
-    
+
+
     public static String toString(ByteChunk bc) {
 
         // If the cache is null, then either caching is disabled, or we're
@@ -300,7 +299,7 @@ public class StringCache {
                                     0, end - start);
                             // Set encoding
                             entry.enc = bc.getEncoding();
-                            // Initialize occurrence count to one 
+                            // Initialize occurrence count to one
                             count = new int[1];
                             count[0] = 1;
                             // Set in the stats hash map
@@ -323,12 +322,12 @@ public class StringCache {
             hitCount++;
             return result;
         }
-        
+
     }
 
 
     public static String toString(CharChunk cc) {
-        
+
         // If the cache is null, then either caching is disabled, or we're
         // still training
         if (ccCache == null) {
@@ -415,7 +414,7 @@ public class StringCache {
                             entry.name = new char[cc.getLength()];
                             System.arraycopy(cc.getBuffer(), start, entry.name,
                                     0, end - start);
-                            // Initialize occurrence count to one 
+                            // Initialize occurrence count to one
                             count = new int[1];
                             count[0] = 1;
                             // Set in the stats hash map
@@ -438,10 +437,10 @@ public class StringCache {
             hitCount++;
             return result;
         }
-        
+
     }
-    
-    
+
+
     // ----------------------------------------------------- Protected Methods
 
 
@@ -477,7 +476,7 @@ public class StringCache {
         return result;
     }
 
-    
+
     /**
      * Find an entry given its name in the cache and return the associated
      * String.
@@ -492,7 +491,7 @@ public class StringCache {
         }
     }
 
-    
+
     /**
      * Find an entry given its name in a sorted array of map elements.
      * This will return the index for the closest inferior or equal item in the
@@ -508,10 +507,10 @@ public class StringCache {
         if (b == -1) {
             return -1;
         }
-        
+
         if (compare(name, array[0].name) < 0) {
             return -1;
-        }         
+        }
         if (b == 0) {
             return 0;
         }
@@ -572,7 +571,7 @@ public class StringCache {
         return result;
     }
 
-    
+
     /**
      * Find an entry given its name in the cache and return the associated
      * String.
@@ -586,7 +585,7 @@ public class StringCache {
         }
     }
 
-    
+
     /**
      * Find an entry given its name in a sorted array of map elements.
      * This will return the index for the closest inferior or equal item in the
@@ -602,10 +601,10 @@ public class StringCache {
         if (b == -1) {
             return -1;
         }
-        
+
         if (compare(name, array[0].name) < 0 ) {
             return -1;
-        }         
+        }
         if (b == 0) {
             return 0;
         }
@@ -658,7 +657,7 @@ public class StringCache {
             }
             return false;
         }
-        
+
     }
 
 
@@ -685,7 +684,7 @@ public class StringCache {
             }
             return false;
         }
-        
+
     }
 
 

==================================================
UEncoder.java
index 381125c4e8..455e644eb7 100644
--- a/java/org/apache/tomcat/util/buf/UDecoder.java
+++ b/java/org/apache/tomcat/util/buf/UDecoder.java
@@ -14,26 +14,25 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
 package org.apache.tomcat.util.buf;
 
 import java.io.CharConversionException;
 import java.io.IOException;
 
-/** 
+/**
  *  All URL decoding happens here. This way we can reuse, review, optimize
  *  without adding complexity to the buffers.
  *
  *  The conversion will modify the original buffer.
- * 
+ *
  *  @author Costin Manolache
  */
 public final class UDecoder {
-    
-    protected static final boolean ALLOW_ENCODED_SLASH = 
+
+    protected static final boolean ALLOW_ENCODED_SLASH =
         Boolean.valueOf(System.getProperty("org.apache.tomcat.util.buf.UDecoder.ALLOW_ENCODED_SLASH", "false")).booleanValue();
 
-    public UDecoder() 
+    public UDecoder()
     {
     }
 
@@ -57,18 +56,23 @@ public final class UDecoder {
 
         int idx= ByteChunk.indexOf( buff, start, end, '%' );
         int idx2=-1;
-        if( query )
+        if( query ) {
             idx2= ByteChunk.indexOf( buff, start, end, '+' );
+        }
         if( idx<0 && idx2<0 ) {
             return;
         }
 
         // idx will be the smallest positive indexes ( first % or + )
-        if( idx2 >= 0 && idx2 < idx ) idx=idx2;
-        if( idx < 0 ) idx=idx2;
+        if( idx2 >= 0 && idx2 < idx ) {
+            idx=idx2;
+        }
+        if( idx < 0 ) {
+            idx=idx2;
+        }
 
         boolean noSlash = !(ALLOW_ENCODED_SLASH || query);
-    
+
         for( int j=idx; j<end; j++, idx++ ) {
             if( buff[ j ] == '+' && query) {
                 buff[idx]= (byte)' ' ;
@@ -81,9 +85,10 @@ public final class UDecoder {
                 }
                 byte b1= buff[j+1];
                 byte b2=buff[j+2];
-                if( !isHexDigit( b1 ) || ! isHexDigit(b2 ))
+                if( !isHexDigit( b1 ) || ! isHexDigit(b2 )) {
                     throw new CharConversionException( "isHexDigit");
-                
+                }
+
                 j+=2;
                 int res=x2c( b1, b2 );
                 if (noSlash && (res == '/')) {
@@ -94,7 +99,7 @@ public final class UDecoder {
         }
 
         mb.setEnd( idx );
-        
+
         return;
     }
 
@@ -122,14 +127,19 @@ public final class UDecoder {
 
         int idx= CharChunk.indexOf( buff, start, cend, '%' );
         int idx2=-1;
-        if( query )
+        if( query ) {
             idx2= CharChunk.indexOf( buff, start, cend, '+' );
+        }
         if( idx<0 && idx2<0 ) {
             return;
         }
-        
-        if( idx2 >= 0 && idx2 < idx ) idx=idx2; 
-        if( idx < 0 ) idx=idx2;
+
+        if( idx2 >= 0 && idx2 < idx ) {
+            idx=idx2;
+        }
+        if( idx < 0 ) {
+            idx=idx2;
+        }
 
         for( int j=idx; j<cend; j++, idx++ ) {
             if( buff[ j ] == '+' && query ) {
@@ -144,9 +154,10 @@ public final class UDecoder {
                 }
                 char b1= buff[j+1];
                 char b2=buff[j+2];
-                if( !isHexDigit( b1 ) || ! isHexDigit(b2 ))
+                if( !isHexDigit( b1 ) || ! isHexDigit(b2 )) {
                     throw new CharConversionException("isHexDigit");
-                
+                }
+
                 j+=2;
                 int res=x2c( b1, b2 );
                 buff[idx]=(char)res;
@@ -169,11 +180,13 @@ public final class UDecoder {
     public void convert(MessageBytes mb, boolean query)
         throws IOException
     {
-        
+
         switch (mb.getType()) {
         case MessageBytes.T_STR:
             String strValue=mb.toString();
-            if( strValue==null ) return;
+            if( strValue==null ) {
+                return;
+            }
             mb.setString( convert( strValue, query ));
             break;
         case MessageBytes.T_CHARS:
@@ -188,7 +201,7 @@ public final class UDecoder {
     }
 
     // XXX Old code, needs to be replaced !!!!
-    // 
+    //
     public final String convert(String str)
     {
         return convert(str, true);
@@ -196,11 +209,14 @@ public final class UDecoder {
 
     public final String convert(String str, boolean query)
     {
-        if (str == null)  return  null;
-        
-        if( (!query || str.indexOf( '+' ) < 0) && str.indexOf( '%' ) < 0 )
+        if (str == null) {
+            return  null;
+        }
+
+        if( (!query || str.indexOf( '+' ) < 0) && str.indexOf( '%' ) < 0 ) {
             return str;
-        
+        }
+
         StringBuilder dec = new StringBuilder();    // decoded string output
         int strPos = 0;
         int strLen = str.length();
@@ -254,7 +270,7 @@ public final class UDecoder {
                  ( c>='a' && c<='f' ) ||
                  ( c>='A' && c<='F' ));
     }
-    
+
     private static int x2c( byte b1, byte b2 ) {
         int digit= (b1>='A') ? ( (b1 & 0xDF)-'A') + 10 :
             (b1 -'0');

==================================================
ContentType.java
index ba30b7f32f..7989951e1f 100644
--- a/java/org/apache/tomcat/util/buf/UEncoder.java
+++ b/java/org/apache/tomcat/util/buf/UEncoder.java
@@ -14,7 +14,6 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
 package org.apache.tomcat.util.buf;
 
 import java.io.CharArrayWriter;
@@ -26,7 +25,7 @@ import java.util.BitSet;
  *  This class is not thread safe - you need one encoder per thread.
  *  The encoder will save and recycle the internal objects, avoiding
  *  garbage.
- * 
+ *
  *  You can add extra characters that you want preserved, for example
  *  while encoding a URL you can add "/".
  *
@@ -36,7 +35,7 @@ public final class UEncoder {
 
     private static final org.apache.juli.logging.Log log=
         org.apache.juli.logging.LogFactory.getLog(UEncoder.class );
-    
+
     // Not static - the set may differ ( it's better than adding
     // an extra check for "/", "+", etc
     private BitSet safeChars=null;
@@ -44,7 +43,7 @@ public final class UEncoder {
     private ByteChunk bb=null;
 
     private String encoding="UTF8";
-    
+
     public UEncoder() {
         initSafeChars();
     }
@@ -74,22 +73,25 @@ public final class UEncoder {
         for (int i = 0; i < s.length(); i++) {
             int c = s.charAt(i);
             if( safeChars.get( c ) ) {
-                if(log.isDebugEnabled())
+                if(log.isDebugEnabled()) {
                     log.debug("Encoder: Safe: " + (char)c);
+                }
                 buf.write((char)c);
             } else {
-                if(log.isDebugEnabled())
+                if(log.isDebugEnabled()) {
                     log.debug("Encoder: Unsafe:  " + (char)c);
+                }
                 c2b.convert( (char)c );
-                
+
                 // "surrogate" - UTF is _not_ 16 bit, but 21 !!!!
                 // ( while UCS is 31 ). Amazing...
                 if (c >= 0xD800 && c <= 0xDBFF) {
                     if ( (i+1) < s.length()) {
                         int d = s.charAt(i+1);
                         if (d >= 0xDC00 && d <= 0xDFFF) {
-                            if(log.isDebugEnabled())
+                            if(log.isDebugEnabled()) {
                                 log.debug("Encoder: Unsafe:  " + c);
+                            }
                             c2b.convert( (char)d);
                             i++;
                         }
@@ -97,7 +99,7 @@ public final class UEncoder {
                 }
 
                 c2b.flushBuffer();
-                
+
                 urlEncode( buf, bb.getBuffer(), bb.getOffset(),
                            bb.getLength() );
                 bb.recycle();
@@ -112,16 +114,18 @@ public final class UEncoder {
         for( int j=off; j< len; j++ ) {
             buf.write( '%' );
             char ch = Character.forDigit((bytes[j] >> 4) & 0xF, 16);
-            if(log.isDebugEnabled())
+            if(log.isDebugEnabled()) {
                 log.debug("Encoder: Encode:  " + ch);
+            }
             buf.write(ch);
             ch = Character.forDigit(bytes[j] & 0xF, 16);
-            if(log.isDebugEnabled())
+            if(log.isDebugEnabled()) {
                 log.debug("Encoder: Encode:  " + ch);
+            }
             buf.write(ch);
         }
     }
-    
+
     /**
      * Utility function to re-encode the URL.
      * Still has problems with charset, since UEncoder mostly
@@ -138,10 +142,10 @@ public final class UEncoder {
         }
         return outUri;
     }
-    
+
 
     // -------------------- Internal implementation --------------------
-    
+
     private void initSafeChars() {
         safeChars=new BitSet(128);
         int i;

==================================================
CookieSupport.java
index 187d503218..183b0240ba 100644
--- a/java/org/apache/tomcat/util/http/ContentType.java
+++ b/java/org/apache/tomcat/util/http/ContentType.java
@@ -14,13 +14,12 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
 package org.apache.tomcat.util.http;
 
 
 /**
  * Useful methods for Content-Type processing
- * 
+ *
  * @author James Duncan Davidson [duncan@eng.sun.com]
  * @author James Todd [gonzo@eng.sun.com]
  * @author Jason Hunter [jch@eng.sun.com]
@@ -38,19 +37,23 @@ public class ContentType {
      */
     public static String getCharsetFromContentType(String contentType) {
 
-        if (contentType == null)
+        if (contentType == null) {
             return (null);
+        }
         int start = contentType.indexOf("charset=");
-        if (start < 0)
+        if (start < 0) {
             return (null);
+        }
         String encoding = contentType.substring(start + 8);
         int end = encoding.indexOf(';');
-        if (end >= 0)
+        if (end >= 0) {
             encoding = encoding.substring(0, end);
+        }
         encoding = encoding.trim();
         if ((encoding.length() > 2) && (encoding.startsWith("\""))
-            && (encoding.endsWith("\"")))
+            && (encoding.endsWith("\""))) {
             encoding = encoding.substring(1, encoding.length() - 1);
+        }
         return (encoding.trim());
 
     }

==================================================
Cookies.java
index 6456de3606..453302ab41 100644
--- a/java/org/apache/tomcat/util/http/CookieSupport.java
+++ b/java/org/apache/tomcat/util/http/CookieSupport.java
@@ -5,17 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-
 package org.apache.tomcat.util.http;
 
 
@@ -44,7 +42,7 @@ public final class CookieSupport {
      * inclusion of / depends on the value of {@link #FWD_SLASH_IS_SEPARATOR}.
      */
     public static final boolean ALLOW_HTTP_SEPARATORS_IN_V0;
-    
+
     /**
      * If set to false, we don't use the IE6/7 Max-Age/Expires work around.
      * Default is usually true. If STRICT_SERVLET_COMPLIANCE==true then default
@@ -71,7 +69,7 @@ public final class CookieSupport {
      */
     private static final char[] V0_SEPARATORS = {',', ';', ' ', '\t'};
     private static final boolean[] V0_SEPARATOR_FLAGS = new boolean[128];
-    
+
     /**
      * The list of separators that apply to version 1 cookies. This may or may
      * not include '/' depending on the setting of
@@ -79,20 +77,20 @@ public final class CookieSupport {
      */
     private static final char[] HTTP_SEPARATORS;
     private static final boolean[] HTTP_SEPARATOR_FLAGS = new boolean[128];
-    
+
     static {
         STRICT_SERVLET_COMPLIANCE = Boolean.valueOf(System.getProperty(
                 "org.apache.catalina.STRICT_SERVLET_COMPLIANCE",
                 "false")).booleanValue();
-        
+
         ALLOW_EQUALS_IN_VALUE = Boolean.valueOf(System.getProperty(
                 "org.apache.tomcat.util.http.ServerCookie.ALLOW_EQUALS_IN_VALUE",
                 "false")).booleanValue();
-        
+
         ALLOW_HTTP_SEPARATORS_IN_V0 = Boolean.valueOf(System.getProperty(
                 "org.apache.tomcat.util.http.ServerCookie.ALLOW_HTTP_SEPARATORS_IN_V0",
                 "false")).booleanValue();
-        
+
         String alwaysAddExpires = System.getProperty(
         "org.apache.tomcat.util.http.ServerCookie.ALWAYS_ADD_EXPIRES");
         if (alwaysAddExpires == null) {
@@ -101,7 +99,7 @@ public final class CookieSupport {
             ALWAYS_ADD_EXPIRES =
                 Boolean.valueOf(alwaysAddExpires).booleanValue();
         }
-        
+
         String  fwdSlashIsSeparator = System.getProperty(
                 "org.apache.tomcat.util.http.ServerCookie.FWD_SLASH_IS_SEPARATOR");
         if (fwdSlashIsSeparator == null) {
@@ -110,24 +108,24 @@ public final class CookieSupport {
             FWD_SLASH_IS_SEPARATOR =
                 Boolean.valueOf(fwdSlashIsSeparator).booleanValue();
         }
-        
+
         ALLOW_NAME_ONLY = Boolean.valueOf(System.getProperty(
                 "org.apache.tomcat.util.http.ServerCookie.ALLOW_NAME_ONLY",
                 "false")).booleanValue();
-        
+
 
         /*
-        Excluding the '/' char by default violates the RFC, but 
+        Excluding the '/' char by default violates the RFC, but
         it looks like a lot of people put '/'
-        in unquoted values: '/': ; //47 
-        '\t':9 ' ':32 '\"':34 '(':40 ')':41 ',':44 ':':58 ';':59 '<':60 
+        in unquoted values: '/': ; //47
+        '\t':9 ' ':32 '\"':34 '(':40 ')':41 ',':44 ':':58 ';':59 '<':60
         '=':61 '>':62 '?':63 '@':64 '[':91 '\\':92 ']':93 '{':123 '}':125
         */
         if (CookieSupport.FWD_SLASH_IS_SEPARATOR) {
-            HTTP_SEPARATORS = new char[] { '\t', ' ', '\"', '(', ')', ',', '/', 
+            HTTP_SEPARATORS = new char[] { '\t', ' ', '\"', '(', ')', ',', '/',
                     ':', ';', '<', '=', '>', '?', '@', '[', '\\', ']', '{', '}' };
         } else {
-            HTTP_SEPARATORS = new char[] { '\t', ' ', '\"', '(', ')', ',', 
+            HTTP_SEPARATORS = new char[] { '\t', ' ', '\"', '(', ')', ',',
                     ':', ';', '<', '=', '>', '?', '@', '[', '\\', ']', '{', '}' };
         }
         for (int i = 0; i < 128; i++) {
@@ -142,7 +140,7 @@ public final class CookieSupport {
         }
 
     }
-    
+
     // ----------------------------------------------------------------- Methods
 
     /**
@@ -159,10 +157,12 @@ public final class CookieSupport {
 
         return V0_SEPARATOR_FLAGS[c];
     }
-    
+
     public static boolean isV0Token(String value) {
-        if( value==null) return false;
-        
+        if( value==null) {
+            return false;
+        }
+
         int i = 0;
         int len = value.length();
 
@@ -170,12 +170,13 @@ public final class CookieSupport {
             i++;
             len--;
         }
-        
+
         for (; i < len; i++) {
             char c = value.charAt(i);
 
-            if (isV0Separator(c))
+            if (isV0Separator(c)) {
                 return true;
+            }
         }
         return false;
     }
@@ -198,8 +199,10 @@ public final class CookieSupport {
     }
 
     public static boolean isHttpToken(String value) {
-        if( value==null) return false;
-        
+        if( value==null) {
+            return false;
+        }
+
         int i = 0;
         int len = value.length();
 
@@ -207,18 +210,21 @@ public final class CookieSupport {
             i++;
             len--;
         }
-        
+
         for (; i < len; i++) {
             char c = value.charAt(i);
 
-            if (isHttpSeparator(c))
+            if (isHttpSeparator(c)) {
                 return true;
+            }
         }
         return false;
     }
 
     public static boolean alreadyQuoted (String value) {
-        if (value==null || value.length() < 2) return false;
+        if (value==null || value.length() < 2) {
+            return false;
+        }
         return (value.charAt(0)=='\"' && value.charAt(value.length()-1)=='\"');
     }
 

==================================================
FastHttpDateFormat.java
index 857d0fdd88..08827d67f3 100644
--- a/java/org/apache/tomcat/util/http/Cookies.java
+++ b/java/org/apache/tomcat/util/http/Cookies.java
@@ -14,7 +14,6 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
 package org.apache.tomcat.util.http;
 
 import java.io.PrintWriter;
@@ -36,9 +35,9 @@ public final class Cookies { // extends MultiMap {
 
     private static final org.apache.juli.logging.Log log=
         org.apache.juli.logging.LogFactory.getLog(Cookies.class );
-    
+
     // expected average number of cookies per request
-    public static final int INITIAL_SIZE=4; 
+    public static final int INITIAL_SIZE=4;
     ServerCookie scookies[]=new ServerCookie[INITIAL_SIZE];
     int cookieCount=0;
     boolean unprocessed=true;
@@ -61,8 +60,9 @@ public final class Cookies { // extends MultiMap {
      */
     public void recycle() {
             for( int i=0; i< cookieCount; i++ ) {
-            if( scookies[i]!=null )
+            if( scookies[i]!=null ) {
                 scookies[i].recycle();
+            }
         }
         cookieCount=0;
         unprocessed=true;
@@ -84,7 +84,7 @@ public final class Cookies { // extends MultiMap {
     }
 
     // -------------------- Indexed access --------------------
-    
+
     public ServerCookie getCookie( int idx ) {
         if( unprocessed ) {
             getCookieCount(); // will also update the cookies
@@ -112,7 +112,7 @@ public final class Cookies { // extends MultiMap {
             System.arraycopy( scookies, 0, scookiesTmp, 0, cookieCount);
             scookies=scookiesTmp;
         }
-        
+
         ServerCookie c = scookies[cookieCount];
         if( c==null ) {
             c= new ServerCookie();
@@ -123,20 +123,24 @@ public final class Cookies { // extends MultiMap {
     }
 
 
-    // code from CookieTools 
+    // code from CookieTools
 
     /** Add all Cookie found in the headers of a request.
      */
     public  void processCookies( MimeHeaders headers ) {
         if( headers==null )
+         {
             return;// nothing to process
+        }
         // process each "cookie" header
         int pos=0;
         while( pos>=0 ) {
             // Cookie2: version ? not needed
             pos=headers.findHeader( "Cookie", pos );
             // no more cookie headers headers
-            if( pos<0 ) break;
+            if( pos<0 ) {
+                break;
+            }
 
             MessageBytes cookieValue=headers.getValue( pos );
             if( cookieValue==null || cookieValue.isNull() ) {
@@ -151,8 +155,9 @@ public final class Cookies { // extends MultiMap {
                         e);
                 cookieValue.toBytes();
             }
-            if(log.isDebugEnabled())
+            if(log.isDebugEnabled()) {
                 log.debug("Cookies: Parsing b[]: " + cookieValue.toString());
+            }
             ByteChunk bc=cookieValue.getByteChunk();
             processCookieHeader( bc.getBytes(),
                                  bc.getOffset(),
@@ -175,7 +180,7 @@ public final class Cookies { // extends MultiMap {
         }
         return true;
     }
-    
+
 
     /**
      * Returns true if the byte is a whitespace character as
@@ -186,7 +191,7 @@ public final class Cookies { // extends MultiMap {
         // This switch statement is slightly slower
         // for my vm than the if statement.
         // Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_07-164)
-        /* 
+        /*
         switch (c) {
         case ' ':;
         case '\t':;
@@ -198,10 +203,11 @@ public final class Cookies { // extends MultiMap {
             return false;
         }
         */
-       if (c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == '\f')
-           return true;
-       else
-           return false;
+       if (c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == '\f') {
+        return true;
+    } else {
+        return false;
+    }
     }
 
     /**
@@ -219,7 +225,7 @@ public final class Cookies { // extends MultiMap {
         int end = bc.getEnd();
         int dest = src;
         byte[] buffer = bc.getBuffer();
-        
+
         while (src < end) {
             if (buffer[src] == '\\' && src < end && buffer[src+1]  == '"') {
                 src++;
@@ -238,7 +244,9 @@ public final class Cookies { // extends MultiMap {
      * JVK
      */
     protected final void processCookieHeader(byte bytes[], int off, int len){
-        if( len<=0 || bytes==null ) return;
+        if( len<=0 || bytes==null ) {
+            return;
+        }
         int end=off+len;
         int pos=off;
         int nameStart=0;
@@ -255,15 +263,16 @@ public final class Cookies { // extends MultiMap {
             isQuoted = false;
 
             // Skip whitespace and non-token characters (separators)
-            while (pos < end && 
+            while (pos < end &&
                    (CookieSupport.isHttpSeparator((char) bytes[pos]) &&
                            !CookieSupport.ALLOW_HTTP_SEPARATORS_IN_V0 ||
                     CookieSupport.isV0Separator((char) bytes[pos]) ||
-                    isWhiteSpace(bytes[pos]))) 
-                {pos++; } 
+                    isWhiteSpace(bytes[pos])))
+                {pos++; }
 
-            if (pos >= end)
+            if (pos >= end) {
                 return;
+            }
 
             // Detect Special cookies
             if (bytes[pos] == '$') {
@@ -271,27 +280,28 @@ public final class Cookies { // extends MultiMap {
                 pos++;
             }
 
-            // Get the cookie/attribute name. This must be a token            
-            valueEnd = valueStart = nameStart = pos; 
+            // Get the cookie/attribute name. This must be a token
+            valueEnd = valueStart = nameStart = pos;
             pos = nameEnd = getTokenEndPosition(bytes,pos,end,version,true);
 
             // Skip whitespace
-            while (pos < end && isWhiteSpace(bytes[pos])) {pos++; } 
-         
+            while (pos < end && isWhiteSpace(bytes[pos])) {pos++; }
+
 
             // Check for an '=' -- This could also be a name-only
             // cookie at the end of the cookie header, so if we
             // are past the end of the header, but we have a name
             // skip to the name-only part.
-            if (pos < (end - 1) && bytes[pos] == '=') {                
+            if (pos < (end - 1) && bytes[pos] == '=') {
 
                 // Skip whitespace
                 do {
                     pos++;
-                } while (pos < end && isWhiteSpace(bytes[pos])); 
+                } while (pos < end && isWhiteSpace(bytes[pos]));
 
-                if (pos >= end)
+                if (pos >= end) {
                     return;
+                }
 
                 // Determine what type of value this is, quoted value,
                 // token, name-only with an '=', or other (bad)
@@ -299,18 +309,19 @@ public final class Cookies { // extends MultiMap {
                 case '"': // Quoted Value
                     isQuoted = true;
                     valueStart=pos + 1; // strip "
-                    // getQuotedValue returns the position before 
+                    // getQuotedValue returns the position before
                     // at the last quote. This must be dealt with
                     // when the bytes are copied into the cookie
-                    valueEnd=getQuotedValueEndPosition(bytes, 
+                    valueEnd=getQuotedValueEndPosition(bytes,
                                                        valueStart, end);
                     // We need pos to advance
-                    pos = valueEnd; 
-                    // Handles cases where the quoted value is 
-                    // unterminated and at the end of the header, 
+                    pos = valueEnd;
+                    // Handles cases where the quoted value is
+                    // unterminated and at the end of the header,
                     // e.g. [myname="value]
-                    if (pos >= end)
+                    if (pos >= end) {
                         return;
+                    }
                     break;
                 case ';':
                 case ',':
@@ -339,15 +350,15 @@ public final class Cookies { // extends MultiMap {
                         // not valid.
                         log.info("Cookies: Invalid cookie. " +
                                 "Value not a token or quoted value");
-                        while (pos < end && bytes[pos] != ';' && 
-                               bytes[pos] != ',') 
+                        while (pos < end && bytes[pos] != ';' &&
+                               bytes[pos] != ',')
                             {pos++; }
                         pos++;
-                        // Make sure no special avpairs can be attributed to 
+                        // Make sure no special avpairs can be attributed to
                         // the previous cookie by setting the current cookie
                         // to null
                         sc = null;
-                        continue;                        
+                        continue;
                     }
                 }
             } else {
@@ -356,30 +367,30 @@ public final class Cookies { // extends MultiMap {
                 pos = nameEnd;
 
             }
-          
+
             // We should have an avpair or name-only cookie at this
             // point. Perform some basic checks to make sure we are
             // in a good state.
-  
+
             // Skip whitespace
             while (pos < end && isWhiteSpace(bytes[pos])) {pos++; }
 
 
             // Make sure that after the cookie we have a separator. This
             // is only important if this is not the last cookie pair
-            while (pos < end && bytes[pos] != ';' && bytes[pos] != ',') { 
+            while (pos < end && bytes[pos] != ';' && bytes[pos] != ',') {
                 pos++;
             }
-            
+
             pos++;
 
-            // All checks passed. Add the cookie, start with the 
+            // All checks passed. Add the cookie, start with the
             // special avpairs first
             if (isSpecial) {
                 isSpecial = false;
                 // $Version must be the first avpair in the cookie header
                 // (sc must be null)
-                if (equals( "Version", bytes, nameStart, nameEnd) && 
+                if (equals( "Version", bytes, nameStart, nameEnd) &&
                     sc == null) {
                     // Set version
                     if( bytes[valueStart] =='1' && valueEnd == (valueStart+1)) {
@@ -388,8 +399,8 @@ public final class Cookies { // extends MultiMap {
                         // unknown version (Versioning is not very strict)
                     }
                     continue;
-                } 
-                
+                }
+
                 // We need an active cookie for Path/Port/etc.
                 if (sc == null) {
                     continue;
@@ -401,22 +412,22 @@ public final class Cookies { // extends MultiMap {
                                            valueStart,
                                            valueEnd-valueStart);
                     continue;
-                } 
+                }
 
                 if (equals( "Path", bytes, nameStart, nameEnd)) {
                     sc.getPath().setBytes( bytes,
                                            valueStart,
                                            valueEnd-valueStart);
                     continue;
-                } 
+                }
 
                 // v2 cookie attributes - skip them
                 if (equals( "Port", bytes, nameStart, nameEnd)) {
                     continue;
-                } 
+                }
                 if (equals( "CommentURL", bytes, nameStart, nameEnd)) {
                     continue;
-                } 
+                }
 
                 // Unknown cookie, complain
                 log.info("Cookies: Unknown Special Cookie");
@@ -431,7 +442,7 @@ public final class Cookies { // extends MultiMap {
                 sc.setVersion( version );
                 sc.getName().setBytes( bytes, nameStart,
                                        nameEnd-nameStart);
-                
+
                 if (valueStart != -1) { // Normal AVPair
                     sc.getValue().setBytes( bytes, valueStart,
                             valueEnd-valueStart);
@@ -441,7 +452,7 @@ public final class Cookies { // extends MultiMap {
                     }
                 } else {
                     // Name Only
-                    sc.getValue().setString(""); 
+                    sc.getValue().setString("");
                 }
                 continue;
             }
@@ -466,13 +477,14 @@ public final class Cookies { // extends MultiMap {
                          CookieSupport.ALLOW_EQUALS_IN_VALUE)) {
             pos++;
         }
-        
-        if (pos > end)
+
+        if (pos > end) {
             return end;
+        }
         return pos;
     }
 
-    /** 
+    /**
      * Given a starting position after an initial quote character, this gets
      * the position of the end quote. This escapes anything after a '\' char
      * JVK RFC 2616
@@ -481,7 +493,7 @@ public final class Cookies { // extends MultiMap {
         int pos = off;
         while (pos < end) {
             if (bytes[pos] == '"') {
-                return pos;                
+                return pos;
             } else if (bytes[pos] == '\\' && pos < (end - 1)) {
                 pos+=2;
             } else {

==================================================
HttpMessages.java
index fa16d32fd3..0626ec2478 100644
--- a/java/org/apache/tomcat/util/http/FastHttpDateFormat.java
+++ b/java/org/apache/tomcat/util/http/FastHttpDateFormat.java
@@ -14,7 +14,6 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
 package org.apache.tomcat.util.http;
 
 import java.text.DateFormat;
@@ -27,7 +26,7 @@ import java.util.concurrent.ConcurrentHashMap;
 
 /**
  * Utility class to generate HTTP dates.
- * 
+ *
  * @author Remy Maucherat
  */
 public final class FastHttpDateFormat {
@@ -36,14 +35,14 @@ public final class FastHttpDateFormat {
     // -------------------------------------------------------------- Variables
 
 
-    private static final int CACHE_SIZE = 
+    private static final int CACHE_SIZE =
         Integer.parseInt(System.getProperty("org.apache.tomcat.util.http.FastHttpDateFormat.CACHE_SIZE", "1000"));
 
-    
+
     /**
      * HTTP date format.
      */
-    private static final SimpleDateFormat format = 
+    private static final SimpleDateFormat format =
         new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
 
 
@@ -89,14 +88,14 @@ public final class FastHttpDateFormat {
     /**
      * Formatter cache.
      */
-    private static final ConcurrentHashMap<Long, String> formatCache = 
+    private static final ConcurrentHashMap<Long, String> formatCache =
         new ConcurrentHashMap<Long, String>(CACHE_SIZE);
 
 
     /**
      * Parser cache.
      */
-    private static final ConcurrentHashMap<String, Long> parseCache = 
+    private static final ConcurrentHashMap<String, Long> parseCache =
         new ConcurrentHashMap<String, Long>(CACHE_SIZE);
 
 
@@ -130,8 +129,9 @@ public final class FastHttpDateFormat {
 
         Long longValue = new Long(value);
         String cachedDate = formatCache.get(longValue);
-        if (cachedDate != null)
+        if (cachedDate != null) {
             return cachedDate;
+        }
 
         String newDate = null;
         Date dateValue = new Date(value);
@@ -154,12 +154,13 @@ public final class FastHttpDateFormat {
     /**
      * Try to parse the given date as a HTTP date.
      */
-    public static final long parseDate(String value, 
+    public static final long parseDate(String value,
                                        DateFormat[] threadLocalformats) {
 
         Long cachedDate = parseCache.get(value);
-        if (cachedDate != null)
+        if (cachedDate != null) {
             return cachedDate.longValue();
+        }
 
         Long date = null;
         if (threadLocalformats != null) {

==================================================
MimeHeaders.java
index 8abb5c15ae..105af7d4c9 100644
--- a/java/org/apache/tomcat/util/http/HttpMessages.java
+++ b/java/org/apache/tomcat/util/http/HttpMessages.java
@@ -14,14 +14,13 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
 package org.apache.tomcat.util.http;
 
 import org.apache.tomcat.util.res.StringManager;
 
 /**
  * Handle (internationalized) HTTP messages.
- * 
+ *
  * @author James Duncan Davidson [duncan@eng.sun.com]
  * @author James Todd [gonzo@eng.sun.com]
  * @author Jason Hunter [jch@eng.sun.com]
@@ -32,12 +31,12 @@ public class HttpMessages {
     // XXX move message resources in this package
     protected static final StringManager sm =
         StringManager.getManager("org.apache.tomcat.util.http.res");
-        
+
     static String st_200=null;
     static String st_302=null;
     static String st_400=null;
     static String st_404=null;
-    
+
     /** Get the status string associated with a status code.
      *  No I18N - return the messages defined in the HTTP spec.
      *  ( the user isn't supposed to see them, this is the last
@@ -48,21 +47,29 @@ public class HttpMessages {
      */
     public static String getMessage( int status ) {
         // method from Response.
-        
+
         // Does HTTP requires/allow international messages or
         // are pre-defined? The user doesn't see them most of the time
         switch( status ) {
         case 200:
-            if( st_200==null ) st_200=sm.getString( "sc.200");
+            if( st_200==null ) {
+                st_200=sm.getString( "sc.200");
+            }
             return st_200;
         case 302:
-            if( st_302==null ) st_302=sm.getString( "sc.302");
+            if( st_302==null ) {
+                st_302=sm.getString( "sc.302");
+            }
             return st_302;
         case 400:
-            if( st_400==null ) st_400=sm.getString( "sc.400");
+            if( st_400==null ) {
+                st_400=sm.getString( "sc.400");
+            }
             return st_400;
         case 404:
-            if( st_404==null ) st_404=sm.getString( "sc.404");
+            if( st_404==null ) {
+                st_404=sm.getString( "sc.404");
+            }
             return st_404;
         }
         return sm.getString("sc."+ status);
@@ -77,8 +84,9 @@ public class HttpMessages {
      */
     public static String filter(String message) {
 
-        if (message == null)
+        if (message == null) {
             return (null);
+        }
 
         char content[] = new char[message.length()];
         message.getChars(0, message.length(), content, 0);
@@ -107,7 +115,7 @@ public class HttpMessages {
     /**
      * Is the provided message safe to use in an HTTP header. Safe messages must
      * meet the requirements of RFC2616 - i.e. must consist only of TEXT.
-     * 
+     *
      * @param msg   The message to test
      * @return      <code>true</code> if the message is safe to use in an HTTP
      *              header else <code>false</code>

==================================================
Parameters.java
index 917daab659..8d2373f552 100644
--- a/java/org/apache/tomcat/util/http/MimeHeaders.java
+++ b/java/org/apache/tomcat/util/http/MimeHeaders.java
@@ -14,7 +14,6 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
 package org.apache.tomcat.util.http;
 
 import java.io.PrintWriter;
@@ -53,16 +52,16 @@ import org.apache.tomcat.util.buf.MessageBytes;
    directly access all headers, and most headers are single-valued.
    ( the alternative - a hash or similar data structure - will add
    an overhead that is not needed in most cases )
-   
+
    Apache seems to be using a similar method for storing and manipulating
    headers.
-       
+
    Future enhancements:
    - hash the headers the first time a header is requested ( i.e. if the
    servlet needs direct access to headers).
    - scan "common" values ( length, cookies, etc ) during the parse
    ( addHeader hook )
-   
+
 */
 
 
@@ -83,8 +82,8 @@ import org.apache.tomcat.util.buf.MessageBytes;
  *  XXX remove unused methods
  *  XXX External enumerations, with 0 GC.
  *  XXX use HeaderName ID
- *  
- * 
+ *
+ *
  * @author dac@eng.sun.com
  * @author James Todd [gonzo@eng.sun.com]
  * @author Costin Manolache
@@ -95,7 +94,7 @@ public class MimeHeaders {
      *  XXX  make it configurable ( fine-tuning of web-apps )
      */
     public static final int DEFAULT_HEADER_SIZE=8;
-    
+
     /**
      * The header fields.
      */
@@ -154,7 +153,7 @@ public class MimeHeaders {
     }
 
     // -------------------- Idx access to headers ----------
-    
+
     /**
      * Returns the current number of header fields.
      */
@@ -182,7 +181,7 @@ public class MimeHeaders {
      */
     public int findHeader( String name, int starting ) {
         // We can use a hash - but it's not clear how much
-        // benefit you can get - there is an  overhead 
+        // benefit you can get - there is an  overhead
         // and the number of headers is small (4-5 ?)
         // Another problem is that we'll pay the overhead
         // of constructing the hashtable
@@ -195,7 +194,7 @@ public class MimeHeaders {
         }
         return -1;
     }
-    
+
     // -------------------- --------------------
 
     /**
@@ -212,7 +211,7 @@ public class MimeHeaders {
     }
 
     // -------------------- Adding headers --------------------
-    
+
 
     /**
      * Adds a partially constructed field to the header.  This
@@ -263,7 +262,7 @@ public class MimeHeaders {
         return mhf.getValue();
     }
 
-    /** Allow "set" operations - 
+    /** Allow "set" operations -
         return a MessageBytes container for the
         header value ( existing header or new
         if this .
@@ -302,7 +301,7 @@ public class MimeHeaders {
     /**
      * Finds and returns a unique header field with the given name. If no such
      * field exists, null is returned. If the specified header field is not
-     * unique then an {@link IllegalArgumentException} is thrown. 
+     * unique then an {@link IllegalArgumentException} is thrown.
      */
     public MessageBytes getUniqueValue(String name) {
         MessageBytes result = null;
@@ -348,7 +347,7 @@ public class MimeHeaders {
      */
     private void removeHeader(int idx) {
         MimeHeaderField mh = headers[idx];
-        
+
         mh.recycle();
         headers[idx] = headers[count - 1];
         headers[count - 1] = mh;
@@ -397,7 +396,7 @@ class NamesEnumerator implements Enumeration<String> {
         // next element
         pos++;
     }
-    
+
     @Override
     public boolean hasMoreElements() {
         return next!=null;
@@ -440,7 +439,7 @@ class ValuesEnumerator implements Enumeration<String> {
         }
         pos++;
     }
-    
+
     @Override
     public boolean hasMoreElements() {
         return next!=null;
@@ -459,8 +458,8 @@ class MimeHeaderField {
     // speed up name enumerations and search ( both cpu and
     // GC)
     MimeHeaderField next;
-    MimeHeaderField prev; 
-    
+    MimeHeaderField prev;
+
     protected final MessageBytes nameB = MessageBytes.newInstance();
     protected final MessageBytes valueB = MessageBytes.newInstance();
 

==================================================
ServerCookie.java
index b26b2bd890..656f965ad0 100644
--- a/java/org/apache/tomcat/util/http/Parameters.java
+++ b/java/org/apache/tomcat/util/http/Parameters.java
@@ -14,7 +14,6 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
 package org.apache.tomcat.util.http;
 
 import java.io.IOException;
@@ -28,22 +27,22 @@ import org.apache.tomcat.util.buf.MessageBytes;
 import org.apache.tomcat.util.buf.UDecoder;
 
 /**
- * 
+ *
  * @author Costin Manolache
  */
 public final class Parameters {
 
-    
+
     private static final org.apache.juli.logging.Log log=
         org.apache.juli.logging.LogFactory.getLog(Parameters.class );
-    
+
     // Transition: we'll use the same Hashtable( String->String[] )
     // for the beginning. When we are sure all accesses happen through
     // this class - we can switch to MultiMap
-    private Hashtable<String,String[]> paramHashStringArray =
+    private final Hashtable<String,String[]> paramHashStringArray =
         new Hashtable<String,String[]>();
     private boolean didQueryParameters=false;
-    
+
     MessageBytes queryMB;
 
     UDecoder urlDec;
@@ -51,7 +50,7 @@ public final class Parameters {
 
     String encoding=null;
     String queryStringEncoding=null;
-    
+
     public Parameters() {
         // NO-OP
     }
@@ -84,15 +83,17 @@ public final class Parameters {
         encoding=null;
         decodedQuery.recycle();
     }
-    
+
     // -------------------- Data access --------------------
     // Access to the current name/values, no side effect ( processing ).
     // You must explicitly call handleQueryParameters and the post methods.
-    
+
     // This is the original data representation ( hash of String->String[])
 
     public void addParameterValues( String key, String[] newValues) {
-        if ( key==null ) return;
+        if ( key==null ) {
+            return;
+        }
         String values[];
         if (paramHashStringArray.containsKey(key)) {
             String oldValues[] = paramHashStringArray.get(key);
@@ -116,7 +117,7 @@ public final class Parameters {
         String values[] = paramHashStringArray.get(name);
         return values;
     }
- 
+
     public Enumeration<String> getParameterNames() {
         handleQueryParameters();
         return paramHashStringArray.keys();
@@ -126,7 +127,9 @@ public final class Parameters {
     public String getParameter(String name ) {
         String[] values = getParameterValues(name);
         if (values != null) {
-            if( values.length==0 ) return "";
+            if( values.length==0 ) {
+                return "";
+            }
             return values[0];
         } else {
             return null;
@@ -136,13 +139,16 @@ public final class Parameters {
     /** Process the query string into parameters
      */
     public void handleQueryParameters() {
-        if( didQueryParameters ) return;
+        if( didQueryParameters ) {
+            return;
+        }
 
         didQueryParameters=true;
 
-        if( queryMB==null || queryMB.isNull() )
+        if( queryMB==null || queryMB.isNull() ) {
             return;
-        
+        }
+
         if(log.isDebugEnabled()) {
             log.debug("Decoding query " + decodedQuery + " " +
                     queryStringEncoding);
@@ -160,7 +166,9 @@ public final class Parameters {
     // incredibly inefficient data representation for parameters,
     // until we test the new one
     private void addParam( String key, String value ) {
-        if( key==null ) return;
+        if( key==null ) {
+            return;
+        }
         String values[];
         if (paramHashStringArray.containsKey(key)) {
             String oldValues[] = paramHashStringArray.get(key);
@@ -173,8 +181,8 @@ public final class Parameters {
             values = new String[1];
             values[0] = value;
         }
-        
-        
+
+
         paramHashStringArray.put(key, values);
     }
 
@@ -187,23 +195,23 @@ public final class Parameters {
     // if needed
     ByteChunk tmpName=new ByteChunk();
     ByteChunk tmpValue=new ByteChunk();
-    private ByteChunk origName=new ByteChunk();
-    private ByteChunk origValue=new ByteChunk();
+    private final ByteChunk origName=new ByteChunk();
+    private final ByteChunk origValue=new ByteChunk();
     CharChunk tmpNameC=new CharChunk(1024);
     public static final String DEFAULT_ENCODING = "ISO-8859-1";
     public static final Charset DEFAULT_CHARSET =
         Charset.forName(DEFAULT_ENCODING);
-    
-    
+
+
     public void processParameters( byte bytes[], int start, int len ) {
         processParameters(bytes, start, len, encoding);
     }
 
-    public void processParameters( byte bytes[], int start, int len, 
+    public void processParameters( byte bytes[], int start, int len,
                                    String enc ) {
         int end=start+len;
         int pos=start;
-        
+
         if(log.isDebugEnabled()) {
             log.debug("Bytes: " +
                     new String(bytes, start, len, DEFAULT_CHARSET));
@@ -213,7 +221,7 @@ public final class Parameters {
             boolean noEq=false;
             int valStart=-1;
             int valEnd=-1;
-            
+
             int nameStart=pos;
             int nameEnd=ByteChunk.indexOf(bytes, nameStart, end, '=' );
             // Workaround for a&b&c encoding
@@ -230,17 +238,20 @@ public final class Parameters {
                                         DEFAULT_CHARSET));
                 }
             }
-            if( nameEnd== -1 ) 
+            if( nameEnd== -1 ) {
                 nameEnd=end;
+            }
 
             if( ! noEq ) {
                 valStart= (nameEnd < end) ? nameEnd+1 : end;
                 valEnd=ByteChunk.indexOf(bytes, valStart, end, '&');
-                if( valEnd== -1 ) valEnd = (valStart < end) ? end : valStart;
+                if( valEnd== -1 ) {
+                    valEnd = (valStart < end) ? end : valStart;
+                }
             }
-            
+
             pos=valEnd+1;
-            
+
             if( nameEnd<=nameStart ) {
                 if (log.isInfoEnabled()) {
                     StringBuilder msg = new StringBuilder("Parameters: Invalid chunk ");
@@ -259,7 +270,7 @@ public final class Parameters {
             }
             tmpName.setBytes( bytes, nameStart, nameEnd-nameStart );
             tmpValue.setBytes( bytes, valStart, valEnd-valStart );
-            
+
             // Take copies as if anything goes wrong originals will be
             // corrupted. This means original values can be logged.
             // For performance - only done for debug
@@ -272,7 +283,7 @@ public final class Parameters {
                     log.error("Error copying parameters", ioe);
                 }
             }
-            
+
             try {
                 addParam( urlDecode(tmpName, enc), urlDecode(tmpValue, enc) );
             } catch (IOException e) {
@@ -310,7 +321,7 @@ public final class Parameters {
     private String urlDecode(ByteChunk bc, String enc)
         throws IOException {
         if( urlDec==null ) {
-            urlDec=new UDecoder();   
+            urlDec=new UDecoder();
         }
         urlDec.convert(bc);
         String result = null;
@@ -336,7 +347,9 @@ public final class Parameters {
     }
 
     public void processParameters( MessageBytes data, String encoding ) {
-        if( data==null || data.isNull() || data.getLength() <= 0 ) return;
+        if( data==null || data.isNull() || data.getLength() <= 0 ) {
+            return;
+        }
 
         if( data.getType() != MessageBytes.T_BYTES ) {
             data.toBytes();
@@ -355,8 +368,9 @@ public final class Parameters {
             String k = en.nextElement();
             sb.append( k ).append("=");
             String v[] = paramHashStringArray.get( k );
-            for( int i=0; i<v.length; i++ )
+            for( int i=0; i<v.length; i++ ) {
                 sb.append( v[i] ).append(",");
+            }
             sb.append("\n");
         }
         return sb.toString();

==================================================
