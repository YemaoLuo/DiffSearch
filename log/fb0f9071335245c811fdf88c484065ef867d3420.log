fb0f9071335245c811fdf88c484065ef867d3420
==================================================
Servlet 3 implementation.
==================================================
Mark Emlyn
==================================================
Thu Nov 12 17:29:00 2009 +0000
==================================================
Authenticator.java
index 4346530647..c0a4ee8b16 100644
--- a/TOMCAT-7-RELEASE-PLAN.txt
+++ b/TOMCAT-7-RELEASE-PLAN.txt
@@ -15,13 +15,11 @@
   limitations under the License.
 ================================================================================
 
-$Id: $
-
             =====================================================
             An outline plan for the first stable Tomcat 7 release
             =====================================================
 
-1. Update trunk with new API from Servlet Spec 3.0 PR
+1. Update trunk with new API from Servlet Spec 3.0 Final Draft 2009-11-05
    - Done
 
 2. Provide NOOP implementations with TODO SRV3 markers so it will build
@@ -36,33 +34,29 @@ $Id: $
      2.3.3.3, 2.3.3.4 - In progress
      2.3.4 - Compliant
    - Sections 3 to 6 - not checked
-   - Section 7 - in progress
-     7.1, 7.2, 7.3, 7.4, 7.5, 7.6 - Compliant
-     7.7.1 - Compliant
-     7.7.2 - When is IAE thrown?
-     7.7.3 - Compliant
+   - Section 7 - Compliant
    - Section 8 - in progress
      8.1 - not checked
-     8.2 - in progress, plan as follows
-           - modify digester to parse to new classes
-           - configure Context & Jasper from new classes
-           - fragment scanning / parsing
-           - fragment ordering
-           - web(-fragment).xml merging code
-           - annotation scanning
+     8.2 - in progress, 'just' annotation scanning left
      8.3 - not checked
-   - Sections 9 onwards - not checked
+     8.4 - not checked
+   - Sections 9 to 12 - not checked
+   - Section 13 - In progess
+     13.1 to 13.3 - Compliant
+     13.4 - In progress
+     13.5 to 13.10 - Compliant
+     Section 14 to 15 - not checked
    - Java EE spec requirements - not checked
+   - JSR 196 - Recommended - Not yet implemented. Copy from Geronimo?
 
 4. Do an alpha release (from trunk)
    - Create tc7.0.x\tags to hold release tags
-   - Create Bugzilla project
    - Add to web site
    - Update Wiki version status page
 
 5. Fix issues as they get reported
 
-6. Update for next public draft(s) of the spec if any.
+6. Update for final release of the spec
 
 7. Aim for first stable TC7 release with final release of Servlet 3 spec
    - Create tc7.0.x\trunk from trunk at first stable release

==================================================
Context.java
index 7847461fdb..e681996039 100644
--- a/java/org/apache/catalina/Authenticator.java
+++ b/java/org/apache/catalina/Authenticator.java
@@ -18,18 +18,55 @@
 
 package org.apache.catalina;
 
+import java.io.IOException;
+import java.security.Principal;
+
+import org.apache.catalina.connector.Request;
+import org.apache.catalina.connector.Response;
+import org.apache.catalina.deploy.LoginConfig;
+
 
 /**
  * An <b>Authenticator</b> is a component (usually a Valve or Container) that
- * provides some sort of authentication service.  The interface itself has no
- * functional significance,  but is used as a tagging mechanism so that other
- * components can detect the presence (via an "instanceof Authenticator" test)
- * of an already configured authentication service.
+ * provides some sort of authentication service.
  *
  * @author Craig R. McClanahan
  * @version $Revision$ $Date$
  */
 
 public interface Authenticator {
-    // No methods
+    
+    /**
+     * Authenticate the user making this request, based on the specified
+     * login configuration.  Return <code>true</code> if any specified
+     * constraint has been satisfied, or <code>false</code> if we have
+     * created a response challenge already.
+     *
+     * @param request Request we are processing
+     * @param response Response we are creating
+     * @param config    Login configuration describing how authentication
+     *              should be performed
+     *
+     * @exception IOException if an input/output error occurs
+     */
+    public boolean authenticate(Request request, Response response,
+            LoginConfig config) throws IOException;
+    
+    /**
+     * Register an authenticated Principal and authentication type in our
+     * request, in the current session (if there is one), and with our
+     * SingleSignOn valve, if there is one.  Set the appropriate cookie
+     * to be returned. Passing in a null principal will de-register any
+     * SSO sessions.
+     *
+     * @param request The servlet request we are processing
+     * @param response The servlet response we are generating
+     * @param principal The authenticated Principal to be registered
+     * @param authType The authentication type to be registered
+     * @param username Username used to authenticate (if any)
+     * @param password Password used to authenticate (if any)
+     */
+    public void register(Request request, Response response,
+            Principal principal, String authType,
+            String username, String password);
 }

==================================================
AuthenticatorBase.java
index 46852d857b..84047da801 100644
--- a/java/org/apache/catalina/Context.java
+++ b/java/org/apache/catalina/Context.java
@@ -1096,5 +1096,10 @@ public interface Context extends Container {
      */
     public void setJarScanner(JarScanner jarScanner);
 
+    /**
+     * Obtain the {@link Authenticator} that is used by this context or
+     * <code>null</code> if none is used.
+     */
+    public Authenticator getAuthenticator();
 }
 

==================================================
Request.java
index 50187cd446..909ffc1f27 100644
--- a/java/org/apache/catalina/connector/LocalStrings.properties
+++ b/java/org/apache/catalina/connector/LocalStrings.properties
@@ -61,6 +61,11 @@ coyoteRequest.attributeEvent=Exception thrown by attributes event listener
 coyoteRequest.parseParameters=Exception thrown whilst processing POSTed parameters
 coyoteRequest.postTooLarge=Parameters were not parsed because the size of the posted data was too big. Use the maxPostSize attribute of the connector to resolve this if the application should accept large POSTs.
 coyoteRequest.chunkedPostTooLarge=Parameters were not parsed because the size of the posted data was too big. Because this request was a chunked request, it could not be processed further. Use the maxPostSize attribute of the connector to resolve this if the application should accept large POSTs.
+coyoteRequest.alreadyAuthenticated=This is request has already been authenticated
+coyoteRequest.noLoginConfig=No authentication mechanism has been configured for this context
+coyoteRequest.noPasswordLogin=The authentication mechanism configured for this context does not support user name and password authentication
+coyoteRequest.authFail=The authentication of user {0} was not successful
+coyoteRequest.authenticate.ise=Cannot call authenticate() after the reponse has been committed
 
 requestFacade.nullRequest=The request object has been recycled and is no longer associated with this facade
 

==================================================
RequestFacade.java
index ed003ce011..6b3506057e 100644
--- a/java/org/apache/catalina/connector/Request.java
+++ b/java/org/apache/catalina/connector/Request.java
@@ -54,6 +54,7 @@ import javax.servlet.http.HttpServletResponse;
 import javax.servlet.http.HttpSession;
 import javax.servlet.http.Part;
 
+import org.apache.catalina.Authenticator;
 import org.apache.catalina.Context;
 import org.apache.catalina.Globals;
 import org.apache.catalina.Host;
@@ -63,6 +64,7 @@ import org.apache.catalina.Session;
 import org.apache.catalina.Wrapper;
 import org.apache.catalina.core.ApplicationSessionCookieConfig;
 import org.apache.catalina.core.AsyncContextImpl;
+import org.apache.catalina.deploy.LoginConfig;
 import org.apache.catalina.realm.GenericPrincipal;
 import org.apache.catalina.util.Enumerator;
 import org.apache.catalina.util.ParameterMap;
@@ -2307,18 +2309,70 @@ public class Request
         return requestedSessionSSL;
     }
     
-    public boolean authenticate(HttpServletResponse response) throws IOException {
-        // TODO Servlet 3 - authentication
+    /**
+     * @throws IOException If an I/O error occurs
+     * @throws IllegalStateException If the response has been committed
+     * @throws ServletException If the caller is responsible for handling the
+     *         error and the container has NOT set the HTTP response code etc.
+     */
+    public boolean authenticate(HttpServletResponse response) 
+    throws IOException, ServletException {
+        if (response.isCommitted()) {
+            throw new IllegalStateException(
+                    sm.getString("coyoteRequest.authenticate.ise"));
+        }
+
+        // TODO SERVLET 3
         return false;
     }
     
+    /**
+     * @throws ServletException If any of {@link #getRemoteUser()},
+     *         {@link #getUserPrincipal()} or {@link #getAuthType()} are
+     *         non-null, if the configured authenticator does not support
+     *         user name and password authentication or if the authentication
+     *         fails
+     */
     public void login(String username, String password)
     throws ServletException {
-        // TODO Servlet 3 - authentication
+        if (getAuthType() != null || getRemoteUser() != null ||
+                getUserPrincipal() != null) {
+            throw new ServletException(
+                    sm.getString("coyoteRequest.alreadyAuthenticated"));
+        }
+        
+        if (context.getLoginConfig() == null) {
+            throw new ServletException(
+                    sm.getString("coyoteRequest.noLoginConfig"));
+        }
+        
+        String authMethod = context.getLoginConfig().getAuthMethod();
+        if (BASIC_AUTH.equals(authMethod) || FORM_AUTH.equals(authMethod) ||
+                DIGEST_AUTH.equals(authMethod)) {
+            // Methods support user name and password authentication
+            Realm realm = context.getRealm();
+            
+            Principal principal = realm.authenticate(username, password);
+
+            if (principal == null) {
+                throw new ServletException(
+                        sm.getString("coyoteRequest.authFail", username));
+            }
+            // Assume if we have a non-null LogonConfig then we must have an
+            // authenticator
+            context.getAuthenticator().register(this, getResponse(), principal,
+                    authMethod, username, password);
+        } else {
+            throw new ServletException("coyoteRequest.noPasswordLogin");
+        }
     }
-    
+
+    /**
+     * @throws ServletException If the logout fails
+     */
     public void logout() throws ServletException {
-        // TODO Servlet 3 - authentication
+        context.getAuthenticator().register(this, getResponse(), null,
+                null, null, null);
     }
     
     public Collection<Part> getParts() {

==================================================
StandardContext.java
index b9bd19276e..476fa714a7 100644
--- a/java/org/apache/catalina/connector/RequestFacade.java
+++ b/java/org/apache/catalina/connector/RequestFacade.java
@@ -982,7 +982,8 @@ public class RequestFacade implements HttpServletRequest {
         return request.getDispatcherType();
     }
     
-    public boolean authenticate(HttpServletResponse response) throws IOException {
+    public boolean authenticate(HttpServletResponse response)
+    throws IOException, ServletException {
         return request.authenticate(response);
     }
 

==================================================
ContextConfig.java
index fbbe0cef7f..1f05e72e7b 100644
--- a/java/org/apache/catalina/core/StandardContext.java
+++ b/java/org/apache/catalina/core/StandardContext.java
@@ -57,6 +57,7 @@ import javax.servlet.ServletRequestListener;
 import javax.servlet.http.HttpSessionAttributeListener;
 import javax.servlet.http.HttpSessionListener;
 
+import org.apache.catalina.Authenticator;
 import org.apache.catalina.Container;
 import org.apache.catalina.ContainerListener;
 import org.apache.catalina.Context;
@@ -69,6 +70,8 @@ import org.apache.catalina.LifecycleException;
 import org.apache.catalina.LifecycleListener;
 import org.apache.catalina.Loader;
 import org.apache.catalina.Manager;
+import org.apache.catalina.Pipeline;
+import org.apache.catalina.Valve;
 import org.apache.catalina.Wrapper;
 import org.apache.catalina.deploy.ApplicationParameter;
 import org.apache.catalina.deploy.ErrorPage;
@@ -738,6 +741,24 @@ public class StandardContext
     // ----------------------------------------------------- Context Properties
 
 
+    public Authenticator getAuthenticator() {
+        if (this instanceof Authenticator)
+            return (Authenticator) this;
+        
+        Pipeline pipeline = getPipeline();
+        if (pipeline != null) {
+            Valve basic = pipeline.getBasic();
+            if ((basic != null) && (basic instanceof Authenticator))
+                return (Authenticator) basic;
+            Valve valves[] = pipeline.getValves();
+            for (int i = 0; i < valves.length; i++) {
+                if (valves[i] instanceof Authenticator)
+                    return (Authenticator) valves[i];
+            }
+        }
+        return null;
+    }
+    
     public JarScanner getJarScanner() {
         if (jarScanner == null) {
             jarScanner = new DefaultJarScanner();

==================================================
WebRuleSet.java
index d43ca4702b..caafda1aa7 100644
--- a/java/org/apache/catalina/startup/LocalStrings.properties
+++ b/java/org/apache/catalina/startup/LocalStrings.properties
@@ -118,6 +118,7 @@ webXml.mergeConflictDisplayName=The display name was defined in multiple fragmen
 webXml.mergeConflictErrorPage=The Error Page for [{0}] was defined inconsistently in multiple fragments including fragment with name [{1}] located at [{2}]
 webXml.mergeConflictFilter=The Filter [{0}] was defined inconsistently in multiple fragments including fragment with name [{1}] located at [{2}]
 webXml.mergeConflictLoginConfig=A LoginConfig was defined inconsistently in multiple fragments including fragment with name [{1}] located at [{2}]
+webXml.mergeConflictOrder=Fragment relative ordering contains circular references. Thsi can be resolved by using absolute ordering in web.xml.
 webXml.mergeConflictResource=The Resource [{0}] was defined inconsistently in multiple fragments including fragment with name [{1}] located at [{2}]
 webXml.mergeConflictFilter=The Servlet [{0}] was defined inconsistently in multiple fragments including fragment with name [{1}] located at [{2}]
 webXml.mergeConflictSessionTimeout=The session timeout was defined inconsistently in multiple fragments with different values including fragment with name [{0}] located at [{1}]

==================================================
WebXml.java
index 6214688480..46e1d251b7 100644
--- a/java/org/apache/catalina/startup/WebRuleSet.java
+++ b/java/org/apache/catalina/startup/WebRuleSet.java
@@ -161,11 +161,10 @@ public class WebRuleSet extends RuleSetBase {
         digester.addRule(fullPrefix,
                          new IgnoreAnnotationsRule());
 
-        digester.addCallMethod(fullPrefix + "/name",
-                "setName", 0);
-        
         if (fragment) {
             // web-fragment.xml
+            digester.addCallMethod(fullPrefix + "/name",
+                    "setName", 0);
             digester.addRule(fullPrefix + "/absolute-ordering",
                     new AbsoluteOrderingRule());
             digester.addCallMethod(fullPrefix + "/ordering/after/name",

==================================================
TestKeepAliveCount.java
index e4170efe31..f67c91755c 100644
--- a/java/org/apache/catalina/startup/WebXml.java
+++ b/java/org/apache/catalina/startup/WebXml.java
@@ -23,6 +23,8 @@ import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
+import java.util.LinkedList;
+import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
@@ -88,28 +90,31 @@ public class WebXml {
     // web-fragment.xml only elements
     // Relative ordering
     private Set<String> after = new LinkedHashSet<String>();
-    public void addAfterOrdering(String fragmentName) {
+    public void addAfterOrder(String fragmentName) {
         after.add(fragmentName);
     }
-    public void addAfterOrderingOthers() {
+    public void addAfterOrderOthers() {
         if (before.contains(ORDER_OTHERS)) {
             throw new IllegalArgumentException(sm.getString(
                     "webXml.multipleOther"));
         }
         after.add(ORDER_OTHERS);
     }
+    public Set<String> getAfterOrder() { return after; }
+    
     private Set<String> before = new LinkedHashSet<String>();
-    public void addBeforeOrdering(String fragmentName) {
+    public void addBeforeOrder(String fragmentName) {
         before.add(fragmentName);
     }
-    public void addBeforeOrderingOthers() {
+    public void addBeforeOrderOthers() {
         if (after.contains(ORDER_OTHERS)) {
             throw new IllegalArgumentException(sm.getString(
                     "webXml.multipleOther"));
         }
         before.add(ORDER_OTHERS);
     }
-    
+    public Set<String> getBeforeOrder() { return before; }
+
     // Common elements and attributes
     
     // Required attribute of web-app element
@@ -441,6 +446,19 @@ public class WebXml {
     public void setURL(URL url) { this.uRL = url; }
     public URL getURL() { return uRL; }
     
+    
+    
+    @Override
+    public String toString() {
+        StringBuilder buf = new StringBuilder(32);
+        buf.append("Name: ");
+        buf.append(getName());
+        buf.append(", URL: ");
+        buf.append(getURL());
+        return buf.toString();
+    }
+    
+    
     /**
      * Configure a {@link Context} using the stored web.xml representation.
      *  
@@ -1004,4 +1022,115 @@ public class WebXml {
         return true;
     }
 
-}
+
+    /**
+     * Generates the sub-set of the web-fragment.xml files to be processed in
+     * the order that the fragments must be processed as per the rules in the
+     * Servlet spec.
+     * 
+     * @param application   The application web.xml file
+     * @param fragments     The map of fragment names to web fragments
+     * @return Ordered list of web-fragment.xml files to process
+     */
+    protected static Set<WebXml> orderWebFragments(WebXml application,
+            Map<String,WebXml> fragments) {
+
+        Set<WebXml> orderedFragments = new LinkedHashSet<WebXml>();
+        
+        boolean absoluteOrdering =
+            (application.getAbsoluteOrdering() != null);
+        
+        if (absoluteOrdering) {
+            // Only those fragments listed should be processed
+            Set<String> requestedOrder = application.getAbsoluteOrdering();
+            
+            for (String requestedName : requestedOrder) {
+                if (WebXml.ORDER_OTHERS.equals(requestedName)) {
+                    // Add all fragments not named explicitly at this point
+                    for (String name : fragments.keySet()) {
+                        if (!requestedOrder.contains(name)) {
+                            WebXml fragment = fragments.get(name);
+                            if (fragment != null) {
+                                orderedFragments.add(fragment);
+                            }
+                        }
+                    }
+                } else {
+                    WebXml fragment = fragments.get(requestedName);
+                    if (fragment != null) {
+                        orderedFragments.add(fragment);
+                    }
+                }
+            }
+        } else {
+            List<String> order = new LinkedList<String>();
+            // Start by adding all fragments - order doesn't matter
+            order.addAll(fragments.keySet());
+            
+            // Now go through and move elements to start/end depending on if
+            // they specify others
+            for (WebXml fragment : fragments.values()) {
+                String name = fragment.getName();
+                if (fragment.getBeforeOrder().contains(WebXml.ORDER_OTHERS)) {
+                    // Move to beginning
+                    order.remove(name);
+                    order.add(0, name);
+                } else if (fragment.getAfterOrder().contains(WebXml.ORDER_OTHERS)) {
+                    // Move to end
+                    order.remove(name);
+                    order.add(name);
+                }
+            }
+            
+            // Now apply remaining ordering
+            for (WebXml fragment : fragments.values()) {
+                String name = fragment.getName();
+                for (String before : fragment.getBeforeOrder()) {
+                    if (!before.equals(WebXml.ORDER_OTHERS) &&
+                            order.contains(before) &&
+                            order.indexOf(before) < order.indexOf(name)) {
+                        order.remove(name);
+                        order.add(order.indexOf(before), name);
+                    }
+                }
+                for (String after : fragment.getAfterOrder()) {
+                    if (!after.equals(WebXml.ORDER_OTHERS) &&
+                            order.contains(after) &&
+                            order.indexOf(after) > order.indexOf(name)) {
+                        order.remove(name);
+                        order.add(order.indexOf(after) + 1, name);
+                    }
+                }
+            }
+            
+            // Finally check ordering was applied correctly - if there are
+            // errors then that indicates circular references
+            for (WebXml fragment : fragments.values()) {
+                String name = fragment.getName();
+                for (String before : fragment.getBeforeOrder()) {
+                    if (!before.equals(WebXml.ORDER_OTHERS) &&
+                            order.contains(before) &&
+                            order.indexOf(before) < order.indexOf(name)) {
+                        throw new IllegalArgumentException(sm.getString(""));
+                    }
+                }
+                for (String after : fragment.getAfterOrder()) {
+                    if (!after.equals(WebXml.ORDER_OTHERS) &&
+                            order.contains(after) &&
+                            order.indexOf(after) > order.indexOf(name)) {
+                        throw new IllegalArgumentException();
+                    }
+                }
+            }
+            
+            // Build the ordered list
+            for (String name : order) {
+                orderedFragments.add(fragments.get(name));
+            }
+        }
+        
+        return orderedFragments;
+    }
+
+}    
+

==================================================
TestRequest.java
index 631727b8f3..97e9b9a3b5 100644
--- a/test/org/apache/catalina/connector/TestKeepAliveCount.java
+++ b/test/org/apache/catalina/connector/TestKeepAliveCount.java
@@ -120,6 +120,8 @@ public class TestKeepAliveCount extends TomcatBaseTest{
     
     private static class SimpleServlet extends HttpServlet {
 
+        private static final long serialVersionUID = 1L;
+
         @Override
         protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
             resp.setContentLength(0);

==================================================
TestContextConfig.java
index 45bb7cd46a..7b2d276b92 100644
--- a/test/org/apache/catalina/connector/TestRequest.java
+++ b/test/org/apache/catalina/connector/TestRequest.java
@@ -30,6 +30,8 @@ import org.apache.catalina.core.StandardContext;
 import org.apache.catalina.startup.SimpleHttpClient;
 import org.apache.catalina.startup.TomcatBaseTest;
 import org.apache.catalina.startup.Tomcat;
+import org.apache.catalina.startup.TestTomcat.MapRealm;
+import org.apache.tomcat.util.buf.ByteChunk;
 
 /**
  * Test case for {@link Request}. 
@@ -192,4 +194,61 @@ public class TestRequest extends TomcatBaseTest {
         }
         
     }
+
+    /**
+     * Test case for {@link Request#login(String, String)} and
+     * {@link Request#logout()}.
+     */
+    public void testLoginLogout() throws Exception{
+        // Setup Tomcat instance
+        Tomcat tomcat = getTomcatInstance();
+        
+        // Must have a real docBase - just use temp
+        StandardContext ctx = 
+            tomcat.addContext("/", System.getProperty("java.io.tmpdir"));
+        // You can customize the context by calling 
+        // its API
+        
+        Tomcat.addServlet(ctx, "servlet", new LoginLogoutServlet());
+        ctx.addServletMapping("/", "servlet");
+        
+        MapRealm realm = new MapRealm();
+        realm.addUser(LoginLogoutServlet.USER, LoginLogoutServlet.PWD);
+        ctx.setRealm(realm);
+        
+        tomcat.start();
+        
+        ByteChunk res = getUrl("http://localhost:" + getPort() + "/");
+
+        assertEquals(LoginLogoutServlet.OK, res.toString());
+    }
+    
+    private static final class LoginLogoutServlet extends HttpServlet {
+        private static final long serialVersionUID = 1L;
+        private static final String USER = "user";
+        private static final String PWD = "pwd";
+        private static final String OK = "OK";
+        
+        @Override
+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
+                throws ServletException, IOException {
+            
+            req.login(USER, PWD);
+            
+            if (!req.getRemoteUser().equals(USER))
+                throw new ServletException();
+            if (!req.getUserPrincipal().getName().equals(USER))
+                throw new ServletException();
+            
+            req.logout();
+            
+            if (req.getRemoteUser() != null)
+                throw new ServletException();
+            if (req.getUserPrincipal() != null)
+                throw new ServletException();
+            
+            resp.getWriter().write(OK);
+        }
+        
+    }
 }

==================================================
TestTomcat.java
deleted file mode 100644
index a7d85f24c1..0000000000
--- a/test/org/apache/catalina/startup/TestContextConfig.java
+++ /dev/null
@@ -1,147 +0,0 @@
-package org.apache.catalina.startup;
-
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.Set;
-
-import junit.framework.TestCase;
-
-/**
- * Test case for {@link ContextConfig}.
- */
-public class TestContextConfig extends TestCase {
-    private WebXml app;
-    private WebXml f1;
-    private WebXml f2;
-    private WebXml f3;
-    private WebXml f4;
-    private WebXml f5;
-    private Map<String,WebXml> fragments;
-
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        app = new WebXml();
-        f1 = new WebXml();
-        f1.setName("f1");
-        f2 = new WebXml();
-        f2.setName("f2");
-        f3 = new WebXml();
-        f3.setName("f3");
-        f4 = new WebXml();
-        f4.setName("f4");
-        f5 = new WebXml();
-        f5.setName("f5");
-        fragments = new HashMap<String,WebXml>();
-        fragments.put("f1",f1);
-        fragments.put("f2",f2);
-        fragments.put("f3",f3);
-        fragments.put("f4",f4);
-        fragments.put("f5",f5);
-    }
-
-
-    public void testOrderWebFragmentsAbsolute() {
-        app.addAbsoluteOrdering("f3");
-        app.addAbsoluteOrdering("f1");
-        app.addAbsoluteOrdering("f2");
-        app.addAbsoluteOrdering("f5");
-        app.addAbsoluteOrdering("f4");
-        
-        Set<WebXml> ordered = ContextConfig.orderWebFragments(app, fragments);
-        
-        Iterator<WebXml> iter = ordered.iterator();
-        assertEquals(f3,iter.next());
-        assertEquals(f1,iter.next());
-        assertEquals(f2,iter.next());
-        assertEquals(f5,iter.next());
-        assertEquals(f4,iter.next());
-        assertFalse(iter.hasNext());
-    }
-
-    public void testOrderWebFragmentsAbsolutePartial() {
-        app.addAbsoluteOrdering("f3");
-        app.addAbsoluteOrdering("f1");
-        
-        Set<WebXml> ordered = ContextConfig.orderWebFragments(app, fragments);
-        
-        Iterator<WebXml> iter = ordered.iterator();
-        assertEquals(f3,iter.next());
-        assertEquals(f1,iter.next());
-        assertFalse(iter.hasNext());
-    }
-
-    public void testOrderWebFragmentsAbsoluteOthersStart() {
-        app.addAbsoluteOrdering(WebXml.ORDER_OTHERS);
-        app.addAbsoluteOrdering("f2");
-        app.addAbsoluteOrdering("f4");
-        
-        Set<WebXml> others = new HashSet<WebXml>();
-        others.add(f1);
-        others.add(f3);
-        others.add(f5);
-        
-        Set<WebXml> ordered = ContextConfig.orderWebFragments(app, fragments);
-        
-        Iterator<WebXml> iter = ordered.iterator();
-        while (others.size() > 0) {
-            WebXml f = iter.next();
-            assertTrue(others.contains(f));
-            others.remove(f);
-        }
-        assertEquals(f2,iter.next());
-        assertEquals(f4,iter.next());
-        assertFalse(iter.hasNext());
-    }
-
-    public void testOrderWebFragmentsAbsoluteOthersMiddle() {
-        app.addAbsoluteOrdering("f2");
-        app.addAbsoluteOrdering(WebXml.ORDER_OTHERS);
-        app.addAbsoluteOrdering("f4");
-        
-        Set<WebXml> others = new HashSet<WebXml>();
-        others.add(f1);
-        others.add(f3);
-        others.add(f5);
-        
-        Set<WebXml> ordered = ContextConfig.orderWebFragments(app, fragments);
-
-        Iterator<WebXml> iter = ordered.iterator();
-        assertEquals(f2,iter.next());
-
-        while (others.size() > 0) {
-            WebXml f = iter.next();
-            assertTrue(others.contains(f));
-            others.remove(f);
-        }
-        assertEquals(f4,iter.next());
-        assertFalse(iter.hasNext());
-    }
-
-    public void testOrderWebFragmentsAbsoluteOthersEnd() {
-        app.addAbsoluteOrdering("f2");
-        app.addAbsoluteOrdering("f4");
-        app.addAbsoluteOrdering(WebXml.ORDER_OTHERS);
-        
-        Set<WebXml> others = new HashSet<WebXml>();
-        others.add(f1);
-        others.add(f3);
-        others.add(f5);
-        
-        Set<WebXml> ordered = ContextConfig.orderWebFragments(app, fragments);
-
-        Iterator<WebXml> iter = ordered.iterator();
-        assertEquals(f2,iter.next());
-        assertEquals(f4,iter.next());
-
-        while (others.size() > 0) {
-            WebXml f = iter.next();
-            assertTrue(others.contains(f));
-            others.remove(f);
-        }
-        assertFalse(iter.hasNext());
-    }
-
-}

==================================================
TestWebXml.java
index bb03800930..1a1b78ac27 100644
--- a/test/org/apache/catalina/startup/TestTomcat.java
+++ b/test/org/apache/catalina/startup/TestTomcat.java
@@ -19,6 +19,9 @@ package org.apache.catalina.startup;
 import java.io.File;
 import java.io.IOException;
 import java.net.URL;
+import java.security.Principal;
+import java.util.HashMap;
+import java.util.Map;
 
 import javax.naming.Context;
 import javax.naming.InitialContext;
@@ -29,6 +32,8 @@ import javax.servlet.http.HttpServletResponse;
 
 import org.apache.catalina.core.StandardContext;
 import org.apache.catalina.deploy.ContextEnvironment;
+import org.apache.catalina.realm.GenericPrincipal;
+import org.apache.catalina.realm.RealmBase;
 import org.apache.tomcat.util.buf.ByteChunk;
 
 public class TestTomcat extends TomcatBaseTest {
@@ -95,6 +100,34 @@ public class TestTomcat extends TomcatBaseTest {
         }
     }
     
+    /**
+     * Simple Realm that uses a configurable {@link Map} to link user names and
+     * passwords. No roles are supported at this stage.
+     */
+    public static final class MapRealm extends RealmBase {
+        private Map<String,String> users = new HashMap<String,String>();
+        
+        public void addUser(String username, String password) {
+            users.put(username, password);
+        }
+
+        @Override
+        protected String getName() {
+            return "MapRealm";
+        }
+
+        @Override
+        protected String getPassword(String username) {
+            return users.get(username);
+        }
+
+        @Override
+        protected Principal getPrincipal(String username) {
+            return new GenericPrincipal(username, getPassword(username));
+        }
+        
+    }
+
     /** 
      * Start tomcat with a single context and one 
      * servlet - all programmatic, no server.xml or 

==================================================
