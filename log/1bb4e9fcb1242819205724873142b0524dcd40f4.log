1bb4e9fcb1242819205724873142b0524dcd40f4
==================================================
Code clean-up. Add braces to improve clarity
==================================================
Mark Thomas
==================================================
Wed May 26 19:27:37 2021 +0100
==================================================
ClassLoaderLogManager.java
Code clean-up. Add braces to improve clarity

Again, mainly to trigger CI to test configuration changes.


==================================================
JdkLoggerFormatter.java
index 43f7e65106..42e8f1137d 100644
--- a/java/org/apache/juli/ClassLoaderLogManager.java
+++ b/java/org/apache/juli/ClassLoaderLogManager.java
@@ -449,18 +449,20 @@ public class ClassLoaderLogManager extends LogManager {
                 URL logConfig = ((URLClassLoader)classLoader).findResource("logging.properties");
 
                 if(null != logConfig) {
-                    if(Boolean.getBoolean(DEBUG_PROPERTY))
+                    if(Boolean.getBoolean(DEBUG_PROPERTY)) {
                         System.err.println(getClass().getName()
                                            + ".readConfiguration(): "
                                            + "Found logging.properties at "
                                            + logConfig);
+                    }
 
                     is = classLoader.getResourceAsStream("logging.properties");
                 } else {
-                    if(Boolean.getBoolean(DEBUG_PROPERTY))
+                    if(Boolean.getBoolean(DEBUG_PROPERTY)) {
                         System.err.println(getClass().getName()
                                            + ".readConfiguration(): "
                                            + "Found no logging.properties");
+                    }
                 }
             }
         } catch (AccessControlException ace) {

==================================================
ContextAccessController.java
index 99b9096836..d38b7d561c 100644
--- a/java/org/apache/juli/JdkLoggerFormatter.java
+++ b/java/org/apache/juli/JdkLoggerFormatter.java
@@ -56,8 +56,9 @@ public class JdkLoggerFormatter extends Formatter {
         String message=formatMessage(record);
 
 
-        if( name.indexOf('.') >= 0 )
+        if( name.indexOf('.') >= 0 ) {
             name = name.substring(name.lastIndexOf('.') + 1);
+        }
 
         // Use a string buffer for better performance
         StringBuilder buf = new StringBuilder();

==================================================
NamingContext.java
index 20f751bbdf..301d648eea 100644
--- a/java/org/apache/naming/ContextAccessController.java
+++ b/java/org/apache/naming/ContextAccessController.java
@@ -97,8 +97,9 @@ public class ContextAccessController {
      * @param token Security token
      */
     public static void setWritable(Object name, Object token) {
-        if (checkSecurityToken(name, token))
+        if (checkSecurityToken(name, token)) {
             readOnlyContexts.remove(name);
+        }
     }
 
 

==================================================
DataSourceLinkFactory.java
index 67d6284339..0535e4694c 100644
--- a/java/org/apache/naming/NamingContext.java
+++ b/java/org/apache/naming/NamingContext.java
@@ -270,11 +270,13 @@ public class NamingContext implements Context {
             return;
         }
 
-        while ((!name.isEmpty()) && (name.get(0).length() == 0))
+        while ((!name.isEmpty()) && (name.get(0).length() == 0)) {
             name = name.getSuffix(1);
-        if (name.isEmpty())
+        }
+        if (name.isEmpty()) {
             throw new NamingException
                 (sm.getString("namingContext.invalidName"));
+        }
 
         NamingEntry entry = bindings.get(name.get(0));
 
@@ -365,8 +367,9 @@ public class NamingContext implements Context {
     public NamingEnumeration<NameClassPair> list(Name name)
         throws NamingException {
         // Removing empty parts
-        while ((!name.isEmpty()) && (name.get(0).length() == 0))
+        while ((!name.isEmpty()) && (name.get(0).length() == 0)) {
             name = name.getSuffix(1);
+        }
         if (name.isEmpty()) {
             return new NamingContextEnumeration(bindings.values().iterator());
         }
@@ -419,8 +422,9 @@ public class NamingContext implements Context {
     public NamingEnumeration<Binding> listBindings(Name name)
         throws NamingException {
         // Removing empty parts
-        while ((!name.isEmpty()) && (name.get(0).length() == 0))
+        while ((!name.isEmpty()) && (name.get(0).length() == 0)) {
             name = name.getSuffix(1);
+        }
         if (name.isEmpty()) {
             return new NamingContextBindingsEnumeration(bindings.values().iterator(), this);
         }
@@ -488,11 +492,13 @@ public class NamingContext implements Context {
             return;
         }
 
-        while ((!name.isEmpty()) && (name.get(0).length() == 0))
+        while ((!name.isEmpty()) && (name.get(0).length() == 0)) {
             name = name.getSuffix(1);
-        if (name.isEmpty())
+        }
+        if (name.isEmpty()) {
             throw new NamingException
                 (sm.getString("namingContext.invalidName"));
+        }
 
         NamingEntry entry = bindings.get(name.get(0));
 
@@ -633,10 +639,12 @@ public class NamingContext implements Context {
     public NameParser getNameParser(Name name)
         throws NamingException {
 
-        while ((!name.isEmpty()) && (name.get(0).length() == 0))
+        while ((!name.isEmpty()) && (name.get(0).length() == 0)) {
             name = name.getSuffix(1);
-        if (name.isEmpty())
+        }
+        if (name.isEmpty()) {
             return nameParser;
+        }
 
         if (name.size() > 1) {
             Object obj = bindings.get(name.get(0));
@@ -819,8 +827,9 @@ public class NamingContext implements Context {
         throws NamingException {
 
         // Removing empty parts
-        while ((!name.isEmpty()) && (name.get(0).length() == 0))
+        while ((!name.isEmpty()) && (name.get(0).length() == 0)) {
             name = name.getSuffix(1);
+        }
         if (name.isEmpty()) {
             // If name is empty, a newly allocated naming context is returned
             return new NamingContext(env, this.name, bindings);
@@ -914,11 +923,13 @@ public class NamingContext implements Context {
             return;
         }
 
-        while ((!name.isEmpty()) && (name.get(0).length() == 0))
+        while ((!name.isEmpty()) && (name.get(0).length() == 0)) {
             name = name.getSuffix(1);
-        if (name.isEmpty())
+        }
+        if (name.isEmpty()) {
             throw new NamingException
                 (sm.getString("namingContext.invalidName"));
+        }
 
         NamingEntry entry = bindings.get(name.get(0));
 

==================================================
LookupFactory.java
index bd029fe756..1834670820 100644
--- a/java/org/apache/naming/factory/DataSourceLinkFactory.java
+++ b/java/org/apache/naming/factory/DataSourceLinkFactory.java
@@ -86,8 +86,9 @@ public class DataSourceLinkFactory extends ResourceLinkFactory {
                     x = (Exception) cause;
                 }
             }
-            if (x instanceof NamingException) throw (NamingException)x;
-            else {
+            if (x instanceof NamingException) {
+                throw (NamingException)x;
+            } else {
                 NamingException nx = new NamingException(x.getMessage());
                 nx.initCause(x);
                 throw nx;

==================================================
MailSessionFactory.java
index 40bbafee60..672763d11b 100644
--- a/java/org/apache/naming/factory/LookupFactory.java
+++ b/java/org/apache/naming/factory/LookupFactory.java
@@ -102,8 +102,9 @@ public class LookupFactory implements ObjectFactory {
                         try {
                             factory = (ObjectFactory) factoryClass.getConstructor().newInstance();
                         } catch (Throwable t) {
-                            if (t instanceof NamingException)
+                            if (t instanceof NamingException) {
                                 throw (NamingException) t;
+                            }
                             NamingException ex = new NamingException(
                                     sm.getString("lookupFactory.createFailed"));
                             ex.initCause(t);

==================================================
Library.java
index dde44c0946..f63dc038fb 100644
--- a/java/org/apache/naming/factory/MailSessionFactory.java
+++ b/java/org/apache/naming/factory/MailSessionFactory.java
@@ -94,8 +94,9 @@ public class MailSessionFactory implements ObjectFactory {
 
         // Return null if we cannot create an object of the requested type
         final Reference ref = (Reference) refObj;
-        if (!ref.getClassName().equals(factoryType))
+        if (!ref.getClassName().equals(factoryType)) {
             return null;
+        }
 
         // Create a new Session inside a doPrivileged block, so that JavaMail
         // can read its default properties without throwing Security

==================================================
EnumElementValue.java
index a9849d3b00..08ba582b54 100644
--- a/java/org/apache/tomcat/jni/Library.java
+++ b/java/org/apache/tomcat/jni/Library.java
@@ -208,10 +208,11 @@ public final class Library {
      */
     public static synchronized boolean initialize(String libraryName) throws Exception {
         if (_instance == null) {
-            if (libraryName == null)
+            if (libraryName == null) {
                 _instance = new Library();
-            else
+            } else {
                 _instance = new Library(libraryName);
+            }
             TCN_MAJOR_VERSION  = version(0x01);
             TCN_MINOR_VERSION  = version(0x02);
             TCN_PATCH_VERSION  = version(0x03);

==================================================
TldRuleSet.java
index d4c3171147..7e95a1eaa8 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/EnumElementValue.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/EnumElementValue.java
@@ -25,9 +25,10 @@ public class EnumElementValue extends ElementValue
 
     EnumElementValue(final int type, final int valueIdx, final ConstantPool cpool) {
         super(type, cpool);
-        if (type != ENUM_CONSTANT)
+        if (type != ENUM_CONSTANT) {
             throw new IllegalArgumentException(
                     "Only element values of type enum can be built with this ctor - type specified: " + type);
+        }
         this.valueIdx = valueIdx;
     }
 

==================================================
ContextService.java
index 5a92b1fdf6..0fb39b3ecb 100644
--- a/java/org/apache/tomcat/util/descriptor/tld/TldRuleSet.java
+++ b/java/org/apache/tomcat/util/descriptor/tld/TldRuleSet.java
@@ -392,8 +392,9 @@ public class TldRuleSet implements RuleSet {
 
         @Override
         public void body(String namespace, String name, String text) throws Exception {
-            if(null != text)
+            if(null != text) {
                 text = text.trim();
+            }
             boolean value = "true".equalsIgnoreCase(text) || "yes".equalsIgnoreCase(text);
             setter.invoke(digester.peek(), Boolean.valueOf(value));
 

==================================================
FilterMap.java
index ee597b88d2..932dd68703 100644
--- a/java/org/apache/tomcat/util/descriptor/web/ContextService.java
+++ b/java/org/apache/tomcat/util/descriptor/web/ContextService.java
@@ -177,8 +177,9 @@ public class ContextService extends ResourceBase {
     }
 
     public void addPortcomponent(String serviceendpoint, String portlink) {
-        if (portlink == null)
+        if (portlink == null) {
             portlink = "";
+        }
         this.setProperty(serviceendpoint, portlink);
     }
 

==================================================
LoginConfig.java
index a9cf68448f..22ee9fd9fd 100644
--- a/java/org/apache/tomcat/util/descriptor/web/FilterMap.java
+++ b/java/org/apache/tomcat/util/descriptor/web/FilterMap.java
@@ -171,7 +171,9 @@ public class FilterMap extends XmlEncodingBase implements Serializable {
     public int getDispatcherMapping() {
         // per the SRV.6.2.5 absence of any dispatcher elements is
         // equivalent to a REQUEST value
-        if (dispatcherMapping == NOT_SET) return REQUEST;
+        if (dispatcherMapping == NOT_SET) {
+            return REQUEST;
+        }
 
         return dispatcherMapping;
     }

==================================================
SecurityCollection.java
index afe9aa9950..61332aa913 100644
--- a/java/org/apache/tomcat/util/descriptor/web/LoginConfig.java
+++ b/java/org/apache/tomcat/util/descriptor/web/LoginConfig.java
@@ -184,31 +184,41 @@ public class LoginConfig extends XmlEncodingBase implements Serializable {
      */
     @Override
     public boolean equals(Object obj) {
-        if (this == obj)
+        if (this == obj) {
             return true;
-        if (!(obj instanceof LoginConfig))
+        }
+        if (!(obj instanceof LoginConfig)) {
             return false;
+        }
         LoginConfig other = (LoginConfig) obj;
         if (authMethod == null) {
-            if (other.authMethod != null)
+            if (other.authMethod != null) {
                 return false;
-        } else if (!authMethod.equals(other.authMethod))
+            }
+        } else if (!authMethod.equals(other.authMethod)) {
             return false;
+        }
         if (errorPage == null) {
-            if (other.errorPage != null)
+            if (other.errorPage != null) {
                 return false;
-        } else if (!errorPage.equals(other.errorPage))
+            }
+        } else if (!errorPage.equals(other.errorPage)) {
             return false;
+        }
         if (loginPage == null) {
-            if (other.loginPage != null)
+            if (other.loginPage != null) {
                 return false;
-        } else if (!loginPage.equals(other.loginPage))
+            }
+        } else if (!loginPage.equals(other.loginPage)) {
             return false;
+        }
         if (realmName == null) {
-            if (other.realmName != null)
+            if (other.realmName != null) {
                 return false;
-        } else if (!realmName.equals(other.realmName))
+            }
+        } else if (!realmName.equals(other.realmName)) {
             return false;
+        }
         return true;
     }
 

==================================================
SecurityConstraint.java
index b3a9b007f7..6cbde72970 100644
--- a/java/org/apache/tomcat/util/descriptor/web/SecurityCollection.java
+++ b/java/org/apache/tomcat/util/descriptor/web/SecurityCollection.java
@@ -172,8 +172,9 @@ public class SecurityCollection extends XmlEncodingBase implements Serializable
      */
     public void addMethod(String method) {
 
-        if (method == null)
+        if (method == null) {
             return;
+        }
         String[] results = Arrays.copyOf(methods, methods.length + 1);
         results[methods.length] = method;
         methods = results;
@@ -187,8 +188,9 @@ public class SecurityCollection extends XmlEncodingBase implements Serializable
      * @param method The method
      */
     public void addOmittedMethod(String method) {
-        if (method == null)
+        if (method == null) {
             return;
+        }
         String[] results = Arrays.copyOf(omittedMethods, omittedMethods.length + 1);
         results[omittedMethods.length] = method;
         omittedMethods = results;
@@ -203,8 +205,9 @@ public class SecurityCollection extends XmlEncodingBase implements Serializable
     }
     public void addPatternDecoded(String pattern) {
 
-        if (pattern == null)
+        if (pattern == null) {
             return;
+        }
 
         String decodedPattern = UDecoder.URLDecode(pattern, getCharset());
         String[] results = Arrays.copyOf(patterns, patterns.length + 1);
@@ -221,19 +224,22 @@ public class SecurityCollection extends XmlEncodingBase implements Serializable
      */
     public boolean findMethod(String method) {
 
-        if (methods.length == 0 && omittedMethods.length == 0)
+        if (methods.length == 0 && omittedMethods.length == 0) {
             return true;
+        }
         if (methods.length > 0) {
             for (String s : methods) {
-                if (s.equals(method))
+                if (s.equals(method)) {
                     return true;
+                }
             }
             return false;
         }
         if (omittedMethods.length > 0) {
             for (String omittedMethod : omittedMethods) {
-                if (omittedMethod.equals(method))
+                if (omittedMethod.equals(method)) {
                     return false;
+                }
             }
         }
         return true;
@@ -268,8 +274,9 @@ public class SecurityCollection extends XmlEncodingBase implements Serializable
      */
     public boolean findPattern(String pattern) {
         for (String s : patterns) {
-            if (s.equals(pattern))
+            if (s.equals(pattern)) {
                 return true;
+            }
         }
         return false;
     }
@@ -293,8 +300,9 @@ public class SecurityCollection extends XmlEncodingBase implements Serializable
      */
     public void removeMethod(String method) {
 
-        if (method == null)
+        if (method == null) {
             return;
+        }
         int n = -1;
         for (int i = 0; i < methods.length; i++) {
             if (methods[i].equals(method)) {
@@ -306,8 +314,9 @@ public class SecurityCollection extends XmlEncodingBase implements Serializable
             int j = 0;
             String results[] = new String[methods.length - 1];
             for (int i = 0; i < methods.length; i++) {
-                if (i != n)
+                if (i != n) {
                     results[j++] = methods[i];
+                }
             }
             methods = results;
         }
@@ -323,8 +332,9 @@ public class SecurityCollection extends XmlEncodingBase implements Serializable
      */
     public void removeOmittedMethod(String method) {
 
-        if (method == null)
+        if (method == null) {
             return;
+        }
         int n = -1;
         for (int i = 0; i < omittedMethods.length; i++) {
             if (omittedMethods[i].equals(method)) {
@@ -336,8 +346,9 @@ public class SecurityCollection extends XmlEncodingBase implements Serializable
             int j = 0;
             String results[] = new String[omittedMethods.length - 1];
             for (int i = 0; i < omittedMethods.length; i++) {
-                if (i != n)
+                if (i != n) {
                     results[j++] = omittedMethods[i];
+                }
             }
             omittedMethods = results;
         }
@@ -353,8 +364,9 @@ public class SecurityCollection extends XmlEncodingBase implements Serializable
      */
     public void removePattern(String pattern) {
 
-        if (pattern == null)
+        if (pattern == null) {
             return;
+        }
         int n = -1;
         for (int i = 0; i < patterns.length; i++) {
             if (patterns[i].equals(pattern)) {
@@ -366,8 +378,9 @@ public class SecurityCollection extends XmlEncodingBase implements Serializable
             int j = 0;
             String results[] = new String[patterns.length - 1];
             for (int i = 0; i < patterns.length; i++) {
-                if (i != n)
+                if (i != n) {
                     results[j++] = patterns[i];
+                }
             }
             patterns = results;
         }

==================================================
WebRuleSet.java
index 607652c67b..f7ad943138 100644
--- a/java/org/apache/tomcat/util/descriptor/web/SecurityConstraint.java
+++ b/java/org/apache/tomcat/util/descriptor/web/SecurityConstraint.java
@@ -213,8 +213,9 @@ public class SecurityConstraint extends XmlEncodingBase implements Serializable
      */
     public void setUserConstraint(String userConstraint) {
 
-        if (userConstraint != null)
+        if (userConstraint != null) {
             this.userConstraint = userConstraint;
+        }
 
     }
 
@@ -246,8 +247,9 @@ public class SecurityConstraint extends XmlEncodingBase implements Serializable
      */
     public void addAuthRole(String authRole) {
 
-        if (authRole == null)
+        if (authRole == null) {
             return;
+        }
 
         if (ROLE_ALL_ROLES.equals(authRole)) {
             allRoles = true;
@@ -283,8 +285,9 @@ public class SecurityConstraint extends XmlEncodingBase implements Serializable
      */
     public void addCollection(SecurityCollection collection) {
 
-        if (collection == null)
+        if (collection == null) {
             return;
+        }
 
         collection.setCharset(getCharset());
 
@@ -304,11 +307,13 @@ public class SecurityConstraint extends XmlEncodingBase implements Serializable
      */
     public boolean findAuthRole(String role) {
 
-        if (role == null)
+        if (role == null) {
             return false;
+        }
         for (String authRole : authRoles) {
-            if (role.equals(authRole))
+            if (role.equals(authRole)) {
                 return true;
+            }
         }
         return false;
 
@@ -335,11 +340,13 @@ public class SecurityConstraint extends XmlEncodingBase implements Serializable
      * @return the collection
      */
     public SecurityCollection findCollection(String name) {
-        if (name == null)
+        if (name == null) {
             return null;
+        }
         for (SecurityCollection collection : collections) {
-            if (name.equals(collection.getName()))
+            if (name.equals(collection.getName())) {
                 return collection;
+            }
         }
         return null;
     }
@@ -366,17 +373,20 @@ public class SecurityConstraint extends XmlEncodingBase implements Serializable
     public boolean included(String uri, String method) {
 
         // We cannot match without a valid request method
-        if (method == null)
+        if (method == null) {
             return false;
+        }
 
         // Check all of the collections included in this constraint
         for (SecurityCollection collection : collections) {
-            if (!collection.findMethod(method))
+            if (!collection.findMethod(method)) {
                 continue;
+            }
             String patterns[] = collection.findPatterns();
             for (String pattern : patterns) {
-                if (matchPattern(uri, pattern))
+                if (matchPattern(uri, pattern)) {
                     return true;
+                }
             }
         }
 
@@ -394,8 +404,9 @@ public class SecurityConstraint extends XmlEncodingBase implements Serializable
      */
     public void removeAuthRole(String authRole) {
 
-        if (authRole == null)
+        if (authRole == null) {
             return;
+        }
 
         if (ROLE_ALL_ROLES.equals(authRole)) {
             allRoles = false;
@@ -418,8 +429,9 @@ public class SecurityConstraint extends XmlEncodingBase implements Serializable
             int j = 0;
             String results[] = new String[authRoles.length - 1];
             for (int i = 0; i < authRoles.length; i++) {
-                if (i != n)
+                if (i != n) {
                     results[j++] = authRoles[i];
+                }
             }
             authRoles = results;
         }
@@ -434,8 +446,9 @@ public class SecurityConstraint extends XmlEncodingBase implements Serializable
      */
     public void removeCollection(SecurityCollection collection) {
 
-        if (collection == null)
+        if (collection == null) {
             return;
+        }
         int n = -1;
         for (int i = 0; i < collections.length; i++) {
             if (collections[i].equals(collection)) {
@@ -448,8 +461,9 @@ public class SecurityConstraint extends XmlEncodingBase implements Serializable
             SecurityCollection results[] =
                 new SecurityCollection[collections.length - 1];
             for (int i = 0; i < collections.length; i++) {
-                if (i != n)
+                if (i != n) {
                     results[j++] = collections[i];
+                }
             }
             collections = results;
         }
@@ -464,8 +478,9 @@ public class SecurityConstraint extends XmlEncodingBase implements Serializable
     public String toString() {
         StringBuilder sb = new StringBuilder("SecurityConstraint[");
         for (int i = 0; i < collections.length; i++) {
-            if (i > 0)
+            if (i > 0) {
                 sb.append(", ");
+            }
             sb.append(collections[i].getName());
         }
         sb.append(']');
@@ -488,28 +503,36 @@ public class SecurityConstraint extends XmlEncodingBase implements Serializable
     private boolean matchPattern(String path, String pattern) {
 
         // Normalize the argument strings
-        if ((path == null) || (path.length() == 0))
+        if ((path == null) || (path.length() == 0)) {
             path = "/";
-        if ((pattern == null) || (pattern.length() == 0))
+        }
+        if ((pattern == null) || (pattern.length() == 0)) {
             pattern = "/";
+        }
 
         // Check for exact match
-        if (path.equals(pattern))
+        if (path.equals(pattern)) {
             return true;
+        }
 
         // Check for path prefix matching
         if (pattern.startsWith("/") && pattern.endsWith("/*")) {
             pattern = pattern.substring(0, pattern.length() - 2);
             if (pattern.length() == 0)
+             {
                 return true;  // "/*" is the same as "/"
-            if (path.endsWith("/"))
+            }
+            if (path.endsWith("/")) {
                 path = path.substring(0, path.length() - 1);
+            }
             while (true) {
-                if (pattern.equals(path))
+                if (pattern.equals(path)) {
                     return true;
+                }
                 int slash = path.lastIndexOf('/');
-                if (slash <= 0)
+                if (slash <= 0) {
                     break;
+                }
                 path = path.substring(0, slash);
             }
             return false;
@@ -527,8 +550,9 @@ public class SecurityConstraint extends XmlEncodingBase implements Serializable
         }
 
         // Check for universal mapping
-        if (pattern.equals("/"))
+        if (pattern.equals("/")) {
             return true;
+        }
 
         return false;
 

==================================================
WebXml.java
index 6bb972f686..2472aae417 100644
--- a/java/org/apache/tomcat/util/descriptor/web/WebRuleSet.java
+++ b/java/org/apache/tomcat/util/descriptor/web/WebRuleSet.java
@@ -904,9 +904,10 @@ final class SetPublicIdRule extends Rule {
         }
 
         m.invoke(top, (Object [])paramValues);
-        if (digester.getLogger().isDebugEnabled())
+        if (digester.getLogger().isDebugEnabled()) {
             digester.getLogger().debug("" + top.getClass().getName() + "."
                                        + method + "(" + paramValues[0] + ")");
+        }
 
         StringBuilder code = digester.getGeneratedCode();
         if (code != null) {
@@ -936,8 +937,9 @@ final class ServletDefCreateRule extends Rule {
         throws Exception {
         ServletDef servletDef = new ServletDef();
         digester.push(servletDef);
-        if (digester.getLogger().isDebugEnabled())
+        if (digester.getLogger().isDebugEnabled()) {
             digester.getLogger().debug("new " + servletDef.getClass().getName());
+        }
 
         StringBuilder code = digester.getGeneratedCode();
         if (code != null) {
@@ -951,8 +953,9 @@ final class ServletDefCreateRule extends Rule {
     public void end(String namespace, String name)
         throws Exception {
         ServletDef servletDef = (ServletDef) digester.pop();
-        if (digester.getLogger().isDebugEnabled())
+        if (digester.getLogger().isDebugEnabled()) {
             digester.getLogger().debug("pop " + servletDef.getClass().getName());
+        }
 
         StringBuilder code = digester.getGeneratedCode();
         if (code != null) {

==================================================
CallMethodRule.java
index 7720fa0217..434e6302cf 100644
--- a/java/org/apache/tomcat/util/descriptor/web/WebXml.java
+++ b/java/org/apache/tomcat/util/descriptor/web/WebXml.java
@@ -1416,7 +1416,9 @@ public class WebXml extends XmlEncodingBase implements DocumentProperties.Charse
 
     private static void appendElement(StringBuilder sb, String indent,
             String elementName, Object value) {
-        if (value == null) return;
+        if (value == null) {
+            return;
+        }
         appendElement(sb, indent, elementName, value.toString());
     }
 

==================================================
Digester.java
index e744a9d99e..28176abe7f 100644
--- a/java/org/apache/tomcat/util/digester/CallMethodRule.java
+++ b/java/org/apache/tomcat/util/digester/CallMethodRule.java
@@ -319,9 +319,9 @@ public class CallMethodRule extends Rule {
             // for non-stringy param types
             Object param = parameters[i];
             // Tolerate null non-primitive values
-            if(null == param && !paramTypes[i].isPrimitive())
+            if(null == param && !paramTypes[i].isPrimitive()) {
                 paramValues[i] = null;
-            else if(param instanceof String &&
+            } else if(param instanceof String &&
                     !String.class.isAssignableFrom(paramTypes[i])) {
 
                 paramValues[i] =

==================================================
RequestUtil.java
index 9b943a58c9..b9584460d3 100644
--- a/java/org/apache/tomcat/util/digester/Digester.java
+++ b/java/org/apache/tomcat/util/digester/Digester.java
@@ -1073,8 +1073,9 @@ public class Digester extends DefaultHandler2 {
         }
         try {
             stack.pop();
-            if (stack.empty())
+            if (stack.empty()) {
                 namespaces.remove(prefix);
+            }
         } catch (EmptyStackException e) {
             throw createSAXException(sm.getString("digester.emptyStackError"));
         }

==================================================
AttributeInfo.java
index 9dfc237469..fb14030dd4 100644
--- a/java/org/apache/tomcat/util/http/RequestUtil.java
+++ b/java/org/apache/tomcat/util/http/RequestUtil.java
@@ -66,12 +66,14 @@ public class RequestUtil {
         // Create a place for the normalized path
         String normalized = path;
 
-        if (replaceBackSlash && normalized.indexOf('\\') >= 0)
+        if (replaceBackSlash && normalized.indexOf('\\') >= 0) {
             normalized = normalized.replace('\\', '/');
+        }
 
         // Add a leading "/" if necessary
-        if (!normalized.startsWith("/"))
+        if (!normalized.startsWith("/")) {
             normalized = "/" + normalized;
+        }
 
         boolean addedTrailingSlash = false;
         if (normalized.endsWith("/.") || normalized.endsWith("/..")) {

==================================================
BaseAttributeFilter.java
index 28936119a1..a2a00c4bb9 100644
--- a/java/org/apache/tomcat/util/modeler/AttributeInfo.java
+++ b/java/org/apache/tomcat/util/modeler/AttributeInfo.java
@@ -56,8 +56,9 @@ public class AttributeInfo extends FeatureInfo {
      * @return the name of the property getter method, if non-standard.
      */
     public String getGetMethod() {
-        if(getMethod == null)
+        if(getMethod == null) {
             getMethod = getMethodName(getName(), true, isIs());
+        }
         return this.getMethod;
     }
 
@@ -96,8 +97,9 @@ public class AttributeInfo extends FeatureInfo {
      * @return the name of the property setter method, if non-standard.
      */
     public String getSetMethod() {
-        if( setMethod == null )
+        if( setMethod == null ) {
             setMethod = getMethodName(getName(), false, false);
+        }
         return this.setMethod;
     }
 
@@ -149,12 +151,14 @@ public class AttributeInfo extends FeatureInfo {
     private String getMethodName(String name, boolean getter, boolean is) {
         StringBuilder sb = new StringBuilder();
         if (getter) {
-            if (is)
+            if (is) {
                 sb.append("is");
-            else
+            } else {
                 sb.append("get");
-        } else
+            }
+        } else {
             sb.append("set");
+        }
         sb.append(Character.toUpperCase(name.charAt(0)));
         sb.append(name.substring(1));
         return sb.toString();

==================================================
BaseModelMBean.java
index 0bfbb16081..11d125c1e8 100644
--- a/java/org/apache/tomcat/util/modeler/BaseAttributeFilter.java
+++ b/java/org/apache/tomcat/util/modeler/BaseAttributeFilter.java
@@ -51,8 +51,9 @@ public class BaseAttributeFilter implements NotificationFilter {
     public BaseAttributeFilter(String name) {
 
         super();
-        if (name != null)
+        if (name != null) {
             addAttribute(name);
+        }
 
     }
 
@@ -125,19 +126,23 @@ public class BaseAttributeFilter implements NotificationFilter {
     @Override
     public boolean isNotificationEnabled(Notification notification) {
 
-        if (notification == null)
+        if (notification == null) {
             return false;
-        if (!(notification instanceof AttributeChangeNotification))
+        }
+        if (!(notification instanceof AttributeChangeNotification)) {
             return false;
+        }
         AttributeChangeNotification acn =
             (AttributeChangeNotification) notification;
-        if (!AttributeChangeNotification.ATTRIBUTE_CHANGE.equals(acn.getType()))
+        if (!AttributeChangeNotification.ATTRIBUTE_CHANGE.equals(acn.getType())) {
             return false;
+        }
         synchronized (names) {
-            if (names.size() < 1)
+            if (names.size() < 1) {
                 return true;
-            else
+            } else {
                 return names.contains(acn.getAttributeName());
+            }
         }
 
     }

==================================================
BaseNotificationBroadcaster.java
index b0f5f0998f..81b62de5ac 100644
--- a/java/org/apache/tomcat/util/modeler/BaseModelMBean.java
+++ b/java/org/apache/tomcat/util/modeler/BaseModelMBean.java
@@ -155,10 +155,11 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration,
         throws AttributeNotFoundException, MBeanException,
             ReflectionException {
         // Validate the input parameters
-        if (name == null)
+        if (name == null) {
             throw new RuntimeOperationsException
                 (new IllegalArgumentException(sm.getString("baseModelMBean.nullAttributeName")),
                         sm.getString("baseModelMBean.nullAttributeName"));
+        }
 
         if( (resource instanceof DynamicMBean) &&
              ! ( resource instanceof BaseModelMBean )) {
@@ -178,17 +179,19 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration,
             }
         } catch (InvocationTargetException e) {
             Throwable t = e.getTargetException();
-            if (t == null)
+            if (t == null) {
                 t = e;
-            if (t instanceof RuntimeException)
+            }
+            if (t instanceof RuntimeException) {
                 throw new RuntimeOperationsException
                     ((RuntimeException) t, sm.getString("baseModelMBean.invokeError", name));
-            else if (t instanceof Error)
+            } else if (t instanceof Error) {
                 throw new RuntimeErrorException
                     ((Error) t, sm.getString("baseModelMBean.invokeError", name));
-            else
+            } else {
                 throw new MBeanException
                     (e, sm.getString("baseModelMBean.invokeError", name));
+            }
         } catch (Exception e) {
             throw new MBeanException
                 (e, sm.getString("baseModelMBean.invokeError", name));
@@ -209,10 +212,11 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration,
     public AttributeList getAttributes(String names[]) {
 
         // Validate the input parameters
-        if (names == null)
+        if (names == null) {
             throw new RuntimeOperationsException
                 (new IllegalArgumentException(sm.getString("baseModelMBean.nullAttributeNameList")),
                         sm.getString("baseModelMBean.nullAttributeNameList"));
+        }
 
         // Prepare our response, eating all exceptions
         AttributeList response = new AttributeList();
@@ -270,12 +274,15 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration,
         }
 
         // Validate the input parameters
-        if (name == null)
+        if (name == null) {
             throw new RuntimeOperationsException
                 (new IllegalArgumentException(sm.getString("baseModelMBean.nullMethodName")),
                         sm.getString("baseModelMBean.nullMethodName"));
+        }
 
-        if( log.isDebugEnabled()) log.debug("Invoke " + name);
+        if( log.isDebugEnabled()) {
+            log.debug("Invoke " + name);
+        }
 
         Method method= managedBean.getInvoke(name, params, signature, this, resource);
 
@@ -290,17 +297,19 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration,
         } catch (InvocationTargetException e) {
             Throwable t = e.getTargetException();
             log.error(sm.getString("baseModelMBean.invokeError", name), t );
-            if (t == null)
+            if (t == null) {
                 t = e;
-            if (t instanceof RuntimeException)
+            }
+            if (t instanceof RuntimeException) {
                 throw new RuntimeOperationsException
                     ((RuntimeException) t, sm.getString("baseModelMBean.invokeError", name));
-            else if (t instanceof Error)
+            } else if (t instanceof Error) {
                 throw new RuntimeErrorException
                     ((Error) t, sm.getString("baseModelMBean.invokeError", name));
-            else
+            } else {
                 throw new MBeanException
                     ((Exception)t, sm.getString("baseModelMBean.invokeError", name));
+            }
         } catch (Exception e) {
             log.error(sm.getString("baseModelMBean.invokeError", name), e );
             throw new MBeanException
@@ -316,27 +325,28 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration,
     static Class<?> getAttributeClass(String signature)
         throws ReflectionException
     {
-        if (signature.equals(Boolean.TYPE.getName()))
+        if (signature.equals(Boolean.TYPE.getName())) {
             return Boolean.TYPE;
-        else if (signature.equals(Byte.TYPE.getName()))
+        } else if (signature.equals(Byte.TYPE.getName())) {
             return Byte.TYPE;
-        else if (signature.equals(Character.TYPE.getName()))
+        } else if (signature.equals(Character.TYPE.getName())) {
             return Character.TYPE;
-        else if (signature.equals(Double.TYPE.getName()))
+        } else if (signature.equals(Double.TYPE.getName())) {
             return Double.TYPE;
-        else if (signature.equals(Float.TYPE.getName()))
+        } else if (signature.equals(Float.TYPE.getName())) {
             return Float.TYPE;
-        else if (signature.equals(Integer.TYPE.getName()))
+        } else if (signature.equals(Integer.TYPE.getName())) {
             return Integer.TYPE;
-        else if (signature.equals(Long.TYPE.getName()))
+        } else if (signature.equals(Long.TYPE.getName())) {
             return Long.TYPE;
-        else if (signature.equals(Short.TYPE.getName()))
+        } else if (signature.equals(Short.TYPE.getName())) {
             return Short.TYPE;
-        else {
+        } else {
             try {
                 ClassLoader cl=Thread.currentThread().getContextClassLoader();
-                if( cl!=null )
+                if( cl!=null ) {
                     return cl.loadClass(signature);
+                }
             } catch( ClassNotFoundException e ) {
             }
             try {
@@ -365,8 +375,9 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration,
         throws AttributeNotFoundException, MBeanException,
         ReflectionException
     {
-        if( log.isDebugEnabled() )
+        if( log.isDebugEnabled() ) {
             log.debug("Setting attribute " + this + " " + attribute );
+        }
 
         if( (resource instanceof DynamicMBean) &&
              ! ( resource instanceof BaseModelMBean )) {
@@ -379,18 +390,20 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration,
         }
 
         // Validate the input parameters
-        if (attribute == null)
+        if (attribute == null) {
             throw new RuntimeOperationsException
                 (new IllegalArgumentException(sm.getString("baseModelMBean.nullAttribute")),
                         sm.getString("baseModelMBean.nullAttribute"));
+        }
 
         String name = attribute.getName();
         Object value = attribute.getValue();
 
-        if (name == null)
+        if (name == null) {
             throw new RuntimeOperationsException
                 (new IllegalArgumentException(sm.getString("baseModelMBean.nullAttributeName")),
                         sm.getString("baseModelMBean.nullAttributeName"));
+        }
 
         Object oldValue=null;
         //if( getAttMap.get(name) != null )
@@ -406,17 +419,19 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration,
             }
         } catch (InvocationTargetException e) {
             Throwable t = e.getTargetException();
-            if (t == null)
+            if (t == null) {
                 t = e;
-            if (t instanceof RuntimeException)
+            }
+            if (t instanceof RuntimeException) {
                 throw new RuntimeOperationsException
                     ((RuntimeException) t, sm.getString("baseModelMBean.invokeError", name));
-            else if (t instanceof Error)
+            } else if (t instanceof Error) {
                 throw new RuntimeErrorException
                     ((Error) t, sm.getString("baseModelMBean.invokeError", name));
-            else
+            } else {
                 throw new MBeanException
                     (e, sm.getString("baseModelMBean.invokeError", name));
+            }
         } catch (Exception e) {
             log.error(sm.getString("baseModelMBean.invokeError", name) , e );
             throw new MBeanException
@@ -437,8 +452,9 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration,
 
     @Override
     public String toString() {
-        if( resource==null )
+        if( resource==null ) {
             return "BaseModelMbean[" + resourceType + "]";
+        }
         return resource.toString();
     }
 
@@ -454,8 +470,9 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration,
         AttributeList response = new AttributeList();
 
         // Validate the input parameters
-        if (attributes == null)
+        if (attributes == null) {
             return response;
+        }
 
         // Prepare and return our response, eating all exceptions
         String names[] = new String[attributes.size()];
@@ -496,10 +513,11 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration,
         throws InstanceNotFoundException, InvalidTargetObjectTypeException,
         MBeanException, RuntimeOperationsException {
 
-        if (resource == null)
+        if (resource == null) {
             throw new RuntimeOperationsException
                 (new IllegalArgumentException(sm.getString("baseModelMBean.nullResource")),
                         sm.getString("baseModelMBean.nullResource"));
+        }
 
         return resource;
 
@@ -529,10 +547,11 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration,
         throws InstanceNotFoundException,
         MBeanException, RuntimeOperationsException
     {
-        if (resource == null)
+        if (resource == null) {
             throw new RuntimeOperationsException
                 (new IllegalArgumentException(sm.getString("baseModelMBean.nullResource")),
                         sm.getString("baseModelMBean.nullResource"));
+        }
 
 //        if (!"objectreference".equalsIgnoreCase(type))
 //            throw new InvalidTargetObjectTypeException(type);
@@ -574,13 +593,16 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration,
         (NotificationListener listener, String name, Object handback)
         throws IllegalArgumentException {
 
-        if (listener == null)
+        if (listener == null) {
             throw new IllegalArgumentException(sm.getString("baseModelMBean.nullListener"));
-        if (attributeBroadcaster == null)
+        }
+        if (attributeBroadcaster == null) {
             attributeBroadcaster = new BaseNotificationBroadcaster();
+        }
 
-        if( log.isDebugEnabled() )
+        if( log.isDebugEnabled() ) {
             log.debug("addAttributeNotificationListener " + listener);
+        }
 
         BaseAttributeFilter filter = new BaseAttributeFilter(name);
         attributeBroadcaster.addNotificationListener
@@ -605,8 +627,9 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration,
         (NotificationListener listener, String name)
         throws ListenerNotFoundException {
 
-        if (listener == null)
+        if (listener == null) {
             throw new IllegalArgumentException(sm.getString("baseModelMBean.nullListener"));
+        }
 
         // FIXME - currently this removes *all* notifications for this listener
         if (attributeBroadcaster != null) {
@@ -633,14 +656,18 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration,
         (AttributeChangeNotification notification)
         throws MBeanException, RuntimeOperationsException {
 
-        if (notification == null)
+        if (notification == null) {
             throw new RuntimeOperationsException
                 (new IllegalArgumentException(sm.getString("baseModelMBean.nullNotification")),
                         sm.getString("baseModelMBean.nullNotification"));
+        }
         if (attributeBroadcaster == null)
+         {
             return; // This means there are no registered listeners
-        if( log.isDebugEnabled() )
+        }
+        if( log.isDebugEnabled() ) {
             log.debug( "AttributeChangeNotification " + notification );
+        }
         attributeBroadcaster.sendNotification(notification);
 
     }
@@ -665,12 +692,14 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration,
 
         // Calculate the class name for the change notification
         String type = null;
-        if (newValue.getValue() != null)
+        if (newValue.getValue() != null) {
             type = newValue.getValue().getClass().getName();
-        else if (oldValue.getValue() != null)
+        } else if (oldValue.getValue() != null) {
             type = oldValue.getValue().getClass().getName();
-        else
+        }
+        else {
             return;  // Old and new are both null == no change
+        }
 
         AttributeChangeNotification notification =
             new AttributeChangeNotification
@@ -698,12 +727,15 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration,
     public void sendNotification(Notification notification)
         throws MBeanException, RuntimeOperationsException {
 
-        if (notification == null)
+        if (notification == null) {
             throw new RuntimeOperationsException
                 (new IllegalArgumentException(sm.getString("baseModelMBean.nullNotification")),
                         sm.getString("baseModelMBean.nullNotification"));
+        }
         if (generalBroadcaster == null)
+         {
             return; // This means there are no registered listeners
+        }
         generalBroadcaster.sendNotification(notification);
 
     }
@@ -724,10 +756,11 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration,
     public void sendNotification(String message)
         throws MBeanException, RuntimeOperationsException {
 
-        if (message == null)
+        if (message == null) {
             throw new RuntimeOperationsException
                 (new IllegalArgumentException(sm.getString("baseModelMBean.nullMessage")),
                         sm.getString("baseModelMBean.nullMessage"));
+        }
         Notification notification = new Notification
             ("jmx.modelmbean.generic", this, 1, message);
         sendNotification(notification);
@@ -755,13 +788,17 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration,
                                         Object handback)
         throws IllegalArgumentException {
 
-        if (listener == null)
+        if (listener == null) {
             throw new IllegalArgumentException(sm.getString("baseModelMBean.nullListener"));
+        }
 
-        if( log.isDebugEnabled() ) log.debug("addNotificationListener " + listener);
+        if( log.isDebugEnabled() ) {
+            log.debug("addNotificationListener " + listener);
+        }
 
-        if (generalBroadcaster == null)
+        if (generalBroadcaster == null) {
             generalBroadcaster = new BaseNotificationBroadcaster();
+        }
         generalBroadcaster.addNotificationListener
             (listener, filter, handback);
 
@@ -769,11 +806,13 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration,
         // The normal filtering can be used.
         // The problem is that there is no other way to add attribute change listeners
         // to a model mbean ( AFAIK ). I suppose the spec should be fixed.
-        if (attributeBroadcaster == null)
+        if (attributeBroadcaster == null) {
             attributeBroadcaster = new BaseNotificationBroadcaster();
+        }
 
-        if( log.isDebugEnabled() )
+        if( log.isDebugEnabled() ) {
             log.debug("addAttributeNotificationListener " + listener);
+        }
 
         attributeBroadcaster.addNotificationListener
                 (listener, filter, handback);
@@ -839,8 +878,9 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration,
     public void removeNotificationListener(NotificationListener listener)
         throws ListenerNotFoundException {
 
-        if (listener == null)
+        if (listener == null) {
             throw new IllegalArgumentException(sm.getString("baseModelMBean.nullListener"));
+        }
 
         if (generalBroadcaster != null) {
             generalBroadcaster.removeNotificationListener(listener);
@@ -882,8 +922,9 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration,
                                   ObjectName name)
             throws Exception
     {
-        if( log.isDebugEnabled())
+        if( log.isDebugEnabled()) {
             log.debug("preRegister " + resource + " " + name );
+        }
         oname=name;
         if( resource instanceof MBeanRegistration ) {
             oname = ((MBeanRegistration)resource).preRegister(server, name );

==================================================
ManagedBean.java
index 0b82be03cb..6fbddcfb21 100644
--- a/java/org/apache/tomcat/util/modeler/BaseNotificationBroadcaster.java
+++ b/java/org/apache/tomcat/util/modeler/BaseNotificationBroadcaster.java
@@ -94,7 +94,9 @@ public class BaseNotificationBroadcaster implements NotificationBroadcaster {
                             oldFilter.clear();
                         } else {
                             if (oldNames.length != 0) {
-                                for (String newName : newNames) oldFilter.addAttribute(newName);
+                                for (String newName : newNames) {
+                                    oldFilter.addAttribute(newName);
+                                }
                             }
                         }
                         return;
@@ -150,8 +152,9 @@ public class BaseNotificationBroadcaster implements NotificationBroadcaster {
         synchronized (entries) {
             for (BaseNotificationBroadcasterEntry item : entries) {
                 if ((item.filter != null) &&
-                    (!item.filter.isNotificationEnabled(notification)))
+                    (!item.filter.isNotificationEnabled(notification))) {
                     continue;
+                }
                 item.listener.handleNotification(notification, item.handback);
             }
         }

==================================================
NotificationInfo.java
index 36084adc0a..54a610d862 100644
--- a/java/org/apache/tomcat/util/modeler/ManagedBean.java
+++ b/java/org/apache/tomcat/util/modeler/ManagedBean.java
@@ -307,8 +307,9 @@ public class ManagedBean implements java.io.Serializable {
             if( clazz==null ) {
                 try {
                     ClassLoader cl= Thread.currentThread().getContextClassLoader();
-                    if ( cl != null)
+                    if ( cl != null) {
                         clazz= cl.loadClass(getClassName());
+                    }
                 } catch (Exception e) {
                     ex=e;
                 }
@@ -333,8 +334,9 @@ public class ManagedBean implements java.io.Serializable {
 
         // Set the managed resource (if any)
         try {
-            if (instance != null)
+            if (instance != null) {
                 mbean.setManagedResource(instance, "ObjectReference");
+            }
         } catch (InstanceNotFoundException e) {
             throw e;
         }
@@ -367,21 +369,24 @@ public class ManagedBean implements java.io.Serializable {
                 AttributeInfo attrs[] = getAttributes();
                 MBeanAttributeInfo attributes[] =
                     new MBeanAttributeInfo[attrs.length];
-                for (int i = 0; i < attrs.length; i++)
+                for (int i = 0; i < attrs.length; i++) {
                     attributes[i] = attrs[i].createAttributeInfo();
+                }
 
                 OperationInfo opers[] = getOperations();
                 MBeanOperationInfo operations[] =
                     new MBeanOperationInfo[opers.length];
-                for (int i = 0; i < opers.length; i++)
+                for (int i = 0; i < opers.length; i++) {
                     operations[i] = opers[i].createOperationInfo();
+                }
 
 
                 NotificationInfo notifs[] = getNotifications();
                 MBeanNotificationInfo notifications[] =
                     new MBeanNotificationInfo[notifs.length];
-                for (int i = 0; i < notifs.length; i++)
+                for (int i = 0; i < notifs.length; i++) {
                     notifications[i] = notifs[i].createNotificationInfo();
+                }
 
 
                 // Construct and return a new ModelMBeanInfo object
@@ -431,8 +436,9 @@ public class ManagedBean implements java.io.Serializable {
 
         AttributeInfo attrInfo = attributes.get(aname);
         // Look up the actual operation to be used
-        if (attrInfo == null)
+        if (attrInfo == null) {
             throw new AttributeNotFoundException(sm.getString("managedMBean.noAttribute", aname, resource));
+        }
 
         String getMethod = attrInfo.getGetMethod();
 
@@ -505,22 +511,26 @@ public class ManagedBean implements java.io.Serializable {
 
         Method method = null;
 
-        if (params == null)
+        if (params == null) {
             params = new Object[0];
-        if (signature == null)
+        }
+        if (signature == null) {
             signature = new String[0];
-        if (params.length != signature.length)
+        }
+        if (params.length != signature.length) {
             throw new RuntimeOperationsException(
                     new IllegalArgumentException(sm.getString("managedMBean.inconsistentArguments")),
                     sm.getString("managedMBean.inconsistentArguments"));
+        }
 
         // Acquire the ModelMBeanOperationInfo information for
         // the requested operation
         OperationInfo opInfo =
                 operations.get(createOperationKey(aname, signature));
-        if (opInfo == null)
+        if (opInfo == null) {
             throw new MBeanException(new ServiceNotFoundException(sm.getString("managedMBean.noOperation", aname)),
                     sm.getString("managedMBean.noOperation", aname));
+        }
 
         // Prepare the signature required by Java reflection APIs
         // FIXME - should we use the signature from opInfo?

==================================================
OperationInfo.java
index 18f55245b2..c5c78fbfa8 100644
--- a/java/org/apache/tomcat/util/modeler/NotificationInfo.java
+++ b/java/org/apache/tomcat/util/modeler/NotificationInfo.java
@@ -117,8 +117,9 @@ public class NotificationInfo extends FeatureInfo {
     public MBeanNotificationInfo createNotificationInfo() {
 
         // Return our cached information (if any)
-        if (info != null)
+        if (info != null) {
             return info;
+        }
 
         // Create and return a new information object
         info = new MBeanNotificationInfo

==================================================
Registry.java
index 6a63870d87..c5dbdee823 100644
--- a/java/org/apache/tomcat/util/modeler/OperationInfo.java
+++ b/java/org/apache/tomcat/util/modeler/OperationInfo.java
@@ -64,10 +64,11 @@ public class OperationInfo extends FeatureInfo {
     }
 
     public void setImpact(String impact) {
-        if (impact == null)
+        if (impact == null) {
             this.impact = null;
-        else
+        } else {
             this.impact = impact.toUpperCase(Locale.ENGLISH);
+        }
     }
 
 
@@ -147,12 +148,13 @@ public class OperationInfo extends FeatureInfo {
         if (info == null) {
             // Create and return a new information object
             int impact = MBeanOperationInfo.UNKNOWN;
-            if ("ACTION".equals(getImpact()))
+            if ("ACTION".equals(getImpact())) {
                 impact = MBeanOperationInfo.ACTION;
-            else if ("ACTION_INFO".equals(getImpact()))
+            } else if ("ACTION_INFO".equals(getImpact())) {
                 impact = MBeanOperationInfo.ACTION_INFO;
-            else if ("INFO".equals(getImpact()))
+            } else if ("INFO".equals(getImpact())) {
                 impact = MBeanOperationInfo.INFO;
+            }
 
             info = new MBeanOperationInfo(getName(), getDescription(),
                                           getMBeanParameterInfo(),
@@ -165,8 +167,9 @@ public class OperationInfo extends FeatureInfo {
         ParameterInfo params[] = getSignature();
         MBeanParameterInfo parameters[] =
             new MBeanParameterInfo[params.length];
-        for (int i = 0; i < params.length; i++)
+        for (int i = 0; i < params.length; i++) {
             parameters[i] = params[i].createParameterInfo();
+        }
         return parameters;
     }
 }

==================================================
MbeansDescriptorsIntrospectionSource.java
index 514bfe0de9..7ef9ad70e4 100644
--- a/java/org/apache/tomcat/util/modeler/Registry.java
+++ b/java/org/apache/tomcat/util/modeler/Registry.java
@@ -257,8 +257,9 @@ public class Registry implements RegistryMBean, MBeanRegistration {
                 getMBeanServer().invoke(current, operation, new Object[] {}, new String[] {});
 
             } catch (Exception t) {
-                if (failFirst)
+                if (failFirst) {
                     throw t;
+                }
                 log.info(sm.getString("registry.initError"), t);
             }
         }
@@ -336,8 +337,9 @@ public class Registry implements RegistryMBean, MBeanRegistration {
     public ManagedBean findManagedBean(String name) {
         // XXX Group ?? Use Group + Type
         ManagedBean mb = descriptors.get(name);
-        if (mb == null)
+        if (mb == null) {
             mb = descriptorsByClass.get(name);
+        }
         return mb;
     }
 
@@ -716,8 +718,9 @@ public class Registry implements RegistryMBean, MBeanRegistration {
         String pkg = className;
         while (pkg.indexOf('.') > 0) {
             int lastComp = pkg.lastIndexOf('.');
-            if (lastComp <= 0)
+            if (lastComp <= 0) {
                 return;
+            }
             pkg = pkg.substring(0, lastComp);
             if (searchedPaths.get(pkg) != null) {
                 return;
@@ -728,8 +731,9 @@ public class Registry implements RegistryMBean, MBeanRegistration {
 
 
     private ModelerSource getModelerSource(String type) throws Exception {
-        if (type == null)
+        if (type == null) {
             type = "MbeansDescriptorsDigesterSource";
+        }
         if (!type.contains(".")) {
             type = "org.apache.tomcat.util.modeler.modules." + type;
         }

==================================================
AbstractEndpoint.java
index 72809e7853..40dc24f144 100644
--- a/java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsIntrospectionSource.java
+++ b/java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsIntrospectionSource.java
@@ -73,11 +73,15 @@ public class MbeansDescriptorsIntrospectionSource extends ModelerSource
     }
 
     public void execute() throws Exception {
-        if( registry==null ) registry=Registry.getRegistry(null, null);
+        if( registry==null ) {
+            registry=Registry.getRegistry(null, null);
+        }
         try {
             ManagedBean managed = createManagedBean(registry, null,
                     (Class<?>)source, type);
-            if( managed==null ) return;
+            if( managed==null ) {
+                return;
+            }
             managed.setName( type );
 
             registry.addManagedBean(managed);
@@ -315,26 +319,33 @@ public class MbeansDescriptorsIntrospectionSource extends ModelerSource
                     //ai.setGetMethodObj( gm );
                     ai.setGetMethod( gm.getName());
                     Class<?> t=gm.getReturnType();
-                    if( t!=null )
+                    if( t!=null ) {
                         ai.setType( t.getName() );
+                    }
                 }
                 Method sm = setAttMap.get(name);
                 if( sm!=null ) {
                     //ai.setSetMethodObj(sm);
                     Class<?> t = sm.getParameterTypes()[0];
-                    if( t!=null )
+                    if( t!=null ) {
                         ai.setType( t.getName());
+                    }
                     ai.setSetMethod( sm.getName());
                 }
                 ai.setDescription("Introspected attribute " + name);
-                if( log.isDebugEnabled()) log.debug("Introspected attribute " +
-                        name + " " + gm + " " + sm);
-                if( gm==null )
+                if( log.isDebugEnabled()) {
+                    log.debug("Introspected attribute " +
+                            name + " " + gm + " " + sm);
+                }
+                if( gm==null ) {
                     ai.setReadable(false);
-                if( sm==null )
+                }
+                if( sm==null ) {
                     ai.setWriteable(false);
-                if( sm!=null || gm!=null )
+                }
+                if( sm!=null || gm!=null ) {
                     mbean.addAttribute(ai);
+                }
             }
 
             // This map is populated by iterating the methods (which end up as
@@ -359,8 +370,9 @@ public class MbeansDescriptorsIntrospectionSource extends ModelerSource
                 mbean.addOperation(op);
             }
 
-            if( log.isDebugEnabled())
+            if( log.isDebugEnabled()) {
                 log.debug("Setting name: " + type );
+            }
             mbean.setName( type );
 
             return mbean;

==================================================
AprEndpoint.java
index ae5c798f57..437e1da351 100644
--- a/java/org/apache/tomcat/util/net/AbstractEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AbstractEndpoint.java
@@ -605,7 +605,9 @@ public abstract class AbstractEndpoint<S,U> {
      * is 100.
      */
     private int acceptCount = 100;
-    public void setAcceptCount(int acceptCount) { if (acceptCount > 0) this.acceptCount = acceptCount; }
+    public void setAcceptCount(int acceptCount) { if (acceptCount > 0) {
+        this.acceptCount = acceptCount;
+    } }
     public int getAcceptCount() { return acceptCount; }
 
     /**
@@ -1011,10 +1013,12 @@ public abstract class AbstractEndpoint<S,U> {
             try (java.net.Socket s = new java.net.Socket()) {
                 int stmo = 2 * 1000;
                 int utmo = 2 * 1000;
-                if (getSocketProperties().getSoTimeout() > stmo)
+                if (getSocketProperties().getSoTimeout() > stmo) {
                     stmo = getSocketProperties().getSoTimeout();
-                if (getSocketProperties().getUnlockTimeout() > utmo)
+                }
+                if (getSocketProperties().getUnlockTimeout() > utmo) {
                     utmo = getSocketProperties().getUnlockTimeout();
+                }
                 s.setSoTimeout(stmo);
                 s.setSoLinger(getSocketProperties().getSoLingerOn(),getSocketProperties().getSoLingerTime());
                 if (getLog().isDebugEnabled()) {
@@ -1324,7 +1328,9 @@ public abstract class AbstractEndpoint<S,U> {
     protected abstract Log getLog();
 
     protected LimitLatch initializeConnectionLatch() {
-        if (maxConnections==-1) return null;
+        if (maxConnections==-1) {
+            return null;
+        }
         if (connectionLimitLatch==null) {
             connectionLimitLatch = new LimitLatch(getMaxConnections());
         }
@@ -1333,18 +1339,26 @@ public abstract class AbstractEndpoint<S,U> {
 
     private void releaseConnectionLatch() {
         LimitLatch latch = connectionLimitLatch;
-        if (latch!=null) latch.releaseAll();
+        if (latch!=null) {
+            latch.releaseAll();
+        }
         connectionLimitLatch = null;
     }
 
     protected void countUpOrAwaitConnection() throws InterruptedException {
-        if (maxConnections==-1) return;
+        if (maxConnections==-1) {
+            return;
+        }
         LimitLatch latch = connectionLimitLatch;
-        if (latch!=null) latch.countUpOrAwait();
+        if (latch!=null) {
+            latch.countUpOrAwait();
+        }
     }
 
     protected long countDownConnection() {
-        if (maxConnections==-1) return -1;
+        if (maxConnections==-1) {
+            return -1;
+        }
         LimitLatch latch = connectionLimitLatch;
         if (latch!=null) {
             long result = latch.countDown();
@@ -1352,7 +1366,9 @@ public abstract class AbstractEndpoint<S,U> {
                 getLog().warn(sm.getString("endpoint.warn.incorrectConnectionCount"));
             }
             return result;
-        } else return -1;
+        } else {
+            return -1;
+        }
     }
 
 

==================================================
NioEndpoint.java
index d11d69a0b8..3682e55a73 100644
--- a/java/org/apache/tomcat/util/net/AprEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AprEndpoint.java
@@ -651,10 +651,12 @@ public class AprEndpoint extends AbstractEndpoint<Long,Long> implements SNICallB
         try {
 
             // 1: Set socket options: timeout, linger, etc
-            if (socketProperties.getSoLingerOn() && socketProperties.getSoLingerTime() >= 0)
+            if (socketProperties.getSoLingerOn() && socketProperties.getSoLingerTime() >= 0) {
                 Socket.optSet(socket, Socket.APR_SO_LINGER, socketProperties.getSoLingerTime());
-            if (socketProperties.getTcpNoDelay())
+            }
+            if (socketProperties.getTcpNoDelay()) {
                 Socket.optSet(socket, Socket.APR_TCP_NODELAY, (socketProperties.getTcpNoDelay() ? 1 : 0));
+            }
             Socket.timeoutSet(socket, socketProperties.getSoTimeout() * 1000);
 
             // 2: SSL handshake

==================================================
SSLImplementation.java
index 5d8db7572a..c50c720c4f 100644
--- a/java/org/apache/tomcat/util/net/NioEndpoint.java
+++ b/java/org/apache/tomcat/util/net/NioEndpoint.java
@@ -1683,7 +1683,9 @@ public class NioEndpoint extends AbstractJsseEndpoint<NioChannel,SocketChannel>
                     }
                 } catch (IOException x) {
                     handshake = -1;
-                    if (log.isDebugEnabled()) log.debug("Error during SSL handshake",x);
+                    if (log.isDebugEnabled()) {
+                        log.debug("Error during SSL handshake",x);
+                    }
                 } catch (CancelledKeyException ckx) {
                     handshake = -1;
                 }

==================================================
SecureNio2Channel.java
index ec385cc10a..99aa83521b 100644
--- a/java/org/apache/tomcat/util/net/SSLImplementation.java
+++ b/java/org/apache/tomcat/util/net/SSLImplementation.java
@@ -51,8 +51,9 @@ public abstract class SSLImplementation {
      */
     public static SSLImplementation getInstance(String className)
             throws ClassNotFoundException {
-        if (className == null)
+        if (className == null) {
             return new JSSEImplementation();
+        }
 
         try {
             Class<?> clazz = Class.forName(className);

==================================================
SecureNioChannel.java
index b2d94d1126..f0e4bb7636 100644
--- a/java/org/apache/tomcat/util/net/SecureNio2Channel.java
+++ b/java/org/apache/tomcat/util/net/SecureNio2Channel.java
@@ -289,8 +289,9 @@ public class SecureNio2Channel extends Nio2Channel  {
                         handshake = handshakeWrap();
                     }
                     if (handshake.getStatus() == Status.OK) {
-                        if (handshakeStatus == HandshakeStatus.NEED_TASK)
+                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {
                             handshakeStatus = tasks();
+                        }
                     } else if (handshake.getStatus() == Status.CLOSED) {
                         return -1;
                     } else {
@@ -323,8 +324,9 @@ public class SecureNio2Channel extends Nio2Channel  {
                     //perform the unwrap function
                     handshake = handshakeUnwrap();
                     if (handshake.getStatus() == Status.OK) {
-                        if (handshakeStatus == HandshakeStatus.NEED_TASK)
+                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {
                             handshakeStatus = tasks();
+                        }
                     } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {
                         if (netInBuffer.position() == netInBuffer.limit()) {
                             //clear the buffer if we have emptied it out on data
@@ -476,10 +478,18 @@ public class SecureNio2Channel extends Nio2Channel  {
      */
     public void rehandshake() throws IOException {
         //validate the network buffers are empty
-        if (netInBuffer.position() > 0 && netInBuffer.position() < netInBuffer.limit()) throw new IOException(sm.getString("channel.nio.ssl.netInputNotEmpty"));
-        if (netOutBuffer.position() > 0 && netOutBuffer.position() < netOutBuffer.limit()) throw new IOException(sm.getString("channel.nio.ssl.netOutputNotEmpty"));
-        if (!getBufHandler().isReadBufferEmpty()) throw new IOException(sm.getString("channel.nio.ssl.appInputNotEmpty"));
-        if (!getBufHandler().isWriteBufferEmpty()) throw new IOException(sm.getString("channel.nio.ssl.appOutputNotEmpty"));
+        if (netInBuffer.position() > 0 && netInBuffer.position() < netInBuffer.limit()) {
+            throw new IOException(sm.getString("channel.nio.ssl.netInputNotEmpty"));
+        }
+        if (netOutBuffer.position() > 0 && netOutBuffer.position() < netOutBuffer.limit()) {
+            throw new IOException(sm.getString("channel.nio.ssl.netOutputNotEmpty"));
+        }
+        if (!getBufHandler().isReadBufferEmpty()) {
+            throw new IOException(sm.getString("channel.nio.ssl.appInputNotEmpty"));
+        }
+        if (!getBufHandler().isWriteBufferEmpty()) {
+            throw new IOException(sm.getString("channel.nio.ssl.appOutputNotEmpty"));
+        }
 
         netOutBuffer.position(0);
         netOutBuffer.limit(0);
@@ -727,11 +737,13 @@ public class SecureNio2Channel extends Nio2Channel  {
         }
         private Integer unwrap(int nRead, long timeout, TimeUnit unit) throws ExecutionException, TimeoutException, InterruptedException {
             //are we in the middle of closing or closed?
-            if (closing || closed)
+            if (closing || closed) {
                 return Integer.valueOf(-1);
+            }
             //did we reach EOF? if so send EOF up one layer.
-            if (nRead < 0)
+            if (nRead < 0) {
                 return Integer.valueOf(-1);
+            }
             //the data read
             int read = 0;
             //the SSL engine result
@@ -886,8 +898,9 @@ public class SecureNio2Channel extends Nio2Channel  {
                     written = result.bytesConsumed();
                     netOutBuffer.flip();
                     if (result.getStatus() == Status.OK) {
-                        if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK)
+                        if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {
                             tasks();
+                        }
                     } else {
                         t = new IOException(sm.getString("channel.nio.ssl.wrapFail", result.getStatus()));
                     }
@@ -945,8 +958,9 @@ public class SecureNio2Channel extends Nio2Channel  {
                                 //we did receive some data, add it to our total
                                 read += unwrap.bytesProduced();
                                 //perform any tasks if needed
-                                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK)
+                                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {
                                     tasks();
+                                }
                                 //if we need more network data, then bail out for now.
                                 if (unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {
                                     if (read == 0) {
@@ -1057,8 +1071,9 @@ public class SecureNio2Channel extends Nio2Channel  {
                                     read -= getBufHandler().getReadBuffer().position();
                                 }
                                 //perform any tasks if needed
-                                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK)
+                                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {
                                     tasks();
+                                }
                                 //if we need more network data, then bail out for now.
                                 if (unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {
                                     if (read == 0) {

==================================================
SocketProperties.java
index 1f13338d6b..277193bc76 100644
--- a/java/org/apache/tomcat/util/net/SecureNioChannel.java
+++ b/java/org/apache/tomcat/util/net/SecureNioChannel.java
@@ -841,7 +841,9 @@ public class SecureNioChannel extends NioChannel {
         netOutBuffer.flip();
 
         if (result.getStatus() == Status.OK) {
-            if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) tasks();
+            if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {
+                tasks();
+            }
         } else {
             throw new IOException(sm.getString("channel.nio.ssl.wrapFail", result.getStatus()));
         }

==================================================
JSSESupport.java
index 37311d2d56..1cdb2c6302 100644
--- a/java/org/apache/tomcat/util/net/SocketProperties.java
+++ b/java/org/apache/tomcat/util/net/SocketProperties.java
@@ -182,27 +182,35 @@ public class SocketProperties {
 
 
     public void setProperties(Socket socket) throws SocketException{
-        if (rxBufSize != null)
+        if (rxBufSize != null) {
             socket.setReceiveBufferSize(rxBufSize.intValue());
-        if (txBufSize != null)
+        }
+        if (txBufSize != null) {
             socket.setSendBufferSize(txBufSize.intValue());
-        if (ooBInline !=null)
+        }
+        if (ooBInline !=null) {
             socket.setOOBInline(ooBInline.booleanValue());
-        if (soKeepAlive != null)
+        }
+        if (soKeepAlive != null) {
             socket.setKeepAlive(soKeepAlive.booleanValue());
+        }
         if (performanceConnectionTime != null && performanceLatency != null &&
-                performanceBandwidth != null)
+                performanceBandwidth != null) {
             socket.setPerformancePreferences(
                     performanceConnectionTime.intValue(),
                     performanceLatency.intValue(),
                     performanceBandwidth.intValue());
-        if (soReuseAddress != null)
+        }
+        if (soReuseAddress != null) {
             socket.setReuseAddress(soReuseAddress.booleanValue());
-        if (soLingerOn != null && soLingerTime != null)
+        }
+        if (soLingerOn != null && soLingerTime != null) {
             socket.setSoLinger(soLingerOn.booleanValue(),
                     soLingerTime.intValue());
-        if (soTimeout != null && soTimeout.intValue() >= 0)
+        }
+        if (soTimeout != null && soTimeout.intValue() >= 0) {
             socket.setSoTimeout(soTimeout.intValue());
+        }
         if (tcpNoDelay != null) {
             try {
                 socket.setTcpNoDelay(tcpNoDelay.booleanValue());
@@ -213,40 +221,52 @@ public class SocketProperties {
     }
 
     public void setProperties(ServerSocket socket) throws SocketException{
-        if (rxBufSize != null)
+        if (rxBufSize != null) {
             socket.setReceiveBufferSize(rxBufSize.intValue());
+        }
         if (performanceConnectionTime != null && performanceLatency != null &&
-                performanceBandwidth != null)
+                performanceBandwidth != null) {
             socket.setPerformancePreferences(
                     performanceConnectionTime.intValue(),
                     performanceLatency.intValue(),
                     performanceBandwidth.intValue());
-        if (soReuseAddress != null)
+        }
+        if (soReuseAddress != null) {
             socket.setReuseAddress(soReuseAddress.booleanValue());
-        if (soTimeout != null && soTimeout.intValue() >= 0)
+        }
+        if (soTimeout != null && soTimeout.intValue() >= 0) {
             socket.setSoTimeout(soTimeout.intValue());
+        }
     }
 
     public void setProperties(AsynchronousSocketChannel socket) throws IOException {
-        if (rxBufSize != null)
+        if (rxBufSize != null) {
             socket.setOption(StandardSocketOptions.SO_RCVBUF, rxBufSize);
-        if (txBufSize != null)
+        }
+        if (txBufSize != null) {
             socket.setOption(StandardSocketOptions.SO_SNDBUF, txBufSize);
-        if (soKeepAlive != null)
+        }
+        if (soKeepAlive != null) {
             socket.setOption(StandardSocketOptions.SO_KEEPALIVE, soKeepAlive);
-        if (soReuseAddress != null)
+        }
+        if (soReuseAddress != null) {
             socket.setOption(StandardSocketOptions.SO_REUSEADDR, soReuseAddress);
-        if (soLingerOn != null && soLingerOn.booleanValue() && soLingerTime != null)
+        }
+        if (soLingerOn != null && soLingerOn.booleanValue() && soLingerTime != null) {
             socket.setOption(StandardSocketOptions.SO_LINGER, soLingerTime);
-        if (tcpNoDelay != null)
+        }
+        if (tcpNoDelay != null) {
             socket.setOption(StandardSocketOptions.TCP_NODELAY, tcpNoDelay);
+        }
     }
 
     public void setProperties(AsynchronousServerSocketChannel socket) throws IOException {
-        if (rxBufSize != null)
+        if (rxBufSize != null) {
             socket.setOption(StandardSocketOptions.SO_RCVBUF, rxBufSize);
-        if (soReuseAddress != null)
+        }
+        if (soReuseAddress != null) {
             socket.setOption(StandardSocketOptions.SO_REUSEADDR, soReuseAddress);
+        }
     }
 
     public boolean getDirectBuffer() {

==================================================
OpenSSLContext.java
index d293137c83..3fa82c0bb4 100644
--- a/java/org/apache/tomcat/util/net/jsse/JSSESupport.java
+++ b/java/org/apache/tomcat/util/net/jsse/JSSESupport.java
@@ -85,8 +85,9 @@ public class JSSESupport implements SSLSupport, SSLSessionManager {
     @Override
     public String getCipherSuite() throws IOException {
         // Look up the current SSLSession
-        if (session == null)
+        if (session == null) {
             return null;
+        }
         return session.getCipherSuite();
     }
 
@@ -101,8 +102,9 @@ public class JSSESupport implements SSLSupport, SSLSessionManager {
     @Override
     public java.security.cert.X509Certificate[] getPeerCertificateChain() throws IOException {
         // Look up the current SSLSession
-        if (session == null)
+        if (session == null) {
             return null;
+        }
 
         Certificate [] certs=null;
         try {
@@ -117,7 +119,9 @@ public class JSSESupport implements SSLSupport, SSLSessionManager {
 
 
     private static java.security.cert.X509Certificate[] convertCertificates(Certificate[] certs) {
-        if( certs==null ) return null;
+        if( certs==null ) {
+            return null;
+        }
 
         java.security.cert.X509Certificate [] x509Certs =
             new java.security.cert.X509Certificate[certs.length];
@@ -140,11 +144,13 @@ public class JSSESupport implements SSLSupport, SSLSessionManager {
                     return null;
                 }
             }
-            if(log.isTraceEnabled())
+            if(log.isTraceEnabled()) {
                 log.trace("Cert #" + i + " = " + x509Certs[i]);
+            }
         }
-        if(x509Certs.length < 1)
+        if(x509Certs.length < 1) {
             return null;
+        }
         return x509Certs;
     }
 
@@ -168,17 +174,23 @@ public class JSSESupport implements SSLSupport, SSLSessionManager {
     public String getSessionId()
         throws IOException {
         // Look up the current SSLSession
-        if (session == null)
+        if (session == null) {
             return null;
+        }
         // Expose ssl_session (getId)
         byte [] ssl_session = session.getId();
-        if ( ssl_session == null)
+        if ( ssl_session == null) {
             return null;
+        }
         StringBuilder buf=new StringBuilder();
         for (byte b : ssl_session) {
             String digit = Integer.toHexString(b);
-            if (digit.length() < 2) buf.append('0');
-            if (digit.length() > 2) digit = digit.substring(digit.length() - 2);
+            if (digit.length() < 2) {
+                buf.append('0');
+            }
+            if (digit.length() > 2) {
+                digit = digit.substring(digit.length() - 2);
+            }
             buf.append(digit);
         }
         return buf.toString();

==================================================
OpenSSLCipherConfigurationParser.java
index 10fa1822a6..ce3cce348d 100644
--- a/java/org/apache/tomcat/util/net/openssl/OpenSSLContext.java
+++ b/java/org/apache/tomcat/util/net/openssl/OpenSSLContext.java
@@ -115,8 +115,9 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
             OpenSSLConf openSslConf = sslHostConfig.getOpenSslConf();
             if (openSslConf != null) {
                 try {
-                    if (log.isDebugEnabled())
+                    if (log.isDebugEnabled()) {
                         log.debug(sm.getString("openssl.makeConf"));
+                    }
                     cctx = SSLConf.make(aprPool,
                                         SSL.SSL_CONF_FLAG_FILE |
                                         SSL.SSL_CONF_FLAG_SERVER |
@@ -289,8 +290,9 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
                 // an acceptable certificate
                 for (X509Certificate caCert : x509TrustManager.getAcceptedIssuers()) {
                     SSLContext.addClientCACertificateRaw(ctx, caCert.getEncoded());
-                    if (log.isDebugEnabled())
+                    if (log.isDebugEnabled()) {
                         log.debug(sm.getString("openssl.addedClientCaCert", caCert.toString()));
+                    }
                 }
             } else {
                 // Client certificate verification based on trusted CA files and dirs
@@ -311,8 +313,9 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
             OpenSSLConf openSslConf = sslHostConfig.getOpenSslConf();
             if (openSslConf != null && cctx != 0) {
                 // Check OpenSSLConfCmd if used
-                if (log.isDebugEnabled())
+                if (log.isDebugEnabled()) {
                     log.debug(sm.getString("openssl.checkConf"));
+                }
                 try {
                     if (!openSslConf.check(cctx)) {
                         log.error(sm.getString("openssl.errCheckConf"));
@@ -321,8 +324,9 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
                 } catch (Exception e) {
                     throw new Exception(sm.getString("openssl.errCheckConf"), e);
                 }
-                if (log.isDebugEnabled())
+                if (log.isDebugEnabled()) {
                     log.debug(sm.getString("openssl.applyConf"));
+                }
                 try {
                     if (!openSslConf.apply(cctx, ctx)) {
                         log.error(sm.getString("openssl.errApplyConf"));

==================================================
