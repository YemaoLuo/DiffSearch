36f94338746fa1bf6bc63e8fe276ed91a72a3c67
==================================================
Correct the previous fix for bug 56825 that enabled pre-emptive authentication to work with the SSL authenticator.
==================================================
Mark Emlyn
==================================================
Thu Sep 4 13:12:55 2014 +0000
==================================================
AuthenticatorBase.java
Correct the previous fix for bug 56825 that enabled pre-emptive authentication to work with the SSL authenticator.
An SSL handshake is now triggered if:
- premetive authentication is enabled;
- CLIENT-CERT is being used; and
- the previous handshake did not include a client cert

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1622470 13f79535-47bb-0310-9956-ffa450edef68



==================================================
SSLAuthenticator.java
index 8c057ec87a..18f5b3940a 100644
--- a/java/org/apache/catalina/authenticator/AuthenticatorBase.java
+++ b/java/org/apache/catalina/authenticator/AuthenticatorBase.java
@@ -25,6 +25,7 @@ import java.util.Locale;
 
 import javax.servlet.ServletException;
 import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
 import org.apache.catalina.Authenticator;
@@ -567,8 +568,9 @@ public abstract class AuthenticatorBase extends ValveBase
                         "authorization") != null;
         }
 
-        if (!authRequired && context.getPreemptiveAuthentication()) {
-            X509Certificate[] certs = getRequestCertificates(request, false);
+        if (!authRequired && context.getPreemptiveAuthentication() &&
+                HttpServletRequest.CLIENT_CERT_AUTH.equals(getAuthMethod())) {
+            X509Certificate[] certs = getRequestCertificates(request);
             authRequired = certs != null && certs.length > 0;
         }
 
@@ -626,13 +628,11 @@ public abstract class AuthenticatorBase extends ValveBase
      * extracting the certificate chain from the Coyote request.
      *
      * @param request   Request to be processed
-     * @param force     Should a renegotiation be forced to request certificates
-     *                  from the user agent if none have been provided
      *
      * @return          The X509 certificate chain if found, <code>null</code>
      *                  otherwise.
      */
-    protected X509Certificate[] getRequestCertificates(final Request request, boolean force)
+    protected X509Certificate[] getRequestCertificates(final Request request)
             throws IllegalStateException {
 
         X509Certificate certs[] =
@@ -640,7 +640,7 @@ public abstract class AuthenticatorBase extends ValveBase
 
         if ((certs == null) || (certs.length < 1)) {
             try {
-                request.getCoyoteRequest().action(ActionCode.REQ_SSL_CERTIFICATE, Boolean.valueOf(force));
+                request.getCoyoteRequest().action(ActionCode.REQ_SSL_CERTIFICATE, null);
                 certs = (X509Certificate[]) request.getAttribute(Globals.CERTIFICATES_ATTR);
             } catch (IllegalStateException ise) {
                 // Request body was too large for save buffer

==================================================
Http11AprProcessor.java
index 56376bf4cc..0269ee4b9d 100644
--- a/java/org/apache/catalina/authenticator/SSLAuthenticator.java
+++ b/java/org/apache/catalina/authenticator/SSLAuthenticator.java
@@ -95,7 +95,7 @@ public class SSLAuthenticator extends AuthenticatorBase {
             containerLog.debug(" Looking up certificates");
         }
 
-        X509Certificate certs[] = getRequestCertificates(request, true);
+        X509Certificate certs[] = getRequestCertificates(request);
 
         if ((certs == null) || (certs.length < 1)) {
             if (containerLog.isDebugEnabled()) {

==================================================
Http11Nio2Processor.java
index 30d3225c79..e4ecd1a370 100644
--- a/java/org/apache/coyote/http11/Http11AprProcessor.java
+++ b/java/org/apache/coyote/http11/Http11AprProcessor.java
@@ -419,26 +419,18 @@ public class Http11AprProcessor extends AbstractHttp11Processor<Long> {
         }
         case REQ_SSL_CERTIFICATE: {
             if (endpoint.isSSLEnabled() && (socketRef != 0)) {
-                boolean force = ((Boolean) param).booleanValue();
-                if (force) {
-                    /* Forced triggers a handshake so consume and buffer the
-                     * request body, so that it does not interfere with the
-                     * client's handshake messages
-                     */
-                    InputFilter[] inputFilters = inputBuffer.getFilters();
-                    ((BufferedInputFilter) inputFilters[Constants.BUFFERED_FILTER])
-                            .setLimit(maxSavePostSize);
-                    inputBuffer.addActiveFilter(inputFilters[Constants.BUFFERED_FILTER]);
-                }
+                // Consume and buffer the request body, so that it does not
+                // interfere with the client's handshake messages
+                InputFilter[] inputFilters = inputBuffer.getFilters();
+                ((BufferedInputFilter) inputFilters[Constants.BUFFERED_FILTER]).setLimit(maxSavePostSize);
+                inputBuffer.addActiveFilter(inputFilters[Constants.BUFFERED_FILTER]);
                 try {
-                    if (force) {
-                        // Configure connection to require a certificate
-                        SSLSocket.setVerify(socketRef, SSL.SSL_CVERIFY_REQUIRE,
-                                ((AprEndpoint)endpoint).getSSLVerifyDepth());
-                    }
-                    if (!force || SSLSocket.renegotiate(socketRef) == 0) {
-                        // Only look for certs if not forcing a renegotiation or
-                        // if we know renegotiation worked.
+                    // Configure connection to require a certificate
+                    SSLSocket.setVerify(socketRef, SSL.SSL_CVERIFY_REQUIRE,
+                            ((AprEndpoint)endpoint).getSSLVerifyDepth());
+                    // Renegotiate certificates
+                    if (SSLSocket.renegotiate(socketRef) == 0) {
+                        // Don't look for certs unless we know renegotiation worked.
                         // Get client certificate and the certificate chain if present
                         // certLength == -1 indicates an error
                         int certLength = SSLSocket.getInfoI(socketRef,SSL.SSL_INFO_CLIENT_CERT_CHAIN);

==================================================
Http11NioProcessor.java
index 6ee96f5bc6..6abd2004b8 100644
--- a/java/org/apache/coyote/http11/Http11Nio2Processor.java
+++ b/java/org/apache/coyote/http11/Http11Nio2Processor.java
@@ -465,20 +465,18 @@ public class Http11Nio2Processor extends AbstractHttp11Processor<Nio2Channel> {
         }
         case REQ_SSL_CERTIFICATE: {
             if (sslSupport != null && socketWrapper.getSocket() != null) {
-                boolean force = ((Boolean) param).booleanValue();
-                if (force) {
-                    /* Forced triggers a handshake so consume and buffer the
-                     * request body, so that it does not interfere with the
-                     * client's handshake messages
-                     */
-                    InputFilter[] inputFilters = inputBuffer.getFilters();
-                    ((BufferedInputFilter) inputFilters[Constants.BUFFERED_FILTER])
-                            .setLimit(maxSavePostSize);
-                    inputBuffer.addActiveFilter(inputFilters[Constants.BUFFERED_FILTER]);
-                }
+                /*
+                 * Consume and buffer the request body, so that it does not
+                 * interfere with the client's handshake messages
+                 */
+                InputFilter[] inputFilters = inputBuffer.getFilters();
+                ((BufferedInputFilter) inputFilters[Constants.BUFFERED_FILTER])
+                    .setLimit(maxSavePostSize);
+                inputBuffer.addActiveFilter
+                    (inputFilters[Constants.BUFFERED_FILTER]);
                 SecureNio2Channel sslChannel = (SecureNio2Channel) socketWrapper.getSocket();
                 SSLEngine engine = sslChannel.getSslEngine();
-                if (!engine.getNeedClientAuth() && force) {
+                if (!engine.getNeedClientAuth()) {
                     // Need to re-negotiate SSL connection
                     engine.setNeedClientAuth(true);
                     try {
@@ -495,8 +493,9 @@ public class Http11Nio2Processor extends AbstractHttp11Processor<Nio2Channel> {
                     // use force=false since re-negotiation is handled above
                     // (and it is a NO-OP for NIO anyway)
                     Object sslO = sslSupport.getPeerCertificateChain(false);
-                    if (sslO != null) {
-                        request.setAttribute(SSLSupport.CERTIFICATE_KEY, sslO);
+                    if( sslO != null) {
+                        request.setAttribute
+                            (SSLSupport.CERTIFICATE_KEY, sslO);
                     }
                 } catch (Exception e) {
                     log.warn(sm.getString("http11processor.socket.ssl"), e);

==================================================
Http11Processor.java
index c3045c6328..30aa9e9697 100644
--- a/java/org/apache/coyote/http11/Http11NioProcessor.java
+++ b/java/org/apache/coyote/http11/Http11NioProcessor.java
@@ -434,20 +434,18 @@ public class Http11NioProcessor extends AbstractHttp11Processor<NioChannel> {
         }
         case REQ_SSL_CERTIFICATE: {
             if (sslSupport != null) {
-                boolean force = ((Boolean) param).booleanValue();
-                if (force) {
-                    /* Forced triggers a handshake so consume and buffer the
-                     * request body, so that it does not interfere with the
-                     * client's handshake messages
-                     */
-                    InputFilter[] inputFilters = inputBuffer.getFilters();
-                    ((BufferedInputFilter) inputFilters[Constants.BUFFERED_FILTER])
-                            .setLimit(maxSavePostSize);
-                    inputBuffer.addActiveFilter(inputFilters[Constants.BUFFERED_FILTER]);
-                }
+                /*
+                 * Consume and buffer the request body, so that it does not
+                 * interfere with the client's handshake messages
+                 */
+                InputFilter[] inputFilters = inputBuffer.getFilters();
+                ((BufferedInputFilter) inputFilters[Constants.BUFFERED_FILTER])
+                    .setLimit(maxSavePostSize);
+                inputBuffer.addActiveFilter
+                    (inputFilters[Constants.BUFFERED_FILTER]);
                 SecureNioChannel sslChannel = (SecureNioChannel) socketWrapper.getSocket();
                 SSLEngine engine = sslChannel.getSslEngine();
-                if (!engine.getNeedClientAuth() && force) {
+                if (!engine.getNeedClientAuth()) {
                     // Need to re-negotiate SSL connection
                     engine.setNeedClientAuth(true);
                     try {
@@ -464,8 +462,9 @@ public class Http11NioProcessor extends AbstractHttp11Processor<NioChannel> {
                     // use force=false since re-negotiation is handled above
                     // (and it is a NO-OP for NIO anyway)
                     Object sslO = sslSupport.getPeerCertificateChain(false);
-                    if (sslO != null) {
-                        request.setAttribute(SSLSupport.CERTIFICATE_KEY, sslO);
+                    if( sslO != null) {
+                        request.setAttribute
+                            (SSLSupport.CERTIFICATE_KEY, sslO);
                     }
                 } catch (Exception e) {
                     log.warn(sm.getString("http11processor.socket.ssl"), e);

==================================================
TestClientCert.java
index 0deb42c923..98f8dbad16 100644
--- a/java/org/apache/coyote/http11/Http11Processor.java
+++ b/java/org/apache/coyote/http11/Http11Processor.java
@@ -350,19 +350,17 @@ public class Http11Processor extends AbstractHttp11Processor<Socket> {
         }
         case REQ_SSL_CERTIFICATE: {
             if (sslSupport != null) {
-                boolean force = ((Boolean) param).booleanValue();
-                if (force) {
-                    /* Forced triggers a handshake so consume and buffer the
-                     * request body, so that it does not interfere with the
-                     * client's handshake messages
-                     */
-                    InputFilter[] inputFilters = inputBuffer.getFilters();
-                    ((BufferedInputFilter) inputFilters[Constants.BUFFERED_FILTER])
-                            .setLimit(maxSavePostSize);
-                    inputBuffer.addActiveFilter(inputFilters[Constants.BUFFERED_FILTER]);
-                }
+                /*
+                 * Consume and buffer the request body, so that it does not
+                 * interfere with the client's handshake messages
+                 */
+                InputFilter[] inputFilters = inputBuffer.getFilters();
+                ((BufferedInputFilter) inputFilters[Constants.BUFFERED_FILTER])
+                    .setLimit(maxSavePostSize);
+                inputBuffer.addActiveFilter
+                    (inputFilters[Constants.BUFFERED_FILTER]);
                 try {
-                    Object sslO = sslSupport.getPeerCertificateChain(force);
+                    Object sslO = sslSupport.getPeerCertificateChain(true);
                     if( sslO != null) {
                         request.setAttribute
                             (SSLSupport.CERTIFICATE_KEY, sslO);

==================================================
