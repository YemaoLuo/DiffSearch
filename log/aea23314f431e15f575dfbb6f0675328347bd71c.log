aea23314f431e15f575dfbb6f0675328347bd71c
==================================================
Follow-up to 1635301
==================================================
Mark Emlyn
==================================================
Wed Oct 29 21:25:33 2014 +0000
==================================================
Request.java
Follow-up to 1635301
Use isCompleting to align with isDispatching
Fix the implementation for HTTP and AJP

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1635308 13f79535-47bb-0310-9956-ffa450edef68



==================================================
ErrorReportValve.java
index 2de51cb48b..e6331a7a55 100644
--- a/java/org/apache/catalina/connector/Request.java
+++ b/java/org/apache/catalina/connector/Request.java
@@ -1634,13 +1634,13 @@ public class Request
         return result.get();
     }
 
-    public boolean canAsyncComplete() {
+    public boolean isAsyncCompleting() {
         if (asyncContext == null) {
             return false;
         }
 
         AtomicBoolean result = new AtomicBoolean(false);
-        coyoteRequest.action(ActionCode.ASYNC_CAN_COMPLETE, result);
+        coyoteRequest.action(ActionCode.ASYNC_IS_COMPLETING, result);
         return result.get();
     }
 

==================================================
ActionCode.java
index 9a5faa5a12..1a10d46841 100644
--- a/java/org/apache/catalina/valves/ErrorReportValve.java
+++ b/java/org/apache/catalina/valves/ErrorReportValve.java
@@ -123,7 +123,8 @@ public class ErrorReportValve extends ValveBase {
             ExceptionUtils.handleThrowable(tt);
         }
 
-        if (request.canAsyncComplete()) {
+        if (request.isAsyncStarted() && !request.isAsyncCompleting() &&
+                !request.isAsyncDispatching()) {
             request.getAsyncContext().complete();
         }
     }

==================================================
AsyncStateMachine.java
index 8a6ff33bdc..efcf4d8824 100644
--- a/java/org/apache/coyote/ActionCode.java
+++ b/java/org/apache/coyote/ActionCode.java
@@ -110,17 +110,17 @@ public enum ActionCode {
     REQ_SET_BODY_REPLAY,
 
     /**
-     * Callback for begin Comet processing
+     * Callback for begin Comet processing.
      */
     COMET_BEGIN,
 
     /**
-     * Callback for end Comet processing
+     * Callback for end Comet processing.
      */
     COMET_END,
 
     /**
-     * Callback for getting the amount of available bytes
+     * Callback for getting the amount of available bytes.
      */
     AVAILABLE,
 
@@ -135,13 +135,13 @@ public enum ActionCode {
     COMET_SETTIMEOUT,
 
     /**
-     * Callback for an async request
+     * Callback for an async request.
      */
     ASYNC_START,
 
     /**
      * Callback for an async call to
-     * {@link javax.servlet.AsyncContext#dispatch()}
+     * {@link javax.servlet.AsyncContext#dispatch()}.
      */
     ASYNC_DISPATCH,
 
@@ -153,29 +153,23 @@ public enum ActionCode {
 
     /**
      * Callback for an async call to
-     * {@link javax.servlet.AsyncContext#start(Runnable)}
+     * {@link javax.servlet.AsyncContext#start(Runnable)}.
      */
     ASYNC_RUN,
 
-    /**
-     * Call back to see if it is currently possible to call
-     * {@link javax.servlet.AsyncContext#complete()} without error.
-     */
-    ASYNC_CAN_COMPLETE,
-
     /**
      * Callback for an async call to
-     * {@link javax.servlet.AsyncContext#complete()}
+     * {@link javax.servlet.AsyncContext#complete()}.
      */
     ASYNC_COMPLETE,
 
     /**
-     * Callback to trigger the processing of an async timeout
+     * Callback to trigger the processing of an async timeout.
      */
     ASYNC_TIMEOUT,
 
     /**
-     * Callback to trigger the error processing
+     * Callback to trigger the error processing.
      */
     ASYNC_ERROR,
 
@@ -186,27 +180,32 @@ public enum ActionCode {
     ASYNC_SETTIMEOUT,
 
     /**
-     * Callback to determine if async processing is in progress
+     * Callback to determine if async processing is in progress.
      */
     ASYNC_IS_ASYNC,
 
     /**
-     * Callback to determine if async dispatch is in progress
+     * Callback to determine if async dispatch is in progress.
      */
     ASYNC_IS_STARTED,
 
     /**
-     * Callback to determine if async dispatch is in progress
+     * Call back to determine if async complete is in progress.
+     */
+    ASYNC_IS_COMPLETING,
+
+    /**
+     * Callback to determine if async dispatch is in progress.
      */
     ASYNC_IS_DISPATCHING,
 
     /**
-     * Callback to determine if async is timing out
+     * Callback to determine if async is timing out.
      */
     ASYNC_IS_TIMINGOUT,
 
     /**
-    * Callback to determine if async is in error
+    * Callback to determine if async is in error.
     */
     ASYNC_IS_ERROR,
 

==================================================
AbstractAjpProcessor.java
index 7908dd335c..8787df61f2 100644
--- a/java/org/apache/coyote/AsyncStateMachine.java
+++ b/java/org/apache/coyote/AsyncStateMachine.java
@@ -107,26 +107,26 @@ public class AsyncStateMachine {
 
     private static enum AsyncState {
         DISPATCHED(false, false, false, false),
-        STARTING(true, true, true, false),
-        STARTED(true, true, true, false),
-        MUST_COMPLETE(true, true, false, false),
-        COMPLETING(true, false, false, false),
+        STARTING(true, true, false, false),
+        STARTED(true, true, false, false),
+        MUST_COMPLETE(true, true, true, false),
+        COMPLETING(true, false, true, false),
         TIMING_OUT(true, false, false, false),
         MUST_DISPATCH(true, true, false, true),
         DISPATCHING(true, false, false, true),
-        READ_WRITE_OP(true, true, true, false),
+        READ_WRITE_OP(true, true, false, false),
         ERROR(true, false, false, false);
 
         private final boolean isAsync;
         private final boolean isStarted;
-        private final boolean canComplete;
+        private final boolean isCompleting;
         private final boolean isDispatching;
 
-        private AsyncState(boolean isAsync, boolean isStarted, boolean canComplete,
+        private AsyncState(boolean isAsync, boolean isStarted, boolean isCompleting,
                 boolean isDispatching) {
             this.isAsync = isAsync;
             this.isStarted = isStarted;
-            this.canComplete = canComplete;
+            this.isCompleting = isCompleting;
             this.isDispatching = isDispatching;
         }
 
@@ -142,8 +142,8 @@ public class AsyncStateMachine {
             return isDispatching;
         }
 
-        public boolean canComplete() {
-            return canComplete;
+        public boolean isCompleting() {
+            return isCompleting;
         }
     }
 
@@ -179,8 +179,8 @@ public class AsyncStateMachine {
         return state == AsyncState.ERROR;
     }
 
-    public boolean canComplete() {
-        return state.canComplete();
+    public boolean isCompleting() {
+        return state.isCompleting();
     }
 
     public synchronized void asyncStart(AsyncContextCallback asyncCtxt) {

==================================================
AbstractHttp11Processor.java
index 01c9c72e72..01b9c2afc7 100644
--- a/java/org/apache/coyote/ajp/AbstractAjpProcessor.java
+++ b/java/org/apache/coyote/ajp/AbstractAjpProcessor.java
@@ -522,10 +522,6 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
             getSocketWrapper().access();
             break;
         }
-        case ASYNC_CAN_COMPLETE: {
-            ((AtomicBoolean) param).set(asyncStateMachine.canComplete());
-            break;
-        }
         case ASYNC_COMPLETE: {
             socketWrapper.clearDispatches();
             if (asyncStateMachine.asyncComplete()) {
@@ -566,6 +562,10 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
             ((AtomicBoolean) param).set(asyncStateMachine.isAsyncStarted());
             break;
         }
+        case ASYNC_IS_COMPLETING: {
+            ((AtomicBoolean) param).set(asyncStateMachine.isCompleting());
+            break;
+        }
         case ASYNC_IS_DISPATCHING: {
             ((AtomicBoolean) param).set(asyncStateMachine.isAsyncDispatching());
             break;

==================================================
