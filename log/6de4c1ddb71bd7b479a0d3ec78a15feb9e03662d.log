6de4c1ddb71bd7b479a0d3ec78a15feb9e03662d
==================================================
Reformat excessively long lines (> 200 chars).
==================================================
Mark Emlyn
==================================================
Wed Aug 14 12:13:59 2013 +0000
==================================================
ChannelCoordinator.java
Reformat excessively long lines (> 200 chars).
Also reformatted long lines > 100 chars.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1513828 13f79535-47bb-0310-9956-ffa450edef68



==================================================
GroupChannel.java
index fdd852da56..4b4b6b27df 100644
--- a/java/org/apache/catalina/tribes/group/ChannelCoordinator.java
+++ b/java/org/apache/catalina/tribes/group/ChannelCoordinator.java
@@ -72,7 +72,8 @@ public class ChannelCoordinator extends ChannelInterceptorBase implements Messag
      * @param payload TBA
      */
     @Override
-    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
+    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload)
+            throws ChannelException {
         if ( destination == null ) destination = membershipService.getMembers();
         if ((msg.getOptions()&Channel.SEND_OPTIONS_MULTICAST) == Channel.SEND_OPTIONS_MULTICAST) {
             membershipService.broadcast(msg);
@@ -80,7 +81,9 @@ public class ChannelCoordinator extends ChannelInterceptorBase implements Messag
             clusterSender.sendMessage(msg,destination);
         }
         if ( Logs.MESSAGES.isTraceEnabled() ) {
-            Logs.MESSAGES.trace("ChannelCoordinator - Sent msg:" + new UniqueId(msg.getUniqueId()) + " at " +new java.sql.Timestamp(System.currentTimeMillis())+ " to "+Arrays.toNameString(destination));
+            Logs.MESSAGES.trace("ChannelCoordinator - Sent msg:" + new UniqueId(msg.getUniqueId()) +
+                    " at " + new java.sql.Timestamp(System.currentTimeMillis()) + " to " +
+                    Arrays.toNameString(destination));
         }
     }
 
@@ -138,7 +141,9 @@ public class ChannelCoordinator extends ChannelInterceptorBase implements Messag
             if (startLevel == Channel.DEFAULT) return; //we have already started up all components
             if (svc == 0 ) return;//nothing to start
 
-            if (svc == (svc & startLevel)) throw new ChannelException("Channel already started for level:"+svc);
+            if (svc == (svc & startLevel)) {
+                throw new ChannelException("Channel already started for level:"+svc);
+            }
 
             //must start the receiver first so that we can coordinate the port it
             //listens to with the local membership settings
@@ -170,8 +175,9 @@ public class ChannelCoordinator extends ChannelInterceptorBase implements Messag
                 valid = true;
             }
 
-            if ( !valid) {
-                throw new IllegalArgumentException("Invalid start level, valid levels are:SND_RX_SEQ,SND_TX_SEQ,MBR_TX_SEQ,MBR_RX_SEQ");
+            if (!valid) {
+                throw new IllegalArgumentException("Invalid start level, valid levels are:" +
+                        "SND_RX_SEQ,SND_TX_SEQ,MBR_TX_SEQ,MBR_RX_SEQ");
             }
             startLevel = (startLevel | svc);
         }catch ( ChannelException cx ) {
@@ -222,7 +228,8 @@ public class ChannelCoordinator extends ChannelInterceptorBase implements Messag
                 membershipService.stop(MembershipService.MBR_TX);
             }
             if ( !valid) {
-                throw new IllegalArgumentException("Invalid start level, valid levels are:SND_RX_SEQ,SND_TX_SEQ,MBR_TX_SEQ,MBR_RX_SEQ");
+                throw new IllegalArgumentException("Invalid start level, valid levels are:" +
+                        "SND_RX_SEQ,SND_TX_SEQ,MBR_TX_SEQ,MBR_RX_SEQ");
             }
 
             startLevel = (startLevel & (~svc));
@@ -250,7 +257,10 @@ public class ChannelCoordinator extends ChannelInterceptorBase implements Messag
     @Override
     public void messageReceived(ChannelMessage msg) {
         if ( Logs.MESSAGES.isTraceEnabled() ) {
-            Logs.MESSAGES.trace("ChannelCoordinator - Received msg:" + new UniqueId(msg.getUniqueId()) + " at " +new java.sql.Timestamp(System.currentTimeMillis())+ " from "+msg.getAddress().getName());
+            Logs.MESSAGES.trace("ChannelCoordinator - Received msg:" +
+                    new UniqueId(msg.getUniqueId()) + " at " +
+                    new java.sql.Timestamp(System.currentTimeMillis()) + " from " +
+                    msg.getAddress().getName());
         }
         super.messageReceived(msg);
     }

==================================================
MessageDispatchInterceptor.java
index 06897c2fd5..697a47b1ff 100644
--- a/java/org/apache/catalina/tribes/group/GroupChannel.java
+++ b/java/org/apache/catalina/tribes/group/GroupChannel.java
@@ -172,14 +172,16 @@ public class GroupChannel extends ChannelInterceptorBase implements ManagedChann
      * Send a message to the destinations specified
      * @param destination Member[] - destination.length > 0
      * @param msg Serializable - the message to send
-     * @param options int - sender options, options can trigger guarantee levels and different interceptors to
-     * react to the message see class documentation for the <code>Channel</code> object.<br>
+     * @param options sender options, options can trigger guarantee levels and different
+     *                interceptors to react to the message see class documentation for the
+     *                <code>Channel</code> object.<br>
      * @return UniqueId - the unique Id that was assigned to this message
      * @throws ChannelException - if an error occurs processing the message
      * @see org.apache.catalina.tribes.Channel
      */
     @Override
-    public UniqueId send(Member[] destination, Serializable msg, int options) throws ChannelException {
+    public UniqueId send(Member[] destination, Serializable msg, int options)
+            throws ChannelException {
         return send(destination,msg,options,null);
     }
 
@@ -187,20 +189,25 @@ public class GroupChannel extends ChannelInterceptorBase implements ManagedChann
      *
      * @param destination Member[] - destination.length > 0
      * @param msg Serializable - the message to send
-     * @param options int - sender options, options can trigger guarantee levels and different interceptors to
-     * react to the message see class documentation for the <code>Channel</code> object.<br>
-     * @param handler - callback object for error handling and completion notification, used when a message is
-     * sent asynchronously using the <code>Channel.SEND_OPTIONS_ASYNCHRONOUS</code> flag enabled.
+     * @param options sender options, options can trigger guarantee levels and different
+     *                interceptors to react to the message see class documentation for the
+     *                <code>Channel</code> object.<br>
+     * @param handler - callback object for error handling and completion notification,
+     *                  used when a message is sent asynchronously using the
+     *                  <code>Channel.SEND_OPTIONS_ASYNCHRONOUS</code> flag enabled.
      * @return UniqueId - the unique Id that was assigned to this message
      * @throws ChannelException - if an error occurs processing the message
      * @see org.apache.catalina.tribes.Channel
      */
     @Override
-    public UniqueId send(Member[] destination, Serializable msg, int options, ErrorHandler handler) throws ChannelException {
+    public UniqueId send(Member[] destination, Serializable msg, int options, ErrorHandler handler)
+            throws ChannelException {
         if ( msg == null ) throw new ChannelException("Cant send a NULL message");
         XByteBuffer buffer = null;
         try {
-            if ( destination == null || destination.length == 0) throw new ChannelException("No destination given");
+            if (destination == null || destination.length == 0) {
+                throw new ChannelException("No destination given");
+            }
             ChannelData data = new ChannelData(true);//generates a unique Id
             data.setAddress(getLocalMember(false));
             data.setTimestamp(System.currentTimeMillis());
@@ -224,8 +231,11 @@ public class GroupChannel extends ChannelInterceptorBase implements ManagedChann
             }
             getFirstInterceptor().sendMessage(destination, data, payload);
             if ( Logs.MESSAGES.isTraceEnabled() ) {
-                Logs.MESSAGES.trace("GroupChannel - Sent msg:" + new UniqueId(data.getUniqueId()) + " at " +new java.sql.Timestamp(System.currentTimeMillis())+ " to "+Arrays.toNameString(destination));
-                Logs.MESSAGES.trace("GroupChannel - Send Message:" + new UniqueId(data.getUniqueId()) + " is " +msg);
+                Logs.MESSAGES.trace("GroupChannel - Sent msg:" + new UniqueId(data.getUniqueId()) +
+                        " at " + new java.sql.Timestamp(System.currentTimeMillis()) + " to " +
+                        Arrays.toNameString(destination));
+                Logs.MESSAGES.trace("GroupChannel - Send Message:" +
+                        new UniqueId(data.getUniqueId()) + " is " + msg);
             }
 
             return new UniqueId(data.getUniqueId());
@@ -240,10 +250,11 @@ public class GroupChannel extends ChannelInterceptorBase implements ManagedChann
 
     /**
      * Callback from the interceptor stack. <br>
-     * When a message is received from a remote node, this method will be invoked by
-     * the previous interceptor.<br>
-     * This method can also be used to send a message to other components within the same application,
-     * but its an extreme case, and you're probably better off doing that logic between the applications itself.
+     * When a message is received from a remote node, this method will be
+     * invoked by the previous interceptor.<br>
+     * This method can also be used to send a message to other components
+     * within the same application, but its an extreme case, and you're probably
+     * better off doing that logic between the applications itself.
      * @param msg ChannelMessage
      */
     @Override
@@ -251,7 +262,10 @@ public class GroupChannel extends ChannelInterceptorBase implements ManagedChann
         if ( msg == null ) return;
         try {
             if ( Logs.MESSAGES.isTraceEnabled() ) {
-                Logs.MESSAGES.trace("GroupChannel - Received msg:" + new UniqueId(msg.getUniqueId()) + " at " +new java.sql.Timestamp(System.currentTimeMillis())+ " from "+msg.getAddress().getName());
+                Logs.MESSAGES.trace("GroupChannel - Received msg:" +
+                        new UniqueId(msg.getUniqueId()) + " at " +
+                        new java.sql.Timestamp(System.currentTimeMillis()) + " from " +
+                        msg.getAddress().getName());
             }
 
             Serializable fwd = null;
@@ -259,14 +273,16 @@ public class GroupChannel extends ChannelInterceptorBase implements ManagedChann
                 fwd = new ByteMessage(msg.getMessage().getBytes());
             } else {
                 try {
-                    fwd = XByteBuffer.deserialize(msg.getMessage().getBytesDirect(), 0, msg.getMessage().getLength());
+                    fwd = XByteBuffer.deserialize(msg.getMessage().getBytesDirect(), 0,
+                            msg.getMessage().getLength());
                 }catch (Exception sx) {
                     log.error("Unable to deserialize message:"+msg,sx);
                     return;
                 }
             }
             if ( Logs.MESSAGES.isTraceEnabled() ) {
-                Logs.MESSAGES.trace("GroupChannel - Receive Message:" + new UniqueId(msg.getUniqueId()) + " is " +fwd);
+                Logs.MESSAGES.trace("GroupChannel - Receive Message:" +
+                        new UniqueId(msg.getUniqueId()) + " is " + fwd);
             }
 
             //get the actual member with the correct alive time
@@ -289,7 +305,8 @@ public class GroupChannel extends ChannelInterceptorBase implements ManagedChann
                 sendNoRpcChannelReply((RpcMessage)fwd,source);
             }
             if ( Logs.MESSAGES.isTraceEnabled() ) {
-                Logs.MESSAGES.trace("GroupChannel delivered["+delivered+"] id:"+new UniqueId(msg.getUniqueId()));
+                Logs.MESSAGES.trace("GroupChannel delivered[" + delivered + "] id:" +
+                        new UniqueId(msg.getUniqueId()));
             }
 
         } catch ( Exception x ) {
@@ -311,7 +328,8 @@ public class GroupChannel extends ChannelInterceptorBase implements ManagedChann
         try {
             //avoid circular loop
             if ( msg instanceof RpcMessage.NoRpcChannelReply) return;
-            RpcMessage.NoRpcChannelReply reply = new RpcMessage.NoRpcChannelReply(msg.rpcId,msg.uuid);
+            RpcMessage.NoRpcChannelReply reply =
+                    new RpcMessage.NoRpcChannelReply(msg.rpcId, msg.uuid);
             send(new Member[]{destination},reply,Channel.SEND_OPTIONS_ASYNCHRONOUS);
         } catch ( Exception x ) {
             log.error("Unable to find rpc channel, failed to send NoRpcChannelReply.",x);
@@ -358,8 +376,9 @@ public class GroupChannel extends ChannelInterceptorBase implements ManagedChann
             ChannelInterceptor interceptor = null;
             Class<?> clazz = null;
             try {
-                clazz = Class.forName("org.apache.catalina.tribes.group.interceptors.MessageDispatch15Interceptor",
-                                      true,GroupChannel.class.getClassLoader());
+                clazz = Class.forName(
+                        "org.apache.catalina.tribes.group.interceptors.MessageDispatch15Interceptor",
+                        true, GroupChannel.class.getClassLoader());
                 clazz.newInstance();
             } catch ( Throwable x ) {
                 clazz = MessageDispatchInterceptor.class;
@@ -367,7 +386,8 @@ public class GroupChannel extends ChannelInterceptorBase implements ManagedChann
             try {
                 interceptor = (ChannelInterceptor) clazz.newInstance();
             } catch (Exception x) {
-                throw new ChannelException("Unable to add MessageDispatchInterceptor to interceptor chain.",x);
+                throw new ChannelException(
+                        "Unable to add MessageDispatchInterceptor to interceptor chain.", x);
             }
             this.addInterceptor(interceptor);
         }

==================================================
ParallelNioSender.java
index 287e6f4c22..390417d0bd 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/MessageDispatchInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/MessageDispatchInterceptor.java
@@ -14,7 +14,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package org.apache.catalina.tribes.group.interceptors;
 
 import org.apache.catalina.tribes.Channel;
@@ -32,10 +31,9 @@ import org.apache.juli.logging.LogFactory;
 /**
  *
  * The message dispatcher is a way to enable asynchronous communication
- * through a channel. The dispatcher will look for the <code>Channel.SEND_OPTIONS_ASYNCHRONOUS</code>
- * flag to be set, if it is, it will queue the message for delivery and immediately return to the sender.
- *
- *
+ * through a channel. The dispatcher will look for the
+ * <code>Channel.SEND_OPTIONS_ASYNCHRONOUS</code> flag to be set, if it is, it
+ * will queue the message for delivery and immediately return to the sender.
  *
  * @author Filip Hanik
  * @version 1.0
@@ -56,21 +54,25 @@ public class MessageDispatchInterceptor extends ChannelInterceptorBase implement
     }
 
     @Override
-    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
-        boolean async = (msg.getOptions() & Channel.SEND_OPTIONS_ASYNCHRONOUS) == Channel.SEND_OPTIONS_ASYNCHRONOUS;
+    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload)
+            throws ChannelException {
+        boolean async = (msg.getOptions() &
+                Channel.SEND_OPTIONS_ASYNCHRONOUS) == Channel.SEND_OPTIONS_ASYNCHRONOUS;
         if ( async && run ) {
             if ( (getCurrentSize()+msg.getMessage().getLength()) > maxQueueSize ) {
                 if ( alwaysSend ) {
                     super.sendMessage(destination,msg,payload);
                     return;
                 } else {
-                    throw new ChannelException("Asynchronous queue is full, reached its limit of " + maxQueueSize +" bytes, current:" + getCurrentSize() + " bytes.");
+                    throw new ChannelException("Asynchronous queue is full, reached its limit of " +
+                            maxQueueSize +" bytes, current:" + getCurrentSize() + " bytes.");
                 }//end if
             }//end if
             //add to queue
             if ( useDeepClone ) msg = (ChannelMessage)msg.deepclone();
             if (!addToQueue(msg, destination, payload) ) {
-                throw new ChannelException("Unable to add the message to the async queue, queue bug?");
+                throw new ChannelException(
+                        "Unable to add the message to the async queue, queue bug?");
             }
             addAndGetCurrentSize(msg.getMessage().getLength());
         } else {
@@ -78,7 +80,8 @@ public class MessageDispatchInterceptor extends ChannelInterceptorBase implement
         }
     }
 
-    public boolean addToQueue(ChannelMessage msg, Member[] destination, InterceptorPayload payload) {
+    public boolean addToQueue(ChannelMessage msg, Member[] destination,
+            InterceptorPayload payload) {
         return queue.add(msg,destination,payload);
     }
 
@@ -106,7 +109,11 @@ public class MessageDispatchInterceptor extends ChannelInterceptorBase implement
 
     @Override
     public void setOptionFlag(int flag) {
-        if ( flag != Channel.SEND_OPTIONS_ASYNCHRONOUS ) log.warn("Warning, you are overriding the asynchronous option flag, this will disable the Channel.SEND_OPTIONS_ASYNCHRONOUS that other apps might use.");
+        if ( flag != Channel.SEND_OPTIONS_ASYNCHRONOUS ) {
+            log.warn("Warning, you are overriding the asynchronous option " +
+                    "flag, this will disable the Channel.SEND_OPTIONS_ASYNCHRONOUS " +
+                    "that other apps might use.");
+        }
         super.setOptionFlag(flag);
     }
 
@@ -149,7 +156,8 @@ public class MessageDispatchInterceptor extends ChannelInterceptorBase implement
         //start the thread
         if (!run ) {
             synchronized (this) {
-                if ( !run && ((svc & Channel.SND_TX_SEQ)==Channel.SND_TX_SEQ) ) {//only start with the sender
+                // only start with the sender
+                if ( !run && ((svc & Channel.SND_TX_SEQ)==Channel.SND_TX_SEQ) ) {
                     startQueue();
                 }//end if
             }//sync
@@ -189,7 +197,9 @@ public class MessageDispatchInterceptor extends ChannelInterceptorBase implement
         try {
             super.sendMessage(destination,msg,null);
             try {
-                if ( link.getHandler() != null ) link.getHandler().handleCompletion(new UniqueId(msg.getUniqueId()));
+                if (link.getHandler() != null) {
+                    link.getHandler().handleCompletion(new UniqueId(msg.getUniqueId()));
+                }
             } catch ( Exception ex ) {
                 log.error("Unable to report back completed message.",ex);
             }
@@ -199,7 +209,9 @@ public class MessageDispatchInterceptor extends ChannelInterceptorBase implement
             else cx = new ChannelException(x);
             if ( log.isDebugEnabled() ) log.debug("Error while processing async message.",x);
             try {
-                if (link.getHandler() != null) link.getHandler().handleError(cx, new UniqueId(msg.getUniqueId()));
+                if (link.getHandler() != null) {
+                    link.getHandler().handleError(cx, new UniqueId(msg.getUniqueId()));
+                }
             } catch ( Exception ex ) {
                 log.error("Unable to report back error message.",ex);
             }

==================================================
