aec258aa71a547c138308b84dbd3dd03b498fc7e
==================================================
Code clean-up. Formatting. No functional change.
==================================================
Mark Thomas
==================================================
Wed Mar 8 18:26:36 2023 +0000
==================================================
AsyncChannelGroupUtil.java
Code clean-up. Formatting. No functional change.


==================================================
AsyncChannelWrapper.java
index 9d1220ac01..6e6d5aef05 100644
--- a/java/org/apache/tomcat/websocket/AsyncChannelGroupUtil.java
+++ b/java/org/apache/tomcat/websocket/AsyncChannelGroupUtil.java
@@ -28,14 +28,12 @@ import org.apache.tomcat.util.res.StringManager;
 import org.apache.tomcat.util.threads.ThreadPoolExecutor;
 
 /**
- * This is a utility class that enables multiple {@link WsWebSocketContainer}
- * instances to share a single {@link AsynchronousChannelGroup} while ensuring
- * that the group is destroyed when no longer required.
+ * This is a utility class that enables multiple {@link WsWebSocketContainer} instances to share a single
+ * {@link AsynchronousChannelGroup} while ensuring that the group is destroyed when no longer required.
  */
 public class AsyncChannelGroupUtil {
 
-    private static final StringManager sm =
-            StringManager.getManager(AsyncChannelGroupUtil.class);
+    private static final StringManager sm = StringManager.getManager(AsyncChannelGroupUtil.class);
 
     private static AsynchronousChannelGroup group = null;
     private static int usageCount = 0;
@@ -81,16 +79,11 @@ public class AsyncChannelGroupUtil {
             // These are the same settings as the default
             // AsynchronousChannelGroup
             int initialSize = Runtime.getRuntime().availableProcessors();
-            ExecutorService executorService = new ThreadPoolExecutor(
-                    0,
-                    Integer.MAX_VALUE,
-                    Long.MAX_VALUE, TimeUnit.MILLISECONDS,
-                    new SynchronousQueue<>(),
-                    new AsyncIOThreadFactory());
+            ExecutorService executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, Long.MAX_VALUE,
+                    TimeUnit.MILLISECONDS, new SynchronousQueue<>(), new AsyncIOThreadFactory());
 
             try {
-                return AsynchronousChannelGroup.withCachedThreadPool(
-                        executorService, initialSize);
+                return AsynchronousChannelGroup.withCachedThreadPool(executorService, initialSize);
             } catch (IOException e) {
                 // No good reason for this to happen.
                 throw new IllegalStateException(sm.getString("asyncChannelGroup.createFail"));

==================================================
AsyncChannelWrapperNonSecure.java
index cd6fc78af4..978dc3fa73 100644
--- a/java/org/apache/tomcat/websocket/AsyncChannelWrapper.java
+++ b/java/org/apache/tomcat/websocket/AsyncChannelWrapper.java
@@ -26,22 +26,19 @@ import java.util.concurrent.TimeUnit;
 import javax.net.ssl.SSLException;
 
 /**
- * This is a wrapper for a {@link java.nio.channels.AsynchronousSocketChannel}
- * that limits the methods available thereby simplifying the process of
- * implementing SSL/TLS support since there are fewer methods to intercept.
+ * This is a wrapper for a {@link java.nio.channels.AsynchronousSocketChannel} that limits the methods available thereby
+ * simplifying the process of implementing SSL/TLS support since there are fewer methods to intercept.
  */
 public interface AsyncChannelWrapper {
 
     Future<Integer> read(ByteBuffer dst);
 
-    <B,A extends B> void read(ByteBuffer dst, A attachment,
-            CompletionHandler<Integer,B> handler);
+    <B, A extends B> void read(ByteBuffer dst, A attachment, CompletionHandler<Integer, B> handler);
 
     Future<Integer> write(ByteBuffer src);
 
-    <B,A extends B> void write(ByteBuffer[] srcs, int offset, int length,
-            long timeout, TimeUnit unit, A attachment,
-            CompletionHandler<Long,B> handler);
+    <B, A extends B> void write(ByteBuffer[] srcs, int offset, int length, long timeout, TimeUnit unit, A attachment,
+            CompletionHandler<Long, B> handler);
 
     void close();
 

==================================================
AsyncChannelWrapperSecure.java
index f28ef87284..31f8998c05 100644
--- a/java/org/apache/tomcat/websocket/AsyncChannelWrapperNonSecure.java
+++ b/java/org/apache/tomcat/websocket/AsyncChannelWrapperNonSecure.java
@@ -27,9 +27,8 @@ import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
 /**
- * Generally, just passes calls straight to the wrapped
- * {@link AsynchronousSocketChannel}. In some cases exceptions may be swallowed
- * to save them being swallowed by the calling code.
+ * Generally, just passes calls straight to the wrapped {@link AsynchronousSocketChannel}. In some cases exceptions may
+ * be swallowed to save them being swallowed by the calling code.
  */
 public class AsyncChannelWrapperNonSecure implements AsyncChannelWrapper {
 
@@ -37,8 +36,7 @@ public class AsyncChannelWrapperNonSecure implements AsyncChannelWrapper {
 
     private final AsynchronousSocketChannel socketChannel;
 
-    public AsyncChannelWrapperNonSecure(
-            AsynchronousSocketChannel socketChannel) {
+    public AsyncChannelWrapperNonSecure(AsynchronousSocketChannel socketChannel) {
         this.socketChannel = socketChannel;
     }
 
@@ -48,8 +46,7 @@ public class AsyncChannelWrapperNonSecure implements AsyncChannelWrapper {
     }
 
     @Override
-    public <B,A extends B> void read(ByteBuffer dst, A attachment,
-            CompletionHandler<Integer,B> handler) {
+    public <B, A extends B> void read(ByteBuffer dst, A attachment, CompletionHandler<Integer, B> handler) {
         socketChannel.read(dst, attachment, handler);
     }
 
@@ -59,11 +56,9 @@ public class AsyncChannelWrapperNonSecure implements AsyncChannelWrapper {
     }
 
     @Override
-    public <B,A extends B> void write(ByteBuffer[] srcs, int offset, int length,
-            long timeout, TimeUnit unit, A attachment,
-            CompletionHandler<Long,B> handler) {
-        socketChannel.write(
-                srcs, offset, length, timeout, unit, attachment, handler);
+    public <B, A extends B> void write(ByteBuffer[] srcs, int offset, int length, long timeout, TimeUnit unit,
+            A attachment, CompletionHandler<Long, B> handler) {
+        socketChannel.write(srcs, offset, length, timeout, unit, attachment, handler);
     }
 
     @Override
@@ -110,9 +105,7 @@ public class AsyncChannelWrapperNonSecure implements AsyncChannelWrapper {
         }
 
         @Override
-        public Void get(long timeout, TimeUnit unit)
-                throws InterruptedException, ExecutionException,
-                TimeoutException {
+        public Void get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
             return null;
         }
     }

==================================================
AuthenticationException.java
index e90774a052..6836ba0866 100644
--- a/java/org/apache/tomcat/websocket/AsyncChannelWrapperSecure.java
+++ b/java/org/apache/tomcat/websocket/AsyncChannelWrapperSecure.java
@@ -44,15 +44,13 @@ import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.res.StringManager;
 
 /**
- * Wraps the {@link AsynchronousSocketChannel} with SSL/TLS. This needs a lot
- * more testing before it can be considered robust.
+ * Wraps the {@link AsynchronousSocketChannel} with SSL/TLS. This needs a lot more testing before it can be considered
+ * robust.
  */
 public class AsyncChannelWrapperSecure implements AsyncChannelWrapper {
 
-    private final Log log =
-            LogFactory.getLog(AsyncChannelWrapperSecure.class);
-    private static final StringManager sm =
-            StringManager.getManager(AsyncChannelWrapperSecure.class);
+    private final Log log = LogFactory.getLog(AsyncChannelWrapperSecure.class);
+    private static final StringManager sm = StringManager.getManager(AsyncChannelWrapperSecure.class);
 
     private static final ByteBuffer DUMMY = ByteBuffer.allocate(16921);
     private final AsynchronousSocketChannel socketChannel;
@@ -60,13 +58,11 @@ public class AsyncChannelWrapperSecure implements AsyncChannelWrapper {
     private final ByteBuffer socketReadBuffer;
     private final ByteBuffer socketWriteBuffer;
     // One thread for read, one for write
-    private final ExecutorService executor =
-            Executors.newFixedThreadPool(2, new SecureIOThreadFactory());
+    private final ExecutorService executor = Executors.newFixedThreadPool(2, new SecureIOThreadFactory());
     private AtomicBoolean writing = new AtomicBoolean(false);
     private AtomicBoolean reading = new AtomicBoolean(false);
 
-    public AsyncChannelWrapperSecure(AsynchronousSocketChannel socketChannel,
-            SSLEngine sslEngine) {
+    public AsyncChannelWrapperSecure(AsynchronousSocketChannel socketChannel, SSLEngine sslEngine) {
         this.socketChannel = socketChannel;
         this.sslEngine = sslEngine;
 
@@ -77,11 +73,10 @@ public class AsyncChannelWrapperSecure implements AsyncChannelWrapper {
 
     @Override
     public Future<Integer> read(ByteBuffer dst) {
-        WrapperFuture<Integer,Void> future = new WrapperFuture<>();
+        WrapperFuture<Integer, Void> future = new WrapperFuture<>();
 
         if (!reading.compareAndSet(false, true)) {
-            throw new IllegalStateException(sm.getString(
-                    "asyncChannelWrapperSecure.concurrentRead"));
+            throw new IllegalStateException(sm.getString("asyncChannelWrapperSecure.concurrentRead"));
         }
 
         ReadTask readTask = new ReadTask(dst, future);
@@ -92,15 +87,12 @@ public class AsyncChannelWrapperSecure implements AsyncChannelWrapper {
     }
 
     @Override
-    public <B,A extends B> void read(ByteBuffer dst, A attachment,
-            CompletionHandler<Integer,B> handler) {
+    public <B, A extends B> void read(ByteBuffer dst, A attachment, CompletionHandler<Integer, B> handler) {
 
-        WrapperFuture<Integer,B> future =
-                new WrapperFuture<>(handler, attachment);
+        WrapperFuture<Integer, B> future = new WrapperFuture<>(handler, attachment);
 
         if (!reading.compareAndSet(false, true)) {
-            throw new IllegalStateException(sm.getString(
-                    "asyncChannelWrapperSecure.concurrentRead"));
+            throw new IllegalStateException(sm.getString("asyncChannelWrapperSecure.concurrentRead"));
         }
 
         ReadTask readTask = new ReadTask(dst, future);
@@ -111,15 +103,13 @@ public class AsyncChannelWrapperSecure implements AsyncChannelWrapper {
     @Override
     public Future<Integer> write(ByteBuffer src) {
 
-        WrapperFuture<Long,Void> inner = new WrapperFuture<>();
+        WrapperFuture<Long, Void> inner = new WrapperFuture<>();
 
         if (!writing.compareAndSet(false, true)) {
-            throw new IllegalStateException(sm.getString(
-                    "asyncChannelWrapperSecure.concurrentWrite"));
+            throw new IllegalStateException(sm.getString("asyncChannelWrapperSecure.concurrentWrite"));
         }
 
-        WriteTask writeTask =
-                new WriteTask(new ByteBuffer[] {src}, 0, 1, inner);
+        WriteTask writeTask = new WriteTask(new ByteBuffer[] { src }, 0, 1, inner);
 
         executor.execute(writeTask);
 
@@ -128,16 +118,13 @@ public class AsyncChannelWrapperSecure implements AsyncChannelWrapper {
     }
 
     @Override
-    public <B,A extends B> void write(ByteBuffer[] srcs, int offset, int length,
-            long timeout, TimeUnit unit, A attachment,
-            CompletionHandler<Long,B> handler) {
+    public <B, A extends B> void write(ByteBuffer[] srcs, int offset, int length, long timeout, TimeUnit unit,
+            A attachment, CompletionHandler<Long, B> handler) {
 
-        WrapperFuture<Long,B> future =
-                new WrapperFuture<>(handler, attachment);
+        WrapperFuture<Long, B> future = new WrapperFuture<>(handler, attachment);
 
         if (!writing.compareAndSet(false, true)) {
-            throw new IllegalStateException(sm.getString(
-                    "asyncChannelWrapperSecure.concurrentWrite"));
+            throw new IllegalStateException(sm.getString("asyncChannelWrapperSecure.concurrentWrite"));
         }
 
         WriteTask writeTask = new WriteTask(srcs, offset, length, future);
@@ -158,7 +145,7 @@ public class AsyncChannelWrapperSecure implements AsyncChannelWrapper {
     @Override
     public Future<Void> handshake() throws SSLException {
 
-        WrapperFuture<Void,Void> wFuture = new WrapperFuture<>();
+        WrapperFuture<Void, Void> wFuture = new WrapperFuture<>();
 
         Thread t = new WebSocketSslHandshakeThread(wFuture);
         t.start();
@@ -178,10 +165,9 @@ public class AsyncChannelWrapperSecure implements AsyncChannelWrapper {
         private final ByteBuffer[] srcs;
         private final int offset;
         private final int length;
-        private final WrapperFuture<Long,?> future;
+        private final WrapperFuture<Long, ?> future;
 
-        WriteTask(ByteBuffer[] srcs, int offset, int length,
-                WrapperFuture<Long,?> future) {
+        WriteTask(ByteBuffer[] srcs, int offset, int length, WrapperFuture<Long, ?> future) {
             this.srcs = srcs;
             this.future = future;
             this.offset = offset;
@@ -209,8 +195,7 @@ public class AsyncChannelWrapperSecure implements AsyncChannelWrapper {
                         } else {
                             // Status.BUFFER_UNDERFLOW - only happens on unwrap
                             // Status.CLOSED - unexpected
-                            throw new IllegalStateException(sm.getString(
-                                    "asyncChannelWrapperSecure.statusWrap"));
+                            throw new IllegalStateException(sm.getString("asyncChannelWrapperSecure.statusWrap"));
                         }
 
                         // Check for tasks
@@ -227,8 +212,7 @@ public class AsyncChannelWrapperSecure implements AsyncChannelWrapper {
                         // Do the write
                         int toWrite = r.bytesProduced();
                         while (toWrite > 0) {
-                            Future<Integer> f =
-                                    socketChannel.write(socketWriteBuffer);
+                            Future<Integer> f = socketChannel.write(socketWriteBuffer);
                             Integer socketWrite = f.get();
                             toWrite -= socketWrite.intValue();
                         }
@@ -239,8 +223,7 @@ public class AsyncChannelWrapperSecure implements AsyncChannelWrapper {
                 if (writing.compareAndSet(true, false)) {
                     future.complete(Long.valueOf(written));
                 } else {
-                    future.fail(new IllegalStateException(sm.getString(
-                            "asyncChannelWrapperSecure.wrongStateWrite")));
+                    future.fail(new IllegalStateException(sm.getString("asyncChannelWrapperSecure.wrongStateWrite")));
                 }
             } catch (Exception e) {
                 writing.set(false);
@@ -253,9 +236,9 @@ public class AsyncChannelWrapperSecure implements AsyncChannelWrapper {
     private class ReadTask implements Runnable {
 
         private final ByteBuffer dest;
-        private final WrapperFuture<Integer,?> future;
+        private final WrapperFuture<Integer, ?> future;
 
-        ReadTask(ByteBuffer dest, WrapperFuture<Integer,?> future) {
+        ReadTask(ByteBuffer dest, WrapperFuture<Integer, ?> future) {
             this.dest = dest;
             this.future = future;
         }
@@ -308,16 +291,15 @@ public class AsyncChannelWrapperSecure implements AsyncChannelWrapper {
                             // buffer size required but an explicit exception is
                             // clearer.
                             if (reading.compareAndSet(true, false)) {
-                                throw new ReadBufferOverflowException(sslEngine.
-                                        getSession().getApplicationBufferSize());
+                                throw new ReadBufferOverflowException(
+                                        sslEngine.getSession().getApplicationBufferSize());
                             } else {
-                                future.fail(new IllegalStateException(sm.getString(
-                                        "asyncChannelWrapperSecure.wrongStateRead")));
+                                future.fail(new IllegalStateException(
+                                        sm.getString("asyncChannelWrapperSecure.wrongStateRead")));
                             }
                         } else {
                             // Status.CLOSED - unexpected
-                            throw new IllegalStateException(sm.getString(
-                                    "asyncChannelWrapperSecure.statusUnwrap"));
+                            throw new IllegalStateException(sm.getString("asyncChannelWrapperSecure.statusUnwrap"));
                         }
 
                         // Check for tasks
@@ -337,11 +319,10 @@ public class AsyncChannelWrapperSecure implements AsyncChannelWrapper {
                 if (reading.compareAndSet(true, false)) {
                     future.complete(Integer.valueOf(read));
                 } else {
-                    future.fail(new IllegalStateException(sm.getString(
-                            "asyncChannelWrapperSecure.wrongStateRead")));
+                    future.fail(new IllegalStateException(sm.getString("asyncChannelWrapperSecure.wrongStateRead")));
                 }
-            } catch (RuntimeException | ReadBufferOverflowException | SSLException | EOFException |
-                    ExecutionException | InterruptedException e) {
+            } catch (RuntimeException | ReadBufferOverflowException | SSLException | EOFException | ExecutionException
+                    | InterruptedException e) {
                 reading.set(false);
                 future.fail(e);
             }
@@ -351,12 +332,12 @@ public class AsyncChannelWrapperSecure implements AsyncChannelWrapper {
 
     private class WebSocketSslHandshakeThread extends Thread {
 
-        private final WrapperFuture<Void,Void> hFuture;
+        private final WrapperFuture<Void, Void> hFuture;
 
         private HandshakeStatus handshakeStatus;
         private Status resultStatus;
 
-        WebSocketSslHandshakeThread(WrapperFuture<Void,Void> hFuture) {
+        WebSocketSslHandshakeThread(WrapperFuture<Void, Void> hFuture) {
             this.hFuture = hFuture;
         }
 
@@ -372,30 +353,25 @@ public class AsyncChannelWrapperSecure implements AsyncChannelWrapper {
 
                 boolean handshaking = true;
 
-                while(handshaking) {
+                while (handshaking) {
                     switch (handshakeStatus) {
                         case NEED_WRAP: {
                             socketWriteBuffer.clear();
-                            SSLEngineResult r =
-                                    sslEngine.wrap(DUMMY, socketWriteBuffer);
+                            SSLEngineResult r = sslEngine.wrap(DUMMY, socketWriteBuffer);
                             checkResult(r, true);
                             socketWriteBuffer.flip();
-                            Future<Integer> fWrite =
-                                    socketChannel.write(socketWriteBuffer);
+                            Future<Integer> fWrite = socketChannel.write(socketWriteBuffer);
                             fWrite.get();
                             break;
                         }
                         case NEED_UNWRAP: {
                             socketReadBuffer.compact();
-                            if (socketReadBuffer.position() == 0 ||
-                                    resultStatus == Status.BUFFER_UNDERFLOW) {
-                                Future<Integer> fRead =
-                                        socketChannel.read(socketReadBuffer);
+                            if (socketReadBuffer.position() == 0 || resultStatus == Status.BUFFER_UNDERFLOW) {
+                                Future<Integer> fRead = socketChannel.read(socketReadBuffer);
                                 fRead.get();
                             }
                             socketReadBuffer.flip();
-                            SSLEngineResult r =
-                                    sslEngine.unwrap(socketReadBuffer, DUMMY);
+                            SSLEngineResult r = sslEngine.unwrap(socketReadBuffer, DUMMY);
                             checkResult(r, false);
                             break;
                         }
@@ -415,8 +391,8 @@ public class AsyncChannelWrapperSecure implements AsyncChannelWrapper {
                             // Don't expect to see this during a handshake
                         case NEED_UNWRAP_AGAIN: {
                             // Only applies to DLTS
-                            throw new SSLException(sm.getString(
-                                    "asyncChannelWrapperSecure.unexpectedHandshakeState", handshakeStatus));
+                            throw new SSLException(sm.getString("asyncChannelWrapperSecure.unexpectedHandshakeState",
+                                    handshakeStatus));
                         }
                     }
                 }
@@ -428,16 +404,13 @@ public class AsyncChannelWrapperSecure implements AsyncChannelWrapper {
             hFuture.complete(null);
         }
 
-        private void checkResult(SSLEngineResult result, boolean wrap)
-                throws SSLException {
+        private void checkResult(SSLEngineResult result, boolean wrap) throws SSLException {
 
             handshakeStatus = result.getHandshakeStatus();
             resultStatus = result.getStatus();
 
-            if (resultStatus != Status.OK &&
-                    (wrap || resultStatus != Status.BUFFER_UNDERFLOW)) {
-                throw new SSLException(
-                        sm.getString("asyncChannelWrapperSecure.check.notOk", resultStatus));
+            if (resultStatus != Status.OK && (wrap || resultStatus != Status.BUFFER_UNDERFLOW)) {
+                throw new SSLException(sm.getString("asyncChannelWrapperSecure.check.notOk", resultStatus));
             }
             if (wrap && result.bytesConsumed() != 0) {
                 throw new SSLException(sm.getString("asyncChannelWrapperSecure.check.wrap"));
@@ -449,9 +422,9 @@ public class AsyncChannelWrapperSecure implements AsyncChannelWrapper {
     }
 
 
-    private static class WrapperFuture<T,A> implements Future<T> {
+    private static class WrapperFuture<T, A> implements Future<T> {
 
-        private final CompletionHandler<T,A> handler;
+        private final CompletionHandler<T, A> handler;
         private final A attachment;
 
         private volatile T result = null;
@@ -462,7 +435,7 @@ public class AsyncChannelWrapperSecure implements AsyncChannelWrapper {
             this(null, null);
         }
 
-        WrapperFuture(CompletionHandler<T,A> handler, A attachment) {
+        WrapperFuture(CompletionHandler<T, A> handler, A attachment) {
             this.handler = handler;
             this.attachment = attachment;
         }
@@ -510,9 +483,7 @@ public class AsyncChannelWrapperSecure implements AsyncChannelWrapper {
         }
 
         @Override
-        public T get(long timeout, TimeUnit unit)
-                throws InterruptedException, ExecutionException,
-                TimeoutException {
+        public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
             boolean latchResult = completionLatch.await(timeout, unit);
             if (latchResult == false) {
                 throw new TimeoutException();
@@ -551,20 +522,17 @@ public class AsyncChannelWrapperSecure implements AsyncChannelWrapper {
         public Integer get() throws InterruptedException, ExecutionException {
             Long result = wrapped.get();
             if (result.longValue() > Integer.MAX_VALUE) {
-                throw new ExecutionException(sm.getString(
-                        "asyncChannelWrapperSecure.tooBig", result), null);
+                throw new ExecutionException(sm.getString("asyncChannelWrapperSecure.tooBig", result), null);
             }
             return Integer.valueOf(result.intValue());
         }
 
         @Override
         public Integer get(long timeout, TimeUnit unit)
-                throws InterruptedException, ExecutionException,
-                TimeoutException {
+                throws InterruptedException, ExecutionException, TimeoutException {
             Long result = wrapped.get(timeout, unit);
             if (result.longValue() > Integer.MAX_VALUE) {
-                throw new ExecutionException(sm.getString(
-                        "asyncChannelWrapperSecure.tooBig", result), null);
+                throw new ExecutionException(sm.getString("asyncChannelWrapperSecure.tooBig", result), null);
             }
             return Integer.valueOf(result.intValue());
         }

==================================================
AuthenticationType.java
index 7ac8d37244..9efc2d0d29 100644
--- a/java/org/apache/tomcat/websocket/AuthenticationException.java
+++ b/java/org/apache/tomcat/websocket/AuthenticationException.java
@@ -17,8 +17,7 @@
 package org.apache.tomcat.websocket;
 
 /**
- * Exception thrown on authentication error connecting to a remote
- * websocket endpoint.
+ * Exception thrown on authentication error connecting to a remote websocket endpoint.
  */
 public class AuthenticationException extends Exception {
 
@@ -26,6 +25,7 @@ public class AuthenticationException extends Exception {
 
     /**
      * Create authentication exception.
+     *
      * @param message the error message
      */
     public AuthenticationException(String message) {

==================================================
Authenticator.java
index 32d64334d5..740a956e09 100644
--- a/java/org/apache/tomcat/websocket/AuthenticationType.java
+++ b/java/org/apache/tomcat/websocket/AuthenticationType.java
@@ -18,16 +18,12 @@ package org.apache.tomcat.websocket;
 
 public enum AuthenticationType {
 
-    WWW(Constants.AUTHORIZATION_HEADER_NAME,
-            Constants.WWW_AUTHENTICATE_HEADER_NAME,
-            Constants.WS_AUTHENTICATION_USER_NAME,
-            Constants.WS_AUTHENTICATION_PASSWORD,
+    WWW(Constants.AUTHORIZATION_HEADER_NAME, Constants.WWW_AUTHENTICATE_HEADER_NAME,
+            Constants.WS_AUTHENTICATION_USER_NAME, Constants.WS_AUTHENTICATION_PASSWORD,
             Constants.WS_AUTHENTICATION_REALM),
 
-    PROXY(Constants.PROXY_AUTHORIZATION_HEADER_NAME,
-            Constants.PROXY_AUTHENTICATE_HEADER_NAME,
-            Constants.WS_AUTHENTICATION_PROXY_USER_NAME,
-            Constants.WS_AUTHENTICATION_PROXY_PASSWORD,
+    PROXY(Constants.PROXY_AUTHORIZATION_HEADER_NAME, Constants.PROXY_AUTHENTICATE_HEADER_NAME,
+            Constants.WS_AUTHENTICATION_PROXY_USER_NAME, Constants.WS_AUTHENTICATION_PROXY_PASSWORD,
             Constants.WS_AUTHENTICATION_PROXY_REALM);
 
     private final String authorizationHeaderName;

==================================================
AuthenticatorFactory.java
index 2766330cb3..43979ea899 100644
--- a/java/org/apache/tomcat/websocket/Authenticator.java
+++ b/java/org/apache/tomcat/websocket/Authenticator.java
@@ -36,13 +36,12 @@ public abstract class Authenticator {
     /**
      * Generate the authorization header value that will be sent to the server.
      *
-     * @param requestUri            The request URI
-     * @param authenticateHeader    The server authentication header received
-     * @param userName              The user name
-     * @param userPassword          The user password
-     * @param userRealm             The realm for which the provided user name
-     *                                  and password are valid. {@code null} to
-     *                                  indicate all realms.
+     * @param requestUri         The request URI
+     * @param authenticateHeader The server authentication header received
+     * @param userName           The user name
+     * @param userPassword       The user password
+     * @param userRealm          The realm for which the provided user name and password are valid. {@code null} to
+     *                               indicate all realms.
      *
      * @return The generated authorization header value
      *
@@ -110,9 +109,8 @@ public abstract class Authenticator {
         }
 
         /*
-         * User has configured a realm. Only allow authentication to proceed if
-         * the realm in the authentication challenge matches (both BASIC and
-         * DIGEST are required to include a realm).
+         * User has configured a realm. Only allow authentication to proceed if the realm in the authentication
+         * challenge matches (both BASIC and DIGEST are required to include a realm).
          */
         if (serverRealm != null) {
             serverRealm = serverRealm.trim();

==================================================
BackgroundProcessManager.java
index 1480d6229c..9718db43a0 100644
--- a/java/org/apache/tomcat/websocket/AuthenticatorFactory.java
+++ b/java/org/apache/tomcat/websocket/AuthenticatorFactory.java
@@ -19,14 +19,15 @@ package org.apache.tomcat.websocket;
 import java.util.ServiceLoader;
 
 /**
- * Utility method to return the appropriate authenticator according to
- * the scheme that the server uses.
+ * Utility method to return the appropriate authenticator according to the scheme that the server uses.
  */
 public class AuthenticatorFactory {
 
     /**
      * Return a new authenticator instance.
+     *
      * @param authScheme The scheme used
+     *
      * @return the authenticator
      */
     public static Authenticator getAuthenticator(String authScheme) {
@@ -34,17 +35,17 @@ public class AuthenticatorFactory {
         Authenticator auth = null;
         switch (authScheme.toLowerCase()) {
 
-        case BasicAuthenticator.schemeName:
-            auth = new BasicAuthenticator();
-            break;
+            case BasicAuthenticator.schemeName:
+                auth = new BasicAuthenticator();
+                break;
 
-        case DigestAuthenticator.schemeName:
-            auth = new DigestAuthenticator();
-            break;
+            case DigestAuthenticator.schemeName:
+                auth = new DigestAuthenticator();
+                break;
 
-        default:
-            auth = loadAuthenticators(authScheme);
-            break;
+            default:
+                auth = loadAuthenticators(authScheme);
+                break;
         }
 
         return auth;

==================================================
BasicAuthenticator.java
index f7dedb8db0..ef70dd28b8 100644
--- a/java/org/apache/tomcat/websocket/BackgroundProcessManager.java
+++ b/java/org/apache/tomcat/websocket/BackgroundProcessManager.java
@@ -25,16 +25,13 @@ import org.apache.tomcat.util.ExceptionUtils;
 import org.apache.tomcat.util.res.StringManager;
 
 /**
- * Provides a background processing mechanism that triggers roughly once a
- * second. The class maintains a thread that only runs when there is at least
- * one instance of {@link BackgroundProcess} registered.
+ * Provides a background processing mechanism that triggers roughly once a second. The class maintains a thread that
+ * only runs when there is at least one instance of {@link BackgroundProcess} registered.
  */
 public class BackgroundProcessManager {
 
-    private final Log log =
-            LogFactory.getLog(BackgroundProcessManager.class);
-    private static final StringManager sm =
-            StringManager.getManager(BackgroundProcessManager.class);
+    private final Log log = LogFactory.getLog(BackgroundProcessManager.class);
+    private static final StringManager sm = StringManager.getManager(BackgroundProcessManager.class);
     private static final BackgroundProcessManager instance;
 
 
@@ -60,8 +57,7 @@ public class BackgroundProcessManager {
         synchronized (processesLock) {
             if (processes.size() == 0) {
                 wsBackgroundThread = new WsBackgroundThread(this);
-                wsBackgroundThread.setContextClassLoader(
-                        this.getClass().getClassLoader());
+                wsBackgroundThread.setContextClassLoader(this.getClass().getClassLoader());
                 wsBackgroundThread.setDaemon(true);
                 wsBackgroundThread.start();
             }
@@ -91,8 +87,7 @@ public class BackgroundProcessManager {
                 process.backgroundProcess();
             } catch (Throwable t) {
                 ExceptionUtils.handleThrowable(t);
-                log.error(sm.getString(
-                        "backgroundProcessManager.processFailed"), t);
+                log.error(sm.getString("backgroundProcessManager.processFailed"), t);
             }
         }
     }

==================================================
ClientEndpointHolder.java
index d993ccf40d..c8e63859f9 100644
--- a/java/org/apache/tomcat/websocket/BasicAuthenticator.java
+++ b/java/org/apache/tomcat/websocket/BasicAuthenticator.java
@@ -44,8 +44,7 @@ public class BasicAuthenticator extends Authenticator {
         String userPass = userName + ":" + userPassword;
         Charset charset;
 
-        if (parameterMap.get(charsetparam) != null
-                && parameterMap.get(charsetparam).equalsIgnoreCase("UTF-8")) {
+        if (parameterMap.get(charsetparam) != null && parameterMap.get(charsetparam).equalsIgnoreCase("UTF-8")) {
             charset = StandardCharsets.UTF_8;
         } else {
             charset = StandardCharsets.ISO_8859_1;

==================================================
Constants.java
index d3334d1413..028b922410 100644
--- a/java/org/apache/tomcat/websocket/ClientEndpointHolder.java
+++ b/java/org/apache/tomcat/websocket/ClientEndpointHolder.java
@@ -23,5 +23,6 @@ import org.apache.tomcat.InstanceManager;
 
 public interface ClientEndpointHolder {
     String getClassName();
+
     Endpoint getInstance(InstanceManager instanceManager) throws DeploymentException;
 }

==================================================
DecoderEntry.java
index 55deb20c0b..7ec14131bd 100644
--- a/java/org/apache/tomcat/websocket/Constants.java
+++ b/java/org/apache/tomcat/websocket/Constants.java
@@ -41,24 +41,20 @@ public class Constants {
     static final byte INTERNAL_OPCODE_FLUSH = 0x18;
 
     // Buffers
-    static final int DEFAULT_BUFFER_SIZE = Integer.getInteger(
-            "org.apache.tomcat.websocket.DEFAULT_BUFFER_SIZE", 8 * 1024)
-            .intValue();
+    static final int DEFAULT_BUFFER_SIZE = Integer
+            .getInteger("org.apache.tomcat.websocket.DEFAULT_BUFFER_SIZE", 8 * 1024).intValue();
 
     // Client connection
     /**
-     * Property name to set to configure the timeout (in milliseconds) when
-     * establishing a WebSocket connection to server. The default is
-     * {@link #IO_TIMEOUT_MS_DEFAULT}.
+     * Property name to set to configure the timeout (in milliseconds) when establishing a WebSocket connection to
+     * server. The default is {@link #IO_TIMEOUT_MS_DEFAULT}.
      */
-    public static final String IO_TIMEOUT_MS_PROPERTY =
-            "org.apache.tomcat.websocket.IO_TIMEOUT_MS";
+    public static final String IO_TIMEOUT_MS_PROPERTY = "org.apache.tomcat.websocket.IO_TIMEOUT_MS";
     public static final long IO_TIMEOUT_MS_DEFAULT = 5000;
 
     // RFC 2068 recommended a limit of 5
     // Most browsers have a default limit of 20
-    public static final String MAX_REDIRECTIONS_PROPERTY =
-            "org.apache.tomcat.websocket.MAX_REDIRECTIONS";
+    public static final String MAX_REDIRECTIONS_PROPERTY = "org.apache.tomcat.websocket.MAX_REDIRECTIONS";
     public static final int MAX_REDIRECTIONS_DEFAULT = 20;
 
     // HTTP upgrade header names and values
@@ -90,12 +86,11 @@ public class Constants {
     public static final int PROXY_AUTHENTICATION_REQUIRED = 407;
 
     // Configuration for Origin header in client
-    static final String DEFAULT_ORIGIN_HEADER_VALUE =
-            System.getProperty("org.apache.tomcat.websocket.DEFAULT_ORIGIN_HEADER_VALUE");
+    static final String DEFAULT_ORIGIN_HEADER_VALUE = System
+            .getProperty("org.apache.tomcat.websocket.DEFAULT_ORIGIN_HEADER_VALUE");
 
     // Configuration for blocking sends
-    public static final String BLOCKING_SEND_TIMEOUT_PROPERTY =
-            "org.apache.tomcat.websocket.BLOCKING_SEND_TIMEOUT";
+    public static final String BLOCKING_SEND_TIMEOUT_PROPERTY = "org.apache.tomcat.websocket.BLOCKING_SEND_TIMEOUT";
     // Milliseconds so this is 20 seconds
     public static final long DEFAULT_BLOCKING_SEND_TIMEOUT = 20 * 1000;
 
@@ -106,20 +101,16 @@ public class Constants {
     public static final String WRITE_IDLE_TIMEOUT_MS = "org.apache.tomcat.websocket.WRITE_IDLE_TIMEOUT_MS";
 
     // Configuration for background processing checks intervals
-    static final int DEFAULT_PROCESS_PERIOD = Integer.getInteger(
-            "org.apache.tomcat.websocket.DEFAULT_PROCESS_PERIOD", 10)
-            .intValue();
+    static final int DEFAULT_PROCESS_PERIOD = Integer
+            .getInteger("org.apache.tomcat.websocket.DEFAULT_PROCESS_PERIOD", 10).intValue();
 
     public static final String WS_AUTHENTICATION_USER_NAME = "org.apache.tomcat.websocket.WS_AUTHENTICATION_USER_NAME";
     public static final String WS_AUTHENTICATION_PASSWORD = "org.apache.tomcat.websocket.WS_AUTHENTICATION_PASSWORD";
     public static final String WS_AUTHENTICATION_REALM = "org.apache.tomcat.websocket.WS_AUTHENTICATION_REALM";
 
-    public static final String WS_AUTHENTICATION_PROXY_USER_NAME =
-            "org.apache.tomcat.websocket.WS_AUTHENTICATION_PROXY_USER_NAME";
-    public static final String WS_AUTHENTICATION_PROXY_PASSWORD =
-            "org.apache.tomcat.websocket.WS_AUTHENTICATION_PROXY_PASSWORD";
-    public static final String WS_AUTHENTICATION_PROXY_REALM =
-            "org.apache.tomcat.websocket.WS_AUTHENTICATION_PROXY_REALM";
+    public static final String WS_AUTHENTICATION_PROXY_USER_NAME = "org.apache.tomcat.websocket.WS_AUTHENTICATION_PROXY_USER_NAME";
+    public static final String WS_AUTHENTICATION_PROXY_PASSWORD = "org.apache.tomcat.websocket.WS_AUTHENTICATION_PROXY_PASSWORD";
+    public static final String WS_AUTHENTICATION_PROXY_REALM = "org.apache.tomcat.websocket.WS_AUTHENTICATION_PROXY_REALM";
 
     public static final List<Extension> INSTALLED_EXTENSIONS;
 

==================================================
DigestAuthenticator.java
index 3af5aa59a8..ed81e9999c 100644
--- a/java/org/apache/tomcat/websocket/DecoderEntry.java
+++ b/java/org/apache/tomcat/websocket/DecoderEntry.java
@@ -23,8 +23,7 @@ public class DecoderEntry {
     private final Class<?> clazz;
     private final Class<? extends Decoder> decoderClazz;
 
-    public DecoderEntry(Class<?> clazz,
-            Class<? extends Decoder> decoderClazz) {
+    public DecoderEntry(Class<?> clazz, Class<? extends Decoder> decoderClazz) {
         this.clazz = clazz;
         this.decoderClazz = decoderClazz;
     }

==================================================
FutureToSendHandler.java
index 000f01e445..ac9f2f7040 100644
--- a/java/org/apache/tomcat/websocket/DigestAuthenticator.java
+++ b/java/org/apache/tomcat/websocket/DigestAuthenticator.java
@@ -56,7 +56,7 @@ public class DigestAuthenticator extends Authenticator {
 
         if (!messageQop.isEmpty()) {
             if (cnonceGenerator == null) {
-                synchronized(cnonceGeneratorLock) {
+                synchronized (cnonceGeneratorLock) {
                     if (cnonceGenerator == null) {
                         cnonceGenerator = new SecureRandom();
                     }
@@ -74,13 +74,13 @@ public class DigestAuthenticator extends Authenticator {
         challenge.append("uri=\"" + requestUri + "\",");
 
         try {
-            challenge.append("response=\"" + calculateRequestDigest(requestUri, userName, userPassword,
-                    realm, nonce, messageQop, algorithm) + "\",");
+            challenge.append("response=\"" +
+                    calculateRequestDigest(requestUri, userName, userPassword, realm, nonce, messageQop, algorithm) +
+                    "\",");
         }
 
         catch (NoSuchAlgorithmException e) {
-            throw new AuthenticationException(
-                    "Unable to generate request digest " + e.getMessage());
+            throw new AuthenticationException("Unable to generate request digest " + e.getMessage());
         }
 
         challenge.append("algorithm=" + algorithm + ",");
@@ -96,9 +96,8 @@ public class DigestAuthenticator extends Authenticator {
 
     }
 
-    private String calculateRequestDigest(String requestUri, String userName, String password,
-            String realm, String nonce, String qop, String algorithm)
-            throws NoSuchAlgorithmException {
+    private String calculateRequestDigest(String requestUri, String userName, String password, String realm,
+            String nonce, String qop, String algorithm) throws NoSuchAlgorithmException {
 
         StringBuilder preDigest = new StringBuilder();
         String A1;
@@ -110,9 +109,8 @@ public class DigestAuthenticator extends Authenticator {
         }
 
         /*
-         * If the "qop" value is "auth-int", then A2 is: A2 = Method ":"
-         * digest-uri-value ":" H(entity-body) since we do not have an entity-body, A2 =
-         * Method ":" digest-uri-value for auth and auth_int
+         * If the "qop" value is "auth-int", then A2 is: A2 = Method ":" digest-uri-value ":" H(entity-body) since we do
+         * not have an entity-body, A2 = Method ":" digest-uri-value for auth and auth_int
          */
         String A2 = "GET:" + requestUri;
 

==================================================
MessageHandlerResult.java
index 7940b419a6..17a01d3c87 100644
--- a/java/org/apache/tomcat/websocket/FutureToSendHandler.java
+++ b/java/org/apache/tomcat/websocket/FutureToSendHandler.java
@@ -74,8 +74,7 @@ class FutureToSendHandler implements Future<Void>, SendHandler {
     }
 
     @Override
-    public Void get() throws InterruptedException,
-            ExecutionException {
+    public Void get() throws InterruptedException, ExecutionException {
         try {
             wsSession.registerFuture(this);
             latch.await();
@@ -89,9 +88,7 @@ class FutureToSendHandler implements Future<Void>, SendHandler {
     }
 
     @Override
-    public Void get(long timeout, TimeUnit unit)
-            throws InterruptedException, ExecutionException,
-            TimeoutException {
+    public Void get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
         boolean retval = false;
         try {
             wsSession.registerFuture(this);
@@ -101,8 +98,8 @@ class FutureToSendHandler implements Future<Void>, SendHandler {
 
         }
         if (retval == false) {
-            throw new TimeoutException(sm.getString("futureToSendHandler.timeout",
-                    Long.valueOf(timeout), unit.toString().toLowerCase()));
+            throw new TimeoutException(
+                    sm.getString("futureToSendHandler.timeout", Long.valueOf(timeout), unit.toString().toLowerCase()));
         }
         if (result.get().getException() != null) {
             throw new ExecutionException(result.get().getException());

==================================================
MessagePart.java
index 2f6a938871..f989117a81 100644
--- a/java/org/apache/tomcat/websocket/MessageHandlerResult.java
+++ b/java/org/apache/tomcat/websocket/MessageHandlerResult.java
@@ -24,8 +24,7 @@ public class MessageHandlerResult {
     private final MessageHandlerResultType type;
 
 
-    public MessageHandlerResult(MessageHandler handler,
-            MessageHandlerResultType type) {
+    public MessageHandlerResult(MessageHandler handler, MessageHandlerResultType type) {
         this.handler = handler;
         this.type = type;
     }

==================================================
PerMessageDeflate.java
index 44b7629041..f7b5af92e8 100644
--- a/java/org/apache/tomcat/websocket/MessagePart.java
+++ b/java/org/apache/tomcat/websocket/MessagePart.java
@@ -29,9 +29,8 @@ class MessagePart {
     private volatile SendHandler endHandler;
     private final long blockingWriteTimeoutExpiry;
 
-    MessagePart( boolean fin, int rsv, byte opCode, ByteBuffer payload,
-            SendHandler intermediateHandler, SendHandler endHandler,
-            long blockingWriteTimeoutExpiry) {
+    MessagePart(boolean fin, int rsv, byte opCode, ByteBuffer payload, SendHandler intermediateHandler,
+            SendHandler endHandler, long blockingWriteTimeoutExpiry) {
         this.fin = fin;
         this.rsv = rsv;
         this.opCode = opCode;
@@ -80,4 +79,3 @@ class MessagePart {
     }
 }
 
-

==================================================
Transformation.java
index a96da9083a..482c5c1d2d 100644
--- a/java/org/apache/tomcat/websocket/PerMessageDeflate.java
+++ b/java/org/apache/tomcat/websocket/PerMessageDeflate.java
@@ -40,7 +40,7 @@ public class PerMessageDeflate implements Transformation {
     private static final String CLIENT_MAX_WINDOW_BITS = "client_max_window_bits";
 
     private static final int RSV_BITMASK = 0b100;
-    private static final byte[] EOM_BYTES = new byte[] {0, 0, -1, -1};
+    private static final byte[] EOM_BYTES = new byte[] { 0, 0, -1, -1 };
 
     public static final String NAME = "permessage-deflate";
 
@@ -76,27 +76,23 @@ public class PerMessageDeflate implements Transformation {
                         serverContextTakeover = false;
                     } else {
                         // Duplicate definition
-                        throw new IllegalArgumentException(sm.getString(
-                                "perMessageDeflate.duplicateParameter",
-                                SERVER_NO_CONTEXT_TAKEOVER ));
+                        throw new IllegalArgumentException(
+                                sm.getString("perMessageDeflate.duplicateParameter", SERVER_NO_CONTEXT_TAKEOVER));
                     }
                 } else if (CLIENT_NO_CONTEXT_TAKEOVER.equals(param.getName())) {
                     if (clientContextTakeover) {
                         clientContextTakeover = false;
                     } else {
                         // Duplicate definition
-                        throw new IllegalArgumentException(sm.getString(
-                                "perMessageDeflate.duplicateParameter",
-                                CLIENT_NO_CONTEXT_TAKEOVER ));
+                        throw new IllegalArgumentException(
+                                sm.getString("perMessageDeflate.duplicateParameter", CLIENT_NO_CONTEXT_TAKEOVER));
                     }
                 } else if (SERVER_MAX_WINDOW_BITS.equals(param.getName())) {
                     if (serverMaxWindowBits == -1) {
                         serverMaxWindowBits = Integer.parseInt(param.getValue());
                         if (serverMaxWindowBits < 8 || serverMaxWindowBits > 15) {
-                            throw new IllegalArgumentException(sm.getString(
-                                    "perMessageDeflate.invalidWindowSize",
-                                    SERVER_MAX_WINDOW_BITS,
-                                    Integer.valueOf(serverMaxWindowBits)));
+                            throw new IllegalArgumentException(sm.getString("perMessageDeflate.invalidWindowSize",
+                                    SERVER_MAX_WINDOW_BITS, Integer.valueOf(serverMaxWindowBits)));
                         }
                         // Java SE API (as of Java 11) does not expose the API to
                         // control the Window size. It is effectively hard-coded
@@ -111,9 +107,8 @@ public class PerMessageDeflate implements Transformation {
                         }
                     } else {
                         // Duplicate definition
-                        throw new IllegalArgumentException(sm.getString(
-                                "perMessageDeflate.duplicateParameter",
-                                SERVER_MAX_WINDOW_BITS ));
+                        throw new IllegalArgumentException(
+                                sm.getString("perMessageDeflate.duplicateParameter", SERVER_MAX_WINDOW_BITS));
                     }
                 } else if (CLIENT_MAX_WINDOW_BITS.equals(param.getName())) {
                     if (clientMaxWindowBits == -1) {
@@ -126,10 +121,8 @@ public class PerMessageDeflate implements Transformation {
                         } else {
                             clientMaxWindowBits = Integer.parseInt(param.getValue());
                             if (clientMaxWindowBits < 8 || clientMaxWindowBits > 15) {
-                                throw new IllegalArgumentException(sm.getString(
-                                        "perMessageDeflate.invalidWindowSize",
-                                        CLIENT_MAX_WINDOW_BITS,
-                                        Integer.valueOf(clientMaxWindowBits)));
+                                throw new IllegalArgumentException(sm.getString("perMessageDeflate.invalidWindowSize",
+                                        CLIENT_MAX_WINDOW_BITS, Integer.valueOf(clientMaxWindowBits)));
                             }
                         }
                         // Java SE API (as of Java 11) does not expose the API to
@@ -145,19 +138,18 @@ public class PerMessageDeflate implements Transformation {
                         }
                     } else {
                         // Duplicate definition
-                        throw new IllegalArgumentException(sm.getString(
-                                "perMessageDeflate.duplicateParameter",
-                                CLIENT_MAX_WINDOW_BITS ));
+                        throw new IllegalArgumentException(
+                                sm.getString("perMessageDeflate.duplicateParameter", CLIENT_MAX_WINDOW_BITS));
                     }
                 } else {
                     // Unknown parameter
-                    throw new IllegalArgumentException(sm.getString(
-                            "perMessageDeflate.unknownParameter", param.getName()));
+                    throw new IllegalArgumentException(
+                            sm.getString("perMessageDeflate.unknownParameter", param.getName()));
                 }
             }
             if (ok) {
-                return new PerMessageDeflate(serverContextTakeover, serverMaxWindowBits,
-                        clientContextTakeover, clientMaxWindowBits, isServer);
+                return new PerMessageDeflate(serverContextTakeover, serverMaxWindowBits, clientContextTakeover,
+                        clientMaxWindowBits, isServer);
             }
         }
         // Failed to negotiate agreeable terms
@@ -165,8 +157,8 @@ public class PerMessageDeflate implements Transformation {
     }
 
 
-    private PerMessageDeflate(boolean serverContextTakeover, int serverMaxWindowBits,
-            boolean clientContextTakeover, int clientMaxWindowBits, boolean isServer) {
+    private PerMessageDeflate(boolean serverContextTakeover, int serverMaxWindowBits, boolean clientContextTakeover,
+            int clientMaxWindowBits, boolean isServer) {
         this.serverContextTakeover = serverContextTakeover;
         this.serverMaxWindowBits = serverMaxWindowBits;
         this.clientContextTakeover = clientContextTakeover;
@@ -176,8 +168,7 @@ public class PerMessageDeflate implements Transformation {
 
 
     @Override
-    public TransformationResult getMoreData(byte opCode, boolean fin, int rsv, ByteBuffer dest)
-            throws IOException {
+    public TransformationResult getMoreData(byte opCode, boolean fin, int rsv, ByteBuffer dest) throws IOException {
         // Control frames are never compressed and may appear in the middle of
         // a WebSocket method. Pass them straight through.
         if (Util.isControl(opCode)) {
@@ -200,8 +191,7 @@ public class PerMessageDeflate implements Transformation {
         while (dest.remaining() > 0 || usedEomBytes) {
             // Space available in destination. Try and fill it.
             try {
-                written = inflater.inflate(
-                        dest.array(), dest.arrayOffset() + dest.position(), dest.remaining());
+                written = inflater.inflate(dest.array(), dest.arrayOffset() + dest.position(), dest.remaining());
             } catch (DataFormatException e) {
                 throw new IOException(sm.getString("perMessageDeflate.deflateFailed"), e);
             } catch (NullPointerException e) {
@@ -209,15 +199,14 @@ public class PerMessageDeflate implements Transformation {
             }
             dest.position(dest.position() + written);
 
-            if (inflater.needsInput() && !usedEomBytes ) {
+            if (inflater.needsInput() && !usedEomBytes) {
                 readBuffer.clear();
                 TransformationResult nextResult = next.getMoreData(opCode, fin, (rsv ^ RSV_BITMASK), readBuffer);
                 inflater.setInput(readBuffer.array(), readBuffer.arrayOffset(), readBuffer.position());
                 if (dest.hasRemaining()) {
                     if (TransformationResult.UNDERFLOW.equals(nextResult)) {
                         return nextResult;
-                    } else if (TransformationResult.END_OF_FRAME.equals(nextResult) &&
-                            readBuffer.position() == 0) {
+                    } else if (TransformationResult.END_OF_FRAME.equals(nextResult) && readBuffer.position() == 0) {
                         if (fin) {
                             inflater.setInput(EOM_BYTES);
                             usedEomBytes = true;
@@ -232,8 +221,7 @@ public class PerMessageDeflate implements Transformation {
                     usedEomBytes = true;
                 }
             } else if (written == 0) {
-                if (fin && (isServer && !clientContextTakeover ||
-                        !isServer && !serverContextTakeover)) {
+                if (fin && (isServer && !clientContextTakeover || !isServer && !serverContextTakeover)) {
                     try {
                         inflater.reset();
                     } catch (NullPointerException e) {
@@ -284,15 +272,13 @@ public class PerMessageDeflate implements Transformation {
             params.add(new WsExtensionParameter(SERVER_NO_CONTEXT_TAKEOVER, null));
         }
         if (serverMaxWindowBits != -1) {
-            params.add(new WsExtensionParameter(SERVER_MAX_WINDOW_BITS,
-                    Integer.toString(serverMaxWindowBits)));
+            params.add(new WsExtensionParameter(SERVER_MAX_WINDOW_BITS, Integer.toString(serverMaxWindowBits)));
         }
         if (!clientContextTakeover) {
             params.add(new WsExtensionParameter(CLIENT_NO_CONTEXT_TAKEOVER, null));
         }
         if (clientMaxWindowBits != -1) {
-            params.add(new WsExtensionParameter(CLIENT_MAX_WINDOW_BITS,
-                    Integer.toString(clientMaxWindowBits)));
+            params.add(new WsExtensionParameter(CLIENT_MAX_WINDOW_BITS, Integer.toString(clientMaxWindowBits)));
         }
 
         return result;
@@ -341,8 +327,7 @@ public class PerMessageDeflate implements Transformation {
             } else {
                 List<MessagePart> compressedParts = new ArrayList<>();
                 ByteBuffer uncompressedPayload = uncompressedPart.getPayload();
-                SendHandler uncompressedIntermediateHandler =
-                        uncompressedPart.getIntermediateHandler();
+                SendHandler uncompressedIntermediateHandler = uncompressedPart.getIntermediateHandler();
 
                 deflater.setInput(uncompressedPayload.array(),
                         uncompressedPayload.arrayOffset() + uncompressedPayload.position(),
@@ -388,29 +373,29 @@ public class PerMessageDeflate implements Transformation {
                     if (fin && !full && needsInput) {
                         // End of compressed message. Drop EOM bytes and output.
                         compressedPayload.limit(compressedPayload.limit() - EOM_BYTES.length);
-                        compressedPart = new MessagePart(true, getRsv(uncompressedPart),
-                                opCode, compressedPayload, uncompressedIntermediateHandler,
-                                uncompressedIntermediateHandler, blockingWriteTimeoutExpiry);
+                        compressedPart = new MessagePart(true, getRsv(uncompressedPart), opCode, compressedPayload,
+                                uncompressedIntermediateHandler, uncompressedIntermediateHandler,
+                                blockingWriteTimeoutExpiry);
                         deflateRequired = false;
                         startNewMessage();
                     } else if (full && !needsInput) {
                         // Write buffer full and input message not fully read.
                         // Output and start new compressed part.
-                        compressedPart = new MessagePart(false, getRsv(uncompressedPart),
-                                opCode, compressedPayload, uncompressedIntermediateHandler,
-                                uncompressedIntermediateHandler, blockingWriteTimeoutExpiry);
+                        compressedPart = new MessagePart(false, getRsv(uncompressedPart), opCode, compressedPayload,
+                                uncompressedIntermediateHandler, uncompressedIntermediateHandler,
+                                blockingWriteTimeoutExpiry);
                     } else if (!fin && full && needsInput) {
                         // Write buffer full and input message not fully read.
                         // Output and get more data.
-                        compressedPart = new MessagePart(false, getRsv(uncompressedPart),
-                                opCode, compressedPayload, uncompressedIntermediateHandler,
-                                uncompressedIntermediateHandler, blockingWriteTimeoutExpiry);
+                        compressedPart = new MessagePart(false, getRsv(uncompressedPart), opCode, compressedPayload,
+                                uncompressedIntermediateHandler, uncompressedIntermediateHandler,
+                                blockingWriteTimeoutExpiry);
                         deflateRequired = false;
                     } else if (fin && full && needsInput) {
                         // Write buffer full. Input fully read. Deflater may be
                         // in one of four states:
                         // - output complete (just happened to align with end of
-                        //   buffer
+                        // buffer
                         // - in middle of EOM bytes
                         // - about to write EOM bytes
                         // - more data to write
@@ -423,8 +408,7 @@ public class PerMessageDeflate implements Transformation {
                         if (eomBufferWritten < EOM_BUFFER.length) {
                             // EOM has just been completed
                             compressedPayload.limit(compressedPayload.limit() - EOM_BYTES.length + eomBufferWritten);
-                            compressedPart = new MessagePart(true,
-                                    getRsv(uncompressedPart), opCode, compressedPayload,
+                            compressedPart = new MessagePart(true, getRsv(uncompressedPart), opCode, compressedPayload,
                                     uncompressedIntermediateHandler, uncompressedIntermediateHandler,
                                     blockingWriteTimeoutExpiry);
                             deflateRequired = false;
@@ -433,8 +417,7 @@ public class PerMessageDeflate implements Transformation {
                             // More data to write
                             // Copy bytes to new write buffer
                             writeBuffer.put(EOM_BUFFER, 0, eomBufferWritten);
-                            compressedPart = new MessagePart(false,
-                                    getRsv(uncompressedPart), opCode, compressedPayload,
+                            compressedPart = new MessagePart(false, getRsv(uncompressedPart), opCode, compressedPayload,
                                     uncompressedIntermediateHandler, uncompressedIntermediateHandler,
                                     blockingWriteTimeoutExpiry);
                         }

==================================================
TransformationFactory.java
index 0a955f07fe..7e60c5674c 100644
--- a/java/org/apache/tomcat/websocket/Transformation.java
+++ b/java/org/apache/tomcat/websocket/Transformation.java
@@ -23,87 +23,73 @@ import java.util.List;
 import jakarta.websocket.Extension;
 
 /**
- * The internal representation of the transformation that a WebSocket extension
- * performs on a message.
+ * The internal representation of the transformation that a WebSocket extension performs on a message.
  */
 public interface Transformation {
 
     /**
      * Sets the next transformation in the pipeline.
+     *
      * @param t The next transformation
      */
     void setNext(Transformation t);
 
     /**
-     * Validate that the RSV bit(s) required by this transformation are not
-     * being used by another extension. The implementation is expected to set
-     * any bits it requires before passing the set of in-use bits to the next
+     * Validate that the RSV bit(s) required by this transformation are not being used by another extension. The
+     * implementation is expected to set any bits it requires before passing the set of in-use bits to the next
      * transformation.
      *
-     * @param i         The RSV bits marked as in use so far as an int in the
-     *                  range zero to seven with RSV1 as the MSB and RSV3 as the
-     *                  LSB
+     * @param i The RSV bits marked as in use so far as an int in the range zero to seven with RSV1 as the MSB and RSV3
+     *              as the LSB
      *
-     * @return <code>true</code> if the combination of RSV bits used by the
-     *         transformations in the pipeline do not conflict otherwise
-     *         <code>false</code>
+     * @return <code>true</code> if the combination of RSV bits used by the transformations in the pipeline do not
+     *             conflict otherwise <code>false</code>
      */
     boolean validateRsvBits(int i);
 
     /**
-     * Obtain the extension that describes the information to be returned to the
-     * client.
+     * Obtain the extension that describes the information to be returned to the client.
      *
-     * @return The extension information that describes the parameters that have
-     *         been agreed for this transformation
+     * @return The extension information that describes the parameters that have been agreed for this transformation
      */
     Extension getExtensionResponse();
 
     /**
      * Obtain more input data.
      *
-     * @param opCode    The opcode for the frame currently being processed
-     * @param fin       Is this the final frame in this WebSocket message?
-     * @param rsv       The reserved bits for the frame currently being
-     *                      processed
-     * @param dest      The buffer in which the data is to be written
+     * @param opCode The opcode for the frame currently being processed
+     * @param fin    Is this the final frame in this WebSocket message?
+     * @param rsv    The reserved bits for the frame currently being processed
+     * @param dest   The buffer in which the data is to be written
      *
      * @return The result of trying to read more data from the transform
      *
-     * @throws IOException If an I/O error occurs while reading data from the
-     *         transform
+     * @throws IOException If an I/O error occurs while reading data from the transform
      */
     TransformationResult getMoreData(byte opCode, boolean fin, int rsv, ByteBuffer dest) throws IOException;
 
     /**
-     * Validates the RSV and opcode combination (assumed to have been extracted
-     * from a WebSocket Frame) for this extension. The implementation is
-     * expected to unset any RSV bits it has validated before passing the
-     * remaining RSV bits to the next transformation in the pipeline.
+     * Validates the RSV and opcode combination (assumed to have been extracted from a WebSocket Frame) for this
+     * extension. The implementation is expected to unset any RSV bits it has validated before passing the remaining RSV
+     * bits to the next transformation in the pipeline.
      *
-     * @param rsv       The RSV bits received as an int in the range zero to
-     *                  seven with RSV1 as the MSB and RSV3 as the LSB
-     * @param opCode    The opCode received
+     * @param rsv    The RSV bits received as an int in the range zero to seven with RSV1 as the MSB and RSV3 as the LSB
+     * @param opCode The opCode received
      *
-     * @return <code>true</code> if the RSV is valid otherwise
-     *         <code>false</code>
+     * @return <code>true</code> if the RSV is valid otherwise <code>false</code>
      */
     boolean validateRsv(int rsv, byte opCode);
 
     /**
-     * Takes the provided list of messages, transforms them, passes the
-     * transformed list on to the next transformation (if any) and then returns
-     * the resulting list of message parts after all of the transformations have
-     * been applied.
+     * Takes the provided list of messages, transforms them, passes the transformed list on to the next transformation
+     * (if any) and then returns the resulting list of message parts after all of the transformations have been applied.
      *
-     * @param messageParts  The list of messages to be transformed
+     * @param messageParts The list of messages to be transformed
      *
-     * @return  The list of messages after this any any subsequent
-     *          transformations have been applied. The size of the returned list
-     *          may be bigger or smaller than the size of the input list
+     * @return The list of messages after this any any subsequent transformations have been applied. The size of the
+     *             returned list may be bigger or smaller than the size of the input list
      *
-     * @throws IOException If an error occurs during the transformation of the
-     *                     message parts
+     * @throws IOException If an error occurs during the transformation of the message parts
      */
     List<MessagePart> sendMessagePart(List<MessagePart> messageParts) throws IOException;
 

==================================================
TransformationResult.java
index c1eae211e3..3503717abf 100644
--- a/java/org/apache/tomcat/websocket/TransformationFactory.java
+++ b/java/org/apache/tomcat/websocket/TransformationFactory.java
@@ -32,8 +32,7 @@ public class TransformationFactory {
         return factory;
     }
 
-    public Transformation create(String name, List<List<Extension.Parameter>> preferences,
-            boolean isServer) {
+    public Transformation create(String name, List<List<Extension.Parameter>> preferences, boolean isServer) {
         if (PerMessageDeflate.NAME.equals(name)) {
             return PerMessageDeflate.negotiate(preferences, isServer);
         }

==================================================
Util.java
index c6ced0251c..edf282ce97 100644
--- a/java/org/apache/tomcat/websocket/TransformationResult.java
+++ b/java/org/apache/tomcat/websocket/TransformationResult.java
@@ -18,20 +18,19 @@ package org.apache.tomcat.websocket;
 
 public enum TransformationResult {
     /**
-     * The end of the available data was reached before the WebSocket frame was
-     * completely read.
+     * The end of the available data was reached before the WebSocket frame was completely read.
      */
     UNDERFLOW,
 
     /**
-     * The provided destination buffer was filled before all of the available
-     * data from the WebSocket frame could be processed.
+     * The provided destination buffer was filled before all of the available data from the WebSocket frame could be
+     * processed.
      */
     OVERFLOW,
 
     /**
-     * The end of the WebSocket frame was reached and all the data from that
-     * frame processed into the provided destination buffer.
+     * The end of the WebSocket frame was reached and all the data from that frame processed into the provided
+     * destination buffer.
      */
     END_OF_FRAME
 }

==================================================
WsContainerProvider.java
index e362b19d27..a49716b223 100644
--- a/java/org/apache/tomcat/websocket/Util.java
+++ b/java/org/apache/tomcat/websocket/Util.java
@@ -57,14 +57,12 @@ import org.apache.tomcat.websocket.pojo.PojoMessageHandlerWholeBinary;
 import org.apache.tomcat.websocket.pojo.PojoMessageHandlerWholeText;
 
 /**
- * Utility class for internal use only within the
- * {@link org.apache.tomcat.websocket} package.
+ * Utility class for internal use only within the {@link org.apache.tomcat.websocket} package.
  */
 public class Util {
 
     private static final StringManager sm = StringManager.getManager(Util.class);
-    private static final Queue<SecureRandom> randoms =
-            new ConcurrentLinkedQueue<>();
+    private static final Queue<SecureRandom> randoms = new ConcurrentLinkedQueue<>();
 
     private Util() {
         // Hide default constructor
@@ -170,8 +168,7 @@ public class Util {
 
 
     static Class<?> getMessageType(MessageHandler listener) {
-        return Util.getGenericType(MessageHandler.class,
-                listener.getClass()).getClazz();
+        return Util.getGenericType(MessageHandler.class, listener.getClass()).getClazz();
     }
 
 
@@ -185,8 +182,7 @@ public class Util {
     }
 
 
-    private static <T> TypeResult getGenericType(Class<T> type,
-            Class<? extends T> clazz) {
+    private static <T> TypeResult getGenericType(Class<T> type, Class<? extends T> clazz) {
 
         // Look to see if this class implements the interface of interest
 
@@ -199,8 +195,7 @@ public class Util {
                 // Look for the interface of interest
                 if (pi.getRawType() instanceof Class) {
                     if (type.isAssignableFrom((Class<?>) pi.getRawType())) {
-                        return getTypeParameter(
-                                clazz, pi.getActualTypeArguments()[0]);
+                        return getTypeParameter(clazz, pi.getActualTypeArguments()[0]);
                     }
                 }
             }
@@ -208,8 +203,7 @@ public class Util {
 
         // Interface not found on this class. Look at the superclass.
         @SuppressWarnings("unchecked")
-        Class<? extends T> superClazz =
-                (Class<? extends T>) clazz.getSuperclass();
+        Class<? extends T> superClazz = (Class<? extends T>) clazz.getSuperclass();
         if (superClazz == null) {
             // Finished looking up the class hierarchy without finding anything
             return null;
@@ -227,11 +221,9 @@ public class Util {
             // Superclass implements interface and defines unknown type for
             // the interface of interest
             // Map that unknown type to the generic types defined in this class
-            ParameterizedType superClassType =
-                    (ParameterizedType) clazz.getGenericSuperclass();
+            ParameterizedType superClassType = (ParameterizedType) clazz.getGenericSuperclass();
             TypeResult result = getTypeParameter(clazz,
-                    superClassType.getActualTypeArguments()[
-                            superClassTypeResult.getIndex()]);
+                    superClassType.getActualTypeArguments()[superClassTypeResult.getIndex()]);
             result.incrementDimension(superClassTypeResult.getDimension());
             if (result.getClazz() != null && result.getDimension() > 0) {
                 superClassTypeResult = result;
@@ -265,14 +257,14 @@ public class Util {
 
 
     /*
-     * For a generic parameter, return either the Class used or if the type
-     * is unknown, the index for the type in definition of the class
+     * For a generic parameter, return either the Class used or if the type is unknown, the index for the type in
+     * definition of the class
      */
     private static TypeResult getTypeParameter(Class<?> clazz, Type argType) {
         if (argType instanceof Class<?>) {
             return new TypeResult((Class<?>) argType, -1, 0);
         } else if (argType instanceof ParameterizedType) {
-            return new TypeResult((Class<?>)((ParameterizedType) argType).getRawType(), -1, 0);
+            return new TypeResult((Class<?>) ((ParameterizedType) argType).getRawType(), -1, 0);
         } else if (argType instanceof GenericArrayType) {
             Type arrayElementType = ((GenericArrayType) argType).getGenericComponentType();
             TypeResult result = getTypeParameter(clazz, arrayElementType);
@@ -293,14 +285,9 @@ public class Util {
     public static boolean isPrimitive(Class<?> clazz) {
         if (clazz.isPrimitive()) {
             return true;
-        } else if(clazz.equals(Boolean.class) ||
-                clazz.equals(Byte.class) ||
-                clazz.equals(Character.class) ||
-                clazz.equals(Double.class) ||
-                clazz.equals(Float.class) ||
-                clazz.equals(Integer.class) ||
-                clazz.equals(Long.class) ||
-                clazz.equals(Short.class)) {
+        } else if (clazz.equals(Boolean.class) || clazz.equals(Byte.class) || clazz.equals(Character.class) ||
+                clazz.equals(Double.class) || clazz.equals(Float.class) || clazz.equals(Integer.class) ||
+                clazz.equals(Long.class) || clazz.equals(Short.class)) {
             return true;
         }
         return false;
@@ -327,8 +314,7 @@ public class Util {
         } else if (type.equals(short.class) || type.equals(Short.class)) {
             return Short.valueOf(value);
         } else {
-            throw new IllegalArgumentException(sm.getString(
-                    "util.invalidType", value, type.getName()));
+            throw new IllegalArgumentException(sm.getString("util.invalidType", value, type.getName()));
         }
     }
 
@@ -336,16 +322,15 @@ public class Util {
     /**
      * Build the list of decoder entries from a set of decoder implementations.
      *
-     * @param decoderClazzes    Decoder implementation classes
-     * @param instanceManager   Instance manager to use to create Decoder
-     *                              instances
+     * @param decoderClazzes  Decoder implementation classes
+     * @param instanceManager Instance manager to use to create Decoder instances
      *
      * @return List of mappings from target type to associated decoder
      *
      * @throws DeploymentException If a provided decoder class is not valid
      */
     public static List<DecoderEntry> getDecoders(List<Class<? extends Decoder>> decoderClazzes,
-            InstanceManager instanceManager) throws DeploymentException{
+            InstanceManager instanceManager) throws DeploymentException {
 
         List<DecoderEntry> result = new ArrayList<>();
         if (decoderClazzes != null) {
@@ -361,8 +346,8 @@ public class Util {
                         // Don't need this instance, so destroy it
                         instanceManager.destroyInstance(instance);
                     }
-                } catch (ReflectiveOperationException | IllegalArgumentException | SecurityException |
-                        NamingException e) {
+                } catch (ReflectiveOperationException | IllegalArgumentException | SecurityException
+                        | NamingException e) {
                     throw new DeploymentException(
                             sm.getString("pojoMethodMapping.invalidDecoder", decoderClazz.getName()), e);
                 }
@@ -375,9 +360,8 @@ public class Util {
     }
 
 
-    static Set<MessageHandlerResult> getMessageHandlers(Class<?> target,
-            MessageHandler listener, EndpointConfig endpointConfig,
-            Session session) {
+    static Set<MessageHandlerResult> getMessageHandlers(Class<?> target, MessageHandler listener,
+            EndpointConfig endpointConfig, Session session) {
 
         // Will never be more than 2 types
         Set<MessageHandlerResult> results = new HashSet<>(2);
@@ -385,47 +369,36 @@ public class Util {
         // Simple cases - handlers already accepts one of the types expected by
         // the frame handling code
         if (String.class.isAssignableFrom(target)) {
-            MessageHandlerResult result =
-                    new MessageHandlerResult(listener,
-                            MessageHandlerResultType.TEXT);
+            MessageHandlerResult result = new MessageHandlerResult(listener, MessageHandlerResultType.TEXT);
             results.add(result);
         } else if (ByteBuffer.class.isAssignableFrom(target)) {
-            MessageHandlerResult result =
-                    new MessageHandlerResult(listener,
-                            MessageHandlerResultType.BINARY);
+            MessageHandlerResult result = new MessageHandlerResult(listener, MessageHandlerResultType.BINARY);
             results.add(result);
         } else if (PongMessage.class.isAssignableFrom(target)) {
-            MessageHandlerResult result =
-                    new MessageHandlerResult(listener,
-                            MessageHandlerResultType.PONG);
+            MessageHandlerResult result = new MessageHandlerResult(listener, MessageHandlerResultType.PONG);
             results.add(result);
-        // Handler needs wrapping and optional decoder to convert it to one of
-        // the types expected by the frame handling code
+            // Handler needs wrapping and optional decoder to convert it to one of
+            // the types expected by the frame handling code
         } else if (byte[].class.isAssignableFrom(target)) {
             boolean whole = MessageHandler.Whole.class.isAssignableFrom(listener.getClass());
-            MessageHandlerResult result = new MessageHandlerResult(
-                    whole ? new PojoMessageHandlerWholeBinary(listener,
-                                    getOnMessageMethod(listener), session, endpointConfig,
-                                    matchDecoders(target, endpointConfig, true,
-                                            ((WsSession) session).getInstanceManager()),
-                                    new Object[1], 0, true, -1, false, -1) :
-                            new PojoMessageHandlerPartialBinary(listener,
-                                    getOnMessagePartialMethod(listener), session,
-                                    new Object[2], 0, true, 1, -1, -1),
+            MessageHandlerResult result = new MessageHandlerResult(whole
+                    ? new PojoMessageHandlerWholeBinary(listener, getOnMessageMethod(listener), session, endpointConfig,
+                            matchDecoders(target, endpointConfig, true, ((WsSession) session).getInstanceManager()),
+                            new Object[1], 0, true, -1, false, -1)
+                    : new PojoMessageHandlerPartialBinary(listener, getOnMessagePartialMethod(listener), session,
+                            new Object[2], 0, true, 1, -1, -1),
                     MessageHandlerResultType.BINARY);
             results.add(result);
         } else if (InputStream.class.isAssignableFrom(target)) {
             MessageHandlerResult result = new MessageHandlerResult(
-                    new PojoMessageHandlerWholeBinary(listener,
-                            getOnMessageMethod(listener), session, endpointConfig,
+                    new PojoMessageHandlerWholeBinary(listener, getOnMessageMethod(listener), session, endpointConfig,
                             matchDecoders(target, endpointConfig, true, ((WsSession) session).getInstanceManager()),
                             new Object[1], 0, true, -1, true, -1),
                     MessageHandlerResultType.BINARY);
             results.add(result);
         } else if (Reader.class.isAssignableFrom(target)) {
             MessageHandlerResult result = new MessageHandlerResult(
-                    new PojoMessageHandlerWholeText(listener,
-                            getOnMessageMethod(listener), session, endpointConfig,
+                    new PojoMessageHandlerWholeText(listener, getOnMessageMethod(listener), session, endpointConfig,
                             matchDecoders(target, endpointConfig, false, ((WsSession) session).getInstanceManager()),
                             new Object[1], 0, true, -1, -1),
                     MessageHandlerResultType.TEXT);
@@ -438,34 +411,29 @@ public class Util {
             Method m = getOnMessageMethod(listener);
             if (decoderMatch.getBinaryDecoders().size() > 0) {
                 MessageHandlerResult result = new MessageHandlerResult(
-                        new PojoMessageHandlerWholeBinary(listener, m, session,
-                                endpointConfig,
-                                decoderMatch.getBinaryDecoders(), new Object[1],
-                                0, false, -1, false, -1),
-                                MessageHandlerResultType.BINARY);
+                        new PojoMessageHandlerWholeBinary(listener, m, session, endpointConfig,
+                                decoderMatch.getBinaryDecoders(), new Object[1], 0, false, -1, false, -1),
+                        MessageHandlerResultType.BINARY);
                 results.add(result);
             }
             if (decoderMatch.getTextDecoders().size() > 0) {
                 MessageHandlerResult result = new MessageHandlerResult(
-                        new PojoMessageHandlerWholeText(listener, m, session,
-                                endpointConfig,
-                                decoderMatch.getTextDecoders(), new Object[1],
-                                0, false, -1, -1),
-                                MessageHandlerResultType.TEXT);
+                        new PojoMessageHandlerWholeText(listener, m, session, endpointConfig,
+                                decoderMatch.getTextDecoders(), new Object[1], 0, false, -1, -1),
+                        MessageHandlerResultType.TEXT);
                 results.add(result);
             }
         }
 
         if (results.size() == 0) {
-            throw new IllegalArgumentException(
-                    sm.getString("wsSession.unknownHandler", listener, target));
+            throw new IllegalArgumentException(sm.getString("wsSession.unknownHandler", listener, target));
         }
 
         return results;
     }
 
-    private static List<Class<? extends Decoder>> matchDecoders(Class<?> target,
-            EndpointConfig endpointConfig, boolean binary, InstanceManager instanceManager) {
+    private static List<Class<? extends Decoder>> matchDecoders(Class<?> target, EndpointConfig endpointConfig,
+            boolean binary, InstanceManager instanceManager) {
         DecoderMatch decoderMatch = matchDecoders(target, endpointConfig, instanceManager);
         if (binary) {
             if (decoderMatch.getBinaryDecoders().size() > 0) {
@@ -477,12 +445,11 @@ public class Util {
         return null;
     }
 
-    private static DecoderMatch matchDecoders(Class<?> target,
-            EndpointConfig endpointConfig, InstanceManager instanceManager) {
+    private static DecoderMatch matchDecoders(Class<?> target, EndpointConfig endpointConfig,
+            InstanceManager instanceManager) {
         DecoderMatch decoderMatch;
         try {
-            List<Class<? extends Decoder>> decoders =
-                    endpointConfig.getDecoders();
+            List<Class<? extends Decoder>> decoders = endpointConfig.getDecoders();
             List<DecoderEntry> decoderEntries = getDecoders(decoders, instanceManager);
             decoderMatch = new DecoderMatch(target, decoderEntries);
         } catch (DeploymentException e) {
@@ -491,17 +458,16 @@ public class Util {
         return decoderMatch;
     }
 
-    public static void parseExtensionHeader(List<Extension> extensions,
-            String header) {
+    public static void parseExtensionHeader(List<Extension> extensions, String header) {
         // The relevant ABNF for the Sec-WebSocket-Extensions is as follows:
-        //      extension-list = 1#extension
-        //      extension = extension-token *( ";" extension-param )
-        //      extension-token = registered-token
-        //      registered-token = token
-        //      extension-param = token [ "=" (token | quoted-string) ]
-        //             ; When using the quoted-string syntax variant, the value
-        //             ; after quoted-string unescaping MUST conform to the
-        //             ; 'token' ABNF.
+        // extension-list = 1#extension
+        // extension = extension-token *( ";" extension-param )
+        // extension-token = registered-token
+        // registered-token = token
+        // extension-param = token [ "=" (token | quoted-string) ]
+        // ; When using the quoted-string syntax variant, the value
+        // ; after quoted-string unescaping MUST conform to the
+        // ; 'token' ABNF.
         //
         // The limiting of parameter values to tokens or "quoted tokens" makes
         // the parsing of the header significantly simpler and allows a number
@@ -536,12 +502,10 @@ public class Util {
                 // Make sure value doesn't contain any of the delimiters since
                 // that would indicate something went wrong
                 if (containsDelims(name) || containsDelims(value)) {
-                    throw new IllegalArgumentException(sm.getString(
-                            "util.notToken", name, value));
+                    throw new IllegalArgumentException(sm.getString("util.notToken", name, value));
                 }
-                if (value != null &&
-                        (value.indexOf(',') > -1 || value.indexOf(';') > -1 ||
-                        value.indexOf('\"') > -1 || value.indexOf('=') > -1)) {
+                if (value != null && (value.indexOf(',') > -1 || value.indexOf(';') > -1 || value.indexOf('\"') > -1 ||
+                        value.indexOf('=') > -1)) {
                     throw new IllegalArgumentException(sm.getString("", value));
                 }
                 extension.addParameter(new WsExtensionParameter(name, value));
@@ -574,8 +538,7 @@ public class Util {
         try {
             return listener.getClass().getMethod("onMessage", Object.class);
         } catch (NoSuchMethodException | SecurityException e) {
-            throw new IllegalArgumentException(
-                    sm.getString("util.invalidMessageHandler"), e);
+            throw new IllegalArgumentException(sm.getString("util.invalidMessageHandler"), e);
         }
     }
 
@@ -583,51 +546,43 @@ public class Util {
         try {
             return listener.getClass().getMethod("onMessage", Object.class, Boolean.TYPE);
         } catch (NoSuchMethodException | SecurityException e) {
-            throw new IllegalArgumentException(
-                    sm.getString("util.invalidMessageHandler"), e);
+            throw new IllegalArgumentException(sm.getString("util.invalidMessageHandler"), e);
         }
     }
 
 
     public static class DecoderMatch {
 
-        private final List<Class<? extends Decoder>> textDecoders =
-                new ArrayList<>();
-        private final List<Class<? extends Decoder>> binaryDecoders =
-                new ArrayList<>();
+        private final List<Class<? extends Decoder>> textDecoders = new ArrayList<>();
+        private final List<Class<? extends Decoder>> binaryDecoders = new ArrayList<>();
         private final Class<?> target;
 
         public DecoderMatch(Class<?> target, List<DecoderEntry> decoderEntries) {
             this.target = target;
             for (DecoderEntry decoderEntry : decoderEntries) {
                 if (decoderEntry.getClazz().isAssignableFrom(target)) {
-                    if (Binary.class.isAssignableFrom(
-                            decoderEntry.getDecoderClazz())) {
+                    if (Binary.class.isAssignableFrom(decoderEntry.getDecoderClazz())) {
                         binaryDecoders.add(decoderEntry.getDecoderClazz());
                         // willDecode() method means this decoder may or may not
                         // decode a message so need to carry on checking for
                         // other matches
-                    } else if (BinaryStream.class.isAssignableFrom(
-                            decoderEntry.getDecoderClazz())) {
+                    } else if (BinaryStream.class.isAssignableFrom(decoderEntry.getDecoderClazz())) {
                         binaryDecoders.add(decoderEntry.getDecoderClazz());
                         // Stream decoders have to process the message so no
                         // more decoders can be matched
                         break;
-                    } else if (Text.class.isAssignableFrom(
-                            decoderEntry.getDecoderClazz())) {
+                    } else if (Text.class.isAssignableFrom(decoderEntry.getDecoderClazz())) {
                         textDecoders.add(decoderEntry.getDecoderClazz());
                         // willDecode() method means this decoder may or may not
                         // decode a message so need to carry on checking for
                         // other matches
-                    } else if (TextStream.class.isAssignableFrom(
-                            decoderEntry.getDecoderClazz())) {
+                    } else if (TextStream.class.isAssignableFrom(decoderEntry.getDecoderClazz())) {
                         textDecoders.add(decoderEntry.getDecoderClazz());
                         // Stream decoders have to process the message so no
                         // more decoders can be matched
                         break;
                     } else {
-                        throw new IllegalArgumentException(
-                                sm.getString("util.unknownDecoderType"));
+                        throw new IllegalArgumentException(sm.getString("util.unknownDecoderType"));
                     }
                 }
             }
@@ -661,7 +616,7 @@ public class Util {
         private int dimension;
 
         TypeResult(Class<?> clazz, int index, int dimension) {
-            this.clazz= clazz;
+            this.clazz = clazz;
             this.index = index;
             this.dimension = dimension;
         }

==================================================
WsFrameBase.java
index c3b52a37f6..0933791577 100644
--- a/java/org/apache/tomcat/websocket/WsContainerProvider.java
+++ b/java/org/apache/tomcat/websocket/WsContainerProvider.java
@@ -19,7 +19,7 @@ package org.apache.tomcat.websocket;
 import jakarta.websocket.ContainerProvider;
 import jakarta.websocket.WebSocketContainer;
 
-@aQute.bnd.annotation.spi.ServiceProvider(value=ContainerProvider.class)
+@aQute.bnd.annotation.spi.ServiceProvider(value = ContainerProvider.class)
 public class WsContainerProvider extends ContainerProvider {
 
     @Override

==================================================
WsFrameClient.java
index 10dfb7913d..cce9fd4e48 100644
--- a/java/org/apache/tomcat/websocket/WsFrameBase.java
+++ b/java/org/apache/tomcat/websocket/WsFrameBase.java
@@ -37,9 +37,8 @@ import org.apache.tomcat.util.ExceptionUtils;
 import org.apache.tomcat.util.res.StringManager;
 
 /**
- * Takes the ServletInputStream, processes the WebSocket frames it contains and
- * extracts the messages. WebSocket Pings received will be responded to
- * automatically without any action required by the application.
+ * Takes the ServletInputStream, processes the WebSocket frames it contains and extracts the messages. WebSocket Pings
+ * received will be responded to automatically without any action required by the application.
  */
 public abstract class WsFrameBase {
 
@@ -57,12 +56,10 @@ public abstract class WsFrameBase {
     private final CharBuffer controlBufferText = CharBuffer.allocate(125);
 
     // Attributes of the current message
-    private final CharsetDecoder utf8DecoderControl = StandardCharsets.UTF_8.newDecoder().
-            onMalformedInput(CodingErrorAction.REPORT).
-            onUnmappableCharacter(CodingErrorAction.REPORT);
-    private final CharsetDecoder utf8DecoderMessage = StandardCharsets.UTF_8.newDecoder().
-            onMalformedInput(CodingErrorAction.REPORT).
-            onUnmappableCharacter(CodingErrorAction.REPORT);
+    private final CharsetDecoder utf8DecoderControl = StandardCharsets.UTF_8.newDecoder()
+            .onMalformedInput(CodingErrorAction.REPORT).onUnmappableCharacter(CodingErrorAction.REPORT);
+    private final CharsetDecoder utf8DecoderMessage = StandardCharsets.UTF_8.newDecoder()
+            .onMalformedInput(CodingErrorAction.REPORT).onUnmappableCharacter(CodingErrorAction.REPORT);
     private boolean continuationExpected = false;
     private boolean textMessage = false;
     private ByteBuffer messageBufferBinary;
@@ -85,8 +82,8 @@ public abstract class WsFrameBase {
     private volatile State state = State.NEW_FRAME;
     private volatile boolean open = true;
 
-    private static final AtomicReferenceFieldUpdater<WsFrameBase, ReadState> READ_STATE_UPDATER =
-            AtomicReferenceFieldUpdater.newUpdater(WsFrameBase.class, ReadState.class, "readState");
+    private static final AtomicReferenceFieldUpdater<WsFrameBase, ReadState> READ_STATE_UPDATER = AtomicReferenceFieldUpdater
+            .newUpdater(WsFrameBase.class, ReadState.class, "readState");
     private volatile ReadState readState = ReadState.WAITING;
 
     public WsFrameBase(WsSession wsSession, Transformation transformation) {
@@ -139,8 +136,7 @@ public abstract class WsFrameBase {
 
 
     /**
-     * @return <code>true</code> if sufficient data was present to process all
-     *         of the initial header
+     * @return <code>true</code> if sufficient data was present to process all of the initial header
      */
     private boolean processInitialHeader() throws IOException {
         // Need at least two bytes of data to do this
@@ -152,30 +148,25 @@ public abstract class WsFrameBase {
         rsv = (b & 0x70) >>> 4;
         opCode = (byte) (b & 0x0F);
         if (!transformation.validateRsv(rsv, opCode)) {
-            throw new WsIOException(new CloseReason(
-                    CloseCodes.PROTOCOL_ERROR,
+            throw new WsIOException(new CloseReason(CloseCodes.PROTOCOL_ERROR,
                     sm.getString("wsFrame.wrongRsv", Integer.valueOf(rsv), Integer.valueOf(opCode))));
         }
 
         if (Util.isControl(opCode)) {
             if (!fin) {
-                throw new WsIOException(new CloseReason(
-                        CloseCodes.PROTOCOL_ERROR,
-                        sm.getString("wsFrame.controlFragmented")));
+                throw new WsIOException(
+                        new CloseReason(CloseCodes.PROTOCOL_ERROR, sm.getString("wsFrame.controlFragmented")));
             }
-            if (opCode != Constants.OPCODE_PING &&
-                    opCode != Constants.OPCODE_PONG &&
+            if (opCode != Constants.OPCODE_PING && opCode != Constants.OPCODE_PONG &&
                     opCode != Constants.OPCODE_CLOSE) {
-                throw new WsIOException(new CloseReason(
-                        CloseCodes.PROTOCOL_ERROR,
+                throw new WsIOException(new CloseReason(CloseCodes.PROTOCOL_ERROR,
                         sm.getString("wsFrame.invalidOpCode", Integer.valueOf(opCode))));
             }
         } else {
             if (continuationExpected) {
                 if (!Util.isContinuation(opCode)) {
-                    throw new WsIOException(new CloseReason(
-                            CloseCodes.PROTOCOL_ERROR,
-                            sm.getString("wsFrame.noContinuation")));
+                    throw new WsIOException(
+                            new CloseReason(CloseCodes.PROTOCOL_ERROR, sm.getString("wsFrame.noContinuation")));
                 }
             } else {
                 try {
@@ -198,15 +189,13 @@ public abstract class WsFrameBase {
                         binaryMsgHandler = null;
                         textMsgHandler = wsSession.getTextMessageHandler();
                     } else {
-                        throw new WsIOException(new CloseReason(
-                                CloseCodes.PROTOCOL_ERROR,
+                        throw new WsIOException(new CloseReason(CloseCodes.PROTOCOL_ERROR,
                                 sm.getString("wsFrame.invalidOpCode", Integer.valueOf(opCode))));
                     }
                 } catch (IllegalStateException ise) {
                     // Thrown if the session is already closed
-                    throw new WsIOException(new CloseReason(
-                            CloseCodes.PROTOCOL_ERROR,
-                            sm.getString("wsFrame.sessionClosed")));
+                    throw new WsIOException(
+                            new CloseReason(CloseCodes.PROTOCOL_ERROR, sm.getString("wsFrame.sessionClosed")));
                 }
             }
             continuationExpected = !fin;
@@ -214,27 +203,25 @@ public abstract class WsFrameBase {
         b = inputBuffer.get();
         // Client data must be masked
         if ((b & 0x80) == 0 && isMasked()) {
-            throw new WsIOException(new CloseReason(
-                    CloseCodes.PROTOCOL_ERROR,
-                    sm.getString("wsFrame.notMasked")));
+            throw new WsIOException(new CloseReason(CloseCodes.PROTOCOL_ERROR, sm.getString("wsFrame.notMasked")));
         }
         payloadLength = b & 0x7F;
         state = State.PARTIAL_HEADER;
         if (getLog().isDebugEnabled()) {
-            getLog().debug(sm.getString("wsFrame.partialHeaderComplete", Boolean.toString(fin),
-                    Integer.toString(rsv), Integer.toString(opCode), Long.toString(payloadLength)));
+            getLog().debug(sm.getString("wsFrame.partialHeaderComplete", Boolean.toString(fin), Integer.toString(rsv),
+                    Integer.toString(opCode), Long.toString(payloadLength)));
         }
         return true;
     }
 
 
     protected abstract boolean isMasked();
+
     protected abstract Log getLog();
 
 
     /**
-     * @return <code>true</code> if sufficient data was present to complete the
-     *         processing of the header
+     * @return <code>true</code> if sufficient data was present to complete the processing of the header
      */
     private boolean processRemainingHeader() throws IOException {
         // Ignore the 2 bytes already read. 4 for the mask
@@ -255,12 +242,10 @@ public abstract class WsFrameBase {
         }
         // Calculate new payload length if necessary
         if (payloadLength == 126) {
-            payloadLength = byteArrayToLong(inputBuffer.array(),
-                    inputBuffer.arrayOffset() + inputBuffer.position(), 2);
+            payloadLength = byteArrayToLong(inputBuffer.array(), inputBuffer.arrayOffset() + inputBuffer.position(), 2);
             inputBuffer.position(inputBuffer.position() + 2);
         } else if (payloadLength == 127) {
-            payloadLength = byteArrayToLong(inputBuffer.array(),
-                    inputBuffer.arrayOffset() + inputBuffer.position(), 8);
+            payloadLength = byteArrayToLong(inputBuffer.array(), inputBuffer.arrayOffset() + inputBuffer.position(), 8);
             // The most significant bit of those 8 bytes is required to be zero
             // (see RFC 6455, section 5.2). If the most significant bit is set,
             // the resulting payload length will be negative so test for that.
@@ -272,14 +257,12 @@ public abstract class WsFrameBase {
         }
         if (Util.isControl(opCode)) {
             if (payloadLength > 125) {
-                throw new WsIOException(new CloseReason(
-                        CloseCodes.PROTOCOL_ERROR,
+                throw new WsIOException(new CloseReason(CloseCodes.PROTOCOL_ERROR,
                         sm.getString("wsFrame.controlPayloadTooBig", Long.valueOf(payloadLength))));
             }
             if (!fin) {
-                throw new WsIOException(new CloseReason(
-                        CloseCodes.PROTOCOL_ERROR,
-                        sm.getString("wsFrame.controlNoFin")));
+                throw new WsIOException(
+                        new CloseReason(CloseCodes.PROTOCOL_ERROR, sm.getString("wsFrame.controlNoFin")));
             }
         }
         if (isMasked()) {
@@ -341,21 +324,18 @@ public abstract class WsFrameBase {
             if (controlBufferBinary.remaining() == 1) {
                 controlBufferBinary.clear();
                 // Payload must be zero or 2+ bytes long
-                throw new WsIOException(new CloseReason(
-                        CloseCodes.PROTOCOL_ERROR,
-                        sm.getString("wsFrame.oneByteCloseCode")));
+                throw new WsIOException(
+                        new CloseReason(CloseCodes.PROTOCOL_ERROR, sm.getString("wsFrame.oneByteCloseCode")));
             }
             if (controlBufferBinary.remaining() > 1) {
                 code = controlBufferBinary.getShort();
                 if (controlBufferBinary.remaining() > 0) {
-                    CoderResult cr = utf8DecoderControl.decode(controlBufferBinary,
-                            controlBufferText, true);
+                    CoderResult cr = utf8DecoderControl.decode(controlBufferBinary, controlBufferText, true);
                     if (cr.isError()) {
                         controlBufferBinary.clear();
                         controlBufferText.clear();
-                        throw new WsIOException(new CloseReason(
-                                CloseCodes.PROTOCOL_ERROR,
-                                sm.getString("wsFrame.invalidUtf8Close")));
+                        throw new WsIOException(
+                                new CloseReason(CloseCodes.PROTOCOL_ERROR, sm.getString("wsFrame.invalidUtf8Close")));
                     }
                     // There will be no overflow as the output buffer is big
                     // enough. There will be no underflow as all the data is
@@ -383,8 +363,7 @@ public abstract class WsFrameBase {
         } else {
             // Should have caught this earlier but just in case...
             controlBufferBinary.clear();
-            throw new WsIOException(new CloseReason(
-                    CloseCodes.PROTOCOL_ERROR,
+            throw new WsIOException(new CloseReason(CloseCodes.PROTOCOL_ERROR,
                     sm.getString("wsFrame.invalidOpCode", Integer.valueOf(opCode))));
         }
         controlBufferBinary.clear();
@@ -398,21 +377,17 @@ public abstract class WsFrameBase {
         if (textMsgHandler instanceof WrappedMessageHandler) {
             long maxMessageSize = ((WrappedMessageHandler) textMsgHandler).getMaxMessageSize();
             if (maxMessageSize > -1 && messageBufferText.remaining() > maxMessageSize) {
-                throw new WsIOException(new CloseReason(CloseCodes.TOO_BIG,
-                        sm.getString("wsFrame.messageTooBig",
-                                Long.valueOf(messageBufferText.remaining()),
-                                Long.valueOf(maxMessageSize))));
+                throw new WsIOException(new CloseReason(CloseCodes.TOO_BIG, sm.getString("wsFrame.messageTooBig",
+                        Long.valueOf(messageBufferText.remaining()), Long.valueOf(maxMessageSize))));
             }
         }
 
         try {
             if (textMsgHandler instanceof MessageHandler.Partial<?>) {
-                ((MessageHandler.Partial<String>) textMsgHandler)
-                        .onMessage(messageBufferText.toString(), last);
+                ((MessageHandler.Partial<String>) textMsgHandler).onMessage(messageBufferText.toString(), last);
             } else {
                 // Caller ensures last == true if this branch is used
-                ((MessageHandler.Whole<String>) textMsgHandler)
-                        .onMessage(messageBufferText.toString());
+                ((MessageHandler.Whole<String>) textMsgHandler).onMessage(messageBufferText.toString());
             }
         } catch (Throwable t) {
             handleThrowableOnSend(t);
@@ -430,12 +405,10 @@ public abstract class WsFrameBase {
             // Convert bytes to UTF-8
             messageBufferBinary.flip();
             while (true) {
-                CoderResult cr = utf8DecoderMessage.decode(messageBufferBinary, messageBufferText,
-                        false);
+                CoderResult cr = utf8DecoderMessage.decode(messageBufferBinary, messageBufferText, false);
                 if (cr.isError()) {
-                    throw new WsIOException(new CloseReason(
-                            CloseCodes.NOT_CONSISTENT,
-                            sm.getString("wsFrame.invalidUtf8")));
+                    throw new WsIOException(
+                            new CloseReason(CloseCodes.NOT_CONSISTENT, sm.getString("wsFrame.invalidUtf8")));
                 } else if (cr.isOverflow()) {
                     // Ran out of space in text buffer - flush it
                     if (usePartial()) {
@@ -443,9 +416,8 @@ public abstract class WsFrameBase {
                         sendMessageText(false);
                         messageBufferText.clear();
                     } else {
-                        throw new WsIOException(new CloseReason(
-                                CloseCodes.TOO_BIG,
-                                sm.getString("wsFrame.textMessageTooBig")));
+                        throw new WsIOException(
+                                new CloseReason(CloseCodes.TOO_BIG, sm.getString("wsFrame.textMessageTooBig")));
                     }
                 } else if (cr.isUnderflow()) {
                     // Compact what we have to create as much space as possible
@@ -473,12 +445,10 @@ public abstract class WsFrameBase {
         // Frame is fully received
         // Convert bytes to UTF-8
         while (true) {
-            CoderResult cr = utf8DecoderMessage.decode(messageBufferBinary, messageBufferText,
-                    last);
+            CoderResult cr = utf8DecoderMessage.decode(messageBufferBinary, messageBufferText, last);
             if (cr.isError()) {
-                throw new WsIOException(new CloseReason(
-                        CloseCodes.NOT_CONSISTENT,
-                        sm.getString("wsFrame.invalidUtf8")));
+                throw new WsIOException(
+                        new CloseReason(CloseCodes.NOT_CONSISTENT, sm.getString("wsFrame.invalidUtf8")));
             } else if (cr.isOverflow()) {
                 // Ran out of space in text buffer - flush it
                 if (usePartial()) {
@@ -486,9 +456,8 @@ public abstract class WsFrameBase {
                     sendMessageText(false);
                     messageBufferText.clear();
                 } else {
-                    throw new WsIOException(new CloseReason(
-                            CloseCodes.TOO_BIG,
-                            sm.getString("wsFrame.textMessageTooBig")));
+                    throw new WsIOException(
+                            new CloseReason(CloseCodes.TOO_BIG, sm.getString("wsFrame.textMessageTooBig")));
                 }
             } else if (cr.isUnderflow() && !last) {
                 // End of frame and possible message as well.
@@ -533,10 +502,8 @@ public abstract class WsFrameBase {
 
             // Ran out of message buffer - flush it
             if (!usePartial()) {
-                CloseReason cr = new CloseReason(CloseCodes.TOO_BIG,
-                        sm.getString("wsFrame.bufferTooSmall",
-                                Integer.valueOf(messageBufferBinary.capacity()),
-                                Long.valueOf(payloadLength)));
+                CloseReason cr = new CloseReason(CloseCodes.TOO_BIG, sm.getString("wsFrame.bufferTooSmall",
+                        Integer.valueOf(messageBufferBinary.capacity()), Long.valueOf(payloadLength)));
                 throw new WsIOException(cr);
             }
             messageBufferBinary.flip();
@@ -577,8 +544,7 @@ public abstract class WsFrameBase {
     private void handleThrowableOnSend(Throwable t) throws WsIOException {
         ExceptionUtils.handleThrowable(t);
         wsSession.getLocal().onError(wsSession, t);
-        CloseReason cr = new CloseReason(CloseCodes.CLOSED_ABNORMALLY,
-                sm.getString("wsFrame.ioeTriggeredClose"));
+        CloseReason cr = new CloseReason(CloseCodes.CLOSED_ABNORMALLY, sm.getString("wsFrame.ioeTriggeredClose"));
         throw new WsIOException(cr);
     }
 
@@ -588,10 +554,8 @@ public abstract class WsFrameBase {
         if (binaryMsgHandler instanceof WrappedMessageHandler) {
             long maxMessageSize = ((WrappedMessageHandler) binaryMsgHandler).getMaxMessageSize();
             if (maxMessageSize > -1 && msg.remaining() > maxMessageSize) {
-                throw new WsIOException(new CloseReason(CloseCodes.TOO_BIG,
-                        sm.getString("wsFrame.messageTooBig",
-                                Long.valueOf(msg.remaining()),
-                                Long.valueOf(maxMessageSize))));
+                throw new WsIOException(new CloseReason(CloseCodes.TOO_BIG, sm.getString("wsFrame.messageTooBig",
+                        Long.valueOf(msg.remaining()), Long.valueOf(maxMessageSize))));
             }
         }
         try {
@@ -709,43 +673,25 @@ public abstract class WsFrameBase {
 
 
     private enum State {
-        NEW_FRAME, PARTIAL_HEADER, DATA
+        NEW_FRAME,
+        PARTIAL_HEADER,
+        DATA
     }
 
 
     /**
-     * WAITING            - not suspended
-     *                      Server case: waiting for a notification that data
-     *                      is ready to be read from the socket, the socket is
-     *                      registered to the poller
-     *                      Client case: data has been read from the socket and
-     *                      is waiting for data to be processed
-     * PROCESSING         - not suspended
-     *                      Server case: reading from the socket and processing
-     *                      the data
-     *                      Client case: processing the data if such has
-     *                      already been read and more data will be read from
-     *                      the socket
-     * SUSPENDING_WAIT    - suspended, a call to suspend() was made while in
-     *                      WAITING state. A call to resume() will do nothing
-     *                      and will transition to WAITING state
-     * SUSPENDING_PROCESS - suspended, a call to suspend() was made while in
-     *                      PROCESSING state. A call to resume() will do
-     *                      nothing and will transition to PROCESSING state
-     * SUSPENDED          - suspended
-     *                      Server case: processing data finished
-     *                      (SUSPENDING_PROCESS) / a notification was received
-     *                      that data is ready to be read from the socket
-     *                      (SUSPENDING_WAIT), socket is not registered to the
-     *                      poller
-     *                      Client case: processing data finished
-     *                      (SUSPENDING_PROCESS) / data has been read from the
-     *                      socket and is available for processing
-     *                      (SUSPENDING_WAIT)
-     *                      A call to resume() will:
-     *                      Server case: register the socket to the poller
-     *                      Client case: resume data processing
-     * CLOSING            - not suspended, a close will be send
+     * WAITING - not suspended Server case: waiting for a notification that data is ready to be read from the socket,
+     * the socket is registered to the poller Client case: data has been read from the socket and is waiting for data to
+     * be processed PROCESSING - not suspended Server case: reading from the socket and processing the data Client case:
+     * processing the data if such has already been read and more data will be read from the socket SUSPENDING_WAIT -
+     * suspended, a call to suspend() was made while in WAITING state. A call to resume() will do nothing and will
+     * transition to WAITING state SUSPENDING_PROCESS - suspended, a call to suspend() was made while in PROCESSING
+     * state. A call to resume() will do nothing and will transition to PROCESSING state SUSPENDED - suspended Server
+     * case: processing data finished (SUSPENDING_PROCESS) / a notification was received that data is ready to be read
+     * from the socket (SUSPENDING_WAIT), socket is not registered to the poller Client case: processing data finished
+     * (SUSPENDING_PROCESS) / data has been read from the socket and is available for processing (SUSPENDING_WAIT) A
+     * call to resume() will: Server case: register the socket to the poller Client case: resume data processing CLOSING
+     * - not suspended, a close will be send
      *
      * <pre>
      *     resume           data to be        resume
@@ -770,12 +716,12 @@ public abstract class WsFrameBase {
      * </pre>
      */
     protected enum ReadState {
-        WAITING           (false),
-        PROCESSING        (false),
-        SUSPENDING_WAIT   (true),
+        WAITING(false),
+        PROCESSING(false),
+        SUSPENDING_WAIT(true),
         SUSPENDING_PROCESS(true),
-        SUSPENDED         (true),
-        CLOSING           (false);
+        SUSPENDED(true),
+        CLOSING(false);
 
         private final boolean isSuspended;
 
@@ -791,49 +737,47 @@ public abstract class WsFrameBase {
     public void suspend() {
         while (true) {
             switch (readState) {
-            case WAITING:
-                if (!READ_STATE_UPDATER.compareAndSet(this, ReadState.WAITING,
-                        ReadState.SUSPENDING_WAIT)) {
-                    continue;
-                }
-                return;
-            case PROCESSING:
-                if (!READ_STATE_UPDATER.compareAndSet(this, ReadState.PROCESSING,
-                        ReadState.SUSPENDING_PROCESS)) {
-                    continue;
-                }
-                return;
-            case SUSPENDING_WAIT:
-                if (readState != ReadState.SUSPENDING_WAIT) {
-                    continue;
-                } else {
-                    if (getLog().isWarnEnabled()) {
-                        getLog().warn(sm.getString("wsFrame.suspendRequested"));
+                case WAITING:
+                    if (!READ_STATE_UPDATER.compareAndSet(this, ReadState.WAITING, ReadState.SUSPENDING_WAIT)) {
+                        continue;
                     }
-                }
-                return;
-            case SUSPENDING_PROCESS:
-                if (readState != ReadState.SUSPENDING_PROCESS) {
-                    continue;
-                } else {
-                    if (getLog().isWarnEnabled()) {
-                        getLog().warn(sm.getString("wsFrame.suspendRequested"));
+                    return;
+                case PROCESSING:
+                    if (!READ_STATE_UPDATER.compareAndSet(this, ReadState.PROCESSING, ReadState.SUSPENDING_PROCESS)) {
+                        continue;
                     }
-                }
-                return;
-            case SUSPENDED:
-                if (readState != ReadState.SUSPENDED) {
-                    continue;
-                } else {
-                    if (getLog().isWarnEnabled()) {
-                        getLog().warn(sm.getString("wsFrame.alreadySuspended"));
+                    return;
+                case SUSPENDING_WAIT:
+                    if (readState != ReadState.SUSPENDING_WAIT) {
+                        continue;
+                    } else {
+                        if (getLog().isWarnEnabled()) {
+                            getLog().warn(sm.getString("wsFrame.suspendRequested"));
+                        }
                     }
-                }
-                return;
-            case CLOSING:
-                return;
-            default:
-                throw new IllegalStateException(sm.getString("wsFrame.illegalReadState", state));
+                    return;
+                case SUSPENDING_PROCESS:
+                    if (readState != ReadState.SUSPENDING_PROCESS) {
+                        continue;
+                    } else {
+                        if (getLog().isWarnEnabled()) {
+                            getLog().warn(sm.getString("wsFrame.suspendRequested"));
+                        }
+                    }
+                    return;
+                case SUSPENDED:
+                    if (readState != ReadState.SUSPENDED) {
+                        continue;
+                    } else {
+                        if (getLog().isWarnEnabled()) {
+                            getLog().warn(sm.getString("wsFrame.alreadySuspended"));
+                        }
+                    }
+                    return;
+                case CLOSING:
+                    return;
+                default:
+                    throw new IllegalStateException(sm.getString("wsFrame.illegalReadState", state));
             }
         }
     }
@@ -841,47 +785,44 @@ public abstract class WsFrameBase {
     public void resume() {
         while (true) {
             switch (readState) {
-            case WAITING:
-                if (readState != ReadState.WAITING) {
-                    continue;
-                } else {
-                    if (getLog().isWarnEnabled()) {
-                        getLog().warn(sm.getString("wsFrame.alreadyResumed"));
+                case WAITING:
+                    if (readState != ReadState.WAITING) {
+                        continue;
+                    } else {
+                        if (getLog().isWarnEnabled()) {
+                            getLog().warn(sm.getString("wsFrame.alreadyResumed"));
+                        }
                     }
-                }
-                return;
-            case PROCESSING:
-                if (readState != ReadState.PROCESSING) {
-                    continue;
-                } else {
-                    if (getLog().isWarnEnabled()) {
-                        getLog().warn(sm.getString("wsFrame.alreadyResumed"));
+                    return;
+                case PROCESSING:
+                    if (readState != ReadState.PROCESSING) {
+                        continue;
+                    } else {
+                        if (getLog().isWarnEnabled()) {
+                            getLog().warn(sm.getString("wsFrame.alreadyResumed"));
+                        }
                     }
-                }
-                return;
-            case SUSPENDING_WAIT:
-                if (!READ_STATE_UPDATER.compareAndSet(this, ReadState.SUSPENDING_WAIT,
-                        ReadState.WAITING)) {
-                    continue;
-                }
-                return;
-            case SUSPENDING_PROCESS:
-                if (!READ_STATE_UPDATER.compareAndSet(this, ReadState.SUSPENDING_PROCESS,
-                        ReadState.PROCESSING)) {
-                    continue;
-                }
-                return;
-            case SUSPENDED:
-                if (!READ_STATE_UPDATER.compareAndSet(this, ReadState.SUSPENDED,
-                        ReadState.WAITING)) {
-                    continue;
-                }
-                resumeProcessing();
-                return;
-            case CLOSING:
-                return;
-            default:
-                throw new IllegalStateException(sm.getString("wsFrame.illegalReadState", state));
+                    return;
+                case SUSPENDING_WAIT:
+                    if (!READ_STATE_UPDATER.compareAndSet(this, ReadState.SUSPENDING_WAIT, ReadState.WAITING)) {
+                        continue;
+                    }
+                    return;
+                case SUSPENDING_PROCESS:
+                    if (!READ_STATE_UPDATER.compareAndSet(this, ReadState.SUSPENDING_PROCESS, ReadState.PROCESSING)) {
+                        continue;
+                    }
+                    return;
+                case SUSPENDED:
+                    if (!READ_STATE_UPDATER.compareAndSet(this, ReadState.SUSPENDED, ReadState.WAITING)) {
+                        continue;
+                    }
+                    resumeProcessing();
+                    return;
+                case CLOSING:
+                    return;
+                default:
+                    throw new IllegalStateException(sm.getString("wsFrame.illegalReadState", state));
             }
         }
     }
@@ -903,11 +844,9 @@ public abstract class WsFrameBase {
     }
 
     /**
-     * This method will be invoked when the read operation is resumed.
-     * As the suspend of the read operation can be invoked at any time, when
-     * implementing this method one should consider that there might still be
-     * data remaining into the internal buffers that needs to be processed
-     * before reading again from the socket.
+     * This method will be invoked when the read operation is resumed. As the suspend of the read operation can be
+     * invoked at any time, when implementing this method one should consider that there might still be data remaining
+     * into the internal buffers that needs to be processed before reading again from the socket.
      */
     protected abstract void resumeProcessing();
 
@@ -950,14 +889,12 @@ public abstract class WsFrameBase {
 
 
     /**
-     * For use by the client implementation that needs to obtain payload data
-     * without the need for unmasking.
+     * For use by the client implementation that needs to obtain payload data without the need for unmasking.
      */
     private final class NoopTransformation extends TerminalTransformation {
 
         @Override
-        public TransformationResult getMoreData(byte opCode, boolean fin, int rsv,
-                ByteBuffer dest) {
+        public TransformationResult getMoreData(byte opCode, boolean fin, int rsv, ByteBuffer dest) {
             // opCode is ignored as the transformation is the same for all
             // opCodes
             // rsv is ignored as it known to be zero at this point
@@ -991,19 +928,17 @@ public abstract class WsFrameBase {
 
 
     /**
-     * For use by the server implementation that needs to obtain payload data
-     * and unmask it before any further processing.
+     * For use by the server implementation that needs to obtain payload data and unmask it before any further
+     * processing.
      */
     private final class UnmaskTransformation extends TerminalTransformation {
 
         @Override
-        public TransformationResult getMoreData(byte opCode, boolean fin, int rsv,
-                ByteBuffer dest) {
+        public TransformationResult getMoreData(byte opCode, boolean fin, int rsv, ByteBuffer dest) {
             // opCode is ignored as the transformation is the same for all
             // opCodes
             // rsv is ignored as it known to be zero at this point
-            while (payloadWritten < payloadLength && inputBuffer.remaining() > 0 &&
-                    dest.hasRemaining()) {
+            while (payloadWritten < payloadLength && inputBuffer.remaining() > 0 && dest.hasRemaining()) {
                 byte b = (byte) ((inputBuffer.get() ^ mask[maskIndex]) & 0xFF);
                 maskIndex++;
                 if (maskIndex == 4) {

==================================================
WsHandshakeResponse.java
index 1d80d4fb0e..dd0c851790 100644
--- a/java/org/apache/tomcat/websocket/WsFrameClient.java
+++ b/java/org/apache/tomcat/websocket/WsFrameClient.java
@@ -59,66 +59,64 @@ public class WsFrameClient extends WsFrameBase {
     private void processSocketRead() throws IOException {
         while (true) {
             switch (getReadState()) {
-            case WAITING:
-                if (!changeReadState(ReadState.WAITING, ReadState.PROCESSING)) {
-                    continue;
-                }
-                while (response.hasRemaining()) {
-                    if (isSuspended()) {
-                        if (!changeReadState(ReadState.SUSPENDING_PROCESS, ReadState.SUSPENDED)) {
-                            continue;
-                        }
-                        // There is still data available in the response buffer
-                        // Return here so that the response buffer will not be
-                        // cleared and there will be no data read from the
-                        // socket. Thus when the read operation is resumed first
-                        // the data left in the response buffer will be consumed
-                        // and then a new socket read will be performed
-                        return;
+                case WAITING:
+                    if (!changeReadState(ReadState.WAITING, ReadState.PROCESSING)) {
+                        continue;
                     }
-                    inputBuffer.mark();
-                    inputBuffer.position(inputBuffer.limit()).limit(inputBuffer.capacity());
+                    while (response.hasRemaining()) {
+                        if (isSuspended()) {
+                            if (!changeReadState(ReadState.SUSPENDING_PROCESS, ReadState.SUSPENDED)) {
+                                continue;
+                            }
+                            // There is still data available in the response buffer
+                            // Return here so that the response buffer will not be
+                            // cleared and there will be no data read from the
+                            // socket. Thus when the read operation is resumed first
+                            // the data left in the response buffer will be consumed
+                            // and then a new socket read will be performed
+                            return;
+                        }
+                        inputBuffer.mark();
+                        inputBuffer.position(inputBuffer.limit()).limit(inputBuffer.capacity());
 
-                    int toCopy = Math.min(response.remaining(), inputBuffer.remaining());
+                        int toCopy = Math.min(response.remaining(), inputBuffer.remaining());
 
-                    // Copy remaining bytes read in HTTP phase to input buffer used by
-                    // frame processing
+                        // Copy remaining bytes read in HTTP phase to input buffer used by
+                        // frame processing
 
-                    int orgLimit = response.limit();
-                    response.limit(response.position() + toCopy);
-                    inputBuffer.put(response);
-                    response.limit(orgLimit);
+                        int orgLimit = response.limit();
+                        response.limit(response.position() + toCopy);
+                        inputBuffer.put(response);
+                        response.limit(orgLimit);
 
-                    inputBuffer.limit(inputBuffer.position()).reset();
+                        inputBuffer.limit(inputBuffer.position()).reset();
 
-                    // Process the data we have
-                    processInputBuffer();
-                }
-                response.clear();
+                        // Process the data we have
+                        processInputBuffer();
+                    }
+                    response.clear();
 
-                // Get some more data
-                if (isOpen()) {
-                    channel.read(response, null, handler);
-                } else {
-                    changeReadState(ReadState.CLOSING);
-                }
-                return;
-            case SUSPENDING_WAIT:
-                if (!changeReadState(ReadState.SUSPENDING_WAIT, ReadState.SUSPENDED)) {
-                    continue;
-                }
-                return;
-            default:
-                throw new IllegalStateException(
-                        sm.getString("wsFrameServer.illegalReadState", getReadState()));
+                    // Get some more data
+                    if (isOpen()) {
+                        channel.read(response, null, handler);
+                    } else {
+                        changeReadState(ReadState.CLOSING);
+                    }
+                    return;
+                case SUSPENDING_WAIT:
+                    if (!changeReadState(ReadState.SUSPENDING_WAIT, ReadState.SUSPENDED)) {
+                        continue;
+                    }
+                    return;
+                default:
+                    throw new IllegalStateException(sm.getString("wsFrameServer.illegalReadState", getReadState()));
             }
         }
     }
 
 
     /*
-     * Fatal error. Usually an I/O error. Try and send notifications. Make sure
-     * socket is closed.
+     * Fatal error. Usually an I/O error. Try and send notifications. Make sure socket is closed.
      */
     private void close(Throwable t) {
         changeReadState(ReadState.CLOSING);
@@ -170,8 +168,7 @@ public class WsFrameClient extends WsFrameBase {
             }
             if (exc instanceof ReadBufferOverflowException) {
                 // response will be empty if this exception is thrown
-                response = ByteBuffer
-                        .allocate(((ReadBufferOverflowException) exc).getMinBufferSize());
+                response = ByteBuffer.allocate(((ReadBufferOverflowException) exc).getMinBufferSize());
                 response.flip();
                 doResumeProcessing(false);
             } else {
@@ -182,20 +179,19 @@ public class WsFrameClient extends WsFrameBase {
         private void doResumeProcessing(boolean checkOpenOnError) {
             while (true) {
                 switch (getReadState()) {
-                case PROCESSING:
-                    if (!changeReadState(ReadState.PROCESSING, ReadState.WAITING)) {
-                        continue;
-                    }
-                    resumeProcessing(checkOpenOnError);
-                    return;
-                case SUSPENDING_PROCESS:
-                    if (!changeReadState(ReadState.SUSPENDING_PROCESS, ReadState.SUSPENDED)) {
-                        continue;
-                    }
-                    return;
-                default:
-                    throw new IllegalStateException(
-                            sm.getString("wsFrame.illegalReadState", getReadState()));
+                    case PROCESSING:
+                        if (!changeReadState(ReadState.PROCESSING, ReadState.WAITING)) {
+                            continue;
+                        }
+                        resumeProcessing(checkOpenOnError);
+                        return;
+                    case SUSPENDING_PROCESS:
+                        if (!changeReadState(ReadState.SUSPENDING_PROCESS, ReadState.SUSPENDED)) {
+                            continue;
+                        }
+                        return;
+                    default:
+                        throw new IllegalStateException(sm.getString("wsFrame.illegalReadState", getReadState()));
                 }
             }
         }

==================================================
WsIOException.java
index e99c03f399..a35f04dc54 100644
--- a/java/org/apache/tomcat/websocket/WsHandshakeResponse.java
+++ b/java/org/apache/tomcat/websocket/WsHandshakeResponse.java
@@ -30,15 +30,15 @@ import org.apache.tomcat.util.collections.CaseInsensitiveKeyMap;
  */
 public class WsHandshakeResponse implements HandshakeResponse {
 
-    private final Map<String,List<String>> headers = new CaseInsensitiveKeyMap<>();
+    private final Map<String, List<String>> headers = new CaseInsensitiveKeyMap<>();
 
 
     public WsHandshakeResponse() {
     }
 
 
-    public WsHandshakeResponse(Map<String,List<String>> headers) {
-        for (Entry<String,List<String>> entry : headers.entrySet()) {
+    public WsHandshakeResponse(Map<String, List<String>> headers) {
+        for (Entry<String, List<String>> entry : headers.entrySet()) {
             if (this.headers.containsKey(entry.getKey())) {
                 this.headers.get(entry.getKey()).addAll(entry.getValue());
             } else {
@@ -50,7 +50,7 @@ public class WsHandshakeResponse implements HandshakeResponse {
 
 
     @Override
-    public Map<String,List<String>> getHeaders() {
+    public Map<String, List<String>> getHeaders() {
         return headers;
     }
 }

==================================================
WsRemoteEndpointAsync.java
index c09e0ad2a8..d7fe6fbc71 100644
--- a/java/org/apache/tomcat/websocket/WsIOException.java
+++ b/java/org/apache/tomcat/websocket/WsIOException.java
@@ -21,9 +21,8 @@ import java.io.IOException;
 import jakarta.websocket.CloseReason;
 
 /**
- * Allows the WebSocket implementation to throw an {@link IOException} that
- * includes a {@link CloseReason} specific to the error that can be passed back
- * to the client.
+ * Allows the WebSocket implementation to throw an {@link IOException} that includes a {@link CloseReason} specific to
+ * the error that can be passed back to the client.
  */
 public class WsIOException extends IOException {
 

==================================================
WsRemoteEndpointBase.java
index afb59e941b..a214026ade 100644
--- a/java/org/apache/tomcat/websocket/WsRemoteEndpointAsync.java
+++ b/java/org/apache/tomcat/websocket/WsRemoteEndpointAsync.java
@@ -22,8 +22,7 @@ import java.util.concurrent.Future;
 import jakarta.websocket.RemoteEndpoint;
 import jakarta.websocket.SendHandler;
 
-public class WsRemoteEndpointAsync extends WsRemoteEndpointBase
-        implements RemoteEndpoint.Async {
+public class WsRemoteEndpointAsync extends WsRemoteEndpointBase implements RemoteEndpoint.Async {
 
     WsRemoteEndpointAsync(WsRemoteEndpointImplBase base) {
         super(base);

==================================================
WsRemoteEndpointBasic.java
index 65a5f27454..e0a054da88 100644
--- a/java/org/apache/tomcat/websocket/WsRemoteEndpointBase.java
+++ b/java/org/apache/tomcat/websocket/WsRemoteEndpointBase.java
@@ -50,15 +50,13 @@ public abstract class WsRemoteEndpointBase implements RemoteEndpoint {
 
 
     @Override
-    public final void sendPing(ByteBuffer applicationData) throws IOException,
-            IllegalArgumentException {
+    public final void sendPing(ByteBuffer applicationData) throws IOException, IllegalArgumentException {
         base.sendPing(applicationData);
     }
 
 
     @Override
-    public final void sendPong(ByteBuffer applicationData) throws IOException,
-            IllegalArgumentException {
+    public final void sendPong(ByteBuffer applicationData) throws IOException, IllegalArgumentException {
         base.sendPong(applicationData);
     }
 }

==================================================
WsRemoteEndpointImplBase.java
index 27859aac30..5bbd41f700 100644
--- a/java/org/apache/tomcat/websocket/WsRemoteEndpointBasic.java
+++ b/java/org/apache/tomcat/websocket/WsRemoteEndpointBasic.java
@@ -24,8 +24,7 @@ import java.nio.ByteBuffer;
 import jakarta.websocket.EncodeException;
 import jakarta.websocket.RemoteEndpoint;
 
-public class WsRemoteEndpointBasic extends WsRemoteEndpointBase
-        implements RemoteEndpoint.Basic {
+public class WsRemoteEndpointBasic extends WsRemoteEndpointBase implements RemoteEndpoint.Basic {
 
     WsRemoteEndpointBasic(WsRemoteEndpointImplBase base) {
         super(base);
@@ -51,8 +50,7 @@ public class WsRemoteEndpointBasic extends WsRemoteEndpointBase
 
 
     @Override
-    public void sendBinary(ByteBuffer partialByte, boolean isLast)
-            throws IOException {
+    public void sendBinary(ByteBuffer partialByte, boolean isLast) throws IOException {
         base.sendPartialBytes(partialByte, isLast);
     }
 

==================================================
WsRemoteEndpointImplClient.java
index cfa3d3e9a3..eec3381a85 100644
--- a/java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java
+++ b/java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java
@@ -55,8 +55,7 @@ import org.apache.tomcat.util.res.StringManager;
 
 public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
 
-    protected static final StringManager sm =
-            StringManager.getManager(WsRemoteEndpointImplBase.class);
+    protected static final StringManager sm = StringManager.getManager(WsRemoteEndpointImplBase.class);
 
     protected static final SendResult SENDRESULT_OK = new SendResult();
 
@@ -64,8 +63,7 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
 
     private final StateMachine stateMachine = new StateMachine();
 
-    private final IntermediateMessageHandler intermediateMessageHandler =
-            new IntermediateMessageHandler(this);
+    private final IntermediateMessageHandler intermediateMessageHandler = new IntermediateMessageHandler(this);
 
     private Transformation transformation = null;
     private final Semaphore messagePartInProgress = new Semaphore(1);
@@ -157,8 +155,7 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
     }
 
 
-    public void sendPartialBytes(ByteBuffer partialByte, boolean last)
-            throws IOException {
+    public void sendPartialBytes(ByteBuffer partialByte, boolean last) throws IOException {
         if (partialByte == null) {
             throw new IllegalArgumentException(sm.getString("wsRemoteEndpoint.nullData"));
         }
@@ -169,8 +166,7 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
 
 
     @Override
-    public void sendPing(ByteBuffer applicationData) throws IOException,
-            IllegalArgumentException {
+    public void sendPing(ByteBuffer applicationData) throws IOException, IllegalArgumentException {
         if (applicationData.remaining() > 125) {
             throw new IllegalArgumentException(sm.getString("wsRemoteEndpoint.tooMuchData"));
         }
@@ -179,8 +175,7 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
 
 
     @Override
-    public void sendPong(ByteBuffer applicationData) throws IOException,
-            IllegalArgumentException {
+    public void sendPong(ByteBuffer applicationData) throws IOException, IllegalArgumentException {
         if (applicationData.remaining() > 125) {
             throw new IllegalArgumentException(sm.getString("wsRemoteEndpoint.tooMuchData"));
         }
@@ -212,15 +207,14 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
             throw new IllegalArgumentException(sm.getString("wsRemoteEndpoint.nullHandler"));
         }
         stateMachine.textStart();
-        TextMessageSendHandler tmsh = new TextMessageSendHandler(handler,
-                CharBuffer.wrap(text), true, encoder, encoderBuffer, this);
+        TextMessageSendHandler tmsh = new TextMessageSendHandler(handler, CharBuffer.wrap(text), true, encoder,
+                encoderBuffer, this);
         tmsh.write();
         // TextMessageSendHandler will update stateMachine when it completes
     }
 
 
-    public void sendPartialString(String fragment, boolean isLast)
-            throws IOException {
+    public void sendPartialString(String fragment, boolean isLast) throws IOException {
         if (fragment == null) {
             throw new IllegalArgumentException(sm.getString("wsRemoteEndpoint.nullData"));
         }
@@ -258,8 +252,7 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
     }
 
 
-    void sendMessageBlock(byte opCode, ByteBuffer payload, boolean last)
-            throws IOException {
+    void sendMessageBlock(byte opCode, ByteBuffer payload, boolean last) throws IOException {
         sendMessageBlock(opCode, payload, last, getTimeoutExpiry());
     }
 
@@ -277,8 +270,8 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
     }
 
 
-    private void sendMessageBlock(byte opCode, ByteBuffer payload, boolean last,
-            long timeoutExpiry) throws IOException {
+    private void sendMessageBlock(byte opCode, ByteBuffer payload, boolean last, long timeoutExpiry)
+            throws IOException {
         wsSession.updateLastActiveWrite();
 
         BlockingSendHandler bsh = new BlockingSendHandler();
@@ -325,7 +318,7 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
                 Throwable t = bsh.getSendResult().getException();
                 wsSession.doClose(new CloseReason(CloseCodes.GOING_AWAY, t.getMessage()),
                         new CloseReason(CloseCodes.CLOSED_ABNORMALLY, t.getMessage()), true);
-                throw new IOException (t);
+                throw new IOException(t);
             }
             // The BlockingSendHandler doesn't call end message so update the
             // flags.
@@ -341,14 +334,12 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
     }
 
 
-    void startMessage(byte opCode, ByteBuffer payload, boolean last,
-            SendHandler handler) {
+    void startMessage(byte opCode, ByteBuffer payload, boolean last, SendHandler handler) {
 
         wsSession.updateLastActiveWrite();
 
         List<MessagePart> messageParts = new ArrayList<>();
-        messageParts.add(new MessagePart(last, 0, opCode, payload,
-                intermediateMessageHandler,
+        messageParts.add(new MessagePart(last, 0, opCode, payload, intermediateMessageHandler,
                 new EndMessageHandler(this, handler), -1));
 
         try {
@@ -412,7 +403,7 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
             mpNext = messagePartQueue.poll();
             if (mpNext == null) {
                 messagePartInProgress.release();
-            } else if (!closed){
+            } else if (!closed) {
                 // Session may have been closed unexpectedly in the middle of
                 // sending a fragmented message closing the endpoint. If this
                 // happens, clearly there is no point trying to send the rest of
@@ -439,16 +430,14 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
 
     void writeMessagePart(MessagePart mp) {
         if (closed) {
-            throw new IllegalStateException(
-                    sm.getString("wsRemoteEndpoint.closed"));
+            throw new IllegalStateException(sm.getString("wsRemoteEndpoint.closed"));
         }
 
         if (Constants.INTERNAL_OPCODE_FLUSH == mp.getOpCode()) {
             nextFragmented = fragmented;
             nextText = text;
             outputBuffer.flip();
-            SendHandler flushHandler = new OutputBufferFlushSendHandler(
-                    outputBuffer, mp.getEndHandler());
+            SendHandler flushHandler = new OutputBufferFlushSendHandler(outputBuffer, mp.getEndHandler());
             doWrite(flushHandler, mp.getBlockingWriteTimeoutExpiry(), outputBuffer);
             return;
         }
@@ -469,8 +458,7 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
             if (fragmented) {
                 // Currently fragmented
                 if (text != isText) {
-                    throw new IllegalStateException(
-                            sm.getString("wsRemoteEndpoint.changeType"));
+                    throw new IllegalStateException(sm.getString("wsRemoteEndpoint.changeType"));
                 }
                 nextText = text;
                 nextFragmented = !mp.isFin();
@@ -497,21 +485,18 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
 
         int payloadSize = mp.getPayload().remaining();
         headerBuffer.clear();
-        writeHeader(headerBuffer, mp.isFin(), mp.getRsv(), mp.getOpCode(),
-                isMasked(), mp.getPayload(), mask, first);
+        writeHeader(headerBuffer, mp.isFin(), mp.getRsv(), mp.getOpCode(), isMasked(), mp.getPayload(), mask, first);
         headerBuffer.flip();
 
         if (getBatchingAllowed() || isMasked()) {
             // Need to write via output buffer
-            OutputBufferSendHandler obsh = new OutputBufferSendHandler(
-                    mp.getEndHandler(), mp.getBlockingWriteTimeoutExpiry(),
-                    headerBuffer, mp.getPayload(), mask,
-                    outputBuffer, !getBatchingAllowed(), this);
+            OutputBufferSendHandler obsh = new OutputBufferSendHandler(mp.getEndHandler(),
+                    mp.getBlockingWriteTimeoutExpiry(), headerBuffer, mp.getPayload(), mask, outputBuffer,
+                    !getBatchingAllowed(), this);
             obsh.write();
         } else {
             // Can write directly
-            doWrite(mp.getEndHandler(), mp.getBlockingWriteTimeoutExpiry(),
-                    headerBuffer, mp.getPayload());
+            doWrite(mp.getEndHandler(), mp.getBlockingWriteTimeoutExpiry(), headerBuffer, mp.getPayload());
         }
 
         updateStats(payloadSize);
@@ -519,9 +504,8 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
 
 
     /**
-     * Hook for updating server side statistics. Called on every frame written
-     * (including when batching is enabled and the frames are buffered locally
-     * until the buffer is full or is flushed).
+     * Hook for updating server side statistics. Called on every frame written (including when batching is enabled and
+     * the frames are buffered locally until the buffer is full or is flushed).
      *
      * @param payloadLength Size of message payload
      */
@@ -545,16 +529,14 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
 
 
     /**
-     * Wraps the user provided handler so that the end point is notified when
-     * the message is complete.
+     * Wraps the user provided handler so that the end point is notified when the message is complete.
      */
     private static class EndMessageHandler implements SendHandler {
 
         private final WsRemoteEndpointImplBase endpoint;
         private final SendHandler handler;
 
-        EndMessageHandler(WsRemoteEndpointImplBase endpoint,
-                SendHandler handler) {
+        EndMessageHandler(WsRemoteEndpointImplBase endpoint, SendHandler handler) {
             this.endpoint = endpoint;
             this.handler = handler;
         }
@@ -568,13 +550,11 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
 
 
     /**
-     * If a transformation needs to split a {@link MessagePart} into multiple
-     * {@link MessagePart}s, it uses this handler as the end handler for each of
-     * the additional {@link MessagePart}s. This handler notifies this this
-     * class that the {@link MessagePart} has been processed and that the next
-     * {@link MessagePart} in the queue should be started. The final
-     * {@link MessagePart} will use the {@link EndMessageHandler} provided with
-     * the original {@link MessagePart}.
+     * If a transformation needs to split a {@link MessagePart} into multiple {@link MessagePart}s, it uses this handler
+     * as the end handler for each of the additional {@link MessagePart}s. This handler notifies this this class that
+     * the {@link MessagePart} has been processed and that the next {@link MessagePart} in the queue should be started.
+     * The final {@link MessagePart} will use the {@link EndMessageHandler} provided with the original
+     * {@link MessagePart}.
      */
     private static class IntermediateMessageHandler implements SendHandler {
 
@@ -592,15 +572,14 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
     }
 
 
-    @SuppressWarnings({"unchecked", "rawtypes"})
+    @SuppressWarnings({ "unchecked", "rawtypes" })
     public void sendObject(Object obj) throws IOException, EncodeException {
         if (obj == null) {
             throw new IllegalArgumentException(sm.getString("wsRemoteEndpoint.nullData"));
         }
         /*
-         * Note that the implementation will convert primitives and their object
-         * equivalents by default but that users are free to specify their own
-         * encoders and decoders for this if they wish.
+         * Note that the implementation will convert primitives and their object equivalents by default but that users
+         * are free to specify their own encoders and decoders for this if they wish.
          */
         Encoder encoder = findEncoder(obj);
         if (encoder == null && Util.isPrimitive(obj.getClass())) {
@@ -629,8 +608,7 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
                 ((Encoder.BinaryStream) encoder).encode(obj, os);
             }
         } else {
-            throw new EncodeException(obj, sm.getString(
-                    "wsRemoteEndpoint.noEncoder", obj.getClass()));
+            throw new EncodeException(obj, sm.getString("wsRemoteEndpoint.noEncoder", obj.getClass()));
         }
     }
 
@@ -642,7 +620,7 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
     }
 
 
-    @SuppressWarnings({"unchecked", "rawtypes"})
+    @SuppressWarnings({ "unchecked", "rawtypes" })
     public void sendObjectByCompletion(Object obj, SendHandler completion) {
 
         if (obj == null) {
@@ -653,9 +631,8 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
         }
 
         /*
-         * Note that the implementation will convert primitives and their object
-         * equivalents by default but that users are free to specify their own
-         * encoders and decoders for this if they wish.
+         * Note that the implementation will convert primitives and their object equivalents by default but that users
+         * are free to specify their own encoders and decoders for this if they wish.
          */
         Encoder encoder = findEncoder(obj);
         if (encoder == null && Util.isPrimitive(obj.getClass())) {
@@ -687,8 +664,7 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
                 }
                 completion.onResult(new SendResult());
             } else {
-                throw new EncodeException(obj, sm.getString(
-                        "wsRemoteEndpoint.noEncoder", obj.getClass()));
+                throw new EncodeException(obj, sm.getString("wsRemoteEndpoint.noEncoder", obj.getClass()));
             }
         } catch (Exception e) {
             SendResult sr = new SendResult(e);
@@ -702,11 +678,9 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
     }
 
 
-    protected void setEncoders(EndpointConfig endpointConfig)
-            throws DeploymentException {
+    protected void setEncoders(EndpointConfig endpointConfig) throws DeploymentException {
         encoderEntries.clear();
-        for (Class<? extends Encoder> encoderClazz :
-                endpointConfig.getEncoders()) {
+        for (Class<? extends Encoder> encoderClazz : endpointConfig.getEncoders()) {
             Encoder instance;
             InstanceManager instanceManager = wsSession.getInstanceManager();
             try {
@@ -717,12 +691,10 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
                 }
                 instance.init(endpointConfig);
             } catch (ReflectiveOperationException | NamingException e) {
-                throw new DeploymentException(
-                        sm.getString("wsRemoteEndpoint.invalidEncoder",
-                                encoderClazz.getName()), e);
+                throw new DeploymentException(sm.getString("wsRemoteEndpoint.invalidEncoder", encoderClazz.getName()),
+                        e);
             }
-            EncoderEntry entry = new EncoderEntry(
-                    Util.getEncoderType(encoderClazz), instance);
+            EncoderEntry entry = new EncoderEntry(Util.getEncoderType(encoderClazz), instance);
             encoderEntries.add(entry);
         }
     }
@@ -757,14 +729,14 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
     }
 
 
-    protected abstract void doWrite(SendHandler handler, long blockingWriteTimeoutExpiry,
-            ByteBuffer... data);
+    protected abstract void doWrite(SendHandler handler, long blockingWriteTimeoutExpiry, ByteBuffer... data);
+
     protected abstract boolean isMasked();
+
     protected abstract void doClose();
 
-    private static void writeHeader(ByteBuffer headerBuffer, boolean fin,
-            int rsv, byte opCode, boolean masked, ByteBuffer payload,
-            byte[] mask, boolean first) {
+    private static void writeHeader(ByteBuffer headerBuffer, boolean fin, int rsv, byte opCode, boolean masked,
+            ByteBuffer payload, byte[] mask, boolean first) {
 
         byte b = 0;
 
@@ -827,8 +799,7 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
         private final WsRemoteEndpointImplBase endpoint;
         private volatile boolean isDone = false;
 
-        TextMessageSendHandler(SendHandler handler, CharBuffer message,
-                boolean isLast, CharsetEncoder encoder,
+        TextMessageSendHandler(SendHandler handler, CharBuffer message, boolean isLast, CharsetEncoder encoder,
                 ByteBuffer encoderBuffer, WsRemoteEndpointImplBase endpoint) {
             this.handler = handler;
             this.message = message;
@@ -846,8 +817,7 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
             }
             isDone = !cr.isOverflow();
             buffer.flip();
-            endpoint.startMessage(Constants.OPCODE_TEXT, buffer,
-                    isDone && isLast, this);
+            endpoint.startMessage(Constants.OPCODE_TEXT, buffer, isDone && isLast, this);
         }
 
         @Override
@@ -855,11 +825,10 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
             if (isDone) {
                 endpoint.stateMachine.complete(isLast);
                 handler.onResult(result);
-            } else if(!result.isOK()) {
+            } else if (!result.isOK()) {
                 handler.onResult(result);
-            } else if (closed){
-                SendResult sr = new SendResult(new IOException(
-                        sm.getString("wsRemoteEndpoint.closedDuringMessage")));
+            } else if (closed) {
+                SendResult sr = new SendResult(new IOException(sm.getString("wsRemoteEndpoint.closedDuringMessage")));
                 handler.onResult(sr);
             } else {
                 write();
@@ -869,8 +838,7 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
 
 
     /**
-     * Used to write data to the output buffer, flushing the buffer if it fills
-     * up.
+     * Used to write data to the output buffer, flushing the buffer if it fills up.
      */
     private static class OutputBufferSendHandler implements SendHandler {
 
@@ -884,10 +852,8 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
         private final WsRemoteEndpointImplBase endpoint;
         private volatile int maskIndex = 0;
 
-        OutputBufferSendHandler(SendHandler completion,
-                long blockingWriteTimeoutExpiry,
-                ByteBuffer headerBuffer, ByteBuffer payload, byte[] mask,
-                ByteBuffer outputBuffer, boolean flushRequired,
+        OutputBufferSendHandler(SendHandler completion, long blockingWriteTimeoutExpiry, ByteBuffer headerBuffer,
+                ByteBuffer payload, byte[] mask, ByteBuffer outputBuffer, boolean flushRequired,
                 WsRemoteEndpointImplBase endpoint) {
             this.blockingWriteTimeoutExpiry = blockingWriteTimeoutExpiry;
             this.handler = completion;
@@ -928,8 +894,7 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
                 outputBuffer.put(payload);
             } else {
                 for (int i = 0; i < toWrite; i++) {
-                    outputBuffer.put(
-                            (byte) (payload.get() ^ (mask[maskIndex++] & 0xFF)));
+                    outputBuffer.put((byte) (payload.get() ^ (mask[maskIndex++] & 0xFF)));
                     if (maskIndex > 3) {
                         maskIndex = 0;
                     }
@@ -1012,8 +977,7 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
         @Override
         public void write(int b) throws IOException {
             if (closed) {
-                throw new IllegalStateException(
-                        sm.getString("wsRemoteEndpoint.closedOutputStream"));
+                throw new IllegalStateException(sm.getString("wsRemoteEndpoint.closedOutputStream"));
             }
 
             used = true;
@@ -1026,11 +990,9 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
         @Override
         public void write(byte[] b, int off, int len) throws IOException {
             if (closed) {
-                throw new IllegalStateException(
-                        sm.getString("wsRemoteEndpoint.closedOutputStream"));
+                throw new IllegalStateException(sm.getString("wsRemoteEndpoint.closedOutputStream"));
             }
-            if ((off < 0) || (off > b.length) || (len < 0) ||
-                ((off + len) > b.length) || ((off + len) < 0)) {
+            if ((off < 0) || (off > b.length) || (len < 0) || ((off + len) > b.length) || ((off + len) < 0)) {
                 throw new IndexOutOfBoundsException();
             }
 
@@ -1058,8 +1020,7 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
         @Override
         public void flush() throws IOException {
             if (closed) {
-                throw new IllegalStateException(
-                        sm.getString("wsRemoteEndpoint.closedOutputStream"));
+                throw new IllegalStateException(sm.getString("wsRemoteEndpoint.closedOutputStream"));
             }
 
             // Optimisation. If there is no data to flush then do not send an
@@ -1107,11 +1068,9 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
         @Override
         public void write(char[] cbuf, int off, int len) throws IOException {
             if (closed) {
-                throw new IllegalStateException(
-                        sm.getString("wsRemoteEndpoint.closedWriter"));
+                throw new IllegalStateException(sm.getString("wsRemoteEndpoint.closedWriter"));
             }
-            if ((off < 0) || (off > cbuf.length) || (len < 0) ||
-                    ((off + len) > cbuf.length) || ((off + len) < 0)) {
+            if ((off < 0) || (off > cbuf.length) || (len < 0) || ((off + len) > cbuf.length) || ((off + len) < 0)) {
                 throw new IndexOutOfBoundsException();
             }
 
@@ -1139,8 +1098,7 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
         @Override
         public void flush() throws IOException {
             if (closed) {
-                throw new IllegalStateException(
-                        sm.getString("wsRemoteEndpoint.closedWriter"));
+                throw new IllegalStateException(sm.getString("wsRemoteEndpoint.closedWriter"));
             }
 
             if (buffer.position() > 0) {
@@ -1240,27 +1198,25 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
 
         public synchronized void complete(boolean last) {
             if (last) {
-                checkState(State.TEXT_PARTIAL_WRITING, State.TEXT_FULL_WRITING,
-                        State.BINARY_PARTIAL_WRITING, State.BINARY_FULL_WRITING,
-                        State.STREAM_WRITING, State.WRITER_WRITING);
+                checkState(State.TEXT_PARTIAL_WRITING, State.TEXT_FULL_WRITING, State.BINARY_PARTIAL_WRITING,
+                        State.BINARY_FULL_WRITING, State.STREAM_WRITING, State.WRITER_WRITING);
                 state = State.OPEN;
             } else {
-                checkState(State.TEXT_PARTIAL_WRITING, State.BINARY_PARTIAL_WRITING,
-                        State.STREAM_WRITING, State.WRITER_WRITING);
+                checkState(State.TEXT_PARTIAL_WRITING, State.BINARY_PARTIAL_WRITING, State.STREAM_WRITING,
+                        State.WRITER_WRITING);
                 if (state == State.TEXT_PARTIAL_WRITING) {
                     state = State.TEXT_PARTIAL_READY;
-                } else if (state == State.BINARY_PARTIAL_WRITING){
+                } else if (state == State.BINARY_PARTIAL_WRITING) {
                     state = State.BINARY_PARTIAL_READY;
                 } else if (state == State.WRITER_WRITING) {
                     // NO-OP. Leave state as is.
                 } else if (state == State.STREAM_WRITING) {
-                 // NO-OP. Leave state as is.
+                    // NO-OP. Leave state as is.
                 } else {
                     // Should never happen
                     // The if ... else ... blocks above should cover all states
                     // permitted by the preceding checkState() call
-                    throw new IllegalStateException(
-                            "BUG: This code should never be called");
+                    throw new IllegalStateException("BUG: This code should never be called");
                 }
             }
         }
@@ -1271,8 +1227,7 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
                     return;
                 }
             }
-            throw new IllegalStateException(
-                    sm.getString("wsRemoteEndpoint.wrongState", this.state));
+            throw new IllegalStateException(sm.getString("wsRemoteEndpoint.wrongState", this.state));
         }
     }
 

==================================================
WsSession.java
index 789326bb13..d22ac2d3fd 100644
--- a/java/org/apache/tomcat/websocket/WsRemoteEndpointImplClient.java
+++ b/java/org/apache/tomcat/websocket/WsRemoteEndpointImplClient.java
@@ -41,8 +41,7 @@ public class WsRemoteEndpointImplClient extends WsRemoteEndpointImplBase {
 
 
     @Override
-    protected void doWrite(SendHandler handler, long blockingWriteTimeoutExpiry,
-            ByteBuffer... data) {
+    protected void doWrite(SendHandler handler, long blockingWriteTimeoutExpiry, ByteBuffer... data) {
         long timeout;
         for (ByteBuffer byteBuffer : data) {
             if (blockingWriteTimeoutExpiry == -1) {

==================================================
WsWebSocketContainer.java
index c7e331900b..1851e80001 100644
--- a/java/org/apache/tomcat/websocket/WsSession.java
+++ b/java/org/apache/tomcat/websocket/WsSession.java
@@ -78,8 +78,8 @@ public class WsSession implements Session {
         // be sufficient to pass the validation tests.
         ServerEndpointConfig.Builder builder = ServerEndpointConfig.Builder.create(Object.class, "/");
         ServerEndpointConfig sec = builder.build();
-        SEC_CONFIGURATOR_USES_IMPL_DEFAULT =
-                sec.getConfigurator().getClass().equals(DefaultServerEndpointConfigurator.class);
+        SEC_CONFIGURATOR_USES_IMPL_DEFAULT = sec.getConfigurator().getClass()
+                .equals(DefaultServerEndpointConfigurator.class);
     }
 
     private final Endpoint localEndpoint;
@@ -118,32 +118,26 @@ public class WsSession implements Session {
 
 
     /**
-     * Creates a new WebSocket session for communication between the provided
-     * client and remote end points. The result of
-     * {@link Thread#getContextClassLoader()} at the time this constructor is
-     * called will be used when calling
+     * Creates a new WebSocket session for communication between the provided client and remote end points. The result
+     * of {@link Thread#getContextClassLoader()} at the time this constructor is called will be used when calling
      * {@link Endpoint#onClose(Session, CloseReason)}.
      *
      * @param clientEndpointHolder The end point managed by this code
      * @param wsRemoteEndpoint     The other / remote end point
      * @param wsWebSocketContainer The container that created this session
      * @param negotiatedExtensions The agreed extensions to use for this session
-     * @param subProtocol          The agreed sub-protocol to use for this
-     *                             session
-     * @param pathParameters       The path parameters associated with the
-     *                             request that initiated this session or
-     *                             <code>null</code> if this is a client session
-     * @param secure               Was this session initiated over a secure
-     *                             connection?
-     * @param clientEndpointConfig The configuration information for the client
-     *                             end point
+     * @param subProtocol          The agreed sub-protocol to use for this session
+     * @param pathParameters       The path parameters associated with the request that initiated this session or
+     *                                 <code>null</code> if this is a client session
+     * @param secure               Was this session initiated over a secure connection?
+     * @param clientEndpointConfig The configuration information for the client end point
+     *
      * @throws DeploymentException if an invalid encode is specified
      */
-    public WsSession(ClientEndpointHolder clientEndpointHolder,
-            WsRemoteEndpointImplBase wsRemoteEndpoint,
-            WsWebSocketContainer wsWebSocketContainer,
-            List<Extension> negotiatedExtensions, String subProtocol, Map<String, String> pathParameters,
-            boolean secure, ClientEndpointConfig clientEndpointConfig) throws DeploymentException {
+    public WsSession(ClientEndpointHolder clientEndpointHolder, WsRemoteEndpointImplBase wsRemoteEndpoint,
+            WsWebSocketContainer wsWebSocketContainer, List<Extension> negotiatedExtensions, String subProtocol,
+            Map<String, String> pathParameters, boolean secure, ClientEndpointConfig clientEndpointConfig)
+            throws DeploymentException {
         this.wsRemoteEndpoint = wsRemoteEndpoint;
         this.wsRemoteEndpoint.setSession(this);
         this.remoteEndpointAsync = new WsRemoteEndpointAsync(wsRemoteEndpoint);
@@ -182,46 +176,36 @@ public class WsSession implements Session {
 
 
     /**
-     * Creates a new WebSocket session for communication between the provided
-     * server and remote end points. The result of
-     * {@link Thread#getContextClassLoader()} at the time this constructor is
-     * called will be used when calling
+     * Creates a new WebSocket session for communication between the provided server and remote end points. The result
+     * of {@link Thread#getContextClassLoader()} at the time this constructor is called will be used when calling
      * {@link Endpoint#onClose(Session, CloseReason)}.
      *
      * @param wsRemoteEndpoint     The other / remote end point
      * @param wsWebSocketContainer The container that created this session
-     * @param requestUri           The URI used to connect to this end point or
-     *                             <code>null</code> if this is a client session
-     * @param requestParameterMap  The parameters associated with the request
-     *                             that initiated this session or
-     *                             <code>null</code> if this is a client session
-     * @param queryString          The query string associated with the request
-     *                             that initiated this session or
-     *                             <code>null</code> if this is a client session
-     * @param userPrincipal        The principal associated with the request
-     *                             that initiated this session or
-     *                             <code>null</code> if this is a client session
-     * @param httpSessionId        The HTTP session ID associated with the
-     *                             request that initiated this session or
-     *                             <code>null</code> if this is a client session
+     * @param requestUri           The URI used to connect to this end point or <code>null</code> if this is a client
+     *                                 session
+     * @param requestParameterMap  The parameters associated with the request that initiated this session or
+     *                                 <code>null</code> if this is a client session
+     * @param queryString          The query string associated with the request that initiated this session or
+     *                                 <code>null</code> if this is a client session
+     * @param userPrincipal        The principal associated with the request that initiated this session or
+     *                                 <code>null</code> if this is a client session
+     * @param httpSessionId        The HTTP session ID associated with the request that initiated this session or
+     *                                 <code>null</code> if this is a client session
      * @param negotiatedExtensions The agreed extensions to use for this session
-     * @param subProtocol          The agreed sub-protocol to use for this
-     *                             session
-     * @param pathParameters       The path parameters associated with the
-     *                             request that initiated this session or
-     *                             <code>null</code> if this is a client session
-     * @param secure               Was this session initiated over a secure
-     *                             connection?
-     * @param serverEndpointConfig The configuration information for the server
-     *                             end point
+     * @param subProtocol          The agreed sub-protocol to use for this session
+     * @param pathParameters       The path parameters associated with the request that initiated this session or
+     *                                 <code>null</code> if this is a client session
+     * @param secure               Was this session initiated over a secure connection?
+     * @param serverEndpointConfig The configuration information for the server end point
+     *
      * @throws DeploymentException if an invalid encode is specified
      */
-    public WsSession(WsRemoteEndpointImplBase wsRemoteEndpoint,
-            WsWebSocketContainer wsWebSocketContainer,
-            URI requestUri, Map<String, List<String>> requestParameterMap,
-            String queryString, Principal userPrincipal, String httpSessionId,
-            List<Extension> negotiatedExtensions, String subProtocol, Map<String, String> pathParameters,
-            boolean secure, ServerEndpointConfig serverEndpointConfig) throws DeploymentException {
+    public WsSession(WsRemoteEndpointImplBase wsRemoteEndpoint, WsWebSocketContainer wsWebSocketContainer,
+            URI requestUri, Map<String, List<String>> requestParameterMap, String queryString, Principal userPrincipal,
+            String httpSessionId, List<Extension> negotiatedExtensions, String subProtocol,
+            Map<String, String> pathParameters, boolean secure, ServerEndpointConfig serverEndpointConfig)
+            throws DeploymentException {
 
         this.wsRemoteEndpoint = wsRemoteEndpoint;
         this.wsRemoteEndpoint.setSession(this);
@@ -322,15 +306,13 @@ public class WsSession implements Session {
 
 
     @Override
-    public <T> void addMessageHandler(Class<T> clazz, Partial<T> handler)
-            throws IllegalStateException {
+    public <T> void addMessageHandler(Class<T> clazz, Partial<T> handler) throws IllegalStateException {
         doAddMessageHandler(clazz, handler);
     }
 
 
     @Override
-    public <T> void addMessageHandler(Class<T> clazz, Whole<T> handler)
-            throws IllegalStateException {
+    public <T> void addMessageHandler(Class<T> clazz, Whole<T> handler) throws IllegalStateException {
         doAddMessageHandler(clazz, handler);
     }
 
@@ -349,44 +331,41 @@ public class WsSession implements Session {
         // arbitrary objects with MessageHandlers and can wrap MessageHandlers
         // just as easily.
 
-        Set<MessageHandlerResult> mhResults = Util.getMessageHandlers(target, listener,
-                endpointConfig, this);
+        Set<MessageHandlerResult> mhResults = Util.getMessageHandlers(target, listener, endpointConfig, this);
 
         for (MessageHandlerResult mhResult : mhResults) {
             switch (mhResult.getType()) {
-            case TEXT: {
-                if (textMessageHandler != null) {
-                    throw new IllegalStateException(sm.getString("wsSession.duplicateHandlerText"));
+                case TEXT: {
+                    if (textMessageHandler != null) {
+                        throw new IllegalStateException(sm.getString("wsSession.duplicateHandlerText"));
+                    }
+                    textMessageHandler = mhResult.getHandler();
+                    break;
                 }
-                textMessageHandler = mhResult.getHandler();
-                break;
-            }
-            case BINARY: {
-                if (binaryMessageHandler != null) {
-                    throw new IllegalStateException(
-                            sm.getString("wsSession.duplicateHandlerBinary"));
+                case BINARY: {
+                    if (binaryMessageHandler != null) {
+                        throw new IllegalStateException(sm.getString("wsSession.duplicateHandlerBinary"));
+                    }
+                    binaryMessageHandler = mhResult.getHandler();
+                    break;
                 }
-                binaryMessageHandler = mhResult.getHandler();
-                break;
-            }
-            case PONG: {
-                if (pongMessageHandler != null) {
-                    throw new IllegalStateException(sm.getString("wsSession.duplicateHandlerPong"));
+                case PONG: {
+                    if (pongMessageHandler != null) {
+                        throw new IllegalStateException(sm.getString("wsSession.duplicateHandlerPong"));
+                    }
+                    MessageHandler handler = mhResult.getHandler();
+                    if (handler instanceof MessageHandler.Whole<?>) {
+                        pongMessageHandler = (MessageHandler.Whole<PongMessage>) handler;
+                    } else {
+                        throw new IllegalStateException(sm.getString("wsSession.invalidHandlerTypePong"));
+                    }
+
+                    break;
                 }
-                MessageHandler handler = mhResult.getHandler();
-                if (handler instanceof MessageHandler.Whole<?>) {
-                    pongMessageHandler = (MessageHandler.Whole<PongMessage>) handler;
-                } else {
-                    throw new IllegalStateException(
-                            sm.getString("wsSession.invalidHandlerTypePong"));
+                default: {
+                    throw new IllegalArgumentException(
+                            sm.getString("wsSession.unknownHandlerType", listener, mhResult.getType()));
                 }
-
-                break;
-            }
-            default: {
-                throw new IllegalArgumentException(
-                        sm.getString("wsSession.unknownHandlerType", listener, mhResult.getType()));
-            }
             }
         }
     }
@@ -445,8 +424,7 @@ public class WsSession implements Session {
         if (!removed) {
             // ISE for now. Could swallow this silently / log this if the ISE
             // becomes a problem
-            throw new IllegalStateException(
-                    sm.getString("wsSession.removeHandlerFailed", listener));
+            throw new IllegalStateException(sm.getString("wsSession.removeHandlerFailed", listener));
         }
     }
 
@@ -561,9 +539,8 @@ public class WsSession implements Session {
 
 
     /**
-     * WebSocket 1.0. Section 2.1.5.
-     * Need internal close method as spec requires that the local endpoint
-     * receives a 1006 on timeout.
+     * WebSocket 1.0. Section 2.1.5. Need internal close method as spec requires that the local endpoint receives a 1006
+     * on timeout.
      *
      * @param closeReasonMessage The close reason to pass to the remote endpoint
      * @param closeReasonLocal   The close reason to pass to the local endpoint
@@ -574,17 +551,14 @@ public class WsSession implements Session {
 
 
     /**
-     * WebSocket 1.0. Section 2.1.5.
-     * Need internal close method as spec requires that the local endpoint
-     * receives a 1006 on timeout.
+     * WebSocket 1.0. Section 2.1.5. Need internal close method as spec requires that the local endpoint receives a 1006
+     * on timeout.
      *
      * @param closeReasonMessage The close reason to pass to the remote endpoint
      * @param closeReasonLocal   The close reason to pass to the local endpoint
-     * @param closeSocket        Should the socket be closed immediately rather than waiting
-     *                           for the server to respond
+     * @param closeSocket        Should the socket be closed immediately rather than waiting for the server to respond
      */
-    public void doClose(CloseReason closeReasonMessage, CloseReason closeReasonLocal,
-            boolean closeSocket) {
+    public void doClose(CloseReason closeReasonMessage, CloseReason closeReasonLocal, boolean closeSocket) {
         // Double-checked locking. OK because state is volatile
         if (state != State.OPEN) {
             return;
@@ -608,9 +582,8 @@ public class WsSession implements Session {
             }
 
             /*
-             * If the flush above fails the error handling could call this
-             * method recursively. Without this check, the close message and
-             * notifications could be sent multiple times.
+             * If the flush above fails the error handling could call this method recursively. Without this check, the
+             * close message and notifications could be sent multiple times.
              */
             if (state != State.OUTPUT_CLOSED) {
                 state = State.OUTPUT_CLOSED;
@@ -632,12 +605,10 @@ public class WsSession implements Session {
 
 
     /**
-     * Called when a close message is received. Should only ever happen once.
-     * Also called after a protocol error when the ProtocolHandler needs to
-     * force the closing of the connection.
+     * Called when a close message is received. Should only ever happen once. Also called after a protocol error when
+     * the ProtocolHandler needs to force the closing of the connection.
      *
-     * @param closeReason The reason contained within the received close
-     *                    message.
+     * @param closeReason The reason contained within the received close message.
      */
     public void onClose(CloseReason closeReason) {
 
@@ -695,7 +666,6 @@ public class WsSession implements Session {
     }
 
 
-
     private void fireEndpointOnError(Throwable throwable) {
 
         // Fire the onError event
@@ -761,7 +731,8 @@ public class WsSession implements Session {
 
     /**
      * Use protected so unit tests can access this method directly.
-     * @param msg The message
+     *
+     * @param msg    The message
      * @param reason The reason
      */
     protected static void appendCloseReasonWithTruncation(ByteBuffer msg, String reason) {
@@ -791,9 +762,9 @@ public class WsSession implements Session {
 
 
     /**
-     * Make the session aware of a {@link FutureToSendHandler} that will need to
-     * be forcibly closed if the session closes before the
-     * {@link FutureToSendHandler} completes.
+     * Make the session aware of a {@link FutureToSendHandler} that will need to be forcibly closed if the session
+     * closes before the {@link FutureToSendHandler} completes.
+     *
      * @param f2sh The handler
      */
     protected void registerFuture(FutureToSendHandler f2sh) {
@@ -834,7 +805,7 @@ public class WsSession implements Session {
         // complete the Future but knowing if this is the case requires the sync
         // on stateLock (see above).
         // Note: If multiple attempts are made to complete the Future, the
-        //       second and subsequent attempts are ignored.
+        // second and subsequent attempts are ignored.
 
         IOException ioe = new IOException(sm.getString("wsSession.messageFailed"));
         SendResult sr = new SendResult(ioe);
@@ -844,6 +815,7 @@ public class WsSession implements Session {
 
     /**
      * Remove a {@link FutureToSendHandler} from the set of tracked instances.
+     *
      * @param f2sh The handler
      */
     protected void unregisterFuture(FutureToSendHandler f2sh) {
@@ -983,8 +955,8 @@ public class WsSession implements Session {
     private void checkState() {
         if (state == State.CLOSED) {
             /*
-             * As per RFC 6455, a WebSocket connection is considered to be
-             * closed once a peer has sent and received a WebSocket close frame.
+             * As per RFC 6455, a WebSocket connection is considered to be closed once a peer has sent and received a
+             * WebSocket close frame.
              */
             throw new IllegalStateException(sm.getString("wsSession.closed", id));
         }
@@ -998,6 +970,7 @@ public class WsSession implements Session {
 
 
     private WsFrameBase wsFrame;
+
     void setWsFrame(WsFrameBase wsFrame) {
         this.wsFrame = wsFrame;
     }

==================================================
