954cb1c3f259941152ad889b18a380be2bec6756
==================================================
Remove JreCompat support for Java 16 and associated Java < 16 code
==================================================
Mark Thomas
==================================================
Thu Jan 19 10:32:28 2023 +0000
==================================================
MessageBytes.java
index 8f937024bc..7434a083dc 100644
--- a/java/org/apache/tomcat/util/buf/LocalStrings_zh_CN.properties
+++ b/java/org/apache/tomcat/util/buf/LocalStrings_zh_CN.properties
@@ -27,8 +27,6 @@ encodedSolidusHandling.invalid=值[{0}]未识别
 hexUtils.fromHex.nonHex=输入只能由十六进制数字组成
 hexUtils.fromHex.oddDigits=输入必须由偶数个十六进制数字组成
 
-messageBytes.illegalCharacter=代码点[{1}]处的Unicode字符[{0}]无法编码，因为它超出了允许的0到255范围。
-
 uDecoder.eof=文件结尾（EOF）
 uDecoder.noSlash=不允许使用编码的斜杠字符
 uDecoder.urlDecode.conversionError=使用编码[{1}]解码[{0}]失败

==================================================
Jre16Compat.java
index be693b399f..d013231470 100644
--- a/java/org/apache/tomcat/util/buf/MessageBytes.java
+++ b/java/org/apache/tomcat/util/buf/MessageBytes.java
@@ -26,9 +26,6 @@ import java.nio.charset.CharsetEncoder;
 import java.nio.charset.CodingErrorAction;
 import java.util.Locale;
 
-import org.apache.tomcat.util.compat.JreCompat;
-import org.apache.tomcat.util.res.StringManager;
-
 /**
  * This class is used to represent a subarray of bytes in an HTTP message.
  * It represents all request/response elements. The byte/char conversions are
@@ -45,8 +42,6 @@ public final class MessageBytes implements Cloneable, Serializable {
 
     private static final long serialVersionUID = 1L;
 
-    private static final StringManager sm = StringManager.getManager(MessageBytes.class);
-
     // primary type ( whatever is set as original value )
     private int type = T_NULL;
 
@@ -256,17 +251,6 @@ public final class MessageBytes implements Cloneable, Serializable {
             return;
         }
 
-        if (!JreCompat.isJre16Available() && getCharset() == ByteChunk.DEFAULT_CHARSET) {
-            if (type == T_CHARS) {
-                toBytesSimple(charC.getChars(), charC.getStart(), charC.getLength());
-            } else {
-                // Must be T_STR
-                char[] chars = strValue.toCharArray();
-                toBytesSimple(chars, 0, chars.length);
-            }
-            return;
-        }
-
         ByteBuffer bb;
         CharsetEncoder encoder = getCharset().newEncoder();
         encoder.onMalformedInput(CodingErrorAction.REPORT);
@@ -292,31 +276,6 @@ public final class MessageBytes implements Cloneable, Serializable {
     }
 
 
-    /**
-     * Simple conversion of chars to bytes.
-     *
-     * @throws IllegalArgumentException if any of the characters to convert are
-     *                                  above code point 0xFF.
-     */
-    private void toBytesSimple(char[] chars, int start, int len) {
-        byteC.recycle();
-        byteC.allocate(len, byteC.getLimit());
-        byte[] bytes = byteC.getBuffer();
-
-        for (int i = 0; i < len; i++) {
-            if (chars[i + start] > 255) {
-                throw new IllegalArgumentException(sm.getString("messageBytes.illegalCharacter",
-                        Character.toString(chars[i + start]), Integer.valueOf(chars[i + start])));
-            } else {
-                bytes[i] = (byte) chars[i + start];
-            }
-        }
-
-        byteC.setEnd(len);
-        type = T_BYTES;
-    }
-
-
     /**
      * Convert to char[] and fill the CharChunk.
      *

==================================================
Jre19Compat.java
deleted file mode 100644
index fd05da4830..0000000000
--- a/java/org/apache/tomcat/util/compat/Jre16Compat.java
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.util.compat;
-
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.net.ProtocolFamily;
-import java.net.SocketAddress;
-import java.net.StandardProtocolFamily;
-import java.nio.channels.ServerSocketChannel;
-import java.nio.channels.SocketChannel;
-
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-import org.apache.tomcat.util.res.StringManager;
-
-class Jre16Compat extends JreCompat {
-
-    private static final Log log = LogFactory.getLog(Jre16Compat.class);
-    private static final StringManager sm = StringManager.getManager(Jre16Compat.class);
-
-    private static final Class<?> unixDomainSocketAddressClazz;
-    private static final Method openServerSocketChannelFamilyMethod;
-    private static final Method unixDomainSocketAddressOfMethod;
-    private static final Method openSocketChannelFamilyMethod;
-
-    static {
-        Class<?> c1 = null;
-        Method m1 = null;
-        Method m2 = null;
-        Method m3 = null;
-        try {
-            c1 = Class.forName("java.net.UnixDomainSocketAddress");
-            m1 = ServerSocketChannel.class.getMethod("open", ProtocolFamily.class);
-            m2 = c1.getMethod("of", String.class);
-            m3 = SocketChannel.class.getMethod("open", ProtocolFamily.class);
-        } catch (ClassNotFoundException e) {
-            // Must be pre-Java 16
-            log.debug(sm.getString("jre16Compat.javaPre16"), e);
-        } catch (ReflectiveOperationException | IllegalArgumentException e) {
-            // Should never happen
-            log.error(sm.getString("jre16Compat.unexpected"), e);
-        }
-        unixDomainSocketAddressClazz = c1;
-        openServerSocketChannelFamilyMethod = m1;
-        unixDomainSocketAddressOfMethod = m2;
-        openSocketChannelFamilyMethod = m3;
-    }
-
-    static boolean isSupported() {
-        return unixDomainSocketAddressClazz != null;
-    }
-
-
-    @Override
-    public SocketAddress getUnixDomainSocketAddress(String path) {
-        try {
-            return (SocketAddress) unixDomainSocketAddressOfMethod.invoke(null, path);
-        } catch (IllegalAccessException | IllegalArgumentException
-                | InvocationTargetException e) {
-            throw new UnsupportedOperationException(e);
-        }
-    }
-
-
-    @Override
-    public ServerSocketChannel openUnixDomainServerSocketChannel() {
-        try {
-            return (ServerSocketChannel) openServerSocketChannelFamilyMethod.invoke
-                    (null, StandardProtocolFamily.valueOf("UNIX"));
-        } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
-            throw new UnsupportedOperationException(e);
-        }
-    }
-
-
-    @Override
-    public SocketChannel openUnixDomainSocketChannel() {
-        try {
-            return (SocketChannel) openSocketChannelFamilyMethod.invoke
-                    (null, StandardProtocolFamily.valueOf("UNIX"));
-        } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
-            throw new UnsupportedOperationException(e);
-        }
-    }
-}

==================================================
JreCompat.java
index fb94810b40..9fb26f0090 100644
--- a/java/org/apache/tomcat/util/compat/Jre19Compat.java
+++ b/java/org/apache/tomcat/util/compat/Jre19Compat.java
@@ -22,7 +22,7 @@ import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.res.StringManager;
 
-public class Jre19Compat extends Jre16Compat {
+public class Jre19Compat extends JreCompat {
 
     private static final Log log = LogFactory.getLog(Jre19Compat.class);
     private static final StringManager sm = StringManager.getManager(Jre19Compat.class);

==================================================
NioEndpoint.java
index c7be88b3ae..571a2bffd2 100644
--- a/java/org/apache/tomcat/util/compat/LocalStrings_zh_CN.properties
+++ b/java/org/apache/tomcat/util/compat/LocalStrings_zh_CN.properties
@@ -13,9 +13,4 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-jre16Compat.javaPre16=类未找到，因此假设代码在Java16之前的JVM上运行
-jre16Compat.unexpected=无法创建对Java16中类和方法的引用
-
 jre19Compat.javaPre19=该类未找到，因此推测当前代码运行在Java 19版本之前的虚拟机上
-
-jreCompat.noUnixDomainSocket=Java运行环境不支持Unix域名套接字。你必须使用Java16来运行该特性。

==================================================
TestMessageBytes.java
index 7bad146bcf..8c6a3ae566 100644
--- a/java/org/apache/tomcat/util/net/NioEndpoint.java
+++ b/java/org/apache/tomcat/util/net/NioEndpoint.java
@@ -24,6 +24,8 @@ import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
 import java.net.SocketTimeoutException;
+import java.net.StandardProtocolFamily;
+import java.net.UnixDomainSocketAddress;
 import java.nio.ByteBuffer;
 import java.nio.channels.CancelledKeyException;
 import java.nio.channels.Channel;
@@ -57,7 +59,6 @@ import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.ExceptionUtils;
 import org.apache.tomcat.util.collections.SynchronizedQueue;
 import org.apache.tomcat.util.collections.SynchronizedStack;
-import org.apache.tomcat.util.compat.JreCompat;
 import org.apache.tomcat.util.compat.JrePlatform;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.Acceptor.AcceptorState;
@@ -219,8 +220,8 @@ public class NioEndpoint extends AbstractNetworkChannelEndpoint<NioChannel,Socke
                 throw new IllegalArgumentException(sm.getString("endpoint.init.bind.inherited"));
             }
         } else if (getUnixDomainSocketPath() != null) {
-            SocketAddress sa = JreCompat.getInstance().getUnixDomainSocketAddress(getUnixDomainSocketPath());
-            serverSock = JreCompat.getInstance().openUnixDomainServerSocketChannel();
+            SocketAddress sa = UnixDomainSocketAddress.of(getUnixDomainSocketPath());
+            serverSock = ServerSocketChannel.open(StandardProtocolFamily.UNIX);
             serverSock.bind(sa, getAcceptCount());
             if (getUnixDomainSocketPathPermissions() != null) {
                 Path path = Paths.get(getUnixDomainSocketPath());
@@ -393,8 +394,8 @@ public class NioEndpoint extends AbstractNetworkChannelEndpoint<NioChannel,Socke
                 return;
             }
             try {
-                SocketAddress sa = JreCompat.getInstance().getUnixDomainSocketAddress(getUnixDomainSocketPath());
-                try (SocketChannel socket = JreCompat.getInstance().openUnixDomainSocketChannel()) {
+                SocketAddress sa = UnixDomainSocketAddress.of(getUnixDomainSocketPath());
+                try (SocketChannel socket = SocketChannel.open(StandardProtocolFamily.UNIX)) {
                     // With a UDS, expect no delay connecting and no defer accept
                     socket.connect(sa);
                 }

==================================================
TestXxxEndpoint.java
index 4abc1b6374..f9af7fd19d 100644
--- a/test/org/apache/tomcat/util/buf/TestMessageBytes.java
+++ b/test/org/apache/tomcat/util/buf/TestMessageBytes.java
@@ -16,40 +16,10 @@
  */
 package org.apache.tomcat.util.buf;
 
-import java.nio.CharBuffer;
-import java.nio.charset.CharacterCodingException;
-import java.nio.charset.CharsetEncoder;
-import java.nio.charset.CodingErrorAction;
-import java.nio.charset.StandardCharsets;
-
-import org.junit.Assert;
-import org.junit.Assume;
 import org.junit.Test;
 
-import org.apache.tomcat.util.compat.JreCompat;
-
 public class TestMessageBytes {
 
-    private static final String CONVERSION_STRING =
-            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF" +
-            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF" +
-            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF" +
-            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF" +
-            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF" +
-            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF" +
-            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF" +
-            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF" +
-            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF" +
-            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF" +
-            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF" +
-            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF" +
-            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF" +
-            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF" +
-            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF" +
-            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF";
-
-    private static final int CONVERSION_LOOPS = 1000000;
-
     @Test
     public void testToStringFromNull() {
         MessageBytes mb = MessageBytes.newInstance();
@@ -96,69 +66,4 @@ public class TestMessageBytes {
         mb.recycle();
         mb.toChars();
     }
-
-
-    /*
-     * Checks the the optimized code is faster than the non-optimized code.
-     */
-    @Test
-    public void testConversionPerformance() {
-
-        // ISO_8859_1 conversion appears to be optimised in Java 16 onwards
-        Assume.assumeFalse(JreCompat.isJre16Available());
-
-        long optimized = -1;
-        long nonOptimized = -1;
-
-        /*
-         * One loop is likely to be enough as the optimised code is
-         * significantly (3x to 4x on markt's desktop) faster than the
-         * non-optimised code. Loop three times allows once to warn up the JVM
-         * once to run the test and once more in case of unexpected CI /GC
-         * slowness. The test will exit early if possible.
-         *
-         * MessageBytes only optimises conversion for ISO_8859_1
-         */
-        for (int i = 0; i < 3; i++) {
-            optimized = doTestOptimisedConversionPerformance();
-            nonOptimized = doTestConversionPerformance();
-
-            System.out.println(optimized + " " + nonOptimized);
-            if (optimized * 2 < nonOptimized) {
-                break;
-            }
-        }
-
-        Assert.assertTrue("Non-optimised code was faster (" + nonOptimized + "ns) compared to optimized (" +
-                optimized + "ns)", optimized < nonOptimized);
-    }
-
-
-    private long doTestOptimisedConversionPerformance() {
-        MessageBytes mb = MessageBytes.newInstance();
-
-        long start = System.nanoTime();
-        for (int i = 0; i < CONVERSION_LOOPS; i++) {
-            mb.recycle();
-            mb.setCharset(StandardCharsets.ISO_8859_1);
-            mb.setString(CONVERSION_STRING);
-            mb.toBytes();
-        }
-        return System.nanoTime() - start;
-    }
-
-
-    private long doTestConversionPerformance() {
-        long start = System.nanoTime();
-        for (int i = 0; i < CONVERSION_LOOPS; i++) {
-            CharsetEncoder encoder = StandardCharsets.ISO_8859_1.newEncoder().onMalformedInput(
-                    CodingErrorAction.REPORT).onUnmappableCharacter(CodingErrorAction.REPORT);
-            try {
-                encoder.encode(CharBuffer.wrap(CONVERSION_STRING));
-            } catch (CharacterCodingException cce) {
-                Assert.fail();
-            }
-        }
-        return System.nanoTime() - start;
-    }
 }

==================================================
