4ff4094bfc2374e6ecfb0a7407a40e4e819ef239
==================================================
Complete a TODO.
==================================================
Mark Thomas
==================================================
Thu Nov 26 20:53:26 2015 +0000
==================================================
AbstractProcessorLight.java
Complete a TODO.
Remove the hack that added ASYNC_END as a SocketState.
Simplify processing loop.


git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1716766 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AsyncStateMachine.java
index 90e0f159bd..b0aa6ed191 100644
--- a/java/org/apache/coyote/AbstractProcessorLight.java
+++ b/java/org/apache/coyote/AbstractProcessorLight.java
@@ -54,16 +54,6 @@ public abstract class AbstractProcessorLight implements Processor {
                 // Do nothing here, just wait for it to get recycled
             } else if (isAsync() || isUpgrade()) {
                 state = dispatch(status);
-            } else if (state == SocketState.ASYNC_END) {
-                state = dispatch(status);
-                if (state == SocketState.OPEN) {
-                    // There may be pipe-lined data to read. If the data
-                    // isn't processed now, execution will exit this
-                    // loop and call release() which will recycle the
-                    // processor (and input buffer) deleting any
-                    // pipe-lined data. To avoid this, process it now.
-                    state = service(socketWrapper);
-                }
             } else if (status == SocketStatus.OPEN_WRITE) {
                 // Extra write event likely after async, ignore
                 state = SocketState.LONG;
@@ -73,6 +63,18 @@ public abstract class AbstractProcessorLight implements Processor {
 
             if (state != SocketState.CLOSED && isAsync()) {
                 state = asyncPostProcess();
+                if (state != SocketState.LONG) {
+                    // Async has ended.
+                    state = dispatch(status);
+                    if (state == SocketState.OPEN) {
+                        // There may be pipe-lined data to read. If the data
+                        // isn't processed now, execution will exit this
+                        // loop and call release() which will recycle the
+                        // processor (and input buffer) deleting any
+                        // pipe-lined data. To avoid this, process it now.
+                        state = service(socketWrapper);
+                    }
+                }
             }
 
             if (getLog().isDebugEnabled()) {
@@ -86,8 +88,7 @@ public abstract class AbstractProcessorLight implements Processor {
                 // dispatches to process.
                 dispatches = getIteratorAndClearDispatches();
             }
-        } while (state == SocketState.ASYNC_END ||
-                dispatches != null && state != SocketState.CLOSED);
+        } while (dispatches != null && state != SocketState.CLOSED);
 
         return state;
     }

==================================================
AbstractEndpoint.java
index 37a3904c72..e5c1572adf 100644
--- a/java/org/apache/coyote/AsyncStateMachine.java
+++ b/java/org/apache/coyote/AsyncStateMachine.java
@@ -241,17 +241,17 @@ public class AsyncStateMachine {
         } else if (state == AsyncState.MUST_COMPLETE) {
             asyncCtxt.fireOnComplete();
             state = AsyncState.DISPATCHED;
-            return SocketState.ASYNC_END;
+            return SocketState.OPEN;
         } else if (state == AsyncState.COMPLETING) {
             asyncCtxt.fireOnComplete();
             state = AsyncState.DISPATCHED;
-            return SocketState.ASYNC_END;
+            return SocketState.OPEN;
         } else if (state == AsyncState.MUST_DISPATCH) {
             state = AsyncState.DISPATCHING;
-            return SocketState.ASYNC_END;
+            return SocketState.OPEN;
         } else if (state == AsyncState.DISPATCHING) {
             state = AsyncState.DISPATCHED;
-            return SocketState.ASYNC_END;
+            return SocketState.OPEN;
         } else if (state == AsyncState.STARTED) {
             // This can occur if an async listener does a dispatch to an async
             // servlet during onTimeout

==================================================
