fa72a782c4375149aa59fa1a850f5602c3fe3507
==================================================
Javadoc fixes.
==================================================
Remy Maucherat
==================================================
Thu Jan 14 15:57:49 2016 +0000
==================================================
AbstractProcessor.java
Javadoc fixes.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1724638 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AbstractProcessorLight.java
index c256e2b2e6..c0c715bd56 100644
--- a/java/org/apache/coyote/AbstractProcessor.java
+++ b/java/org/apache/coyote/AbstractProcessor.java
@@ -55,9 +55,8 @@ public abstract class AbstractProcessor extends AbstractProcessorLight implement
 
     /**
      * Used by HTTP/2.
-     *
-     * @param coyoteRequest
-     * @param coyoteResponse
+     * @param coyoteRequest The request
+     * @param coyoteResponse The response
      */
     protected AbstractProcessor(Request coyoteRequest, Response coyoteResponse) {
         this(null, coyoteRequest, coyoteResponse);
@@ -83,6 +82,8 @@ public abstract class AbstractProcessor extends AbstractProcessorLight implement
     /**
      * Update the current error state to the new error state if the new error
      * state is more severe than the current error state.
+     * @param errorState The error status details
+     * @param t The error which occurred
      */
     protected void setErrorState(ErrorState errorState, Throwable t) {
         boolean blockIo = this.errorState.isIoAllowed() && !errorState.isIoAllowed();
@@ -135,6 +136,7 @@ public abstract class AbstractProcessor extends AbstractProcessorLight implement
 
     /**
      * Set the socket wrapper being used.
+     * @param socketWrapper The socket wrapper
      */
     protected final void setSocketWrapper(SocketWrapperBase<?> socketWrapper) {
         this.socketWrapper = socketWrapper;
@@ -142,7 +144,7 @@ public abstract class AbstractProcessor extends AbstractProcessorLight implement
 
 
     /**
-     * Get the socket wrapper being used.
+     * @return the socket wrapper being used.
      */
     protected final SocketWrapperBase<?> getSocketWrapper() {
         return socketWrapper;
@@ -156,7 +158,7 @@ public abstract class AbstractProcessor extends AbstractProcessorLight implement
 
 
     /**
-     * Obtain the Executor used by the underlying endpoint.
+     * @return the Executor used by the underlying endpoint.
      */
     protected Executor getExecutor() {
         return endpoint.getExecutor();

==================================================
AbstractProtocol.java
index bb72d7e4bc..c199dac36d 100644
--- a/java/org/apache/coyote/AbstractProcessorLight.java
+++ b/java/org/apache/coyote/AbstractProcessorLight.java
@@ -144,6 +144,8 @@ public abstract class AbstractProcessorLight implements Processor {
      * Uses currently include Servlet 3.0 Async and HTTP upgrade connections.
      * Further uses may be added in the future. These will typically start as
      * HTTP requests.
+     * @param status The event to process
+     * @return the socket state
      */
     protected abstract SocketState dispatch(SocketEvent status);
 

==================================================
AjpProcessor.java
index 1228b58849..9ae3cada31 100644
--- a/java/org/apache/coyote/AbstractProtocol.java
+++ b/java/org/apache/coyote/AbstractProtocol.java
@@ -393,6 +393,7 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
     /**
      * Concrete implementations need to provide access to their logger to be
      * used by the abstract classes.
+     * @return the logger
      */
     protected abstract Log getLog();
 
@@ -400,19 +401,22 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
     /**
      * Obtain the prefix to be used when construction a name for this protocol
      * handler. The name will be prefix-address-port.
+     * @return the prefix
      */
     protected abstract String getNamePrefix();
 
 
     /**
      * Obtain the name of the protocol, (Http, Ajp, etc.). Used with JMX.
+     * @return the protocol name
      */
     protected abstract String getProtocolName();
 
 
     /**
+     * Find a suitable handler for the protocol negotiated
+     * at the network layer.
      * @param name The name of the requested negotiated protocol.
-     *
      * @return The instance where {@link UpgradeProtocol#getAlpnName()} matches
      *         the requested protocol
      */

==================================================
Http11OutputBuffer.java
index b219919992..6973703bb0 100644
--- a/java/org/apache/coyote/ajp/AjpProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpProcessor.java
@@ -932,8 +932,10 @@ public class AjpProcessor extends AbstractProcessor {
     /**
      * Get more request body data from the web server and store it in the
      * internal buffer.
-     *
-     * @return true if there is more data, false if not.
+     * @param block <code>true</code> if this is blocking IO
+     * @return <code>true</code> if there is more data,
+     *  <code>false</code> if not.
+     * @throws IOException An IO error occurred
      */
     protected boolean refillReadBuffer(boolean block) throws IOException {
         // When using replay (e.g. after FORM auth) all the data to read has

==================================================
ChunkedInputFilter.java
index 803ad9a3cc..5174517284 100644
--- a/java/org/apache/coyote/http11/Http11OutputBuffer.java
+++ b/java/org/apache/coyote/http11/Http11OutputBuffer.java
@@ -527,7 +527,7 @@ public class Http11OutputBuffer implements OutputBuffer {
      * @param block     Should this method block until the buffer is empty
      * @return  <code>true</code> if data remains in the buffer (which can only
      *          happen in non-blocking mode) else <code>false</code>.
-     * @throws IOException
+     * @throws IOException Error writing data
      */
     protected boolean flushBuffer(boolean block) throws IOException  {
         return socketWrapper.flush(block);
@@ -536,6 +536,7 @@ public class Http11OutputBuffer implements OutputBuffer {
 
     /**
      * Is standard Servlet blocking IO being used for output?
+     * @return <code>true</code> if this is blocking IO
      */
     protected final boolean isBlocking() {
         return response.getWriteListener() == null;

==================================================
AbstractStream.java
index 498e278773..47241d4fbd 100644
--- a/java/org/apache/coyote/http11/filters/ChunkedInputFilter.java
+++ b/java/org/apache/coyote/http11/filters/ChunkedInputFilter.java
@@ -305,6 +305,8 @@ public class ChunkedInputFilter implements InputFilter {
 
     /**
      * Read bytes from the previous buffer.
+     * @return The byte count which has been read
+     * @throws IOException Read error
      */
     protected int readBytes() throws IOException {
 
@@ -327,6 +329,9 @@ public class ChunkedInputFilter implements InputFilter {
      * The letters before CRLF or ';' (whatever comes first) must be valid hex
      * digits. We should not parse F23IAMGONNAMESSTHISUP34CRLF as a valid
      * header according to the spec.
+     * @return <code>true</code> if the chunk header has been
+     *  successfully parsed
+     * @throws IOException Read error
      */
     protected boolean parseChunkHeader() throws IOException {
 
@@ -397,6 +402,7 @@ public class ChunkedInputFilter implements InputFilter {
      * @param   tolerant    Should tolerant parsing (LF and CRLF) be used? This
      *                      is recommended (RFC2616, section 19.3) for message
      *                      headers.
+     * @throws IOException An error occurred parsing CRLF
      */
     protected void parseCRLF(boolean tolerant) throws IOException {
 
@@ -431,6 +437,7 @@ public class ChunkedInputFilter implements InputFilter {
 
     /**
      * Parse end chunk data.
+     * @throws IOException Error propagation
      */
     protected void parseEndChunk() throws IOException {
         // Handle optional trailer headers

==================================================
