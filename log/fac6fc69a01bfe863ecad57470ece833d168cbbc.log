fac6fc69a01bfe863ecad57470ece833d168cbbc
==================================================
Code clean-up. Format. No functional change.
==================================================
Mark Thomas
==================================================
Mon Mar 6 20:54:47 2023 +0000
==================================================
AbstractAjpProtocol.java
Code clean-up. Format. No functional change.


==================================================
AjpMessage.java
index 537a1d0b04..16ea5772d7 100644
--- a/java/org/apache/coyote/ajp/AbstractAjpProtocol.java
+++ b/java/org/apache/coyote/ajp/AbstractAjpProtocol.java
@@ -29,10 +29,9 @@ import org.apache.tomcat.util.net.SocketWrapperBase;
 import org.apache.tomcat.util.res.StringManager;
 
 /**
- * The is the base implementation for the AJP protocol handlers. Implementations
- * typically extend this base class rather than implement {@link
- * org.apache.coyote.ProtocolHandler}. All of the implementations that ship with
- * Tomcat are implemented this way.
+ * The is the base implementation for the AJP protocol handlers. Implementations typically extend this base class rather
+ * than implement {@link org.apache.coyote.ProtocolHandler}. All of the implementations that ship with Tomcat are
+ * implemented this way.
  *
  * @param <S> The type of socket used by the implementation
  */
@@ -44,7 +43,7 @@ public abstract class AbstractAjpProtocol<S> extends AbstractProtocol<S> {
     protected static final StringManager sm = StringManager.getManager(AbstractAjpProtocol.class);
 
 
-    public AbstractAjpProtocol(AbstractEndpoint<S,?> endpoint) {
+    public AbstractAjpProtocol(AbstractEndpoint<S, ?> endpoint) {
         super(endpoint);
         setConnectionTimeout(Constants.DEFAULT_CONNECTION_TIMEOUT);
         // AJP does not use Send File
@@ -61,20 +60,16 @@ public abstract class AbstractAjpProtocol<S> extends AbstractProtocol<S> {
 
 
     /**
-     * {@inheritDoc}
-     *
-     * Overridden to make getter accessible to other classes in this package.
+     * {@inheritDoc} Overridden to make getter accessible to other classes in this package.
      */
     @Override
-    protected AbstractEndpoint<S,?> getEndpoint() {
+    protected AbstractEndpoint<S, ?> getEndpoint() {
         return super.getEndpoint();
     }
 
 
     /**
-     * {@inheritDoc}
-     *
-     * AJP does not support protocol negotiation so this always returns null.
+     * {@inheritDoc} AJP does not support protocol negotiation so this always returns null.
      */
     @Override
     protected UpgradeProtocol getNegotiatedProtocol(String name) {
@@ -83,9 +78,7 @@ public abstract class AbstractAjpProtocol<S> extends AbstractProtocol<S> {
 
 
     /**
-     * {@inheritDoc}
-     *
-     * AJP does not support protocol upgrade so this always returns null.
+     * {@inheritDoc} AJP does not support protocol upgrade so this always returns null.
      */
     @Override
     protected UpgradeProtocol getUpgradeProtocol(String name) {
@@ -96,17 +89,18 @@ public abstract class AbstractAjpProtocol<S> extends AbstractProtocol<S> {
     // ------------------------------------------ managed in the ProtocolHandler
 
     private boolean ajpFlush = true;
-    public boolean getAjpFlush() { return ajpFlush; }
+
+    public boolean getAjpFlush() {
+        return ajpFlush;
+    }
+
     /**
-     * Configure whether to aend an AJP flush packet when flushing. A flush
-     * packet is a zero byte AJP13 SEND_BODY_CHUNK packet. mod_jk and
-     * mod_proxy_ajp interpret this as a request to flush data to the client.
-     * AJP always does flush at the and of the response, so if it is not
-     * important, that the packets get streamed up to the client, do not use
-     * extra flush packets. For compatibility and to stay on the safe side,
-     * flush packets are enabled by default.
+     * Configure whether to aend an AJP flush packet when flushing. A flush packet is a zero byte AJP13 SEND_BODY_CHUNK
+     * packet. mod_jk and mod_proxy_ajp interpret this as a request to flush data to the client. AJP always does flush
+     * at the and of the response, so if it is not important, that the packets get streamed up to the client, do not use
+     * extra flush packets. For compatibility and to stay on the safe side, flush packets are enabled by default.
      *
-     * @param ajpFlush  The new flush setting
+     * @param ajpFlush The new flush setting
      */
     public void setAjpFlush(boolean ajpFlush) {
         this.ajpFlush = ajpFlush;
@@ -114,34 +108,39 @@ public abstract class AbstractAjpProtocol<S> extends AbstractProtocol<S> {
 
 
     private boolean tomcatAuthentication = true;
+
     /**
-     * Should authentication be done in the native web server layer,
-     * or in the Servlet container ?
+     * Should authentication be done in the native web server layer, or in the Servlet container ?
      *
-     * @return {@code true} if authentication should be performed by Tomcat,
-     *         otherwise {@code false}
+     * @return {@code true} if authentication should be performed by Tomcat, otherwise {@code false}
      */
-    public boolean getTomcatAuthentication() { return tomcatAuthentication; }
+    public boolean getTomcatAuthentication() {
+        return tomcatAuthentication;
+    }
+
     public void setTomcatAuthentication(boolean tomcatAuthentication) {
         this.tomcatAuthentication = tomcatAuthentication;
     }
 
 
     private boolean tomcatAuthorization = false;
+
     /**
-     * Should authentication be done in the native web server layer and
-     * authorization in the Servlet container?
+     * Should authentication be done in the native web server layer and authorization in the Servlet container?
      *
-     * @return {@code true} if authorization should be performed by Tomcat,
-     *         otherwise {@code false}
+     * @return {@code true} if authorization should be performed by Tomcat, otherwise {@code false}
      */
-    public boolean getTomcatAuthorization() { return tomcatAuthorization; }
+    public boolean getTomcatAuthorization() {
+        return tomcatAuthorization;
+    }
+
     public void setTomcatAuthorization(boolean tomcatAuthorization) {
         this.tomcatAuthorization = tomcatAuthorization;
     }
 
 
     private String secret = null;
+
     /**
      * Set the secret that must be included with every request.
      *
@@ -150,27 +149,33 @@ public abstract class AbstractAjpProtocol<S> extends AbstractProtocol<S> {
     public void setSecret(String secret) {
         this.secret = secret;
     }
+
     protected String getSecret() {
         return secret;
     }
 
 
     private boolean secretRequired = true;
+
     public void setSecretRequired(boolean secretRequired) {
         this.secretRequired = secretRequired;
     }
+
     public boolean getSecretRequired() {
         return secretRequired;
     }
 
 
     private Pattern allowedRequestAttributesPattern;
+
     public void setAllowedRequestAttributesPattern(String allowedRequestAttributesPattern) {
         this.allowedRequestAttributesPattern = Pattern.compile(allowedRequestAttributesPattern);
     }
+
     public String getAllowedRequestAttributesPattern() {
         return allowedRequestAttributesPattern.pattern();
     }
+
     protected Pattern getAllowedRequestAttributesPatternInternal() {
         return allowedRequestAttributesPattern;
     }
@@ -180,7 +185,11 @@ public abstract class AbstractAjpProtocol<S> extends AbstractProtocol<S> {
      * AJP packet size.
      */
     private int packetSize = Constants.MAX_PACKET_SIZE;
-    public int getPacketSize() { return packetSize; }
+
+    public int getPacketSize() {
+        return packetSize;
+    }
+
     public void setPacketSize(int packetSize) {
         this.packetSize = Math.max(packetSize, Constants.MAX_PACKET_SIZE);
     }
@@ -226,8 +235,7 @@ public abstract class AbstractAjpProtocol<S> extends AbstractProtocol<S> {
 
 
     @Override
-    protected Processor createUpgradeProcessor(SocketWrapperBase<?> socket,
-            UpgradeToken upgradeToken) {
+    protected Processor createUpgradeProcessor(SocketWrapperBase<?> socket, UpgradeToken upgradeToken) {
         throw new IllegalStateException(sm.getString("ajpprotocol.noUpgradeHandler",
                 upgradeToken.getHttpUpgradeHandler().getClass().getName()));
     }

==================================================
AjpNio2Protocol.java
index 7ec6b5139f..53fca56514 100644
--- a/java/org/apache/coyote/ajp/AjpMessage.java
+++ b/java/org/apache/coyote/ajp/AjpMessage.java
@@ -26,11 +26,9 @@ import org.apache.tomcat.util.buf.MessageBytes;
 import org.apache.tomcat.util.res.StringManager;
 
 /**
- * A single packet for communication between the web server and the
- * container.  Designed to be reused many times with no creation of
- * garbage.  Understands the format of data types for these packets.
- * Can be used (somewhat confusingly) for both incoming and outgoing
- * packets.
+ * A single packet for communication between the web server and the container. Designed to be reused many times with no
+ * creation of garbage. Understands the format of data types for these packets. Can be used (somewhat confusingly) for
+ * both incoming and outgoing packets.
  *
  * @author Henri Gomez
  * @author Dan Milstein
@@ -73,10 +71,9 @@ public class AjpMessage {
 
 
     /**
-     * This actually means different things depending on whether the
-     * packet is read or write.  For read, it's the length of the
-     * payload (excluding the header).  For write, it's the length of
-     * the packet as a whole (counting the header).  Oh, well.
+     * This actually means different things depending on whether the packet is read or write. For read, it's the length
+     * of the payload (excluding the header). For write, it's the length of the packet as a whole (counting the header).
+     * Oh, well.
      */
     protected int len;
 
@@ -85,9 +82,8 @@ public class AjpMessage {
 
 
     /**
-     * Prepare this packet for accumulating a message from the container to
-     * the web server.  Set the write position to just after the header
-     * (but leave the length unwritten, because it is as yet unknown).
+     * Prepare this packet for accumulating a message from the container to the web server. Set the write position to
+     * just after the header (but leave the length unwritten, because it is as yet unknown).
      */
     public void reset() {
         len = 4;
@@ -96,9 +92,8 @@ public class AjpMessage {
 
 
     /**
-     * For a packet to be sent to the web server, finish the process of
-     * accumulating data and write the length of the data payload into
-     * the header.
+     * For a packet to be sent to the web server, finish the process of accumulating data and write the length of the
+     * data payload into the header.
      */
     public void end() {
         len = pos;
@@ -106,7 +101,7 @@ public class AjpMessage {
 
         buf[0] = (byte) 0x41;
         buf[1] = (byte) 0x42;
-        buf[2] = (byte) ((dLen>>>8) & 0xFF);
+        buf[2] = (byte) ((dLen >>> 8) & 0xFF);
         buf[3] = (byte) (dLen & 0xFF);
     }
 
@@ -124,9 +119,8 @@ public class AjpMessage {
     /**
      * Return the current message length.
      *
-     * @return For read, it's the length of the payload (excluding the header).
-     * For write, it's the length of the packet as a whole (counting the
-     * header).
+     * @return For read, it's the length of the payload (excluding the header). For write, it's the length of the packet
+     *             as a whole (counting the header).
      */
     public int getLen() {
         return len;
@@ -155,15 +149,13 @@ public class AjpMessage {
 
 
     /**
-     * Write a MessageBytes out at the current write position. A null
-     * MessageBytes is encoded as a string with length 0.
+     * Write a MessageBytes out at the current write position. A null MessageBytes is encoded as a string with length 0.
      *
      * @param mb The data to write
      */
     public void appendBytes(MessageBytes mb) {
         if (mb == null) {
-            log.error(sm.getString("ajpmessage.null"),
-                    new NullPointerException());
+            log.error(sm.getString("ajpmessage.null"), new NullPointerException());
             appendInt(0);
             appendByte(0);
             return;
@@ -181,8 +173,7 @@ public class AjpMessage {
                 // filtered (apart from TAB which is 9). 127 is a control (DEL).
                 // The values 128 to 255 are all OK. Converting those to signed
                 // gives -128 to -1.
-                if ((buffer[i] > -1 && buffer[i] <= 31 && buffer[i] != 9) ||
-                        buffer[i] == 127) {
+                if ((buffer[i] > -1 && buffer[i] <= 31 && buffer[i] != 9) || buffer[i] == 127) {
                     buffer[i] = ' ';
                 }
             }
@@ -192,15 +183,13 @@ public class AjpMessage {
 
 
     /**
-     * Write a ByteChunk out at the current write position. A null ByteChunk is
-     * encoded as a string with length 0.
+     * Write a ByteChunk out at the current write position. A null ByteChunk is encoded as a string with length 0.
      *
      * @param bc The data to write
      */
     public void appendByteChunk(ByteChunk bc) {
         if (bc == null) {
-            log.error(sm.getString("ajpmessage.null"),
-                    new NullPointerException());
+            log.error(sm.getString("ajpmessage.null"), new NullPointerException());
             appendInt(0);
             appendByte(0);
             return;
@@ -210,14 +199,12 @@ public class AjpMessage {
 
 
     /**
-     * Copy a chunk of bytes into the packet, starting at the current
-     * write position.  The chunk of bytes is encoded with the length
-     * in two bytes first, then the data itself, and finally a
-     * terminating \0 (which is <B>not</B> included in the encoded
-     * length).
+     * Copy a chunk of bytes into the packet, starting at the current write position. The chunk of bytes is encoded with
+     * the length in two bytes first, then the data itself, and finally a terminating \0 (which is <B>not</B> included
+     * in the encoded length).
      *
-     * @param b The array from which to copy bytes.
-     * @param off The offset into the array at which to start copying
+     * @param b        The array from which to copy bytes.
+     * @param off      The offset into the array at which to start copying
      * @param numBytes The number of bytes to copy.
      */
     public void appendBytes(byte[] b, int off, int numBytes) {
@@ -232,11 +219,9 @@ public class AjpMessage {
 
 
     /**
-     * Copy a chunk of bytes into the packet, starting at the current
-     * write position.  The chunk of bytes is encoded with the length
-     * in two bytes first, then the data itself, and finally a
-     * terminating \0 (which is <B>not</B> included in the encoded
-     * length).
+     * Copy a chunk of bytes into the packet, starting at the current write position. The chunk of bytes is encoded with
+     * the length in two bytes first, then the data itself, and finally a terminating \0 (which is <B>not</B> included
+     * in the encoded length).
      *
      * @param b The ByteBuffer from which to copy bytes.
      */
@@ -266,10 +251,8 @@ public class AjpMessage {
 
 
     /**
-     * Read an integer from packet, and advance the read position past
-     * it.  Integers are encoded as two unsigned bytes with the
-     * high-order byte first, and, as far as I can tell, in
-     * little-endian order within each byte.
+     * Read an integer from packet, and advance the read position past it. Integers are encoded as two unsigned bytes
+     * with the high-order byte first, and, as far as I can tell, in little-endian order within each byte.
      *
      * @return The integer value read from the message
      */
@@ -277,15 +260,15 @@ public class AjpMessage {
         int b1 = buf[pos++] & 0xFF;
         int b2 = buf[pos++] & 0xFF;
         validatePos(pos);
-        return (b1<<8) + b2;
+        return (b1 << 8) + b2;
     }
 
 
     public int peekInt() {
         validatePos(pos + 2);
         int b1 = buf[pos] & 0xFF;
-        int b2 = buf[pos+1] & 0xFF;
-        return (b1<<8) + b2;
+        int b2 = buf[pos + 1] & 0xFF;
+        return (b1 << 8) + b2;
     }
 
 
@@ -325,10 +308,8 @@ public class AjpMessage {
 
 
     /**
-     * Read a 32 bits integer from packet, and advance the read position past
-     * it.  Integers are encoded as four unsigned bytes with the
-     * high-order byte first, and, as far as I can tell, in
-     * little-endian order within each byte.
+     * Read a 32 bits integer from packet, and advance the read position past it. Integers are encoded as four unsigned
+     * bytes with the high-order byte first, and, as far as I can tell, in little-endian order within each byte.
      *
      * @return The long value read from the message
      */
@@ -338,10 +319,10 @@ public class AjpMessage {
         b1 |= (buf[pos++] & 0xFF);
         b1 <<= 8;
         b1 |= (buf[pos++] & 0xFF);
-        b1 <<=8;
+        b1 <<= 8;
         b1 |= (buf[pos++] & 0xFF);
         validatePos(pos);
-        return  b1;
+        return b1;
     }
 
 
@@ -350,15 +331,14 @@ public class AjpMessage {
         int mark = getInt();
         len = getInt();
         // Verify message signature
-        if ((toContainer && mark != 0x1234) ||
-                (!toContainer && mark != 0x4142)) {
+        if ((toContainer && mark != 0x1234) || (!toContainer && mark != 0x4142)) {
             log.error(sm.getString("ajpmessage.invalid", "" + mark));
             if (log.isDebugEnabled()) {
                 dump("In");
             }
             return -1;
         }
-        if (log.isDebugEnabled())  {
+        if (log.isDebugEnabled()) {
             log.debug("Received " + len + " " + buf[0]);
         }
         return len;
@@ -367,11 +347,11 @@ public class AjpMessage {
 
     private void dump(String prefix) {
         if (log.isDebugEnabled()) {
-            log.debug(prefix + ": " + HexUtils.toHexString(buf) + " " + pos +"/" + (len + 4));
+            log.debug(prefix + ": " + HexUtils.toHexString(buf) + " " + pos + "/" + (len + 4));
         }
         int max = pos;
         if (len + 4 > pos) {
-            max = len+4;
+            max = len + 4;
         }
         if (max > 1000) {
             max = 1000;
@@ -387,8 +367,7 @@ public class AjpMessage {
     private void validatePos(int posToTest) {
         if (posToTest > len + 4) {
             // Trying to read data beyond the end of the AJP message
-            throw new ArrayIndexOutOfBoundsException(sm.getString(
-                    "ajpMessage.invalidPos", Integer.valueOf(posToTest)));
+            throw new ArrayIndexOutOfBoundsException(sm.getString("ajpMessage.invalidPos", Integer.valueOf(posToTest)));
         }
     }
     // ------------------------------------------------------ Protected Methods
@@ -396,7 +375,7 @@ public class AjpMessage {
 
     protected static String hexLine(byte buf[], int start, int len) {
         StringBuilder sb = new StringBuilder();
-        for (int i = start; i < start + 16 ; i++) {
+        for (int i = start; i < start + 16; i++) {
             if (i < len + 4) {
                 sb.append(hex(buf[i])).append(' ');
             } else {

==================================================
AjpNioProtocol.java
index 0a3e75b84f..857d6aca93 100644
--- a/java/org/apache/coyote/ajp/AjpNio2Protocol.java
+++ b/java/org/apache/coyote/ajp/AjpNio2Protocol.java
@@ -30,7 +30,9 @@ public class AjpNio2Protocol extends AbstractAjpProtocol<Nio2Channel> {
     private static final Log log = LogFactory.getLog(AjpNio2Protocol.class);
 
     @Override
-    protected Log getLog() { return log; }
+    protected Log getLog() {
+        return log;
+    }
 
 
     // ------------------------------------------------------------ Constructor

==================================================
AjpProcessor.java
index 534cbc7c9f..0b6cce7637 100644
--- a/java/org/apache/coyote/ajp/AjpNioProtocol.java
+++ b/java/org/apache/coyote/ajp/AjpNioProtocol.java
@@ -29,7 +29,9 @@ public class AjpNioProtocol extends AbstractAjpProtocol<NioChannel> {
     private static final Log log = LogFactory.getLog(AjpNioProtocol.class);
 
     @Override
-    protected Log getLog() { return log; }
+    protected Log getLog() {
+        return log;
+    }
 
 
     // ------------------------------------------------------------ Constructor

==================================================
Constants.java
index 2b76af3eb2..93d671cb7f 100644
--- a/java/org/apache/coyote/ajp/AjpProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpProcessor.java
@@ -87,7 +87,7 @@ public class AjpProcessor extends AbstractProcessor {
     private static final byte[] pongMessageArray;
 
 
-    private static final Map<String,String> jakartaAttributeMapping;
+    private static final Map<String, String> jakartaAttributeMapping;
     private static final Set<String> iisTlsAttributes;
 
 
@@ -99,8 +99,7 @@ public class AjpProcessor extends AbstractProcessor {
         endMessage.appendByte(1);
         endMessage.end();
         endMessageArray = new byte[endMessage.getLen()];
-        System.arraycopy(endMessage.getBuffer(), 0, endMessageArray, 0,
-                endMessage.getLen());
+        System.arraycopy(endMessage.getBuffer(), 0, endMessageArray, 0, endMessage.getLen());
 
         // Allocate the end and close message array
         AjpMessage endAndCloseMessage = new AjpMessage(16);
@@ -109,8 +108,7 @@ public class AjpProcessor extends AbstractProcessor {
         endAndCloseMessage.appendByte(0);
         endAndCloseMessage.end();
         endAndCloseMessageArray = new byte[endAndCloseMessage.getLen()];
-        System.arraycopy(endAndCloseMessage.getBuffer(), 0, endAndCloseMessageArray, 0,
-                endAndCloseMessage.getLen());
+        System.arraycopy(endAndCloseMessage.getBuffer(), 0, endAndCloseMessageArray, 0, endAndCloseMessage.getLen());
 
         // Allocate the flush message array
         AjpMessage flushMessage = new AjpMessage(16);
@@ -120,8 +118,7 @@ public class AjpProcessor extends AbstractProcessor {
         flushMessage.appendByte(0);
         flushMessage.end();
         flushMessageArray = new byte[flushMessage.getLen()];
-        System.arraycopy(flushMessage.getBuffer(), 0, flushMessageArray, 0,
-                flushMessage.getLen());
+        System.arraycopy(flushMessage.getBuffer(), 0, flushMessageArray, 0, flushMessage.getLen());
 
         // Allocate the pong message array
         AjpMessage pongMessage = new AjpMessage(16);
@@ -129,11 +126,10 @@ public class AjpProcessor extends AbstractProcessor {
         pongMessage.appendByte(Constants.JK_AJP13_CPONG_REPLY);
         pongMessage.end();
         pongMessageArray = new byte[pongMessage.getLen()];
-        System.arraycopy(pongMessage.getBuffer(), 0, pongMessageArray,
-                0, pongMessage.getLen());
+        System.arraycopy(pongMessage.getBuffer(), 0, pongMessageArray, 0, pongMessage.getLen());
 
         // Build Map of Java Servlet to Jakarta Servlet attribute names
-        Map<String,String> m = new HashMap<>();
+        Map<String, String> m = new HashMap<>();
         m.put("jakarta.servlet.request.cipher_suite", "jakarta.servlet.request.cipher_suite");
         m.put("jakarta.servlet.request.key_size", "jakarta.servlet.request.key_size");
         m.put("jakarta.servlet.request.ssl_session", "jakarta.servlet.request.ssl_session");
@@ -164,8 +160,8 @@ public class AjpProcessor extends AbstractProcessor {
 
 
     /**
-     * GetBody message array. Not static like the other message arrays since the
-     * message varies with packetSize and that can vary per connector.
+     * GetBody message array. Not static like the other message arrays since the message varies with packetSize and that
+     * can vary per connector.
      */
     private final byte[] getBodyMessageArray;
 
@@ -176,9 +172,8 @@ public class AjpProcessor extends AbstractProcessor {
     private final int outputMaxChunkSize;
 
     /**
-     * Header message. Note that this header is merely the one used during the
-     * processing of the first message of a "request", so it might not be a
-     * request header. It will stay unchanged during the processing of the whole
+     * Header message. Note that this header is merely the one used during the processing of the first message of a
+     * "request", so it might not be a request header. It will stay unchanged during the processing of the whole
      * request.
      */
     private final AjpMessage requestHeaderMessage;
@@ -191,9 +186,8 @@ public class AjpProcessor extends AbstractProcessor {
 
 
     /**
-     * Location of next write of the response message (used with non-blocking
-     * writes when the message may not be written in a single write). A value of
-     * -1 indicates that no message has been written to the buffer.
+     * Location of next write of the response message (used with non-blocking writes when the message may not be written
+     * in a single write). A value of -1 indicates that no message has been written to the buffer.
      */
     private int responseMsgPos = -1;
 
@@ -241,8 +235,7 @@ public class AjpProcessor extends AbstractProcessor {
 
 
     /**
-     * Indicates that a 'get body chunk' message has been sent but the body
-     * chunk has not yet been received.
+     * Indicates that a 'get body chunk' message has been sent but the body chunk has not yet been received.
      */
     private boolean waitingForBodyMessage = false;
 
@@ -271,8 +264,6 @@ public class AjpProcessor extends AbstractProcessor {
     private long bytesWritten = 0;
 
 
-
-
     // ------------------------------------------------------------ Constructor
 
     public AjpProcessor(AbstractAjpProtocol<?> protocol, Adapter adapter) {
@@ -295,12 +286,10 @@ public class AjpProcessor extends AbstractProcessor {
         getBodyMessage.reset();
         getBodyMessage.appendByte(Constants.JK_AJP13_GET_BODY_CHUNK);
         // Adjust read size if packetSize != default (Constants.MAX_PACKET_SIZE)
-        getBodyMessage.appendInt(Constants.MAX_READ_SIZE + packetSize -
-                Constants.MAX_PACKET_SIZE);
+        getBodyMessage.appendInt(Constants.MAX_READ_SIZE + packetSize - Constants.MAX_PACKET_SIZE);
         getBodyMessage.end();
         getBodyMessageArray = new byte[getBodyMessage.getLen()];
-        System.arraycopy(getBodyMessage.getBuffer(), 0, getBodyMessageArray,
-                0, getBodyMessage.getLen());
+        System.arraycopy(getBodyMessage.getBuffer(), 0, getBodyMessageArray, 0, getBodyMessage.getLen());
 
         response.setOutputBuffer(new SocketOutputBuffer());
     }
@@ -391,7 +380,7 @@ public class AjpProcessor extends AbstractProcessor {
                     }
                     recycle();
                     continue;
-                } else if(type != Constants.JK_AJP13_FORWARD_REQUEST) {
+                } else if (type != Constants.JK_AJP13_FORWARD_REQUEST) {
                     // Unexpected packet type. Unread body packets should have
                     // been swallowed in finish().
                     if (getLog().isDebugEnabled()) {
@@ -459,7 +448,7 @@ public class AjpProcessor extends AbstractProcessor {
                 try {
                     action(ActionCode.COMMIT, null);
                     finishResponse();
-                } catch (IOException ioe){
+                } catch (IOException ioe) {
                     setErrorState(ErrorState.CLOSE_CONNECTION_NOW, ioe);
                 } catch (Throwable t) {
                     ExceptionUtils.handleThrowable(t);
@@ -524,14 +513,13 @@ public class AjpProcessor extends AbstractProcessor {
 
     // Methods used by SocketInputBuffer
     /**
-     * Read an AJP body message. Used to read both the 'special' packet in ajp13
-     * and to receive the data after we send a GET_BODY packet.
+     * Read an AJP body message. Used to read both the 'special' packet in ajp13 and to receive the data after we send a
+     * GET_BODY packet.
      *
-     * @param block If there is no data available to read when this method is
-     *              called, should this call block until data becomes available?
+     * @param block If there is no data available to read when this method is called, should this call block until data
+     *                  becomes available?
      *
-     * @return <code>true</code> if at least one body byte was read, otherwise
-     *         <code>false</code>
+     * @return <code>true</code> if at least one body byte was read, otherwise <code>false</code>
      */
     private boolean receive(boolean block) throws IOException {
 
@@ -562,16 +550,15 @@ public class AjpProcessor extends AbstractProcessor {
     /**
      * Read an AJP message.
      *
-     * @param message   The message to populate
-     * @param block If there is no data available to read when this method is
-     *              called, should this call block until data becomes available?
+     * @param message The message to populate
+     * @param block   If there is no data available to read when this method is called, should this call block until
+     *                    data becomes available?
      *
      * @return true if the message has been read, false if no data was read
      *
      * @throws IOException any other failure, including incomplete reads
      */
-    private boolean readMessage(AjpMessage message, boolean block)
-        throws IOException {
+    private boolean readMessage(AjpMessage message, boolean block) throws IOException {
 
         byte[] buf = message.getBuffer();
 
@@ -582,18 +569,16 @@ public class AjpProcessor extends AbstractProcessor {
         int messageLength = message.processHeader(true);
         if (messageLength < 0) {
             // Invalid AJP header signature
-            throw new IOException(sm.getString("ajpmessage.invalidLength",
-                    Integer.valueOf(messageLength)));
-        }
-        else if (messageLength == 0) {
+            throw new IOException(sm.getString("ajpmessage.invalidLength", Integer.valueOf(messageLength)));
+        } else if (messageLength == 0) {
             // Zero length message.
             return true;
         } else {
             if (messageLength > message.getBuffer().length) {
                 // Message too long for the buffer
                 // Need to trigger a 400 response
-                String msg = sm.getString("ajpprocessor.header.tooLong",
-                        Integer.valueOf(messageLength), Integer.valueOf(buf.length));
+                String msg = sm.getString("ajpprocessor.header.tooLong", Integer.valueOf(messageLength),
+                        Integer.valueOf(buf.length));
                 log.error(msg);
                 throw new IllegalArgumentException(msg);
             }
@@ -604,11 +589,12 @@ public class AjpProcessor extends AbstractProcessor {
 
 
     /**
-     * Get more request body data from the web server and store it in the
-     * internal buffer.
+     * Get more request body data from the web server and store it in the internal buffer.
+     *
      * @param block <code>true</code> if this is blocking IO
-     * @return <code>true</code> if there is more data,
-     *  <code>false</code> if not.
+     *
+     * @return <code>true</code> if there is more data, <code>false</code> if not.
+     *
      * @throws IOException An IO error occurred
      */
     protected boolean refillReadBuffer(boolean block) throws IOException {
@@ -625,10 +611,10 @@ public class AjpProcessor extends AbstractProcessor {
             first = false;
             long contentLength = request.getContentLengthLong();
             // - When content length > 0, AJP sends the first body message
-            //   automatically.
+            // automatically.
             // - When content length == 0, AJP does not send a body message.
             // - When content length is unknown, AJP does not send the first
-            //   body message automatically.
+            // body message automatically.
             if (contentLength > 0) {
                 waitingForBodyMessage = true;
             } else if (contentLength == 0) {
@@ -689,7 +675,7 @@ public class AjpProcessor extends AbstractProcessor {
 
         boolean contentLengthSet = false;
         int hCount = requestHeaderMessage.getInt();
-        for(int i = 0 ; i < hCount ; i++) {
+        for (int i = 0; i < hCount; i++) {
             String hName = null;
 
             // Header names are encoded as either an integer code starting
@@ -700,7 +686,7 @@ public class AjpProcessor extends AbstractProcessor {
 
             MessageBytes vMB = null;
             isc &= 0xFF00;
-            if(0xA000 == isc) {
+            if (0xA000 == isc) {
                 requestHeaderMessage.getInt(); // To advance the read position
                 hName = Constants.getHeaderForCode(hId - 1);
                 vMB = headers.addValue(hName);
@@ -710,18 +696,16 @@ public class AjpProcessor extends AbstractProcessor {
                 // will think it's the content-type header or the
                 // content-length header - SC_REQ_CONTENT_TYPE=7,
                 // SC_REQ_CONTENT_LENGTH=8 - leading to unexpected
-                // behaviour.  see bug 5861 for more information.
+                // behaviour. see bug 5861 for more information.
                 hId = -1;
                 requestHeaderMessage.getBytes(tmpMB);
                 ByteChunk bc = tmpMB.getByteChunk();
-                vMB = headers.addValue(bc.getBuffer(),
-                        bc.getStart(), bc.getLength());
+                vMB = headers.addValue(bc.getBuffer(), bc.getStart(), bc.getLength());
             }
 
             requestHeaderMessage.getBytes(vMB);
 
-            if (hId == Constants.SC_REQ_CONTENT_LENGTH ||
-                    (hId == -1 && tmpMB.equalsIgnoreCase("Content-Length"))) {
+            if (hId == Constants.SC_REQ_CONTENT_LENGTH || (hId == -1 && tmpMB.equalsIgnoreCase("Content-Length"))) {
                 long cl = vMB.getLong();
                 if (contentLengthSet) {
                     response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
@@ -731,13 +715,10 @@ public class AjpProcessor extends AbstractProcessor {
                     // Set the content-length header for the request
                     request.setContentLength(cl);
                 }
-            } else if (hId == Constants.SC_REQ_CONTENT_TYPE ||
-                    (hId == -1 && tmpMB.equalsIgnoreCase("Content-Type"))) {
+            } else if (hId == Constants.SC_REQ_CONTENT_TYPE || (hId == -1 && tmpMB.equalsIgnoreCase("Content-Type"))) {
                 // just read the content-type header, so set it
                 ByteChunk bchunk = vMB.getByteChunk();
-                request.contentType().setBytes(bchunk.getBytes(),
-                        bchunk.getOffset(),
-                        bchunk.getLength());
+                request.contentType().setBytes(bchunk.getBytes(), bchunk.getOffset(), bchunk.getLength());
             }
         }
 
@@ -745,136 +726,130 @@ public class AjpProcessor extends AbstractProcessor {
         String secret = protocol.getSecret();
         boolean secretPresentInRequest = false;
         byte attributeCode;
-        while ((attributeCode = requestHeaderMessage.getByte())
-                != Constants.SC_A_ARE_DONE) {
+        while ((attributeCode = requestHeaderMessage.getByte()) != Constants.SC_A_ARE_DONE) {
 
             switch (attributeCode) {
 
-            case Constants.SC_A_REQ_ATTRIBUTE :
-                requestHeaderMessage.getBytes(tmpMB);
-                String n = tmpMB.toString();
-                requestHeaderMessage.getBytes(tmpMB);
-                String v = tmpMB.toString();
-                /*
-                 * AJP13 misses to forward the local IP address and the
-                 * remote port. Allow the AJP connector to add this info via
-                 * private request attributes.
-                 * We will accept the forwarded data and remove it from the
-                 * public list of request attributes.
-                 */
-                if(n.equals(Constants.SC_A_REQ_LOCAL_ADDR)) {
-                    request.localAddr().setString(v);
-                } else if(n.equals(Constants.SC_A_REQ_REMOTE_PORT)) {
-                    try {
-                        request.setRemotePort(Integer.parseInt(v));
-                    } catch (NumberFormatException nfe) {
-                        // Ignore invalid value
-                    }
-                } else if(n.equals(Constants.SC_A_SSL_PROTOCOL)) {
-                    request.setAttribute(SSLSupport.PROTOCOL_VERSION_KEY, v);
-                } else if (n.equals("JK_LB_ACTIVATION")) {
-                    request.setAttribute(n, v);
-                } else if (jakartaAttributeMapping.containsKey(n)) {
-                    // AJP uses the Java Servlet attribute names.
-                    // Need to convert these to Jakarta Servlet.
-                    request.setAttribute(jakartaAttributeMapping.get(n), v);
-                } else if (iisTlsAttributes.contains(n)) {
-                    // Allow IIS TLS attributes
-                    request.setAttribute(n, v);
-                } else {
-                    // All 'known' attributes will be processed by the previous
-                    // blocks. Any remaining attribute is an 'arbitrary' one.
-                    Pattern pattern = protocol.getAllowedRequestAttributesPatternInternal();
-                    if (pattern != null && pattern.matcher(n).matches()) {
+                case Constants.SC_A_REQ_ATTRIBUTE:
+                    requestHeaderMessage.getBytes(tmpMB);
+                    String n = tmpMB.toString();
+                    requestHeaderMessage.getBytes(tmpMB);
+                    String v = tmpMB.toString();
+                    /*
+                     * AJP13 misses to forward the local IP address and the remote port. Allow the AJP connector to add
+                     * this info via private request attributes. We will accept the forwarded data and remove it from
+                     * the public list of request attributes.
+                     */
+                    if (n.equals(Constants.SC_A_REQ_LOCAL_ADDR)) {
+                        request.localAddr().setString(v);
+                    } else if (n.equals(Constants.SC_A_REQ_REMOTE_PORT)) {
+                        try {
+                            request.setRemotePort(Integer.parseInt(v));
+                        } catch (NumberFormatException nfe) {
+                            // Ignore invalid value
+                        }
+                    } else if (n.equals(Constants.SC_A_SSL_PROTOCOL)) {
+                        request.setAttribute(SSLSupport.PROTOCOL_VERSION_KEY, v);
+                    } else if (n.equals("JK_LB_ACTIVATION")) {
+                        request.setAttribute(n, v);
+                    } else if (jakartaAttributeMapping.containsKey(n)) {
+                        // AJP uses the Java Servlet attribute names.
+                        // Need to convert these to Jakarta Servlet.
+                        request.setAttribute(jakartaAttributeMapping.get(n), v);
+                    } else if (iisTlsAttributes.contains(n)) {
+                        // Allow IIS TLS attributes
                         request.setAttribute(n, v);
                     } else {
-                        log.warn(sm.getString("ajpprocessor.unknownAttribute", n));
-                        response.setStatus(403);
-                        setErrorState(ErrorState.CLOSE_CLEAN, null);
+                        // All 'known' attributes will be processed by the previous
+                        // blocks. Any remaining attribute is an 'arbitrary' one.
+                        Pattern pattern = protocol.getAllowedRequestAttributesPatternInternal();
+                        if (pattern != null && pattern.matcher(n).matches()) {
+                            request.setAttribute(n, v);
+                        } else {
+                            log.warn(sm.getString("ajpprocessor.unknownAttribute", n));
+                            response.setStatus(403);
+                            setErrorState(ErrorState.CLOSE_CLEAN, null);
+                        }
                     }
-                }
-                break;
-
-            case Constants.SC_A_CONTEXT :
-                requestHeaderMessage.getBytes(tmpMB);
-                // nothing
-                break;
-
-            case Constants.SC_A_SERVLET_PATH :
-                requestHeaderMessage.getBytes(tmpMB);
-                // nothing
-                break;
+                    break;
 
-            case Constants.SC_A_REMOTE_USER :
-                boolean tomcatAuthorization  = protocol.getTomcatAuthorization();
-                if (tomcatAuthorization || !protocol.getTomcatAuthentication()) {
-                    // Implies tomcatAuthentication == false
-                    requestHeaderMessage.getBytes(request.getRemoteUser());
-                    request.setRemoteUserNeedsAuthorization(tomcatAuthorization);
-                } else {
-                    // Ignore user information from reverse proxy
+                case Constants.SC_A_CONTEXT:
                     requestHeaderMessage.getBytes(tmpMB);
-                }
-                break;
+                    // nothing
+                    break;
 
-            case Constants.SC_A_AUTH_TYPE :
-                if (protocol.getTomcatAuthentication()) {
-                    // ignore server
+                case Constants.SC_A_SERVLET_PATH:
                     requestHeaderMessage.getBytes(tmpMB);
-                } else {
-                    requestHeaderMessage.getBytes(request.getAuthType());
-                }
-                break;
+                    // nothing
+                    break;
 
-            case Constants.SC_A_QUERY_STRING :
-                requestHeaderMessage.getBytes(request.queryString());
-                break;
+                case Constants.SC_A_REMOTE_USER:
+                    boolean tomcatAuthorization = protocol.getTomcatAuthorization();
+                    if (tomcatAuthorization || !protocol.getTomcatAuthentication()) {
+                        // Implies tomcatAuthentication == false
+                        requestHeaderMessage.getBytes(request.getRemoteUser());
+                        request.setRemoteUserNeedsAuthorization(tomcatAuthorization);
+                    } else {
+                        // Ignore user information from reverse proxy
+                        requestHeaderMessage.getBytes(tmpMB);
+                    }
+                    break;
 
-            case Constants.SC_A_JVM_ROUTE :
-                requestHeaderMessage.getBytes(tmpMB);
-                // nothing
-                break;
+                case Constants.SC_A_AUTH_TYPE:
+                    if (protocol.getTomcatAuthentication()) {
+                        // ignore server
+                        requestHeaderMessage.getBytes(tmpMB);
+                    } else {
+                        requestHeaderMessage.getBytes(request.getAuthType());
+                    }
+                    break;
 
-            case Constants.SC_A_SSL_CERT :
-                // SSL certificate extraction is lazy, moved to JkCoyoteHandler
-                requestHeaderMessage.getBytes(certificates);
-                break;
+                case Constants.SC_A_QUERY_STRING:
+                    requestHeaderMessage.getBytes(request.queryString());
+                    break;
 
-            case Constants.SC_A_SSL_CIPHER :
-                requestHeaderMessage.getBytes(tmpMB);
-                request.setAttribute(SSLSupport.CIPHER_SUITE_KEY,
-                        tmpMB.toString());
-                break;
+                case Constants.SC_A_JVM_ROUTE:
+                    requestHeaderMessage.getBytes(tmpMB);
+                    // nothing
+                    break;
 
-            case Constants.SC_A_SSL_SESSION :
-                requestHeaderMessage.getBytes(tmpMB);
-                request.setAttribute(SSLSupport.SESSION_ID_KEY,
-                        tmpMB.toString());
-                break;
+                case Constants.SC_A_SSL_CERT:
+                    // SSL certificate extraction is lazy, moved to JkCoyoteHandler
+                    requestHeaderMessage.getBytes(certificates);
+                    break;
 
-            case Constants.SC_A_SSL_KEY_SIZE :
-                request.setAttribute(SSLSupport.KEY_SIZE_KEY,
-                        Integer.valueOf(requestHeaderMessage.getInt()));
-                break;
+                case Constants.SC_A_SSL_CIPHER:
+                    requestHeaderMessage.getBytes(tmpMB);
+                    request.setAttribute(SSLSupport.CIPHER_SUITE_KEY, tmpMB.toString());
+                    break;
 
-            case Constants.SC_A_STORED_METHOD:
-                requestHeaderMessage.getBytes(request.method());
-                break;
+                case Constants.SC_A_SSL_SESSION:
+                    requestHeaderMessage.getBytes(tmpMB);
+                    request.setAttribute(SSLSupport.SESSION_ID_KEY, tmpMB.toString());
+                    break;
 
-            case Constants.SC_A_SECRET:
-                requestHeaderMessage.getBytes(tmpMB);
-                if (secret != null && secret.length() > 0) {
-                    secretPresentInRequest = true;
-                    if (!tmpMB.equals(secret)) {
-                        response.setStatus(403);
-                        setErrorState(ErrorState.CLOSE_CLEAN, null);
+                case Constants.SC_A_SSL_KEY_SIZE:
+                    request.setAttribute(SSLSupport.KEY_SIZE_KEY, Integer.valueOf(requestHeaderMessage.getInt()));
+                    break;
+
+                case Constants.SC_A_STORED_METHOD:
+                    requestHeaderMessage.getBytes(request.method());
+                    break;
+
+                case Constants.SC_A_SECRET:
+                    requestHeaderMessage.getBytes(tmpMB);
+                    if (secret != null && secret.length() > 0) {
+                        secretPresentInRequest = true;
+                        if (!tmpMB.equals(secret)) {
+                            response.setStatus(403);
+                            setErrorState(ErrorState.CLOSE_CLEAN, null);
+                        }
                     }
-                }
-                break;
+                    break;
 
-            default:
-                // Ignore unknown attribute for backward compatibility
-                break;
+                default:
+                    // Ignore unknown attribute for backward compatibility
+                    break;
 
             }
 
@@ -899,16 +874,12 @@ public class AjpProcessor extends AbstractProcessor {
                 if (slashPos == -1) {
                     slashPos = uriBC.getLength();
                     // Set URI as "/"
-                    request.requestURI().setBytes
-                    (uriB, uriBCStart + pos + 1, 1);
+                    request.requestURI().setBytes(uriB, uriBCStart + pos + 1, 1);
                 } else {
-                    request.requestURI().setBytes
-                    (uriB, uriBCStart + slashPos,
-                            uriBC.getLength() - slashPos);
+                    request.requestURI().setBytes(uriB, uriBCStart + slashPos, uriBC.getLength() - slashPos);
                 }
                 MessageBytes hostMB = headers.setValue("host");
-                hostMB.setBytes(uriB, uriBCStart + pos + 3,
-                        slashPos - pos - 3);
+                hostMB.setBytes(uriB, uriBCStart + pos + 3, slashPos - pos - 3);
             }
 
         }
@@ -925,8 +896,7 @@ public class AjpProcessor extends AbstractProcessor {
     /**
      * {@inheritDoc}
      * <p>
-     * This implementation populates the server name from the local name
-     * provided by the AJP message.
+     * This implementation populates the server name from the local name provided by the AJP message.
      */
     @Override
     protected void populateHost() {
@@ -942,8 +912,7 @@ public class AjpProcessor extends AbstractProcessor {
     /**
      * {@inheritDoc}
      * <p>
-     * This implementation populates the server port from the local port
-     * provided by the AJP message.
+     * This implementation populates the server port from the local port provided by the AJP message.
      */
     @Override
     protected void populatePort() {
@@ -953,8 +922,7 @@ public class AjpProcessor extends AbstractProcessor {
 
 
     /**
-     * When committing the response, we have to validate the set of headers, as
-     * well as setup the response filters.
+     * When committing the response, we have to validate the set of headers, as well as setup the response filters.
      */
     @Override
     protected final void prepareResponse() throws IOException {
@@ -1014,12 +982,12 @@ public class AjpProcessor extends AbstractProcessor {
                 } else {
                     responseMessage.appendBytes(hN);
                 }
-                MessageBytes hV=headers.getValue(i);
+                MessageBytes hV = headers.getValue(i);
                 responseMessage.appendBytes(hV);
             } catch (IllegalArgumentException iae) {
                 // Log the problematic header
-                log.warn(sm.getString("ajpprocessor.response.invalidHeader", headers.getName(i),
-                        headers.getValue(i)), iae);
+                log.warn(sm.getString("ajpprocessor.response.invalidHeader", headers.getName(i), headers.getValue(i)),
+                        iae);
                 // Remove the problematic header
                 headers.removeHeader(i);
                 numHeaders--;
@@ -1128,10 +1096,9 @@ public class AjpProcessor extends AbstractProcessor {
 
     @Override
     protected final void disableSwallowRequest() {
-        /* NO-OP
-         * With AJP, Tomcat controls when the client sends request body data. At
-         * most there will be a single packet to read and that will be handled
-         * in finishResponse().
+        /*
+         * NO-OP With AJP, Tomcat controls when the client sends request body data. At most there will be a single
+         * packet to read and that will be handled in finishResponse().
          */
     }
 
@@ -1149,8 +1116,7 @@ public class AjpProcessor extends AbstractProcessor {
         // Get remote host name using a DNS resolution
         if (request.remoteHost().isNull()) {
             try {
-                request.remoteHost().setString(InetAddress.getByName
-                        (request.remoteAddr().toString()).getHostName());
+                request.remoteHost().setString(InetAddress.getByName(request.remoteAddr().toString()).getHostName());
             } catch (IOException iex) {
                 // Ignore
             }
@@ -1163,29 +1129,25 @@ public class AjpProcessor extends AbstractProcessor {
         if (!certificates.isNull()) {
             ByteChunk certData = certificates.getByteChunk();
             X509Certificate jsseCerts[] = null;
-            ByteArrayInputStream bais =
-                new ByteArrayInputStream(certData.getBytes(),
-                        certData.getStart(),
-                        certData.getLength());
-            // Fill the  elements.
+            ByteArrayInputStream bais = new ByteArrayInputStream(certData.getBytes(), certData.getStart(),
+                    certData.getLength());
+            // Fill the elements.
             try {
                 CertificateFactory cf;
                 String clientCertProvider = protocol.getClientCertProvider();
                 if (clientCertProvider == null) {
                     cf = CertificateFactory.getInstance("X.509");
                 } else {
-                    cf = CertificateFactory.getInstance("X.509",
-                            clientCertProvider);
+                    cf = CertificateFactory.getInstance("X.509", clientCertProvider);
                 }
-                while(bais.available() > 0) {
-                    X509Certificate cert = (X509Certificate)
-                    cf.generateCertificate(bais);
-                    if(jsseCerts == null) {
+                while (bais.available() > 0) {
+                    X509Certificate cert = (X509Certificate) cf.generateCertificate(bais);
+                    if (jsseCerts == null) {
                         jsseCerts = new X509Certificate[1];
                         jsseCerts[0] = cert;
                     } else {
-                        X509Certificate [] temp = new X509Certificate[jsseCerts.length+1];
-                        System.arraycopy(jsseCerts,0,temp,0,jsseCerts.length);
+                        X509Certificate[] temp = new X509Certificate[jsseCerts.length + 1];
+                        System.arraycopy(jsseCerts, 0, temp, 0, jsseCerts.length);
                         temp[jsseCerts.length] = cert;
                         jsseCerts = temp;
                     }
@@ -1226,18 +1188,17 @@ public class AjpProcessor extends AbstractProcessor {
 
 
     /**
-     * Read at least the specified amount of bytes, and place them
-     * in the input buffer. Note that if any data is available to read then this
-     * method will always block until at least the specified number of bytes
-     * have been read.
+     * Read at least the specified amount of bytes, and place them in the input buffer. Note that if any data is
+     * available to read then this method will always block until at least the specified number of bytes have been read.
      *
      * @param buf   Buffer to read data into
      * @param pos   Start position
      * @param n     The minimum number of bytes to read
-     * @param block If there is no data available to read when this method is
-     *              called, should this call block until data becomes available?
-     * @return  <code>true</code> if the requested number of bytes were read
-     *          else <code>false</code>
+     * @param block If there is no data available to read when this method is called, should this call block until data
+     *                  becomes available?
+     *
+     * @return <code>true</code> if the requested number of bytes were read else <code>false</code>
+     *
      * @throws IOException If an I/O error occurs during the read
      */
     private boolean read(byte[] buf, int pos, int n, boolean block) throws IOException {
@@ -1307,8 +1268,7 @@ public class AjpProcessor extends AbstractProcessor {
     // ------------------------------------- InputStreamInputBuffer Inner Class
 
     /**
-     * This class is an input buffer which will read its data from an input
-     * stream.
+     * This class is an input buffer which will read its data from an input stream.
      */
     protected class SocketInputBuffer implements InputBuffer {
 
@@ -1343,8 +1303,7 @@ public class AjpProcessor extends AbstractProcessor {
     // ----------------------------------- OutputStreamOutputBuffer Inner Class
 
     /**
-     * This class is an output buffer which will write data to an output
-     * stream.
+     * This class is an output buffer which will write data to an output stream.
      */
     protected class SocketOutputBuffer implements OutputBuffer {
 

==================================================
SimpleAjpClient.java
index 6c7cd9abb3..bdda943754 100644
--- a/java/org/apache/coyote/ajp/Constants.java
+++ b/java/org/apache/coyote/ajp/Constants.java
@@ -29,44 +29,44 @@ public final class Constants {
     public static final int DEFAULT_CONNECTION_TIMEOUT = -1;
 
     // Prefix codes for message types from server to container
-    public static final byte JK_AJP13_FORWARD_REQUEST   = 2;
-    public static final byte JK_AJP13_SHUTDOWN          = 7;    // XXX Unused
-    public static final byte JK_AJP13_PING_REQUEST      = 8;    // XXX Unused
-    public static final byte JK_AJP13_CPING_REQUEST     = 10;
+    public static final byte JK_AJP13_FORWARD_REQUEST = 2;
+    public static final byte JK_AJP13_SHUTDOWN = 7; // XXX Unused
+    public static final byte JK_AJP13_PING_REQUEST = 8; // XXX Unused
+    public static final byte JK_AJP13_CPING_REQUEST = 10;
 
     // Prefix codes for message types from container to server
-    public static final byte JK_AJP13_SEND_BODY_CHUNK   = 3;
-    public static final byte JK_AJP13_SEND_HEADERS      = 4;
-    public static final byte JK_AJP13_END_RESPONSE      = 5;
-    public static final byte JK_AJP13_GET_BODY_CHUNK    = 6;
-    public static final byte JK_AJP13_CPONG_REPLY       = 9;
+    public static final byte JK_AJP13_SEND_BODY_CHUNK = 3;
+    public static final byte JK_AJP13_SEND_HEADERS = 4;
+    public static final byte JK_AJP13_END_RESPONSE = 5;
+    public static final byte JK_AJP13_GET_BODY_CHUNK = 6;
+    public static final byte JK_AJP13_CPONG_REPLY = 9;
 
     // Integer codes for common response header strings
-    public static final int SC_RESP_CONTENT_TYPE        = 0xA001;
-    public static final int SC_RESP_CONTENT_LANGUAGE    = 0xA002;
-    public static final int SC_RESP_CONTENT_LENGTH      = 0xA003;
-    public static final int SC_RESP_DATE                = 0xA004;
-    public static final int SC_RESP_LAST_MODIFIED       = 0xA005;
-    public static final int SC_RESP_LOCATION            = 0xA006;
-    public static final int SC_RESP_SET_COOKIE          = 0xA007;
-    public static final int SC_RESP_SET_COOKIE2         = 0xA008;
-    public static final int SC_RESP_SERVLET_ENGINE      = 0xA009;
-    public static final int SC_RESP_STATUS              = 0xA00A;
-    public static final int SC_RESP_WWW_AUTHENTICATE    = 0xA00B;
-    public static final int SC_RESP_AJP13_MAX           = 11;
+    public static final int SC_RESP_CONTENT_TYPE = 0xA001;
+    public static final int SC_RESP_CONTENT_LANGUAGE = 0xA002;
+    public static final int SC_RESP_CONTENT_LENGTH = 0xA003;
+    public static final int SC_RESP_DATE = 0xA004;
+    public static final int SC_RESP_LAST_MODIFIED = 0xA005;
+    public static final int SC_RESP_LOCATION = 0xA006;
+    public static final int SC_RESP_SET_COOKIE = 0xA007;
+    public static final int SC_RESP_SET_COOKIE2 = 0xA008;
+    public static final int SC_RESP_SERVLET_ENGINE = 0xA009;
+    public static final int SC_RESP_STATUS = 0xA00A;
+    public static final int SC_RESP_WWW_AUTHENTICATE = 0xA00B;
+    public static final int SC_RESP_AJP13_MAX = 11;
 
     // Integer codes for common (optional) request attribute names
-    public static final byte SC_A_CONTEXT       = 1;  // XXX Unused
-    public static final byte SC_A_SERVLET_PATH  = 2;  // XXX Unused
-    public static final byte SC_A_REMOTE_USER   = 3;
-    public static final byte SC_A_AUTH_TYPE     = 4;
-    public static final byte SC_A_QUERY_STRING  = 5;
-    public static final byte SC_A_JVM_ROUTE     = 6;
-    public static final byte SC_A_SSL_CERT      = 7;
-    public static final byte SC_A_SSL_CIPHER    = 8;
-    public static final byte SC_A_SSL_SESSION   = 9;
-    public static final byte SC_A_SSL_KEY_SIZE  = 11;
-    public static final byte SC_A_SECRET        = 12;
+    public static final byte SC_A_CONTEXT = 1; // XXX Unused
+    public static final byte SC_A_SERVLET_PATH = 2; // XXX Unused
+    public static final byte SC_A_REMOTE_USER = 3;
+    public static final byte SC_A_AUTH_TYPE = 4;
+    public static final byte SC_A_QUERY_STRING = 5;
+    public static final byte SC_A_JVM_ROUTE = 6;
+    public static final byte SC_A_SSL_CERT = 7;
+    public static final byte SC_A_SSL_CIPHER = 8;
+    public static final byte SC_A_SSL_SESSION = 9;
+    public static final byte SC_A_SSL_KEY_SIZE = 11;
+    public static final byte SC_A_SECRET = 12;
     public static final byte SC_A_STORED_METHOD = 13;
 
     // Used for attributes which are not in the list above
@@ -75,12 +75,12 @@ public final class Constants {
     /**
      * AJP private request attributes
      */
-    public static final String SC_A_REQ_LOCAL_ADDR  = "AJP_LOCAL_ADDR";
+    public static final String SC_A_REQ_LOCAL_ADDR = "AJP_LOCAL_ADDR";
     public static final String SC_A_REQ_REMOTE_PORT = "AJP_REMOTE_PORT";
-    public static final String SC_A_SSL_PROTOCOL    = "AJP_SSL_PROTOCOL";
+    public static final String SC_A_SSL_PROTOCOL = "AJP_SSL_PROTOCOL";
 
     // Terminates list of attributes
-    public static final byte SC_A_ARE_DONE      = (byte)0xFF;
+    public static final byte SC_A_ARE_DONE = (byte) 0xFF;
 
     /**
      * Default maximum total byte size for an AJP packet
@@ -94,49 +94,26 @@ public final class Constants {
     /**
      * Size of the header metadata
      */
-    public static final int  READ_HEAD_LEN = 6;
-    public static final int  SEND_HEAD_LEN = 8;
+    public static final int READ_HEAD_LEN = 6;
+    public static final int SEND_HEAD_LEN = 8;
 
     /**
      * Default maximum size of data that can be sent in one packet
      */
-    public static final int  MAX_READ_SIZE = MAX_PACKET_SIZE - READ_HEAD_LEN;
-    public static final int  MAX_SEND_SIZE = MAX_PACKET_SIZE - SEND_HEAD_LEN;
+    public static final int MAX_READ_SIZE = MAX_PACKET_SIZE - READ_HEAD_LEN;
+    public static final int MAX_SEND_SIZE = MAX_PACKET_SIZE - SEND_HEAD_LEN;
 
     // Translates integer codes to names of HTTP methods
-    private static final String [] methodTransArray = {
-            "OPTIONS",
-            "GET",
-            "HEAD",
-            "POST",
-            "PUT",
-            "DELETE",
-            "TRACE",
-            "PROPFIND",
-            "PROPPATCH",
-            "MKCOL",
-            "COPY",
-            "MOVE",
-            "LOCK",
-            "UNLOCK",
-            "ACL",
-            "REPORT",
-            "VERSION-CONTROL",
-            "CHECKIN",
-            "CHECKOUT",
-            "UNCHECKOUT",
-            "SEARCH",
-            "MKWORKSPACE",
-            "UPDATE",
-            "LABEL",
-            "MERGE",
-            "BASELINE-CONTROL",
-            "MKACTIVITY"
-    };
+    private static final String[] methodTransArray = { "OPTIONS", "GET", "HEAD", "POST", "PUT", "DELETE", "TRACE",
+            "PROPFIND", "PROPPATCH", "MKCOL", "COPY", "MOVE", "LOCK", "UNLOCK", "ACL", "REPORT", "VERSION-CONTROL",
+            "CHECKIN", "CHECKOUT", "UNCHECKOUT", "SEARCH", "MKWORKSPACE", "UPDATE", "LABEL", "MERGE",
+            "BASELINE-CONTROL", "MKACTIVITY" };
 
     /**
      * Converts an AJP coded HTTP method to the method name.
+     *
      * @param code the coded value
+     *
      * @return the string value of the method
      */
     public static String getMethodForCode(final int code) {
@@ -146,42 +123,31 @@ public final class Constants {
     public static final int SC_M_JK_STORED = (byte) 0xFF;
 
     // id's for common request headers
-    public static final int SC_REQ_ACCEPT          = 1;
-    public static final int SC_REQ_ACCEPT_CHARSET  = 2;
+    public static final int SC_REQ_ACCEPT = 1;
+    public static final int SC_REQ_ACCEPT_CHARSET = 2;
     public static final int SC_REQ_ACCEPT_ENCODING = 3;
     public static final int SC_REQ_ACCEPT_LANGUAGE = 4;
-    public static final int SC_REQ_AUTHORIZATION   = 5;
-    public static final int SC_REQ_CONNECTION      = 6;
-    public static final int SC_REQ_CONTENT_TYPE    = 7;
-    public static final int SC_REQ_CONTENT_LENGTH  = 8;
-    public static final int SC_REQ_COOKIE          = 9;
-    public static final int SC_REQ_COOKIE2         = 10;
-    public static final int SC_REQ_HOST            = 11;
-    public static final int SC_REQ_PRAGMA          = 12;
-    public static final int SC_REQ_REFERER         = 13;
-    public static final int SC_REQ_USER_AGENT      = 14;
+    public static final int SC_REQ_AUTHORIZATION = 5;
+    public static final int SC_REQ_CONNECTION = 6;
+    public static final int SC_REQ_CONTENT_TYPE = 7;
+    public static final int SC_REQ_CONTENT_LENGTH = 8;
+    public static final int SC_REQ_COOKIE = 9;
+    public static final int SC_REQ_COOKIE2 = 10;
+    public static final int SC_REQ_HOST = 11;
+    public static final int SC_REQ_PRAGMA = 12;
+    public static final int SC_REQ_REFERER = 13;
+    public static final int SC_REQ_USER_AGENT = 14;
 
     // Translates integer codes to request header names
-    private static final String [] headerTransArray = {
-            "accept",
-            "accept-charset",
-            "accept-encoding",
-            "accept-language",
-            "authorization",
-            "connection",
-            "content-type",
-            "content-length",
-            "cookie",
-            "cookie2",
-            "host",
-            "pragma",
-            "referer",
-            "user-agent"
-    };
+    private static final String[] headerTransArray = { "accept", "accept-charset", "accept-encoding", "accept-language",
+            "authorization", "connection", "content-type", "content-length", "cookie", "cookie2", "host", "pragma",
+            "referer", "user-agent" };
 
     /**
      * Converts an AJP coded HTTP request header to the header name.
+     *
      * @param code the coded value
+     *
      * @return the string value of the header name
      */
     public static String getHeaderForCode(final int code) {
@@ -189,30 +155,21 @@ public final class Constants {
     }
 
     // Translates integer codes to response header names
-    private static final String [] responseTransArray = {
-            "Content-Type",
-            "Content-Language",
-            "Content-Length",
-            "Date",
-            "Last-Modified",
-            "Location",
-            "Set-Cookie",
-            "Set-Cookie2",
-            "Servlet-Engine",
-            "Status",
-            "WWW-Authenticate"
-    };
+    private static final String[] responseTransArray = { "Content-Type", "Content-Language", "Content-Length", "Date",
+            "Last-Modified", "Location", "Set-Cookie", "Set-Cookie2", "Servlet-Engine", "Status", "WWW-Authenticate" };
 
     /**
      * Converts an AJP coded response header name to the HTTP response header name.
+     *
      * @param code the coded value
+     *
      * @return the string value of the header
      */
     public static String getResponseHeaderForCode(final int code) {
         return responseTransArray[code];
     }
 
-    private static final Map<String,Integer>  responseTransMap = new HashMap<>(20);
+    private static final Map<String, Integer> responseTransMap = new HashMap<>(20);
 
     static {
         try {
@@ -220,8 +177,7 @@ public final class Constants {
             for (i = 0; i < SC_RESP_AJP13_MAX; i++) {
                 responseTransMap.put(getResponseHeaderForCode(i), Integer.valueOf(0xA001 + i));
             }
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
             // Do nothing
         }
     }

==================================================
TestAbstractAjpProcessor.java
index bb34d04b5e..f4ba2a64d6 100644
--- a/test/org/apache/coyote/ajp/SimpleAjpClient.java
+++ b/test/org/apache/coyote/ajp/SimpleAjpClient.java
@@ -24,9 +24,8 @@ import java.util.Locale;
 import javax.net.SocketFactory;
 
 /**
- * AJP client that is not (yet) a full AJP client implementation as it just
- * provides the functionality required for the unit tests. The client uses
- * blocking IO throughout.
+ * AJP client that is not (yet) a full AJP client implementation as it just provides the functionality required for the
+ * unit tests. The client uses blocking IO throughout.
  */
 public class SimpleAjpClient {
 
@@ -39,8 +38,7 @@ public class SimpleAjpClient {
         ajpCping.appendByte(Constants.JK_AJP13_CPING_REQUEST);
         ajpCping.end();
         AJP_CPING = new byte[ajpCping.getLen()];
-        System.arraycopy(ajpCping.getBuffer(), 0, AJP_CPING, 0,
-                ajpCping.getLen());
+        System.arraycopy(ajpCping.getBuffer(), 0, AJP_CPING, 0, ajpCping.getLen());
     }
 
     private final int packetSize;
@@ -349,20 +347,16 @@ public class SimpleAjpClient {
     /*
      * Sends an TesterAjpMessage to the server and returns the response message.
      */
-    public TesterAjpMessage sendMessage(TesterAjpMessage headers)
-            throws IOException {
+    public TesterAjpMessage sendMessage(TesterAjpMessage headers) throws IOException {
         return sendMessage(headers, null);
     }
 
-    public TesterAjpMessage sendMessage(TesterAjpMessage headers,
-            TesterAjpMessage body) throws IOException {
+    public TesterAjpMessage sendMessage(TesterAjpMessage headers, TesterAjpMessage body) throws IOException {
         // Send the headers
-        socket.getOutputStream().write(
-                headers.getBuffer(), 0, headers.getLen());
+        socket.getOutputStream().write(headers.getBuffer(), 0, headers.getLen());
         if (body != null) {
             // Send the body of present
-            socket.getOutputStream().write(
-                    body.getBuffer(), 0, body.getLen());
+            socket.getOutputStream().write(body.getBuffer(), 0, body.getLen());
         }
         // Read the response
         return readMessage();
@@ -398,18 +392,15 @@ public class SimpleAjpClient {
             return message;
         } else {
             if (messageLength > buf.length) {
-                throw new IllegalArgumentException("Message too long [" +
-                        Integer.valueOf(messageLength) +
-                        "] for buffer length [" +
-                        Integer.valueOf(buf.length) + "]");
+                throw new IllegalArgumentException("Message too long [" + Integer.valueOf(messageLength) +
+                        "] for buffer length [" + Integer.valueOf(buf.length) + "]");
             }
             read(is, buf, Constants.H_SIZE, messageLength);
             return message;
         }
     }
 
-    protected boolean read(InputStream is, byte[] buf, int pos, int n)
-        throws IOException {
+    protected boolean read(InputStream is, byte[] buf, int pos, int n) throws IOException {
 
         int read = 0;
         int res = 0;

==================================================
TesterAjpMessage.java
index a49ba87ea6..111b033e85 100644
--- a/test/org/apache/coyote/ajp/TestAbstractAjpProcessor.java
+++ b/test/org/apache/coyote/ajp/TestAbstractAjpProcessor.java
@@ -58,8 +58,7 @@ public class TestAbstractAjpProcessor extends TomcatBaseTest {
     @Override
     protected String getProtocol() {
         /*
-         * The tests are all setup for HTTP so need to convert the protocol
-         * values to AJP.
+         * The tests are all setup for HTTP so need to convert the protocol values to AJP.
          */
         // Has a protocol been specified
         String protocol = System.getProperty("tomcat.test.protocol");
@@ -98,17 +97,15 @@ public class TestAbstractAjpProcessor extends TomcatBaseTest {
 
         SimpleAjpClient ajpClient = new SimpleAjpClient(ajpPacketSize);
 
-        if (requestInfo.get("REQUEST-QUERY-STRING") != null &&
-            params.size() > 0) {
-            throw(new IllegalArgumentException("Request setting " +
-                "'REQUEST-QUERY-STRING' and explicit params not allowed " +
-                "together"));
+        if (requestInfo.get("REQUEST-QUERY-STRING") != null && params.size() > 0) {
+            throw (new IllegalArgumentException(
+                    "Request setting " + "'REQUEST-QUERY-STRING' and explicit params not allowed " + "together"));
         }
 
         String value;
         int bodySize = 0;
         Map<String, String> savedRequestInfo = new HashMap<>();
-        for (String name: requestInfo.keySet()) {
+        for (String name : requestInfo.keySet()) {
             value = requestInfo.get(name);
             switch (name) {
                 case "REQUEST-METHOD":
@@ -121,8 +118,9 @@ public class TestAbstractAjpProcessor extends TomcatBaseTest {
                     ajpClient.setUri(value);
                     break;
                 case "REQUEST-REMOTE-HOST":
-                    /* request.getRemoteHost() will default to
-                     * request.getRemoteAddr() unless enableLookups is set. */
+                    /*
+                     * request.getRemoteHost() will default to request.getRemoteAddr() unless enableLookups is set.
+                     */
                     tomcat.getConnector().setEnableLookups(true);
                     ajpClient.setRemoteHost(value);
                     break;
@@ -162,38 +160,38 @@ public class TestAbstractAjpProcessor extends TomcatBaseTest {
                     headers.put("CONTENT-TYPE", value);
                     break;
                 /* Not yet implemented or not (easily) possible to implement */
-                case "REQUEST-LOCAL-NAME":          //request.getLocalName()
-                case "REQUEST-LOCAL-PORT":          //request.getLocalPort()
-                case "REQUEST-SCHEME":              //request.getScheme()
-                case "REQUEST-URL":                 //request.getRequestURL()
-                case "REQUEST-CONTEXT-PATH":        //request.getContextPath()
-                case "REQUEST-SERVLET-PATH":        //request.getServletPath()
-                case "REQUEST-PATH-INFO":           //request.getPathInfo()
-                case "REQUEST-PATH-TRANSLATED":     //request.getPathTranslated()
-                case "REQUEST-USER-PRINCIPAL":      //request.getUserPrincipal()
-                case "REQUEST-CHARACTER-ENCODING":  //request.getCharacterEncoding()
-                case "REQUEST-LOCALE":              //request.getLocale()
-                case "SESSION-REQUESTED-ID":        //request.getRequestedSessionId()
-                case "SESSION-REQUESTED-ID-COOKIE": //request.isRequestedSessionIdFromCookie()
-                case "SESSION-REQUESTED-ID-URL":    //request.isRequestedSessionIdFromUrl()
-                case "SESSION-REQUESTED-ID-VALID":  //request.isRequestedSessionIdValid()
+                case "REQUEST-LOCAL-NAME": // request.getLocalName()
+                case "REQUEST-LOCAL-PORT": // request.getLocalPort()
+                case "REQUEST-SCHEME": // request.getScheme()
+                case "REQUEST-URL": // request.getRequestURL()
+                case "REQUEST-CONTEXT-PATH": // request.getContextPath()
+                case "REQUEST-SERVLET-PATH": // request.getServletPath()
+                case "REQUEST-PATH-INFO": // request.getPathInfo()
+                case "REQUEST-PATH-TRANSLATED": // request.getPathTranslated()
+                case "REQUEST-USER-PRINCIPAL": // request.getUserPrincipal()
+                case "REQUEST-CHARACTER-ENCODING": // request.getCharacterEncoding()
+                case "REQUEST-LOCALE": // request.getLocale()
+                case "SESSION-REQUESTED-ID": // request.getRequestedSessionId()
+                case "SESSION-REQUESTED-ID-COOKIE": // request.isRequestedSessionIdFromCookie()
+                case "SESSION-REQUESTED-ID-URL": // request.isRequestedSessionIdFromUrl()
+                case "SESSION-REQUESTED-ID-VALID": // request.isRequestedSessionIdValid()
                 default:
-                    throw(new IllegalArgumentException("Request setting '" + name + "' not supported"));
+                    throw (new IllegalArgumentException("Request setting '" + name + "' not supported"));
             }
         }
 
         ServletContext sc = ctx.getServletContext();
-        for (String name: contextInitParameters.keySet()) {
+        for (String name : contextInitParameters.keySet()) {
             sc.setInitParameter(name, contextInitParameters.get(name));
         }
-        for (String name: contextAttributes.keySet()) {
+        for (String name : contextAttributes.keySet()) {
             sc.setAttribute(name, contextAttributes.get(name));
         }
 
         /* Basic request properties must be set before this call */
         TesterAjpMessage forwardMessage = ajpClient.createForwardMessage();
 
-        for (String name: savedRequestInfo.keySet()) {
+        for (String name : savedRequestInfo.keySet()) {
             value = savedRequestInfo.get(name);
             switch (name) {
                 case "REQUEST-LOCAL-ADDR":
@@ -203,14 +201,16 @@ public class TestAbstractAjpProcessor extends TomcatBaseTest {
                     forwardMessage.addAttribute("AJP_REMOTE_PORT", value);
                     break;
                 case "REQUEST-REMOTE-USER":
-                    /* request.getRemoteUser() will not trust the AJP
-                     * info if tomcatAuthentication is set. */
+                    /*
+                     * request.getRemoteUser() will not trust the AJP info if tomcatAuthentication is set.
+                     */
                     Assert.assertTrue(tomcat.getConnector().setProperty("tomcatAuthentication", "false"));
                     forwardMessage.addAttribute(0x03, value);
                     break;
                 case "REQUEST-AUTH-TYPE":
-                    /* request.getAuthType() will not trust the AJP
-                     * info if tomcatAuthentication is set. */
+                    /*
+                     * request.getAuthType() will not trust the AJP info if tomcatAuthentication is set.
+                     */
                     Assert.assertTrue(tomcat.getConnector().setProperty("tomcatAuthentication", "false"));
                     forwardMessage.addAttribute(0x04, value);
                     break;
@@ -226,14 +226,14 @@ public class TestAbstractAjpProcessor extends TomcatBaseTest {
                 case "REQUEST-BODY-SIZE":
                     break;
                 default:
-                    throw(new IllegalArgumentException("Request setting '" + name + "' not supported"));
+                    throw (new IllegalArgumentException("Request setting '" + name + "' not supported"));
             }
         }
 
         if (params.size() > 0) {
             StringBuilder query = new StringBuilder();
             boolean sep = false;
-            for (String name: params.keySet()) {
+            for (String name : params.keySet()) {
                 if (sep) {
                     query.append('&');
                 } else {
@@ -246,7 +246,7 @@ public class TestAbstractAjpProcessor extends TomcatBaseTest {
             forwardMessage.addAttribute(0x05, query.toString());
         }
 
-        for (String name: headers.keySet()) {
+        for (String name : headers.keySet()) {
             value = headers.get(name);
             name = name.toUpperCase(Locale.ENGLISH);
             switch (name) {
@@ -297,7 +297,7 @@ public class TestAbstractAjpProcessor extends TomcatBaseTest {
                     break;
             }
         }
-        for (String name: attributes.keySet()) {
+        for (String name : attributes.keySet()) {
             value = attributes.get(name);
             forwardMessage.addAttribute(name, value);
         }
@@ -327,9 +327,10 @@ public class TestAbstractAjpProcessor extends TomcatBaseTest {
         String body = extractResponseBody(ajpClient.readMessage());
         RequestDescriptor result = SnoopResult.parse(body);
 
-        /* AJP attributes result in Coyote Request attributes, which are
-         * not listed by request.getAttributeNames(), so SnoopServlet
-         * does not see them. Delete attributes before result comparison. */
+        /*
+         * AJP attributes result in Coyote Request attributes, which are not listed by request.getAttributeNames(), so
+         * SnoopServlet does not see them. Delete attributes before result comparison.
+         */
         desc.getAttributes().clear();
 
         result.compare(desc);
@@ -513,7 +514,7 @@ public class TestAbstractAjpProcessor extends TomcatBaseTest {
 
         StringManager smClient = StringManager.getManager("org.apache.catalina.valves");
         String expectedBody = "<p><b>" + smClient.getString("errorReportValve.type") + "</b> " +
-            smClient.getString("errorReportValve.statusReport") + "</p>";
+                smClient.getString("errorReportValve.statusReport") + "</p>";
 
         SimpleAjpClient ajpClient = new SimpleAjpClient();
 
@@ -620,8 +621,7 @@ public class TestAbstractAjpProcessor extends TomcatBaseTest {
     }
 
 
-    public void doTestPost(boolean multipleCL, int expectedStatus,
-                           String expectedMessage) throws Exception {
+    public void doTestPost(boolean multipleCL, int expectedStatus, String expectedMessage) throws Exception {
 
         getTomcatInstanceTestWebapp(false, true);
 
@@ -641,11 +641,9 @@ public class TestAbstractAjpProcessor extends TomcatBaseTest {
         forwardMessage.addHeader(0xA007, "application/x-www-form-urlencoded");
         forwardMessage.end();
 
-        TesterAjpMessage bodyMessage =
-                ajpClient.createBodyMessage("test=data".getBytes());
+        TesterAjpMessage bodyMessage = ajpClient.createBodyMessage("test=data".getBytes());
 
-        TesterAjpMessage responseHeaders =
-                ajpClient.sendMessage(forwardMessage, bodyMessage);
+        TesterAjpMessage responseHeaders = ajpClient.sendMessage(forwardMessage, bodyMessage);
 
         validateResponseHeaders(responseHeaders, expectedStatus, expectedMessage);
         if (expectedStatus == HttpServletResponse.SC_OK) {
@@ -660,7 +658,7 @@ public class TestAbstractAjpProcessor extends TomcatBaseTest {
             // Expect 3 messages: headers, error report body, end for an invalid request
             StringManager smClient = StringManager.getManager("org.apache.catalina.valves");
             String expectedBody = "<p><b>" + smClient.getString("errorReportValve.type") + "</b> " +
-                smClient.getString("errorReportValve.statusReport") + "</p>";
+                    smClient.getString("errorReportValve.statusReport") + "</p>";
             TesterAjpMessage responseBody = ajpClient.readMessage();
             validateResponseBody(responseBody, expectedBody);
             validateResponseEnd(ajpClient.readMessage(), false);
@@ -696,8 +694,7 @@ public class TestAbstractAjpProcessor extends TomcatBaseTest {
         TesterAjpMessage forwardMessage = ajpClient.createForwardMessage();
         forwardMessage.end();
 
-        TesterAjpMessage responseHeaders =
-                ajpClient.sendMessage(forwardMessage, null);
+        TesterAjpMessage responseHeaders = ajpClient.sendMessage(forwardMessage, null);
 
         // Expect 2 messages: headers, end
         validateResponseHeaders(responseHeaders, 304, "304");
@@ -730,8 +727,7 @@ public class TestAbstractAjpProcessor extends TomcatBaseTest {
         doTestZeroLengthRequestBody("POST", false);
     }
 
-    private void doTestZeroLengthRequestBody(String method, boolean callAvailable)
-            throws Exception {
+    private void doTestZeroLengthRequestBody(String method, boolean callAvailable) throws Exception {
 
         Tomcat tomcat = getTomcatInstance();
 
@@ -755,13 +751,11 @@ public class TestAbstractAjpProcessor extends TomcatBaseTest {
         forwardMessage.addHeader(0xA008, "0");
         forwardMessage.end();
 
-        TesterAjpMessage responseHeaders =
-                ajpClient.sendMessage(forwardMessage, null);
+        TesterAjpMessage responseHeaders = ajpClient.sendMessage(forwardMessage, null);
 
         // Expect 3 messages: headers, body, end
         validateResponseHeaders(responseHeaders, 200, "200");
-        validateResponseBody(ajpClient.readMessage(),
-                "Request Body length in bytes: 0");
+        validateResponseBody(ajpClient.readMessage(), "Request Body length in bytes: 0");
         validateResponseEnd(ajpClient.readMessage(), true);
 
         // Double check the connection is still open
@@ -777,8 +771,8 @@ public class TestAbstractAjpProcessor extends TomcatBaseTest {
                 success = ((itRead.next().intValue() > 0) == (itAvailable.next().intValue() > 0));
             }
             if (!success) {
-                Assert.fail("available() and read() results do not match.\nAvailable: "
-                        + servlet.availableList + "\nRead: " + servlet.readList);
+                Assert.fail("available() and read() results do not match.\nAvailable: " + servlet.availableList +
+                        "\nRead: " + servlet.readList);
             }
         }
     }
@@ -854,7 +848,7 @@ public class TestAbstractAjpProcessor extends TomcatBaseTest {
         TesterAjpMessage responseHeaderMessage = ajpClient.sendMessage(forwardMessage, null);
 
         // Expect 2 messages: headers, end
-        Map<String,List<String>> responseHeaders = validateResponseHeaders(responseHeaderMessage, 200, "200");
+        Map<String, List<String>> responseHeaders = validateResponseHeaders(responseHeaderMessage, 200, "200");
         Assert.assertTrue(responseHeaders.containsKey(InvalidHeaderServlet.VALID_HEADER_A_NAME));
         Assert.assertFalse(responseHeaders.containsKey(InvalidHeaderServlet.INVALID_HEADER_B_NAME));
         Assert.assertTrue(responseHeaders.containsKey(InvalidHeaderServlet.VALID_HEADER_C_NAME));
@@ -890,11 +884,10 @@ public class TestAbstractAjpProcessor extends TomcatBaseTest {
 
 
     /**
-     * Process response header packet and checks the status. Any other data is
-     * ignored.
+     * Process response header packet and checks the status. Any other data is ignored.
      */
-    private Map<String,List<String>> validateResponseHeaders(TesterAjpMessage message,
-            int expectedStatus, String expectedMessage) throws Exception {
+    private Map<String, List<String>> validateResponseHeaders(TesterAjpMessage message, int expectedStatus,
+            String expectedMessage) throws Exception {
         // First two bytes should always be AB
         Assert.assertEquals((byte) 'A', message.buf[0]);
         Assert.assertEquals((byte) 'B', message.buf[1]);
@@ -917,7 +910,7 @@ public class TestAbstractAjpProcessor extends TomcatBaseTest {
         // Get the number of headers
         int headerCount = message.readInt();
 
-        Map<String,List<String>> headerMap = new HashMap<>();
+        Map<String, List<String>> headerMap = new HashMap<>();
         for (int i = 0; i < headerCount; i++) {
             String headerName = message.readHeaderName();
             String headerValue = message.readString();
@@ -938,8 +931,7 @@ public class TestAbstractAjpProcessor extends TomcatBaseTest {
     /**
      * Extract the content from a response message.
      */
-    private String extractResponseBody(TesterAjpMessage message)
-            throws Exception {
+    private String extractResponseBody(TesterAjpMessage message) throws Exception {
 
         Assert.assertEquals((byte) 'A', message.buf[0]);
         Assert.assertEquals((byte) 'B', message.buf[1]);
@@ -956,18 +948,15 @@ public class TestAbstractAjpProcessor extends TomcatBaseTest {
     }
 
     /**
-     * Validates that the response message is valid and contains the expected
-     * content.
+     * Validates that the response message is valid and contains the expected content.
      */
-    private void validateResponseBody(TesterAjpMessage message,
-            String expectedBody) throws Exception {
+    private void validateResponseBody(TesterAjpMessage message, String expectedBody) throws Exception {
 
         String body = extractResponseBody(message);
         Assert.assertTrue(body.contains(expectedBody));
     }
 
-    private void validateResponseEnd(TesterAjpMessage message,
-            boolean expectedReuse) {
+    private void validateResponseEnd(TesterAjpMessage message, boolean expectedReuse) {
         Assert.assertEquals((byte) 'A', message.buf[0]);
         Assert.assertEquals((byte) 'B', message.buf[1]);
 
@@ -1004,8 +993,7 @@ public class TestAbstractAjpProcessor extends TomcatBaseTest {
         private static final long serialVersionUID = 1L;
 
         @Override
-        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
-                throws ServletException, IOException {
+        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
 
             resp.setStatus(304);
             resp.getWriter().print("Body not permitted for 304 response");
@@ -1028,19 +1016,17 @@ public class TestAbstractAjpProcessor extends TomcatBaseTest {
         }
 
         @Override
-        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
-                throws ServletException, IOException {
+        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
             doRequest(req, resp, false);
         }
 
         @Override
-        protected void doPost(HttpServletRequest req, HttpServletResponse resp)
-                throws ServletException, IOException {
+        protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
             doRequest(req, resp, true);
         }
 
-        private void doRequest(HttpServletRequest request, HttpServletResponse response,
-                boolean isPost) throws IOException {
+        private void doRequest(HttpServletRequest request, HttpServletResponse response, boolean isPost)
+                throws IOException {
 
             long readCount = 0;
 
@@ -1086,8 +1072,7 @@ public class TestAbstractAjpProcessor extends TomcatBaseTest {
         }
 
         @Override
-        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
-                throws ServletException, IOException {
+        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
             resp.setBufferSize(bufferSize);
 
             resp.setContentType("text/plain");

==================================================
