2357fb52763c69aa8cf493e8af2f5a508b188409
==================================================
Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=49567
==================================================
Mark Emlyn
==================================================
Thu Jul 22 09:12:18 2010 +0000
==================================================
CoyoteAdapter.java
Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=49567
Better handling of calls to complete() from a separate thread.
There are still a handful of TODOs around this which will follow shortly but I'm committing this since it passes the unit tests and the Servlet TCK (with BIO)

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@966548 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Request.java
index a043159787..7a81f85ed0 100644
--- a/java/org/apache/catalina/connector/CoyoteAdapter.java
+++ b/java/org/apache/catalina/connector/CoyoteAdapter.java
@@ -267,7 +267,7 @@ public class CoyoteAdapter implements Adapter {
                 //configure settings for timed out
                 asyncConImpl.setTimeoutState();
             }
-            if (status==SocketStatus.ERROR || status==SocketStatus.STOP || status==SocketStatus.DISCONNECT) {
+            if (status==SocketStatus.ERROR || status==SocketStatus.DISCONNECT) {
                 AsyncContextImpl asyncConImpl = (AsyncContextImpl)request.getAsyncContext();
                 //TODO SERVLET3 - async
                 //configure settings for timed out

==================================================
AsyncContextImpl.java
index 168484ecd8..e9b2bb5248 100644
--- a/java/org/apache/catalina/connector/Request.java
+++ b/java/org/apache/catalina/connector/Request.java
@@ -1582,7 +1582,6 @@ public class Request
         }
         
         return (asyncContext.getState()==AsyncContextImpl.AsyncState.DISPATCHING ||
-                asyncContext.getState()==AsyncContextImpl.AsyncState.DISPATCHING_RUNNABLE  ||
                 asyncContext.getState()==AsyncContextImpl.AsyncState.TIMING_OUT  ||
                 asyncContext.getState()==AsyncContextImpl.AsyncState.STARTED     ||
                 asyncContext.getState()==AsyncContextImpl.AsyncState.ERROR_DISPATCHING ||

==================================================
Http11Processor.java
index 5c0de4e0c0..089b2588d8 100644
--- a/java/org/apache/catalina/core/AsyncContextImpl.java
+++ b/java/org/apache/catalina/core/AsyncContextImpl.java
@@ -48,8 +48,8 @@ import org.apache.juli.logging.LogFactory;
 public class AsyncContextImpl implements AsyncContext {
     
     public static enum AsyncState {
-        NOT_STARTED, STARTED, DISPATCHING, DISPATCHING_RUNNABLE, DISPATCHED,
-        COMPLETING, COMPLETING_RUNNABLE, TIMING_OUT, ERROR_DISPATCHING
+        NOT_STARTED, STARTED, DISPATCHING, DISPATCHED, COMPLETING, TIMING_OUT,
+        ERROR_DISPATCHING
     }
     
     private static final Log log = LogFactory.getLog(AsyncContextImpl.class);
@@ -87,9 +87,6 @@ public class AsyncContextImpl implements AsyncContext {
             AtomicBoolean dispatched = new AtomicBoolean(false);
             request.getCoyoteRequest().action(ActionCode.ACTION_ASYNC_COMPLETE,dispatched);
             if (!dispatched.get()) doInternalComplete(false);
-        } else if (state.compareAndSet(AsyncState.DISPATCHING_RUNNABLE,
-                AsyncState.COMPLETING_RUNNABLE)) {
-            // do nothing
         } else {
             throw new IllegalStateException("Complete not allowed. Invalid state:"+state.get());
         }
@@ -182,33 +179,16 @@ public class AsyncContextImpl implements AsyncContext {
             log.debug("AsyncContext Start Called["+state.get()+"; "+request.getRequestURI()+"?"+request.getQueryString()+"]", new DebugException());
         }
 
-        if (state.compareAndSet(AsyncState.STARTED, AsyncState.DISPATCHING_RUNNABLE) ||
-            state.compareAndSet(AsyncState.DISPATCHED, AsyncState.DISPATCHING_RUNNABLE)) {
-            // TODO SERVLET3 - async
-            final ServletContext sctx = getServletRequest().getServletContext();
-            Runnable r = new Runnable() {
-                public void run() {
-                    //TODO SERVLET3 - async - set context class loader when running the task.
-                    try {
-                        
-                        run.run();
-                    }catch (Exception x) {
-                        log.error("Unable to run async task.",x);
-                    }
-                }
-            };
-            this.dispatch = r;
-            AtomicBoolean dispatched = new AtomicBoolean(false);
-            request.getCoyoteRequest().action(ActionCode.ACTION_ASYNC_DISPATCH, dispatched );
-            if (!dispatched.get()) {
-                try {
-                    doInternalDispatch();
-                }catch (ServletException sx) {
-                    throw new RuntimeException(sx);
-                }catch (IOException ix) {
-                    throw new RuntimeException(ix);
-                }
-            }
+        if (state.get() ==  AsyncState.STARTED) {
+            // TODO SERVLET3 - async - set context class loader when running the
+            // task.
+            // final ServletContext sctx = getServletRequest().getServletContext();
+            // TODO - Use a container thread without creating a memory leak 
+            // Execute the runnable using a container thread from the
+            // Connector's thread pool
+            // request.getConnector().getProtocolHandler().getExecutor().execute(run);
+            Thread t = new Thread(run);
+            t.start();
         } else {
             throw new IllegalStateException("Dispatch not allowed. Invalid state:"+state.get());
         }
@@ -258,8 +238,7 @@ public class AsyncContextImpl implements AsyncContext {
 
     public boolean isStarted() {
         return (state.get() == AsyncState.STARTED ||
-                state.get() == AsyncState.DISPATCHING ||
-                state.get() == AsyncState.DISPATCHING_RUNNABLE);
+                state.get() == AsyncState.DISPATCHING);
     }
 
     public void setStarted(Context context) {
@@ -304,10 +283,16 @@ public class AsyncContextImpl implements AsyncContext {
                 listener.fireOnTimeout(event);
                 listenerInvoked = true;
             }
-            if (!listenerInvoked) {
-                ((HttpServletResponse)servletResponse).setStatus(500);
+            if (listenerInvoked) {
+                // Listener should have called complete
+                if (state.get() != AsyncState.NOT_STARTED) {
+                    ((HttpServletResponse)servletResponse).setStatus(500);
+                    doInternalComplete(true);
+                }
+            } else {
+                // No listeners, container calls complete
+                doInternalComplete(false);
             }
-            doInternalComplete(true);
         } else if (this.state.compareAndSet(AsyncState.ERROR_DISPATCHING, AsyncState.COMPLETING)) {
             log.debug("ON ERROR!");
             boolean listenerInvoked = false;
@@ -339,27 +324,6 @@ public class AsyncContextImpl implements AsyncContext {
                     dispatch = null;
                 }
             }
-        } else if (this.state.get() == AsyncState.DISPATCHING_RUNNABLE) {
-            if (this.dispatch!=null) {
-                try {
-                    dispatch.run();
-                } catch (RuntimeException x) {
-                    doInternalComplete(true);
-                    if (x.getCause() instanceof ServletException) throw (ServletException)x.getCause();
-                    if (x.getCause() instanceof IOException) throw (IOException)x.getCause();
-                    else throw new ServletException(x);
-                } finally {
-                    dispatch = null;
-                }
-                if (this.state.compareAndSet(AsyncState.COMPLETING_RUNNABLE,
-                        AsyncState.COMPLETING)) {
-                    doInternalComplete(false);
-                } else if (this.state.get() == AsyncState.DISPATCHING_RUNNABLE) {
-                    doInternalComplete(true);
-                    throw new IllegalStateException(
-                            "Failed to call dispatch() or complete() after start()");
-                }
-            }
         } else if (this.state.get()==AsyncState.COMPLETING) {
             doInternalComplete(false);
         } else {

==================================================
TestAsyncContextImpl.java
index 0b35ece3fe..e0c7f13d8c 100644
--- a/java/org/apache/coyote/http11/Http11Processor.java
+++ b/java/org/apache/coyote/http11/Http11Processor.java
@@ -349,8 +349,8 @@ public class Http11Processor extends AbstractHttp11Processor implements ActionHo
         } else if (async) {
             return SocketState.LONG;
         } else {
+            recycle();
             if (!keepAlive) {
-                recycle();
                 return SocketState.CLOSED;
             } else {
                 return SocketState.OPEN;

==================================================
