70f8398d08103705420ff330fb2be8a31d7da11a
==================================================
Code clean-up. Add braces for clarity
==================================================
Mark Thomas
==================================================
Wed May 26 12:28:51 2021 +0100
==================================================
ConnectorStoreAppender.java
Code clean-up. Add braces for clarity

Again, primarily to trigger CI builds to tes CI config changes


==================================================
CredentialHandlerSF.java
index c48416aca4..5b872aca5b 100644
--- a/java/org/apache/catalina/storeconfig/ConnectorStoreAppender.java
+++ b/java/org/apache/catalina/storeconfig/ConnectorStoreAppender.java
@@ -129,8 +129,9 @@ public class ConnectorStoreAppender extends StoreAppender {
             }
             if ("protocol".equals(descriptor.getName())
                     || "protocolHandlerClassName".equals(descriptor
-                            .getName()))
+                            .getName())) {
                 continue;
+            }
             propertyKeys.add(descriptor.getName());
         }
         // Add the properties of the protocol handler
@@ -292,8 +293,9 @@ public class ConnectorStoreAppender extends StoreAppender {
 
         File jkHomeBase;
         File file = new File(jkHome);
-        if (!file.isAbsolute())
+        if (!file.isAbsolute()) {
             file = new File(appBase, jkHome);
+        }
         try {
             jkHomeBase = file.getCanonicalFile();
         } catch (IOException e) {

==================================================
InterceptorSF.java
index 7e85497a33..bb90e1f92a 100644
--- a/java/org/apache/catalina/storeconfig/CredentialHandlerSF.java
+++ b/java/org/apache/catalina/storeconfig/CredentialHandlerSF.java
@@ -39,9 +39,10 @@ public class CredentialHandlerSF extends StoreFactoryBase {
                     aElement.getClass());
 
             if (elementDesc != null) {
-                if (log.isDebugEnabled())
+                if (log.isDebugEnabled()) {
                     log.debug(sm.getString("factory.storeTag",
                             elementDesc.getTag(), aElement));
+                }
                 getStoreAppender().printIndent(aWriter, indent + 2);
                 getStoreAppender().printOpenTag(aWriter, indent + 2, aElement,
                             elementDesc);
@@ -49,9 +50,10 @@ public class CredentialHandlerSF extends StoreFactoryBase {
                 getStoreAppender().printIndent(aWriter, indent + 2);
                 getStoreAppender().printCloseTag(aWriter, elementDesc);
             } else {
-                if (log.isWarnEnabled())
+                if (log.isWarnEnabled()) {
                     log.warn(sm.getString("factory.storeNoDescriptor",
                             aElement.getClass()));
+                }
             }
         } else {
             super.store(aWriter, indent, aElement);

==================================================
LoaderSF.java
index 205d221930..0602141309 100644
--- a/java/org/apache/catalina/storeconfig/InterceptorSF.java
+++ b/java/org/apache/catalina/storeconfig/InterceptorSF.java
@@ -39,9 +39,10 @@ public class InterceptorSF extends StoreFactoryBase {
                     aElement.getClass());
 
             if (elementDesc != null) {
-                if (log.isDebugEnabled())
+                if (log.isDebugEnabled()) {
                     log.debug(sm.getString("factory.storeTag",
                             elementDesc.getTag(), aElement));
+                }
                 getStoreAppender().printIndent(aWriter, indent + 2);
                 getStoreAppender().printOpenTag(aWriter, indent + 2, aElement,
                             elementDesc);
@@ -49,9 +50,10 @@ public class InterceptorSF extends StoreFactoryBase {
                 getStoreAppender().printIndent(aWriter, indent + 2);
                 getStoreAppender().printCloseTag(aWriter, elementDesc);
             } else {
-                if (log.isWarnEnabled())
+                if (log.isWarnEnabled()) {
                     log.warn(sm.getString("factory.storeNoDescriptor",
                             aElement.getClass()));
+                }
             }
         } else {
             super.store(aWriter, indent, aElement);

==================================================
ManagerSF.java
index 1d89e9fb7d..d5019777d7 100644
--- a/java/org/apache/catalina/storeconfig/LoaderSF.java
+++ b/java/org/apache/catalina/storeconfig/LoaderSF.java
@@ -44,9 +44,10 @@ public class LoaderSF extends StoreFactoryBase {
         if (elementDesc != null) {
             Loader loader = (Loader) aElement;
             if (!isDefaultLoader(loader)) {
-                if (log.isDebugEnabled())
+                if (log.isDebugEnabled()) {
                     log.debug("store " + elementDesc.getTag() + "( " + aElement
                             + " )");
+                }
                 getStoreAppender().printIndent(aWriter, indent + 2);
                 getStoreAppender().printTag(aWriter, indent + 2, loader,
                         elementDesc);

==================================================
NamingResourcesSF.java
index e4e0a79b83..715d16f867 100644
--- a/java/org/apache/catalina/storeconfig/ManagerSF.java
+++ b/java/org/apache/catalina/storeconfig/ManagerSF.java
@@ -46,18 +46,20 @@ public class ManagerSF extends StoreFactoryBase {
             if (aElement instanceof StandardManager) {
                 StandardManager manager = (StandardManager) aElement;
                 if (!isDefaultManager(manager)) {
-                    if (log.isDebugEnabled())
+                    if (log.isDebugEnabled()) {
                         log.debug(sm.getString("factory.storeTag", elementDesc
                                 .getTag(), aElement));
+                    }
                     super.store(aWriter, indent, aElement);
                 }
             } else {
                 super.store(aWriter, indent, aElement);
             }
         } else {
-            if (log.isWarnEnabled())
+            if (log.isWarnEnabled()) {
                 log.warn(sm.getString("factory.storeNoDescriptor", aElement
                         .getClass()));
+            }
         }
     }
 

==================================================
RealmSF.java
index 8bf0adff0e..46dba5c3df 100644
--- a/java/org/apache/catalina/storeconfig/NamingResourcesSF.java
+++ b/java/org/apache/catalina/storeconfig/NamingResourcesSF.java
@@ -45,9 +45,10 @@ public class NamingResourcesSF extends StoreFactoryBase {
         StoreDescription elementDesc = getRegistry().findDescription(
                 aElement.getClass());
         if (elementDesc != null) {
-            if (log.isDebugEnabled())
+            if (log.isDebugEnabled()) {
                 log.debug("store " + elementDesc.getTag() + "( " + aElement
                         + " )");
+            }
             storeChildren(aWriter, indent, aElement, elementDesc);
         } else {
             log.warn(sm.getString("storeFactory.noDescriptor", aElement.getClass(), "NamingResources"));

==================================================
StandardContextSF.java
index cf257bd738..0d870d59f4 100644
--- a/java/org/apache/catalina/storeconfig/RealmSF.java
+++ b/java/org/apache/catalina/storeconfig/RealmSF.java
@@ -40,9 +40,10 @@ public class RealmSF extends StoreFactoryBase {
                     aElement.getClass());
 
             if (elementDesc != null) {
-                if (log.isDebugEnabled())
+                if (log.isDebugEnabled()) {
                     log.debug(sm.getString("factory.storeTag",
                             elementDesc.getTag(), aElement));
+                }
                 getStoreAppender().printIndent(aWriter, indent + 2);
                 getStoreAppender().printOpenTag(aWriter, indent + 2, aElement,
                             elementDesc);
@@ -50,9 +51,10 @@ public class RealmSF extends StoreFactoryBase {
                 getStoreAppender().printIndent(aWriter, indent + 2);
                 getStoreAppender().printCloseTag(aWriter, elementDesc);
             } else {
-                if (log.isWarnEnabled())
+                if (log.isWarnEnabled()) {
                     log.warn(sm.getString("factory.storeNoDescriptor",
                             aElement.getClass()));
+                }
             }
         } else {
             super.store(aWriter, indent, aElement);

==================================================
StandardEngineSF.java
index 3130a6f375..aaf0c54011 100644
--- a/java/org/apache/catalina/storeconfig/StandardContextSF.java
+++ b/java/org/apache/catalina/storeconfig/StandardContextSF.java
@@ -77,11 +77,12 @@ public class StandardContextSF extends StoreFactoryBase {
                         .getConfigFile();
                 if (configFile != null) {
                     if (desc.isExternalAllowed()) {
-                        if (desc.isBackup())
+                        if (desc.isBackup()) {
                             storeWithBackup((StandardContext) aContext);
-                        else
+                        } else {
                             storeContextSeparate(aWriter, indent,
                                     (StandardContext) aContext);
+                        }
                         return;
                     }
                 } else if (desc.isExternalOnly()) {
@@ -93,11 +94,12 @@ public class StandardContextSF extends StoreFactoryBase {
                     String baseName = cn.getBaseName();
                     File xml = new File(configBase, baseName + ".xml");
                     context.setConfigFile(xml.toURI().toURL());
-                    if (desc.isBackup())
+                    if (desc.isBackup()) {
                         storeWithBackup((StandardContext) aContext);
-                    else
+                    } else {
                         storeContextSeparate(aWriter, indent,
                                 (StandardContext) aContext);
+                    }
                     return;
                 }
             }
@@ -339,18 +341,24 @@ public class StandardContextSF extends StoreFactoryBase {
 
         List<String> resource = new ArrayList<>();
         for (String wresource : wresources) {
-            if (wresource.equals(confContext))
+            if (wresource.equals(confContext)) {
                 continue;
-            if (wresource.equals(confWeb))
+            }
+            if (wresource.equals(confWeb)) {
                 continue;
-            if (wresource.equals(confHostDefault))
+            }
+            if (wresource.equals(confHostDefault)) {
                 continue;
-            if (wresource.equals(configFile))
+            }
+            if (wresource.equals(configFile)) {
                 continue;
-            if (wresource.equals(webxml))
+            }
+            if (wresource.equals(webxml)) {
                 continue;
-            if (wresource.equals(tomcatwebxml))
+            }
+            if (wresource.equals(tomcatwebxml)) {
                 continue;
+            }
             resource.add(wresource);
         }
         return resource.toArray(new String[0]);

==================================================
StandardHostSF.java
index 582dde4e2a..6ccc9d8f62 100644
--- a/java/org/apache/catalina/storeconfig/StandardEngineSF.java
+++ b/java/org/apache/catalina/storeconfig/StandardEngineSF.java
@@ -73,8 +73,9 @@ public class StandardEngineSF extends StoreFactoryBase {
             if(valves != null && valves.length > 0 ) {
                 List<Valve> engineValves = new ArrayList<>() ;
                 for (Valve valve : valves) {
-                    if (!(valve instanceof ClusterValve))
+                    if (!(valve instanceof ClusterValve)) {
                         engineValves.add(valve);
+                    }
                 }
                 storeElementArray(aWriter, indent, engineValves.toArray());
             }

==================================================
StoreAppender.java
index 917d14b3a5..710f09bf26 100644
--- a/java/org/apache/catalina/storeconfig/StandardHostSF.java
+++ b/java/org/apache/catalina/storeconfig/StandardHostSF.java
@@ -79,8 +79,9 @@ public class StandardHostSF extends StoreFactoryBase {
             if(valves != null && valves.length > 0 ) {
                 List<Valve> hostValves = new ArrayList<>() ;
                 for (Valve valve : valves) {
-                    if (!(valve instanceof ClusterValve))
+                    if (!(valve instanceof ClusterValve)) {
                         hostValves.add(valve);
+                    }
                 }
                 storeElementArray(aWriter, indent, hostValves.toArray());
             }

==================================================
StoreConfig.java
index 29a23ee525..28b30d8694 100644
--- a/java/org/apache/catalina/storeconfig/StoreAppender.java
+++ b/java/org/apache/catalina/storeconfig/StoreAppender.java
@@ -71,8 +71,9 @@ public class StoreAppender {
             StoreDescription aDesc) throws Exception {
         aWriter.print("<");
         aWriter.print(aDesc.getTag());
-        if (aDesc.isAttributes() && bean != null)
+        if (aDesc.isAttributes() && bean != null) {
             printAttributes(aWriter, indent, bean, aDesc);
+        }
         aWriter.println(">");
     }
 
@@ -89,8 +90,9 @@ public class StoreAppender {
             StoreDescription aDesc) throws Exception {
         aWriter.print("<");
         aWriter.print(aDesc.getTag());
-        if (aDesc.isAttributes() && bean != null)
+        if (aDesc.isAttributes() && bean != null) {
             printAttributes(aWriter, indent, bean, aDesc);
+        }
         aWriter.println("/>");
     }
 
@@ -131,8 +133,9 @@ public class StoreAppender {
             for (int i = 0; i < elements.length; i++) {
                 printIndent(aWriter, indent + 4);
                 aWriter.print(elements[i]);
-                if (i + 1 < elements.length)
+                if (i + 1 < elements.length) {
                     aWriter.println(",");
+                }
             }
             printIndent(aWriter, indent + 2);
             aWriter.print("</");
@@ -298,8 +301,9 @@ public class StoreAppender {
      * @param value The attribute value
      */
     protected void printAttribute(PrintWriter writer, int indent, Object bean, StoreDescription desc, String attributeName, Object bean2, Object value) {
-        if (isPrintValue(bean, bean2, attributeName, desc))
+        if (isPrintValue(bean, bean2, attributeName, desc)) {
             printValue(writer, indent, attributeName, value);
+        }
     }
 
     /**

==================================================
StoreContextAppender.java
index 3d3cba18f0..9bd1e893de 100644
--- a/java/org/apache/catalina/storeconfig/StoreConfig.java
+++ b/java/org/apache/catalina/storeconfig/StoreConfig.java
@@ -275,8 +275,9 @@ public class StoreConfig implements IStoreConfig {
             desc.setStoreSeparate(false);
             desc.getStoreFactory().store(aWriter, indent, aContext);
         } finally {
-            if (desc != null)
+            if (desc != null) {
                 desc.setStoreSeparate(oldSeparate);
+            }
         }
     }
 

==================================================
StoreDescription.java
index b8a1b03a5a..920a482152 100644
--- a/java/org/apache/catalina/storeconfig/StoreContextAppender.java
+++ b/java/org/apache/catalina/storeconfig/StoreContextAppender.java
@@ -39,8 +39,9 @@ public class StoreContextAppender extends StoreAppender {
             if(attributeName.equals("docBase")) {
                 if(bean instanceof StandardContext) {
                     String docBase = ((StandardContext)bean).getOriginalDocBase() ;
-                    if(docBase != null)
+                    if(docBase != null) {
                         value = docBase ;
+                    }
                 }
             }
             printValue(writer, indent, attributeName, value);
@@ -85,9 +86,10 @@ public class StoreContextAppender extends StoreAppender {
 
         File appBase;
         File file = new File(host.getAppBase());
-        if (!file.isAbsolute())
+        if (!file.isAbsolute()) {
             file = new File(System.getProperty("catalina.base"), host
                     .getAppBase());
+        }
         try {
             appBase = file.getCanonicalFile();
         } catch (IOException e) {
@@ -100,11 +102,13 @@ public class StoreContextAppender extends StoreAppender {
     protected File getDocBase(StandardContext context, File appBase) {
         File docBase;
         String contextDocBase = context.getOriginalDocBase() ;
-        if(contextDocBase == null)
+        if(contextDocBase == null) {
             contextDocBase = context.getDocBase() ;
+        }
         File file = new File(contextDocBase);
-        if (!file.isAbsolute())
+        if (!file.isAbsolute()) {
             file = new File(appBase, contextDocBase);
+        }
         try {
             docBase = file.getCanonicalFile();
         } catch (IOException e) {
@@ -122,10 +126,12 @@ public class StoreContextAppender extends StoreAppender {
     protected String getDefaultWorkDir(StandardContext context) {
         String defaultWorkDir = null;
         String contextWorkDir = context.getName();
-        if (contextWorkDir.length() == 0)
+        if (contextWorkDir.length() == 0) {
             contextWorkDir = "_";
-        if (contextWorkDir.startsWith("/"))
+        }
+        if (contextWorkDir.startsWith("/")) {
             contextWorkDir = contextWorkDir.substring(1);
+        }
 
         Container host = context.getParent();
         if (host instanceof StandardHost) {
@@ -167,7 +173,8 @@ public class StoreContextAppender extends StoreAppender {
              * .getConfigBase(), "context.xml.default")); }
              */
             return defaultContext;
-        } else
+        } else {
             return super.defaultInstance(bean);
+        }
     }
 }

==================================================
StoreFactoryBase.java
index 4bb23b3b6a..0ede758301 100644
--- a/java/org/apache/catalina/storeconfig/StoreDescription.java
+++ b/java/org/apache/catalina/storeconfig/StoreDescription.java
@@ -248,14 +248,16 @@ public class StoreDescription {
     }
 
     public void addTransientAttribute(String attribute) {
-        if (transientAttributes == null)
+        if (transientAttributes == null) {
             transientAttributes = new ArrayList<>();
+        }
         transientAttributes.add(attribute);
     }
 
     public void removeTransientAttribute(String attribute) {
-        if (transientAttributes != null)
+        if (transientAttributes != null) {
             transientAttributes.remove(attribute);
+        }
     }
 
     /**
@@ -274,14 +276,16 @@ public class StoreDescription {
     }
 
     public void addTransientChild(String classname) {
-        if (transientChildren == null)
+        if (transientChildren == null) {
             transientChildren = new ArrayList<>();
+        }
         transientChildren.add(classname);
     }
 
     public void removeTransientChild(String classname) {
-        if (transientChildren != null)
+        if (transientChildren != null) {
             transientChildren.remove(classname);
+        }
     }
 
     /**
@@ -291,8 +295,9 @@ public class StoreDescription {
      * @return is classname attribute?
      */
     public boolean isTransientChild(String classname) {
-        if (transientChildren != null)
+        if (transientChildren != null) {
             return transientChildren.contains(classname);
+        }
         return false;
     }
 
@@ -303,8 +308,9 @@ public class StoreDescription {
      * @return is transient attribute?
      */
     public boolean isTransientAttribute(String attribute) {
-        if (transientAttributes != null)
+        if (transientAttributes != null) {
             return transientAttributes.contains(attribute);
+        }
         return false;
     }
 
@@ -314,10 +320,11 @@ public class StoreDescription {
      * @return Returns the id.
      */
     public String getId() {
-        if (id != null)
+        if (id != null) {
             return id;
-        else
+        } else {
             return getTagClass();
+        }
     }
 
     /**

==================================================
StoreFactoryRule.java
index 6a9ffc1a8b..2a1171ec85 100644
--- a/java/org/apache/catalina/storeconfig/StoreFactoryBase.java
+++ b/java/org/apache/catalina/storeconfig/StoreFactoryBase.java
@@ -116,9 +116,10 @@ public class StoreFactoryBase implements IStoreFactory {
                 aElement.getClass());
 
         if (elementDesc != null) {
-            if (log.isDebugEnabled())
+            if (log.isDebugEnabled()) {
                 log.debug(sm.getString("factory.storeTag",
                         elementDesc.getTag(), aElement));
+            }
             getStoreAppender().printIndent(aWriter, indent + 2);
             if (!elementDesc.isChildren()) {
                 getStoreAppender().printTag(aWriter, indent, aElement,
@@ -130,9 +131,10 @@ public class StoreFactoryBase implements IStoreFactory {
                 getStoreAppender().printIndent(aWriter, indent + 2);
                 getStoreAppender().printCloseTag(aWriter, elementDesc);
             }
-        } else
+        } else {
             log.warn(sm.getString("factory.storeNoDescriptor", aElement
                     .getClass()));
+        }
     }
 
     /**
@@ -166,8 +168,9 @@ public class StoreFactoryBase implements IStoreFactory {
             if (elementFactory != null) {
                 StoreDescription desc = getRegistry().findDescription(
                         aTagElement.getClass());
-                if (!desc.isTransientChild(aTagElement.getClass().getName()))
+                if (!desc.isTransientChild(aTagElement.getClass().getName())) {
                     elementFactory.store(aWriter, indent, aTagElement);
+                }
             } else {
                 log.warn(sm.getString("factory.storeNoDescriptor", aTagElement
                         .getClass()));

==================================================
WatchedResourceSF.java
index 69d8d4db13..a49a0fb47c 100644
--- a/java/org/apache/catalina/storeconfig/StoreFactoryRule.java
+++ b/java/org/apache/catalina/storeconfig/StoreFactoryRule.java
@@ -114,8 +114,9 @@ public class StoreFactoryRule extends Rule {
         String className = defaultName;
         if (attr != null) {
             String value = attributes.getValue(attr);
-            if (value != null)
+            if (value != null) {
                 className = value;
+            }
         }
         Class<?> clazz = Class.forName(className);
         return clazz.getConstructor().newInstance();

==================================================
WrapperLifecycleSF.java
index 7e5dafd0b4..da24ae8ace 100644
--- a/java/org/apache/catalina/storeconfig/WatchedResourceSF.java
+++ b/java/org/apache/catalina/storeconfig/WatchedResourceSF.java
@@ -41,9 +41,10 @@ public class WatchedResourceSF extends StoreFactoryBase {
             String[] resources = ((StandardContext) aElement)
                     .findWatchedResources();
             if (elementDesc != null) {
-                if (log.isDebugEnabled())
+                if (log.isDebugEnabled()) {
                     log.debug("store " + elementDesc.getTag() + "( " + aElement
                             + " )");
+                }
                 getStoreAppender().printTagArray(aWriter, "WatchedResource",
                         indent, resources);
             }

==================================================
WrapperListenerSF.java
index 89aa667b63..1800db7148 100644
--- a/java/org/apache/catalina/storeconfig/WrapperLifecycleSF.java
+++ b/java/org/apache/catalina/storeconfig/WrapperLifecycleSF.java
@@ -41,9 +41,10 @@ public class WrapperLifecycleSF extends StoreFactoryBase {
             String[] listeners = ((StandardContext) aElement)
                     .findWrapperLifecycles();
             if (elementDesc != null) {
-                if (log.isDebugEnabled())
+                if (log.isDebugEnabled()) {
                     log.debug("store " + elementDesc.getTag() + "( " + aElement
                             + " )");
+                }
                 getStoreAppender().printTagArray(aWriter, "WrapperLifecycle",
                         indent, listeners);
             }

==================================================
ByteMessage.java
index 8bcc974b5e..6e3cfd61ff 100644
--- a/java/org/apache/catalina/storeconfig/WrapperListenerSF.java
+++ b/java/org/apache/catalina/storeconfig/WrapperListenerSF.java
@@ -41,9 +41,10 @@ public class WrapperListenerSF extends StoreFactoryBase {
             String[] listeners = ((StandardContext) aElement)
                     .findWrapperListeners();
             if (elementDesc != null) {
-                if (log.isDebugEnabled())
+                if (log.isDebugEnabled()) {
                     log.debug("store " + elementDesc.getTag() + "( " + aElement
                             + " )");
+                }
                 getStoreAppender().printTagArray(aWriter, "WrapperListener",
                         indent, listeners);
             }

==================================================
ChannelException.java
index e300e7481d..cd414aaec2 100644
--- a/java/org/apache/catalina/tribes/ByteMessage.java
+++ b/java/org/apache/catalina/tribes/ByteMessage.java
@@ -94,7 +94,9 @@ public class ByteMessage implements Externalizable {
     @Override
     public void writeExternal(ObjectOutput out) throws IOException {
         out.writeInt(message!=null?message.length:0);
-        if ( message!=null ) out.write(message,0,message.length);
+        if ( message!=null ) {
+            out.write(message,0,message.length);
+        }
     }
 
 }

==================================================
UniqueId.java
index 9ec2924e89..8492dea300 100644
--- a/java/org/apache/catalina/tribes/ChannelException.java
+++ b/java/org/apache/catalina/tribes/ChannelException.java
@@ -112,7 +112,9 @@ public class ChannelException extends Exception {
     public int addFaultyMember(FaultyMember[] mbrs) {
         int result = 0;
         for (int i=0; mbrs!=null && i<mbrs.length; i++ ) {
-            if ( addFaultyMember(mbrs[i]) ) result++;
+            if ( addFaultyMember(mbrs[i]) ) {
+                result++;
+            }
         }
         return result;
     }
@@ -123,9 +125,14 @@ public class ChannelException extends Exception {
      * @return <code>true</code> if the member was added
      */
     public boolean addFaultyMember(FaultyMember mbr) {
-        if ( this.faultyMembers==null ) this.faultyMembers = new ArrayList<>();
-        if ( !faultyMembers.contains(mbr) ) return faultyMembers.add(mbr);
-        else return false;
+        if ( this.faultyMembers==null ) {
+            this.faultyMembers = new ArrayList<>();
+        }
+        if ( !faultyMembers.contains(mbr) ) {
+            return faultyMembers.add(mbr);
+        } else {
+            return false;
+        }
     }
 
     /**
@@ -133,7 +140,9 @@ public class ChannelException extends Exception {
      * @return FaultyMember[]
      */
     public FaultyMember[] getFaultyMembers() {
-        if ( this.faultyMembers==null ) return EMPTY_LIST;
+        if ( this.faultyMembers==null ) {
+            return EMPTY_LIST;
+        }
         return faultyMembers.toArray(new FaultyMember[0]);
     }
 
@@ -174,7 +183,9 @@ public class ChannelException extends Exception {
 
         @Override
         public boolean equals(Object o) {
-            if (member==null || (!(o instanceof FaultyMember)) || (((FaultyMember)o).member==null)) return false;
+            if (member==null || (!(o instanceof FaultyMember)) || (((FaultyMember)o).member==null)) {
+                return false;
+            }
             return member.equals(((FaultyMember)o).member);
         }
     }

==================================================
AbsoluteOrder.java
index cfb4387279..7adb75b80d 100644
--- a/java/org/apache/catalina/tribes/UniqueId.java
+++ b/java/org/apache/catalina/tribes/UniqueId.java
@@ -47,7 +47,9 @@ public final class UniqueId implements Serializable{
 
     @Override
     public int hashCode() {
-        if ( id == null ) return 0;
+        if ( id == null ) {
+            return 0;
+        }
         return Arrays.hashCode(id);
     }
 
@@ -56,10 +58,15 @@ public final class UniqueId implements Serializable{
         boolean result = (other instanceof UniqueId);
         if ( result ) {
             UniqueId uid = (UniqueId)other;
-            if ( this.id == null && uid.id == null ) result = true;
-            else if ( this.id == null && uid.id != null ) result = false;
-            else if ( this.id != null && uid.id == null ) result = false;
-            else result = Arrays.equals(this.id,uid.id);
+            if ( this.id == null && uid.id == null ) {
+                result = true;
+            } else if ( this.id == null && uid.id != null ) {
+                result = false;
+            } else if ( this.id != null && uid.id == null ) {
+                result = false;
+            } else {
+                result = Arrays.equals(this.id,uid.id);
+            }
         }//end if
         return result;
     }

==================================================
ChannelCoordinator.java
index 20e8b430f1..412d2a6c7a 100644
--- a/java/org/apache/catalina/tribes/group/AbsoluteOrder.java
+++ b/java/org/apache/catalina/tribes/group/AbsoluteOrder.java
@@ -52,12 +52,16 @@ public class AbsoluteOrder {
 
 
     public static void absoluteOrder(Member[] members) {
-        if ( members == null || members.length <= 1 ) return;
+        if ( members == null || members.length <= 1 ) {
+            return;
+        }
         Arrays.sort(members,comp);
     }
 
     public static void absoluteOrder(List<Member> members) {
-        if ( members == null || members.size() <= 1 ) return;
+        if ( members == null || members.size() <= 1 ) {
+            return;
+        }
         members.sort(comp);
     }
 
@@ -69,8 +73,12 @@ public class AbsoluteOrder {
         @Override
         public int compare(Member m1, Member m2) {
             int result = compareIps(m1,m2);
-            if ( result == 0 ) result = comparePorts(m1,m2);
-            if ( result == 0 ) result = compareIds(m1,m2);
+            if ( result == 0 ) {
+                result = comparePorts(m1,m2);
+            }
+            if ( result == 0 ) {
+                result = compareIds(m1,m2);
+            }
             return result;
         }
 

==================================================
ChannelInterceptorBase.java
index 3edcecf22b..4f5826114a 100644
--- a/java/org/apache/catalina/tribes/group/ChannelCoordinator.java
+++ b/java/org/apache/catalina/tribes/group/ChannelCoordinator.java
@@ -74,7 +74,9 @@ public class ChannelCoordinator extends ChannelInterceptorBase implements Messag
     @Override
     public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload)
             throws ChannelException {
-        if ( destination == null ) destination = membershipService.getMembers();
+        if ( destination == null ) {
+            destination = membershipService.getMembers();
+        }
         if ((msg.getOptions()&Channel.SEND_OPTIONS_MULTICAST) == Channel.SEND_OPTIONS_MULTICAST) {
             membershipService.broadcast(msg);
         } else {
@@ -138,8 +140,14 @@ public class ChannelCoordinator extends ChannelInterceptorBase implements Messag
             //make sure we don't pass down any flags that are unrelated to the bottom layer
             svc = svc & Channel.DEFAULT;
 
-            if (startLevel == Channel.DEFAULT) return; //we have already started up all components
-            if (svc == 0 ) return;//nothing to start
+            if (startLevel == Channel.DEFAULT)
+             {
+                return; //we have already started up all components
+            }
+            if (svc == 0 )
+             {
+                return;//nothing to start
+            }
 
             if (svc == (svc & startLevel)) {
                 throw new ChannelException(sm.getString("channelCoordinator.alreadyStarted",
@@ -217,8 +225,14 @@ public class ChannelCoordinator extends ChannelInterceptorBase implements Messag
             //make sure we don't pass down any flags that are unrelated to the bottom layer
             svc = svc & Channel.DEFAULT;
 
-            if (startLevel == 0) return; //we have already stopped up all components
-            if (svc == 0 ) return;//nothing to stop
+            if (startLevel == 0)
+             {
+                return; //we have already stopped up all components
+            }
+            if (svc == 0 )
+             {
+                return;//nothing to stop
+            }
 
             boolean valid = false;
             if ( Channel.MBR_TX_SEQ==(svc & Channel.MBR_TX_SEQ) ) {
@@ -296,7 +310,9 @@ public class ChannelCoordinator extends ChannelInterceptorBase implements Messag
             this.clusterReceiver = clusterReceiver;
             this.clusterReceiver.setMessageListener(this);
         } else {
-            if  (this.clusterReceiver!=null ) this.clusterReceiver.setMessageListener(null);
+            if  (this.clusterReceiver!=null ) {
+                this.clusterReceiver.setMessageListener(null);
+            }
             this.clusterReceiver = null;
         }
     }
@@ -312,7 +328,9 @@ public class ChannelCoordinator extends ChannelInterceptorBase implements Messag
 
     @Override
     public void heartbeat() {
-        if ( clusterSender!=null ) clusterSender.heartbeat();
+        if ( clusterSender!=null ) {
+            clusterSender.heartbeat();
+        }
         super.heartbeat();
     }
 

==================================================
GroupChannel.java
index 17ce382d59..9e0519cab6 100644
--- a/java/org/apache/catalina/tribes/group/ChannelInterceptorBase.java
+++ b/java/org/apache/catalina/tribes/group/ChannelInterceptorBase.java
@@ -46,7 +46,9 @@ public abstract class ChannelInterceptorBase implements ChannelInterceptor {
     }
 
     public boolean okToProcess(int messageFlags) {
-        if (this.optionFlag == 0 ) return true;
+        if (this.optionFlag == 0 ) {
+            return true;
+        }
         return ((optionFlag&messageFlags) == optionFlag);
     }
 
@@ -83,29 +85,39 @@ public abstract class ChannelInterceptorBase implements ChannelInterceptor {
     @Override
     public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws
         ChannelException {
-        if (getNext() != null) getNext().sendMessage(destination, msg, payload);
+        if (getNext() != null) {
+            getNext().sendMessage(destination, msg, payload);
+        }
     }
 
     @Override
     public void messageReceived(ChannelMessage msg) {
-        if (getPrevious() != null) getPrevious().messageReceived(msg);
+        if (getPrevious() != null) {
+            getPrevious().messageReceived(msg);
+        }
     }
 
     @Override
     public void memberAdded(Member member) {
         //notify upwards
-        if (getPrevious() != null) getPrevious().memberAdded(member);
+        if (getPrevious() != null) {
+            getPrevious().memberAdded(member);
+        }
     }
 
     @Override
     public void memberDisappeared(Member member) {
         //notify upwards
-        if (getPrevious() != null) getPrevious().memberDisappeared(member);
+        if (getPrevious() != null) {
+            getPrevious().memberDisappeared(member);
+        }
     }
 
     @Override
     public void heartbeat() {
-        if (getNext() != null) getNext().heartbeat();
+        if (getNext() != null) {
+            getNext().heartbeat();
+        }
     }
 
     /**
@@ -113,8 +125,11 @@ public abstract class ChannelInterceptorBase implements ChannelInterceptor {
      */
     @Override
     public boolean hasMembers() {
-        if ( getNext()!=null )return getNext().hasMembers();
-        else return false;
+        if ( getNext()!=null ) {
+            return getNext().hasMembers();
+        } else {
+            return false;
+        }
     }
 
     /**
@@ -123,8 +138,11 @@ public abstract class ChannelInterceptorBase implements ChannelInterceptor {
      */
     @Override
     public Member[] getMembers() {
-        if ( getNext()!=null ) return getNext().getMembers();
-        else return null;
+        if ( getNext()!=null ) {
+            return getNext().getMembers();
+        } else {
+            return null;
+        }
     }
 
     /**
@@ -134,8 +152,11 @@ public abstract class ChannelInterceptorBase implements ChannelInterceptor {
      */
     @Override
     public Member getMember(Member mbr) {
-        if ( getNext()!=null) return getNext().getMember(mbr);
-        else return null;
+        if ( getNext()!=null) {
+            return getNext().getMember(mbr);
+        } else {
+            return null;
+        }
     }
 
     /**
@@ -145,8 +166,11 @@ public abstract class ChannelInterceptorBase implements ChannelInterceptor {
      */
     @Override
     public Member getLocalMember(boolean incAlive) {
-        if ( getNext()!=null ) return getNext().getLocalMember(incAlive);
-        else return null;
+        if ( getNext()!=null ) {
+            return getNext().getLocalMember(incAlive);
+        } else {
+            return null;
+        }
     }
 
     /**
@@ -162,11 +186,15 @@ public abstract class ChannelInterceptorBase implements ChannelInterceptor {
      */
     @Override
     public void start(int svc) throws ChannelException {
-        if ( getNext()!=null ) getNext().start(svc);
+        if ( getNext()!=null ) {
+            getNext().start(svc);
+        }
         // register jmx
         JmxRegistry jmxRegistry = JmxRegistry.getRegistry(channel);
-        if (jmxRegistry != null) this.oname = jmxRegistry.registerJmx(
-                ",component=Interceptor,interceptorName=" + getClass().getSimpleName(), this);
+        if (jmxRegistry != null) {
+            this.oname = jmxRegistry.registerJmx(
+                    ",component=Interceptor,interceptorName=" + getClass().getSimpleName(), this);
+        }
     }
 
     /**
@@ -182,7 +210,9 @@ public abstract class ChannelInterceptorBase implements ChannelInterceptor {
      */
     @Override
     public void stop(int svc) throws ChannelException {
-        if (getNext() != null) getNext().stop(svc);
+        if (getNext() != null) {
+            getNext().stop(svc);
+        }
         if (oname != null) {
             JmxRegistry.getRegistry(channel).unregisterJmx(oname);
             oname = null;

==================================================
RpcChannel.java
index abd9303db1..bf1e1e4727 100644
--- a/java/org/apache/catalina/tribes/group/GroupChannel.java
+++ b/java/org/apache/catalina/tribes/group/GroupChannel.java
@@ -201,11 +201,15 @@ public class GroupChannel extends ChannelInterceptorBase
         super.heartbeat();
 
         for (MembershipListener listener : membershipListeners) {
-            if ( listener instanceof Heartbeat ) ((Heartbeat)listener).heartbeat();
+            if ( listener instanceof Heartbeat ) {
+                ((Heartbeat)listener).heartbeat();
+            }
         }
 
         for (ChannelListener listener : channelListeners) {
-            if ( listener instanceof Heartbeat ) ((Heartbeat)listener).heartbeat();
+            if ( listener instanceof Heartbeat ) {
+                ((Heartbeat)listener).heartbeat();
+            }
         }
     }
 
@@ -244,7 +248,9 @@ public class GroupChannel extends ChannelInterceptorBase
     @Override
     public UniqueId send(Member[] destination, Serializable msg, int options, ErrorHandler handler)
             throws ChannelException {
-        if ( msg == null ) throw new ChannelException(sm.getString("groupChannel.nullMessage"));
+        if ( msg == null ) {
+            throw new ChannelException(sm.getString("groupChannel.nullMessage"));
+        }
         XByteBuffer buffer = null;
         try {
             if (destination == null || destination.length == 0) {
@@ -284,7 +290,9 @@ public class GroupChannel extends ChannelInterceptorBase
         } catch (RuntimeException | IOException e) {
             throw new ChannelException(e);
         } finally {
-            if ( buffer != null ) BufferPool.getBufferPool().returnBuffer(buffer);
+            if ( buffer != null ) {
+                BufferPool.getBufferPool().returnBuffer(buffer);
+            }
         }
     }
 
@@ -300,7 +308,9 @@ public class GroupChannel extends ChannelInterceptorBase
      */
     @Override
     public void messageReceived(ChannelMessage msg) {
-        if ( msg == null ) return;
+        if ( msg == null ) {
+            return;
+        }
         try {
             if ( Logs.MESSAGES.isTraceEnabled() ) {
                 Logs.MESSAGES.trace("GroupChannel - Received msg:" +
@@ -336,7 +346,9 @@ public class GroupChannel extends ChannelInterceptorBase
                     delivered = true;
                     //if the message was accepted by an RPC channel, that channel
                     //is responsible for returning the reply, otherwise we send an absence reply
-                    if (channelListener instanceof RpcChannel) rx = true;
+                    if (channelListener instanceof RpcChannel) {
+                        rx = true;
+                    }
                 }
             }//for
             if ((!rx) && (fwd instanceof RpcMessage)) {
@@ -352,7 +364,9 @@ public class GroupChannel extends ChannelInterceptorBase
         } catch ( Exception x ) {
             //this could be the channel listener throwing an exception, we should log it
             //as a warning.
-            if ( log.isWarnEnabled() ) log.warn(sm.getString("groupChannel.receiving.error"),x);
+            if ( log.isWarnEnabled() ) {
+                log.warn(sm.getString("groupChannel.receiving.error"),x);
+            }
             throw new RemoteProcessException(sm.getString("groupChannel.receiving.error"),x);
         }
     }
@@ -367,7 +381,9 @@ public class GroupChannel extends ChannelInterceptorBase
     protected void sendNoRpcChannelReply(RpcMessage msg, Member destination) {
         try {
             //avoid circular loop
-            if ( msg instanceof RpcMessage.NoRpcChannelReply) return;
+            if ( msg instanceof RpcMessage.NoRpcChannelReply) {
+                return;
+            }
             RpcMessage.NoRpcChannelReply reply =
                     new RpcMessage.NoRpcChannelReply(msg.rpcId, msg.uuid);
             send(new Member[]{destination},reply,Channel.SEND_OPTIONS_ASYNCHRONOUS);
@@ -385,7 +401,9 @@ public class GroupChannel extends ChannelInterceptorBase
     public void memberAdded(Member member) {
         //notify upwards
         for (MembershipListener membershipListener : membershipListeners) {
-            if (membershipListener != null) membershipListener.memberAdded(member);
+            if (membershipListener != null) {
+                membershipListener.memberAdded(member);
+            }
         }
     }
 
@@ -398,7 +416,9 @@ public class GroupChannel extends ChannelInterceptorBase
     public void memberDisappeared(Member member) {
         //notify upwards
         for (MembershipListener membershipListener : membershipListeners) {
-            if (membershipListener != null) membershipListener.memberDisappeared(member);
+            if (membershipListener != null) {
+                membershipListener.memberDisappeared(member);
+            }
         }
     }
 
@@ -450,8 +470,10 @@ public class GroupChannel extends ChannelInterceptorBase
             }//end if
             first = first.getNext();
         }//while
-        if ( conflicts.length() > 0 ) throw new ChannelException(sm.getString("groupChannel.optionFlag.conflict",
-                conflicts.toString()));
+        if ( conflicts.length() > 0 ) {
+            throw new ChannelException(sm.getString("groupChannel.optionFlag.conflict",
+                    conflicts.toString()));
+        }
 
     }
 
@@ -466,10 +488,14 @@ public class GroupChannel extends ChannelInterceptorBase
     @Override
     public synchronized void start(int svc) throws ChannelException {
         setupDefaultStack();
-        if (optionCheck) checkOptionFlags();
+        if (optionCheck) {
+            checkOptionFlags();
+        }
         // register jmx
         JmxRegistry jmxRegistry = JmxRegistry.getRegistry(this);
-        if (jmxRegistry != null) this.oname = jmxRegistry.registerJmx(",component=Channel", this);
+        if (jmxRegistry != null) {
+            this.oname = jmxRegistry.registerJmx(",component=Channel", this);
+        }
         if (utilityExecutor == null) {
             log.warn(sm.getString("groupChannel.warn.noUtilityExecutor"));
             utilityExecutor = new ScheduledThreadPoolExecutor(1);
@@ -527,8 +553,11 @@ public class GroupChannel extends ChannelInterceptorBase
      * @return ChannelInterceptor
      */
     public ChannelInterceptor getFirstInterceptor() {
-        if (interceptors != null) return interceptors;
-        else return coordinator;
+        if (interceptors != null) {
+            return interceptors;
+        } else {
+            return coordinator;
+        }
     }
 
     @Override
@@ -602,8 +631,9 @@ public class GroupChannel extends ChannelInterceptorBase
      */
     @Override
     public void addMembershipListener(MembershipListener membershipListener) {
-        if (!this.membershipListeners.contains(membershipListener) )
+        if (!this.membershipListeners.contains(membershipListener) ) {
             this.membershipListeners.add(membershipListener);
+        }
     }
 
     /**

==================================================
DomainFilterInterceptor.java
index 5af81d07c4..ab2d45e941 100644
--- a/java/org/apache/catalina/tribes/group/RpcChannel.java
+++ b/java/org/apache/catalina/tribes/group/RpcChannel.java
@@ -83,7 +83,9 @@ public class RpcChannel implements ChannelListener {
                            int channelOptions,
                            long timeout) throws ChannelException {
 
-        if ( destination==null || destination.length == 0 ) return new Response[0];
+        if ( destination==null || destination.length == 0 ) {
+            return new Response[0];
+        }
 
         //avoid dead lock
         int sendOptions =
@@ -93,10 +95,14 @@ public class RpcChannel implements ChannelListener {
         RpcCollector collector = new RpcCollector(key,rpcOptions,destination.length);
         try {
             synchronized (collector) {
-                if ( rpcOptions != NO_REPLY ) responseMap.put(key, collector);
+                if ( rpcOptions != NO_REPLY ) {
+                    responseMap.put(key, collector);
+                }
                 RpcMessage rmsg = new RpcMessage(rpcId, key.id, message);
                 channel.send(destination, rmsg, sendOptions);
-                if ( rpcOptions != NO_REPLY ) collector.wait(timeout);
+                if ( rpcOptions != NO_REPLY ) {
+                    collector.wait(timeout);
+                }
             }
         } catch ( InterruptedException ix ) {
             Thread.currentThread().interrupt();
@@ -113,20 +119,25 @@ public class RpcChannel implements ChannelListener {
         if ( rmsg.reply ) {
             RpcCollector collector = responseMap.get(key);
             if (collector == null) {
-                if (!(rmsg instanceof RpcMessage.NoRpcChannelReply))
+                if (!(rmsg instanceof RpcMessage.NoRpcChannelReply)) {
                     callback.leftOver(rmsg.message, sender);
+                }
             } else {
                 synchronized (collector) {
                     //make sure it hasn't been removed
                     if ( responseMap.containsKey(key) ) {
-                        if ( (rmsg instanceof RpcMessage.NoRpcChannelReply) )
+                        if ( (rmsg instanceof RpcMessage.NoRpcChannelReply) ) {
                             collector.destcnt--;
-                        else
+                        } else {
                             collector.addResponse(rmsg.message, sender);
-                        if (collector.isComplete()) collector.notifyAll();
+                        }
+                        if (collector.isComplete()) {
+                            collector.notifyAll();
+                        }
                     } else {
-                        if (! (rmsg instanceof RpcMessage.NoRpcChannelReply) )
+                        if (! (rmsg instanceof RpcMessage.NoRpcChannelReply) ) {
                             callback.leftOver(rmsg.message, sender);
+                        }
                     }
                 }//synchronized
             }//end if
@@ -188,7 +199,9 @@ public class RpcChannel implements ChannelListener {
         if ( msg instanceof RpcMessage ) {
             RpcMessage rmsg = (RpcMessage)msg;
             return Arrays.equals(rmsg.rpcId,rpcId);
-        } else return false;
+        } else {
+            return false;
+        }
     }
 
     public Channel getChannel() {
@@ -246,7 +259,9 @@ public class RpcChannel implements ChannelListener {
         }
 
         public boolean isComplete() {
-            if ( destcnt <= 0 ) return true;
+            if ( destcnt <= 0 ) {
+                return true;
+            }
             switch (options) {
                 case ALL_REPLY:
                     return destcnt == responses.size();
@@ -270,7 +285,9 @@ public class RpcChannel implements ChannelListener {
             if ( o instanceof RpcCollector ) {
                 RpcCollector r = (RpcCollector)o;
                 return r.key.equals(this.key);
-            } else return false;
+            } else {
+                return false;
+            }
         }
 
         public Response[] getResponses() {
@@ -294,7 +311,9 @@ public class RpcChannel implements ChannelListener {
             if ( o instanceof RpcCollectorKey ) {
                 RpcCollectorKey r = (RpcCollectorKey)o;
                 return Arrays.equals(id,r.id);
-            } else return false;
+            } else {
+                return false;
+            }
         }
 
     }

==================================================
EncryptInterceptor.java
index 0b9a3c588a..37bf826882 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/DomainFilterInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/DomainFilterInterceptor.java
@@ -53,8 +53,9 @@ public class DomainFilterInterceptor extends ChannelInterceptorBase
         } else {
             if (logCounter.incrementAndGet() >= logInterval) {
                 logCounter.set(0);
-                if (log.isWarnEnabled())
+                if (log.isWarnEnabled()) {
                     log.warn(sm.getString("domainFilterInterceptor.message.refused", msg.getAddress()));
+                }
             }
         }
     }//messageReceived
@@ -62,45 +63,63 @@ public class DomainFilterInterceptor extends ChannelInterceptorBase
 
     @Override
     public void memberAdded(Member member) {
-        if ( membership == null ) setupMembership();
+        if ( membership == null ) {
+            setupMembership();
+        }
         boolean notify = false;
         synchronized (membership) {
             notify = Arrays.equals(domain,member.getDomain());
-            if ( notify ) notify = membership.memberAlive(member);
+            if ( notify ) {
+                notify = membership.memberAlive(member);
+            }
         }
         if ( notify ) {
             super.memberAdded(member);
         } else {
-            if(log.isInfoEnabled()) log.info(sm.getString("domainFilterInterceptor.member.refused", member));
+            if(log.isInfoEnabled()) {
+                log.info(sm.getString("domainFilterInterceptor.member.refused", member));
+            }
         }
     }
 
     @Override
     public void memberDisappeared(Member member) {
-        if ( membership == null ) setupMembership();
+        if ( membership == null ) {
+            setupMembership();
+        }
         boolean notify = false;
         synchronized (membership) {
             notify = Arrays.equals(domain,member.getDomain());
-            if ( notify ) membership.removeMember(member);
+            if ( notify ) {
+                membership.removeMember(member);
+            }
+        }
+        if ( notify ) {
+            super.memberDisappeared(member);
         }
-        if ( notify ) super.memberDisappeared(member);
     }
 
     @Override
     public boolean hasMembers() {
-        if ( membership == null ) setupMembership();
+        if ( membership == null ) {
+            setupMembership();
+        }
         return membership.hasMembers();
     }
 
     @Override
     public Member[] getMembers() {
-        if ( membership == null ) setupMembership();
+        if ( membership == null ) {
+            setupMembership();
+        }
         return membership.getMembers();
     }
 
     @Override
     public Member getMember(Member mbr) {
-        if ( membership == null ) setupMembership();
+        if ( membership == null ) {
+            setupMembership();
+        }
         return membership.getMember(mbr);
     }
 
@@ -127,11 +146,14 @@ public class DomainFilterInterceptor extends ChannelInterceptorBase
     }
 
     public void setDomain(String domain) {
-        if ( domain == null ) return;
-        if (domain.startsWith("{"))
+        if ( domain == null ) {
+            return;
+        }
+        if (domain.startsWith("{")) {
             setDomain(org.apache.catalina.tribes.util.Arrays.fromString(domain));
-        else
+        } else {
             setDomain(org.apache.catalina.tribes.util.Arrays.convert(domain));
+        }
     }
 
     @Override

==================================================
FragmentationInterceptor.java
index d98b5d8116..e2a48f7429 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/EncryptInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/EncryptInterceptor.java
@@ -91,8 +91,9 @@ public class EncryptInterceptor extends ChannelInterceptorBase implements Encryp
     private void validateChannelChain() throws ChannelException {
         ChannelInterceptor interceptor = getPrevious();
         while(null != interceptor) {
-            if(interceptor instanceof TcpFailureDetector)
+            if(interceptor instanceof TcpFailureDetector) {
                 throw new ChannelConfigException(sm.getString("encryptInterceptor.tcpFailureDetector.ordering"));
+            }
 
             interceptor = interceptor.getPrevious();
         }
@@ -163,15 +164,18 @@ public class EncryptInterceptor extends ChannelInterceptorBase implements Encryp
      */
     @Override
     public void setEncryptionAlgorithm(String algorithm) {
-        if(null == getEncryptionAlgorithm())
+        if(null == getEncryptionAlgorithm()) {
             throw new IllegalStateException(sm.getString("encryptInterceptor.algorithm.required"));
+        }
 
         int pos = algorithm.indexOf('/');
-        if(pos < 0)
+        if(pos < 0) {
             throw new IllegalArgumentException(sm.getString("encryptInterceptor.algorithm.required"));
+        }
         pos = algorithm.indexOf('/', pos + 1);
-        if(pos < 0)
+        if(pos < 0) {
             throw new IllegalArgumentException(sm.getString("encryptInterceptor.algorithm.required"));
+        }
 
         encryptionAlgorithm = algorithm;
     }
@@ -228,8 +232,9 @@ public class EncryptInterceptor extends ChannelInterceptorBase implements Encryp
     public byte[] getEncryptionKey() {
         byte[] key = getEncryptionKeyInternal();
 
-        if(null != key)
+        if(null != key) {
             key = key.clone();
+        }
 
         return key;
     }
@@ -317,8 +322,9 @@ public class EncryptInterceptor extends ChannelInterceptorBase implements Encryp
     private static BaseEncryptionManager createEncryptionManager(String algorithm,
             byte[] encryptionKey, String providerName)
         throws NoSuchAlgorithmException, NoSuchPaddingException, NoSuchProviderException {
-        if(null == encryptionKey)
+        if(null == encryptionKey) {
             throw new IllegalStateException(sm.getString("encryptInterceptor.key.required"));
+        }
 
         String algorithmName;
         String algorithmMode;
@@ -341,16 +347,17 @@ public class EncryptInterceptor extends ChannelInterceptorBase implements Encryp
             algorithmMode = "CBC";
         }
 
-        if("GCM".equalsIgnoreCase(algorithmMode))
+        if("GCM".equalsIgnoreCase(algorithmMode)) {
             return new GCMEncryptionManager(algorithm, new SecretKeySpec(encryptionKey, algorithmName), providerName);
-        else if("CBC".equalsIgnoreCase(algorithmMode)
+        } else if("CBC".equalsIgnoreCase(algorithmMode)
                 || "OFB".equalsIgnoreCase(algorithmMode)
-                || "CFB".equalsIgnoreCase(algorithmMode))
+                || "CFB".equalsIgnoreCase(algorithmMode)) {
             return new BaseEncryptionManager(algorithm,
                     new SecretKeySpec(encryptionKey, algorithmName),
                     providerName);
-        else
+        } else {
             throw new IllegalArgumentException(sm.getString("encryptInterceptor.algorithm.unsupported-mode", algorithmMode));
+        }
     }
 
     private static class BaseEncryptionManager {
@@ -502,8 +509,9 @@ public class EncryptInterceptor extends ChannelInterceptorBase implements Encryp
 
                 return data;
             } finally {
-                if(null != cipher)
+                if(null != cipher) {
                     returnCipher(cipher);
+                }
             }
         }
 
@@ -530,8 +538,9 @@ public class EncryptInterceptor extends ChannelInterceptorBase implements Encryp
                 // Decrypt remainder of the message.
                 return cipher.doFinal(bytes, ivSize, bytes.length - ivSize);
             } finally {
-                if(null != cipher)
+                if(null != cipher) {
                     returnCipher(cipher);
+                }
             }
         }
 
@@ -550,8 +559,9 @@ public class EncryptInterceptor extends ChannelInterceptorBase implements Encryp
 
                 return ivBytes;
             } finally {
-                if(null != random)
+                if(null != random) {
                     returnRandom(random);
+                }
             }
         }
 

==================================================
MessageDispatchInterceptor.java
index 872f66a7e2..f4be81b4dd 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/FragmentationInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/FragmentationInterceptor.java
@@ -146,8 +146,9 @@ public class FragmentationInterceptor extends ChannelInterceptorBase implements
             Object[] keys = set.toArray();
             for (Object o : keys) {
                 FragKey key = (FragKey) o;
-                if (key != null && key.expired(getExpire()))
+                if (key != null && key.expired(getExpire())) {
                     removeFragCollection(key);
+                }
             }
         }catch ( Exception x ) {
             if ( log.isErrorEnabled() ) {
@@ -201,12 +202,16 @@ public class FragmentationInterceptor extends ChannelInterceptorBase implements
 
         public boolean complete() {
             boolean result = true;
-            for ( int i=0; (i<frags.length) && (result); i++ ) result = (frags[i] != null);
+            for ( int i=0; (i<frags.length) && (result); i++ ) {
+                result = (frags[i] != null);
+            }
             return result;
         }
 
         public ChannelMessage assemble() {
-            if ( !complete() ) throw new IllegalStateException(sm.getString("fragmentationInterceptor.fragments.missing"));
+            if ( !complete() ) {
+                throw new IllegalStateException(sm.getString("fragmentationInterceptor.fragments.missing"));
+            }
             int buffersize = 0;
             for (XByteBuffer frag : frags) {
                 buffersize += frag.getLength();
@@ -239,7 +244,9 @@ public class FragmentationInterceptor extends ChannelInterceptorBase implements
         public boolean equals(Object o ) {
             if ( o instanceof FragKey ) {
             return Arrays.equals(uniqueId,((FragKey)o).uniqueId);
-        } else return false;
+        } else {
+                return false;
+            }
 
         }
 

==================================================
NonBlockingCoordinator.java
index 18b97758e7..33113f62b0 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/MessageDispatchInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/MessageDispatchInterceptor.java
@@ -107,7 +107,9 @@ public class MessageDispatchInterceptor extends ChannelInterceptorBase
             return;
         }
         String channelName = "";
-        if (getChannel().getName() != null) channelName = "[" + getChannel().getName() + "]";
+        if (getChannel().getName() != null) {
+            channelName = "[" + getChannel().getName() + "]";
+        }
         executor = ExecutorFactory.newThreadPool(maxSpareThreads, maxThreads, keepAliveTime,
                 TimeUnit.MILLISECONDS,
                 new TcclThreadFactory("MessageDispatchInterceptor.MessageDispatchThread" + channelName));

==================================================
OrderInterceptor.java
index 71db650948..37937b79c8 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java
@@ -276,7 +276,9 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
             }catch ( ChannelException x  ) {
                 log.warn(sm.getString("nonBlockingCoordinator.electionMessage.sendfailed", msg.getMembers()[current]));
                 current = Arrays.nextIndex(msg.getMembers()[current],msg.getMembers());
-                if ( current == next ) throw x;
+                if ( current == next ) {
+                    throw x;
+                }
             }
         }
     }
@@ -297,7 +299,9 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
 
     protected boolean memberAlive(Member mbr, long conTimeout) {
         //could be a shutdown notification
-        if ( Arrays.equals(mbr.getCommand(),Member.SHUTDOWN_PAYLOAD) ) return false;
+        if ( Arrays.equals(mbr.getCommand(),Member.SHUTDOWN_PAYLOAD) ) {
+            return false;
+        }
 
         try (Socket socket = new Socket()) {
             InetAddress ia = InetAddress.getByAddress(mbr.getHost());
@@ -320,8 +324,11 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
         Arrays.fill(merged,getMembers());
         Member[] diff = Arrays.diff(merged,membership,local);
         for (Member member : diff) {
-            if (!alive(member)) merged.removeMember(member);
-            else memberAdded(member, false);
+            if (!alive(member)) {
+                merged.removeMember(member);
+            } else {
+                memberAdded(member, false);
+            }
         }
         fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_POST_MERGE,this,"Post merge"));
         return merged;
@@ -333,8 +340,11 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
             synchronized (electionMutex) { electionMutex.notifyAll();}
         }
         Membership merged = mergeOnArrive(msg);
-        if (isViewConf(msg)) handleViewConf(msg, merged);
-        else handleToken(msg, merged);
+        if (isViewConf(msg)) {
+            handleViewConf(msg, merged);
+        } else {
+            handleToken(msg, merged);
+        }
     }
 
     protected void handleToken(CoordinationMessage msg, Membership merged) throws ChannelException {
@@ -382,7 +392,10 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
     }
 
     protected void handleViewConf(CoordinationMessage msg, Membership merged) throws ChannelException {
-        if ( viewId != null && msg.getId().equals(viewId) ) return;//we already have this view
+        if ( viewId != null && msg.getId().equals(viewId) )
+         {
+            return;//we already have this view
+        }
         view = new Membership(getLocalMember(false),AbsoluteOrder.comp,true);
         Arrays.fill(view,msg.getMembers());
         viewId = msg.getId();
@@ -409,8 +422,12 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
     }
 
     protected boolean hasHigherPriority(Member[] complete, Member[] local) {
-        if ( local == null || local.length == 0 ) return false;
-        if ( complete == null || complete.length == 0 ) return true;
+        if ( local == null || local.length == 0 ) {
+            return false;
+        }
+        if ( complete == null || complete.length == 0 ) {
+            return true;
+        }
         AbsoluteOrder.absoluteOrder(complete);
         AbsoluteOrder.absoluteOrder(local);
         return (AbsoluteOrder.comp.compare(complete[0],local[0]) > 0);
@@ -461,12 +478,18 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
 //============================================================================================================
     @Override
     public void start(int svc) throws ChannelException {
-            if (membership == null) setupMembership();
-            if (started)return;
+            if (membership == null) {
+                setupMembership();
+            }
+            if (started) {
+                return;
+            }
             fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_START, this, "Before start"));
             super.start(startsvc);
             started = true;
-            if (view == null) view = new Membership(super.getLocalMember(true), AbsoluteOrder.comp, true);
+            if (view == null) {
+                view = new Membership(super.getLocalMember(true), AbsoluteOrder.comp, true);
+            }
             fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_START, this, "After start"));
             startElection(false);
     }
@@ -476,7 +499,9 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
         try {
             halt();
             synchronized (electionMutex) {
-                if (!started)return;
+                if (!started) {
+                    return;
+                }
                 started = false;
                 fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_STOP, this, "Before stop"));
                 super.stop(startsvc);
@@ -525,11 +550,17 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
     }
 
     public void memberAdded(Member member,boolean elect) {
-        if (membership == null) setupMembership();
-        if (membership.memberAlive(member)) super.memberAdded(member);
+        if (membership == null) {
+            setupMembership();
+        }
+        if (membership.memberAlive(member)) {
+            super.memberAdded(member);
+        }
         try {
             fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_MBR_ADD,this,"Member add("+member.getName()+")"));
-            if (started && elect) startElection(false);
+            if (started && elect) {
+                startElection(false);
+            }
         } catch (ChannelException x) {
             log.error(sm.getString("nonBlockingCoordinator.memberAdded.failed"),x);
         }
@@ -542,7 +573,9 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
         try {
             fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_MBR_DEL,this,"Member remove("+member.getName()+")"));
             if (started && (isCoordinator() || isHighest()))
+             {
                 startElection(true); //to do, if a member disappears, only the coordinator can start
+            }
         } catch (ChannelException x) {
             log.error(sm.getString("nonBlockingCoordinator.memberDisappeared.failed"),x);
         }
@@ -550,8 +583,11 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
 
     public boolean isHighest() {
         Member local = getLocalMember(false);
-        if ( membership.getMembers().length == 0 ) return true;
-        else return AbsoluteOrder.comp.compare(local,membership.getMembers()[0])<=0;
+        if ( membership.getMembers().length == 0 ) {
+            return true;
+        } else {
+            return AbsoluteOrder.comp.compare(local,membership.getMembers()[0])<=0;
+        }
     }
 
     public boolean isCoordinator() {
@@ -615,7 +651,9 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
     @Override
     public Member getLocalMember(boolean incAlive) {
         Member local = super.getLocalMember(incAlive);
-        if ( view == null && (local != null)) setupMembership();
+        if ( view == null && (local != null)) {
+            setupMembership();
+        }
         return local;
     }
 
@@ -665,27 +703,37 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
         }
 
         public Member getLeader() {
-            if ( leader == null ) parse();
+            if ( leader == null ) {
+                parse();
+            }
             return leader;
         }
 
         public Member getSource() {
-            if ( source == null ) parse();
+            if ( source == null ) {
+                parse();
+            }
             return source;
         }
 
         public UniqueId getId() {
-            if ( id == null ) parse();
+            if ( id == null ) {
+                parse();
+            }
             return id;
         }
 
         public Member[] getMembers() {
-            if ( view == null ) parse();
+            if ( view == null ) {
+                parse();
+            }
             return view;
         }
 
         public byte[] getType() {
-            if (type == null ) parse();
+            if (type == null ) {
+                parse();
+            }
             return type;
         }
 

==================================================
StaticMembershipInterceptor.java
index 89efe71645..6887113492 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/OrderInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/OrderInterceptor.java
@@ -90,11 +90,15 @@ public class OrderInterceptor extends ChannelInterceptorBase {
                     msg.getMessage().trim(4);
                 }
             } catch (ChannelException x) {
-                if (cx == null) cx = x;
+                if (cx == null) {
+                    cx = x;
+                }
                 cx.addFaultyMember(x.getFaultyMembers());
             }
         }//for
-        if ( cx != null ) throw cx;
+        if ( cx != null ) {
+            throw cx;
+        }
     }
 
     @Override
@@ -108,7 +112,9 @@ public class OrderInterceptor extends ChannelInterceptorBase {
         MessageOrder order = new MessageOrder(msgnr,(ChannelMessage)msg.deepclone());
         inLock.writeLock().lock();
         try {
-            if ( processIncoming(order) ) processLeftOvers(msg.getAddress(),false);
+            if ( processIncoming(order) ) {
+                processLeftOvers(msg.getAddress(),false);
+            }
         } finally {
             inLock.writeLock().unlock();
         }
@@ -119,7 +125,9 @@ public class OrderInterceptor extends ChannelInterceptorBase {
             Counter cnt = getInCounter(member);
             cnt.setCounter(Integer.MAX_VALUE);
         }
-        if ( tmp!= null ) processIncoming(tmp);
+        if ( tmp!= null ) {
+            processIncoming(tmp);
+        }
     }
     /**
      *
@@ -139,8 +147,11 @@ public class OrderInterceptor extends ChannelInterceptorBase {
 
         while ( (order!=null) && (order.getMsgNr() <= cnt.getCounter())  ) {
             //we are right on target. process orders
-            if ( order.getMsgNr() == cnt.getCounter() ) cnt.inc();
-            else if ( order.getMsgNr() > cnt.getCounter() ) cnt.setCounter(order.getMsgNr());
+            if ( order.getMsgNr() == cnt.getCounter() ) {
+                cnt.inc();
+            } else if ( order.getMsgNr() > cnt.getCounter() ) {
+                cnt.setCounter(order.getMsgNr());
+            }
             super.messageReceived(order.getMessage());
             order.setMessage(null);
             order = order.next;
@@ -154,21 +165,29 @@ public class OrderInterceptor extends ChannelInterceptorBase {
             //process expired messages or empty out the queue
             if ( tmp.isExpired(expire) || empty ) {
                 //reset the head
-                if ( tmp == head ) head = tmp.next;
+                if ( tmp == head ) {
+                    head = tmp.next;
+                }
                 cnt.setCounter(tmp.getMsgNr()+1);
-                if ( getForwardExpired() )
+                if ( getForwardExpired() ) {
                     super.messageReceived(tmp.getMessage());
+                }
                 tmp.setMessage(null);
                 tmp = tmp.next;
-                if ( prev != null ) prev.next = tmp;
+                if ( prev != null ) {
+                    prev.next = tmp;
+                }
                 result = true;
             } else {
                 prev = tmp;
                 tmp = tmp.next;
             }
         }
-        if ( head == null ) incoming.remove(member);
-        else incoming.put(member, head);
+        if ( head == null ) {
+            incoming.remove(member);
+        } else {
+            incoming.put(member, head);
+        }
         return result;
     }
 
@@ -270,9 +289,15 @@ public class OrderInterceptor extends ChannelInterceptorBase {
 
         @SuppressWarnings("null") // prev cannot be null
         public static MessageOrder add(MessageOrder head, MessageOrder add) {
-            if ( head == null ) return add;
-            if ( add == null ) return head;
-            if ( head == add ) return add;
+            if ( head == null ) {
+                return add;
+            }
+            if ( add == null ) {
+                return head;
+            }
+            if ( head == add ) {
+                return add;
+            }
 
             if ( head.getMsgNr() > add.getMsgNr() ) {
                 add.next = head;

==================================================
TcpFailureDetector.java
index c7c70c8135..4c4477db67 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/StaticMembershipInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/StaticMembershipInterceptor.java
@@ -57,13 +57,17 @@ public class StaticMembershipInterceptor extends ChannelInterceptorBase
 
     public void addStaticMember(Member member) {
         synchronized (members) {
-            if (!members.contains(member)) members.add(member);
+            if (!members.contains(member)) {
+                members.add(member);
+            }
         }
     }
 
     public void removeStaticMember(Member member) {
         synchronized (members) {
-            if (members.contains(member)) members.remove(member);
+            if (members.contains(member)) {
+                members.remove(member);
+            }
         }
     }
 
@@ -112,13 +116,18 @@ public class StaticMembershipInterceptor extends ChannelInterceptorBase
      */
     @Override
     public Member[] getMembers() {
-        if ( members.size() == 0 ) return super.getMembers();
-        else {
+        if ( members.size() == 0 ) {
+            return super.getMembers();
+        } else {
             synchronized (members) {
                 Member[] others = super.getMembers();
                 Member[] result = new Member[members.size() + others.length];
-                for (int i = 0; i < others.length; i++) result[i] = others[i];
-                for (int i = 0; i < members.size(); i++) result[i + others.length] = members.get(i);
+                for (int i = 0; i < others.length; i++) {
+                    result[i] = others[i];
+                }
+                for (int i = 0; i < members.size(); i++) {
+                    result[i + others.length] = members.get(i);
+                }
                 AbsoluteOrder.absoluteOrder(result);
                 return result;
             }//sync
@@ -132,8 +141,11 @@ public class StaticMembershipInterceptor extends ChannelInterceptorBase
      */
     @Override
     public Member getMember(Member mbr) {
-        if ( members.contains(mbr) ) return members.get(members.indexOf(mbr));
-        else return super.getMember(mbr);
+        if ( members.contains(mbr) ) {
+            return members.get(members.indexOf(mbr));
+        } else {
+            return super.getMember(mbr);
+        }
     }
 
     /**
@@ -143,8 +155,11 @@ public class StaticMembershipInterceptor extends ChannelInterceptorBase
      */
     @Override
     public Member getLocalMember(boolean incAlive) {
-        if (this.localMember != null ) return localMember;
-        else return super.getLocalMember(incAlive);
+        if (this.localMember != null ) {
+            return localMember;
+        } else {
+            return super.getLocalMember(incAlive);
+        }
     }
 
     /**
@@ -154,8 +169,12 @@ public class StaticMembershipInterceptor extends ChannelInterceptorBase
      */
     @Override
     public void start(int svc) throws ChannelException {
-        if ( (Channel.SND_RX_SEQ&svc)==Channel.SND_RX_SEQ ) super.start(Channel.SND_RX_SEQ);
-        if ( (Channel.SND_TX_SEQ&svc)==Channel.SND_TX_SEQ ) super.start(Channel.SND_TX_SEQ);
+        if ( (Channel.SND_RX_SEQ&svc)==Channel.SND_RX_SEQ ) {
+            super.start(Channel.SND_RX_SEQ);
+        }
+        if ( (Channel.SND_TX_SEQ&svc)==Channel.SND_TX_SEQ ) {
+            super.start(Channel.SND_TX_SEQ);
+        }
         final ChannelInterceptorBase base = this;
         ScheduledExecutorService executor = getChannel().getUtilityExecutor();
         for (final Member member : members) {
@@ -174,8 +193,12 @@ public class StaticMembershipInterceptor extends ChannelInterceptorBase
         TcpPingInterceptor pingInterceptor = null;
         ChannelInterceptor prev = getPrevious();
         while (prev != null) {
-            if (prev instanceof TcpFailureDetector ) failureDetector = (TcpFailureDetector) prev;
-            if (prev instanceof TcpPingInterceptor) pingInterceptor = (TcpPingInterceptor) prev;
+            if (prev instanceof TcpFailureDetector ) {
+                failureDetector = (TcpFailureDetector) prev;
+            }
+            if (prev instanceof TcpPingInterceptor) {
+                pingInterceptor = (TcpPingInterceptor) prev;
+            }
             prev = prev.getPrevious();
         }
         if (failureDetector == null) {
@@ -226,7 +249,9 @@ public class StaticMembershipInterceptor extends ChannelInterceptorBase
     }
 
     protected void sendMemberMessage(Member[] members, byte[] message) throws ChannelException {
-        if ( members == null || members.length == 0 ) return;
+        if ( members == null || members.length == 0 ) {
+            return;
+        }
         ChannelData data = new ChannelData(true);
         data.setAddress(getLocalMember(false));
         data.setTimestamp(System.currentTimeMillis());

==================================================
TcpPingInterceptor.java
index e493540d95..53aa34e483 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java
@@ -114,14 +114,19 @@ public class TcpFailureDetector extends ChannelInterceptorBase implements TcpFai
         }//end if
 
         //ignore the message, it doesnt have the flag set
-        if ( process ) super.messageReceived(msg);
-        else if ( log.isDebugEnabled() ) log.debug("Received a failure detector packet:"+msg);
+        if ( process ) {
+            super.messageReceived(msg);
+        } else if ( log.isDebugEnabled() ) {
+            log.debug("Received a failure detector packet:"+msg);
+        }
     }//messageReceived
 
 
     @Override
     public void memberAdded(Member member) {
-        if ( membership == null ) setupMembership();
+        if ( membership == null ) {
+            setupMembership();
+        }
         boolean notify = false;
         synchronized (membership) {
             if (removeSuspects.containsKey(member)) {
@@ -141,16 +146,22 @@ public class TcpFailureDetector extends ChannelInterceptorBase implements TcpFai
                 }
             }
         }
-        if ( notify ) super.memberAdded(member);
+        if ( notify ) {
+            super.memberAdded(member);
+        }
     }
 
     @Override
     public void memberDisappeared(Member member) {
-        if ( membership == null ) setupMembership();
+        if ( membership == null ) {
+            setupMembership();
+        }
         boolean shutdown = Arrays.equals(member.getCommand(),Member.SHUTDOWN_PAYLOAD);
         if (shutdown) {
             synchronized (membership) {
-                if (!membership.contains(member)) return;
+                if (!membership.contains(member)) {
+                    return;
+                }
                 membership.removeMember(member);
                 removeSuspects.remove(member);
                 if (member instanceof StaticMember) {
@@ -160,12 +171,14 @@ public class TcpFailureDetector extends ChannelInterceptorBase implements TcpFai
             super.memberDisappeared(member);
         } else {
             boolean notify = false;
-            if(log.isInfoEnabled())
+            if(log.isInfoEnabled()) {
                 log.info(sm.getString("tcpFailureDetector.memberDisappeared.verify", member));
+            }
             synchronized (membership) {
                 if (!membership.contains(member)) {
-                    if(log.isInfoEnabled())
+                    if(log.isInfoEnabled()) {
                         log.info(sm.getString("tcpFailureDetector.already.disappeared", member));
+                    }
                     return;
                 }
                 //check to see if the member really is gone
@@ -183,31 +196,39 @@ public class TcpFailureDetector extends ChannelInterceptorBase implements TcpFai
                 }
             }
             if ( notify ) {
-                if(log.isInfoEnabled())
+                if(log.isInfoEnabled()) {
                     log.info(sm.getString("tcpFailureDetector.member.disappeared", member));
+                }
                 super.memberDisappeared(member);
             } else {
-                if(log.isInfoEnabled())
+                if(log.isInfoEnabled()) {
                     log.info(sm.getString("tcpFailureDetector.still.alive", member));
+                }
             }
         }
     }
 
     @Override
     public boolean hasMembers() {
-        if ( membership == null ) setupMembership();
+        if ( membership == null ) {
+            setupMembership();
+        }
         return membership.hasMembers();
     }
 
     @Override
     public Member[] getMembers() {
-        if ( membership == null ) setupMembership();
+        if ( membership == null ) {
+            setupMembership();
+        }
         return membership.getMembers();
     }
 
     @Override
     public Member getMember(Member mbr) {
-        if ( membership == null ) setupMembership();
+        if ( membership == null ) {
+            setupMembership();
+        }
         return membership.getMember(mbr);
     }
 
@@ -225,10 +246,15 @@ public class TcpFailureDetector extends ChannelInterceptorBase implements TcpFai
     @Override
     public void checkMembers(boolean checkAll) {
         try {
-            if (membership == null) setupMembership();
+            if (membership == null) {
+                setupMembership();
+            }
             synchronized (membership) {
-                if (!checkAll) performBasicCheck();
-                else performForcedCheck();
+                if (!checkAll) {
+                    performBasicCheck();
+                } else {
+                    performForcedCheck();
+                }
             }
         } catch (Exception x) {
             log.warn(sm.getString("tcpFailureDetector.heartbeat.failed"),x);
@@ -240,7 +266,9 @@ public class TcpFailureDetector extends ChannelInterceptorBase implements TcpFai
         Member[] members = super.getMembers();
         for (int i = 0; members != null && i < members.length; i++) {
             if (memberAlive(members[i])) {
-                if (membership.memberAlive(members[i])) super.memberAdded(members[i]);
+                if (membership.memberAlive(members[i])) {
+                    super.memberAdded(members[i]);
+                }
                 addSuspects.remove(members[i]);
             } else {
                 if (membership.getMember(members[i])!=null) {
@@ -286,8 +314,9 @@ public class TcpFailureDetector extends ChannelInterceptorBase implements TcpFai
                 }
                 super.memberDisappeared(m);
                 removeSuspects.remove(m);
-                if (log.isInfoEnabled())
+                if (log.isInfoEnabled()) {
                     log.info(sm.getString("tcpFailureDetector.suspectMember.dead", m));
+                }
             } else {
                 if (removeSuspectsTimeout > 0) {
                     long timeNow = System.currentTimeMillis();
@@ -307,8 +336,9 @@ public class TcpFailureDetector extends ChannelInterceptorBase implements TcpFai
                 membership.memberAlive(m);
                 super.memberAdded(m);
                 addSuspects.remove(m);
-                if (log.isInfoEnabled())
+                if (log.isInfoEnabled()) {
                     log.info(sm.getString("tcpFailureDetector.suspectMember.alive", m));
+                }
             } //end if
         }
     }
@@ -329,7 +359,9 @@ public class TcpFailureDetector extends ChannelInterceptorBase implements TcpFai
                                          long readTimeout, long conTimeout,
                                          int optionFlag) {
         //could be a shutdown notification
-        if ( Arrays.equals(mbr.getCommand(),Member.SHUTDOWN_PAYLOAD) ) return false;
+        if ( Arrays.equals(mbr.getCommand(),Member.SHUTDOWN_PAYLOAD) ) {
+            return false;
+        }
 
         try (Socket socket = new Socket()) {
             InetAddress ia = InetAddress.getByAddress(mbr.getHost());
@@ -342,8 +374,11 @@ public class TcpFailureDetector extends ChannelInterceptorBase implements TcpFai
                 data.setMessage(new XByteBuffer(msgData,false));
                 data.setTimestamp(System.currentTimeMillis());
                 int options = optionFlag | Channel.SEND_OPTIONS_BYTE_MESSAGE;
-                if ( readTest ) options = (options | Channel.SEND_OPTIONS_USE_ACK);
-                else options = (options & (~Channel.SEND_OPTIONS_USE_ACK));
+                if ( readTest ) {
+                    options = (options | Channel.SEND_OPTIONS_USE_ACK);
+                } else {
+                    options = (options & (~Channel.SEND_OPTIONS_USE_ACK));
+                }
                 data.setOptions(options);
                 byte[] message = XByteBuffer.createDataPackage(data);
                 socket.getOutputStream().write(message);

==================================================
ThroughputInterceptor.java
index 725f5d3ebc..1671e9c7b0 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/TcpPingInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/TcpPingInterceptor.java
@@ -70,7 +70,9 @@ public class TcpPingInterceptor extends ChannelInterceptorBase implements TcpPin
             thread = new PingThread();
             thread.setDaemon(true);
             String channelName = "";
-            if (getChannel().getName() != null) channelName = "[" + getChannel().getName() + "]";
+            if (getChannel().getName() != null) {
+                channelName = "[" + getChannel().getName() + "]";
+            }
             thread.setName("TcpPingInterceptor.PingThread" + channelName +"-"+cnt.addAndGet(1));
             thread.start();
         }
@@ -78,10 +80,12 @@ public class TcpPingInterceptor extends ChannelInterceptorBase implements TcpPin
         //acquire the interceptors to invoke on send ping events
         ChannelInterceptor next = getNext();
         while ( next != null ) {
-            if ( next instanceof TcpFailureDetector )
+            if ( next instanceof TcpFailureDetector ) {
                 failureDetector = new WeakReference<>((TcpFailureDetector)next);
-            if ( next instanceof StaticMembershipInterceptor )
+            }
+            if ( next instanceof StaticMembershipInterceptor ) {
                 staticMembers = new WeakReference<>((StaticMembershipInterceptor)next);
+            }
             next = next.getNext();
         }
 
@@ -100,7 +104,9 @@ public class TcpPingInterceptor extends ChannelInterceptorBase implements TcpPin
     @Override
     public void heartbeat() {
         super.heartbeat();
-        if (!getUseThread()) sendPing();
+        if (!getUseThread()) {
+            sendPing();
+        }
     }
 
     @Override
@@ -148,7 +154,9 @@ public class TcpPingInterceptor extends ChannelInterceptorBase implements TcpPin
     }
 
     protected void sendPingMessage(Member[] members) {
-        if ( members == null || members.length == 0 ) return;
+        if ( members == null || members.length == 0 ) {
+            return;
+        }
         ChannelData data = new ChannelData(true);//generates a unique Id
         data.setAddress(getLocalMember(false));
         data.setTimestamp(System.currentTimeMillis());
@@ -172,8 +180,11 @@ public class TcpPingInterceptor extends ChannelInterceptorBase implements TcpPin
         }//end if
 
         //ignore the message, it doesnt have the flag set
-        if ( process ) super.messageReceived(msg);
-        else if ( log.isDebugEnabled() ) log.debug("Received a TCP ping packet:"+msg);
+        if ( process ) {
+            super.messageReceived(msg);
+        } else if ( log.isDebugEnabled() ) {
+            log.debug("Received a TCP ping packet:"+msg);
+        }
     }//messageReceived
 
     protected class PingThread extends Thread {

==================================================
TwoPhaseCommitInterceptor.java
index 4516ff9a14..05410b8a2f 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/ThroughputInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/ThroughputInterceptor.java
@@ -54,13 +54,17 @@ public class ThroughputInterceptor extends ChannelInterceptorBase
 
     @Override
     public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
-        if ( access.addAndGet(1) == 1 ) txStart = System.currentTimeMillis();
+        if ( access.addAndGet(1) == 1 ) {
+            txStart = System.currentTimeMillis();
+        }
         long bytes = XByteBuffer.getDataPackageLength(((ChannelData)msg).getDataPackageLength());
         try {
             super.sendMessage(destination, msg, payload);
         }catch ( ChannelException x ) {
             msgTxErr.addAndGet(1);
-            if ( access.get() == 1 ) access.addAndGet(-1);
+            if ( access.get() == 1 ) {
+                access.addAndGet(-1);
+            }
             throw x;
         }
         mbTx += (bytes*destination.length)/(1024d*1024d);
@@ -78,23 +82,28 @@ public class ThroughputInterceptor extends ChannelInterceptorBase
 
     @Override
     public void messageReceived(ChannelMessage msg) {
-        if ( rxStart == 0 ) rxStart = System.currentTimeMillis();
+        if ( rxStart == 0 ) {
+            rxStart = System.currentTimeMillis();
+        }
         long bytes = XByteBuffer.getDataPackageLength(((ChannelData)msg).getDataPackageLength());
         mbRx += bytes/(1024d*1024d);
         msgRxCnt.addAndGet(1);
-        if ( msgRxCnt.get() % interval == 0 ) report(timeTx);
+        if ( msgRxCnt.get() % interval == 0 ) {
+            report(timeTx);
+        }
         super.messageReceived(msg);
 
     }
 
     @Override
     public void report(double timeTx) {
-        if ( log.isInfoEnabled() )
+        if ( log.isInfoEnabled() ) {
             log.info(sm.getString("throughputInterceptor.report",
                     msgTxCnt, df.format(mbTx), df.format(mbAppTx), df.format(timeTx),
                     df.format(mbTx/timeTx), df.format(mbAppTx/timeTx), msgTxErr, msgRxCnt,
                     df.format(mbRx/((System.currentTimeMillis()-rxStart)/(double)1000)),
                     df.format(mbRx)));
+        }
     }
 
     @Override

==================================================
BufferPool.java
index 1b956716f8..b7983395ff 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/TwoPhaseCommitInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/TwoPhaseCommitInterceptor.java
@@ -51,8 +51,11 @@ public class TwoPhaseCommitInterceptor extends ChannelInterceptorBase {
         if (okToProcess(msg.getOptions()) ) {
             super.sendMessage(destination, msg, null);
             ChannelMessage confirmation = null;
-            if ( deepclone ) confirmation = (ChannelMessage)msg.deepclone();
-            else confirmation = (ChannelMessage)msg.clone();
+            if ( deepclone ) {
+                confirmation = (ChannelMessage)msg.deepclone();
+            } else {
+                confirmation = (ChannelMessage)msg.clone();
+            }
             confirmation.getMessage().reset();
             UUIDGenerator.randomUUID(false,confirmation.getUniqueId(),0);
             confirmation.getMessage().append(START_DATA,0,START_DATA.length);
@@ -79,7 +82,9 @@ public class TwoPhaseCommitInterceptor extends ChannelInterceptorBase {
                 if ( original != null ) {
                     super.messageReceived(original.msg);
                     messages.remove(id);
-                } else log.warn(sm.getString("twoPhaseCommitInterceptor.originalMessage.missing", Arrays.toString(id.getBytes())));
+                } else {
+                    log.warn(sm.getString("twoPhaseCommitInterceptor.originalMessage.missing", Arrays.toString(id.getBytes())));
+                }
             } else {
                 UniqueId id = new UniqueId(msg.getUniqueId());
                 MapEntry entry = new MapEntry((ChannelMessage)msg.deepclone(),id,System.currentTimeMillis());

==================================================
ChannelData.java
index 0a607b7833..4692cd383e 100644
--- a/java/org/apache/catalina/tribes/io/BufferPool.java
+++ b/java/org/apache/catalina/tribes/io/BufferPool.java
@@ -55,9 +55,14 @@ public class BufferPool {
 
     public XByteBuffer getBuffer(int minSize, boolean discard) {
         XByteBuffer buffer = queue.poll();
-        if ( buffer != null ) size.addAndGet(-buffer.getCapacity());
-        if ( buffer == null ) buffer = new XByteBuffer(minSize,discard);
-        else if ( buffer.getCapacity() <= minSize ) buffer.expand(minSize);
+        if ( buffer != null ) {
+            size.addAndGet(-buffer.getCapacity());
+        }
+        if ( buffer == null ) {
+            buffer = new XByteBuffer(minSize,discard);
+        } else if ( buffer.getCapacity() <= minSize ) {
+            buffer.expand(minSize);
+        }
         buffer.setDiscard(discard);
         buffer.reset();
         return buffer;

==================================================
ObjectReader.java
index c9b1ed390f..512b79d778 100644
--- a/java/org/apache/catalina/tribes/io/ChannelData.java
+++ b/java/org/apache/catalina/tribes/io/ChannelData.java
@@ -73,7 +73,9 @@ public class ChannelData implements ChannelMessage {
      * @param generateUUID boolean - if true, a unique Id will be generated
      */
     public ChannelData(boolean generateUUID) {
-        if ( generateUUID ) generateUUID();
+        if ( generateUUID ) {
+            generateUUID();
+        }
     }
 
 
@@ -293,7 +295,9 @@ public class ChannelData implements ChannelMessage {
     public boolean equals(Object o) {
         if ( o instanceof ChannelData ) {
             return Arrays.equals(getUniqueId(),((ChannelData)o).getUniqueId());
-        } else return false;
+        } else {
+            return false;
+        }
     }
 
     /**
@@ -365,7 +369,9 @@ public class ChannelData implements ChannelMessage {
     public static String bToS(byte[] data) {
         StringBuilder buf = new StringBuilder(4*16);
         buf.append('{');
-        for (int i=0; data!=null && i<data.length; i++ ) buf.append(String.valueOf(data[i])).append(' ');
+        for (int i=0; data!=null && i<data.length; i++ ) {
+            buf.append(String.valueOf(data[i])).append(' ');
+        }
         buf.append('}');
         return buf.toString();
     }

==================================================
ReplicationStream.java
index b47e7463c5..20eed9e300 100644
--- a/java/org/apache/catalina/tribes/io/ObjectReader.java
+++ b/java/org/apache/catalina/tribes/io/ObjectReader.java
@@ -97,14 +97,18 @@ public class ObjectReader {
     public int append(ByteBuffer data, int len, boolean count) {
        buffer.append(data,len);
        int pkgCnt = -1;
-       if ( count ) pkgCnt = buffer.countPackages();
+       if ( count ) {
+        pkgCnt = buffer.countPackages();
+    }
        return pkgCnt;
    }
 
      public int append(byte[] data,int off,int len, boolean count) {
         buffer.append(data,off,len);
         int pkgCnt = -1;
-        if ( count ) pkgCnt = buffer.countPackages();
+        if ( count ) {
+            pkgCnt = buffer.countPackages();
+        }
         return pkgCnt;
     }
 

==================================================
XByteBuffer.java
index e691dee116..1726bd7c5d 100644
--- a/java/org/apache/catalina/tribes/io/ReplicationStream.java
+++ b/java/org/apache/catalina/tribes/io/ReplicationStream.java
@@ -84,15 +84,17 @@ public final class ReplicationStream extends ObjectInputStream {
 
         boolean tryRepFirst = name.startsWith("org.apache.catalina.tribes");
             try {
-            if (tryRepFirst)
+            if (tryRepFirst) {
                 return findReplicationClass(name);
-            else
+            } else {
                 return findExternalClass(name);
+            }
         } catch (Exception x) {
-            if (tryRepFirst)
+            if (tryRepFirst) {
                 return findExternalClass(name);
-            else
+            } else {
                 return findReplicationClass(name);
+            }
         }
     }
 
@@ -117,7 +119,9 @@ public final class ReplicationStream extends ObjectInputStream {
         Class<?>[] classObjs = new Class[interfaces.length];
         for (int i = 0; i < interfaces.length; i++) {
             Class<?> cl = this.resolveClass(interfaces[i]);
-            if (latestLoader==null) latestLoader = cl.getClassLoader();
+            if (latestLoader==null) {
+                latestLoader = cl.getClassLoader();
+            }
             if ((cl.getModifiers() & Modifier.PUBLIC) == 0) {
                 if (hasNonPublicInterface) {
                     if (nonPublicLoader != cl.getClassLoader()) {
@@ -158,8 +162,11 @@ public final class ReplicationStream extends ObjectInputStream {
                 cnfe = x;
             }
         }
-        if ( cnfe != null ) throw cnfe;
-        else throw new ClassNotFoundException(name);
+        if ( cnfe != null ) {
+            throw cnfe;
+        } else {
+            throw new ClassNotFoundException(name);
+        }
     }
 
     @Override

==================================================
JmxRegistry.java
index c915552769..6962271c34 100644
--- a/java/org/apache/catalina/tribes/io/XByteBuffer.java
+++ b/java/org/apache/catalina/tribes/io/XByteBuffer.java
@@ -111,14 +111,17 @@ public class XByteBuffer implements Serializable {
     }
 
     public void setLength(int size) {
-        if ( size > buf.length ) throw new ArrayIndexOutOfBoundsException(sm.getString("xByteBuffer.size.larger.buffer"));
+        if ( size > buf.length ) {
+            throw new ArrayIndexOutOfBoundsException(sm.getString("xByteBuffer.size.larger.buffer"));
+        }
         bufSize = size;
     }
 
     public void trim(int length) {
-        if ( (bufSize - length) < 0 )
+        if ( (bufSize - length) < 0 ) {
             throw new ArrayIndexOutOfBoundsException(sm.getString("xByteBuffer.unableTrim",
                     Integer.toString(bufSize), Integer.toString(length)));
+        }
         bufSize -= length;
     }
 
@@ -271,25 +274,33 @@ public class XByteBuffer implements Serializable {
             int index = XByteBuffer.firstIndexOf(buf,start,START_DATA);
             //if the header (START_DATA) isn't the first thing or
             //the buffer isn't even 14 bytes
-            if ( index != start || ((bufSize-start)<14) ) break;
+            if ( index != start || ((bufSize-start)<14) ) {
+                break;
+            }
             //next 4 bytes are compress flag not needed for count packages
             //then get the size 4 bytes
             int size = toInt(buf, pos);
             //now the total buffer has to be long enough to hold
             //START_DATA.length+4+size+END_DATA.length
             pos = start + START_DATA.length + 4 + size;
-            if ( (pos + END_DATA.length) > bufSize) break;
+            if ( (pos + END_DATA.length) > bufSize) {
+                break;
+            }
             //and finally check the footer of the package END_DATA
             int newpos = firstIndexOf(buf, pos, END_DATA);
             //mismatch, there is no package
-            if (newpos != pos) break;
+            if (newpos != pos) {
+                break;
+            }
             //increase the packet count
             cnt++;
             //reset the values
             start = pos + END_DATA.length;
             pos = start + START_DATA.length;
             //we only want to verify that we have at least one package
-            if ( first ) break;
+            if ( first ) {
+                break;
+            }
         }
         return cnt;
     }
@@ -497,9 +508,15 @@ public class XByteBuffer implements Serializable {
      */
     public static int firstIndexOf(byte[] src, int srcOff, byte[] find){
         int result = -1;
-        if (find.length > src.length) return result;
-        if (find.length == 0 || src.length == 0) return result;
-        if (srcOff >= src.length ) throw new java.lang.ArrayIndexOutOfBoundsException();
+        if (find.length > src.length) {
+            return result;
+        }
+        if (find.length == 0 || src.length == 0) {
+            return result;
+        }
+        if (srcOff >= src.length ) {
+            throw new java.lang.ArrayIndexOutOfBoundsException();
+        }
         boolean found = false;
         int srclen = src.length;
         int findlen = find.length;
@@ -508,17 +525,20 @@ public class XByteBuffer implements Serializable {
         while (!found) {
             //find the first byte
             while (pos < srclen){
-                if (first == src[pos])
+                if (first == src[pos]) {
                     break;
+                }
                 pos++;
             }
-            if (pos >= srclen)
+            if (pos >= srclen) {
                 return -1;
+            }
 
             //we found the first character
             //match the rest of the bytes - they have to match
-            if ( (srclen - pos) < findlen)
+            if ( (srclen - pos) < findlen) {
                 return -1;
+            }
             //assume it does exist
             found = true;
             for (int i = 1; ( (i < findlen) && found); i++) {
@@ -552,7 +572,9 @@ public class XByteBuffer implements Serializable {
         throws IOException, ClassNotFoundException, ClassCastException {
         invokecount.addAndGet(1);
         Object message = null;
-        if ( cls == null ) cls = new ClassLoader[0];
+        if ( cls == null ) {
+            cls = new ClassLoader[0];
+        }
         if (data != null && length > 0) {
             InputStream  instream = new ByteArrayInputStream(data,offset,length);
             ObjectInputStream stream = null;
@@ -563,9 +585,9 @@ public class XByteBuffer implements Serializable {
         }
         if ( message == null ) {
             return null;
-        } else if (message instanceof Serializable)
+        } else if (message instanceof Serializable) {
             return (Serializable) message;
-        else {
+        } else {
             throw new ClassCastException(sm.getString("xByteBuffer.wrong.class", message.getClass().getName()));
         }
     }

==================================================
McastService.java
index 5c3893cc50..a22904d963 100644
--- a/java/org/apache/catalina/tribes/jmx/JmxRegistry.java
+++ b/java/org/apache/catalina/tribes/jmx/JmxRegistry.java
@@ -49,14 +49,22 @@ public class JmxRegistry {
             return null;
         }
         JmxRegistry registry = registryCache.get(channel.getName());
-        if (registry != null) return registry;
+        if (registry != null) {
+            return registry;
+        }
 
-        if (!(channel instanceof JmxChannel)) return null;
+        if (!(channel instanceof JmxChannel)) {
+            return null;
+        }
         JmxChannel jmxChannel = (JmxChannel) channel;
-        if (!jmxChannel.isJmxEnabled()) return null;
+        if (!jmxChannel.isJmxEnabled()) {
+            return null;
+        }
         ObjectName baseOn = createBaseObjectName(jmxChannel.getJmxDomain(),
                 jmxChannel.getJmxPrefix(), channel.getName());
-        if (baseOn == null) return null;
+        if (baseOn == null) {
+            return null;
+        }
         // create registry
         registry = new JmxRegistry();
         registry.baseOname = baseOn;
@@ -69,7 +77,9 @@ public class JmxRegistry {
 
     public static void removeRegistry(Channel channel, boolean clear) {
         JmxRegistry registry = registryCache.get(channel.getName());
-        if (registry == null) return;
+        if (registry == null) {
+            return;
+        }
         if (clear) {
             registry.clearMBeans();
         }
@@ -121,7 +131,9 @@ public class JmxRegistry {
     }
 
     public void unregisterJmx(ObjectName oname) {
-        if (oname ==null) return;
+        if (oname ==null) {
+            return;
+        }
         try {
             mbserver.unregisterMBean(oname);
         } catch (InstanceNotFoundException e) {

==================================================
McastServiceImpl.java
index 9c73f64372..1d72a3d67e 100644
--- a/java/org/apache/catalina/tribes/membership/McastService.java
+++ b/java/org/apache/catalina/tribes/membership/McastService.java
@@ -125,7 +125,9 @@ public class McastService
      */
     @Override
     public Member getLocalMember(boolean alive) {
-        if ( alive && localMember != null && impl != null) localMember.setMemberAliveTime(System.currentTimeMillis()-impl.getServiceStartTime());
+        if ( alive && localMember != null && impl != null) {
+            localMember.setMemberAliveTime(System.currentTimeMillis()-impl.getServiceStartTime());
+        }
         return localMember;
     }
 
@@ -270,7 +272,9 @@ public class McastService
      * @param name The property to check for
      */
     protected void hasProperty(Properties properties, String name){
-        if ( properties.getProperty(name)==null) throw new IllegalArgumentException(sm.getString("mcastService.missing.property", name));
+        if ( properties.getProperty(name)==null) {
+            throw new IllegalArgumentException(sm.getString("mcastService.missing.property", name));
+        }
     }
 
     @Override
@@ -305,8 +309,12 @@ public class McastService
         }
         localMember.setSecurePort(securePort);
         localMember.setUdpPort(udpPort);
-        if ( this.payload != null ) localMember.setPayload(payload);
-        if ( this.domain != null ) localMember.setDomain(domain);
+        if ( this.payload != null ) {
+            localMember.setPayload(payload);
+        }
+        if ( this.domain != null ) {
+            localMember.setDomain(domain);
+        }
         localMember.setServiceStartTime(System.currentTimeMillis());
         java.net.InetAddress bind = null;
         if ( properties.getProperty("mcastBindAddress")!= null ) {
@@ -392,7 +400,9 @@ public class McastService
 
     @Override
     public void messageReceived(ChannelMessage msg) {
-        if (msglistener!=null && msglistener.accept(msg)) msglistener.messageReceived(msg);
+        if (msglistener!=null && msglistener.accept(msg)) {
+            msglistener.messageReceived(msg);
+        }
     }
 
     @Override
@@ -401,8 +411,9 @@ public class McastService
     }
     @Override
     public void broadcast(ChannelMessage message) throws ChannelException {
-        if (impl==null || (impl.startLevel & Channel.MBR_TX_SEQ)!=Channel.MBR_TX_SEQ )
+        if (impl==null || (impl.startLevel & Channel.MBR_TX_SEQ)!=Channel.MBR_TX_SEQ ) {
             throw new ChannelException(sm.getString("mcastService.noStart"));
+        }
 
         byte[] data = XByteBuffer.createDataPackage((ChannelData)message);
         if (data.length>McastServiceImpl.MAX_PACKET_SIZE) {
@@ -453,7 +464,9 @@ public class McastService
         if ( localMember != null ) {
             localMember.setPayload(payload);
             try {
-                if (impl != null) impl.send(false);
+                if (impl != null) {
+                    impl.send(false);
+                }
             }catch ( Exception x ) {
                 log.error(sm.getString("McastService.payload"), x);
             }
@@ -466,7 +479,9 @@ public class McastService
         if ( localMember != null ) {
             localMember.setDomain(domain);
             try {
-                if (impl != null) impl.send(false);
+                if (impl != null) {
+                    impl.send(false);
+                }
             }catch ( Exception x ) {
                 log.error(sm.getString("McastService.domain"), x);
             }
@@ -474,9 +489,14 @@ public class McastService
     }
 
     public void setDomain(String domain) {
-        if ( domain == null ) return;
-        if ( domain.startsWith("{") ) setDomain(Arrays.fromString(domain));
-        else setDomain(Arrays.convert(domain));
+        if ( domain == null ) {
+            return;
+        }
+        if ( domain.startsWith("{") ) {
+            setDomain(Arrays.fromString(domain));
+        } else {
+            setDomain(Arrays.convert(domain));
+        }
     }
 
     @Override
@@ -486,22 +506,30 @@ public class McastService
 
     protected void setDefaults(Properties properties) {
         // default values
-        if (properties.getProperty("mcastPort") == null)
+        if (properties.getProperty("mcastPort") == null) {
             properties.setProperty("mcastPort","45564");
-        if (properties.getProperty("mcastAddress") == null)
+        }
+        if (properties.getProperty("mcastAddress") == null) {
             properties.setProperty("mcastAddress","228.0.0.4");
-        if (properties.getProperty("memberDropTime") == null)
+        }
+        if (properties.getProperty("memberDropTime") == null) {
             properties.setProperty("memberDropTime","3000");
-        if (properties.getProperty("mcastFrequency") == null)
+        }
+        if (properties.getProperty("mcastFrequency") == null) {
             properties.setProperty("mcastFrequency","500");
-        if (properties.getProperty("recoveryCounter") == null)
+        }
+        if (properties.getProperty("recoveryCounter") == null) {
             properties.setProperty("recoveryCounter", "10");
-        if (properties.getProperty("recoveryEnabled") == null)
+        }
+        if (properties.getProperty("recoveryEnabled") == null) {
             properties.setProperty("recoveryEnabled", "true");
-        if (properties.getProperty("recoverySleepTime") == null)
+        }
+        if (properties.getProperty("recoverySleepTime") == null) {
             properties.setProperty("recoverySleepTime", "5000");
-        if (properties.getProperty("localLoopbackDisabled") == null)
+        }
+        if (properties.getProperty("localLoopbackDisabled") == null) {
             properties.setProperty("localLoopbackDisabled", "false");
+        }
     }
 
     /**

==================================================
MemberImpl.java
index dc00496539..2bebc02232 100644
--- a/java/org/apache/catalina/tribes/membership/McastServiceImpl.java
+++ b/java/org/apache/catalina/tribes/membership/McastServiceImpl.java
@@ -196,7 +196,9 @@ public class McastServiceImpl extends MembershipProviderBase {
         receivePacket.setAddress(address);
         receivePacket.setPort(port);
         member.setCommand(new byte[0]);
-        if ( membership == null ) membership = new Membership(member);
+        if ( membership == null ) {
+            membership = new Membership(member);
+        }
     }
 
     protected void setupSocket() throws IOException {
@@ -218,12 +220,15 @@ public class McastServiceImpl extends MembershipProviderBase {
         }
         socket.setLoopbackMode(localLoopbackDisabled); //hint if we want disable loop back(local machine) messages
         if (mcastBindAddress != null) {
-            if(log.isInfoEnabled())
+            if(log.isInfoEnabled()) {
                 log.info(sm.getString("mcastServiceImpl.setInterface", mcastBindAddress));
+            }
             socket.setInterface(mcastBindAddress);
         } //end if
         //force a so timeout so that we don't block forever
-        if (mcastSoTimeout <= 0) mcastSoTimeout = (int)sendFrequency;
+        if (mcastSoTimeout <= 0) {
+            mcastSoTimeout = (int)sendFrequency;
+        }
         if (log.isInfoEnabled()) {
             log.info(sm.getString("mcastServiceImpl.setSoTimeout",
                     Integer.toString(mcastSoTimeout)));
@@ -231,8 +236,9 @@ public class McastServiceImpl extends MembershipProviderBase {
         socket.setSoTimeout(mcastSoTimeout);
 
         if ( mcastTTL >= 0 ) {
-            if(log.isInfoEnabled())
+            if(log.isInfoEnabled()) {
                 log.info(sm.getString("mcastServiceImpl.setTTL", Integer.toString(mcastTTL)));
+            }
             socket.setTimeToLive(mcastTTL);
         }
     }
@@ -248,9 +254,13 @@ public class McastServiceImpl extends MembershipProviderBase {
     public synchronized void start(int level) throws IOException {
         boolean valid = false;
         if ( (level & Channel.MBR_RX_SEQ)==Channel.MBR_RX_SEQ ) {
-            if ( receiver != null ) throw new IllegalStateException(sm.getString("mcastServiceImpl.receive.running"));
+            if ( receiver != null ) {
+                throw new IllegalStateException(sm.getString("mcastServiceImpl.receive.running"));
+            }
             try {
-                if ( sender == null ) socket.joinGroup(address);
+                if ( sender == null ) {
+                    socket.joinGroup(address);
+                }
             }catch (IOException iox) {
                 log.error(sm.getString("mcastServiceImpl.unable.join"));
                 throw iox;
@@ -262,8 +272,12 @@ public class McastServiceImpl extends MembershipProviderBase {
             valid = true;
         }
         if ( (level & Channel.MBR_TX_SEQ)==Channel.MBR_TX_SEQ ) {
-            if ( sender != null ) throw new IllegalStateException(sm.getString("mcastServiceImpl.send.running"));
-            if ( receiver == null ) socket.joinGroup(address);
+            if ( sender != null ) {
+                throw new IllegalStateException(sm.getString("mcastServiceImpl.send.running"));
+            }
+            if ( receiver == null ) {
+                socket.joinGroup(address);
+            }
             //make sure at least one packet gets out there
             send(false);
             doRunSender = true;
@@ -283,12 +297,14 @@ public class McastServiceImpl extends MembershipProviderBase {
 
     private void waitForMembers(int level) {
         long memberwait = sendFrequency*2;
-        if(log.isInfoEnabled())
+        if(log.isInfoEnabled()) {
             log.info(sm.getString("mcastServiceImpl.waitForMembers.start",
                     Long.toString(memberwait), Integer.toString(level)));
+        }
         try {Thread.sleep(memberwait);}catch (InterruptedException ignore){}
-        if(log.isInfoEnabled())
+        if(log.isInfoEnabled()) {
             log.info(sm.getString("mcastServiceImpl.waitForMembers.done", Integer.toString(level)));
+        }
     }
 
     /**
@@ -304,13 +320,17 @@ public class McastServiceImpl extends MembershipProviderBase {
         if ( (level & Channel.MBR_RX_SEQ)==Channel.MBR_RX_SEQ ) {
             valid = true;
             doRunReceiver = false;
-            if ( receiver !=null ) receiver.interrupt();
+            if ( receiver !=null ) {
+                receiver.interrupt();
+            }
             receiver = null;
         }
         if ( (level & Channel.MBR_TX_SEQ)==Channel.MBR_TX_SEQ ) {
             valid = true;
             doRunSender = false;
-            if ( sender != null )sender.interrupt();
+            if ( sender != null ) {
+                sender.interrupt();
+            }
             sender = null;
         }
 
@@ -358,15 +378,21 @@ public class McastServiceImpl extends MembershipProviderBase {
             //since the receive thread is the same thread
             //that does membership expiration
         }
-        if (checkexpired) checkExpired();
+        if (checkexpired) {
+            checkExpired();
+        }
     }
 
     private void memberDataReceived(byte[] data) {
         final Member m = MemberImpl.getMember(data);
-        if (log.isTraceEnabled()) log.trace("Mcast receive ping from member " + m);
+        if (log.isTraceEnabled()) {
+            log.trace("Mcast receive ping from member " + m);
+        }
         Runnable t = null;
         if (Arrays.equals(m.getCommand(), Member.SHUTDOWN_PAYLOAD)) {
-            if (log.isDebugEnabled()) log.debug("Member has shutdown:" + m);
+            if (log.isDebugEnabled()) {
+                log.debug("Member has shutdown:" + m);
+            }
             membership.removeMember(m);
             t = () -> {
                 String name = Thread.currentThread().getName();
@@ -378,7 +404,9 @@ public class McastServiceImpl extends MembershipProviderBase {
                 }
             };
         } else if (membership.memberAlive(m)) {
-            if (log.isDebugEnabled()) log.debug("Mcast add member " + m);
+            if (log.isDebugEnabled()) {
+                log.debug("Mcast add member " + m);
+            }
             t = () -> {
                 String name = Thread.currentThread().getName();
                 try {
@@ -395,7 +423,9 @@ public class McastServiceImpl extends MembershipProviderBase {
     }
 
     private void memberBroadcastsReceived(final byte[] b) {
-        if (log.isTraceEnabled()) log.trace("Mcast received broadcasts.");
+        if (log.isTraceEnabled()) {
+            log.trace("Mcast received broadcasts.");
+        }
         XByteBuffer buffer = new XByteBuffer(b,true);
         if (buffer.countPackages(true)>0) {
             int count = buffer.countPackages();
@@ -439,8 +469,9 @@ public class McastServiceImpl extends MembershipProviderBase {
         synchronized (expiredMutex) {
             Member[] expired = membership.expire(timeToExpiration);
             for (final Member member : expired) {
-                if (log.isDebugEnabled())
+                if (log.isDebugEnabled()) {
                     log.debug("Mcast expire  member " + member);
+                }
                 try {
                     Runnable t = () -> {
                         String name = Thread.currentThread().getName();
@@ -490,7 +521,9 @@ public class McastServiceImpl extends MembershipProviderBase {
         synchronized (sendLock) {
             socket.send(packet);
         }
-        if ( checkexpired ) checkExpired();
+        if ( checkexpired ) {
+            checkExpired();
+        }
     }
 
     public long getServiceStartTime() {
@@ -522,7 +555,9 @@ public class McastServiceImpl extends MembershipProviderBase {
         public ReceiverThread() {
             super();
             String channelName = "";
-            if (channel.getName() != null) channelName = "[" + channel.getName() + "]";
+            if (channel.getName() != null) {
+                channelName = "[" + channel.getName() + "]";
+            }
             setName("Tribes-MembershipReceiver" + channelName);
         }
         @Override
@@ -534,11 +569,15 @@ public class McastServiceImpl extends MembershipProviderBase {
                 } catch ( ArrayIndexOutOfBoundsException ax ) {
                     //we can ignore this, as it means we have an invalid package
                     //but we will log it to debug
-                    if ( log.isDebugEnabled() )
+                    if ( log.isDebugEnabled() ) {
                         log.debug("Invalid member mcast package.",ax);
+                    }
                 } catch ( Exception x ) {
-                    if (errorCounter==0 && doRunReceiver) log.warn(sm.getString("mcastServiceImpl.error.receiving"),x);
-                    else if (log.isDebugEnabled()) log.debug("Error receiving mcast package"+(doRunReceiver?". Sleeping 500ms":"."),x);
+                    if (errorCounter==0 && doRunReceiver) {
+                        log.warn(sm.getString("mcastServiceImpl.error.receiving"),x);
+                    } else if (log.isDebugEnabled()) {
+                        log.debug("Error receiving mcast package"+(doRunReceiver?". Sleeping 500ms":"."),x);
+                    }
                     if (doRunReceiver) {
                         try { Thread.sleep(500); } catch ( Exception ignore ){}
                         if ( (++errorCounter)>=recoveryCounter ) {
@@ -557,7 +596,9 @@ public class McastServiceImpl extends MembershipProviderBase {
         public SenderThread(long time) {
             this.time = time;
             String channelName = "";
-            if (channel.getName() != null) channelName = "[" + channel.getName() + "]";
+            if (channel.getName() != null) {
+                channelName = "[" + channel.getName() + "]";
+            }
             setName("Tribes-MembershipSender" + channelName);
 
         }
@@ -568,8 +609,11 @@ public class McastServiceImpl extends MembershipProviderBase {
                     send(true);
                     errorCounter = 0;
                 } catch ( Exception x ) {
-                    if (errorCounter==0) log.warn(sm.getString("mcastServiceImpl.send.failed"),x);
-                    else log.debug("Unable to send mcast message.",x);
+                    if (errorCounter==0) {
+                        log.warn(sm.getString("mcastServiceImpl.send.failed"),x);
+                    } else {
+                        log.debug("Unable to send mcast message.",x);
+                    }
                     if ( (++errorCounter)>=recoveryCounter ) {
                         errorCounter=0;
                         RecoveryThread.recover(McastServiceImpl.this);
@@ -596,7 +640,9 @@ public class McastServiceImpl extends MembershipProviderBase {
 
             Thread t = new RecoveryThread(parent);
             String channelName = "";
-            if (parent.channel.getName() != null) channelName = "[" + parent.channel.getName() + "]";
+            if (parent.channel.getName() != null) {
+                channelName = "[" + parent.channel.getName() + "]";
+            }
             t.setName("Tribes-MembershipRecovery" + channelName);
             t.setDaemon(true);
             t.start();
@@ -633,19 +679,22 @@ public class McastServiceImpl extends MembershipProviderBase {
             int attempt = 0;
             try {
                 while (!success) {
-                    if(log.isInfoEnabled())
+                    if(log.isInfoEnabled()) {
                         log.info(sm.getString("mcastServiceImpl.recovery"));
+                    }
                     if (stopService() & startService()) {
                         success = true;
-                        if(log.isInfoEnabled())
+                        if(log.isInfoEnabled()) {
                             log.info(sm.getString("mcastServiceImpl.recovery.successful"));
+                        }
                     }
                     try {
                         if (!success) {
-                            if(log.isInfoEnabled())
+                            if(log.isInfoEnabled()) {
                                 log.info(sm.getString("mcastServiceImpl.recovery.failed",
                                         Integer.toString(++attempt),
                                         Long.toString(parent.recoverySleepTime)));
+                            }
                             Thread.sleep(parent.recoverySleepTime);
                         }
                     }catch (InterruptedException ignore) {

==================================================
Membership.java
index e651d9014e..0801e348e5 100644
--- a/java/org/apache/catalina/tribes/membership/MemberImpl.java
+++ b/java/org/apache/catalina/tribes/membership/MemberImpl.java
@@ -569,9 +569,9 @@ public class MemberImpl implements Member, java.io.Externalizable {
             return Arrays.equals(this.getHost(),((MemberImpl)o).getHost()) &&
                    this.getPort() == ((MemberImpl)o).getPort() &&
                    Arrays.equals(this.getUniqueId(),((MemberImpl)o).getUniqueId());
-        }
-        else
+        } else {
             return false;
+        }
     }
 
     public synchronized void setHost(byte[] host) {

==================================================
MembershipProviderBase.java
index 99a60717a1..234bf47b3d 100644
--- a/java/org/apache/catalina/tribes/membership/Membership.java
+++ b/java/org/apache/catalina/tribes/membership/Membership.java
@@ -199,7 +199,9 @@ public class Membership implements Cloneable {
                     break;
                 }
             }
-            if (n < 0) return;
+            if (n < 0) {
+                return;
+            }
             Member results[] = new Member[members.length - 1];
             int j = 0;
             for (int i = 0; i < members.length; i++) {

==================================================
MembershipServiceBase.java
index 4779c97cb0..07ede91cb1 100644
--- a/java/org/apache/catalina/tribes/membership/MembershipProviderBase.java
+++ b/java/org/apache/catalina/tribes/membership/MembershipProviderBase.java
@@ -39,19 +39,25 @@ public abstract class MembershipProviderBase implements MembershipProvider {
 
     @Override
     public boolean hasMembers() {
-        if (membership == null ) return false;
+        if (membership == null ) {
+            return false;
+        }
         return membership.hasMembers();
     }
 
     @Override
     public Member getMember(Member mbr) {
-        if (membership.getMembers() == null) return null;
+        if (membership.getMembers() == null) {
+            return null;
+        }
         return membership.getMember(mbr);
     }
 
     @Override
     public Member[] getMembers() {
-        if (membership.getMembers() == null) return Membership.EMPTY_MEMBERS;
+        if (membership.getMembers() == null) {
+            return Membership.EMPTY_MEMBERS;
+        }
         return membership.getMembers();
     }
 

==================================================
StaticMember.java
index 399d230214..b910022de3 100644
--- a/java/org/apache/catalina/tribes/membership/MembershipServiceBase.java
+++ b/java/org/apache/catalina/tribes/membership/MembershipServiceBase.java
@@ -53,19 +53,25 @@ public abstract class MembershipServiceBase implements MembershipService, Member
 
     @Override
     public boolean hasMembers() {
-        if (getMembershipProvider() == null ) return false;
+        if (getMembershipProvider() == null ) {
+            return false;
+        }
         return getMembershipProvider().hasMembers();
     }
 
     @Override
     public Member getMember(Member mbr) {
-        if (getMembershipProvider() == null) return null;
+        if (getMembershipProvider() == null) {
+            return null;
+        }
         return getMembershipProvider().getMember(mbr);
     }
 
     @Override
     public Member[] getMembers() {
-        if (getMembershipProvider() == null) return Membership.EMPTY_MEMBERS;
+        if (getMembershipProvider() == null) {
+            return Membership.EMPTY_MEMBERS;
+        }
         return getMembershipProvider().getMembers();
     }
 
@@ -78,8 +84,9 @@ public abstract class MembershipServiceBase implements MembershipService, Member
             for (int i = 0; i < currentMembers.length; i++) {
                 membernames[i] = currentMembers[i].toString() ;
             }
-        } else
+        } else {
             membernames = new String[0] ;
+        }
         return membernames ;
     }
 
@@ -87,8 +94,9 @@ public abstract class MembershipServiceBase implements MembershipService, Member
     public Member findMemberByName(String name) {
         Member[] currentMembers = getMembers();
         for (Member currentMember : currentMembers) {
-            if (name.equals(currentMember.toString()))
+            if (name.equals(currentMember.toString())) {
                 return currentMember;
+            }
         }
         return null;
     }
@@ -106,13 +114,17 @@ public abstract class MembershipServiceBase implements MembershipService, Member
     @Override
     public void memberAdded(Member member) {
         MembershipListener listener = this.listener;
-        if (listener != null) listener.memberAdded(member);
+        if (listener != null) {
+            listener.memberAdded(member);
+        }
     }
 
     @Override
     public void memberDisappeared(Member member) {
         MembershipListener listener = this.listener;
-        if (listener != null) listener.memberDisappeared(member);
+        if (listener != null) {
+            listener.memberDisappeared(member);
+        }
     }
 
     @Override

==================================================
StaticMembershipProvider.java
index a4245dcefe..39159f9b6d 100644
--- a/java/org/apache/catalina/tribes/membership/StaticMember.java
+++ b/java/org/apache/catalina/tribes/membership/StaticMember.java
@@ -38,9 +38,14 @@ public class StaticMember extends MemberImpl {
      * or as a regular hostname, 127.0.0.1 or tomcat01.mydomain.com
      */
     public void setHost(String host) {
-        if ( host == null ) return;
-        if ( host.startsWith("{") ) setHost(Arrays.fromString(host));
-        else try { setHostname(host); }catch (IOException x) { throw new RuntimeException(x);}
+        if ( host == null ) {
+            return;
+        }
+        if ( host.startsWith("{") ) {
+            setHost(Arrays.fromString(host));
+        } else {
+            try { setHostname(host); }catch (IOException x) { throw new RuntimeException(x);}
+        }
 
     }
 
@@ -49,9 +54,14 @@ public class StaticMember extends MemberImpl {
      * or as a regular string value like 'mydomain'. The latter will be converted using ISO-8859-1 encoding
      */
     public void setDomain(String domain) {
-        if ( domain == null ) return;
-        if ( domain.startsWith("{") ) setDomain(Arrays.fromString(domain));
-        else setDomain(Arrays.convert(domain));
+        if ( domain == null ) {
+            return;
+        }
+        if ( domain.startsWith("{") ) {
+            setDomain(Arrays.fromString(domain));
+        } else {
+            setDomain(Arrays.convert(domain));
+        }
     }
 
     /**
@@ -59,7 +69,9 @@ public class StaticMember extends MemberImpl {
      */
     public void setUniqueId(String id) {
         byte[] uuid = Arrays.fromString(id);
-        if ( uuid==null || uuid.length != 16 ) throw new RuntimeException(sm.getString("staticMember.invalid.uuidLength", id));
+        if ( uuid==null || uuid.length != 16 ) {
+            throw new RuntimeException(sm.getString("staticMember.invalid.uuidLength", id));
+        }
         setUniqueId(uuid);
     }
 

==================================================
StaticMembershipService.java
index 155cf29041..f4f1ccdf24 100644
--- a/java/org/apache/catalina/tribes/membership/StaticMembershipProvider.java
+++ b/java/org/apache/catalina/tribes/membership/StaticMembershipProvider.java
@@ -137,7 +137,9 @@ public class StaticMembershipProvider extends MembershipProviderBase implements
     }
 
     protected void startMembership(Member[] members) throws ChannelException {
-        if (members.length == 0) return;
+        if (members.length == 0) {
+            return;
+        }
         MemberMessage msg = new MemberMessage(membershipId, MemberMessage.MSG_START, service.getLocalMember(true));
         Response[] resp = rpcChannel.send(members, msg, RpcChannel.ALL_REPLY, sendOptions, rpcTimeout);
         if (resp.length > 0) {
@@ -185,12 +187,16 @@ public class StaticMembershipProvider extends MembershipProviderBase implements
     }
 
     protected void memberAlive(Member member) {
-        if (!membership.contains(member)) memberAdded(member);
+        if (!membership.contains(member)) {
+            memberAdded(member);
+        }
         membership.memberAlive(member);
     }
 
     protected void stopMembership(Member[] members) {
-        if (members.length == 0 ) return;
+        if (members.length == 0 ) {
+            return;
+        }
         Member localmember = service.getLocalMember(false);
         localmember.setCommand(Member.SHUTDOWN_PAYLOAD);
         MemberMessage msg = new MemberMessage(membershipId, MemberMessage.MSG_STOP, localmember);
@@ -225,7 +231,9 @@ public class StaticMembershipProvider extends MembershipProviderBase implements
 
     @Override
     public Serializable replyRequest(Serializable msg, final Member sender) {
-        if (!(msg instanceof MemberMessage)) return null;
+        if (!(msg instanceof MemberMessage)) {
+            return null;
+        }
         MemberMessage memMsg = (MemberMessage) msg;
         if (memMsg.getMsgtype() == MemberMessage.MSG_START) {
             messageReceived(memMsg, sender);
@@ -237,16 +245,19 @@ public class StaticMembershipProvider extends MembershipProviderBase implements
             return memMsg;
         } else {
             // other messages are ignored.
-            if (log.isInfoEnabled())
+            if (log.isInfoEnabled()) {
                 log.info(sm.getString("staticMembershipProvider.replyRequest.ignored",
                         memMsg.getTypeDesc()));
+            }
             return null;
         }
     }
 
     @Override
     public void leftOver(Serializable msg, Member sender) {
-        if (!(msg instanceof MemberMessage)) return;
+        if (!(msg instanceof MemberMessage)) {
+            return;
+        }
         MemberMessage memMsg = (MemberMessage) msg;
         if (memMsg.getMsgtype() == MemberMessage.MSG_START) {
             messageReceived(memMsg, sender);
@@ -254,16 +265,19 @@ public class StaticMembershipProvider extends MembershipProviderBase implements
             messageReceived(memMsg, sender);
         } else {
             // other messages are ignored.
-            if (log.isInfoEnabled())
+            if (log.isInfoEnabled()) {
                 log.info(sm.getString("staticMembershipProvider.leftOver.ignored",
                         memMsg.getTypeDesc()));
+            }
         }
     }
 
     @Override
     public void heartbeat() {
         try {
-            if (!useThread) ping();
+            if (!useThread) {
+                ping();
+            }
         } catch (ChannelException e) {
             log.warn(sm.getString("staticMembershipProvider.heartbeat.failed"), e);
         }

==================================================
CloudMembershipProvider.java
index 299b961fb0..f48ed51ca8 100644
--- a/java/org/apache/catalina/tribes/membership/StaticMembershipService.java
+++ b/java/org/apache/catalina/tribes/membership/StaticMembershipService.java
@@ -213,16 +213,21 @@ public class StaticMembershipService extends MembershipServiceBase
 
     protected void setDefaults(Properties properties) {
         // default values
-        if (properties.getProperty("expirationTime") == null)
+        if (properties.getProperty("expirationTime") == null) {
             properties.setProperty("expirationTime","5000");
-        if (properties.getProperty("connectTimeout") == null)
+        }
+        if (properties.getProperty("connectTimeout") == null) {
             properties.setProperty("connectTimeout","500");
-        if (properties.getProperty("rpcTimeout") == null)
+        }
+        if (properties.getProperty("rpcTimeout") == null) {
             properties.setProperty("rpcTimeout","3000");
-        if (properties.getProperty("useThread") == null)
+        }
+        if (properties.getProperty("useThread") == null) {
             properties.setProperty("useThread","false");
-        if (properties.getProperty("pingInterval") == null)
+        }
+        if (properties.getProperty("pingInterval") == null) {
             properties.setProperty("pingInterval","1000");
+        }
     }
 
     private String getMembershipName() {
@@ -230,7 +235,9 @@ public class StaticMembershipService extends MembershipServiceBase
     }
 
     private void findLocalMember() throws IOException {
-        if (this.localMember != null) return;
+        if (this.localMember != null) {
+            return;
+        }
         String listenHost = properties.getProperty("tcpListenHost");
         String listenPort = properties.getProperty("tcpListenPort");
 
@@ -242,7 +249,9 @@ public class StaticMembershipService extends MembershipServiceBase
                 break;
             }
         }
-        if (this.localMember == null) throw new IllegalStateException(sm.getString("staticMembershipService.noLocalMember"));
+        if (this.localMember == null) {
+            throw new IllegalStateException(sm.getString("staticMembershipService.noLocalMember"));
+        }
         staticMembers.remove(this.localMember);
     }
 }
\ No newline at end of file

==================================================
KubernetesMembershipProvider.java
index 319d13050a..3ead2e2db3 100644
--- a/java/org/apache/catalina/tribes/membership/cloud/CloudMembershipProvider.java
+++ b/java/org/apache/catalina/tribes/membership/cloud/CloudMembershipProvider.java
@@ -76,8 +76,9 @@ public abstract class CloudMembershipProvider extends MembershipProviderBase imp
         String val = null;
         for (String key : keys) {
             val = AccessController.doPrivileged((PrivilegedAction<String>) () -> System.getenv(key));
-            if (val != null)
+            if (val != null) {
                 break;
+            }
         }
         return val;
     }

==================================================
AbstractReplicatedMap.java
index 11e0a488a8..d24c0bf0b7 100644
--- a/java/org/apache/catalina/tribes/membership/cloud/KubernetesMembershipProvider.java
+++ b/java/org/apache/catalina/tribes/membership/cloud/KubernetesMembershipProvider.java
@@ -99,8 +99,9 @@ public class KubernetesMembershipProvider extends CloudMembershipProvider {
         }
 
         String ver = getEnv(CUSTOM_ENV_PREFIX + "API_VERSION", "KUBERNETES_API_VERSION");
-        if (ver == null)
+        if (ver == null) {
             ver = "v1";
+        }
 
         String labels = getEnv(CUSTOM_ENV_PREFIX + "LABELS", "KUBERNETES_LABELS");
 

==================================================
LazyReplicatedMap.java
index 8c4199e6df..3776a85321 100644
--- a/java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java
+++ b/java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java
@@ -195,8 +195,11 @@ public abstract class AbstractReplicatedMap<K,V>
      * @return Member[]
      */
     protected Member[] wrap(Member m) {
-        if ( m == null ) return new Member[0];
-        else return new Member[] {m};
+        if ( m == null ) {
+            return new Member[0];
+        } else {
+            return new Member[] {m};
+        }
     }
 
     /**
@@ -213,7 +216,9 @@ public abstract class AbstractReplicatedMap<K,V>
     protected void init(MapOwner owner, Channel channel, String mapContextName,
             long timeout, int channelSendOptions,ClassLoader[] cls, boolean terminate) {
         long start = System.currentTimeMillis();
-        if (log.isInfoEnabled()) log.info(sm.getString("abstractReplicatedMap.init.start", mapContextName));
+        if (log.isInfoEnabled()) {
+            log.info(sm.getString("abstractReplicatedMap.init.start", mapContextName));
+        }
         this.mapOwner = owner;
         this.externalLoaders = cls;
         this.channelSendOptions = channelSendOptions;
@@ -223,7 +228,9 @@ public abstract class AbstractReplicatedMap<K,V>
         this.mapname = mapContextName;
         //unique context is more efficient if it is stored as bytes
         this.mapContextName = mapContextName.getBytes(StandardCharsets.ISO_8859_1);
-        if ( log.isTraceEnabled() ) log.trace("Created Lazy Map with name:"+mapContextName+", bytes:"+Arrays.toString(this.mapContextName));
+        if ( log.isTraceEnabled() ) {
+            log.trace("Created Lazy Map with name:"+mapContextName+", bytes:"+Arrays.toString(this.mapContextName));
+        }
 
         //create an rpc channel and add the map as a listener
         this.rpcChannel = new RpcChannel(this.mapContextName, channel, this);
@@ -248,9 +255,10 @@ public abstract class AbstractReplicatedMap<K,V>
         }
         this.state = State.INITIALIZED;
         long complete = System.currentTimeMillis() - start;
-        if (log.isInfoEnabled())
+        if (log.isInfoEnabled()) {
             log.info(sm.getString("abstractReplicatedMap.init.completed",
                     mapContextName, Long.toString(complete)));
+        }
     }
 
 
@@ -286,17 +294,19 @@ public abstract class AbstractReplicatedMap<K,V>
                             memberAlive(member);
                         } else if (state == State.STATETRANSFERRED) {
                             synchronized (mapMembers) {
-                                if (log.isInfoEnabled())
+                                if (log.isInfoEnabled()) {
                                     log.info(sm.getString("abstractReplicatedMap.ping.stateTransferredMember",
                                             member));
+                                }
                                 if (mapMembers.containsKey(member)) {
                                     mapMembers.put(member, Long.valueOf(System.currentTimeMillis()));
                                 }
                             }
                         } else {
-                            if (log.isInfoEnabled())
+                            if (log.isInfoEnabled()) {
                                 log.info(sm.getString("abstractReplicatedMap.mapMember.unavailable",
                                         member));
+                            }
                         }
                     } catch (ClassNotFoundException | IOException e) {
                         log.error(sm.getString("abstractReplicatedMap.unable.deserialize.MapMessage"), e);
@@ -345,7 +355,9 @@ public abstract class AbstractReplicatedMap<K,V>
     protected void broadcast(int msgtype, boolean rpc) throws ChannelException {
         Member[] members = channel.getMembers();
         // No destination.
-        if (members.length == 0 ) return;
+        if (members.length == 0 ) {
+            return;
+        }
         //send out a map membership message, only wait for the first reply
         MapMessage msg = new MapMessage(this.mapContextName, msgtype,
                                         false, null, null, null, channel.getLocalMember(false), null);
@@ -400,8 +412,12 @@ public abstract class AbstractReplicatedMap<K,V>
 
     @Override
     public boolean equals(Object o) {
-        if ( !(o instanceof AbstractReplicatedMap)) return false;
-        if ( !(o.getClass().equals(this.getClass())) ) return false;
+        if ( !(o instanceof AbstractReplicatedMap)) {
+            return false;
+        }
+        if ( !(o.getClass().equals(this.getClass())) ) {
+            return false;
+        }
         @SuppressWarnings("unchecked")
         AbstractReplicatedMap<K,V> other = (AbstractReplicatedMap<K,V>)o;
         return Arrays.equals(mapContextName,other.mapContextName);
@@ -428,7 +444,9 @@ public abstract class AbstractReplicatedMap<K,V>
         synchronized (mapMembers) {
             @SuppressWarnings("unchecked") // mapMembers has the correct type
             HashMap<Member, Long> list = (HashMap<Member, Long>)mapMembers.clone();
-            for (Member member : exclude) list.remove(member);
+            for (Member member : exclude) {
+                list.remove(member);
+            }
             return getMapMembers(list);
         }
     }
@@ -443,22 +461,30 @@ public abstract class AbstractReplicatedMap<K,V>
      * be replicated
      */
     public void replicate(Object key, boolean complete) {
-        if ( log.isTraceEnabled() )
+        if ( log.isTraceEnabled() ) {
             log.trace("Replicate invoked on key:"+key);
+        }
         MapEntry<K,V> entry = innerMap.get(key);
-        if ( entry == null ) return;
-        if ( !entry.isSerializable() ) return;
+        if ( entry == null ) {
+            return;
+        }
+        if ( !entry.isSerializable() ) {
+            return;
+        }
         if (entry.isPrimary() && entry.getBackupNodes()!= null && entry.getBackupNodes().length > 0) {
             //check to see if we need to replicate this object isDirty()||complete || isAccessReplicate()
             ReplicatedMapEntry rentry = null;
-            if (entry.getValue() instanceof ReplicatedMapEntry) rentry = (ReplicatedMapEntry)entry.getValue();
+            if (entry.getValue() instanceof ReplicatedMapEntry) {
+                rentry = (ReplicatedMapEntry)entry.getValue();
+            }
             boolean isDirty = rentry != null && rentry.isDirty();
             boolean isAccess = rentry != null && rentry.isAccessReplicate();
             boolean repl = complete || isDirty || isAccess;
 
             if (!repl) {
-                if ( log.isTraceEnabled() )
+                if ( log.isTraceEnabled() ) {
                     log.trace("Not replicating:"+key+", no change made");
+                }
 
                 return;
             }
@@ -495,7 +521,9 @@ public abstract class AbstractReplicatedMap<K,V>
             }
             try {
                 if ( channel!=null && entry.getBackupNodes()!= null && entry.getBackupNodes().length > 0 ) {
-                    if (rentry != null) rentry.setLastTimeReplicated(System.currentTimeMillis());
+                    if (rentry != null) {
+                        rentry.setLastTimeReplicated(System.currentTimeMillis());
+                    }
                     channel.send(entry.getBackupNodes(), msg, channelSendOptions);
                 }
             } catch (ChannelException x) {
@@ -551,7 +579,9 @@ public abstract class AbstractReplicatedMap<K,V>
      */
     @Override
     public Serializable replyRequest(Serializable msg, final Member sender) {
-        if (! (msg instanceof MapMessage))return null;
+        if (! (msg instanceof MapMessage)) {
+            return null;
+        }
         MapMessage mapmsg = (MapMessage) msg;
 
         //map init request
@@ -570,7 +600,9 @@ public abstract class AbstractReplicatedMap<K,V>
         //backup request
         if (mapmsg.getMsgType() == MapMessage.MSG_RETRIEVE_BACKUP) {
             MapEntry<K,V> entry = innerMap.get(mapmsg.getKey());
-            if (entry == null || (!entry.isSerializable()) )return null;
+            if (entry == null || (!entry.isSerializable()) ) {
+                return null;
+            }
             mapmsg.setValue( (Serializable) entry.getValue());
             return mapmsg;
         }
@@ -615,7 +647,9 @@ public abstract class AbstractReplicatedMap<K,V>
     @Override
     public void leftOver(Serializable msg, Member sender) {
         //left over membership messages
-        if (! (msg instanceof MapMessage))return;
+        if (! (msg instanceof MapMessage)) {
+            return;
+        }
 
         MapMessage mapmsg = (MapMessage) msg;
         try {
@@ -626,17 +660,19 @@ public abstract class AbstractReplicatedMap<K,V>
                 memberAlive(mapmsg.getPrimary());
             } else if (mapmsg.getMsgType() == MapMessage.MSG_PING) {
                 Member member = mapmsg.getPrimary();
-                if (log.isInfoEnabled())
+                if (log.isInfoEnabled()) {
                     log.info(sm.getString("abstractReplicatedMap.leftOver.pingMsg", member));
+                }
                 State state = (State) mapmsg.getValue();
                 if (state.isAvailable()) {
                     memberAlive(member);
                 }
             } else {
                 // other messages are ignored.
-                if (log.isInfoEnabled())
+                if (log.isInfoEnabled()) {
                     log.info(sm.getString("abstractReplicatedMap.leftOver.ignored",
                             mapmsg.getTypeDesc()));
+                }
             }
         } catch (IOException | ClassNotFoundException x) {
             log.error(sm.getString("abstractReplicatedMap.unable.deserialize.MapMessage"),x);
@@ -646,7 +682,9 @@ public abstract class AbstractReplicatedMap<K,V>
     @SuppressWarnings("unchecked")
     @Override
     public void messageReceived(Serializable msg, Member sender) {
-        if (! (msg instanceof MapMessage)) return;
+        if (! (msg instanceof MapMessage)) {
+            return;
+        }
 
         MapMessage mapmsg = (MapMessage) msg;
         if ( log.isTraceEnabled() ) {
@@ -659,8 +697,9 @@ public abstract class AbstractReplicatedMap<K,V>
             log.error(sm.getString("abstractReplicatedMap.unable.deserialize.MapMessage"), x);
             return;
         }
-        if ( log.isTraceEnabled() )
+        if ( log.isTraceEnabled() ) {
             log.trace("Map message received from:"+sender.getName()+" msg:"+mapmsg);
+        }
         if (mapmsg.getMsgType() == MapMessage.MSG_START) {
             mapMemberAdded(mapmsg.getPrimary());
         }
@@ -736,7 +775,9 @@ public abstract class AbstractReplicatedMap<K,V>
                     re.setOwner(getMapOwner());
                     entry.setValue((V) re);
                 } else {
-                    if ( mapmsg.getValue()!=null ) entry.setValue((V) mapmsg.getValue());
+                    if ( mapmsg.getValue()!=null ) {
+                        entry.setValue((V) mapmsg.getValue());
+                    }
                 } //end if
             } //end if
             innerMap.put(entry.getKey(), entry);
@@ -769,15 +810,21 @@ public abstract class AbstractReplicatedMap<K,V>
     public boolean accept(Serializable msg, Member sender) {
         boolean result = false;
         if (msg instanceof MapMessage) {
-            if ( log.isTraceEnabled() ) log.trace("Map["+mapname+"] accepting...."+msg);
+            if ( log.isTraceEnabled() ) {
+                log.trace("Map["+mapname+"] accepting...."+msg);
+            }
             result = Arrays.equals(mapContextName, ( (MapMessage) msg).getMapId());
-            if ( log.isTraceEnabled() ) log.trace("Msg["+mapname+"] accepted["+result+"]...."+msg);
+            if ( log.isTraceEnabled() ) {
+                log.trace("Msg["+mapname+"] accepted["+result+"]...."+msg);
+            }
         }
         return result;
     }
 
     public void mapMemberAdded(Member member) {
-        if ( member.equals(getChannel().getLocalMember(false)) ) return;
+        if ( member.equals(getChannel().getLocalMember(false)) ) {
+            return;
+        }
         boolean memberAdded = false;
         //select a backup node if we don't have one
         Member mapMember = getChannel().getMember(member);
@@ -787,8 +834,9 @@ public abstract class AbstractReplicatedMap<K,V>
         }
         synchronized (mapMembers) {
             if (!mapMembers.containsKey(mapMember) ) {
-                if (log.isInfoEnabled())
+                if (log.isInfoEnabled()) {
                     log.info(sm.getString("abstractReplicatedMap.mapMemberAdded.added", mapMember));
+                }
                 mapMembers.put(mapMember, Long.valueOf(System.currentTimeMillis()));
                 memberAdded = true;
             }
@@ -797,7 +845,9 @@ public abstract class AbstractReplicatedMap<K,V>
             synchronized (stateMutex) {
                 for (Entry<K, MapEntry<K, V>> e : innerMap.entrySet()) {
                     MapEntry<K,V> entry = innerMap.get(e.getKey());
-                    if ( entry == null ) continue;
+                    if ( entry == null ) {
+                        continue;
+                    }
                     if (entry.isPrimary() && (entry.getBackupNodes() == null || entry.getBackupNodes().length == 0)) {
                         try {
                             Member[] backup = publishEntryInfo(entry.getKey(), entry.getValue());
@@ -813,13 +863,16 @@ public abstract class AbstractReplicatedMap<K,V>
     }
 
     public boolean inSet(Member m, Member[] set) {
-        if ( set == null ) return false;
+        if ( set == null ) {
+            return false;
+        }
         boolean result = false;
-        for (Member member : set)
+        for (Member member : set) {
             if (m.equals(member)) {
                 result = true;
                 break;
             }
+        }
         return result;
     }
 
@@ -827,12 +880,15 @@ public abstract class AbstractReplicatedMap<K,V>
         List<Member> result = new ArrayList<>();
         for (Member member : set) {
             boolean include = true;
-            for (Member mbr : mbrs)
+            for (Member mbr : mbrs) {
                 if (mbr.equals(member)) {
                     include = false;
                     break;
                 }
-            if (include) result.add(member);
+            }
+            if (include) {
+                result.add(member);
+            }
         }
         return result.toArray(new Member[0]);
     }
@@ -848,20 +904,27 @@ public abstract class AbstractReplicatedMap<K,V>
         synchronized (mapMembers) {
             removed = (mapMembers.remove(member) != null );
             if (!removed) {
-                if (log.isDebugEnabled()) log.debug("Member["+member+"] disappeared, but was not present in the map.");
+                if (log.isDebugEnabled()) {
+                    log.debug("Member["+member+"] disappeared, but was not present in the map.");
+                }
                 return; //the member was not part of our map.
             }
         }
-        if (log.isInfoEnabled())
+        if (log.isInfoEnabled()) {
             log.info(sm.getString("abstractReplicatedMap.member.disappeared", member));
+        }
         long start = System.currentTimeMillis();
         Iterator<Map.Entry<K,MapEntry<K,V>>> i = innerMap.entrySet().iterator();
         while (i.hasNext()) {
             Map.Entry<K,MapEntry<K,V>> e = i.next();
             MapEntry<K,V> entry = innerMap.get(e.getKey());
-            if (entry==null) continue;
+            if (entry==null) {
+                continue;
+            }
             if (entry.isPrimary() && inSet(member,entry.getBackupNodes())) {
-                if (log.isDebugEnabled()) log.debug("[1] Primary choosing a new backup");
+                if (log.isDebugEnabled()) {
+                    log.debug("[1] Primary choosing a new backup");
+                }
                 try {
                     Member[] backup = publishEntryInfo(entry.getKey(), entry.getValue());
                     entry.setBackupNodes(backup);
@@ -870,7 +933,9 @@ public abstract class AbstractReplicatedMap<K,V>
                     log.error(sm.getString("abstractReplicatedMap.unable.relocate", entry.getKey()), x);
                 }
             } else if (member.equals(entry.getPrimary())) {
-                if (log.isDebugEnabled()) log.debug("[2] Primary disappeared");
+                if (log.isDebugEnabled()) {
+                    log.debug("[2] Primary disappeared");
+                }
                 entry.setPrimary(null);
             } //end if
 
@@ -880,7 +945,9 @@ public abstract class AbstractReplicatedMap<K,V>
                  entry.getBackupNodes().length == 1 &&
                  entry.getBackupNodes()[0].equals(member) ) {
                 //remove proxies that have no backup nor primaries
-                if (log.isDebugEnabled()) log.debug("[3] Removing orphaned proxy");
+                if (log.isDebugEnabled()) {
+                    log.debug("[3] Removing orphaned proxy");
+                }
                 i.remove();
             } else if ( entry.getPrimary() == null &&
                         entry.isBackup() &&
@@ -888,14 +955,18 @@ public abstract class AbstractReplicatedMap<K,V>
                         entry.getBackupNodes().length == 1 &&
                         entry.getBackupNodes()[0].equals(channel.getLocalMember(false)) ) {
                 try {
-                    if (log.isDebugEnabled()) log.debug("[4] Backup becoming primary");
+                    if (log.isDebugEnabled()) {
+                        log.debug("[4] Backup becoming primary");
+                    }
                     entry.setPrimary(channel.getLocalMember(false));
                     entry.setBackup(false);
                     entry.setProxy(false);
                     entry.setCopy(false);
                     Member[] backup = publishEntryInfo(entry.getKey(), entry.getValue());
                     entry.setBackupNodes(backup);
-                    if ( mapOwner!=null ) mapOwner.objectMadePrimary(entry.getKey(),entry.getValue());
+                    if ( mapOwner!=null ) {
+                        mapOwner.objectMadePrimary(entry.getKey(),entry.getValue());
+                    }
 
                 } catch (ChannelException x) {
                     log.error(sm.getString("abstractReplicatedMap.unable.relocate", entry.getKey()), x);
@@ -904,13 +975,17 @@ public abstract class AbstractReplicatedMap<K,V>
 
         } //while
         long complete = System.currentTimeMillis() - start;
-        if (log.isInfoEnabled()) log.info(sm.getString("abstractReplicatedMap.relocate.complete",
-                Long.toString(complete)));
+        if (log.isInfoEnabled()) {
+            log.info(sm.getString("abstractReplicatedMap.relocate.complete",
+                    Long.toString(complete)));
+        }
     }
 
     public int getNextBackupIndex() {
         int size = mapMembers.size();
-        if (mapMembers.size() == 0)return -1;
+        if (mapMembers.size() == 0) {
+            return -1;
+        }
         int node = currentNode++;
         if (node >= size) {
             node = 0;
@@ -921,8 +996,12 @@ public abstract class AbstractReplicatedMap<K,V>
     public Member getNextBackupNode() {
         Member[] members = getMapMembers();
         int node = getNextBackupIndex();
-        if ( members.length == 0 || node==-1) return null;
-        if ( node >= members.length ) node = 0;
+        if ( members.length == 0 || node==-1) {
+            return null;
+        }
+        if ( node >= members.length ) {
+            node = 0;
+        }
         return members[node];
     }
 
@@ -931,7 +1010,9 @@ public abstract class AbstractReplicatedMap<K,V>
     @Override
     public void heartbeat() {
         try {
-            if (this.state.isAvailable()) ping(accessTimeout);
+            if (this.state.isAvailable()) {
+                ping(accessTimeout);
+            }
         }catch ( Exception x ) {
             log.error(sm.getString("abstractReplicatedMap.heartbeat.failed"),x);
         }
@@ -973,8 +1054,12 @@ public abstract class AbstractReplicatedMap<K,V>
     @Override
     public V get(Object key) {
         MapEntry<K,V> entry = innerMap.get(key);
-        if (log.isTraceEnabled()) log.trace("Requesting id:"+key+" entry:"+entry);
-        if ( entry == null ) return null;
+        if (log.isTraceEnabled()) {
+            log.trace("Requesting id:"+key+" entry:"+entry);
+        }
+        if ( entry == null ) {
+            return null;
+        }
         if ( !entry.isPrimary() ) {
             //if the message is not primary, we need to retrieve the latest value
             try {
@@ -996,7 +1081,9 @@ public abstract class AbstractReplicatedMap<K,V>
                     msg = (MapMessage) resp[0].getMessage();
                     msg.deserialize(getExternalLoaders());
                     backup = entry.getBackupNodes();
-                    if ( msg.getValue()!=null ) entry.setValue((V) msg.getValue());
+                    if ( msg.getValue()!=null ) {
+                        entry.setValue((V) msg.getValue());
+                    }
 
                     // notify member
                     msg = new MapMessage(getMapContextName(), MapMessage.MSG_NOTIFY_MAPMEMBER,false,
@@ -1028,14 +1115,18 @@ public abstract class AbstractReplicatedMap<K,V>
                 entry.setBackup(false);
                 entry.setProxy(false);
                 entry.setCopy(false);
-                if ( getMapOwner()!=null ) getMapOwner().objectMadePrimary(key, entry.getValue());
+                if ( getMapOwner()!=null ) {
+                    getMapOwner().objectMadePrimary(key, entry.getValue());
+                }
 
             } catch (RuntimeException | ChannelException | ClassNotFoundException | IOException x) {
                 log.error(sm.getString("abstractReplicatedMap.unable.get"), x);
                 return null;
             }
         }
-        if (log.isTraceEnabled()) log.trace("Requesting id:"+key+" result:"+entry.getValue());
+        if (log.isTraceEnabled()) {
+            log.trace("Requesting id:"+key+" result:"+entry.getValue());
+        }
         return entry.getValue();
     }
 
@@ -1090,7 +1181,9 @@ public abstract class AbstractReplicatedMap<K,V>
         V old = null;
 
         //make sure that any old values get removed
-        if ( containsKey(key) ) old = remove(key);
+        if ( containsKey(key) ) {
+            old = remove(key);
+        }
         try {
             if ( notify ) {
                 Member[] backup = publishEntryInfo(key, value);
@@ -1138,7 +1231,9 @@ public abstract class AbstractReplicatedMap<K,V>
         Objects.requireNonNull(value);
         for (Entry<K, MapEntry<K, V>> e : innerMap.entrySet()) {
             MapEntry<K,V> entry = innerMap.get(e.getKey());
-            if (entry!=null && entry.isActive() && value.equals(entry.getValue())) return true;
+            if (entry!=null && entry.isActive() && value.equals(entry.getValue())) {
+                return true;
+            }
         }
         return false;
     }
@@ -1182,7 +1277,9 @@ public abstract class AbstractReplicatedMap<K,V>
         for (Entry<K, MapEntry<K, V>> e : innerMap.entrySet()) {
             K key = e.getKey();
             MapEntry<K,V> entry = innerMap.get(key);
-            if ( entry!=null && entry.isActive() ) set.add(key);
+            if ( entry!=null && entry.isActive() ) {
+                set.add(key);
+            }
         }
         return Collections.unmodifiableSet(set);
 
@@ -1199,7 +1296,9 @@ public abstract class AbstractReplicatedMap<K,V>
             Map.Entry<?,?> e = it.next();
             if ( e != null ) {
                 MapEntry<K,V> entry = innerMap.get(e.getKey());
-                if (entry!=null && entry.isActive() && entry.getValue() != null) counter++;
+                if (entry!=null && entry.isActive() && entry.getValue() != null) {
+                    counter++;
+                }
             }
         }
         return counter;
@@ -1215,7 +1314,9 @@ public abstract class AbstractReplicatedMap<K,V>
         List<V> values = new ArrayList<>();
         for (Entry<K, MapEntry<K, V>> e : innerMap.entrySet()) {
             MapEntry<K,V> entry = innerMap.get(e.getKey());
-            if (entry!=null && entry.isActive() && entry.getValue()!=null) values.add(entry.getValue());
+            if (entry!=null && entry.isActive() && entry.getValue()!=null) {
+                values.add(entry.getValue());
+            }
         }
         return Collections.unmodifiableCollection(values);
     }
@@ -1478,8 +1579,12 @@ public abstract class AbstractReplicatedMap<K,V>
         }
 
         public Serializable key(ClassLoader[] cls) throws IOException, ClassNotFoundException {
-            if ( key!=null ) return key;
-            if ( keydata == null || keydata.length == 0 ) return null;
+            if ( key!=null ) {
+                return key;
+            }
+            if ( keydata == null || keydata.length == 0 ) {
+                return null;
+            }
             key = XByteBuffer.deserialize(keydata,0,keydata.length,cls);
             keydata = null;
             return key;
@@ -1498,8 +1603,12 @@ public abstract class AbstractReplicatedMap<K,V>
         }
 
         public Serializable value(ClassLoader[] cls) throws IOException, ClassNotFoundException  {
-            if ( value!=null ) return value;
-            if ( valuedata == null || valuedata.length == 0 ) return null;
+            if ( value!=null ) {
+                return value;
+            }
+            if ( valuedata == null || valuedata.length == 0 ) {
+                return null;
+            }
             value = XByteBuffer.deserialize(valuedata,0,valuedata.length,cls);
             valuedata = null;
             return value;
@@ -1531,7 +1640,9 @@ public abstract class AbstractReplicatedMap<K,V>
 
         public void setValue(Serializable value) {
             try {
-                if ( value != null ) valuedata = XByteBuffer.serialize(value);
+                if ( value != null ) {
+                    valuedata = XByteBuffer.serialize(value);
+                }
                 this.value = value;
             }catch ( IOException x ) {
                 throw new RuntimeException(x);
@@ -1540,7 +1651,9 @@ public abstract class AbstractReplicatedMap<K,V>
 
         public void setKey(Serializable key) {
             try {
-                if (key != null) keydata = XByteBuffer.serialize(key);
+                if (key != null) {
+                    keydata = XByteBuffer.serialize(key);
+                }
                 this.key = key;
             } catch (IOException x) {
                 throw new RuntimeException(x);

==================================================
ReplicatedMap.java
index 280d49ef4f..72d2ba8c16 100644
--- a/java/org/apache/catalina/tribes/tipis/LazyReplicatedMap.java
+++ b/java/org/apache/catalina/tribes/tipis/LazyReplicatedMap.java
@@ -150,14 +150,18 @@ public class LazyReplicatedMap<K,V> extends AbstractReplicatedMap<K,V> {
     @Override
     protected Member[] publishEntryInfo(Object key, Object value) throws ChannelException {
         Log log = getLog();
-        if  (! (key instanceof Serializable && value instanceof Serializable)  ) return new Member[0];
+        if  (! (key instanceof Serializable && value instanceof Serializable)  ) {
+            return new Member[0];
+        }
         Member[] members = getMapMembers();
         int firstIdx = getNextBackupIndex();
         int nextIdx = firstIdx;
         Member[] backup = new Member[0];
 
         //there are no backups
-        if ( members.length == 0 || firstIdx == -1 ) return backup;
+        if ( members.length == 0 || firstIdx == -1 ) {
+            return backup;
+        }
 
         boolean success = false;
         do {
@@ -166,7 +170,9 @@ public class LazyReplicatedMap<K,V> extends AbstractReplicatedMap<K,V> {
 
             //increment for the next round of back up selection
             nextIdx = nextIdx + 1;
-            if ( nextIdx >= members.length ) nextIdx = 0;
+            if ( nextIdx >= members.length ) {
+                nextIdx = 0;
+            }
 
             if (next == null) {
                 continue;
@@ -177,11 +183,13 @@ public class LazyReplicatedMap<K,V> extends AbstractReplicatedMap<K,V> {
                 //publish the backup data to one node
                 msg = new MapMessage(getMapContextName(), MapMessage.MSG_BACKUP, false,
                                      (Serializable) key, (Serializable) value, null, channel.getLocalMember(false), tmpBackup);
-                if ( log.isTraceEnabled() )
+                if ( log.isTraceEnabled() ) {
                     log.trace("Publishing backup data:"+msg+" to: "+next.getName());
+                }
                 UniqueId id = getChannel().send(tmpBackup, msg, getChannelSendOptions());
-                if ( log.isTraceEnabled() )
+                if ( log.isTraceEnabled() ) {
                     log.trace("Data published:"+msg+" msg Id:"+id);
+                }
                 //we published out to a backup, mark the test success
                 success = true;
                 backup = tmpBackup;
@@ -195,8 +203,9 @@ public class LazyReplicatedMap<K,V> extends AbstractReplicatedMap<K,V> {
                 if (success && proxies.length > 0 ) {
                     msg = new MapMessage(getMapContextName(), MapMessage.MSG_PROXY, false,
                                          (Serializable) key, null, null, channel.getLocalMember(false),backup);
-                    if ( log.isTraceEnabled() )
+                    if ( log.isTraceEnabled() ) {
                         log.trace("Publishing proxy data:"+msg+" to: "+Arrays.toNameString(proxies));
+                    }
                     getChannel().send(proxies, msg, getChannelSendOptions());
                 }
             }catch  ( ChannelException x ) {

==================================================
AbstractSender.java
index 44536ddedd..4f2f0f85e7 100644
--- a/java/org/apache/catalina/tribes/tipis/ReplicatedMap.java
+++ b/java/org/apache/catalina/tribes/tipis/ReplicatedMap.java
@@ -138,11 +138,15 @@ public class ReplicatedMap<K,V> extends AbstractReplicatedMap<K,V> {
      */
     @Override
     protected Member[] publishEntryInfo(Object key, Object value) throws ChannelException {
-        if  (! (key instanceof Serializable && value instanceof Serializable)  ) return new Member[0];
+        if  (! (key instanceof Serializable && value instanceof Serializable)  ) {
+            return new Member[0];
+        }
         //select a backup node
         Member[] backup = getMapMembers();
 
-        if (backup == null || backup.length == 0) return null;
+        if (backup == null || backup.length == 0) {
+            return null;
+        }
 
         try {
             //publish the data out to all nodes
@@ -152,7 +156,9 @@ public class ReplicatedMap<K,V> extends AbstractReplicatedMap<K,V> {
             getChannel().send(backup, msg, getChannelSendOptions());
         } catch (ChannelException e) {
             FaultyMember[] faultyMembers = e.getFaultyMembers();
-            if (faultyMembers.length == 0) throw e;
+            if (faultyMembers.length == 0) {
+                throw e;
+            }
             List<Member> faulty = new ArrayList<>();
             for (FaultyMember faultyMember : faultyMembers) {
                 if (!(faultyMember.getCause() instanceof RemoteProcessException)) {
@@ -182,16 +188,21 @@ public class ReplicatedMap<K,V> extends AbstractReplicatedMap<K,V> {
         synchronized (mapMembers) {
             removed = (mapMembers.remove(member) != null );
             if (!removed) {
-                if (log.isDebugEnabled()) log.debug("Member["+member+"] disappeared, but was not present in the map.");
+                if (log.isDebugEnabled()) {
+                    log.debug("Member["+member+"] disappeared, but was not present in the map.");
+                }
                 return; //the member was not part of our map.
             }
         }
-        if (log.isInfoEnabled())
+        if (log.isInfoEnabled()) {
             log.info(sm.getString("replicatedMap.member.disappeared", member));
+        }
         long start = System.currentTimeMillis();
         for (Entry<K, MapEntry<K, V>> e : innerMap.entrySet()) {
             MapEntry<K,V> entry = innerMap.get(e.getKey());
-            if (entry==null) continue;
+            if (entry==null) {
+                continue;
+            }
             if (entry.isPrimary()) {
                 try {
                     Member[] backup = getMapMembers();
@@ -226,7 +237,9 @@ public class ReplicatedMap<K,V> extends AbstractReplicatedMap<K,V> {
                         getChannel().send(backup, msg, getChannelSendOptions());
                     }
                     entry.setBackupNodes(backup);
-                    if ( mapOwner!=null ) mapOwner.objectMadePrimary(entry.getKey(),entry.getValue());
+                    if ( mapOwner!=null ) {
+                        mapOwner.objectMadePrimary(entry.getKey(),entry.getValue());
+                    }
 
                 } catch (ChannelException x) {
                     log.error(sm.getString("replicatedMap.unable.relocate", entry.getKey()), x);
@@ -235,13 +248,17 @@ public class ReplicatedMap<K,V> extends AbstractReplicatedMap<K,V> {
 
         } //while
         long complete = System.currentTimeMillis() - start;
-        if (log.isInfoEnabled()) log.info(sm.getString("replicatedMap.relocate.complete",
-                Long.toString(complete)));
+        if (log.isInfoEnabled()) {
+            log.info(sm.getString("replicatedMap.relocate.complete",
+                    Long.toString(complete)));
+        }
     }
 
     @Override
     public void mapMemberAdded(Member member) {
-        if ( member.equals(getChannel().getLocalMember(false)) ) return;
+        if ( member.equals(getChannel().getLocalMember(false)) ) {
+            return;
+        }
         boolean memberAdded = false;
         synchronized (mapMembers) {
             if (!mapMembers.containsKey(member) ) {
@@ -254,7 +271,9 @@ public class ReplicatedMap<K,V> extends AbstractReplicatedMap<K,V> {
                 Member[] backup = getMapMembers();
                 for (Entry<K, MapEntry<K, V>> e : innerMap.entrySet()) {
                     MapEntry<K,V> entry = innerMap.get(e.getKey());
-                    if ( entry == null ) continue;
+                    if ( entry == null ) {
+                        continue;
+                    }
                     if (entry.isPrimary() && !inSet(member,entry.getBackupNodes())) {
                         entry.setBackupNodes(backup);
                     }

==================================================
PooledSender.java
index 77be39e6a0..b12d59a9a4 100644
--- a/java/org/apache/catalina/tribes/transport/AbstractSender.java
+++ b/java/org/apache/catalina/tribes/transport/AbstractSender.java
@@ -110,10 +110,16 @@ public abstract class AbstractSender implements DataSender {
     @Override
     public boolean keepalive() {
         boolean disconnect = false;
-        if (isUdpBased()) disconnect = true; //always disconnect UDP, TODO optimize the keepalive handling
-        else if ( keepAliveCount >= 0 && requestCount>keepAliveCount ) disconnect = true;
-        else if ( keepAliveTime >= 0 && (System.currentTimeMillis()-connectTime)>keepAliveTime ) disconnect = true;
-        if ( disconnect ) disconnect();
+        if (isUdpBased()) {
+            disconnect = true; //always disconnect UDP, TODO optimize the keepalive handling
+        } else if ( keepAliveCount >= 0 && requestCount>keepAliveCount ) {
+            disconnect = true;
+        } else if ( keepAliveTime >= 0 && (System.currentTimeMillis()-connectTime)>keepAliveTime ) {
+            disconnect = true;
+        }
+        if ( disconnect ) {
+            disconnect();
+        }
         return disconnect;
     }
 

==================================================
ReceiverBase.java
index 175fb5d2fc..bbb4370e26 100644
--- a/java/org/apache/catalina/tribes/transport/PooledSender.java
+++ b/java/org/apache/catalina/tribes/transport/PooledSender.java
@@ -160,7 +160,9 @@ public abstract class PooledSender extends AbstractSender implements MultiPointS
         public synchronized DataSender getSender(long timeout) {
             long start = System.currentTimeMillis();
             while ( true ) {
-                if (!isOpen)throw new IllegalStateException(sm.getString("pooledSender.closed.queue"));
+                if (!isOpen) {
+                    throw new IllegalStateException(sm.getString("pooledSender.closed.queue"));
+                }
                 DataSender sender = null;
                 if (notinuse.size() == 0 && inuse.size() < limit) {
                     sender = parent.getNewDataSender();
@@ -172,8 +174,9 @@ public abstract class PooledSender extends AbstractSender implements MultiPointS
                     return sender;
                 }//end if
                 long delta = System.currentTimeMillis() - start;
-                if ( delta > timeout && timeout>0) return null;
-                else {
+                if ( delta > timeout && timeout>0) {
+                    return null;
+                } else {
                     try {
                         wait(Math.max(timeout - delta,1));
                     }catch (InterruptedException x){}
@@ -189,8 +192,9 @@ public abstract class PooledSender extends AbstractSender implements MultiPointS
             //to do
             inuse.remove(sender);
             //just in case the limit has changed
-            if ( notinuse.size() < this.getLimit() ) notinuse.add(sender);
-            else
+            if ( notinuse.size() < this.getLimit() ) {
+                notinuse.add(sender);
+            } else {
                 try {
                     sender.disconnect();
                 } catch (Exception e) {
@@ -199,6 +203,7 @@ public abstract class PooledSender extends AbstractSender implements MultiPointS
                                 "PooledSender.senderDisconnectFail"), e);
                     }
                 }
+            }
             notifyAll();
         }
 

==================================================
ReplicationTransmitter.java
index dd769cd8b8..20547cccd2 100644
--- a/java/org/apache/catalina/tribes/transport/ReceiverBase.java
+++ b/java/org/apache/catalina/tribes/transport/ReceiverBase.java
@@ -99,22 +99,31 @@ public abstract class ReceiverBase implements ChannelReceiver, ListenCallback, R
         if ( executor == null ) {
             //executor = new ThreadPoolExecutor(minThreads,maxThreads,60,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>());
             String channelName = "";
-            if (channel.getName() != null) channelName = "[" + channel.getName() + "]";
+            if (channel.getName() != null) {
+                channelName = "[" + channel.getName() + "]";
+            }
             TaskThreadFactory tf = new TaskThreadFactory("Tribes-Task-Receiver" + channelName + "-");
             executor = ExecutorFactory.newThreadPool(minThreads, maxThreads, maxIdleTime, TimeUnit.MILLISECONDS, tf);
         }
         // register jmx
         JmxRegistry jmxRegistry = JmxRegistry.getRegistry(channel);
-        if (jmxRegistry != null) this.oname = jmxRegistry.registerJmx(",component=Receiver", this);
+        if (jmxRegistry != null) {
+            this.oname = jmxRegistry.registerJmx(",component=Receiver", this);
+        }
     }
 
     @Override
     public void stop() {
-        if ( executor != null ) executor.shutdownNow();//ignore left overs
+        if ( executor != null )
+         {
+            executor.shutdownNow();//ignore left overs
+        }
         executor = null;
         if (oname != null) {
             JmxRegistry jmxRegistry = JmxRegistry.getRegistry(channel);
-            if (jmxRegistry != null) jmxRegistry.unregisterJmx(oname);
+            if (jmxRegistry != null) {
+                jmxRegistry.unregisterJmx(oname);
+            }
             oname = null;
         }
         channel = null;
@@ -174,8 +183,9 @@ public abstract class ReceiverBase implements ChannelReceiver, ListenCallback, R
                 if ("auto".equals(host)) {
                     host = java.net.InetAddress.getLocalHost().getHostAddress();
                 }
-                if (log.isDebugEnabled())
+                if (log.isDebugEnabled()) {
                     log.debug("Starting replication listener on address:"+ host);
+                }
                 bind = java.net.InetAddress.getByName(host);
             } catch (IOException ioe) {
                 log.error(sm.getString("receiverBase.bind.failed", host), ioe);
@@ -258,13 +268,17 @@ public abstract class ReceiverBase implements ChannelReceiver, ListenCallback, R
     @Override
     public void messageDataReceived(ChannelMessage data) {
         if ( this.listener != null ) {
-            if ( listener.accept(data) ) listener.messageReceived(data);
+            if ( listener.accept(data) ) {
+                listener.messageReceived(data);
+            }
         }
     }
 
     public int getWorkerThreadOptions() {
         int options = 0;
-        if ( getDirect() ) options = options | OPTION_DIRECT_BUFFER;
+        if ( getDirect() ) {
+            options = options | OPTION_DIRECT_BUFFER;
+        }
         return options;
     }
 
@@ -413,7 +427,9 @@ public abstract class ReceiverBase implements ChannelReceiver, ListenCallback, R
 
     public void setAutoBind(int autoBind) {
         this.autoBind = autoBind;
-        if ( this.autoBind <= 0 ) this.autoBind = 1;
+        if ( this.autoBind <= 0 ) {
+            this.autoBind = 1;
+        }
     }
 
     public void setMaxThreads(int maxThreads) {

==================================================
RxTaskPool.java
index 2ecde8a4b3..a67cc5e71c 100644
--- a/java/org/apache/catalina/tribes/transport/ReplicationTransmitter.java
+++ b/java/org/apache/catalina/tribes/transport/ReplicationTransmitter.java
@@ -76,7 +76,9 @@ public class ReplicationTransmitter implements ChannelSender {
         getTransport().connect();
         // register jmx
         JmxRegistry jmxRegistry = JmxRegistry.getRegistry(channel);
-        if (jmxRegistry != null) this.oname = jmxRegistry.registerJmx(",component=Sender", transport);
+        if (jmxRegistry != null) {
+            this.oname = jmxRegistry.registerJmx(",component=Sender", transport);
+        }
     }
 
     /**
@@ -101,7 +103,9 @@ public class ReplicationTransmitter implements ChannelSender {
      */
     @Override
     public void heartbeat() {
-        if (getTransport()!=null) getTransport().keepalive();
+        if (getTransport()!=null) {
+            getTransport().keepalive();
+        }
     }
 
     /**

==================================================
NioReceiver.java
index 15633e92a1..a72110d05e 100644
--- a/java/org/apache/catalina/tribes/transport/RxTaskPool.java
+++ b/java/org/apache/catalina/tribes/transport/RxTaskPool.java
@@ -84,7 +84,9 @@ public class RxTaskPool {
                     }
                 }
             }//while
-            if ( worker != null ) used.add(worker);
+            if ( worker != null ) {
+                used.add(worker);
+            }
         }
         return worker;
     }
@@ -103,8 +105,9 @@ public class RxTaskPool {
             synchronized (mutex) {
                 used.remove(worker);
                 //if ( idle.size() < minThreads && !idle.contains(worker)) idle.add(worker);
-                if ( idle.size() < maxTasks && !idle.contains(worker)) idle.add(worker); //let max be the upper limit
-                else {
+                if ( idle.size() < maxTasks && !idle.contains(worker)) {
+                    idle.add(worker); //let max be the upper limit
+                } else {
                     worker.close();
                 }
                 mutex.notifyAll();

==================================================
NioReplicationTask.java
index 60633632db..cc4b9d0376 100644
--- a/java/org/apache/catalina/tribes/transport/nio/NioReceiver.java
+++ b/java/org/apache/catalina/tribes/transport/nio/NioReceiver.java
@@ -82,21 +82,29 @@ public class NioReceiver extends ReceiverBase implements Runnable, NioReceiverMB
             setPool(new RxTaskPool(getMaxThreads(),getMinThreads(),this));
         } catch (Exception x) {
             log.fatal(sm.getString("nioReceiver.threadpool.fail"), x);
-            if ( x instanceof IOException ) throw (IOException)x;
-            else throw new IOException(x.getMessage());
+            if ( x instanceof IOException ) {
+                throw (IOException)x;
+            } else {
+                throw new IOException(x.getMessage());
+            }
         }
         try {
             getBind();
             bind();
             String channelName = "";
-            if (getChannel().getName() != null) channelName = "[" + getChannel().getName() + "]";
+            if (getChannel().getName() != null) {
+                channelName = "[" + getChannel().getName() + "]";
+            }
             Thread t = new Thread(this, "NioReceiver" + channelName);
             t.setDaemon(true);
             t.start();
         } catch (Exception x) {
             log.fatal(sm.getString("nioReceiver.start.fail"), x);
-            if ( x instanceof IOException ) throw (IOException)x;
-            else throw new IOException(x.getMessage());
+            if ( x instanceof IOException ) {
+                throw (IOException)x;
+            } else {
+                throw new IOException(x.getMessage());
+            }
         }
     }
 
@@ -182,21 +190,33 @@ public class NioReceiver extends ReceiverBase implements Runnable, NioReceiverMB
         }
         key.cancel();
         key.attach(null);
-        if (key.channel() instanceof SocketChannel)
-            try { ((SocketChannel)key.channel()).socket().close(); } catch (IOException e) { if (log.isDebugEnabled()) log.debug("", e); }
-        if (key.channel() instanceof DatagramChannel)
-            try { ((DatagramChannel)key.channel()).socket().close(); } catch (Exception e) { if (log.isDebugEnabled()) log.debug("", e); }
-        try { key.channel().close(); } catch (IOException e) { if (log.isDebugEnabled()) log.debug("", e); }
+        if (key.channel() instanceof SocketChannel) {
+            try { ((SocketChannel)key.channel()).socket().close(); } catch (IOException e) { if (log.isDebugEnabled()) {
+                log.debug("", e);
+            } }
+        }
+        if (key.channel() instanceof DatagramChannel) {
+            try { ((DatagramChannel)key.channel()).socket().close(); } catch (Exception e) { if (log.isDebugEnabled()) {
+                log.debug("", e);
+            } }
+        }
+        try { key.channel().close(); } catch (IOException e) { if (log.isDebugEnabled()) {
+            log.debug("", e);
+        } }
 
     }
     protected long lastCheck = System.currentTimeMillis();
     protected void socketTimeouts() {
         long now = System.currentTimeMillis();
-        if ( (now-lastCheck) < getSelectorTimeout() ) return;
+        if ( (now-lastCheck) < getSelectorTimeout() ) {
+            return;
+        }
         //timeout
         Selector tmpsel = this.selector.get();
         Set<SelectionKey> keys =  (isListening()&&tmpsel!=null)?tmpsel.keys():null;
-        if ( keys == null ) return;
+        if ( keys == null ) {
+            return;
+        }
         for (SelectionKey key : keys) {
             try {
 //                if (key.interestOps() == SelectionKey.OP_READ) {
@@ -214,13 +234,14 @@ public class NioReceiver extends ReceiverBase implements Runnable, NioReceiverMB
                     if ( ka != null ) {
                         long delta = now - ka.getLastAccess();
                         if (delta > getTimeout() && (!ka.isAccessed())) {
-                            if (log.isWarnEnabled())
+                            if (log.isWarnEnabled()) {
                                 log.warn(sm.getString(
                                         "nioReceiver.threadsExhausted",
                                         Integer.valueOf(getTimeout()),
                                         Boolean.valueOf(ka.isCancelled()),
                                         key,
                                         new java.sql.Timestamp(ka.getLastAccess())));
+                            }
                             ka.setLastAccess(now);
                             //key.interestOps(SelectionKey.OP_READ);
                         }//end if
@@ -325,7 +346,9 @@ public class NioReceiver extends ReceiverBase implements Runnable, NioReceiverMB
             try {
                 datagramChannel.close();
             }catch (Exception iox) {
-                if (log.isDebugEnabled()) log.debug("Unable to close datagram channel.",iox);
+                if (log.isDebugEnabled()) {
+                    log.debug("Unable to close datagram channel.",iox);
+                }
             }
             datagramChannel=null;
         }
@@ -366,7 +389,9 @@ public class NioReceiver extends ReceiverBase implements Runnable, NioReceiverMB
 
     private void closeSelector() throws IOException {
         Selector selector = this.selector.getAndSet(null);
-        if (selector == null) return;
+        if (selector == null) {
+            return;
+        }
         try {
             // look at each key in the selected set
             for (SelectionKey key : selector.keys()) {
@@ -405,7 +430,10 @@ public class NioReceiver extends ReceiverBase implements Runnable, NioReceiverMB
                                    SelectableChannel channel,
                                    int ops,
                                    Object attach) throws Exception {
-        if (channel == null)return; // could happen
+        if (channel == null)
+         {
+            return; // could happen
+        }
         // set the new channel non-blocking
         channel.configureBlocking(false);
         // register it with the selector
@@ -445,7 +473,9 @@ public class NioReceiver extends ReceiverBase implements Runnable, NioReceiverMB
             // loop will keep calling this method until a
             // thread becomes available, the thread pool itself has a waiting mechanism
             // so we will not wait here.
-            if (log.isDebugEnabled()) log.debug("No TcpReplicationThread available");
+            if (log.isDebugEnabled()) {
+                log.debug("No TcpReplicationThread available");
+            }
         } else {
             // invoking this wakes up the worker thread then returns
             //add task to thread pool

==================================================
NioSender.java
index 0cb3bbdc42..62a5fa8c8e 100644
--- a/java/org/apache/catalina/tribes/transport/nio/NioReplicationTask.java
+++ b/java/org/apache/catalina/tribes/transport/nio/NioReplicationTask.java
@@ -85,18 +85,21 @@ public class NioReplicationTask extends AbstractRxTask {
         if (key == null) {
             return; // just in case
         }
-        if ( log.isTraceEnabled() )
+        if ( log.isTraceEnabled() ) {
             log.trace("Servicing key:"+key);
+        }
 
         try {
             ObjectReader reader = (ObjectReader)key.attachment();
             if ( reader == null ) {
-                if ( log.isTraceEnabled() )
+                if ( log.isTraceEnabled() ) {
                     log.trace("No object reader, cancelling:"+key);
+                }
                 cancelKey(key);
             } else {
-                if ( log.isTraceEnabled() )
+                if ( log.isTraceEnabled() ) {
                     log.trace("Draining channel:"+key);
+                }
 
                 drainChannel(key, reader);
             }
@@ -107,8 +110,11 @@ public class NioReplicationTask extends AbstractRxTask {
                 //do nothing
             } else if ( e instanceof IOException ) {
                 //don't spew out stack traces for IO exceptions unless debug is enabled.
-                if (log.isDebugEnabled()) log.debug ("IOException in replication worker, unable to drain channel. Probable cause: Keep alive socket closed["+e.getMessage()+"].", e);
-                else log.warn (sm.getString("nioReplicationTask.unable.drainChannel.ioe", e.getMessage()));
+                if (log.isDebugEnabled()) {
+                    log.debug ("IOException in replication worker, unable to drain channel. Probable cause: Keep alive socket closed["+e.getMessage()+"].", e);
+                } else {
+                    log.warn (sm.getString("nioReplicationTask.unable.drainChannel.ioe", e.getMessage()));
+                }
             } else if ( log.isErrorEnabled() ) {
                 //this is a real error, log it.
                 log.error(sm.getString("nioReplicationTask.exception.drainChannel"),e);
@@ -133,9 +139,13 @@ public class NioReplicationTask extends AbstractRxTask {
      * @param key The key to process
      */
     public synchronized void serviceChannel (SelectionKey key) {
-        if ( log.isTraceEnabled() ) log.trace("About to service key:"+key);
+        if ( log.isTraceEnabled() ) {
+            log.trace("About to service key:"+key);
+        }
         ObjectReader reader = (ObjectReader)key.attachment();
-        if ( reader != null ) reader.setLastAccess(System.currentTimeMillis());
+        if ( reader != null ) {
+            reader.setLastAccess(System.currentTimeMillis());
+        }
         this.key = key;
         key.interestOps (key.interestOps() & (~SelectionKey.OP_READ));
         key.interestOps (key.interestOps() & (~SelectionKey.OP_WRITE));
@@ -163,22 +173,26 @@ public class NioReplicationTask extends AbstractRxTask {
             // loop while data available, channel is non-blocking
             while ((count = channel.read (buffer)) > 0) {
                 buffer.flip();      // make buffer readable
-                if ( buffer.hasArray() )
+                if ( buffer.hasArray() ) {
                     reader.append(buffer.array(),0,count,false);
-                else
+                } else {
                     reader.append(buffer,count,false);
+                }
                 buffer.clear();     // make buffer empty
                 //do we have at least one package?
-                if ( reader.hasPackage() ) break;
+                if ( reader.hasPackage() ) {
+                    break;
+                }
             }
         } else if (channel instanceof DatagramChannel) {
             DatagramChannel dchannel = (DatagramChannel)channel;
             saddr = dchannel.receive(buffer);
             buffer.flip();      // make buffer readable
-            if ( buffer.hasArray() )
+            if ( buffer.hasArray() ) {
                 reader.append(buffer.array(),0,buffer.limit()-buffer.position(),false);
-            else
+            } else {
                 reader.append(buffer,buffer.limit()-buffer.position(),false);
+            }
             buffer.clear();     // make buffer empty
             //did we get a package
             count = reader.hasPackage()?1:-1;
@@ -219,16 +233,21 @@ public class NioReplicationTask extends AbstractRxTask {
                  * server before sending the ack to the remote server
                  * This is considered a synchronized request
                  */
-                if (ChannelData.sendAckSync(msg.getOptions()))
+                if (ChannelData.sendAckSync(msg.getOptions())) {
                     sendAck(key, (WritableByteChannel) channel, Constants.ACK_COMMAND, saddr);
+                }
             } catch (RemoteProcessException e) {
-                if (log.isDebugEnabled()) log.error(sm.getString("nioReplicationTask.process.clusterMsg.failed"), e);
-                if (ChannelData.sendAckSync(msg.getOptions()))
+                if (log.isDebugEnabled()) {
+                    log.error(sm.getString("nioReplicationTask.process.clusterMsg.failed"), e);
+                }
+                if (ChannelData.sendAckSync(msg.getOptions())) {
                     sendAck(key, (WritableByteChannel) channel, Constants.FAIL_ACK_COMMAND, saddr);
+                }
             } catch (Exception e) {
                 log.error(sm.getString("nioReplicationTask.process.clusterMsg.failed"), e);
-                if (ChannelData.sendAckSync(msg.getOptions()))
+                if (ChannelData.sendAckSync(msg.getOptions())) {
                     sendAck(key, (WritableByteChannel) channel, Constants.FAIL_ACK_COMMAND, saddr);
+                }
             }
             if (getUseBufferPool()) {
                 BufferPool.getBufferPool().returnBuffer(msg.getMessage());
@@ -243,13 +262,16 @@ public class NioReplicationTask extends AbstractRxTask {
 
     private void remoteEof(SelectionKey key) {
         // close channel on EOF, invalidates the key
-        if ( log.isDebugEnabled() ) log.debug("Channel closed on the remote end, disconnecting");
+        if ( log.isDebugEnabled() ) {
+            log.debug("Channel closed on the remote end, disconnecting");
+        }
         cancelKey(key);
     }
 
     protected void registerForRead(final SelectionKey key, ObjectReader reader) {
-        if ( log.isTraceEnabled() )
+        if ( log.isTraceEnabled() ) {
             log.trace("Adding key for read event:"+key);
+        }
         reader.finish();
         //register our OP_READ interest
         Runnable r = () -> {
@@ -260,13 +282,15 @@ public class NioReplicationTask extends AbstractRxTask {
                     // resume interest in OP_READ, OP_WRITE
                     int resumeOps = key.interestOps() | SelectionKey.OP_READ;
                     key.interestOps(resumeOps);
-                    if ( log.isTraceEnabled() )
+                    if ( log.isTraceEnabled() ) {
                         log.trace("Registering key for read:"+key);
+                    }
                 }
             } catch (CancelledKeyException ckx ) {
                 NioReceiver.cancelledKey(key);
-                if ( log.isTraceEnabled() )
+                if ( log.isTraceEnabled() ) {
                     log.trace("CKX Cancelling key:"+key);
+                }
 
             } catch (Exception x) {
                 log.error(sm.getString("nioReplicationTask.error.register.key", key),x);
@@ -276,8 +300,9 @@ public class NioReplicationTask extends AbstractRxTask {
     }
 
     private void cancelKey(final SelectionKey key) {
-        if ( log.isTraceEnabled() )
+        if ( log.isTraceEnabled() ) {
             log.trace("Adding key for cancel event:"+key);
+        }
 
         ObjectReader reader = (ObjectReader)key.attachment();
         if ( reader != null ) {
@@ -285,8 +310,9 @@ public class NioReplicationTask extends AbstractRxTask {
             reader.finish();
         }
         Runnable cx = () -> {
-            if ( log.isTraceEnabled() )
+            if ( log.isTraceEnabled() ) {
                 log.trace("Cancelling key:"+key);
+            }
 
             NioReceiver.cancelledKey(key);
         };

==================================================
ParallelNioSender.java
index 6354deeac4..9b2e8bdf8d 100644
--- a/java/org/apache/catalina/tribes/transport/nio/NioSender.java
+++ b/java/org/apache/catalina/tribes/transport/nio/NioSender.java
@@ -85,12 +85,18 @@ public class NioSender extends AbstractSender {
         int ops = key.readyOps();
         key.interestOps(key.interestOps() & ~ops);
         //in case disconnect has been called
-        if ((!isConnected()) && (!connecting)) throw new IOException(sm.getString("nioSender.sender.disconnected"));
-        if ( !key.isValid() ) throw new IOException(sm.getString("nioSender.key.inValid"));
+        if ((!isConnected()) && (!connecting)) {
+            throw new IOException(sm.getString("nioSender.sender.disconnected"));
+        }
+        if ( !key.isValid() ) {
+            throw new IOException(sm.getString("nioSender.key.inValid"));
+        }
         if ( key.isConnectable() ) {
             if ( socketChannel.finishConnect() ) {
                 completeConnect();
-                if ( current != null ) key.interestOps(key.interestOps() | SelectionKey.OP_WRITE);
+                if ( current != null ) {
+                    key.interestOps(key.interestOps() | SelectionKey.OP_WRITE);
+                }
                 return false;
             } else  {
                 //wait for the connection to finish
@@ -167,12 +173,16 @@ public class NioSender extends AbstractSender {
 
     protected boolean read() throws IOException {
         //if there is no message here, we are done
-        if ( current == null ) return true;
+        if ( current == null ) {
+            return true;
+        }
         int read = isUdpBased()?dataChannel.read(readbuf) : socketChannel.read(readbuf);
         //end of stream
-        if ( read == -1 ) throw new IOException(sm.getString("nioSender.unable.receive.ack"));
-        //no data read
-        else if ( read == 0 ) return false;
+        if ( read == -1 ) {
+            throw new IOException(sm.getString("nioSender.unable.receive.ack"));
+        } else if ( read == 0 ) {
+            return false;
+        }
         readbuf.flip();
         ackbuf.append(readbuf,read);
         readbuf.clear();
@@ -180,7 +190,9 @@ public class NioSender extends AbstractSender {
             byte[] ackcmd = ackbuf.extractDataPackage(true).getBytes();
             boolean ack = Arrays.equals(ackcmd,org.apache.catalina.tribes.transport.Constants.ACK_DATA);
             boolean fack = Arrays.equals(ackcmd,org.apache.catalina.tribes.transport.Constants.FAIL_ACK_DATA);
-            if ( fack && getThrowOnFailedAck() ) throw new RemoteProcessException(sm.getString("nioSender.receive.failedAck"));
+            if ( fack && getThrowOnFailedAck() ) {
+                throw new RemoteProcessException(sm.getString("nioSender.receive.failedAck"));
+            }
             return ack || fack;
         } else {
             return false;
@@ -197,7 +209,9 @@ public class NioSender extends AbstractSender {
                 //we have written everything, or we are starting a new package
                 //protect against buffer overwrite
                 int byteswritten = isUdpBased()?dataChannel.write(writebuf) : socketChannel.write(writebuf);
-                if (byteswritten == -1 ) throw new EOFException();
+                if (byteswritten == -1 ) {
+                    throw new EOFException();
+                }
                 remaining -= byteswritten;
                 //if the entire message was written from the buffer
                 //reset the position counter
@@ -219,9 +233,13 @@ public class NioSender extends AbstractSender {
      */
     @Override
     public synchronized void connect() throws IOException {
-        if ( connecting || isConnected()) return;
+        if ( connecting || isConnected()) {
+            return;
+        }
         connecting = true;
-        if ( isConnected() ) throw new IOException(sm.getString("nioSender.already.connected"));
+        if ( isConnected() ) {
+            throw new IOException(sm.getString("nioSender.already.connected"));
+        }
         if ( readbuf == null ) {
             readbuf = getReadBuffer();
         } else {
@@ -235,7 +253,9 @@ public class NioSender extends AbstractSender {
 
         if (isUdpBased()) {
             InetSocketAddress daddr = new InetSocketAddress(getAddress(),getUdpPort());
-            if ( dataChannel != null ) throw new IOException(sm.getString("nioSender.datagram.already.established"));
+            if ( dataChannel != null ) {
+                throw new IOException(sm.getString("nioSender.datagram.already.established"));
+            }
             dataChannel = DatagramChannel.open();
             configureSocket();
             dataChannel.connect(daddr);
@@ -244,7 +264,9 @@ public class NioSender extends AbstractSender {
 
         } else {
             InetSocketAddress addr = new InetSocketAddress(getAddress(),getPort());
-            if ( socketChannel != null ) throw new IOException(sm.getString("nioSender.socketChannel.already.established"));
+            if ( socketChannel != null ) {
+                throw new IOException(sm.getString("nioSender.socketChannel.already.established"));
+            }
             socketChannel = SocketChannel.open();
             configureSocket();
             if ( socketChannel.connect(addr) ) {
@@ -309,7 +331,9 @@ public class NioSender extends AbstractSender {
             }
         } catch ( Exception x ) {
             log.error(sm.getString("nioSender.unable.disconnect", x.getMessage()));
-            if ( log.isDebugEnabled() ) log.debug(sm.getString("nioSender.unable.disconnect", x.getMessage()),x);
+            if ( log.isDebugEnabled() ) {
+                log.debug(sm.getString("nioSender.unable.disconnect", x.getMessage()),x);
+            }
         }
     }
 
@@ -317,8 +341,12 @@ public class NioSender extends AbstractSender {
         if ( isConnected() && readbuf == null) {
             readbuf = getReadBuffer();
         }
-        if ( readbuf != null ) readbuf.clear();
-        if ( writebuf != null ) writebuf.clear();
+        if ( readbuf != null ) {
+            readbuf.clear();
+        }
+        if ( writebuf != null ) {
+            writebuf.clear();
+        }
         current = null;
         ackbuf.clear();
         remaining = 0;
@@ -369,10 +397,11 @@ public class NioSender extends AbstractSender {
                 writebuf.put(data,offset,length);
                 writebuf.flip();
                 if (isConnected()) {
-                    if (isUdpBased())
+                    if (isUdpBased()) {
                         dataChannel.register(getSelector(), SelectionKey.OP_WRITE, this);
-                    else
+                    } else {
                         socketChannel.register(getSelector(), SelectionKey.OP_WRITE, this);
+                    }
                 }
             }
         }

==================================================
PooledParallelSender.java
index e6e5bdb18f..0d250f9654 100644
--- a/java/org/apache/catalina/tribes/transport/nio/ParallelNioSender.java
+++ b/java/org/apache/catalina/tribes/transport/nio/ParallelNioSender.java
@@ -79,14 +79,22 @@ public class ParallelNioSender extends AbstractSender implements MultiPointSende
                     remaining -= result.getCompleted();
                     if (result.getFailed() != null) {
                         remaining -= result.getFailed().getFaultyMembers().length;
-                        if (cx == null) cx = result.getFailed();
-                        else cx.addFaultyMember(result.getFailed().getFaultyMembers());
+                        if (cx == null) {
+                            cx = result.getFailed();
+                        } else {
+                            cx.addFaultyMember(result.getFailed().getFaultyMembers());
+                        }
                     }
                 } catch (Exception x ) {
-                    if (log.isTraceEnabled()) log.trace("Error sending message", x);
+                    if (log.isTraceEnabled()) {
+                        log.trace("Error sending message", x);
+                    }
                     if (cx == null) {
-                        if ( x instanceof ChannelException ) cx = (ChannelException)x;
-                        else cx = new ChannelException(sm.getString("parallelNioSender.send.failed"), x);
+                        if ( x instanceof ChannelException ) {
+                            cx = (ChannelException)x;
+                        } else {
+                            cx = new ChannelException(sm.getString("parallelNioSender.send.failed"), x);
+                        }
                     }
                     for (NioSender sender : senders) {
                         if (!sender.isComplete()) {
@@ -121,8 +129,11 @@ public class ParallelNioSender extends AbstractSender implements MultiPointSende
             } catch (Exception e) {
                 // Ignore
             }
-            if ( x instanceof ChannelException ) throw (ChannelException)x;
-            else throw new ChannelException(x);
+            if ( x instanceof ChannelException ) {
+                throw (ChannelException)x;
+            } else {
+                throw new ChannelException(x);
+            }
         }
 
     }
@@ -171,13 +182,16 @@ public class ParallelNioSender extends AbstractSender implements MultiPointSende
                 synchronized (state) {
 
                     //sk.cancel();
-                    if (state.isSuspect()) state.setFailing();
+                    if (state.isSuspect()) {
+                        state.setFailing();
+                    }
                     if (state.isReady()) {
                         state.setSuspect();
-                        if ( retry )
+                        if ( retry ) {
                             log.warn(sm.getString("parallelNioSender.send.fail.retrying", sender.getDestination().getName()));
-                        else
+                        } else {
                             log.warn(sm.getString("parallelNioSender.send.fail", sender.getDestination().getName()), x);
+                        }
                     }
                 }
                 if ( !isConnected() ) {
@@ -215,13 +229,17 @@ public class ParallelNioSender extends AbstractSender implements MultiPointSende
         private List<NioSender> completeSenders = new ArrayList<>();
         private ChannelException exception = null;
         private void complete(NioSender sender) {
-            if (!completeSenders.contains(sender)) completeSenders.add(sender);
+            if (!completeSenders.contains(sender)) {
+                completeSenders.add(sender);
+            }
         }
         private int getCompleted() {
             return completeSenders.size();
         }
         private void failed(ChannelException cx){
-            if (exception == null) exception = cx;
+            if (exception == null) {
+                exception = cx;
+            }
             exception.addFaultyMember(cx.getFaultyMembers());
         }
 
@@ -236,11 +254,15 @@ public class ParallelNioSender extends AbstractSender implements MultiPointSende
             try {
                 sender.connect();
             } catch (IOException io) {
-                if (x == null) x = new ChannelException(io);
+                if (x == null) {
+                    x = new ChannelException(io);
+                }
                 x.addFaultyMember(sender.getDestination(), io);
             }
         }
-        if ( x != null ) throw x;
+        if ( x != null ) {
+            throw x;
+        }
     }
 
     private void setData(NioSender[] senders, byte[] data) throws ChannelException {
@@ -249,11 +271,15 @@ public class ParallelNioSender extends AbstractSender implements MultiPointSende
             try {
                 sender.setMessage(data);
             } catch (IOException io) {
-                if (x == null) x = new ChannelException(io);
+                if (x == null) {
+                    x = new ChannelException(io);
+                }
                 x.addFaultyMember(sender.getDestination(), io);
             }
         }
-        if ( x != null ) throw x;
+        if ( x != null ) {
+            throw x;
+        }
     }
 
 
@@ -275,12 +301,17 @@ public class ParallelNioSender extends AbstractSender implements MultiPointSende
                 sender.setUdpBased(isUdpBased());
                 result[i] = sender;
             }catch ( UnknownHostException x ) {
-                if (cx == null) cx = new ChannelException(sm.getString("parallelNioSender.unable.setup.NioSender"), x);
+                if (cx == null) {
+                    cx = new ChannelException(sm.getString("parallelNioSender.unable.setup.NioSender"), x);
+                }
                 cx.addFaultyMember(destination[i], x);
             }
         }
-        if ( cx != null ) throw cx;
-        else return result;
+        if ( cx != null ) {
+            throw cx;
+        } else {
+            return result;
+        }
     }
 
     @Override
@@ -299,12 +330,16 @@ public class ParallelNioSender extends AbstractSender implements MultiPointSende
                 NioSender sender = nioSenders.get(mbr);
                 sender.disconnect();
             } catch (Exception e) {
-                if (x == null) x = new ChannelException(e);
+                if (x == null) {
+                    x = new ChannelException(e);
+                }
                 x.addFaultyMember(mbr, e);
             }
             nioSenders.remove(mbr);
         }
-        if ( x != null ) throw x;
+        if ( x != null ) {
+            throw x;
+        }
     }
 
     @Override
@@ -316,7 +351,9 @@ public class ParallelNioSender extends AbstractSender implements MultiPointSende
     public void remove(Member member) {
         //disconnect senders
         NioSender sender = nioSenders.remove(member);
-        if ( sender != null ) sender.disconnect();
+        if ( sender != null ) {
+            sender.disconnect();
+        }
     }
 
 
@@ -368,7 +405,9 @@ public class ParallelNioSender extends AbstractSender implements MultiPointSende
             }
         }
         //clean up any cancelled keys
-        if ( result ) try { selector.selectNow(); }catch (Exception e){/*Ignore*/}
+        if ( result ) {
+            try { selector.selectNow(); }catch (Exception e){/*Ignore*/}
+        }
         return result;
     }
 }

==================================================
Arrays.java
index 4abc3ddd38..0db604b719 100644
--- a/java/org/apache/catalina/tribes/transport/nio/PooledParallelSender.java
+++ b/java/org/apache/catalina/tribes/transport/nio/PooledParallelSender.java
@@ -39,12 +39,15 @@ public class PooledParallelSender extends PooledSender implements PooledParallel
             ChannelException cx = new ChannelException(sm.getString(
                     "pooledParallelSender.unable.retrieveSender.timeout",
                     Long.toString(getMaxWait())));
-            for (Member member : destination)
+            for (Member member : destination) {
                 cx.addFaultyMember(member, new NullPointerException(sm.getString("pooledParallelSender.unable.retrieveSender")));
+            }
             throw cx;
         } else {
             try {
-                if (!sender.isConnected()) sender.connect();
+                if (!sender.isConnected()) {
+                    sender.connect();
+                }
                 sender.sendMessage(destination, message);
                 sender.keepalive();
             } catch (ChannelException x) {

==================================================
ExecutorFactory.java
index 547654531d..2bf317cafb 100644
--- a/java/org/apache/catalina/tribes/util/Arrays.java
+++ b/java/org/apache/catalina/tribes/util/Arrays.java
@@ -34,11 +34,19 @@ public class Arrays {
     protected static final StringManager sm = StringManager.getManager(Arrays.class);
 
     public static boolean contains(byte[] source, int srcoffset, byte[] key, int keyoffset, int length) {
-        if ( srcoffset < 0 || srcoffset >= source.length) throw new ArrayIndexOutOfBoundsException(sm.getString("arrays.srcoffset.outOfBounds"));
-        if ( keyoffset < 0 || keyoffset >= key.length) throw new ArrayIndexOutOfBoundsException(sm.getString("arrays.keyoffset.outOfBounds"));
-        if ( length > (key.length-keyoffset) ) throw new ArrayIndexOutOfBoundsException(sm.getString("arrays.length.outOfBounds"));
+        if ( srcoffset < 0 || srcoffset >= source.length) {
+            throw new ArrayIndexOutOfBoundsException(sm.getString("arrays.srcoffset.outOfBounds"));
+        }
+        if ( keyoffset < 0 || keyoffset >= key.length) {
+            throw new ArrayIndexOutOfBoundsException(sm.getString("arrays.keyoffset.outOfBounds"));
+        }
+        if ( length > (key.length-keyoffset) ) {
+            throw new ArrayIndexOutOfBoundsException(sm.getString("arrays.length.outOfBounds"));
+        }
         //we don't have enough data to validate it
-        if ( length > (source.length-srcoffset) ) return false;
+        if ( length > (source.length-srcoffset) ) {
+            return false;
+        }
         boolean match = true;
         int pos = keyoffset;
         for ( int i=srcoffset; match && i<length; i++ ) {
@@ -109,7 +117,9 @@ public class Arrays {
 
     public static int add(int[] data) {
         int result = 0;
-        for (int datum : data) result += datum;
+        for (int datum : data) {
+            result += datum;
+        }
         return result;
     }
 
@@ -127,7 +137,11 @@ public class Arrays {
 
     public static boolean equals(Object[] o1, Object[] o2) {
         boolean result = o1.length == o2.length;
-        if ( result ) for (int i=0; i<o1.length && result; i++ ) result = o1[i].equals(o2[i]);
+        if ( result ) {
+            for (int i=0; i<o1.length && result; i++ ) {
+                result = o1[i].equals(o2[i]);
+            }
+        }
         return result;
     }
 
@@ -141,7 +155,11 @@ public class Arrays {
         AbsoluteOrder.absoluteOrder(m1);
         AbsoluteOrder.absoluteOrder(m2);
         ArrayList<Member> list = new ArrayList<>(java.util.Arrays.asList(m1));
-        for (Member member : m2) if (!list.contains(member)) list.add(member);
+        for (Member member : m2) {
+            if (!list.contains(member)) {
+                list.add(member);
+            }
+        }
         Member[] result = new Member[list.size()];
         list.toArray(result);
         AbsoluteOrder.absoluteOrder(result);
@@ -149,15 +167,21 @@ public class Arrays {
     }
 
     public static void fill(Membership mbrship, Member[] m) {
-        for (Member member : m) mbrship.addMember(member);
+        for (Member member : m) {
+            mbrship.addMember(member);
+        }
     }
 
     public static Member[] diff(Membership complete, Membership local, Member ignore) {
         List<Member> result = new ArrayList<>();
         Member[] comp = complete.getMembers();
         for (Member member : comp) {
-            if (ignore != null && ignore.equals(member)) continue;
-            if (local.getMember(member) == null) result.add(member);
+            if (ignore != null && ignore.equals(member)) {
+                continue;
+            }
+            if (local.getMember(member) == null) {
+                result.add(member);
+            }
         }
         return result.toArray(new Member[0]);
     }
@@ -169,27 +193,35 @@ public class Arrays {
     public static Member[] extract(Member[] all, Member[] remove) {
         List<Member> alist = java.util.Arrays.asList(all);
         ArrayList<Member> list = new ArrayList<>(alist);
-        for (Member member : remove) list.remove(member);
+        for (Member member : remove) {
+            list.remove(member);
+        }
         return list.toArray(new Member[0]);
     }
 
     public static int indexOf(Member member, Member[] members) {
         int result = -1;
-        for (int i=0; (result==-1) && (i<members.length); i++ )
-            if ( member.equals(members[i]) ) result = i;
+        for (int i=0; (result==-1) && (i<members.length); i++ ) {
+            if ( member.equals(members[i]) ) {
+                result = i;
+            }
+        }
         return result;
     }
 
     public static int nextIndex(Member member, Member[] members) {
         int idx = indexOf(member,members)+1;
-        if (idx >= members.length ) idx = ((members.length>0)?0:-1);
+        if (idx >= members.length ) {
+            idx = ((members.length>0)?0:-1);
+        }
 
         return idx;
     }
 
     public static int hashCode(byte a[]) {
-        if (a == null)
+        if (a == null) {
             return 0;
+        }
 
         int result = 1;
         for (byte element : a) {
@@ -199,11 +231,17 @@ public class Arrays {
     }
 
     public static byte[] fromString(String value) {
-        if ( value == null ) return null;
-        if ( !value.startsWith("{") ) throw new RuntimeException(sm.getString("arrays.malformed.arrays"));
+        if ( value == null ) {
+            return null;
+        }
+        if ( !value.startsWith("{") ) {
+            throw new RuntimeException(sm.getString("arrays.malformed.arrays"));
+        }
         StringTokenizer t = new StringTokenizer(value,"{,}",false);
         byte[] result = new byte[t.countTokens()];
-        for (int i=0; i<result.length; i++ ) result[i] = Byte.parseByte(t.nextToken());
+        for (int i=0; i<result.length; i++ ) {
+            result[i] = Byte.parseByte(t.nextToken());
+        }
         return result;
     }
 

==================================================
UUIDGenerator.java
index b1241cfc36..e2f197d19b 100644
--- a/java/org/apache/catalina/tribes/util/ExecutorFactory.java
+++ b/java/org/apache/catalina/tribes/util/ExecutorFactory.java
@@ -106,14 +106,22 @@ public class ExecutorFactory {
         @Override
         public boolean offer(Runnable o) {
             //we can't do any checks
-            if (parent==null) return super.offer(o);
+            if (parent==null) {
+                return super.offer(o);
+            }
             //we are maxed out on threads, simply queue the object
-            if (parent.getPoolSize() == parent.getMaximumPoolSize()) return super.offer(o);
+            if (parent.getPoolSize() == parent.getMaximumPoolSize()) {
+                return super.offer(o);
+            }
             //we have idle threads, just add it to the queue
             //this is an approximation, so it could use some tuning
-            if (parent.getActiveCount()<(parent.getPoolSize())) return super.offer(o);
+            if (parent.getActiveCount()<(parent.getPoolSize())) {
+                return super.offer(o);
+            }
             //if we have less threads than maximum force creation of a new thread
-            if (parent.getPoolSize()<parent.getMaximumPoolSize()) return false;
+            if (parent.getPoolSize()<parent.getMaximumPoolSize()) {
+                return false;
+            }
             //if we reached here, we need to add it to the queue
             return super.offer(o);
         }

==================================================
