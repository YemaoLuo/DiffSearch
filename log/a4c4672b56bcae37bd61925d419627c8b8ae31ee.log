a4c4672b56bcae37bd61925d419627c8b8ae31ee
==================================================
Revert r1523988.
==================================================
Mark Emlyn
==================================================
Tue Sep 17 12:51:17 2013 +0000
==================================================
BeanELResolver.java
Revert r1523988.
Using java.beans.expression was a lot simpler in terms of code volume but it failed to handle varargs correctly and triggered some unit test failures.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1524019 13f79535-47bb-0310-9956-ffa450edef68



==================================================
StaticFieldELResolver.java
index 2add4b6b1e..8a6c02f132 100644
--- a/java/javax/el/BeanELResolver.java
+++ b/java/javax/el/BeanELResolver.java
@@ -166,16 +166,16 @@ public class BeanELResolver extends ELResolver {
 
         String methodName = (String) factory.coerceToType(method, String.class);
 
-        java.beans.Expression beanExpression =
-                new java.beans.Expression(base, methodName, params);
+        // Find the matching method
+        Method matchingMethod =
+                Util.findMethod(base.getClass(), methodName, paramTypes, params);
 
-        Object result;
+        Object[] parameters = Util.buildParameters(
+                matchingMethod.getParameterTypes(), matchingMethod.isVarArgs(),
+                params);
+
+        Object result = null;
         try {
-            result = beanExpression.getValue();
-        } catch (Exception e) {
-            throw new ELException(e);
-        }
-/*        try {
             result = matchingMethod.invoke(base, parameters);
         } catch (IllegalArgumentException | IllegalAccessException e) {
             throw new ELException(e);
@@ -184,7 +184,7 @@ public class BeanELResolver extends ELResolver {
             Util.handleThrowable(cause);
             throw new ELException(cause);
         }
-*/
+
         context.setPropertyResolved(base, method);
         return result;
     }

==================================================
Util.java
index 9482679a1a..bf761b160b 100644
--- a/java/javax/el/StaticFieldELResolver.java
+++ b/java/javax/el/StaticFieldELResolver.java
@@ -17,7 +17,10 @@
 package javax.el;
 
 import java.beans.FeatureDescriptor;
+import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.util.Iterator;
 
@@ -89,29 +92,61 @@ public class StaticFieldELResolver extends ELResolver {
             throw new NullPointerException();
         }
 
-        Object result = null;
-
         if (base instanceof ELClass && method instanceof String) {
             context.setPropertyResolved(base, method);
 
+            Class<?> clazz = ((ELClass) base).getKlass();
             String methodName = (String) method;
+
             if ("<init>".equals(methodName)) {
-                // java.beans.Expression uses 'new' for constructors
-                methodName = "new";
-            }
-            Class<?> clazz = ((ELClass) base).getKlass();
+                Constructor<?> match =
+                        Util.findConstructor(clazz, paramTypes, params);
+
+                Object[] parameters = Util.buildParameters(
+                        match.getParameterTypes(), match.isVarArgs(), params);
+
+                Object result = null;
+
+                try {
+                    result = match.newInstance(parameters);
+                } catch (IllegalArgumentException | IllegalAccessException |
+                        InstantiationException e) {
+                    throw new ELException(e);
+                } catch (InvocationTargetException e) {
+                    Throwable cause = e.getCause();
+                    Util.handleThrowable(cause);
+                    throw new ELException(cause);
+                }
+                return result;
 
-            java.beans.Expression beanExpression =
-                    new java.beans.Expression(clazz, methodName, params);
+            } else {
+                Method match =
+                        Util.findMethod(clazz, methodName, paramTypes, params);
+
+                int modifiers = match.getModifiers();
+                if (!Modifier.isStatic(modifiers)) {
+                    throw new MethodNotFoundException(Util.message(context,
+                            "staticFieldELResolver.methodNotFound", methodName,
+                            clazz.getName()));
+                }
 
-            try {
-                result = beanExpression.getValue();
-            } catch (Exception e) {
-                throw new ELException(e);
+                Object[] parameters = Util.buildParameters(
+                        match.getParameterTypes(), match.isVarArgs(), params);
+
+                Object result = null;
+                try {
+                    result = match.invoke(null, parameters);
+                } catch (IllegalArgumentException | IllegalAccessException e) {
+                    throw new ELException(e);
+                } catch (InvocationTargetException e) {
+                    Throwable cause = e.getCause();
+                    Util.handleThrowable(cause);
+                    throw new ELException(cause);
+                }
+                return result;
             }
         }
-
-        return result;
+        return null;
     }
 
     @Override

==================================================
