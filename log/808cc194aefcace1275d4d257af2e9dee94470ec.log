808cc194aefcace1275d4d257af2e9dee94470ec
==================================================
- Prevent recursive invocation of Runnables by Room.invokeAndWait() to prevent errors like ConcurrentModificationException when Room.broadcastRoomMessage() iterates over an ArrayList and then calls Room.invokeAndWait() recursivly, iterating again over the array.
==================================================
Konstantin Prei√üer
==================================================
Tue Oct 22 23:29:14 2013 +0000
==================================================
Client.java
- Prevent recursive invocation of Runnables by Room.invokeAndWait() to prevent errors like ConcurrentModificationException when Room.broadcastRoomMessage() iterates over an ArrayList and then calls Room.invokeAndWait() recursivly, iterating again over the array.
- Add comment about blocking Session.close() method.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1534846 13f79535-47bb-0310-9956-ffa450edef68



==================================================
DrawboardEndpoint.java
index bd55c8af70..2ccbc68673 100644
--- a/webapps/examples/WEB-INF/classes/websocket/drawboard/Client.java
+++ b/webapps/examples/WEB-INF/classes/websocket/drawboard/Client.java
@@ -105,6 +105,17 @@ public class Client {
                                 CloseCodes.VIOLATED_POLICY,
                                 "Send Buffer exceeded");
                         try {
+                            // TODO: close() may block if the remote endpoint doesn't read the data
+                            // (eventually there will be a TimeoutException). However, this method
+                            // (sendMessage) is intended to run asynchronous code and shouldn't
+                            // block. Otherwise it would temporarily stop processing of messages
+                            // from other clients.
+                            // Maybe call this method on another thread.
+                            // Note that when this method is called, the RemoteEndpoint.Async
+                            // is still in the process of sending data, so there probably should
+                            // be another way to abort the Websocket connection.
+                            // Ideally, there should be some abort() method that cancels the
+                            // connection immediately...
                             session.close(cr);
                         } catch (IOException e) {
                             // Ignore
@@ -184,6 +195,21 @@ public class Client {
     private final SendHandler sendHandler = new SendHandler() {
         @Override
         public void onResult(SendResult result) {
+            if (!result.isOK()) {
+                // Message could not be sent. In this case, we don't
+                // set isSendingMessage to false because we must assume the connection
+                // broke (and onClose will be called), so we don't try to send
+                // other messages.
+                // As a precaution, we close the session (e.g. if a send timeout occured).
+                // TODO: session.close() blocks, while this handler shouldn't block.
+                // Ideally, there should be some abort() method that cancels the
+                // connection immediately...
+                try {
+                    session.close();
+                } catch (IOException ex) {
+                    // Ignore
+                }
+            }
             synchronized (messagesToSend) {
 
                 if (!messagesToSend.isEmpty()) {

==================================================
Room.java
index 0c7abe8262..63e0bb0ab6 100644
--- a/webapps/examples/WEB-INF/classes/websocket/drawboard/DrawboardEndpoint.java
+++ b/webapps/examples/WEB-INF/classes/websocket/drawboard/DrawboardEndpoint.java
@@ -123,6 +123,11 @@ public final class DrawboardEndpoint extends Endpoint {
                         if (player != null) {
                             // Remove this player from the room.
                             player.removeFromRoom();
+
+                            // Set player to null to prevent NPEs when onMessage events
+                            // are processed (from other threads) after onClose has been
+                            // called from different thread which closed the Websocket session.
+                            player = null;
                         }
                     } catch (RuntimeException ex) {
                         log.error("Unexpected exception: " + ex.toString(), ex);

==================================================
