569df636fac49e74dfe806c162be92f480d16d75
==================================================
Convert ActionCode to an enum.
==================================================
Mark Emlyn
==================================================
Mon Sep 13 20:23:22 2010 +0000
==================================================
FormAuthenticator.java
Convert ActionCode to an enum.
Shorten all the names by removing ACTION_ from the beginning. We have to use ActionCode.XXX to ACTION_ is just wasted screen space.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@996677 13f79535-47bb-0310-9956-ffa450edef68



==================================================
SSLAuthenticator.java
index e199ca5da3..721129c139 100644
--- a/java/org/apache/catalina/authenticator/FormAuthenticator.java
+++ b/java/org/apache/catalina/authenticator/FormAuthenticator.java
@@ -460,7 +460,7 @@ public class FormAuthenticator
             
             if (body != null) {
                 request.getCoyoteRequest().action
-                    (ActionCode.ACTION_REQ_SET_BODY_REPLAY, body);
+                    (ActionCode.REQ_SET_BODY_REPLAY, body);
     
                 // Set content type
                 MessageBytes contentType = MessageBytes.newInstance();

==================================================
CoyoteAdapter.java
index fb5dc654ef..821d367dba 100644
--- a/java/org/apache/catalina/authenticator/SSLAuthenticator.java
+++ b/java/org/apache/catalina/authenticator/SSLAuthenticator.java
@@ -133,7 +133,7 @@ public class SSLAuthenticator
             request.getAttribute(Globals.CERTIFICATES_ATTR);
         if ((certs == null) || (certs.length < 1)) {
             request.getCoyoteRequest().action
-                              (ActionCode.ACTION_REQ_SSL_CERTIFICATE, null);
+                              (ActionCode.REQ_SSL_CERTIFICATE, null);
             certs = (X509Certificate[])
                 request.getAttribute(Globals.CERTIFICATES_ATTR);
         }

==================================================
InputBuffer.java
index fbda3870ee..5627d8cafd 100644
--- a/java/org/apache/catalina/connector/CoyoteAdapter.java
+++ b/java/org/apache/catalina/connector/CoyoteAdapter.java
@@ -221,7 +221,7 @@ public class CoyoteAdapter implements Adapter {
                     error = true;
                     connector.getService().getContainer().getPipeline().getFirst().event(request, response, request.getEvent());
                 }
-                res.action(ActionCode.ACTION_COMET_END, null);
+                res.action(ActionCode.COMET_END, null);
             } else if (!error && read && request.getAvailable()) {
                 // If this was a read and not all bytes have been read, or if no data
                 // was read from the connector, then it is an error
@@ -285,7 +285,7 @@ public class CoyoteAdapter implements Adapter {
                     }
                 } else if (impl.getState()==AsyncContextImpl.AsyncState.STARTED){
                     //TODO SERVLET3 - async
-                    res.action(ActionCode.ACTION_ASYNC_START, request.getAsyncContext());
+                    res.action(ActionCode.ASYNC_START, request.getAsyncContext());
                     async = true;
                     break;
                 } else if (impl.getState()==AsyncContextImpl.AsyncState.NOT_STARTED){
@@ -311,11 +311,11 @@ public class CoyoteAdapter implements Adapter {
                         // Invoke a read event right away if there are available bytes
                         if (event(req, res, SocketStatus.OPEN)) {
                             comet = true;
-                            res.action(ActionCode.ACTION_COMET_BEGIN, null);
+                            res.action(ActionCode.COMET_BEGIN, null);
                         }
                     } else {
                         comet = true;
-                        res.action(ActionCode.ACTION_COMET_BEGIN, null);
+                        res.action(ActionCode.COMET_BEGIN, null);
                     }
                 } else {
                     // Clear the filter chain, as otherwise it will not be reset elsewhere
@@ -325,7 +325,7 @@ public class CoyoteAdapter implements Adapter {
             }
             if (!async && !comet) {
                 response.finishResponse();
-                req.action(ActionCode.ACTION_POST_REQUEST , null);
+                req.action(ActionCode.POST_REQUEST , null);
             }
 
         } catch (IOException e) {
@@ -406,11 +406,11 @@ public class CoyoteAdapter implements Adapter {
                             // Invoke a read event right away if there are available bytes
                             if (event(req, res, SocketStatus.OPEN)) {
                                 comet = true;
-                                res.action(ActionCode.ACTION_COMET_BEGIN, null);
+                                res.action(ActionCode.COMET_BEGIN, null);
                             }
                         } else {
                             comet = true;
-                            res.action(ActionCode.ACTION_COMET_BEGIN, null);
+                            res.action(ActionCode.COMET_BEGIN, null);
                         }
                     } else {
                         // Clear the filter chain, as otherwise it will not be reset elsewhere
@@ -422,17 +422,17 @@ public class CoyoteAdapter implements Adapter {
             }
             AsyncContextImpl asyncConImpl = (AsyncContextImpl)request.getAsyncContext();
             if (asyncConImpl!=null && asyncConImpl.getState()==AsyncContextImpl.AsyncState.STARTED) {
-                res.action(ActionCode.ACTION_ASYNC_START, request.getAsyncContext());
+                res.action(ActionCode.ASYNC_START, request.getAsyncContext());
                 async = true;
             } else if (request.isAsyncDispatching()) {
                 asyncDispatch(req, res, SocketStatus.OPEN);
                 if (request.isAsyncStarted()) {
                     async = true;
-                    res.action(ActionCode.ACTION_ASYNC_START, request.getAsyncContext());
+                    res.action(ActionCode.ASYNC_START, request.getAsyncContext());
                 }
             } else if (!comet) {
                 response.finishResponse();
-                req.action(ActionCode.ACTION_POST_REQUEST , null);
+                req.action(ActionCode.POST_REQUEST , null);
             }
 
         } catch (IOException e) {
@@ -587,7 +587,7 @@ public class CoyoteAdapter implements Adapter {
             serverName = req.localName();
             if (serverName.isNull()) {
                 // well, they did ask for it
-                res.action(ActionCode.ACTION_REQ_LOCAL_NAME_ATTRIBUTE, null);
+                res.action(ActionCode.REQ_LOCAL_NAME_ATTRIBUTE, null);
             }
         } else {
             serverName = req.serverName();

==================================================
OutputBuffer.java
index f6f656d2a8..6e18a14062 100644
--- a/java/org/apache/catalina/connector/InputBuffer.java
+++ b/java/org/apache/catalina/connector/InputBuffer.java
@@ -253,7 +253,7 @@ public class InputBuffer extends Reader
             available = cb.getLength();
         }
         if (available == 0) {
-            coyoteRequest.action(ActionCode.ACTION_AVAILABLE, null);
+            coyoteRequest.action(ActionCode.AVAILABLE, null);
             available = (coyoteRequest.getAvailable() > 0) ? 1 : 0;
         }
         return available;

==================================================
Request.java
index 25e78928e1..ef3460f58d 100644
--- a/java/org/apache/catalina/connector/OutputBuffer.java
+++ b/java/org/apache/catalina/connector/OutputBuffer.java
@@ -314,7 +314,7 @@ public class OutputBuffer extends Writer
         doFlush = false;
 
         if (realFlush) {
-            coyoteResponse.action(ActionCode.ACTION_CLIENT_FLUSH, 
+            coyoteResponse.action(ActionCode.CLIENT_FLUSH, 
                                   coyoteResponse);
             // If some exception occurred earlier, or if some IOE occurred
             // here, notify the servlet with an IOE

==================================================
AsyncContextImpl.java
index 2b7bdce539..a8949bc274 100644
--- a/java/org/apache/catalina/connector/Request.java
+++ b/java/org/apache/catalina/connector/Request.java
@@ -922,7 +922,7 @@ public class Request
         if(attr != null)
             return attr;
         if( isSSLAttribute(name) ) {
-            coyoteRequest.action(ActionCode.ACTION_REQ_SSL_ATTRIBUTE, 
+            coyoteRequest.action(ActionCode.REQ_SSL_ATTRIBUTE, 
                                  coyoteRequest);
             attr = coyoteRequest.getAttribute(Globals.CERTIFICATES_ATTR);
             if( attr != null) {
@@ -1224,7 +1224,7 @@ public class Request
     public String getRemoteAddr() {
         if (remoteAddr == null) {
             coyoteRequest.action
-                (ActionCode.ACTION_REQ_HOST_ADDR_ATTRIBUTE, coyoteRequest);
+                (ActionCode.REQ_HOST_ADDR_ATTRIBUTE, coyoteRequest);
             remoteAddr = coyoteRequest.remoteAddr().toString();
         }
         return remoteAddr;
@@ -1240,7 +1240,7 @@ public class Request
                 remoteHost = getRemoteAddr();
             } else {
                 coyoteRequest.action
-                    (ActionCode.ACTION_REQ_HOST_ATTRIBUTE, coyoteRequest);
+                    (ActionCode.REQ_HOST_ATTRIBUTE, coyoteRequest);
                 remoteHost = coyoteRequest.remoteHost().toString();
             }
         }
@@ -1254,7 +1254,7 @@ public class Request
     public int getRemotePort(){
         if (remotePort == -1) {
             coyoteRequest.action
-                (ActionCode.ACTION_REQ_REMOTEPORT_ATTRIBUTE, coyoteRequest);
+                (ActionCode.REQ_REMOTEPORT_ATTRIBUTE, coyoteRequest);
             remotePort = coyoteRequest.getRemotePort();
         }
         return remotePort;    
@@ -1267,7 +1267,7 @@ public class Request
     public String getLocalName(){
         if (localName == null) {
             coyoteRequest.action
-                (ActionCode.ACTION_REQ_LOCAL_NAME_ATTRIBUTE, coyoteRequest);
+                (ActionCode.REQ_LOCAL_NAME_ATTRIBUTE, coyoteRequest);
             localName = coyoteRequest.localName().toString();
         }
         return localName;
@@ -1280,7 +1280,7 @@ public class Request
     public String getLocalAddr(){
         if (localAddr == null) {
             coyoteRequest.action
-                (ActionCode.ACTION_REQ_LOCAL_ADDR_ATTRIBUTE, coyoteRequest);
+                (ActionCode.REQ_LOCAL_ADDR_ATTRIBUTE, coyoteRequest);
             localAddr = coyoteRequest.localAddr().toString();
         }
         return localAddr;    
@@ -1294,7 +1294,7 @@ public class Request
     public int getLocalPort(){
         if (localPort == -1){
             coyoteRequest.action
-                (ActionCode.ACTION_REQ_LOCALPORT_ATTRIBUTE, coyoteRequest);
+                (ActionCode.REQ_LOCALPORT_ATTRIBUTE, coyoteRequest);
             localPort = coyoteRequest.getLocalPort();
         }
         return localPort;
@@ -2381,11 +2381,11 @@ public class Request
     }
 
     public void cometClose() {
-        coyoteRequest.action(ActionCode.ACTION_COMET_CLOSE,getEvent());
+        coyoteRequest.action(ActionCode.COMET_CLOSE,getEvent());
     }
     
     public void setCometTimeout(long timeout) {
-        coyoteRequest.action(ActionCode.ACTION_COMET_SETTIMEOUT,new Long(timeout));
+        coyoteRequest.action(ActionCode.COMET_SETTIMEOUT,new Long(timeout));
     }
     
     /**

==================================================
ActionCode.java
index bcc61b5248..8eb52c8aed 100644
--- a/java/org/apache/catalina/core/AsyncContextImpl.java
+++ b/java/org/apache/catalina/core/AsyncContextImpl.java
@@ -90,7 +90,7 @@ public class AsyncContextImpl implements AsyncContext {
                    state.compareAndSet(AsyncState.TIMING_OUT_NEED_COMPLETE,
                            AsyncState.COMPLETING)) {
             AtomicBoolean dispatched = new AtomicBoolean(false);
-            request.getCoyoteRequest().action(ActionCode.ACTION_ASYNC_COMPLETE,
+            request.getCoyoteRequest().action(ActionCode.ASYNC_COMPLETE,
                     dispatched);
             if (!dispatched.get()) doInternalComplete(false);
         } else {
@@ -152,7 +152,7 @@ public class AsyncContextImpl implements AsyncContext {
             };
             this.dispatch = run;
             AtomicBoolean dispatched = new AtomicBoolean(false);
-            request.getCoyoteRequest().action(ActionCode.ACTION_ASYNC_DISPATCH, dispatched );
+            request.getCoyoteRequest().action(ActionCode.ASYNC_DISPATCH, dispatched );
             if (!dispatched.get()) {
                 try {
                     doInternalDispatch();
@@ -398,7 +398,7 @@ public class AsyncContextImpl implements AsyncContext {
     @Override
     public void setTimeout(long timeout) {
         this.timeout = timeout;
-        request.getCoyoteRequest().action(ActionCode.ACTION_ASYNC_SETTIMEOUT,
+        request.getCoyoteRequest().action(ActionCode.ASYNC_SETTIMEOUT,
                 Long.valueOf(timeout));
     }
     

==================================================
RequestInfo.java
index a2b7b3eb87..971877bcd0 100644
--- a/java/org/apache/coyote/ActionCode.java
+++ b/java/org/apache/coyote/ActionCode.java
@@ -14,188 +14,139 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
- 
-package org.apache.coyote;
 
+package org.apache.coyote;
 
 /**
- * Enumerated class containing the adapter event codes.
- * Actions represent callbacks from the servlet container to the coyote
- * connector.
- *
- * Actions are implemented by ProtocolHandler, using the ActionHook interface.
- *
+ * ActionCodes represent callbacks from the servlet container to the coyote
+ * connector. Actions are implemented by ProtocolHandler, using the ActionHook
+ * interface.
+ * 
  * @see ProtocolHandler
  * @see ActionHook
  * @author Remy Maucherat
  */
-public final class ActionCode {
-
-
-    // -------------------------------------------------------------- Constants
-
-
-    public static final ActionCode ACTION_ACK = new ActionCode(1);
-
-
-    public static final ActionCode ACTION_CLOSE = new ActionCode(2);
-
-
-    public static final ActionCode ACTION_COMMIT = new ActionCode(3);
-
+public enum ActionCode {
+    ACK,
+    CLOSE,
+    COMMIT,
 
     /**
-     * A flush() operation originated by the client ( i.e. a flush() on
-     * the servlet output stream or writer, called by a servlet ).
-     * 
-     * Argument is the Response.
+     * A flush() operation originated by the client ( i.e. a flush() on the
+     * servlet output stream or writer, called by a servlet ). Argument is the
+     * Response.
      */
-    public static final ActionCode ACTION_CLIENT_FLUSH = new ActionCode(4);
-
-    
-    public static final ActionCode ACTION_CUSTOM = new ActionCode(5);
-
-
-    public static final ActionCode ACTION_RESET = new ActionCode(6);
-
-
-    public static final ActionCode ACTION_START = new ActionCode(7);
+    CLIENT_FLUSH,
 
+    CUSTOM,
+    RESET,
+    START,
+    STOP,
+    WEBAPP,
 
-    public static final ActionCode ACTION_STOP = new ActionCode(8);
-
-
-    public static final ActionCode ACTION_WEBAPP = new ActionCode(9);
-
-    /** Hook called after request, but before recycling. Can be used
-        for logging, to update counters, custom cleanup - the request
-        is still visible
-    */
-    public static final ActionCode ACTION_POST_REQUEST = new ActionCode(10);
+    /**
+     * Hook called after request, but before recycling. Can be used for logging,
+     * to update counters, custom cleanup - the request is still visible
+     */
+    POST_REQUEST,
 
     /**
      * Callback for lazy evaluation - extract the remote host address.
      */
-    public static final ActionCode ACTION_REQ_HOST_ATTRIBUTE = 
-        new ActionCode(11);
-
+    REQ_HOST_ATTRIBUTE,
 
     /**
-     * Callback for lazy evaluation - extract the remote host infos (address, name, port) and local address.
+     * Callback for lazy evaluation - extract the remote host infos (address,
+     * name, port) and local address.
      */
-    public static final ActionCode ACTION_REQ_HOST_ADDR_ATTRIBUTE = new ActionCode(12);
+    REQ_HOST_ADDR_ATTRIBUTE,
 
     /**
      * Callback for lazy evaluation - extract the SSL-related attributes.
      */
-    public static final ActionCode ACTION_REQ_SSL_ATTRIBUTE = new ActionCode(13);
-
+    REQ_SSL_ATTRIBUTE,
 
-    /** Chain for request creation. Called each time a new request is created
-        ( requests are recycled ).
+    /**
+     * Chain for request creation. Called each time a new request is created
+     * (requests are recycled).
      */
-    public static final ActionCode ACTION_NEW_REQUEST = new ActionCode(14);
-
+    NEW_REQUEST,
 
     /**
-     * Callback for lazy evaluation - extract the SSL-certificate 
-     * (including forcing a re-handshake if necessary)
+     * Callback for lazy evaluation - extract the SSL-certificate (including
+     * forcing a re-handshake if necessary)
      */
-    public static final ActionCode ACTION_REQ_SSL_CERTIFICATE = new ActionCode(15);
-    
-    
+    REQ_SSL_CERTIFICATE,
+
     /**
      * Callback for lazy evaluation - socket remote port.
-     **/
-    public static final ActionCode ACTION_REQ_REMOTEPORT_ATTRIBUTE = new ActionCode(16);
+     */
+    REQ_REMOTEPORT_ATTRIBUTE,
 
-    
     /**
      * Callback for lazy evaluation - socket local port.
-     **/
-    public static final ActionCode ACTION_REQ_LOCALPORT_ATTRIBUTE = new ActionCode(17);
-    
-    
+     */
+    REQ_LOCALPORT_ATTRIBUTE,
+
     /**
      * Callback for lazy evaluation - local address.
-     **/
-    public static final ActionCode ACTION_REQ_LOCAL_ADDR_ATTRIBUTE = new ActionCode(18);
-    
-    
+     */
+    REQ_LOCAL_ADDR_ATTRIBUTE,
+
     /**
      * Callback for lazy evaluation - local address.
-     **/
-    public static final ActionCode ACTION_REQ_LOCAL_NAME_ATTRIBUTE = new ActionCode(19);
-
+     */
+    REQ_LOCAL_NAME_ATTRIBUTE,
 
     /**
      * Callback for setting FORM auth body replay
      */
-    public static final ActionCode ACTION_REQ_SET_BODY_REPLAY = new ActionCode(20);
-
+    REQ_SET_BODY_REPLAY,
 
     /**
      * Callback for begin Comet processing
      */
-    public static final ActionCode ACTION_COMET_BEGIN = new ActionCode(21);
-
+    COMET_BEGIN,
 
     /**
      * Callback for end Comet processing
      */
-    public static final ActionCode ACTION_COMET_END = new ActionCode(22);
-
+    COMET_END,
 
     /**
      * Callback for getting the amount of available bytes
      */
-    public static final ActionCode ACTION_AVAILABLE = new ActionCode(23);
+    AVAILABLE,
 
     /**
      * Callback for an asynchronous close of the Comet event
      */
-    public static final ActionCode ACTION_COMET_CLOSE = new ActionCode(24);
+    COMET_CLOSE,
 
     /**
      * Callback for setting the timeout asynchronously
      */
-    public static final ActionCode ACTION_COMET_SETTIMEOUT = new ActionCode(25);
-    
+    COMET_SETTIMEOUT,
+
     /**
      * Callback for an async request
      */
-    public static final ActionCode ACTION_ASYNC_START = new ActionCode(26);
-    
-    /**
-     * Callback for an async call to {@link javax.servlet.AsyncContext#complete()}
-     */
-    public static final ActionCode ACTION_ASYNC_COMPLETE = new ActionCode(27);
+    ASYNC_START,
+
     /**
-     * Callback for an async call to {@link javax.servlet.AsyncContext#setTimeout(long)}
+     * Callback for an async call to
+     * {@link javax.servlet.AsyncContext#complete()}
      */
-    public static final ActionCode ACTION_ASYNC_SETTIMEOUT = new ActionCode(28);
-    
+    ASYNC_COMPLETE,
     /**
-     * Callback for an async call to {@link javax.servlet.AsyncContext#dispatch()}
+     * Callback for an async call to
+     * {@link javax.servlet.AsyncContext#setTimeout(long)}
      */
-    public static final ActionCode ACTION_ASYNC_DISPATCH = new ActionCode(29);
-    
-    
-    // ----------------------------------------------------------- Constructors
-    int code;
+    ASYNC_SETTIMEOUT,
 
     /**
-     * Private constructor.
-     */
-    private ActionCode(int code) {
-        this.code=code;
-    }
-
-    /** Action id, usable in switches and table indexes
+     * Callback for an async call to
+     * {@link javax.servlet.AsyncContext#dispatch()}
      */
-    public int getCode() {
-        return code;
-    }
-
-
+    ASYNC_DISPATCH,
 }

==================================================
Response.java
index 5df4a4182d..ee8c0b3625 100644
--- a/java/org/apache/coyote/RequestInfo.java
+++ b/java/org/apache/coyote/RequestInfo.java
@@ -94,7 +94,7 @@ public class RequestInfo  {
     }
 
     public String getRemoteAddr() {
-        req.action(ActionCode.ACTION_REQ_HOST_ADDR_ATTRIBUTE, null);
+        req.action(ActionCode.REQ_HOST_ADDR_ATTRIBUTE, null);
         return req.remoteAddr().toString();
     }
 

==================================================
AjpAprProcessor.java
index 12a7ef1bd8..ed1b33b864 100644
--- a/java/org/apache/coyote/Response.java
+++ b/java/org/apache/coyote/Response.java
@@ -297,17 +297,17 @@ public final class Response {
             throw new IllegalStateException();
         }
         
-        action(ActionCode.ACTION_RESET, this);
+        action(ActionCode.RESET, this);
     }
 
 
     public void finish() throws IOException {
-        action(ActionCode.ACTION_CLOSE, this);
+        action(ActionCode.CLOSE, this);
     }
 
 
     public void acknowledge() throws IOException {
-        action(ActionCode.ACTION_ACK, this);
+        action(ActionCode.ACK, this);
     }
 
 
@@ -376,7 +376,7 @@ public final class Response {
      *  interceptors to fix headers.
      */
     public void sendHeaders() throws IOException {
-        action(ActionCode.ACTION_COMMIT, this);
+        action(ActionCode.COMMIT, this);
         commited = true;
     }
 

==================================================
AjpAprProtocol.java
index 103b147b8a..b452b512da 100644
--- a/java/org/apache/coyote/ajp/AjpAprProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpAprProcessor.java
@@ -541,7 +541,7 @@ public class AjpAprProcessor implements ActionHook {
      */
     public void action(ActionCode actionCode, Object param) {
 
-        if (actionCode == ActionCode.ACTION_COMMIT) {
+        if (actionCode == ActionCode.COMMIT) {
 
             if (response.isCommitted())
                 return;
@@ -554,7 +554,7 @@ public class AjpAprProcessor implements ActionHook {
                 error = true;
             }
 
-        } else if (actionCode == ActionCode.ACTION_CLIENT_FLUSH) {
+        } else if (actionCode == ActionCode.CLIENT_FLUSH) {
 
             if (!response.isCommitted()) {
                 // Validate and write response headers
@@ -579,7 +579,7 @@ public class AjpAprProcessor implements ActionHook {
                 error = true;
             }
 
-        } else if (actionCode == ActionCode.ACTION_CLOSE) {
+        } else if (actionCode == ActionCode.CLOSE) {
             // Close
             async = false;
 
@@ -593,15 +593,15 @@ public class AjpAprProcessor implements ActionHook {
                 error = true;
             }
 
-        } else if (actionCode == ActionCode.ACTION_START) {
+        } else if (actionCode == ActionCode.START) {
 
             started = true;
 
-        } else if (actionCode == ActionCode.ACTION_STOP) {
+        } else if (actionCode == ActionCode.STOP) {
 
             started = false;
 
-        } else if (actionCode == ActionCode.ACTION_REQ_SSL_ATTRIBUTE ) {
+        } else if (actionCode == ActionCode.REQ_SSL_ATTRIBUTE ) {
 
             if (!certificates.isNull()) {
                 ByteChunk certData = certificates.getByteChunk();
@@ -634,7 +634,7 @@ public class AjpAprProcessor implements ActionHook {
                 request.setAttribute(AbstractEndpoint.CERTIFICATE_KEY, jsseCerts);
             }
 
-        } else if (actionCode == ActionCode.ACTION_REQ_HOST_ATTRIBUTE) {
+        } else if (actionCode == ActionCode.REQ_HOST_ATTRIBUTE) {
 
             // Get remote host name using a DNS resolution
             if (request.remoteHost().isNull()) {
@@ -646,12 +646,12 @@ public class AjpAprProcessor implements ActionHook {
                 }
             }
 
-        } else if (actionCode == ActionCode.ACTION_REQ_LOCAL_ADDR_ATTRIBUTE) {
+        } else if (actionCode == ActionCode.REQ_LOCAL_ADDR_ATTRIBUTE) {
 
             // Copy from local name for now, which should simply be an address
             request.localAddr().setString(request.localName().toString());
 
-        } else if (actionCode == ActionCode.ACTION_REQ_SET_BODY_REPLAY) {
+        } else if (actionCode == ActionCode.REQ_SET_BODY_REPLAY) {
 
             // Set the given bytes as the content
             ByteChunk bc = (ByteChunk) param;
@@ -662,9 +662,9 @@ public class AjpAprProcessor implements ActionHook {
             empty = false;
             replay = true;
 
-        } else if (actionCode == ActionCode.ACTION_ASYNC_START) {
+        } else if (actionCode == ActionCode.ASYNC_START) {
             async = true;
-        } else if (actionCode == ActionCode.ACTION_ASYNC_COMPLETE) {
+        } else if (actionCode == ActionCode.ASYNC_COMPLETE) {
             AtomicBoolean dispatch = (AtomicBoolean)param;
             RequestInfo rp = request.getRequestProcessor();
             if ( rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE ) { //async handling
@@ -673,12 +673,12 @@ public class AjpAprProcessor implements ActionHook {
             } else {
                 dispatch.set(false);
             }        
-        } else if (actionCode == ActionCode.ACTION_ASYNC_SETTIMEOUT) {
+        } else if (actionCode == ActionCode.ASYNC_SETTIMEOUT) {
             if (param==null) return;
             if (socket==0) return;
             long timeout = ((Long)param).longValue();
             Socket.timeoutSet(socket, timeout * 1000); 
-        } else if (actionCode == ActionCode.ACTION_ASYNC_DISPATCH) {
+        } else if (actionCode == ActionCode.ASYNC_DISPATCH) {
            RequestInfo rp = request.getRequestProcessor();
             AtomicBoolean dispatch = (AtomicBoolean)param;
             if ( rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE ) {//async handling

==================================================
AjpProcessor.java
index e8184a6674..6dc73af967 100644
--- a/java/org/apache/coyote/ajp/AjpAprProtocol.java
+++ b/java/org/apache/coyote/ajp/AjpAprProtocol.java
@@ -396,7 +396,7 @@ public class AjpAprProtocol
                     processor = createProcessor();
                 }
 
-                processor.action(ActionCode.ACTION_START, null);
+                processor.action(ActionCode.START, null);
 
                 if (processor.process(socket)) {
                     connections.put(Long.valueOf(socket), processor);
@@ -427,7 +427,7 @@ public class AjpAprProtocol
                 AjpAprProtocol.log.error
                     (sm.getString("ajpprotocol.proto.error"), e);
             } finally {
-                processor.action(ActionCode.ACTION_STOP, null);
+                processor.action(ActionCode.STOP, null);
                 recycledProcessors.offer(processor);
             }
             return SocketState.CLOSED;

==================================================
AjpProtocol.java
index 9b983ebbec..a8709f9601 100644
--- a/java/org/apache/coyote/ajp/AjpProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpProcessor.java
@@ -550,7 +550,7 @@ public class AjpProcessor implements ActionHook {
      */
     public void action(ActionCode actionCode, Object param) {
 
-        if (actionCode == ActionCode.ACTION_COMMIT) {
+        if (actionCode == ActionCode.COMMIT) {
 
             if (response.isCommitted())
                 return;
@@ -563,7 +563,7 @@ public class AjpProcessor implements ActionHook {
                 error = true;
             }
 
-        } else if (actionCode == ActionCode.ACTION_CLIENT_FLUSH) {
+        } else if (actionCode == ActionCode.CLIENT_FLUSH) {
 
             if (!response.isCommitted()) {
                 // Validate and write response headers
@@ -583,7 +583,7 @@ public class AjpProcessor implements ActionHook {
                 error = true;
             }
 
-        } else if (actionCode == ActionCode.ACTION_CLOSE) {
+        } else if (actionCode == ActionCode.CLOSE) {
             // Close
             async = false;
             // End the processing of the current request, and stop any further
@@ -596,15 +596,15 @@ public class AjpProcessor implements ActionHook {
                 error = true;
             }
 
-        } else if (actionCode == ActionCode.ACTION_START) {
+        } else if (actionCode == ActionCode.START) {
 
             started = true;
 
-        } else if (actionCode == ActionCode.ACTION_STOP) {
+        } else if (actionCode == ActionCode.STOP) {
 
             started = false;
 
-        } else if (actionCode == ActionCode.ACTION_REQ_SSL_ATTRIBUTE ) {
+        } else if (actionCode == ActionCode.REQ_SSL_ATTRIBUTE ) {
 
             if (!certificates.isNull()) {
                 ByteChunk certData = certificates.getByteChunk();
@@ -637,7 +637,7 @@ public class AjpProcessor implements ActionHook {
                 request.setAttribute(AbstractEndpoint.CERTIFICATE_KEY, jsseCerts);
             }
 
-        } else if (actionCode == ActionCode.ACTION_REQ_HOST_ATTRIBUTE) {
+        } else if (actionCode == ActionCode.REQ_HOST_ATTRIBUTE) {
 
             // Get remote host name using a DNS resolution
             if (request.remoteHost().isNull()) {
@@ -649,12 +649,12 @@ public class AjpProcessor implements ActionHook {
                 }
             }
 
-        } else if (actionCode == ActionCode.ACTION_REQ_LOCAL_ADDR_ATTRIBUTE) {
+        } else if (actionCode == ActionCode.REQ_LOCAL_ADDR_ATTRIBUTE) {
 
             // Copy from local name for now, which should simply be an address
             request.localAddr().setString(request.localName().toString());
 
-        } else if (actionCode == ActionCode.ACTION_REQ_SET_BODY_REPLAY) {
+        } else if (actionCode == ActionCode.REQ_SET_BODY_REPLAY) {
 
             // Set the given bytes as the content
             ByteChunk bc = (ByteChunk) param;
@@ -665,10 +665,10 @@ public class AjpProcessor implements ActionHook {
             empty = false;
             replay = true;
 
-        }  else if (actionCode == ActionCode.ACTION_ASYNC_START) {
+        }  else if (actionCode == ActionCode.ASYNC_START) {
             //TODO SERVLET3 - async
             async = true;
-        } else if (actionCode == ActionCode.ACTION_ASYNC_COMPLETE) {
+        } else if (actionCode == ActionCode.ASYNC_COMPLETE) {
           //TODO SERVLET3 - async
             AtomicBoolean dispatch = (AtomicBoolean)param;
             RequestInfo rp = request.getRequestProcessor();
@@ -678,13 +678,13 @@ public class AjpProcessor implements ActionHook {
             } else {
                 dispatch.set(false);
             }
-        } else if (actionCode == ActionCode.ACTION_ASYNC_SETTIMEOUT) {
+        } else if (actionCode == ActionCode.ASYNC_SETTIMEOUT) {
           //TODO SERVLET3 - async
             if (param==null) return;
             long timeout = ((Long)param).longValue();
             //if we are not piggy backing on a worker thread, set the timeout
             socket.setTimeout(timeout);
-        } else if (actionCode == ActionCode.ACTION_ASYNC_DISPATCH) {
+        } else if (actionCode == ActionCode.ASYNC_DISPATCH) {
             RequestInfo rp = request.getRequestProcessor();
             AtomicBoolean dispatch = (AtomicBoolean)param;
             if ( rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE ) {//async handling

==================================================
AbstractHttp11Processor.java
index 584a8b3837..b9430db38f 100644
--- a/java/org/apache/coyote/ajp/AjpProtocol.java
+++ b/java/org/apache/coyote/ajp/AjpProtocol.java
@@ -391,7 +391,7 @@ public class AjpProtocol
                 if (processor == null) {
                     processor = createProcessor();
                 }
-                processor.action(ActionCode.ACTION_START, null);
+                processor.action(ActionCode.START, null);
 
                 SocketState state = socket.isAsync()?processor.asyncDispatch(status):processor.process(socket);
                 if (state == SocketState.LONG) {
@@ -423,7 +423,7 @@ public class AjpProtocol
                 AjpProtocol.log.error
                     (sm.getString("ajpprotocol.proto.error"), e);
             } finally {
-                processor.action(ActionCode.ACTION_STOP, null);
+                processor.action(ActionCode.STOP, null);
                 recycledProcessors.offer(processor);
             }
             return SocketState.CLOSED;

==================================================
AbstractOutputBuffer.java
index a8b0c90557..154343852c 100644
--- a/java/org/apache/coyote/http11/AbstractHttp11Processor.java
+++ b/java/org/apache/coyote/http11/AbstractHttp11Processor.java
@@ -844,7 +844,7 @@ public abstract class AbstractHttp11Processor {
      */
     public final void action(ActionCode actionCode, Object param) {
         
-        if (actionCode == ActionCode.ACTION_COMMIT) {
+        if (actionCode == ActionCode.COMMIT) {
             // Commit current response
 
             if (response.isCommitted())
@@ -858,7 +858,7 @@ public abstract class AbstractHttp11Processor {
                 // Set error flag
                 error = true;
             }
-        } else if (actionCode == ActionCode.ACTION_ACK) {
+        } else if (actionCode == ActionCode.ACK) {
             // Acknowledge request
             // Send a 100 status back if it makes sense (response not committed
             // yet, and client specified an expectation for 100-continue)
@@ -873,7 +873,7 @@ public abstract class AbstractHttp11Processor {
                 // Set error flag
                 error = true;
             }
-        } else if (actionCode == ActionCode.ACTION_CLIENT_FLUSH) {
+        } else if (actionCode == ActionCode.CLIENT_FLUSH) {
 
             try {
                 getOutputBuffer().flush();
@@ -883,17 +883,17 @@ public abstract class AbstractHttp11Processor {
                 response.setErrorException(e);
             }
 
-        } else if (actionCode == ActionCode.ACTION_RESET) {
+        } else if (actionCode == ActionCode.RESET) {
             // Reset response
             // Note: This must be called before the response is committed
 
             getOutputBuffer().reset();
 
-        } else if (actionCode == ActionCode.ACTION_CUSTOM) {
+        } else if (actionCode == ActionCode.CUSTOM) {
             // Do nothing
             // TODO Remove this action
 
-        } else if (actionCode == ActionCode.ACTION_REQ_SET_BODY_REPLAY) {
+        } else if (actionCode == ActionCode.REQ_SET_BODY_REPLAY) {
             ByteChunk body = (ByteChunk) param;
             
             InputFilter savedBody = new SavedRequestInputFilter(body);
@@ -902,7 +902,7 @@ public abstract class AbstractHttp11Processor {
             AbstractInputBuffer internalBuffer = (AbstractInputBuffer)
                 request.getInputBuffer();
             internalBuffer.addActiveFilter(savedBody);
-        } else if (actionCode == ActionCode.ACTION_ASYNC_START) {
+        } else if (actionCode == ActionCode.ASYNC_START) {
             async = true;
         } else {
             actionInternal(actionCode, param);

==================================================
Http11AprProcessor.java
index 6aa1666071..e5e8f897cd 100644
--- a/java/org/apache/coyote/http11/AbstractOutputBuffer.java
+++ b/java/org/apache/coyote/http11/AbstractOutputBuffer.java
@@ -192,7 +192,7 @@ public abstract class AbstractOutputBuffer implements OutputBuffer{
             // Send the connector a request for commit. The connector should
             // then validate the headers, send them (using sendHeaders) and 
             // set the filters accordingly.
-            response.action(ActionCode.ACTION_COMMIT, null);
+            response.action(ActionCode.COMMIT, null);
 
         }
 
@@ -219,7 +219,7 @@ public abstract class AbstractOutputBuffer implements OutputBuffer{
             // Send the connector a request for commit. The connector should
             // then validate the headers, send them (using sendHeader) and 
             // set the filters accordingly.
-            response.action(ActionCode.ACTION_COMMIT, null);
+            response.action(ActionCode.COMMIT, null);
 
         }
         
@@ -306,7 +306,7 @@ public abstract class AbstractOutputBuffer implements OutputBuffer{
             // Send the connector a request for commit. The connector should
             // then validate the headers, send them (using sendHeader) and 
             // set the filters accordingly.
-            response.action(ActionCode.ACTION_COMMIT, null);
+            response.action(ActionCode.COMMIT, null);
 
         }
 

==================================================
Http11AprProtocol.java
index 43cdb8bf66..720c556145 100644
--- a/java/org/apache/coyote/http11/Http11AprProcessor.java
+++ b/java/org/apache/coyote/http11/Http11AprProcessor.java
@@ -411,7 +411,7 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
     @Override
     public void actionInternal(ActionCode actionCode, Object param) {
 
-        if (actionCode == ActionCode.ACTION_CLOSE) {
+        if (actionCode == ActionCode.CLOSE) {
             // Close
 
             // End the processing of the current request, and stop any further
@@ -426,7 +426,7 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
                 error = true;
             }
 
-        } else if (actionCode == ActionCode.ACTION_REQ_HOST_ADDR_ATTRIBUTE) {
+        } else if (actionCode == ActionCode.REQ_HOST_ADDR_ATTRIBUTE) {
 
             // Get remote host address
             if (remoteAddr == null && (socket != 0)) {
@@ -439,7 +439,7 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
             }
             request.remoteAddr().setString(remoteAddr);
 
-        } else if (actionCode == ActionCode.ACTION_REQ_LOCAL_NAME_ATTRIBUTE) {
+        } else if (actionCode == ActionCode.REQ_LOCAL_NAME_ATTRIBUTE) {
 
             // Get local host name
             if (localName == null && (socket != 0)) {
@@ -452,7 +452,7 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
             }
             request.localName().setString(localName);
 
-        } else if (actionCode == ActionCode.ACTION_REQ_HOST_ATTRIBUTE) {
+        } else if (actionCode == ActionCode.REQ_HOST_ATTRIBUTE) {
 
             // Get remote host name
             if (remoteHost == null && (socket != 0)) {
@@ -465,7 +465,7 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
             }
             request.remoteHost().setString(remoteHost);
 
-        } else if (actionCode == ActionCode.ACTION_REQ_LOCAL_ADDR_ATTRIBUTE) {
+        } else if (actionCode == ActionCode.REQ_LOCAL_ADDR_ATTRIBUTE) {
 
             // Get local host address
             if (localAddr == null && (socket != 0)) {
@@ -479,7 +479,7 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
 
             request.localAddr().setString(localAddr);
 
-        } else if (actionCode == ActionCode.ACTION_REQ_REMOTEPORT_ATTRIBUTE) {
+        } else if (actionCode == ActionCode.REQ_REMOTEPORT_ATTRIBUTE) {
 
             // Get remote port
             if (remotePort == -1 && (socket != 0)) {
@@ -493,7 +493,7 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
             }
             request.setRemotePort(remotePort);
 
-        } else if (actionCode == ActionCode.ACTION_REQ_LOCALPORT_ATTRIBUTE) {
+        } else if (actionCode == ActionCode.REQ_LOCALPORT_ATTRIBUTE) {
 
             // Get local port
             if (localPort == -1 && (socket != 0)) {
@@ -507,7 +507,7 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
             }
             request.setLocalPort(localPort);
 
-        } else if (actionCode == ActionCode.ACTION_REQ_SSL_ATTRIBUTE ) {
+        } else if (actionCode == ActionCode.REQ_SSL_ATTRIBUTE ) {
 
             if (ssl && (socket != 0)) {
                 try {
@@ -549,7 +549,7 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
                 }
             }
 
-        } else if (actionCode == ActionCode.ACTION_REQ_SSL_CERTIFICATE) {
+        } else if (actionCode == ActionCode.REQ_SSL_CERTIFICATE) {
 
             if (ssl && (socket != 0)) {
                 // Consume and buffer the request body, so that it does not
@@ -587,17 +587,17 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
                 }
             }
 
-        } else if (actionCode == ActionCode.ACTION_AVAILABLE) {
+        } else if (actionCode == ActionCode.AVAILABLE) {
             request.setAvailable(inputBuffer.available());
-        } else if (actionCode == ActionCode.ACTION_COMET_BEGIN) {
+        } else if (actionCode == ActionCode.COMET_BEGIN) {
             comet = true;
-        } else if (actionCode == ActionCode.ACTION_COMET_END) {
+        } else if (actionCode == ActionCode.COMET_END) {
             comet = false;
-        } else if (actionCode == ActionCode.ACTION_COMET_CLOSE) {
+        } else if (actionCode == ActionCode.COMET_CLOSE) {
             //no op
-        } else if (actionCode == ActionCode.ACTION_COMET_SETTIMEOUT) {
+        } else if (actionCode == ActionCode.COMET_SETTIMEOUT) {
             //no op
-        } else if (actionCode == ActionCode.ACTION_ASYNC_COMPLETE) {
+        } else if (actionCode == ActionCode.ASYNC_COMPLETE) {
           //TODO SERVLET3 - async - that is bit hacky -
             AtomicBoolean dispatch = (AtomicBoolean)param;
             RequestInfo rp = request.getRequestProcessor();
@@ -607,13 +607,13 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
             } else {
                 dispatch.set(false);
             }
-        } else if (actionCode == ActionCode.ACTION_ASYNC_SETTIMEOUT) {
+        } else if (actionCode == ActionCode.ASYNC_SETTIMEOUT) {
           //TODO SERVLET3 - async
             if (param==null) return;
             if (socket==0) return;
             long timeout = ((Long)param).longValue();
             Socket.timeoutSet(socket, timeout * 1000);
-        } else if (actionCode == ActionCode.ACTION_ASYNC_DISPATCH) {
+        } else if (actionCode == ActionCode.ASYNC_DISPATCH) {
             RequestInfo rp = request.getRequestProcessor();
             AtomicBoolean dispatch = (AtomicBoolean)param;
             if ( rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE ) {//async handling

==================================================
Http11NioProcessor.java
index f3ffe993bd..be74ac9fcd 100644
--- a/java/org/apache/coyote/http11/Http11AprProtocol.java
+++ b/java/org/apache/coyote/http11/Http11AprProtocol.java
@@ -349,7 +349,7 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
                     processor = createProcessor();
                 }
 
-                processor.action(ActionCode.ACTION_START, null);
+                processor.action(ActionCode.START, null);
 
                 SocketState state = processor.process(socket);
                 if (state == SocketState.LONG) {

==================================================
Http11NioProtocol.java
index a6a4df8e64..48e89e485e 100644
--- a/java/org/apache/coyote/http11/Http11NioProcessor.java
+++ b/java/org/apache/coyote/http11/Http11NioProcessor.java
@@ -492,7 +492,7 @@ public class Http11NioProcessor extends AbstractHttp11Processor implements Actio
     @Override
     public void actionInternal(ActionCode actionCode, Object param) {
 
-        if (actionCode == ActionCode.ACTION_CLOSE) {
+        if (actionCode == ActionCode.CLOSE) {
             // Close
 
             // End the processing of the current request, and stop any further
@@ -520,7 +520,7 @@ public class Http11NioProcessor extends AbstractHttp11Processor implements Actio
                 error = true;
             }
 
-        } else if (actionCode == ActionCode.ACTION_REQ_HOST_ADDR_ATTRIBUTE) {
+        } else if (actionCode == ActionCode.REQ_HOST_ADDR_ATTRIBUTE) {
 
             // Get remote host address
             if ((remoteAddr == null) && (socket != null)) {
@@ -531,7 +531,7 @@ public class Http11NioProcessor extends AbstractHttp11Processor implements Actio
             }
             request.remoteAddr().setString(remoteAddr);
 
-        } else if (actionCode == ActionCode.ACTION_REQ_LOCAL_NAME_ATTRIBUTE) {
+        } else if (actionCode == ActionCode.REQ_LOCAL_NAME_ATTRIBUTE) {
 
             // Get local host name
             if ((localName == null) && (socket != null)) {
@@ -542,7 +542,7 @@ public class Http11NioProcessor extends AbstractHttp11Processor implements Actio
             }
             request.localName().setString(localName);
 
-        } else if (actionCode == ActionCode.ACTION_REQ_HOST_ATTRIBUTE) {
+        } else if (actionCode == ActionCode.REQ_HOST_ATTRIBUTE) {
 
             // Get remote host name
             if ((remoteHost == null) && (socket != null)) {
@@ -560,28 +560,28 @@ public class Http11NioProcessor extends AbstractHttp11Processor implements Actio
             }
             request.remoteHost().setString(remoteHost);
 
-        } else if (actionCode == ActionCode.ACTION_REQ_LOCAL_ADDR_ATTRIBUTE) {
+        } else if (actionCode == ActionCode.REQ_LOCAL_ADDR_ATTRIBUTE) {
 
             if (localAddr == null)
                localAddr = socket.getIOChannel().socket().getLocalAddress().getHostAddress();
 
             request.localAddr().setString(localAddr);
 
-        } else if (actionCode == ActionCode.ACTION_REQ_REMOTEPORT_ATTRIBUTE) {
+        } else if (actionCode == ActionCode.REQ_REMOTEPORT_ATTRIBUTE) {
 
             if ((remotePort == -1 ) && (socket !=null)) {
                 remotePort = socket.getIOChannel().socket().getPort();
             }
             request.setRemotePort(remotePort);
 
-        } else if (actionCode == ActionCode.ACTION_REQ_LOCALPORT_ATTRIBUTE) {
+        } else if (actionCode == ActionCode.REQ_LOCALPORT_ATTRIBUTE) {
 
             if ((localPort == -1 ) && (socket !=null)) {
                 localPort = socket.getIOChannel().socket().getLocalPort();
             }
             request.setLocalPort(localPort);
 
-        } else if (actionCode == ActionCode.ACTION_REQ_SSL_ATTRIBUTE ) {
+        } else if (actionCode == ActionCode.REQ_SSL_ATTRIBUTE ) {
 
             try {
                 if (sslSupport != null) {
@@ -607,7 +607,7 @@ public class Http11NioProcessor extends AbstractHttp11Processor implements Actio
                 log.warn(sm.getString("http11processor.socket.ssl"), e);
             }
 
-        } else if (actionCode == ActionCode.ACTION_REQ_SSL_CERTIFICATE) {
+        } else if (actionCode == ActionCode.REQ_SSL_CERTIFICATE) {
 
             if( sslSupport != null) {
                 /*
@@ -630,13 +630,13 @@ public class Http11NioProcessor extends AbstractHttp11Processor implements Actio
                 }
             }
 
-        } else if (actionCode == ActionCode.ACTION_AVAILABLE) {
+        } else if (actionCode == ActionCode.AVAILABLE) {
             request.setAvailable(inputBuffer.available());
-        } else if (actionCode == ActionCode.ACTION_COMET_BEGIN) {
+        } else if (actionCode == ActionCode.COMET_BEGIN) {
             comet = true;
-        } else if (actionCode == ActionCode.ACTION_COMET_END) {
+        } else if (actionCode == ActionCode.COMET_END) {
             comet = false;
-        }  else if (actionCode == ActionCode.ACTION_COMET_CLOSE) {
+        }  else if (actionCode == ActionCode.COMET_CLOSE) {
             if (socket==null || socket.getAttachment(false)==null) return;
             NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment)socket.getAttachment(false);
             attach.setCometOps(NioEndpoint.OP_CALLBACK);
@@ -644,7 +644,7 @@ public class Http11NioProcessor extends AbstractHttp11Processor implements Actio
             RequestInfo rp = request.getRequestProcessor();
             if ( rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE ) //async handling
                 socket.getPoller().cometInterest(socket);
-        } else if (actionCode == ActionCode.ACTION_COMET_SETTIMEOUT) {
+        } else if (actionCode == ActionCode.COMET_SETTIMEOUT) {
             if (param==null) return;
             if (socket==null || socket.getAttachment(false)==null) return;
             NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment)socket.getAttachment(false);
@@ -653,7 +653,7 @@ public class Http11NioProcessor extends AbstractHttp11Processor implements Actio
             RequestInfo rp = request.getRequestProcessor();
             if ( rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE ) //async handling
                 attach.setTimeout(timeout);
-        } else if (actionCode == ActionCode.ACTION_ASYNC_COMPLETE) {
+        } else if (actionCode == ActionCode.ASYNC_COMPLETE) {
           //TODO SERVLET3 - async
             AtomicBoolean dispatch = (AtomicBoolean)param;
             RequestInfo rp = request.getRequestProcessor();
@@ -663,7 +663,7 @@ public class Http11NioProcessor extends AbstractHttp11Processor implements Actio
             } else {
                 dispatch.set(false);
             }
-        } else if (actionCode == ActionCode.ACTION_ASYNC_SETTIMEOUT) {
+        } else if (actionCode == ActionCode.ASYNC_SETTIMEOUT) {
           //TODO SERVLET3 - async
             if (param==null) return;
             if (socket==null || socket.getAttachment(false)==null) return;
@@ -671,7 +671,7 @@ public class Http11NioProcessor extends AbstractHttp11Processor implements Actio
             long timeout = ((Long)param).longValue();
             //if we are not piggy backing on a worker thread, set the timeout
             attach.setTimeout(timeout);
-        } else if (actionCode == ActionCode.ACTION_ASYNC_DISPATCH) {
+        } else if (actionCode == ActionCode.ASYNC_DISPATCH) {
             RequestInfo rp = request.getRequestProcessor();
             AtomicBoolean dispatch = (AtomicBoolean)param;
             if ( rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE ) {//async handling

==================================================
Http11Processor.java
index beb3bcab05..63fa912754 100644
--- a/java/org/apache/coyote/http11/Http11NioProtocol.java
+++ b/java/org/apache/coyote/http11/Http11NioProtocol.java
@@ -351,7 +351,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
                     processor = createProcessor();
                 }
 
-                processor.action(ActionCode.ACTION_START, null);
+                processor.action(ActionCode.START, null);
                 
                 if (proto.endpoint.isSSLEnabled() && (proto.sslImplementation != null)) {
                     if (socket instanceof SecureNioChannel) {

==================================================
Http11Protocol.java
index 1656c393e6..cee58bdea1 100644
--- a/java/org/apache/coyote/http11/Http11Processor.java
+++ b/java/org/apache/coyote/http11/Http11Processor.java
@@ -384,7 +384,7 @@ public class Http11Processor extends AbstractHttp11Processor implements ActionHo
     @Override
     public void actionInternal(ActionCode actionCode, Object param) {
 
-        if (actionCode == ActionCode.ACTION_CLOSE) {
+        if (actionCode == ActionCode.CLOSE) {
             // Close
             async = false;
             // End the processing of the current request, and stop any further
@@ -397,15 +397,15 @@ public class Http11Processor extends AbstractHttp11Processor implements ActionHo
                 error = true;
             }
 
-        } else if (actionCode == ActionCode.ACTION_START) {
+        } else if (actionCode == ActionCode.START) {
 
             started = true;
 
-        } else if (actionCode == ActionCode.ACTION_STOP) {
+        } else if (actionCode == ActionCode.STOP) {
 
             started = false;
 
-        } else if (actionCode == ActionCode.ACTION_REQ_SSL_ATTRIBUTE ) {
+        } else if (actionCode == ActionCode.REQ_SSL_ATTRIBUTE ) {
 
             try {
                 if (sslSupport != null) {
@@ -431,7 +431,7 @@ public class Http11Processor extends AbstractHttp11Processor implements ActionHo
                 log.warn(sm.getString("http11processor.socket.ssl"), e);
             }
 
-        } else if (actionCode == ActionCode.ACTION_REQ_HOST_ADDR_ATTRIBUTE) {
+        } else if (actionCode == ActionCode.REQ_HOST_ADDR_ATTRIBUTE) {
 
             if ((remoteAddr == null) && (socket != null)) {
                 InetAddress inetAddr = socket.getSocket().getInetAddress();
@@ -441,7 +441,7 @@ public class Http11Processor extends AbstractHttp11Processor implements ActionHo
             }
             request.remoteAddr().setString(remoteAddr);
 
-        } else if (actionCode == ActionCode.ACTION_REQ_LOCAL_NAME_ATTRIBUTE) {
+        } else if (actionCode == ActionCode.REQ_LOCAL_NAME_ATTRIBUTE) {
 
             if ((localName == null) && (socket != null)) {
                 InetAddress inetAddr = socket.getSocket().getLocalAddress();
@@ -451,7 +451,7 @@ public class Http11Processor extends AbstractHttp11Processor implements ActionHo
             }
             request.localName().setString(localName);
 
-        } else if (actionCode == ActionCode.ACTION_REQ_HOST_ATTRIBUTE) {
+        } else if (actionCode == ActionCode.REQ_HOST_ATTRIBUTE) {
 
             if ((remoteHost == null) && (socket != null)) {
                 InetAddress inetAddr = socket.getSocket().getInetAddress();
@@ -468,28 +468,28 @@ public class Http11Processor extends AbstractHttp11Processor implements ActionHo
             }
             request.remoteHost().setString(remoteHost);
 
-        } else if (actionCode == ActionCode.ACTION_REQ_LOCAL_ADDR_ATTRIBUTE) {
+        } else if (actionCode == ActionCode.REQ_LOCAL_ADDR_ATTRIBUTE) {
 
             if (localAddr == null)
                localAddr = socket.getSocket().getLocalAddress().getHostAddress();
 
             request.localAddr().setString(localAddr);
 
-        } else if (actionCode == ActionCode.ACTION_REQ_REMOTEPORT_ATTRIBUTE) {
+        } else if (actionCode == ActionCode.REQ_REMOTEPORT_ATTRIBUTE) {
 
             if ((remotePort == -1 ) && (socket !=null)) {
                 remotePort = socket.getSocket().getPort();
             }
             request.setRemotePort(remotePort);
 
-        } else if (actionCode == ActionCode.ACTION_REQ_LOCALPORT_ATTRIBUTE) {
+        } else if (actionCode == ActionCode.REQ_LOCALPORT_ATTRIBUTE) {
 
             if ((localPort == -1 ) && (socket !=null)) {
                 localPort = socket.getSocket().getLocalPort();
             }
             request.setLocalPort(localPort);
 
-        } else if (actionCode == ActionCode.ACTION_REQ_SSL_CERTIFICATE) {
+        } else if (actionCode == ActionCode.REQ_SSL_CERTIFICATE) {
             if( sslSupport != null) {
                 /*
                  * Consume and buffer the request body, so that it does not
@@ -510,7 +510,7 @@ public class Http11Processor extends AbstractHttp11Processor implements ActionHo
                     log.warn(sm.getString("http11processor.socket.ssl"), e);
                 }
             }
-        } else if (actionCode == ActionCode.ACTION_ASYNC_COMPLETE) {
+        } else if (actionCode == ActionCode.ASYNC_COMPLETE) {
             //TODO SERVLET3 - async
             AtomicBoolean dispatch = (AtomicBoolean)param;
             RequestInfo rp = request.getRequestProcessor();
@@ -520,13 +520,13 @@ public class Http11Processor extends AbstractHttp11Processor implements ActionHo
             } else {
                 dispatch.set(false);
             }
-        } else if (actionCode == ActionCode.ACTION_ASYNC_SETTIMEOUT) {
+        } else if (actionCode == ActionCode.ASYNC_SETTIMEOUT) {
           //TODO SERVLET3 - async
             if (param==null) return;
             long timeout = ((Long)param).longValue();
             //if we are not piggy backing on a worker thread, set the timeout
             socket.setTimeout(timeout);
-        } else if (actionCode == ActionCode.ACTION_ASYNC_DISPATCH) {
+        } else if (actionCode == ActionCode.ASYNC_DISPATCH) {
             RequestInfo rp = request.getRequestProcessor();
             AtomicBoolean dispatch = (AtomicBoolean)param;
             if ( rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE ) {//async handling

==================================================
InternalAprOutputBuffer.java
index ecac665f89..e49a10271a 100644
--- a/java/org/apache/coyote/http11/Http11Protocol.java
+++ b/java/org/apache/coyote/http11/Http11Protocol.java
@@ -246,7 +246,7 @@ public class Http11Protocol extends AbstractHttp11JsseProtocol {
                 if (processor == null) {
                     processor = createProcessor();
                 }
-                processor.action(ActionCode.ACTION_START, null);
+                processor.action(ActionCode.START, null);
 
                 if (proto.isSSLEnabled() && (proto.sslImplementation != null)) {
                     processor.setSSLSupport
@@ -290,7 +290,7 @@ public class Http11Protocol extends AbstractHttp11JsseProtocol {
                 //                processor.recycle();
 
                 if (recycle) {
-                    processor.action(ActionCode.ACTION_STOP, null);
+                    processor.action(ActionCode.STOP, null);
                     recycledProcessors.offer(processor);
                 }
             }

==================================================
