9c0682869d9bbbd124d8ad9c96b95ab57328ba11
==================================================
Remove SecurityManager references from the o.a.t.utils package
==================================================
Mark Thomas
==================================================
Thu Jan 12 19:48:15 2023 +0000
==================================================
BasicDataSource.java
Remove SecurityManager references from the o.a.t.utils package


==================================================
Utils.java
index a9cf96761c..b3729e025c 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java
@@ -19,9 +19,6 @@ package org.apache.tomcat.dbcp.dbcp2;
 import java.io.OutputStreamWriter;
 import java.io.PrintWriter;
 import java.nio.charset.StandardCharsets;
-import java.security.AccessController;
-import java.security.PrivilegedActionException;
-import java.security.PrivilegedExceptionAction;
 import java.sql.Connection;
 import java.sql.Driver;
 import java.sql.DriverManager;
@@ -73,30 +70,6 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     static {
         // Attempt to prevent deadlocks - see DBCP - 272
         DriverManager.getDrivers();
-        try {
-            // Load classes now to prevent AccessControlExceptions later
-            // A number of classes are loaded when getConnection() is called
-            // but the following classes are not loaded and therefore require
-            // explicit loading.
-            if (Utils.isSecurityEnabled()) {
-                final ClassLoader loader = BasicDataSource.class.getClassLoader();
-                final String dbcpPackageName = BasicDataSource.class.getPackage().getName();
-                loader.loadClass(dbcpPackageName + ".DelegatingCallableStatement");
-                loader.loadClass(dbcpPackageName + ".DelegatingDatabaseMetaData");
-                loader.loadClass(dbcpPackageName + ".DelegatingPreparedStatement");
-                loader.loadClass(dbcpPackageName + ".DelegatingResultSet");
-                loader.loadClass(dbcpPackageName + ".PoolableCallableStatement");
-                loader.loadClass(dbcpPackageName + ".PoolablePreparedStatement");
-                loader.loadClass(dbcpPackageName + ".PoolingConnection$StatementType");
-                loader.loadClass(dbcpPackageName + ".PStmtKey");
-
-                final String poolPackageName = PooledObject.class.getPackage().getName();
-                loader.loadClass(poolPackageName + ".impl.LinkedBlockingDeque$Node");
-                loader.loadClass(poolPackageName + ".impl.GenericKeyedObjectPool$ObjectDeque");
-            }
-        } catch (final ClassNotFoundException cnfe) {
-            throw new IllegalStateException("Unable to pre-load classes", cnfe);
-        }
     }
 
     /**
@@ -695,18 +668,6 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
      */
     @Override
     public Connection getConnection() throws SQLException {
-        if (Utils.isSecurityEnabled()) {
-            final PrivilegedExceptionAction<Connection> action = () -> createDataSource().getConnection();
-            try {
-                return AccessController.doPrivileged(action);
-            } catch (final PrivilegedActionException e) {
-                final Throwable cause = e.getCause();
-                if (cause instanceof SQLException) {
-                    throw (SQLException) cause;
-                }
-                throw new SQLException(e);
-            }
-        }
         return createDataSource().getConnection();
     }
 

==================================================
CallStack.java
index 7b44dcdcb0..70f9542f5e 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/Utils.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/Utils.java
@@ -42,14 +42,6 @@ public final class Utils {
     private static final ResourceBundle messages = ResourceBundle
         .getBundle(Utils.class.getPackage().getName() + ".LocalStrings");
 
-    /**
-     * Whether the security manager is enabled.
-     *
-     * @deprecated No replacement.
-     */
-    @Deprecated
-    public static final boolean IS_SECURITY_ENABLED = isSecurityEnabled();
-
     /** Any SQL_STATE starting with this value is considered a fatal disconnect */
     public static final String DISCONNECTION_SQL_CODE_PREFIX = "08";
 
@@ -217,10 +209,6 @@ public final class Utils {
         return collection == null || collection.isEmpty();
     }
 
-    static boolean isSecurityEnabled() {
-        return System.getSecurityManager() != null;
-    }
-
     /**
      * Converts the given String to a char[].
      *

==================================================
CallStackUtils.java
index 0f34709cfa..399dc04ac2 100644
--- a/java/org/apache/tomcat/dbcp/pool2/impl/CallStack.java
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/CallStack.java
@@ -26,7 +26,6 @@ import org.apache.tomcat.dbcp.pool2.UsageTracking;
  * {@linkplain UsageTracking usage tracking} so that different JVMs and configurations can use more efficient strategies
  * for obtaining the current call stack depending on metadata needs.
  *
- * @see CallStackUtils
  * @since 2.4.3
  */
 public interface CallStack {

==================================================
DefaultPooledObject.java
deleted file mode 100644
index 831343fd2b..0000000000
--- a/java/org/apache/tomcat/dbcp/pool2/impl/CallStackUtils.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.tomcat.dbcp.pool2.impl;
-
-import java.security.AccessControlException;
-
-/**
- * Utility methods for {@link CallStack}.
- *
- * @since 2.4.3
- */
-public final class CallStackUtils {
-
-    /**
-     * Tests whether the caller can create a security manager in the current environment.
-     *
-     * @return {@code true} if it is able to create a security manager in the current environment, {@code false}
-     *         otherwise.
-     */
-    private static boolean canCreateSecurityManager() {
-        final SecurityManager manager = System.getSecurityManager();
-        if (manager == null) {
-            return true;
-        }
-        try {
-            manager.checkPermission(new RuntimePermission("createSecurityManager"));
-            return true;
-        } catch (final AccessControlException ignored) {
-            return false;
-        }
-    }
-
-    /**
-     * Constructs a new {@link CallStack} using the fastest allowed strategy.
-     *
-     * @param messageFormat message (or format) to print first in stack traces
-     * @param useTimestamp  if true, interpret message as a SimpleDateFormat and print the created timestamp; otherwise,
-     *                      print message format literally
-     * @return a new CallStack
-     * @deprecated use {@link #newCallStack(String, boolean, boolean)}
-     */
-    @Deprecated
-    public static CallStack newCallStack(final String messageFormat, final boolean useTimestamp) {
-        return newCallStack(messageFormat, useTimestamp, false);
-    }
-
-    /**
-     * Constructs a new {@link CallStack} using the fasted allowed strategy.
-     *
-     * @param messageFormat         message (or format) to print first in stack traces
-     * @param useTimestamp          if true, interpret message as a SimpleDateFormat and print the created timestamp;
-     *                              otherwise, print message format literally
-     * @param requireFullStackTrace if true, forces the use of a stack walking mechanism that includes full stack trace
-     *                              information; otherwise, uses a faster implementation if possible
-     * @return a new CallStack
-     * @since 2.5
-     */
-    public static CallStack newCallStack(final String messageFormat,
-                                         final boolean useTimestamp,
-                                         final boolean requireFullStackTrace) {
-        return canCreateSecurityManager() && !requireFullStackTrace ?
-            new SecurityManagerCallStack(messageFormat, useTimestamp) :
-            new ThrowableCallStack(messageFormat, useTimestamp);
-    }
-
-    /**
-     * Hidden constructor.
-     */
-    private CallStackUtils() {
-    }
-}

==================================================
EvictionTimer.java
index 3894d871e7..69954c8360 100644
--- a/java/org/apache/tomcat/dbcp/pool2/impl/DefaultPooledObject.java
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/DefaultPooledObject.java
@@ -306,11 +306,9 @@ public class DefaultPooledObject<T> implements PooledObject<T> {
      */
     @Override
     public void setRequireFullStackTrace(final boolean requireFullStackTrace) {
-        borrowedBy = CallStackUtils.newCallStack("'Pooled object created' " +
-            "yyyy-MM-dd HH:mm:ss Z 'by the following code has not been returned to the pool:'",
-            true, requireFullStackTrace);
-        usedBy = CallStackUtils.newCallStack("The last code to use this object was:",
-            false, requireFullStackTrace);
+        borrowedBy = new ThrowableCallStack("'Pooled object created' " +
+            "yyyy-MM-dd HH:mm:ss Z 'by the following code has not been returned to the pool:'", true);
+        usedBy = new ThrowableCallStack("The last code to use this object was:", false);
     }
 
     @Override

==================================================
SecurityManagerCallStack.java
index 8e86e1a218..5b930c9d3f 100644
--- a/java/org/apache/tomcat/dbcp/pool2/impl/EvictionTimer.java
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/EvictionTimer.java
@@ -17,8 +17,6 @@
 package org.apache.tomcat.dbcp.pool2.impl;
 
 import java.lang.ref.WeakReference;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
 import java.time.Duration;
 import java.util.HashMap;
 import java.util.Map.Entry;
@@ -57,11 +55,7 @@ class EvictionTimer {
         public Thread newThread(final Runnable runnable) {
             final Thread thread = new Thread(null, runnable, "commons-pool-evictor");
             thread.setDaemon(true); // POOL-363 - Required for applications using Runtime.addShutdownHook().
-            AccessController.doPrivileged((PrivilegedAction<Void>) () -> {
-                thread.setContextClassLoader(EvictorThreadFactory.class.getClassLoader());
-                return null;
-            });
-
+            thread.setContextClassLoader(EvictorThreadFactory.class.getClassLoader());
             return thread;
         }
     }

==================================================
JrePlatform.java
deleted file mode 100644
index 04e030ae94..0000000000
--- a/java/org/apache/tomcat/dbcp/pool2/impl/SecurityManagerCallStack.java
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.tomcat.dbcp.pool2.impl;
-
-import java.io.PrintWriter;
-import java.lang.ref.WeakReference;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
-import java.text.DateFormat;
-import java.text.SimpleDateFormat;
-import java.util.List;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
-
-/**
- * A {@link CallStack} strategy using a {@link SecurityManager}. Obtaining the current call stack is much faster via a
- * SecurityManger, but access to the underlying method may be restricted by the current SecurityManager. In environments
- * where a SecurityManager cannot be created, {@link ThrowableCallStack} should be used instead.
- *
- * @see RuntimePermission
- * @see SecurityManager#getClassContext()
- * @since 2.4.3
- */
-public class SecurityManagerCallStack implements CallStack {
-
-    /**
-     * A custom security manager.
-     */
-    private static class PrivateSecurityManager extends SecurityManager {
-
-        /**
-         * Gets the class stack.
-         *
-         * @return class stack
-         */
-        private List<WeakReference<Class<?>>> getCallStack() {
-            final Stream<WeakReference<Class<?>>> map = Stream.of(getClassContext()).map(WeakReference::new);
-            return map.collect(Collectors.toList());
-        }
-    }
-
-    /**
-     * A snapshot of a class stack.
-     */
-    private static class Snapshot {
-        private final long timestampMillis = System.currentTimeMillis();
-        private final List<WeakReference<Class<?>>> stack;
-
-        /**
-         * Constructs a new snapshot with a class stack.
-         *
-         * @param stack class stack
-         */
-        private Snapshot(final List<WeakReference<Class<?>>> stack) {
-            this.stack = stack;
-        }
-    }
-
-    private final String messageFormat;
-
-    //@GuardedBy("dateFormat")
-    private final DateFormat dateFormat;
-
-    private final PrivateSecurityManager securityManager;
-
-    private volatile Snapshot snapshot;
-
-    /**
-     * Creates a new instance.
-     *
-     * @param messageFormat message format
-     * @param useTimestamp whether to format the dates in the output message or not
-     */
-    public SecurityManagerCallStack(final String messageFormat, final boolean useTimestamp) {
-        this.messageFormat = messageFormat;
-        this.dateFormat = useTimestamp ? new SimpleDateFormat(messageFormat) : null;
-        this.securityManager = AccessController.doPrivileged((PrivilegedAction<PrivateSecurityManager>) PrivateSecurityManager::new);
-    }
-
-    @Override
-    public void clear() {
-        snapshot = null;
-    }
-
-    @Override
-    public void fillInStackTrace() {
-        snapshot = new Snapshot(securityManager.getCallStack());
-    }
-
-    @Override
-    public boolean printStackTrace(final PrintWriter writer) {
-        final Snapshot snapshotRef = this.snapshot;
-        if (snapshotRef == null) {
-            return false;
-        }
-        final String message;
-        if (dateFormat == null) {
-            message = messageFormat;
-        } else {
-            synchronized (dateFormat) {
-                message = dateFormat.format(Long.valueOf(snapshotRef.timestampMillis));
-            }
-        }
-        writer.println(message);
-        snapshotRef.stack.forEach(reference -> writer.println(reference.get()));
-        return true;
-    }
-}

==================================================
Constants.java
index 66717d664f..b0db4f3797 100644
--- a/java/org/apache/tomcat/util/compat/JrePlatform.java
+++ b/java/org/apache/tomcat/util/compat/JrePlatform.java
@@ -16,8 +16,6 @@
  */
 package org.apache.tomcat.util.compat;
 
-import java.security.AccessController;
-import java.security.PrivilegedAction;
 import java.util.Locale;
 
 public class JrePlatform {
@@ -37,13 +35,7 @@ public class JrePlatform {
          */
 
         // This check is derived from the check in Apache Commons Lang
-        String osName;
-        if (System.getSecurityManager() == null) {
-            osName = System.getProperty(OS_NAME_PROPERTY);
-        } else {
-            osName = AccessController.doPrivileged(
-                    (PrivilegedAction<String>) () -> System.getProperty(OS_NAME_PROPERTY));
-        }
+        String osName = System.getProperty(OS_NAME_PROPERTY);
 
         IS_MAC_OS = osName.toLowerCase(Locale.ENGLISH).startsWith("mac os x");
 

==================================================
TldParser.java
index 2ad599666a..08f18bfaf0 100644
--- a/java/org/apache/tomcat/util/descriptor/Constants.java
+++ b/java/org/apache/tomcat/util/descriptor/Constants.java
@@ -18,8 +18,5 @@ package org.apache.tomcat.util.descriptor;
 
 public class Constants {
 
-    public static final String PACKAGE_NAME =
-            Constants.class.getPackage().getName();
-
-    public static final boolean IS_SECURITY_ENABLED = (System.getSecurityManager() != null);
+    public static final String PACKAGE_NAME = Constants.class.getPackage().getName();
 }

==================================================
Constants.java
index e31c2fea58..df2e9c977a 100644
--- a/java/org/apache/tomcat/util/descriptor/tld/TldParser.java
+++ b/java/org/apache/tomcat/util/descriptor/tld/TldParser.java
@@ -18,17 +18,13 @@ package org.apache.tomcat.util.descriptor.tld;
 
 import java.io.IOException;
 import java.io.InputStream;
-import java.security.AccessController;
 
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
-import org.apache.tomcat.util.descriptor.Constants;
 import org.apache.tomcat.util.descriptor.DigesterFactory;
 import org.apache.tomcat.util.descriptor.XmlErrorHandler;
 import org.apache.tomcat.util.digester.Digester;
 import org.apache.tomcat.util.digester.RuleSet;
-import org.apache.tomcat.util.security.PrivilegedGetTccl;
-import org.apache.tomcat.util.security.PrivilegedSetTccl;
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
 
@@ -51,20 +47,9 @@ public class TldParser {
     }
 
     public TaglibXml parse(TldResourcePath path) throws IOException, SAXException {
-        ClassLoader original;
-        if (Constants.IS_SECURITY_ENABLED) {
-            PrivilegedGetTccl pa = new PrivilegedGetTccl();
-            original = AccessController.doPrivileged(pa);
-        } else {
-            original = Thread.currentThread().getContextClassLoader();
-        }
+        ClassLoader original = Thread.currentThread().getContextClassLoader();
         try (InputStream is = path.openStream()) {
-            if (Constants.IS_SECURITY_ENABLED) {
-                PrivilegedSetTccl pa = new PrivilegedSetTccl(TldParser.class.getClassLoader());
-                AccessController.doPrivileged(pa);
-            } else {
-                Thread.currentThread().setContextClassLoader(TldParser.class.getClassLoader());
-            }
+            Thread.currentThread().setContextClassLoader(TldParser.class.getClassLoader());
             XmlErrorHandler handler = new XmlErrorHandler();
             digester.setErrorHandler(handler);
 
@@ -84,12 +69,7 @@ public class TldParser {
             return taglibXml;
         } finally {
             digester.reset();
-            if (Constants.IS_SECURITY_ENABLED) {
-                PrivilegedSetTccl pa = new PrivilegedSetTccl(original);
-                AccessController.doPrivileged(pa);
-            } else {
-                Thread.currentThread().setContextClassLoader(original);
-            }
+            Thread.currentThread().setContextClassLoader(original);
         }
     }
 

==================================================
PrivilegedGetTccl.java
index 9cda5e1836..ca5c0e4a15 100644
--- a/java/org/apache/tomcat/util/net/Constants.java
+++ b/java/org/apache/tomcat/util/net/Constants.java
@@ -38,6 +38,4 @@ public class Constants {
     public static final String SSL_PROTO_SSLv3      = "SSLv3";
     public static final String SSL_PROTO_SSLv2      = "SSLv2";
     public static final String SSL_PROTO_SSLv2Hello = "SSLv2Hello";
-
-    public static final boolean IS_SECURITY_ENABLED = (System.getSecurityManager() != null);
 }

==================================================
PrivilegedSetAccessControlContext.java
deleted file mode 100644
index 11d11a8602..0000000000
--- a/java/org/apache/tomcat/util/security/PrivilegedGetTccl.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.tomcat.util.security;
-
-import java.security.PrivilegedAction;
-
-public class PrivilegedGetTccl implements PrivilegedAction<ClassLoader> {
-    @Override
-    public ClassLoader run() {
-        return Thread.currentThread().getContextClassLoader();
-    }
-}
-
-

==================================================
PrivilegedSetTccl.java
deleted file mode 100644
index 2f53480087..0000000000
--- a/java/org/apache/tomcat/util/security/PrivilegedSetAccessControlContext.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.tomcat.util.security;
-
-import java.lang.reflect.Field;
-import java.security.AccessControlContext;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
-
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-import org.apache.tomcat.util.res.StringManager;
-
-public class PrivilegedSetAccessControlContext implements PrivilegedAction<Void> {
-
-    private static final Log log = LogFactory.getLog(PrivilegedSetAccessControlContext.class);
-    private static final StringManager sm = StringManager.getManager(PrivilegedSetAccessControlContext.class);
-
-    private static final AccessControlContext acc;
-    private static final Field field;
-
-    static {
-        acc = AccessController.getContext();
-        Field f = null;
-        try {
-            f = Thread.class.getDeclaredField("inheritedAccessControlContext");
-            f.trySetAccessible();
-        } catch (NoSuchFieldException | SecurityException e) {
-            log.warn(sm.getString("privilegedSetAccessControlContext.lookupFailed"), e);
-        }
-        field = f;
-    }
-
-    private final Thread t;
-
-
-    public PrivilegedSetAccessControlContext(Thread t) {
-        this.t = t;
-    }
-
-
-    @Override
-    public Void run() {
-        try {
-            if (field != null) {
-                field.set(t,  acc);
-            }
-        } catch (IllegalArgumentException | IllegalAccessException e) {
-            log.warn(sm.getString("privilegedSetAccessControlContext.setFailed"), e);
-        }
-        return null;
-    }
-}
\ No newline at end of file

==================================================
Constants.java
deleted file mode 100644
index 739d915794..0000000000
--- a/java/org/apache/tomcat/util/security/PrivilegedSetTccl.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.tomcat.util.security;
-
-import java.security.PrivilegedAction;
-
-public class PrivilegedSetTccl implements PrivilegedAction<Void> {
-
-    private final ClassLoader cl;
-    private final Thread t;
-
-    public PrivilegedSetTccl(ClassLoader cl) {
-        this(Thread.currentThread(), cl);
-    }
-
-    public PrivilegedSetTccl(Thread t, ClassLoader cl) {
-        this.t = t;
-        this.cl = cl;
-    }
-
-
-    @Override
-    public Void run() {
-        t.setContextClassLoader(cl);
-        return null;
-    }
-}
\ No newline at end of file

==================================================
TaskThreadFactory.java
index 5dcaccef21..715845d9d4 100644
--- a/java/org/apache/tomcat/util/threads/Constants.java
+++ b/java/org/apache/tomcat/util/threads/Constants.java
@@ -22,9 +22,4 @@ package org.apache.tomcat.util.threads;
 public final class Constants {
 
     public static final long DEFAULT_THREAD_RENEWAL_DELAY = 1000L;
-
-    /**
-     * Has security been turned on?
-     */
-    public static final boolean IS_SECURITY_ENABLED = (System.getSecurityManager() != null);
 }

==================================================
ThreadPoolExecutor.java
index 4320f9b6cb..71ae99d9c0 100644
--- a/java/org/apache/tomcat/util/threads/TaskThreadFactory.java
+++ b/java/org/apache/tomcat/util/threads/TaskThreadFactory.java
@@ -16,14 +16,9 @@
  */
 package org.apache.tomcat.util.threads;
 
-import java.security.AccessController;
-import java.security.PrivilegedAction;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.apache.tomcat.util.security.PrivilegedSetAccessControlContext;
-import org.apache.tomcat.util.security.PrivilegedSetTccl;
-
 /**
  * Simple task thread factory to use to create threads for an executor
  * implementation.
@@ -37,8 +32,7 @@ public class TaskThreadFactory implements ThreadFactory {
     private final int threadPriority;
 
     public TaskThreadFactory(String namePrefix, boolean daemon, int priority) {
-        SecurityManager s = System.getSecurityManager();
-        group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();
+        group = Thread.currentThread().getThreadGroup();
         this.namePrefix = namePrefix;
         this.daemon = daemon;
         this.threadPriority = priority;
@@ -49,23 +43,7 @@ public class TaskThreadFactory implements ThreadFactory {
         TaskThread t = new TaskThread(group, r, namePrefix + threadNumber.getAndIncrement());
         t.setDaemon(daemon);
         t.setPriority(threadPriority);
-
-        if (Constants.IS_SECURITY_ENABLED) {
-            // Set the context class loader of newly created threads to be the
-            // class loader that loaded this factory. This avoids retaining
-            // references to web application class loaders and similar.
-            PrivilegedAction<Void> pa = new PrivilegedSetTccl(
-                    t, getClass().getClassLoader());
-            AccessController.doPrivileged(pa);
-
-            // This method may be triggered from an InnocuousThread. Ensure that
-            // the thread inherits an appropriate AccessControlContext
-            pa = new PrivilegedSetAccessControlContext(t);
-            AccessController.doPrivileged(pa);
-        } else {
-            t.setContextClassLoader(getClass().getClassLoader());
-        }
-
+        t.setContextClassLoader(getClass().getClassLoader());
         return t;
     }
 }

==================================================
AsyncChannelGroupUtil.java
index 1844dcba28..1f4c8d5c8f 100644
--- a/java/org/apache/tomcat/util/threads/ThreadPoolExecutor.java
+++ b/java/org/apache/tomcat/util/threads/ThreadPoolExecutor.java
@@ -584,29 +584,6 @@ public class ThreadPoolExecutor extends AbstractExecutorService {
      */
     private static final RejectedExecutionHandler defaultHandler = new RejectPolicy();
 
-    /**
-     * Permission required for callers of shutdown and shutdownNow.
-     * We additionally require (see checkShutdownAccess) that callers
-     * have permission to actually interrupt threads in the worker set
-     * (as governed by Thread.interrupt, which relies on
-     * ThreadGroup.checkAccess, which in turn relies on
-     * SecurityManager.checkAccess). Shutdowns are attempted only if
-     * these checks pass.
-     *
-     * All actual invocations of Thread.interrupt (see
-     * interruptIdleWorkers and interruptWorkers) ignore
-     * SecurityExceptions, meaning that the attempted interrupts
-     * silently fail. In the case of shutdown, they should not fail
-     * unless the SecurityManager has inconsistent policies, sometimes
-     * allowing access to a thread and sometimes not. In such cases,
-     * failure to actually interrupt threads may disable or delay full
-     * termination. Other uses of interruptIdleWorkers are advisory,
-     * and failure to actually interrupt will merely delay response to
-     * configuration changes so is not handled exceptionally.
-     */
-    private static final RuntimePermission shutdownPerm =
-        new RuntimePermission("modifyThread");
-
     /**
      * Class Worker mainly maintains interrupt control state for
      * threads running tasks, along with other minor bookkeeping.
@@ -769,25 +746,6 @@ public class ThreadPoolExecutor extends AbstractExecutorService {
      * Methods for controlling interrupts to worker threads.
      */
 
-    /**
-     * If there is a security manager, makes sure caller has
-     * permission to shut down threads in general (see shutdownPerm).
-     * If this passes, additionally makes sure the caller is allowed
-     * to interrupt each worker thread. This might not be true even if
-     * first check passed, if the SecurityManager treats some threads
-     * specially.
-     */
-    private void checkShutdownAccess() {
-        // assert mainLock.isHeldByCurrentThread();
-        SecurityManager security = System.getSecurityManager();
-        if (security != null) {
-            security.checkPermission(shutdownPerm);
-            for (Worker w : workers) {
-                security.checkAccess(w.thread);
-            }
-        }
-    }
-
     /**
      * Interrupts all threads, even if active. Ignores SecurityExceptions
      * (in which case some threads may remain uninterrupted).
@@ -1469,7 +1427,6 @@ public class ThreadPoolExecutor extends AbstractExecutorService {
         final ReentrantLock mainLock = this.mainLock;
         mainLock.lock();
         try {
-            checkShutdownAccess();
             advanceRunState(SHUTDOWN);
             interruptIdleWorkers();
             onShutdown(); // hook for ScheduledThreadPoolExecutor
@@ -1502,7 +1459,6 @@ public class ThreadPoolExecutor extends AbstractExecutorService {
         final ReentrantLock mainLock = this.mainLock;
         mainLock.lock();
         try {
-            checkShutdownAccess();
             advanceRunState(STOP);
             interruptWorkers();
             tasks = drainQueue();

==================================================
ConnectionPool.java
index 6d1413bdaa..c0e839fb3d 100644
--- a/java/org/apache/tomcat/websocket/AsyncChannelGroupUtil.java
+++ b/java/org/apache/tomcat/websocket/AsyncChannelGroupUtil.java
@@ -18,8 +18,6 @@ package org.apache.tomcat.websocket;
 
 import java.io.IOException;
 import java.nio.channels.AsynchronousChannelGroup;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadFactory;
@@ -105,47 +103,15 @@ public class AsyncChannelGroupUtil {
 
     private static class AsyncIOThreadFactory implements ThreadFactory {
 
-        static {
-            // Load NewThreadPrivilegedAction since newThread() will not be able
-            // to if called from an InnocuousThread.
-            // See https://bz.apache.org/bugzilla/show_bug.cgi?id=57490
-            NewThreadPrivilegedAction.load();
-        }
-
+        private static AtomicInteger count = new AtomicInteger(0);
 
         @Override
         public Thread newThread(final Runnable r) {
-            // Create the new Thread within a doPrivileged block to ensure that
-            // the thread inherits the current ProtectionDomain which is
-            // essential to be able to use this with a Java Applet. See
-            // https://bz.apache.org/bugzilla/show_bug.cgi?id=57091
-            return AccessController.doPrivileged(new NewThreadPrivilegedAction(r));
-        }
-
-        // Non-anonymous class so that AsyncIOThreadFactory can load it
-        // explicitly
-        private static class NewThreadPrivilegedAction implements PrivilegedAction<Thread> {
-
-            private static AtomicInteger count = new AtomicInteger(0);
-
-            private final Runnable r;
-
-            public NewThreadPrivilegedAction(Runnable r) {
-                this.r = r;
-            }
-
-            @Override
-            public Thread run() {
-                Thread t = new Thread(r);
-                t.setName("WebSocketClient-AsyncIO-" + count.incrementAndGet());
-                t.setContextClassLoader(this.getClass().getClassLoader());
-                t.setDaemon(true);
-                return t;
-            }
-
-            private static void load() {
-                // NO-OP. Just provides a hook to enable the class to be loaded
-            }
+            Thread t = new Thread(r);
+            t.setName("WebSocketClient-AsyncIO-" + count.incrementAndGet());
+            t.setContextClassLoader(this.getClass().getClassLoader());
+            t.setDaemon(true);
+            return t;
         }
     }
 }

==================================================
