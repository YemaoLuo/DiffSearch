21cd3083af2d45b2c0d91f57356116f80bdbbed5
==================================================
Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=48266
==================================================
Mark Emlyn
==================================================
Wed Nov 25 01:00:07 2009 +0000
==================================================
JMXAccessorTask.java
Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=48266
Generics and unused imports.
Patch by sebb

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@883943 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Request.java
index 70c7b09f4a..a787b1ed20 100644
--- a/java/org/apache/catalina/ant/jmx/JMXAccessorTask.java
+++ b/java/org/apache/catalina/ant/jmx/JMXAccessorTask.java
@@ -621,7 +621,7 @@ public class JMXAccessorTask extends BaseRedirectorHelperTask {
                 String key = iter.next();
                 Object value = data.get(key);
                 OpenType<?> type = compositeType.getType(key);
-                if (type instanceof SimpleType) {
+                if (type instanceof SimpleType<?>) {
                     setProperty(propertyPrefix + "." + key, value);
                 } else {
                     createProperty(propertyPrefix + "." + key, value);
@@ -637,7 +637,7 @@ public class JMXAccessorTask extends BaseRedirectorHelperTask {
                     Object value = valuedata.get("value");
                     OpenType<?> type = valuedata.getCompositeType().getType(
                             "value");
-                    if (type instanceof SimpleType) {
+                    if (type instanceof SimpleType<?>) {
                         setProperty(propertyPrefix + "." + key1, value);
                     } else {
                         createProperty(propertyPrefix + "." + key1, value);

==================================================
StandardPart.java
index 52effc83a3..743655e2be 100644
--- a/java/org/apache/catalina/connector/Request.java
+++ b/java/org/apache/catalina/connector/Request.java
@@ -74,7 +74,6 @@ import org.apache.catalina.util.Enumerator;
 import org.apache.catalina.util.ParameterMap;
 import org.apache.catalina.util.StringParser;
 import org.apache.coyote.ActionCode;
-import org.apache.jasper.compiler.ServletWriter;
 import org.apache.tomcat.util.buf.B2CConverter;
 import org.apache.tomcat.util.buf.ByteChunk;
 import org.apache.tomcat.util.buf.MessageBytes;
@@ -91,7 +90,6 @@ import org.apache.tomcat.util.http.fileupload.ServletFileUpload;
 import org.apache.tomcat.util.http.fileupload.FileUploadBase.InvalidContentTypeException;
 import org.apache.tomcat.util.http.mapper.MappingData;
 import org.apache.tomcat.util.res.StringManager;
-import org.apache.tools.ant.util.CollectionUtils;
 
 
 /**

==================================================
CollectedInfo.java
index 7f83a25697..b4bdb1cb61 100644
--- a/java/org/apache/catalina/core/StandardPart.java
+++ b/java/org/apache/catalina/core/StandardPart.java
@@ -26,7 +26,6 @@ import java.util.HashSet;
 import java.util.Iterator;
 
 import javax.servlet.MultipartConfigElement;
-import javax.servlet.ServletContext;
 import javax.servlet.http.Part;
 
 import org.apache.tomcat.util.http.fileupload.DiskFileItem;

==================================================
BackupManager.java
index 65afb0f5c4..13bf826058 100644
--- a/java/org/apache/catalina/ha/backend/CollectedInfo.java
+++ b/java/org/apache/catalina/ha/backend/CollectedInfo.java
@@ -56,7 +56,7 @@ public class CollectedInfo {
         mBeanServer = Registry.getRegistry(null, null).getMBeanServer();
         String onStr = "*:type=ThreadPool,*";
         ObjectName objectName = new ObjectName(onStr);
-        Set set = mBeanServer.queryMBeans(objectName, null);
+        Set<ObjectInstance> set = mBeanServer.queryMBeans(objectName, null);
         Iterator<ObjectInstance> iterator = set.iterator();
         while (iterator.hasNext()) {
             ObjectInstance oi = iterator.next();

==================================================
ReplicationValve.java
index 29b61081ac..1f68f35081 100644
--- a/java/org/apache/catalina/ha/session/BackupManager.java
+++ b/java/org/apache/catalina/ha/session/BackupManager.java
@@ -308,6 +308,7 @@ public class BackupManager extends StandardManager implements ClusterManager, Ma
     public String listSessionIdsFull() {
         StringBuilder sb=new StringBuilder();
         LazyReplicatedMap map = (LazyReplicatedMap)sessions;
+        @SuppressWarnings("unchecked") // sessions is of type Map<String, Session>
         Iterator<String> keys = map.keySetFull().iterator();
         while (keys.hasNext()) {
             sb.append(keys.next()).append(" ");

==================================================
AbstractReplicatedMap.java
index 632f0a5ec8..c4898d938a 100644
--- a/java/org/apache/catalina/ha/tcp/ReplicationValve.java
+++ b/java/org/apache/catalina/ha/tcp/ReplicationValve.java
@@ -451,10 +451,9 @@ public class ReplicationValve
      * @param containerCluster
      */
     protected void sendCrossContextSession(CatalinaCluster containerCluster) {
-        Object sessions = crossContextSessions.get();
-        if(sessions != null && sessions instanceof List
-                && ((List<Session>)sessions).size() >0) {
-            for(Iterator<Session> iter = ((List<Session>)sessions).iterator(); iter.hasNext() ;) {          
+        List<DeltaSession> sessions = crossContextSessions.get();
+        if(sessions != null && sessions.size() >0) {
+            for(Iterator<DeltaSession> iter = sessions.iterator(); iter.hasNext() ;) {          
                 Session session = iter.next();
                 if(log.isDebugEnabled())
                     log.debug(sm.getString("ReplicationValve.crossContext.sendDelta",  
@@ -479,10 +478,9 @@ public class ReplicationValve
             ((DeltaSession)contextSession).setPrimarySession(true);
         }
         if(isCrossContext) {
-            Object sessions = crossContextSessions.get();
-            if(sessions != null && sessions instanceof List
-               && ((List<Session>)sessions).size() >0) {
-                Iterator<Session> iter = ((List<Session>)sessions).iterator();
+            List<DeltaSession> sessions = crossContextSessions.get();
+            if(sessions != null && sessions.size() >0) {
+                Iterator<DeltaSession> iter = sessions.iterator();
                 for(; iter.hasNext() ;) {          
                     Session session = iter.next();
                     resetDeltaRequest(session);

==================================================
MultipointBioSender.java
index 8c8500b1fa..9c853f6f0f 100644
--- a/java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java
+++ b/java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java
@@ -360,6 +360,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
     
     public Member[] getMapMembersExcl(Member[] exclude) {
         synchronized (mapMembers) {
+            @SuppressWarnings("unchecked") // mapMembers has the correct type
             HashMap<Member, Long> list = (HashMap<Member, Long>)mapMembers.clone();
             for (int i=0; i<exclude.length;i++) list.remove(exclude[i]);
             return getMapMembers(list);
@@ -438,9 +439,9 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
      * @param complete boolean
      */
     public void replicate(boolean complete) {
-        Iterator i = super.entrySet().iterator();
+        Iterator<Map.Entry<?,?>> i = super.entrySet().iterator();
         while (i.hasNext()) {
-            Map.Entry e = (Map.Entry) i.next();
+            Map.Entry<?,?> e = i.next();
             replicate(e.getKey(), complete);
         } //while
 
@@ -458,7 +459,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
                     synchronized (stateMutex) {
                         msg = (MapMessage) resp[0].getMessage();
                         msg.deserialize(getExternalLoaders());
-                        ArrayList list = (ArrayList) msg.getValue();
+                        ArrayList<?> list = (ArrayList<?>) msg.getValue();
                         for (int i = 0; i < list.size(); i++) {
                             messageReceived( (Serializable) list.get(i), resp[0].getSource());
                         } //for
@@ -511,9 +512,9 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
         if (mapmsg.getMsgType() == MapMessage.MSG_STATE || mapmsg.getMsgType() == MapMessage.MSG_STATE_COPY) {
             synchronized (stateMutex) { //make sure we dont do two things at the same time
                 ArrayList<MapMessage> list = new ArrayList<MapMessage>();
-                Iterator i = super.entrySet().iterator();
+                Iterator<Map.Entry<?,?>> i = super.entrySet().iterator();
                 while (i.hasNext()) {
-                    Map.Entry e = (Map.Entry) i.next();
+                    Map.Entry<?,?> e = i.next();
                     MapEntry entry = (MapEntry) super.get(e.getKey());
                     if ( entry != null && entry.isSerializable() ) {
                         boolean copy = (mapmsg.getMsgType() == MapMessage.MSG_STATE_COPY);
@@ -671,9 +672,9 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
         }
         if ( memberAdded ) {
             synchronized (stateMutex) {
-                Iterator i = super.entrySet().iterator();
+                Iterator<Map.Entry<?,?>> i = super.entrySet().iterator();
                 while (i.hasNext()) {
-                    Map.Entry e = (Map.Entry) i.next();
+                    Map.Entry<?,?> e = i.next();
                     MapEntry entry = (MapEntry) super.get(e.getKey());
                     if ( entry == null ) continue;
                     if (entry.isPrimary() && (entry.getBackupNodes() == null || entry.getBackupNodes().length == 0)) {
@@ -723,9 +724,9 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
             }
         }
         
-        Iterator i = super.entrySet().iterator();
+        Iterator<Map.Entry<?,?>> i = super.entrySet().iterator();
         while (i.hasNext()) {
-            Map.Entry e = (Map.Entry) i.next();
+            Map.Entry<?,?> e = i.next();
             MapEntry entry = (MapEntry) super.get(e.getKey());
             if (entry==null) continue;
             if (entry.isPrimary() && inSet(member,entry.getBackupNodes())) {
@@ -902,11 +903,11 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
             for ( int i=0; i<mbrs.length;i++ ) {
                 System.out.println("Mbr["+(i+1)+"="+mbrs[i].getName());
             }
-            Iterator i = super.entrySet().iterator();
+            Iterator<Map.Entry<?,?>> i = super.entrySet().iterator();
             int cnt = 0;
 
             while (i.hasNext()) {
-                Map.Entry e = (Map.Entry) i.next();
+                Map.Entry<?,?> e = i.next();
                 System.out.println( (++cnt) + ". " + super.get(e.getKey()));
             }
             System.out.println("EndMap]\n\n");
@@ -961,9 +962,9 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
          */
         @Override
         public void putAll(Map m) {
-            Iterator i = m.entrySet().iterator();
+            Iterator<Map.Entry<?,?>> i = m.entrySet().iterator();
             while ( i.hasNext() ) {
-                Map.Entry entry = (Map.Entry)i.next();
+                Map.Entry<?,?> entry = i.next();
                 put(entry.getKey(),entry.getValue());
             }
         }
@@ -989,9 +990,9 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
             if ( value == null ) {
                 return super.containsValue(value);
             } else {
-                Iterator i = super.entrySet().iterator();
+                Iterator<Map.Entry<?,?>> i = super.entrySet().iterator();
                 while (i.hasNext()) {
-                    Map.Entry e = (Map.Entry) i.next();
+                    Map.Entry<?,?> e = i.next();
                     MapEntry entry = (MapEntry) super.get(e.getKey());
                     if (entry!=null && entry.isPrimary() && value.equals(entry.getValue())) return true;
                 }//while
@@ -1025,9 +1026,9 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
         @Override
         public Set<MapEntry> entrySet() {
             LinkedHashSet<MapEntry> set = new LinkedHashSet<MapEntry>(super.size());
-            Iterator i = super.entrySet().iterator();
+            Iterator<Map.Entry<?,?>> i = super.entrySet().iterator();
             while ( i.hasNext() ) {
-                Map.Entry e = (Map.Entry)i.next();
+                Map.Entry<?,?> e = i.next();
                 Object key = e.getKey();
                 MapEntry entry = (MapEntry)super.get(key);
                 if ( entry != null && entry.isPrimary() ) {
@@ -1042,9 +1043,9 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
             //todo implement
             //should only return keys where this is active.
             LinkedHashSet<Object> set = new LinkedHashSet<Object>(super.size());
-            Iterator i = super.entrySet().iterator();
+            Iterator<Map.Entry<?,?>> i = super.entrySet().iterator();
             while ( i.hasNext() ) {
-                Map.Entry e = (Map.Entry)i.next();
+                Map.Entry<?,?> e = i.next();
                 Object key = e.getKey();
                 MapEntry entry = (MapEntry)super.get(key);
                 if ( entry!=null && entry.isPrimary() ) set.add(key);
@@ -1059,9 +1060,9 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
             //todo, implement a counter variable instead
             //only count active members in this node
             int counter = 0;
-            Iterator it = super.entrySet().iterator();
+            Iterator<Map.Entry<?,?>> it = super.entrySet().iterator();
             while (it!=null && it.hasNext() ) {
-                Map.Entry e = (Map.Entry) it.next();
+                Map.Entry<?,?> e = it.next();
                 if ( e != null ) {
                     MapEntry entry = (MapEntry) super.get(e.getKey());
                     if (entry!=null && entry.isPrimary() && entry.getValue() != null) counter++;
@@ -1078,9 +1079,9 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
         @Override
         public Collection<Object> values() {
             ArrayList<Object> values = new ArrayList<Object>();
-            Iterator i = super.entrySet().iterator();
+            Iterator<Map.Entry<?,?>> i = super.entrySet().iterator();
             while ( i.hasNext() ) {
-                Map.Entry e = (Map.Entry)i.next();
+                Map.Entry<?,?> e = i.next();
                 MapEntry entry = (MapEntry)super.get(e.getKey());
                 if (entry!=null && entry.isPrimary() && entry.getValue()!=null) values.add(entry.getValue());
             }

==================================================
