314568fa450680711f12f01ee050f2166f4263bd
==================================================
Remove APR/Native connector implementation.
==================================================
Mark Thomas
==================================================
Wed Aug 18 20:41:02 2021 +0100
==================================================
Connector.java
index 3c48d90b75..330bcd7d7c 100644
--- a/build.xml
+++ b/build.xml
@@ -507,12 +507,9 @@
     <!-- Remove connectors that are not default -->
     <exclude name="**/AbstractAjpProtocol.class"/>
     <exclude name="**/Ajp*.class"/>
-    <exclude name="**/AjpApr*.class"/>
-    <exclude name="**/Http11Apr*.class"/>
     <exclude name="**/Http11Nio2*.class"/>
     <exclude name="**/JniLifecycleListener.class"/>
     <exclude name="org/apache/tomcat/**/*Nio2*.class"/>
-    <exclude name="org/apache/tomcat/**/Apr*.class"/>
 
     <!-- Minimize bundles to the default set -->
     <exclude name="org/apache/**/LocalStrings_*.properties"/>
@@ -1837,10 +1834,10 @@
   <property name="junit.formatter.extension" value=".txt" />
 
   <target name="test" description="Runs the JUnit test cases"
-          depends="test-nio,test-nio2,test-apr,cobertura-report,test-status" />
+          depends="test-nio,test-nio2,cobertura-report,test-status" />
 
   <target name="test-only" description="Runs the JUnit test cases without additional processing"
-          depends="test-only-nio,test-only-nio2,test-only-apr,test-status" />
+          depends="test-only-nio,test-only-nio2,test-status" />
 
   <target name="test-status"
           description="Analyses logs directory and reports on skipped tests, test failures and test errors">
@@ -1901,19 +1898,6 @@
               extension=".NIO2" />
   </target>
 
-  <target name="test-apr" description="Runs the JUnit test cases for APR. Does not stop on errors."
-          depends="test-compile,deploy,test-apr-exists,cobertura-instrument,test-openssl-exists"
-          if="${apr.exists}">
-    <runtests protocol="org.apache.coyote.http11.Http11AprProtocol"
-              extension=".APR" />
-  </target>
-
-  <target name="test-only-apr" description="Runs the JUnit test cases for APR. Does not stop on errors."
-          depends="cobertura-disabled,test-openssl-exists" if="${execute.test.apr}">
-    <runtests protocol="org.apache.coyote.http11.Http11AprProtocol"
-              extension=".APR" />
-  </target>
-
   <target name="test-apr-exists" description="Checks for APR lib"
           if="${execute.test.apr}">
     <available file="${test.apr.loc}" property="apr.exists" />
@@ -2095,7 +2079,7 @@
   </target>
 
   <target name="cobertura-report" if="${cobertura.enabled}"
-          depends="test-nio,test-nio2,test-apr"
+          depends="test-nio,test-nio2"
           description="Creates report from gathered Cobertura results">
 
     <cobertura-report srcdir="${basedir}/java" destdir="${cobertura.out}"

==================================================
StatusManagerServlet.java
index 0dc26adfaf..30d896a0be 100644
--- a/java/org/apache/catalina/connector/LocalStrings_zh_CN.properties
+++ b/java/org/apache/catalina/connector/LocalStrings_zh_CN.properties
@@ -29,8 +29,6 @@ coyoteConnector.parseBodyMethodNoTrace=方法TRACE禁止包含实体（详情查
 coyoteConnector.protocolHandlerDestroyFailed=协议处理程序销毁失败
 coyoteConnector.protocolHandlerInitializationFailed=协议处理程序初始化失败
 coyoteConnector.protocolHandlerInstantiationFailed=协议处理程序实例化失败
-coyoteConnector.protocolHandlerNoAprLibrary=配置的协议[{0}]需要不可用的APR/本机库
-coyoteConnector.protocolHandlerNoAprListener=配置的协议[{0}]需要不可用的aprlifecycleListener
 coyoteConnector.protocolHandlerPauseFailed=协议处理程序暂停失败
 coyoteConnector.protocolHandlerResumeFailed=协议处理程序恢复失败
 coyoteConnector.protocolHandlerStartFailed=协议处理器启动失败

==================================================
StatusTransformer.java
index 65609b3927..c936ad24c1 100644
--- a/java/org/apache/catalina/manager/StatusManagerServlet.java
+++ b/java/org/apache/catalina/manager/StatusManagerServlet.java
@@ -284,17 +284,6 @@ public class StatusManagerServlet
 
         try {
 
-            // Display operating system statistics using APR if available
-            args = new Object[7];
-            args[0] = smClient.getString("htmlManagerServlet.osPhysicalMemory");
-            args[1] = smClient.getString("htmlManagerServlet.osAvailableMemory");
-            args[2] = smClient.getString("htmlManagerServlet.osTotalPageFile");
-            args[3] = smClient.getString("htmlManagerServlet.osFreePageFile");
-            args[4] = smClient.getString("htmlManagerServlet.osMemoryLoad");
-            args[5] = smClient.getString("htmlManagerServlet.osKernelTime");
-            args[6] = smClient.getString("htmlManagerServlet.osUserTime");
-            StatusTransformer.writeOSState(writer, mode, args);
-
             // Display virtual machine statistics
             args = new Object[9];
             args[0] = smClient.getString("htmlManagerServlet.jvmFreeMemory");

==================================================
SecurityClassLoad.java
index 2cf2cc9f1b..d3942dc368 100644
--- a/java/org/apache/catalina/manager/StatusTransformer.java
+++ b/java/org/apache/catalina/manager/StatusTransformer.java
@@ -20,7 +20,6 @@ import java.io.PrintWriter;
 import java.lang.management.ManagementFactory;
 import java.lang.management.MemoryPoolMXBean;
 import java.lang.management.MemoryUsage;
-import java.lang.reflect.Method;
 import java.text.MessageFormat;
 import java.util.Date;
 import java.util.Enumeration;
@@ -36,7 +35,6 @@ import javax.management.ObjectName;
 
 import jakarta.servlet.http.HttpServletResponse;
 
-import org.apache.tomcat.util.ExceptionUtils;
 import org.apache.tomcat.util.security.Escape;
 
 /**
@@ -143,73 +141,6 @@ public class StatusTransformer {
     }
 
 
-    /**
-     * Write the OS state.
-     *
-     * @param writer The output writer
-     * @param mode Mode <code>0</code> will generate HTML.
-     *             Mode <code>1</code> will generate XML.
-     * @param args I18n labels for the OS state values
-     */
-    public static void writeOSState(PrintWriter writer, int mode, Object[] args) {
-        long[] result = new long[16];
-        boolean ok = false;
-        try {
-            String methodName = "info";
-            Class<?> paramTypes[] = new Class[1];
-            paramTypes[0] = result.getClass();
-            Object paramValues[] = new Object[1];
-            paramValues[0] = result;
-            Method method = Class.forName("org.apache.tomcat.jni.OS")
-                .getMethod(methodName, paramTypes);
-            method.invoke(null, paramValues);
-            ok = true;
-        } catch (Throwable t) {
-            t = ExceptionUtils.unwrapInvocationTargetException(t);
-            ExceptionUtils.handleThrowable(t);
-        }
-
-        if (ok) {
-            if (mode == 0){
-                writer.print("<h1>OS</h1>");
-
-                writer.print("<p>");
-                writer.print( args[0] );
-                writer.print(' ');
-                writer.print(formatSize(Long.valueOf(result[0]), true));
-                writer.print(' ');
-                writer.print(args[1]);
-                writer.print(' ');
-                writer.print(formatSize(Long.valueOf(result[1]), true));
-                writer.print(' ');
-                writer.print(args[2]);
-                writer.print(' ');
-                writer.print(formatSize(Long.valueOf(result[2]), true));
-                writer.print(' ');
-                writer.print(args[3]);
-                writer.print(' ');
-                writer.print(formatSize(Long.valueOf(result[3]), true));
-                writer.print(' ');
-                writer.print(args[4]);
-                writer.print(' ');
-                writer.print(Long.valueOf(result[6]));
-                writer.print("<br>");
-                writer.print(args[5]);
-                writer.print(' ');
-                writer.print(formatTime(Long.valueOf(result[11] / 1000), true));
-                writer.print(' ');
-                writer.print(args[6]);
-                writer.print(' ');
-                writer.print(formatTime(Long.valueOf(result[12] / 1000), true));
-                writer.print("</p>");
-            } else if (mode == 1){
-                // NO-OP
-            }
-        }
-
-    }
-
-
     /**
      * Write the VM state.
      * @param writer The output writer

==================================================
Tomcat.java
index a111c65d82..72a389faa0 100644
--- a/java/org/apache/catalina/security/SecurityClassLoad.java
+++ b/java/org/apache/catalina/security/SecurityClassLoad.java
@@ -187,7 +187,6 @@ public final class SecurityClassLoad {
         // net
         loader.loadClass(basePackage + "util.net.Constants");
         loader.loadClass(basePackage + "util.net.DispatchType");
-        loader.loadClass(basePackage + "util.net.AprEndpoint$AprSocketWrapper$AprOperationState");
         loader.loadClass(basePackage + "util.net.NioEndpoint$NioSocketWrapper$NioOperationState");
         loader.loadClass(basePackage + "util.net.Nio2Endpoint$Nio2SocketWrapper$Nio2OperationState");
         loader.loadClass(basePackage + "util.net.SocketWrapperBase$BlockingMode");

==================================================
AbstractProcessor.java
index e5565d14ba..ffcef38481 100644
--- a/java/org/apache/catalina/startup/Tomcat.java
+++ b/java/org/apache/catalina/startup/Tomcat.java
@@ -552,9 +552,7 @@ public class Tomcat {
             return service.findConnectors()[0];
         }
         // The same as in standard Tomcat configuration.
-        // This creates an APR HTTP connector if AprLifecycleListener has been
-        // configured (created) and Tomcat Native library is available.
-        // Otherwise it creates a NIO HTTP connector.
+        // This creates a NIO HTTP connector.
         Connector connector = new Connector("HTTP/1.1");
         connector.setPort(port);
         service.addConnector(connector);

==================================================
AbstractProtocol.java
index f74f87ae14..0884442bf7 100644
--- a/java/org/apache/coyote/AbstractProcessor.java
+++ b/java/org/apache/coyote/AbstractProcessor.java
@@ -216,7 +216,7 @@ public abstract class AbstractProcessor extends AbstractProcessorLight implement
             dispatchNonBlockingRead();
         } else if (status == SocketEvent.ERROR) {
             // An I/O error occurred on a non-container thread. This includes:
-            // - read/write timeouts fired by the Poller (NIO & APR)
+            // - read/write timeouts fired by the Poller in NIO
             // - completion handler failures in NIO2
 
             if (request.getAttribute(RequestDispatcher.ERROR_EXCEPTION) == null) {
@@ -872,7 +872,7 @@ public abstract class AbstractProcessor extends AbstractProcessorLight implement
                  * onWritePossible() and/or onDataAvailable() as appropriate are made by
                  * the container.
                  *
-                 * Processing the dispatches requires (for APR/native at least)
+                 * Processing the dispatches requires (TODO confirm applies without APR)
                  * that the socket has been added to the waitingRequests queue. This may
                  * not have occurred by the time that the non-container thread completes
                  * triggering the call to this method. Therefore, the coded syncs on the

==================================================
ProtocolHandler.java
index a8b65db28d..630ea90699 100644
--- a/java/org/apache/coyote/AbstractProtocol.java
+++ b/java/org/apache/coyote/AbstractProtocol.java
@@ -176,7 +176,7 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
      * instances of {@link java.security.cert.X509Certificate} it needs to be
      * converted before it can be used and this property controls which JSSE
      * provider is used to perform the conversion. For example it is used with
-     * the AJP connectors, the HTTP APR connector and with the
+     * the AJP connectors and with the
      * {@link org.apache.catalina.valves.SSLValve}. If not specified, the
      * default provider will be used.
      *
@@ -195,12 +195,6 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
     }
 
 
-    @Override
-    public boolean isAprRequired() {
-        return false;
-    }
-
-
     @Override
     public boolean isSendfileSupported() {
         return endpoint.getUseSendfile();

==================================================
AjpAprProtocol.java
index cf25010a83..9cf2889e8a 100644
--- a/java/org/apache/coyote/ProtocolHandler.java
+++ b/java/org/apache/coyote/ProtocolHandler.java
@@ -148,15 +148,6 @@ public interface ProtocolHandler {
     public long awaitConnectionsClose(long waitMillis);
 
 
-    /**
-     * Requires APR/native library
-     *
-     * @return <code>true</code> if this Protocol Handler requires the
-     *         APR/native library, otherwise <code>false</code>
-     */
-    public boolean isAprRequired();
-
-
     /**
      * Does this ProtocolHandler support sendfile?
      *

==================================================
Http11AprProtocol.java
deleted file mode 100644
index 34e34ebe42..0000000000
--- a/java/org/apache/coyote/ajp/AjpAprProtocol.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.coyote.ajp;
-
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-import org.apache.tomcat.util.net.AprEndpoint;
-
-
-/**
- * This the APR/native based protocol handler implementation for AJP.
- *
- * @deprecated  The APR/Native Connector will be removed in Tomcat 10.1.x
- *              onwards.
- */
-@Deprecated
-public class AjpAprProtocol extends AbstractAjpProtocol<Long> {
-
-    private static final Log log = LogFactory.getLog(AjpAprProtocol.class);
-
-    @Override
-    protected Log getLog() { return log; }
-
-
-    @Override
-    public boolean isAprRequired() {
-        // Override since this protocol implementation requires the APR/native
-        // library
-        return true;
-    }
-
-
-    // ------------------------------------------------------------ Constructor
-
-    public AjpAprProtocol() {
-        super(new AprEndpoint());
-    }
-
-
-    // --------------------------------------------------------- Public Methods
-
-    public int getPollTime() { return ((AprEndpoint)getEndpoint()).getPollTime(); }
-    public void setPollTime(int pollTime) { ((AprEndpoint)getEndpoint()).setPollTime(pollTime); }
-
-
-    // ----------------------------------------------------- JMX related methods
-
-    @Override
-    protected String getNamePrefix() {
-        return "ajp-apr";
-    }
-}

==================================================
Address.java
deleted file mode 100644
index b3e681d4f0..0000000000
--- a/java/org/apache/coyote/http11/Http11AprProtocol.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.coyote.http11;
-
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-import org.apache.tomcat.util.net.AprEndpoint;
-
-
-/**
- * Abstract the protocol implementation, including threading, etc.
- * Processor is single threaded and specific to stream-based protocols,
- * will not fit Jk protocols like JNI.
- *
- * @author Remy Maucherat
- * @author Costin Manolache
- *
- * @deprecated  The APR/Native Connector will be removed in Tomcat 10.1.x
- *              onwards.
- */
-@Deprecated
-public class Http11AprProtocol extends AbstractHttp11Protocol<Long> {
-
-    private static final Log log = LogFactory.getLog(Http11AprProtocol.class);
-
-    public Http11AprProtocol() {
-        super(new AprEndpoint());
-    }
-
-
-    @Override
-    protected Log getLog() { return log; }
-
-    @Override
-    public boolean isAprRequired() {
-        // Override since this protocol implementation requires the APR/native
-        // library
-        return true;
-    }
-
-    public int getPollTime() { return ((AprEndpoint)getEndpoint()).getPollTime(); }
-    public void setPollTime(int pollTime) { ((AprEndpoint)getEndpoint()).setPollTime(pollTime); }
-
-    public int getSendfileSize() { return ((AprEndpoint)getEndpoint()).getSendfileSize(); }
-    public void setSendfileSize(int sendfileSize) { ((AprEndpoint)getEndpoint()).setSendfileSize(sendfileSize); }
-
-    public boolean getDeferAccept() { return ((AprEndpoint)getEndpoint()).getDeferAccept(); }
-    public void setDeferAccept(boolean deferAccept) { ((AprEndpoint)getEndpoint()).setDeferAccept(deferAccept); }
-
-
-    // ----------------------------------------------------- JMX related methods
-
-    @Override
-    protected String getNamePrefix() {
-        if (isSSLEnabled()) {
-            return "https-openssl-apr";
-        } else {
-            return "http-apr";
-        }
-    }
-}

==================================================
Directory.java
deleted file mode 100644
index acac8008aa..0000000000
--- a/java/org/apache/tomcat/jni/Address.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.jni;
-
-/** Address
- *
- * @author Mladen Turk
- *
- * @deprecated  The scope of the APR/Native Library will be reduced in Tomcat
- *              10.1.x / Tomcat Native 2.x onwards to only include those
- *              components required to provide OpenSSL integration with the NIO
- *              and NIO2 connectors.
- */
-@Deprecated
-public class Address {
-
-    public static final String APR_ANYADDR = "0.0.0.0";
-    /**
-     * Fill the Sockaddr class from apr_sockaddr_t
-     * @param info Sockaddr class to fill
-     * @param sa Structure pointer
-     * @return <code>true</code> if the operation was successful
-     */
-    public static native boolean fill(Sockaddr info, long sa);
-
-    /**
-     * Create the Sockaddr object from apr_sockaddr_t
-     * @param sa Structure pointer
-     * @return the socket address
-     */
-    public static native Sockaddr getInfo(long sa);
-
-    /**
-     * Create apr_sockaddr_t from hostname, address family, and port.
-     * @param hostname The hostname or numeric address string to resolve/parse, the
-     *                 path of the Unix Domain Socket, or NULL to build an address
-     *                 that corresponds to 0.0.0.0 or ::
-     * @param family The address family to use, or APR_UNSPEC if the system should
-     *               decide.
-     * @param port The port number.
-     * @param flags Special processing flags:
-     * <PRE>
-     *       APR_IPV4_ADDR_OK          first query for IPv4 addresses; only look
-     *                                 for IPv6 addresses if the first query failed;
-     *                                 only valid if family is APR_UNSPEC and hostname
-     *                                 isn't NULL; mutually exclusive with
-     *                                 APR_IPV6_ADDR_OK
-     *       APR_IPV6_ADDR_OK          first query for IPv6 addresses; only look
-     *                                 for IPv4 addresses if the first query failed;
-     *                                 only valid if family is APR_UNSPEC and hostname
-     *                                 isn't NULL and APR_HAVE_IPV6; mutually exclusive
-     *                                 with APR_IPV4_ADDR_OK
-     * </PRE>
-     * @param p The pool for the apr_sockaddr_t and associated storage.
-     * @return The new apr_sockaddr_t.
-     * @throws Exception Operation failed
-     */
-    public static native long info(String hostname, int family,
-                                   int port, int flags, long p)
-        throws Exception;
-    /**
-     * Look up the host name from an apr_sockaddr_t.
-     * @param sa The apr_sockaddr_t.
-     * @param flags Special processing flags.
-     * @return The hostname.
-     */
-    public static native String getnameinfo(long sa, int flags);
-
-    /**
-     * Return the IP address (in numeric address string format) in
-     * an APR socket address.  APR will allocate storage for the IP address
-     * string from the pool of the apr_sockaddr_t.
-     * @param sa The socket address to reference.
-     * @return The IP address.
-     */
-    public static native String getip(long sa);
-
-    /**
-     * Given an apr_sockaddr_t and a service name, set the port for the service
-     * @param sockaddr The apr_sockaddr_t that will have its port set
-     * @param servname The name of the service you wish to use
-     * @return APR status code.
-     */
-    public static native int getservbyname(long sockaddr, String servname);
-
-    /**
-     * Return an apr_sockaddr_t from an apr_socket_t
-     * @param which Which interface do we want the apr_sockaddr_t for?
-     * @param sock The socket to use
-     * @return The returned apr_sockaddr_t.
-     * @throws Exception An error occurred
-     */
-    public static native long get(int which, long sock)
-        throws Exception;
-
-    /**
-     * See if the IP addresses in two APR socket addresses are
-     * equivalent.  Appropriate logic is present for comparing
-     * IPv4-mapped IPv6 addresses with IPv4 addresses.
-     *
-     * @param a One of the APR socket addresses.
-     * @param b The other APR socket address.
-     * @return <code>true</code> if the addresses are equal
-     */
-    public static native boolean equal(long a, long b);
-
-}

==================================================
File.java
deleted file mode 100644
index 473b87b71a..0000000000
--- a/java/org/apache/tomcat/jni/Directory.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.jni;
-
-/** Directory
- *
- * @author Mladen Turk
- *
- * @deprecated  The scope of the APR/Native Library will be reduced in Tomcat
- *              10.1.x / Tomcat Native 2.x onwards to only include those
- *              components required to provide OpenSSL integration with the NIO
- *              and NIO2 connectors.
- */
-@Deprecated
-public class Directory {
-
-    /**
-     * Create a new directory on the file system.
-     * @param path the path for the directory to be created. (use / on all systems)
-     * @param perm Permissions for the new directory.
-     * @param pool the pool to use.
-     * @return the operation result
-     */
-    public static native int make(String path, int perm, long pool);
-
-    /**
-     * Creates a new directory on the file system, but behaves like
-     * 'mkdir -p'. Creates intermediate directories as required. No error
-     * will be reported if PATH already exists.
-     * @param path the path for the directory to be created. (use / on all systems)
-     * @param perm Permissions for the new directory.
-     * @param pool the pool to use.
-     * @return the operation result
-     */
-    public static native int makeRecursive(String path, int perm, long pool);
-
-    /**
-     * Remove directory from the file system.
-     * @param path the path for the directory to be removed. (use / on all systems)
-     * @param pool the pool to use.
-     * @return the operation result
-     */
-    public static native int remove(String path, long pool);
-
-    /**
-     * Find an existing directory suitable as a temporary storage location.
-     * @param pool The pool to use for any necessary allocations.
-     * @return The temp directory.
-     *
-     * This function uses an algorithm to search for a directory that an
-     * an application can use for temporary storage.  Once such a
-     * directory is found, that location is cached by the library.  Thus,
-     * callers only pay the cost of this algorithm once if that one time
-     * is successful.
-     */
-    public static native String tempGet(long pool);
-
-    /**
-     * Open the specified directory.
-     * @param dirname The full path to the directory (use / on all systems)
-     * @param pool The pool to use.
-     * @return The opened directory descriptor.
-     * @throws Error An error occurred
-     */
-    public static native long open(String dirname, long pool)
-        throws Error;
-
-    /**
-     * close the specified directory.
-     * @param thedir the directory descriptor to close.
-     * @return the operation result
-     */
-    public static native int close(long thedir);
-
-    /**
-     * Rewind the directory to the first entry.
-     * @param thedir the directory descriptor to rewind.
-     * @return the operation result
-     */
-    public static native int rewind(long thedir);
-
-
-    /**
-     * Read the next entry from the specified directory.
-     * @param finfo the file info structure and filled in by apr_dir_read
-     * @param wanted The desired apr_finfo_t fields, as a bit flag of APR_FINFO_ values
-     * @param thedir the directory descriptor returned from apr_dir_open
-     * No ordering is guaranteed for the entries read.
-     * @return the operation result
-     */
-    public static native int read(FileInfo finfo, int wanted, long thedir);
-
-}

==================================================
Global.java
deleted file mode 100644
index 3e0c3b1bc7..0000000000
--- a/java/org/apache/tomcat/jni/File.java
+++ /dev/null
@@ -1,751 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.jni;
-/* Import needed classes */
-import java.nio.ByteBuffer;
-
-/** File
- *
- * @author Mladen Turk
- *
- * @deprecated  The scope of the APR/Native Library will be reduced in Tomcat
- *              10.1.x / Tomcat Native 2.x onwards to only include those
- *              components required to provide OpenSSL integration with the NIO
- *              and NIO2 connectors.
- */
-@Deprecated
-public class File {
-
-    /** Open the file for reading */
-    public static final int APR_FOPEN_READ       = 0x00001;
-    /** Open the file for writing */
-    public static final int APR_FOPEN_WRITE      = 0x00002;
-    /** Create the file if not there */
-    public static final int APR_FOPEN_CREATE     = 0x00004;
-    /** Append to the end of the file */
-    public static final int APR_FOPEN_APPEND     = 0x00008;
-    /** Open the file and truncate to 0 length */
-    public static final int APR_FOPEN_TRUNCATE   = 0x00010;
-    /** Open the file in binary mode */
-    public static final int APR_FOPEN_BINARY     = 0x00020;
-    /** Open should fail if APR_CREATE and file exists. */
-    public static final int APR_FOPEN_EXCL       = 0x00040;
-    /** Open the file for buffered I/O */
-    public static final int APR_FOPEN_BUFFERED   = 0x00080;
-    /** Delete the file after close */
-    public static final int APR_FOPEN_DELONCLOSE = 0x00100;
-    /** Platform dependent tag to open the file for
-     * use across multiple threads
-     */
-    public static final int APR_FOPEN_XTHREAD     = 0x00200;
-    /** Platform dependent support for higher level locked read/write
-     * access to support writes across process/machines
-     */
-    public static final int APR_FOPEN_SHARELOCK   = 0x00400;
-    /** Do not register a cleanup when the file is opened */
-    public static final int APR_FOPEN_NOCLEANUP   = 0x00800;
-    /** Advisory flag that this file should support
-     * apr_socket_sendfile operation
-     */
-    public static final int APR_FOPEN_SENDFILE_ENABLED = 0x01000;
-    /** Platform dependent flag to enable large file support;
-     * <br><b>Warning :</b> The APR_LARGEFILE flag only has effect on some platforms
-     * where sizeof(apr_off_t) == 4.  Where implemented, it allows opening
-     * and writing to a file which exceeds the size which can be
-     * represented by apr_off_t (2 gigabytes).  When a file's size does
-     * exceed 2Gb, apr_file_info_get() will fail with an error on the
-     * descriptor, likewise apr_stat()/apr_lstat() will fail on the
-     * filename.  apr_dir_read() will fail with APR_INCOMPLETE on a
-     * directory entry for a large file depending on the particular
-     * APR_FINFO_* flags.  Generally, it is not recommended to use this
-     * flag.
-     */
-    public static final int APR_FOPEN_LARGEFILE      = 0x04000;
-
-    /** Set the file position */
-    public static final int APR_SET = 0;
-    /** Current */
-    public static final int APR_CUR = 1;
-    /** Go to end of file */
-    public static final int APR_END = 2;
-
-    /* flags for apr_file_attrs_set */
-
-    /** File is read-only */
-    public static final int APR_FILE_ATTR_READONLY   = 0x01;
-    /** File is executable */
-    public static final int APR_FILE_ATTR_EXECUTABLE = 0x02;
-    /** File is hidden */
-    public static final int APR_FILE_ATTR_HIDDEN     = 0x04;
-
-
-    /* File lock types/flags */
-
-    /** Shared lock. More than one process or thread can hold a shared lock
-     * at any given time. Essentially, this is a "read lock", preventing
-     * writers from establishing an exclusive lock.
-     */
-    public static final int APR_FLOCK_SHARED    = 1;
-
-    /** Exclusive lock. Only one process may hold an exclusive lock at any
-     * given time. This is analogous to a "write lock".
-     */
-    public static final int APR_FLOCK_EXCLUSIVE = 2;
-    /** mask to extract lock type */
-    public static final int APR_FLOCK_TYPEMASK  = 0x000F;
-    /** do not block while acquiring the file lock */
-    public static final int APR_FLOCK_NONBLOCK  = 0x0010;
-
-    /* apr_filetype_e values for the filetype member of the
-     * apr_file_info_t structure
-     * <br><b>Warning :</b>: Not all of the filetypes below can be determined.
-     * For example, a given platform might not correctly report
-     * a socket descriptor as APR_SOCK if that type isn't
-     * well-identified on that platform.  In such cases where
-     * a filetype exists but cannot be described by the recognized
-     * flags below, the filetype will be APR_UNKFILE.  If the
-     * filetype member is not determined, the type will be APR_NOFILE.
-     */
-
-    /** no file type determined */
-    public static final int APR_NOFILE  = 0;
-    /** a regular file */
-    public static final int APR_REG     = 1;
-    /** a directory */
-    public static final int APR_DIR     = 2;
-    /** a character device */
-    public static final int APR_CHR     = 3;
-    /** a block device */
-    public static final int APR_BLK     = 4;
-    /** a FIFO / pipe */
-    public static final int APR_PIPE    = 5;
-    /** a symbolic link */
-    public static final int APR_LNK     = 6;
-    /** a [unix domain] socket */
-    public static final int APR_SOCK    = 7;
-    /** a file of some other unknown type */
-    public static final int APR_UNKFILE = 127;
-
-
-    /*
-     * apr_file_permissions File Permissions flags
-     */
-
-    public static final int APR_FPROT_USETID     = 0x8000; /** Set user id */
-    public static final int APR_FPROT_UREAD      = 0x0400; /** Read by user */
-    public static final int APR_FPROT_UWRITE     = 0x0200; /** Write by user */
-    public static final int APR_FPROT_UEXECUTE   = 0x0100; /** Execute by user */
-
-    public static final int APR_FPROT_GSETID     = 0x4000; /** Set group id */
-    public static final int APR_FPROT_GREAD      = 0x0040; /** Read by group */
-    public static final int APR_FPROT_GWRITE     = 0x0020; /** Write by group */
-    public static final int APR_FPROT_GEXECUTE   = 0x0010; /** Execute by group */
-
-    public static final int APR_FPROT_WSTICKY    = 0x2000; /** Sticky bit */
-    public static final int APR_FPROT_WREAD      = 0x0004; /** Read by others */
-    public static final int APR_FPROT_WWRITE     = 0x0002; /** Write by others */
-    public static final int APR_FPROT_WEXECUTE   = 0x0001; /** Execute by others */
-    public static final int APR_FPROT_OS_DEFAULT = 0x0FFF; /** use OS's default permissions */
-
-
-    public static final int APR_FINFO_LINK   = 0x00000001; /** Stat the link not the file itself if it is a link */
-    public static final int APR_FINFO_MTIME  = 0x00000010; /** Modification Time */
-    public static final int APR_FINFO_CTIME  = 0x00000020; /** Creation or inode-changed time */
-    public static final int APR_FINFO_ATIME  = 0x00000040; /** Access Time */
-    public static final int APR_FINFO_SIZE   = 0x00000100; /** Size of the file */
-    public static final int APR_FINFO_CSIZE  = 0x00000200; /** Storage size consumed by the file */
-    public static final int APR_FINFO_DEV    = 0x00001000; /** Device */
-    public static final int APR_FINFO_INODE  = 0x00002000; /** Inode */
-    public static final int APR_FINFO_NLINK  = 0x00004000; /** Number of links */
-    public static final int APR_FINFO_TYPE   = 0x00008000; /** Type */
-    public static final int APR_FINFO_USER   = 0x00010000; /** User */
-    public static final int APR_FINFO_GROUP  = 0x00020000; /** Group */
-    public static final int APR_FINFO_UPROT  = 0x00100000; /** User protection bits */
-    public static final int APR_FINFO_GPROT  = 0x00200000; /** Group protection bits */
-    public static final int APR_FINFO_WPROT  = 0x00400000; /** World protection bits */
-    public static final int APR_FINFO_ICASE  = 0x01000000; /** if dev is case insensitive */
-    public static final int APR_FINFO_NAME   = 0x02000000; /** -&gt;name in proper case */
-
-    public static final int APR_FINFO_MIN    = 0x00008170; /** type, mtime, ctime, atime, size */
-    public static final int APR_FINFO_IDENT  = 0x00003000; /** dev and inode */
-    public static final int APR_FINFO_OWNER  = 0x00030000; /** user and group */
-    public static final int APR_FINFO_PROT   = 0x00700000; /**  all protections */
-    public static final int APR_FINFO_NORM   = 0x0073b170; /**  an atomic unix apr_stat() */
-    public static final int APR_FINFO_DIRENT = 0x02000000; /**  an atomic unix apr_dir_read() */
-
-
-
-    /**
-     * Open the specified file.
-     * @param fname The full path to the file (using / on all systems)
-     * @param flag Or'ed value of:
-     * <PRE>
-     * APR_FOPEN_READ              open for reading
-     * APR_FOPEN_WRITE             open for writing
-     * APR_FOPEN_CREATE            create the file if not there
-     * APR_FOPEN_APPEND            file ptr is set to end prior to all writes
-     * APR_FOPEN_TRUNCATE          set length to zero if file exists
-     * APR_FOPEN_BINARY            not a text file (This flag is ignored on
-     *                             UNIX because it has no meaning)
-     * APR_FOPEN_BUFFERED          buffer the data.  Default is non-buffered
-     * APR_FOPEN_EXCL              return error if APR_CREATE and file exists
-     * APR_FOPEN_DELONCLOSE        delete the file after closing.
-     * APR_FOPEN_XTHREAD           Platform dependent tag to open the file
-     *                             for use across multiple threads
-     * APR_FOPEN_SHARELOCK         Platform dependent support for higher
-     *                             level locked read/write access to support
-     *                             writes across process/machines
-     * APR_FOPEN_NOCLEANUP         Do not register a cleanup with the pool
-     *                             passed in on the <EM>pool</EM> argument (see below).
-     *                             The apr_os_file_t handle in apr_file_t will not
-     *                             be closed when the pool is destroyed.
-     * APR_FOPEN_SENDFILE_ENABLED  Open with appropriate platform semantics
-     *                             for sendfile operations.  Advisory only,
-     *                             apr_socket_sendfile does not check this flag.
-     * </PRE>
-     * @param perm Access permissions for file.
-     * @param pool The pool to use.
-     * If perm is APR_OS_DEFAULT and the file is being created,
-     * appropriate default permissions will be used.
-     * @return The opened file descriptor.
-     * @throws Error An error occurred
-     */
-    public static native long open(String fname, int flag, int perm, long pool)
-        throws Error;
-
-    /**
-     * Close the specified file.
-     * @param file The file descriptor to close.
-     * @return the operation status
-     */
-    public static native int close(long file);
-
-    /**
-     * Flush the file's buffer.
-     * @param thefile The file descriptor to flush
-     * @return the operation status
-     */
-    public static native int flush(long thefile);
-
-    /**
-     * Open a temporary file
-     * @param templ The template to use when creating a temp file.
-     * @param flags The flags to open the file with. If this is zero,
-     *              the file is opened with
-     *              APR_CREATE | APR_READ | APR_WRITE | APR_EXCL | APR_DELONCLOSE
-     * @param pool The pool to allocate the file out of.
-     * @return The apr file to use as a temporary file.
-     *
-     * This function  generates  a unique temporary file name from template.
-     * The last six characters of template must be XXXXXX and these are replaced
-     * with a string that makes the filename unique. Since it will  be  modified,
-     * template must not be a string constant, but should be declared as a character
-     * array.
-     * @throws Error An error occurred
-     */
-    public static native long mktemp(String templ, int flags, long pool)
-        throws Error;
-
-    /**
-     * Delete the specified file.
-     * @param path The full path to the file (using / on all systems)
-     * @param pool The pool to use.
-     * If the file is open, it won't be removed until all
-     * instances are closed.
-     * @return the operation status
-     */
-    public static native int remove(String path, long pool);
-
-    /**
-     * Rename the specified file.
-     * <br><b>Warning :</b> If a file exists at the new location, then it will be
-     * overwritten.  Moving files or directories across devices may not be
-     * possible.
-     * @param fromPath The full path to the original file (using / on all systems)
-     * @param toPath The full path to the new file (using / on all systems)
-     * @param pool The pool to use.
-     * @return the operation status
-     */
-    public static native int rename(String fromPath, String toPath, long pool);
-
-    /**
-     * Copy the specified file to another file.
-     * The new file does not need to exist, it will be created if required.
-     * <br><b>Warning :</b> If the new file already exists, its contents will be overwritten.
-     * @param fromPath The full path to the original file (using / on all systems)
-     * @param toPath The full path to the new file (using / on all systems)
-     * @param perms Access permissions for the new file if it is created.
-     *     In place of the usual or'd combination of file permissions, the
-     *     value APR_FILE_SOURCE_PERMS may be given, in which case the source
-     *     file's permissions are copied.
-     * @param pool The pool to use.
-     * @return the operation status
-     */
-    public static native int copy(String fromPath, String toPath, int perms, long pool);
-
-    /**
-     * Append the specified file to another file.
-     * The new file does not need to exist, it will be created if required.
-     * @param fromPath The full path to the source file (use / on all systems)
-     * @param toPath The full path to the destination file (use / on all systems)
-     * @param perms Access permissions for the destination file if it is created.
-     *     In place of the usual or'd combination of file permissions, the
-     *     value APR_FILE_SOURCE_PERMS may be given, in which case the source
-     *     file's permissions are copied.
-     * @param pool The pool to use.
-     * @return the operation status
-     */
-    public static native int append(String fromPath, String toPath, int perms, long pool);
-
-    /**
-     * Write the string into the specified file.
-     * @param str The string to write. Must be NUL terminated!
-     * @param thefile The file descriptor to write to
-     * @return the operation status
-     */
-    public static native int puts(byte [] str, long thefile);
-
-    /**
-     * Move the read/write file offset to a specified byte within a file.
-     * @param thefile The file descriptor
-     * @param where How to move the pointer, one of:
-     * <PRE>
-     * APR_SET  --  set the offset to offset
-     * APR_CUR  --  add the offset to the current position
-     * APR_END  --  add the offset to the current file size
-     * </PRE>
-     * @param offset The offset to move the pointer to.
-     * @return Offset the pointer was actually moved to.
-     * @throws Error If an error occurs reading the file
-     */
-    public static native long seek(long thefile, int where, long offset)
-        throws Error;
-
-    /**
-     * Write a character into the specified file.
-     * @param ch The character to write.
-     * @param thefile The file descriptor to write to
-     * @return the operation status
-     */
-    public static native int putc(byte ch, long thefile);
-
-    /**
-     * Put a character back onto a specified stream.
-     * @param ch The character to write.
-     * @param thefile The file descriptor to write to
-     * @return the operation status
-     */
-    public static native int ungetc(byte ch, long thefile);
-
-    /**
-     * Write data to the specified file.
-     *
-     * Write will write up to the specified number of
-     * bytes, but never more.  If the OS cannot write that many bytes, it
-     * will write as many as it can.  The third argument is modified to
-     * reflect the * number of bytes written.
-     *
-     * It is possible for both bytes to be written and an error to
-     * be returned.  APR_EINTR is never returned.
-     * @param thefile The file descriptor to write to.
-     * @param buf The buffer which contains the data.
-     * @param offset Start offset in buf
-     * @param nbytes The number of bytes to write
-     * @return The number of bytes written.
-     */
-    public static native int write(long thefile, byte[] buf, int offset, int nbytes);
-
-    /**
-     * Write data to the specified file.
-     *
-     * Write will write up to the specified number of
-     * bytes, but never more.  If the OS cannot write that many bytes, it
-     * will write as many as it can.  The third argument is modified to
-     * reflect the * number of bytes written.
-     *
-     * It is possible for both bytes to be written and an error to
-     * be returned.  APR_EINTR is never returned.
-     * @param thefile The file descriptor to write to.
-     * @param buf The direct Byte buffer which contains the data.
-     * @param offset Start offset in buf
-     * @param nbytes The number of bytes to write
-     * @return The number of bytes written.
-     */
-    public static native int writeb(long thefile, ByteBuffer buf, int offset, int nbytes);
-
-    /**
-     * Write data to the specified file, ensuring that all of the data is
-     * written before returning.
-     *
-     * Write will write up to the specified number of
-     * bytes, but never more.  If the OS cannot write that many bytes, the
-     * process/thread will block until they can be written. Exceptional
-     * error such as "out of space" or "pipe closed" will terminate with
-     * an error.
-     *
-     * It is possible for both bytes to be written and an error to
-     * be returned.  And if *bytes_written is less than nbytes, an
-     * accompanying error is _always_ returned.
-     *
-     * APR_EINTR is never returned.
-     * @param thefile The file descriptor to write to.
-     * @param buf The buffer which contains the data.
-     * @param offset Start offset in buf
-     * @param nbytes The number of bytes to write
-     * @return The number of bytes written.
-     */
-    public static native int writeFull(long thefile, byte[] buf, int offset, int nbytes);
-
-    /**
-     * Write data to the specified file, ensuring that all of the data is
-     * written before returning.
-     *
-     * Write will write up to the specified number of
-     * bytes, but never more.  If the OS cannot write that many bytes, the
-     * process/thread will block until they can be written. Exceptional
-     * error such as "out of space" or "pipe closed" will terminate with
-     * an error.
-     *
-     * It is possible for both bytes to be written and an error to
-     * be returned.  And if *bytes_written is less than nbytes, an
-     * accompanying error is _always_ returned.
-     *
-     * APR_EINTR is never returned.
-     * @param thefile The file descriptor to write to.
-     * @param buf The direct ByteBuffer which contains the data.
-     * @param offset Start offset in buf
-     * @param nbytes The number of bytes to write.
-     * @return The number of bytes written.
-     */
-    public static native int writeFullb(long thefile, ByteBuffer buf, int offset, int nbytes);
-
-    /**
-     * Write data from array of byte arrays to the specified file.
-     *
-     * It is possible for both bytes to be written and an error to
-     * be returned.  APR_EINTR is never returned.
-     *
-     * apr_file_writev is available even if the underlying
-     * operating system doesn't provide writev().
-     * @param thefile The file descriptor to write to.
-     * @param vec The array from which to get the data to write to the file.
-     * @return The number of bytes written.
-     */
-    public static native int writev(long thefile, byte[][] vec);
-
-    /**
-     * Write data from array of byte arrays to the specified file,
-     * ensuring that all of the data is written before returning.
-     *
-     * writevFull is available even if the underlying
-     * operating system doesn't provide writev().
-     * @param thefile The file descriptor to write to.
-     * @param vec The array from which to get the data to write to the file.
-     * @return The number of bytes written.
-     */
-    public static native int writevFull(long thefile, byte[][] vec);
-
-    /**
-     * Read data from the specified file.
-     *
-     * apr_file_read will read up to the specified number of
-     * bytes, but never more.  If there isn't enough data to fill that
-     * number of bytes, all of the available data is read.  The third
-     * argument is modified to reflect the number of bytes read.  If a
-     * char was put back into the stream via ungetc, it will be the first
-     * character returned.
-     *
-     * It is not possible for both bytes to be read and an APR_EOF
-     * or other error to be returned.  APR_EINTR is never returned.
-     * @param thefile The file descriptor to read from.
-     * @param buf The buffer to store the data to.
-     * @param offset Start offset in buf
-     * @param nbytes The number of bytes to read
-     * @return the number of bytes read.
-     */
-    public static native int read(long thefile, byte[] buf,  int offset, int nbytes);
-
-    /**
-     * Read data from the specified file.
-     *
-     * apr_file_read will read up to the specified number of
-     * bytes, but never more.  If there isn't enough data to fill that
-     * number of bytes, all of the available data is read.  The third
-     * argument is modified to reflect the number of bytes read.  If a
-     * char was put back into the stream via ungetc, it will be the first
-     * character returned.
-     *
-     * It is not possible for both bytes to be read and an APR_EOF
-     * or other error to be returned.  APR_EINTR is never returned.
-     * @param thefile The file descriptor to read from.
-     * @param buf The direct Byte buffer to store the data to.
-     * @param offset Start offset in buf
-     * @param nbytes The number of bytes to read.
-     * @return the number of bytes read.
-     */
-    public static native int readb(long thefile, ByteBuffer buf,  int offset, int nbytes);
-
-    /**
-     * Read data from the specified file, ensuring that the buffer is filled
-     * before returning.
-     *
-     * Read will read up to the specified number of
-     * bytes, but never more.  If there isn't enough data to fill that
-     * number of bytes, then the process/thread will block until it is
-     * available or EOF is reached.  If a char was put back into the
-     * stream via ungetc, it will be the first character returned.
-     *
-     * It is possible for both bytes to be read and an error to be
-     * returned.  And if *bytes_read is less than nbytes, an accompanying
-     * error is _always_ returned.
-     *
-     * APR_EINTR is never returned.
-     * @param thefile The file descriptor to read from.
-     * @param buf The buffer to store the data to.
-     * @param offset Start offset in buf
-     * @param nbytes The number of bytes to read
-     * @return the number of bytes read.
-     */
-    public static native int readFull(long thefile, byte[] buf,  int offset, int nbytes);
-
-    /**
-     * Read data from the specified file, ensuring that the buffer is filled
-     * before returning.
-     *
-     * Read will read up to the specified number of
-     * bytes, but never more.  If there isn't enough data to fill that
-     * number of bytes, then the process/thread will block until it is
-     * available or EOF is reached.  If a char was put back into the
-     * stream via ungetc, it will be the first character returned.
-     *
-     * It is possible for both bytes to be read and an error to be
-     * returned.  And if *bytes_read is less than nbytes, an accompanying
-     * error is _always_ returned.
-     *
-     * APR_EINTR is never returned.
-     * @param thefile The file descriptor to read from.
-     * @param buf The direct ByteBuffer to store the data to.
-     * @param offset Start offset in buf
-     * @param nbytes The number of bytes to read.
-     * @return the number of bytes read.
-     */
-    public static native int readFullb(long thefile, ByteBuffer buf,  int offset, int nbytes);
-
-    /**
-     * Read a string from the specified file.
-     * The buffer will be NUL-terminated if any characters are stored.
-     * @param buf The buffer to store the string in.
-     * @param offset Start offset in buf
-     * @param thefile The file descriptor to read from
-     * @return the number of bytes read.
-     */
-    public static native int gets(byte[] buf,  int offset, long thefile);
-
-
-    /**
-     * Read a character from the specified file.
-     * @param thefile The file descriptor to read from
-     * @return The read character
-     * @throws Error If an error occurs reading the file
-     */
-    public static native int getc(long thefile)
-        throws Error;
-
-    /**
-     * Are we at the end of the file
-     * @param fptr The apr file we are testing.
-     * @return Returns APR_EOF if we are at the end of file, APR_SUCCESS otherwise.
-     */
-    public static native int eof(long fptr);
-
-    /**
-     * Return the file name of the current file.
-     * @param thefile The currently open file.
-     * @return the name
-     */
-    public static native String nameGet(long thefile);
-
-    /**
-     * Set the specified file's permission bits.
-     * <br><b>Warning :</b> Some platforms may not be able to apply all of the
-     * available permission bits; APR_INCOMPLETE will be returned if some
-     * permissions are specified which could not be set.
-     * <br><b>Warning :</b> Platforms which do not implement this feature will return
-     * APR_ENOTIMPL.
-     * @param fname The file (name) to apply the permissions to.
-     * @param perms The permission bits to apply to the file.
-     * @return the operation status
-     */
-    public static native int permsSet(String fname, int perms);
-
-    /**
-     * Set attributes of the specified file.
-     * This function should be used in preference to explicit manipulation
-     *      of the file permissions, because the operations to provide these
-     *      attributes are platform specific and may involve more than simply
-     *      setting permission bits.
-     * <br><b>Warning :</b> Platforms which do not implement this feature will return
-     *      APR_ENOTIMPL.
-     * @param fname The full path to the file (using / on all systems)
-     * @param attributes Or'd combination of
-     * <PRE>
-     *            APR_FILE_ATTR_READONLY   - make the file readonly
-     *            APR_FILE_ATTR_EXECUTABLE - make the file executable
-     *            APR_FILE_ATTR_HIDDEN     - make the file hidden
-     * </PRE>
-     * @param mask Mask of valid bits in attributes.
-     * @param pool the pool to use.
-     * @return the operation status
-     */
-    public static native int  attrsSet(String fname, int attributes, int mask, long pool);
-
-    /**
-     * Set the mtime of the specified file.
-     * <br><b>Warning :</b> Platforms which do not implement this feature will return
-     *      APR_ENOTIMPL.
-     * @param fname The full path to the file (using / on all systems)
-     * @param mtime The mtime to apply to the file in microseconds
-     * @param pool The pool to use.
-     * @return the operation status
-     */
-    public static native int  mtimeSet(String fname, long mtime, long pool);
-
-    /**
-     * Establish a lock on the specified, open file. The lock may be advisory
-     * or mandatory, at the discretion of the platform. The lock applies to
-     * the file as a whole, rather than a specific range. Locks are established
-     * on a per-thread/process basis; a second lock by the same thread will not
-     * block.
-     * @param thefile The file to lock.
-     * @param type The type of lock to establish on the file.
-     * @return the operation status
-     */
-    public static native int lock(long thefile, int type);
-
-    /**
-     * Remove any outstanding locks on the file.
-     * @param thefile The file to unlock.
-     * @return the operation status
-     */
-    public static native int unlock(long thefile);
-
-    /**
-     * Retrieve the flags that were passed into apr_file_open()
-     * when the file was opened.
-     * @param file The file to retrieve flags.
-     * @return the flags
-     */
-    public static native int flagsGet(long file);
-
-    /**
-     * Truncate the file's length to the specified offset
-     * @param fp The file to truncate
-     * @param offset The offset to truncate to.
-     * @return the operation status
-     */
-    public static native int trunc(long fp, long offset);
-
-    /**
-     * Create an anonymous pipe.
-     * @param io io[0] The file descriptors to use as input to the pipe.
-     *           io[1] The file descriptor to use as output from the pipe.
-     * @param pool The pool to operate on.
-     * @return the operation status
-     */
-    public static native int pipeCreate(long [] io, long pool);
-
-    /**
-     * Get the timeout value for a pipe or manipulate the blocking state.
-     * @param thepipe The pipe we are getting a timeout for.
-     * @return The current timeout value in microseconds.
-     * @throws Error If an error occurs
-     */
-    public static native long pipeTimeoutGet(long thepipe)
-        throws Error;
-
-    /**
-     * Set the timeout value for a pipe or manipulate the blocking state.
-     * @param thepipe The pipe we are setting a timeout on.
-     * @param timeout The timeout value in microseconds.  Values &lt; 0 mean
-     *        wait forever, 0 means do not wait at all.
-     * @return the operation status
-     */
-    public static native int pipeTimeoutSet(long thepipe, long timeout);
-
-    /**
-     * Duplicate the specified file descriptor.
-     * @param newFile The file to duplicate.
-     * newFile must point to a valid apr_file_t, or point to NULL.
-     * @param oldFile The file to duplicate.
-     * @param pool The pool to use for the new file.
-     * @return Duplicated file structure.
-     * @throws Error If an error occurs reading the file descriptor
-     */
-    public static native long dup(long newFile, long oldFile, long pool)
-        throws Error;
-
-    /**
-     * Duplicate the specified file descriptor and close the original.
-     * @param newFile The old file that is to be closed and reused.
-     * newFile MUST point at a valid apr_file_t. It cannot be NULL.
-     * @param oldFile The file to duplicate.
-     * @param pool The pool to use for the new file.
-     * @return the operation status
-     */
-    public static native int dup2(long newFile, long oldFile, long pool);
-
-    /**
-     * Get the specified file's stats.  The file is specified by filename,
-     * instead of using a pre-opened file.
-     * @param finfo Where to store the information about the file, which is
-     * never touched if the call fails.
-     * @param fname The name of the file to stat.
-     * @param wanted The desired apr_finfo_t fields, as a bit flag of APR_FINFO_ values
-     * @param pool the pool to use to allocate the new file.
-     * @return the operation status
-     */
-    public static native int stat(FileInfo finfo, String fname, int wanted, long pool);
-
-    /**
-     * Get the specified file's stats.  The file is specified by filename,
-     * instead of using a pre-opened file.
-     * @param fname The name of the file to stat.
-     * @param wanted The desired apr_finfo_t fields, as a bit flag of APR_FINFO_ values
-     * @param pool the pool to use to allocate the new file.
-     * @return FileInfo object.
-     */
-    public static native FileInfo getStat(String fname, int wanted, long pool);
-
-    /**
-     * Get the specified file's stats.
-     * @param finfo Where to store the information about the file.
-     * @param wanted The desired apr_finfo_t fields, as a bit flag of APR_FINFO_ values
-     * @param thefile The file to get information about.
-     * @return the operation status
-     */
-    public static native int infoGet(FileInfo finfo, int wanted, long thefile);
-
-
-    /**
-     * Get the specified file's stats.
-     * @param wanted The desired apr_finfo_t fields, as a bit flag of APR_FINFO_ values
-     * @param thefile The file to get information about.
-     * @return FileInfo object.
-     */
-    public static native FileInfo getInfo(int wanted, long thefile);
-
-}

==================================================
Local.java
deleted file mode 100644
index 7da6740f88..0000000000
--- a/java/org/apache/tomcat/jni/Global.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.jni;
-
-/** Global
- *
- * @author Mladen Turk
- *
- * @deprecated  The scope of the APR/Native Library will be reduced in Tomcat
- *              10.1.x / Tomcat Native 2.x onwards to only include those
- *              components required to provide OpenSSL integration with the NIO
- *              and NIO2 connectors.
- */
-@Deprecated
-public class Global {
-
-    /**
-     * Create and initialize a mutex that can be used to synchronize both
-     * processes and threads. Note: There is considerable overhead in using
-     * this API if only cross-process or cross-thread mutual exclusion is
-     * required. See apr_proc_mutex.h and apr_thread_mutex.h for more
-     * specialized lock routines.
-     * <br><b>Warning :</b> Check APR_HAS_foo_SERIALIZE defines to see if the platform supports
-     *          APR_LOCK_foo.  Only APR_LOCK_DEFAULT is portable.
-     * @param fname A file name to use if the lock mechanism requires one.  This
-     *        argument should always be provided.  The lock code itself will
-     *        determine if it should be used.
-     * @param mech The mechanism to use for the interprocess lock, if any; one of
-     * <PRE>
-     *            APR_LOCK_FCNTL
-     *            APR_LOCK_FLOCK
-     *            APR_LOCK_SYSVSEM
-     *            APR_LOCK_POSIXSEM
-     *            APR_LOCK_PROC_PTHREAD
-     *            APR_LOCK_DEFAULT     pick the default mechanism for the platform
-     * </PRE>
-     * @param pool the pool from which to allocate the mutex.
-     * @return Newly created mutex.
-     * @throws Error If an error occurred
-     */
-    public static native long create(String fname, int mech, long pool)
-        throws Error;
-
-    /**
-     * Re-open a mutex in a child process.
-     * @param fname A file name to use if the mutex mechanism requires one.  This
-     *              argument should always be provided.  The mutex code itself will
-     *              determine if it should be used.  This filename should be the
-     *              same one that was passed to apr_proc_mutex_create().
-     * @param pool The pool to operate on.
-     * This function must be called to maintain portability, even
-     *         if the underlying lock mechanism does not require it.
-     * @return Newly opened mutex.
-     * @throws Error If an error occurred
-     */
-    public static native long childInit(String fname, long pool)
-        throws Error;
-
-    /**
-     * Acquire the lock for the given mutex. If the mutex is already locked,
-     * the current thread will be put to sleep until the lock becomes available.
-     * @param mutex the mutex on which to acquire the lock.
-     * @return the operation status
-     */
-    public static native int lock(long mutex);
-
-    /**
-     * Attempt to acquire the lock for the given mutex. If the mutex has already
-     * been acquired, the call returns immediately with APR_EBUSY. Note: it
-     * is important that the APR_STATUS_IS_EBUSY(s) macro be used to determine
-     * if the return value was APR_EBUSY, for portability reasons.
-     * @param mutex the mutex on which to attempt the lock acquiring.
-     * @return the operation status
-     */
-    public static native int trylock(long mutex);
-
-    /**
-     * Release the lock for the given mutex.
-     * @param mutex the mutex from which to release the lock.
-     * @return the operation status
-     */
-    public static native int unlock(long mutex);
-
-    /**
-     * Destroy the mutex and free the memory associated with the lock.
-     * @param mutex the mutex to destroy.
-     * @return the operation status
-     */
-    public static native int destroy(long mutex);
-
-}

==================================================
Lock.java
deleted file mode 100644
index fd0f3bb064..0000000000
--- a/java/org/apache/tomcat/jni/Local.java
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.jni;
-
-/**
- * Local socket.
- *
- * @author Mladen Turk
- *
- * @deprecated  The scope of the APR/Native Library will be reduced in Tomcat
- *              10.1.x / Tomcat Native 2.x onwards to only include those
- *              components required to provide OpenSSL integration with the NIO
- *              and NIO2 connectors.
- */
-@Deprecated
-public class Local {
-
-    /**
-     * Create a socket.
-     * @param path The address of the new socket.
-     * @param cont The parent pool to use
-     * @return The new socket that has been set up.
-     * @throws Exception If socket creation failed
-     */
-    public static native long create(String path, long cont)
-        throws Exception;
-
-    /**
-     * Bind the socket to its associated port
-     * @param sock The socket to bind
-     * @param sa The socket address to bind to
-     * This may be where we will find out if there is any other process
-     *      using the selected port.
-     * @return the operation status
-     */
-    public static native int bind(long sock, long sa);
-
-    /**
-     * Listen to a bound socket for connections.
-     * @param sock The socket to listen on
-     * @param backlog The number of outstanding connections allowed in the sockets
-     *                listen queue.  If this value is less than zero, for NT pipes
-     *                the number of instances is unlimited.
-     * @return the operation status
-     */
-    public static native int listen(long sock, int backlog);
-
-    /**
-     * Accept a new connection request
-     * @param sock The socket we are listening on.
-     * @return  A copy of the socket that is connected to the socket that
-     *          made the connection request.  This is the socket which should
-     *          be used for all future communication.
-     * @throws Exception If accept failed
-     */
-    public static native long accept(long sock)
-        throws Exception;
-
-    /**
-     * Issue a connection request to a socket either on the same machine
-     * or a different one.
-     * @param sock The socket we wish to use for our side of the connection
-     * @param sa The address of the machine we wish to connect to.
-     *           Unused for NT Pipes.
-     * @return the operation status
-     */
-    public static native int connect(long sock, long sa);
-
-}

==================================================
Mmap.java
deleted file mode 100644
index 9803197cf3..0000000000
--- a/java/org/apache/tomcat/jni/Lock.java
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.jni;
-
-/** Lock
- *
- * @author Mladen Turk
- *
- * @deprecated  The scope of the APR/Native Library will be reduced in Tomcat
- *              10.1.x / Tomcat Native 2.x onwards to only include those
- *              components required to provide OpenSSL integration with the NIO
- *              and NIO2 connectors.
- */
-@Deprecated
-public class Lock {
-
-    /**
-     * Enumerated potential types for APR process locking methods
-     * <br><b>Warning :</b> Check APR_HAS_foo_SERIALIZE defines to see if the platform supports
-     *          APR_LOCK_foo.  Only APR_LOCK_DEFAULT is portable.
-     */
-
-    public static final int APR_LOCK_FCNTL        = 0; /** fcntl() */
-    public static final int APR_LOCK_FLOCK        = 1; /** flock() */
-    public static final int APR_LOCK_SYSVSEM      = 2; /** System V Semaphores */
-    public static final int APR_LOCK_PROC_PTHREAD = 3; /** POSIX pthread process-based locking */
-    public static final int APR_LOCK_POSIXSEM     = 4; /** POSIX semaphore process-based locking */
-    public static final int APR_LOCK_DEFAULT      = 5; /** Use the default process lock */
-
-    /**
-     * Create and initialize a mutex that can be used to synchronize processes.
-     * <br><b>Warning :</b> Check APR_HAS_foo_SERIALIZE defines to see if the platform supports
-     *          APR_LOCK_foo.  Only APR_LOCK_DEFAULT is portable.
-     * @param fname A file name to use if the lock mechanism requires one.  This
-     *        argument should always be provided.  The lock code itself will
-     *        determine if it should be used.
-     * @param mech The mechanism to use for the interprocess lock, if any; one of
-     * <PRE>
-     *            APR_LOCK_FCNTL
-     *            APR_LOCK_FLOCK
-     *            APR_LOCK_SYSVSEM
-     *            APR_LOCK_POSIXSEM
-     *            APR_LOCK_PROC_PTHREAD
-     *            APR_LOCK_DEFAULT     pick the default mechanism for the platform
-     * </PRE>
-     * @param pool the pool from which to allocate the mutex.
-     * @return Newly created mutex.
-     * @throws Error An error occurred
-     */
-    public static native long create(String fname, int mech, long pool)
-        throws Error;
-
-    /**
-     * Re-open a mutex in a child process.
-     * This function must be called to maintain portability, even
-     * if the underlying lock mechanism does not require it.
-     * @param fname A file name to use if the mutex mechanism requires one.  This
-     *              argument should always be provided.  The mutex code itself will
-     *              determine if it should be used.  This filename should be the
-     *              same one that was passed to apr_proc_mutex_create().
-     * @param pool The pool to operate on.
-     * @return Newly opened mutex.
-     * @throws Error An error occurred
-     */
-    public static native long childInit(String fname, long pool)
-        throws Error;
-
-    /**
-     * Acquire the lock for the given mutex. If the mutex is already locked,
-     * the current thread will be put to sleep until the lock becomes available.
-     * @param mutex the mutex on which to acquire the lock.
-     * @return the operation status
-     */
-    public static native int lock(long mutex);
-
-    /**
-     * Attempt to acquire the lock for the given mutex. If the mutex has already
-     * been acquired, the call returns immediately with APR_EBUSY. Note: it
-     * is important that the APR_STATUS_IS_EBUSY(s) macro be used to determine
-     * if the return value was APR_EBUSY, for portability reasons.
-     * @param mutex the mutex on which to attempt the lock acquiring.
-     * @return the operation status
-     */
-    public static native int trylock(long mutex);
-
-    /**
-     * Release the lock for the given mutex.
-     * @param mutex the mutex from which to release the lock.
-     * @return the operation status
-     */
-    public static native int unlock(long mutex);
-
-    /**
-     * Destroy the mutex and free the memory associated with the lock.
-     * @param mutex the mutex to destroy.
-     * @return the operation status
-     */
-    public static native int destroy(long mutex);
-
-    /**
-     * Return the name of the lockfile for the mutex, or NULL
-     * if the mutex doesn't use a lock file
-     * @param mutex the name of the mutex
-     * @return the name of the lock file
-     */
-    public static native String lockfile(long mutex);
-
-    /**
-     * Display the name of the mutex, as it relates to the actual method used.
-     * This matches the valid options for Apache's AcceptMutex directive
-     * @param mutex the name of the mutex
-     * @return the name of the mutex
-     */
-    public static native String name(long mutex);
-
-    /**
-     * Display the name of the default mutex: APR_LOCK_DEFAULT
-     * @return the default name
-     */
-    public static native String defname();
-
-}

==================================================
Multicast.java
deleted file mode 100644
index 16a88a151d..0000000000
--- a/java/org/apache/tomcat/jni/Mmap.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.jni;
-
-/** Mmap
- *
- * @author Mladen Turk
- *
- * @deprecated  The scope of the APR/Native Library will be reduced in Tomcat
- *              10.1.x / Tomcat Native 2.x onwards to only include those
- *              components required to provide OpenSSL integration with the NIO
- *              and NIO2 connectors.
- */
-@Deprecated
-public class Mmap {
-    /** MMap opened for reading */
-    public static final int APR_MMAP_READ  = 1;
-    /** MMap opened for writing */
-    public static final int APR_MMAP_WRITE = 2;
-
-
-    /**
-     * Create a new mmap'ed file out of an existing APR file.
-     * @param file The file turn into an mmap.
-     * @param offset The offset into the file to start the data pointer at.
-     * @param size The size of the file
-     * @param flag bit-wise or of:
-     * <PRE>
-     * APR_MMAP_READ       MMap opened for reading
-     * APR_MMAP_WRITE      MMap opened for writing
-     * </PRE>
-     * @param pool The pool to use when creating the mmap.
-     * @return The newly created mmap'ed file.
-     * @throws Error Error creating memory mapping
-     */
-    public static native long create(long file, long offset, long size, int flag, long pool)
-        throws Error;
-
-    /**
-     * Duplicate the specified MMAP.
-     * @param mmap The mmap to duplicate.
-     * @param pool The pool to use for new_mmap.
-     * @return Duplicated mmap'ed file.
-     * @throws Error Error duplicating memory mapping
-     */
-    public static native long dup(long mmap, long pool)
-        throws Error;
-
-    /**
-     * Remove a mmap'ed.
-     * @param mm The mmap'ed file.
-     * @return the operation status
-     */
-    public static native int delete(long mm);
-
-    /**
-     * Move the pointer into the mmap'ed file to the specified offset.
-     * @param mm The mmap'ed file.
-     * @param offset The offset to move to.
-     * @return The pointer to the offset specified.
-     * @throws Error Error reading file
-     */
-    public static native long offset(long mm, long offset)
-        throws Error;
-
-}

==================================================
Poll.java
deleted file mode 100644
index fd090fdc2e..0000000000
--- a/java/org/apache/tomcat/jni/Multicast.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.jni;
-
-/** Multicast
- *
- * @author Mladen Turk
- *
- * @deprecated  The scope of the APR/Native Library will be reduced in Tomcat
- *              10.1.x / Tomcat Native 2.x onwards to only include those
- *              components required to provide OpenSSL integration with the NIO
- *              and NIO2 connectors.
- */
-@Deprecated
-public class Multicast {
-
-    /**
-     * Join a Multicast Group
-     * @param sock The socket to join a multicast group
-     * @param join The address of the multicast group to join
-     * @param iface Address of the interface to use.  If NULL is passed, the
-     *              default multicast interface will be used. (OS Dependent)
-     * @param source Source Address to accept transmissions from (non-NULL
-     *               implies Source-Specific Multicast)
-     * @return the operation status
-     */
-    public static native int join(long sock, long join,
-                                  long iface, long source);
-
-    /**
-     * Leave a Multicast Group.  All arguments must be the same as
-     * apr_mcast_join.
-     * @param sock The socket to leave a multicast group
-     * @param addr The address of the multicast group to leave
-     * @param iface Address of the interface to use.  If NULL is passed, the
-     *              default multicast interface will be used. (OS Dependent)
-     * @param source Source Address to accept transmissions from (non-NULL
-     *               implies Source-Specific Multicast)
-     * @return the operation status
-     */
-    public static native int leave(long sock, long addr,
-                                   long iface, long source);
-
-    /**
-     * Set the Multicast Time to Live (ttl) for a multicast transmission.
-     * @param sock The socket to set the multicast ttl
-     * @param ttl Time to live to Assign. 0-255, default=1
-     * <br><b>Remark :</b> If the TTL is 0, packets will only be seen
-     * by sockets on the local machine,
-     * and only when multicast loopback is enabled.
-     * @return the operation status
-     */
-    public static native int hops(long sock, int ttl);
-
-    /**
-     * Toggle IP Multicast Loopback
-     * @param sock The socket to set multicast loopback
-     * @param opt false=disable, true=enable
-     * @return the operation status
-     */
-    public static native int loopback(long sock, boolean opt);
-
-
-    /**
-     * Set the Interface to be used for outgoing Multicast Transmissions.
-     * @param sock The socket to set the multicast interface on
-     * @param iface Address of the interface to use for Multicast
-     * @return the operation status
-     */
-    public static native int ointerface(long sock, long iface);
-
-}

==================================================
PoolCallback.java
deleted file mode 100644
index 54f422168a..0000000000
--- a/java/org/apache/tomcat/jni/Poll.java
+++ /dev/null
@@ -1,194 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.jni;
-
-/** Poll
- *
- * @author Mladen Turk
- *
- * @deprecated  The scope of the APR/Native Library will be reduced in Tomcat
- *              10.1.x / Tomcat Native 2.x onwards to only include those
- *              components required to provide OpenSSL integration with the NIO
- *              and NIO2 connectors.
- */
-@Deprecated
-public class Poll {
-
-    /**
-     * Poll return values
-     */
-    /** Can read without blocking */
-    public static final int APR_POLLIN   = 0x001;
-    /** Priority data available */
-    public static final int APR_POLLPRI  = 0x002;
-    /** Can write without blocking */
-    public static final int APR_POLLOUT  = 0x004;
-    /** Pending error */
-    public static final int APR_POLLERR  = 0x010;
-    /** Hangup occurred */
-    public static final int APR_POLLHUP  = 0x020;
-    /** Descriptor invalid */
-    public static final int APR_POLLNVAL = 0x040;
-
-    /**
-     * Pollset Flags
-     */
-    /** Adding or Removing a Descriptor is thread safe */
-    public static final int APR_POLLSET_THREADSAFE = 0x001;
-
-
-    /** Used in apr_pollfd_t to determine what the apr_descriptor is
-     * apr_datatype_e enum
-     */
-    public static final int APR_NO_DESC       = 0; /** nothing here */
-    public static final int APR_POLL_SOCKET   = 1; /** descriptor refers to a socket */
-    public static final int APR_POLL_FILE     = 2; /** descriptor refers to a file */
-    public static final int APR_POLL_LASTDESC = 3; /** descriptor is the last one in the list */
-
-    /**
-     * Setup a pollset object.
-     * If flags equals APR_POLLSET_THREADSAFE, then a pollset is
-     * created on which it is safe to make concurrent calls to
-     * apr_pollset_add(), apr_pollset_remove() and apr_pollset_poll() from
-     * separate threads.  This feature is only supported on some
-     * platforms; the apr_pollset_create() call will fail with
-     * APR_ENOTIMPL on platforms where it is not supported.
-     * @param size The maximum number of descriptors that this pollset can hold
-     * @param p The pool from which to allocate the pollset
-     * @param flags Optional flags to modify the operation of the pollset.
-     * @param ttl Maximum time to live for a particular socket.
-     * @return  The pointer in which to return the newly created object
-     * @throws Error Pollset creation failed
-     */
-    public static native long create(int size, long p, int flags, long ttl)
-        throws Error;
-    /**
-     * Destroy a pollset object
-     * @param pollset The pollset to destroy
-     * @return the operation status
-     */
-    public static native int destroy(long pollset);
-
-    /**
-     * Add a socket to a pollset with the default timeout.
-     * @param pollset The pollset to which to add the socket
-     * @param sock The sockets to add
-     * @param reqevents requested events
-     * @return the operation status
-     */
-    public static native int add(long pollset, long sock,
-                                 int reqevents);
-
-    /**
-     * Add a socket to a pollset with a specific timeout.
-     * @param pollset The pollset to which to add the socket
-     * @param sock The sockets to add
-     * @param reqevents requested events
-     * @param timeout requested timeout in microseconds (-1 for infinite)
-     * @return the operation status
-     */
-    public static native int addWithTimeout(long pollset, long sock,
-                                            int reqevents, long timeout);
-
-    /**
-     * Remove a descriptor from a pollset
-     * @param pollset The pollset from which to remove the descriptor
-     * @param sock The socket to remove
-     * @return the operation status
-     */
-    public static native int remove(long pollset, long sock);
-
-    /**
-     * Block for activity on the descriptor(s) in a pollset
-     * @param pollset The pollset to use
-     * @param timeout Timeout in microseconds
-     * @param descriptors Array of signaled descriptors (output parameter)
-     *        The descriptor array must be two times the size of pollset.
-     *        and are populated as follows:
-     * <PRE>
-     * descriptors[2n + 0] -&gt; returned events
-     * descriptors[2n + 1] -&gt; socket
-     * </PRE>
-     * @param remove Remove signaled descriptors from pollset
-     * @return Number of signaled descriptors (output parameter)
-     *         or negative APR error code.
-     */
-    public static native int poll(long pollset, long timeout,
-                                  long [] descriptors, boolean remove);
-
-    /**
-     * Maintain on the descriptor(s) in a pollset
-     * @param pollset The pollset to use
-     * @param descriptors Array of signaled descriptors (output parameter)
-     *        The descriptor array must be the size of pollset.
-     *        and are populated as follows:
-     * <PRE>
-     * descriptors[n] -&gt; socket
-     * </PRE>
-     * @param remove Remove signaled descriptors from pollset
-     * @return Number of signaled descriptors (output parameter)
-     *         or negative APR error code.
-     */
-    public static native int maintain(long pollset, long [] descriptors,
-                                      boolean remove);
-
-    /**
-     * Set the socket time to live.
-     * @param pollset The pollset to use
-     * @param ttl Timeout in microseconds
-     */
-    public static native void setTtl(long pollset, long ttl);
-
-    /**
-     * Get the socket time to live.
-     * @param pollset The pollset to use
-     * @return Timeout in microseconds
-     */
-    public static native long getTtl(long pollset);
-
-    /**
-     * Return all descriptor(s) in a pollset
-     * @param pollset The pollset to use
-     * @param descriptors Array of descriptors (output parameter)
-     *        The descriptor array must be two times the size of pollset.
-     *        and are populated as follows:
-     * <PRE>
-     * descriptors[2n + 0] -&gt; returned events
-     * descriptors[2n + 1] -&gt; socket
-     * </PRE>
-     * @return Number of descriptors (output parameter) in the Poll
-     *         or negative APR error code.
-     */
-    public static native int pollset(long pollset, long [] descriptors);
-
-    /**
-     * Make poll() return.
-     *
-     * @param   pollset The pollset to use
-     * @return  Negative APR error code
-     */
-    public static native int interrupt(long pollset);
-
-    /**
-     * Check if interrupt() is allowed.
-     *
-     * @param pollset The pollset to use
-     * @return  <code>true</code> if {@link #interrupt(long)} is allowed, else
-     *          <code>false</code>
-     */
-    public static native boolean wakeable(long pollset);
-}

==================================================
Proc.java
deleted file mode 100644
index c709979fce..0000000000
--- a/java/org/apache/tomcat/jni/PoolCallback.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.jni;
-
-/** PoolCallback Interface
- *
- * @author Mladen Turk
- *
- * @deprecated  The scope of the APR/Native Library will be reduced in Tomcat
- *              10.1.x / Tomcat Native 2.x onwards to only include those
- *              components required to provide OpenSSL integration with the NIO
- *              and NIO2 connectors.
- */
-@Deprecated
-public interface PoolCallback {
-
-    /**
-     * Called when the pool is destroyed or cleared
-     * @return Function must return APR_SUCCESS
-     */
-    public int callback();
-}

==================================================
ProcErrorCallback.java
deleted file mode 100644
index 4ea678b6ac..0000000000
--- a/java/org/apache/tomcat/jni/Proc.java
+++ /dev/null
@@ -1,218 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.jni;
-
-/** Proc
- *
- * @author Mladen Turk
- *
- * @deprecated  The scope of the APR/Native Library will be reduced in Tomcat
- *              10.1.x / Tomcat Native 2.x onwards to only include those
- *              components required to provide OpenSSL integration with the NIO
- *              and NIO2 connectors.
- */
-@Deprecated
-public class Proc {
-
-    /*
-     * apr_cmdtype_e enum
-     */
-    public static final int APR_SHELLCM      = 0; /** use the shell to invoke the program */
-    public static final int APR_PROGRAM      = 1; /** invoke the program directly, no copied env */
-    public static final int APR_PROGRAM_ENV  = 2; /** invoke the program, replicating our environment */
-    public static final int APR_PROGRAM_PATH = 3; /** find program on PATH, use our environment */
-    public static final int APR_SHELLCMD_ENV = 4; /** use the shell to invoke the program,
-                                                   *   replicating our environment
-                                                   */
-
-    /*
-     * apr_wait_how_e enum
-     */
-    public static final int APR_WAIT   = 0; /** wait for the specified process to finish */
-    public static final int APR_NOWAIT = 1; /** do not wait -- just see if it has finished */
-
-    /*
-     * apr_exit_why_e enum
-     */
-    public static final int APR_PROC_EXIT        = 1; /** process exited normally */
-    public static final int APR_PROC_SIGNAL      = 2; /** process exited due to a signal */
-    public static final int APR_PROC_SIGNAL_CORE = 4; /** process exited and dumped a core file */
-
-    public static final int APR_NO_PIPE       = 0;
-    public static final int APR_FULL_BLOCK    = 1;
-    public static final int APR_FULL_NONBLOCK = 2;
-    public static final int APR_PARENT_BLOCK  = 3;
-    public static final int APR_CHILD_BLOCK   = 4;
-
-    public static final int APR_LIMIT_CPU     = 0;
-    public static final int APR_LIMIT_MEM     = 1;
-    public static final int APR_LIMIT_NPROC   = 2;
-    public static final int APR_LIMIT_NOFILE  = 3;
-
-
-    /** child has died, caller must call unregister still */
-    public static final int APR_OC_REASON_DEATH      = 0;
-    /** write_fd is unwritable */
-    public static final int APR_OC_REASON_UNWRITABLE = 1;
-    /** a restart is occurring, perform any necessary cleanup (including
-     * sending a special signal to child)
-     */
-    public static final int APR_OC_REASON_RESTART    = 2;
-    /** unregister has been called, do whatever is necessary (including
-     * kill the child)
-     */
-    public static final int APR_OC_REASON_UNREGISTER = 3;
-    /** somehow the child exited without us knowing ... buggy os? */
-    public static final int APR_OC_REASON_LOST       = 4;
-    /** a health check is occurring, for most maintenance functions
-     * this is a no-op.
-     */
-    public static final int APR_OC_REASON_RUNNING    = 5;
-
-    /* apr_kill_conditions_e enumeration */
-    /** process is never sent any signals */
-    public static final int APR_KILL_NEVER         = 0;
-    /** process is sent SIGKILL on apr_pool_t cleanup */
-    public static final int APR_KILL_ALWAYS        = 1;
-    /** SIGTERM, wait 3 seconds, SIGKILL */
-    public static final int APR_KILL_AFTER_TIMEOUT = 2;
-    /** wait forever for the process to complete */
-    public static final int APR_JUST_WAIT          = 3;
-    /** send SIGTERM and then wait */
-    public static final int APR_KILL_ONLY_ONCE     = 4;
-
-    public static final int APR_PROC_DETACH_FOREGROUND = 0; /** Do not detach */
-    public static final int APR_PROC_DETACH_DAEMONIZE  = 1; /** Detach */
-
-    /* Maximum number of arguments for create process call */
-    public static final int MAX_ARGS_SIZE          = 1024;
-    /* Maximum number of environment variables for create process call */
-    public static final int MAX_ENV_SIZE           = 1024;
-
-    /**
-     * Allocate apr_proc_t structure from pool
-     * This is not an apr function.
-     * @param cont The pool to use.
-     * @return the pointer
-     */
-    public static native long alloc(long cont);
-
-    /**
-     * This is currently the only non-portable call in APR.  This executes
-     * a standard unix fork.
-     * @param proc The resulting process handle.
-     * @param cont The pool to use.
-     * @return APR_INCHILD for the child, and APR_INPARENT for the parent
-     * or an error.
-     */
-    public static native int fork(long [] proc, long cont);
-
-    /**
-     * Create a new process and execute a new program within that process.
-     * This function returns without waiting for the new process to terminate;
-     * use apr_proc_wait for that.
-     * @param proc The process handle
-     * @param progname The program to run
-     * @param args The arguments to pass to the new program.  The first
-     *             one should be the program name.
-     * @param env The new environment table for the new process.  This
-     *            should be a list of NULL-terminated strings. This argument
-     *            is ignored for APR_PROGRAM_ENV, APR_PROGRAM_PATH, and
-     *            APR_SHELLCMD_ENV types of commands.
-     * @param attr The procattr we should use to determine how to create the new
-     * process
-     * @param pool The pool to use.
-     * @return The resulting process handle.
-     */
-    public static native int create(long proc, String progname,
-                                    String [] args, String [] env,
-                                    long attr, long pool);
-
-    /**
-     * Wait for a child process to die
-     * @param proc The process handle that corresponds to the desired child process
-     * @param exit exit[0] The returned exit status of the child, if a child process
-     *                dies, or the signal that caused the child to die.
-     *                On platforms that don't support obtaining this information,
-     *                the status parameter will be returned as APR_ENOTIMPL.
-     * exit[1] Why the child died, the bitwise or of:
-     * <PRE>
-     * APR_PROC_EXIT         -- process terminated normally
-     * APR_PROC_SIGNAL       -- process was killed by a signal
-     * APR_PROC_SIGNAL_CORE  -- process was killed by a signal, and
-     *                          generated a core dump.
-     * </PRE>
-     * @param waithow How should we wait.  One of:
-     * <PRE>
-     * APR_WAIT   -- block until the child process dies.
-     * APR_NOWAIT -- return immediately regardless of if the
-     *               child is dead or not.
-     * </PRE>
-     * @return The childs status is in the return code to this process.  It is one of:
-     * <PRE>
-     * APR_CHILD_DONE     -- child is no longer running.
-     * APR_CHILD_NOTDONE  -- child is still running.
-     * </PRE>
-     */
-    public static native int wait(long proc, int [] exit, int waithow);
-
-    /**
-     * Wait for any current child process to die and return information
-     * about that child.
-     * @param proc Pointer to NULL on entry, will be filled out with child's
-     *             information
-     * @param exit exit[0] The returned exit status of the child, if a child process
-     *                dies, or the signal that caused the child to die.
-     *                On platforms that don't support obtaining this information,
-     *                the status parameter will be returned as APR_ENOTIMPL.
-     * exit[1] Why the child died, the bitwise or of:
-     * <PRE>
-     * APR_PROC_EXIT         -- process terminated normally
-     * APR_PROC_SIGNAL       -- process was killed by a signal
-     * APR_PROC_SIGNAL_CORE  -- process was killed by a signal, and
-     *                          generated a core dump.
-     * </PRE>
-     * @param waithow How should we wait.  One of:
-     * <PRE>
-     * APR_WAIT   -- block until the child process dies.
-     * APR_NOWAIT -- return immediately regardless of if the
-     *               child is dead or not.
-     * </PRE>
-     * @param pool Pool to allocate child information out of.
-     * @return the operation status
-     */
-    public static native int waitAllProcs(long proc, int [] exit,
-                                          int waithow, long pool);
-
-     /**
-     * Detach the process from the controlling terminal.
-     * @param daemonize set to non-zero if the process should daemonize
-     *                  and become a background process, else it will
-     *                  stay in the foreground.
-     * @return the operation status
-     */
-    public static native int detach(int daemonize);
-
-    /**
-     * Terminate a process.
-     * @param proc The process to terminate.
-     * @param sig How to kill the process.
-     * @return the operation status
-     */
-    public static native int kill(long proc, int sig);
-
-}

==================================================
Procattr.java
deleted file mode 100644
index a9421bc034..0000000000
--- a/java/org/apache/tomcat/jni/ProcErrorCallback.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.jni;
-
-/** ProcErrorCallback Interface
- *
- * @author Mladen Turk
- *
- * @deprecated  The scope of the APR/Native Library will be reduced in Tomcat
- *              10.1.x / Tomcat Native 2.x onwards to only include those
- *              components required to provide OpenSSL integration with the NIO
- *              and NIO2 connectors.
- */
-@Deprecated
-public interface ProcErrorCallback {
-
-    /**
-     * Called in the child process if APR encounters an error
-     * in the child prior to running the specified program.
-     * @param pool Pool associated with the apr_proc_t.  If your child
-     *             error function needs user data, associate it with this
-     *             pool.
-     * @param err APR error code describing the error
-     * @param description Text description of type of processing which failed
-     */
-    public void callback(long pool, int err, String description);
-}

==================================================
Registry.java
deleted file mode 100644
index 40800d1184..0000000000
--- a/java/org/apache/tomcat/jni/Procattr.java
+++ /dev/null
@@ -1,187 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.jni;
-
-/** Procattr
- *
- * @author Mladen Turk
- *
- * @deprecated  The scope of the APR/Native Library will be reduced in Tomcat
- *              10.1.x / Tomcat Native 2.x onwards to only include those
- *              components required to provide OpenSSL integration with the NIO
- *              and NIO2 connectors.
- */
-@Deprecated
-public class Procattr {
-
-    /**
-     * Create and initialize a new procattr variable
-     * @param cont The pool to use
-     * @return The newly created procattr.
-     * @throws Error An error occurred
-     */
-    public static native long create(long cont)
-        throws Error;
-
-    /**
-     * Determine if any of stdin, stdout, or stderr should be linked to pipes
-     * when starting a child process.
-     * @param attr The procattr we care about.
-     * @param in Should stdin be a pipe back to the parent?
-     * @param out Should stdout be a pipe back to the parent?
-     * @param err Should stderr be a pipe back to the parent?
-     * @return the operation status
-     */
-    public static native int ioSet(long attr, int in, int out, int err);
-
-    /**
-     * Set the child_in and/or parent_in values to existing apr_file_t values.
-     * <br>
-     * This is NOT a required initializer function. This is
-     * useful if you have already opened a pipe (or multiple files)
-     * that you wish to use, perhaps persistently across multiple
-     * process invocations - such as a log file. You can save some
-     * extra function calls by not creating your own pipe since this
-     * creates one in the process space for you.
-     * @param attr The procattr we care about.
-     * @param in apr_file_t value to use as child_in. Must be a valid file.
-     * @param parent apr_file_t value to use as parent_in. Must be a valid file.
-     * @return the operation status
-     */
-    public static native int childInSet(long attr, long in, long parent);
-
-    /**
-     * Set the child_out and parent_out values to existing apr_file_t values.
-     * <br>
-     * This is NOT a required initializer function. This is
-     * useful if you have already opened a pipe (or multiple files)
-     * that you wish to use, perhaps persistently across multiple
-     * process invocations - such as a log file.
-     * @param attr The procattr we care about.
-     * @param out apr_file_t value to use as child_out. Must be a valid file.
-     * @param parent apr_file_t value to use as parent_out. Must be a valid file.
-     * @return the operation status
-     */
-    public static native int childOutSet(long attr, long out, long parent);
-
-    /**
-     * Set the child_err and parent_err values to existing apr_file_t values.
-     * <br>
-     * This is NOT a required initializer function. This is
-     * useful if you have already opened a pipe (or multiple files)
-     * that you wish to use, perhaps persistently across multiple
-     * process invocations - such as a log file.
-     * @param attr The procattr we care about.
-     * @param err apr_file_t value to use as child_err. Must be a valid file.
-     * @param parent apr_file_t value to use as parent_err. Must be a valid file.
-     * @return the operation status
-     */
-    public static native int childErrSet(long attr, long err, long parent);
-
-    /**
-     * Set which directory the child process should start executing in.
-     * @param attr The procattr we care about.
-     * @param dir Which dir to start in.  By default, this is the same dir as
-     *            the parent currently resides in, when the createprocess call
-     *            is made.
-     * @return the operation status
-     */
-    public static native int dirSet(long attr, String dir);
-
-    /**
-     * Set what type of command the child process will call.
-     * @param attr The procattr we care about.
-     * @param cmd The type of command.  One of:
-     * <PRE>
-     * APR_SHELLCMD     --  Anything that the shell can handle
-     * APR_PROGRAM      --  Executable program   (default)
-     * APR_PROGRAM_ENV  --  Executable program, copy environment
-     * APR_PROGRAM_PATH --  Executable program on PATH, copy env
-     * </PRE>
-     * @return the operation status
-     */
-    public static native int cmdtypeSet(long attr, int cmd);
-
-    /**
-     * Determine if the child should start in detached state.
-     * @param attr The procattr we care about.
-     * @param detach Should the child start in detached state?  Default is no.
-     * @return the operation status
-     */
-    public static native int detachSet(long attr, int detach);
-
-    /**
-     * Specify that apr_proc_create() should do whatever it can to report
-     * failures to the caller of apr_proc_create(), rather than find out in
-     * the child.
-     * @param attr The procattr describing the child process to be created.
-     * @param chk Flag to indicate whether or not extra work should be done
-     *            to try to report failures to the caller.
-     * <br>
-     * This flag only affects apr_proc_create() on platforms where
-     * fork() is used.  This leads to extra overhead in the calling
-     * process, but that may help the application handle such
-     * errors more gracefully.
-     * @return the operation status
-     */
-    public static native int errorCheckSet(long attr, int chk);
-
-    /**
-     * Determine if the child should start in its own address space or using the
-     * current one from its parent
-     * @param attr The procattr we care about.
-     * @param addrspace Should the child start in its own address space?
-     *                  Default is yes.
-     * @return the operation status
-     */
-    public static native int addrspaceSet(long attr, int addrspace);
-
-    /**
-     * Specify an error function to be called in the child process if APR
-     * encounters an error in the child prior to running the specified program.
-     * @param attr The procattr describing the child process to be created.
-     * @param pool The the pool to use.
-     * @param o The Object to call in the child process.
-     * <br>
-     * At the present time, it will only be called from apr_proc_create()
-     * on platforms where fork() is used.  It will never be called on other
-     * platforms, on those platforms apr_proc_create() will return the error
-     * in the parent process rather than invoke the callback in the now-forked
-     * child process.
-     */
-    public static native void errfnSet(long attr, long pool, Object o);
-
-    /**
-     * Set the username used for running process
-     * @param attr The procattr we care about.
-     * @param username The username used
-     * @param password User password if needed. Password is needed on WIN32
-     *                 or any other platform having
-     *                 APR_PROCATTR_USER_SET_REQUIRES_PASSWORD set.
-     * @return the operation status
-     */
-    public static native int userSet(long attr, String username, String password);
-
-    /**
-     * Set the group used for running process
-     * @param attr The procattr we care about.
-     * @param groupname The group name  used
-     * @return the operation status
-     */
-    public static native int groupSet(long attr, String groupname);
-
-}

==================================================
SSLSocket.java
deleted file mode 100644
index 7a535f9747..0000000000
--- a/java/org/apache/tomcat/jni/Registry.java
+++ /dev/null
@@ -1,248 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.jni;
-
-/** Windows Registry support
- *
- * @author Mladen Turk
- *
- * @deprecated  The scope of the APR/Native Library will be reduced in Tomcat
- *              10.1.x / Tomcat Native 2.x onwards to only include those
- *              components required to provide OpenSSL integration with the NIO
- *              and NIO2 connectors.
- */
-@Deprecated
-public class Registry {
-
-    /* Registry Enums */
-    public static final int HKEY_CLASSES_ROOT       = 1;
-    public static final int HKEY_CURRENT_CONFIG     = 2;
-    public static final int HKEY_CURRENT_USER       = 3;
-    public static final int HKEY_LOCAL_MACHINE      = 4;
-    public static final int HKEY_USERS              = 5;
-
-    public static final int KEY_ALL_ACCESS          = 0x0001;
-    public static final int KEY_CREATE_LINK         = 0x0002;
-    public static final int KEY_CREATE_SUB_KEY      = 0x0004;
-    public static final int KEY_ENUMERATE_SUB_KEYS  = 0x0008;
-    public static final int KEY_EXECUTE             = 0x0010;
-    public static final int KEY_NOTIFY              = 0x0020;
-    public static final int KEY_QUERY_VALUE         = 0x0040;
-    public static final int KEY_READ                = 0x0080;
-    public static final int KEY_SET_VALUE           = 0x0100;
-    public static final int KEY_WOW64_64KEY         = 0x0200;
-    public static final int KEY_WOW64_32KEY         = 0x0400;
-    public static final int KEY_WRITE               = 0x0800;
-
-    public static final int REG_BINARY              = 1;
-    public static final int REG_DWORD               = 2;
-    public static final int REG_EXPAND_SZ           = 3;
-    public static final int REG_MULTI_SZ            = 4;
-    public static final int REG_QWORD               = 5;
-    public static final int REG_SZ                  = 6;
-
-     /**
-     * Create or open a Registry Key.
-     * @param name Registry Subkey to open
-     * @param root Root key, one of HKEY_*
-     * @param sam Access mask that specifies the access rights for the key.
-     * @param pool Pool used for native memory allocation
-     * @return Opened Registry key
-     * @throws Error An error occurred
-     */
-    public static native long create(int root, String name, int sam, long pool)
-        throws Error;
-
-     /**
-     * Opens the specified Registry Key.
-     * @param name Registry Subkey to open
-     * @param root Root key, one of HKEY_*
-     * @param sam Access mask that specifies the access rights for the key.
-     * @param pool Pool used for native memory allocation
-     * @return Opened Registry key
-     * @throws Error An error occurred
-     */
-    public static native long open(int root, String name, int sam, long pool)
-        throws Error;
-
-    /**
-     * Close the specified Registry key.
-     * @param key The Registry key descriptor to close.
-     * @return the operation status
-     */
-    public static native int close(long key);
-
-    /**
-     * Get the Registry key type.
-     * @param key The Registry key descriptor to use.
-     * @param name The name of the value to query
-     * @return Value type or negative error value
-     */
-    public static native int getType(long key, String name);
-
-    /**
-     * Get the Registry value for REG_DWORD
-     * @param key The Registry key descriptor to use.
-     * @param name The name of the value to query
-     * @return Registry key value
-     * @throws Error An error occurred
-     */
-    public static native int getValueI(long key, String name)
-        throws Error;
-
-    /**
-     * Get the Registry value for REG_QWORD or REG_DWORD
-     * @param key The Registry key descriptor to use.
-     * @param name The name of the value to query
-     * @return Registry key value
-     * @throws Error An error occurred
-     */
-    public static native long getValueJ(long key, String name)
-        throws Error;
-
-    /**
-     * Get the Registry key length.
-     * @param key The Registry key descriptor to use.
-     * @param name The name of the value to query
-     * @return Value size or negative error value
-     */
-    public static native int getSize(long key, String name);
-
-    /**
-     * Get the Registry value for REG_SZ or REG_EXPAND_SZ
-     * @param key The Registry key descriptor to use.
-     * @param name The name of the value to query
-     * @return Registry key value
-     * @throws Error An error occurred
-     */
-    public static native String getValueS(long key, String name)
-        throws Error;
-
-    /**
-     * Get the Registry value for REG_MULTI_SZ
-     * @param key The Registry key descriptor to use.
-     * @param name The name of the value to query
-     * @return Registry key value
-     * @throws Error An error occurred
-     */
-    public static native String[] getValueA(long key, String name)
-        throws Error;
-
-    /**
-     * Get the Registry value for REG_BINARY
-     * @param key The Registry key descriptor to use.
-     * @param name The name of the value to query
-     * @return Registry key value
-     * @throws Error An error occurred
-     */
-    public static native byte[] getValueB(long key, String name)
-        throws Error;
-
-
-    /**
-     * Set the Registry value for REG_DWORD
-     * @param key The Registry key descriptor to use.
-     * @param name The name of the value to set
-     * @param val The the value to set
-     * @return If the function succeeds, the return value is 0
-     */
-    public static native int setValueI(long key, String name, int val);
-
-    /**
-     * Set the Registry value for REG_QWORD
-     * @param key The Registry key descriptor to use.
-     * @param name The name of the value to set
-     * @param val The the value to set
-     * @return If the function succeeds, the return value is 0
-     */
-    public static native int setValueJ(long key, String name, long val);
-
-    /**
-     * Set the Registry value for REG_SZ
-     * @param key The Registry key descriptor to use.
-     * @param name The name of the value to set
-     * @param val The the value to set
-     * @return If the function succeeds, the return value is 0
-     */
-    public static native int setValueS(long key, String name, String val);
-
-    /**
-     * Set the Registry value for REG_EXPAND_SZ
-     * @param key The Registry key descriptor to use.
-     * @param name The name of the value to set
-     * @param val The the value to set
-     * @return If the function succeeds, the return value is 0
-     */
-    public static native int setValueE(long key, String name, String val);
-
-     /**
-     * Set the Registry value for REG_MULTI_SZ
-     * @param key The Registry key descriptor to use.
-     * @param name The name of the value to set
-     * @param val The the value to set
-     * @return If the function succeeds, the return value is 0
-     */
-    public static native int setValueA(long key, String name, String[] val);
-
-     /**
-     * Set the Registry value for REG_BINARY
-     * @param key The Registry key descriptor to use.
-     * @param name The name of the value to set
-     * @param val The the value to set
-     * @return If the function succeeds, the return value is 0
-     */
-    public static native int setValueB(long key, String name, byte[] val);
-
-    /**
-     * Enumerate the Registry subkeys
-     * @param key The Registry key descriptor to use.
-     * @return Array of all subkey names
-     * @throws Error An error occurred
-     */
-    public static native String[] enumKeys(long key)
-        throws Error;
-
-    /**
-     * Enumerate the Registry values
-     * @param key The Registry key descriptor to use.
-     * @return Array of all value names
-     * @throws Error An error occurred
-     */
-    public static native String[] enumValues(long key)
-        throws Error;
-
-     /**
-     * Delete the Registry value
-     * @param key The Registry key descriptor to use.
-     * @param name The name of the value to delete
-     * @return If the function succeeds, the return value is 0
-     */
-    public static native int deleteValue(long key, String name);
-
-     /**
-     * Delete the Registry subkey
-     * @param root Root key, one of HKEY_*
-     * @param name Subkey to delete
-     * @param onlyIfEmpty If true will not delete a key if
-     *                    it contains any subkeys or values
-     * @return If the function succeeds, the return value is 0
-     */
-    public static native int deleteKey(int root, String name,
-                                       boolean onlyIfEmpty);
-
-
-}

==================================================
Shm.java
deleted file mode 100644
index 2e1b316ed0..0000000000
--- a/java/org/apache/tomcat/jni/SSLSocket.java
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.jni;
-
-/** SSL Socket
- *
- * @author Mladen Turk
- *
- * @deprecated  The scope of the APR/Native Library will be reduced in Tomcat
- *              10.1.x / Tomcat Native 2.x onwards to only include those
- *              components required to provide OpenSSL integration with the NIO
- *              and NIO2 connectors.
- */
-@Deprecated
-public class SSLSocket {
-
-    /**
-     * Attach APR socket on an SSL connection.
-     * @param ctx SSLContext to use.
-     * @param sock APR Socket that already did physical connect or accept.
-     * @return APR_STATUS code.
-     * @throws Exception An error occurred
-     */
-    public static native int attach(long ctx, long sock)
-        throws Exception;
-
-    /**
-     * Do an SSL handshake.
-     * @param thesocket The socket to use
-     * @return the handshake status
-     */
-    public static native int handshake(long thesocket);
-
-    /**
-     * Do an SSL renegotiation.
-     * SSL supports per-directory re-configuration of SSL parameters.
-     * This is implemented by performing an SSL renegotiation of the
-     * re-configured parameters after the request is read, but before the
-     * response is sent. In more detail: the renegotiation happens after the
-     * request line and MIME headers were read, but _before_ the attached
-     * request body is read. The reason simply is that in the HTTP protocol
-     * usually there is no acknowledgment step between the headers and the
-     * body (there is the 100-continue feature and the chunking facility
-     * only), so Apache has no API hook for this step.
-     *
-     * @param thesocket The socket to use
-     * @return the operation status
-     */
-    public static native int renegotiate(long thesocket);
-
-    /**
-     * Set Type of Client Certificate verification and Maximum depth of CA
-     * Certificates in Client Certificate verification.
-     * <br>
-     * This is used to change the verification level for a connection prior to
-     * starting a re-negotiation.
-     * <br>
-     * The following levels are available for level:
-     * <PRE>
-     * SSL_CVERIFY_NONE           - No client Certificate is required at all
-     * SSL_CVERIFY_OPTIONAL       - The client may present a valid Certificate
-     * SSL_CVERIFY_REQUIRE        - The client has to present a valid
-     *                              Certificate
-     * SSL_CVERIFY_OPTIONAL_NO_CA - The client may present a valid Certificate
-     *                              but it need not to be (successfully)
-     *                              verifiable
-     * </PRE>
-     * <br>
-     * @param sock  The socket to change.
-     * @param level Type of Client Certificate verification.
-     * @param depth Maximum number of certificates to permit in chain from
-     *              client to trusted CA. Use a value of 0 or less to leave the
-     *              current value unchanged
-     */
-    public static native void setVerify(long sock, int level, int depth);
-
-    /**
-     * Return SSL Info parameter as byte array.
-     *
-     * @param sock The socket to read the data from.
-     * @param id Parameter id.
-     * @return Byte array containing info id value.
-     * @throws Exception An error occurred
-     */
-    public static native byte[] getInfoB(long sock, int id)
-        throws Exception;
-
-    /**
-     * Return SSL Info parameter as String.
-     *
-     * @param sock The socket to read the data from.
-     * @param id Parameter id.
-     * @return String containing info id value.
-     * @throws Exception An error occurred
-     */
-    public static native String getInfoS(long sock, int id)
-        throws Exception;
-
-    /**
-     * Return SSL Info parameter as integer.
-     *
-     * @param sock The socket to read the data from.
-     * @param id Parameter id.
-     * @return Integer containing info id value or -1 on error.
-     * @throws Exception An error occurred
-     */
-    public static native int getInfoI(long sock, int id)
-        throws Exception;
-
-
-    /**
-     * Obtain the name of the protocol negotiated via ALPN. Only valid after the
-     * TLS handshake has completed.
-     *
-     * @param sock                  Socket
-     * @param negotiatedProtocol    Byte array in which to store agreed protocol
-     *
-     * @return Length of agreed protocol. Zero means no protocol agreed.
-     */
-    public static native int getALPN(long sock, byte[] negotiatedProtocol);
-
-}

==================================================
Socket.java
deleted file mode 100644
index f62d4aa39c..0000000000
--- a/java/org/apache/tomcat/jni/Shm.java
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.jni;
-
-import java.nio.ByteBuffer;
-
-/** Shm
- *
- * @author Mladen Turk
- *
- * @deprecated  The scope of the APR/Native Library will be reduced in Tomcat
- *              10.1.x / Tomcat Native 2.x onwards to only include those
- *              components required to provide OpenSSL integration with the NIO
- *              and NIO2 connectors.
- */
-@Deprecated
-public class Shm {
-
-    /**
-     * Create and make accessible a shared memory segment.
-     * <br>
-     * A note about Anonymous vs. Named shared memory segments:<br>
-     *         Not all platforms support anonymous shared memory segments, but in
-     *         some cases it is preferred over other types of shared memory
-     *         implementations. Passing a NULL 'file' parameter to this function
-     *         will cause the subsystem to use anonymous shared memory segments.
-     *         If such a system is not available, APR_ENOTIMPL is returned.
-     * <br>
-     * A note about allocation sizes:<br>
-     *         On some platforms it is necessary to store some metainformation
-     *         about the segment within the actual segment. In order to supply
-     *         the caller with the requested size it may be necessary for the
-     *         implementation to request a slightly greater segment length
-     *         from the subsystem. In all cases, the apr_shm_baseaddr_get()
-     *         function will return the first usable byte of memory.
-     * @param reqsize The desired size of the segment.
-     * @param filename The file to use for shared memory on platforms that
-     *        require it.
-     * @param pool the pool from which to allocate the shared memory
-     *        structure.
-     * @return The created shared memory structure.
-     * @throws Error An error occurred
-     */
-    public static native long create(long reqsize, String filename, long pool)
-        throws Error;
-
-    /**
-     * Remove shared memory segment associated with a filename.
-     * <br>
-     * This function is only supported on platforms which support
-     * name-based shared memory segments, and will return APR_ENOTIMPL on
-     * platforms without such support.
-     * @param filename The filename associated with shared-memory segment which
-     *        needs to be removed
-     * @param pool The pool used for file operations
-     * @return the operation status
-     */
-    public static native int remove(String filename, long pool);
-
-    /**
-     * Destroy a shared memory segment and associated memory.
-     * @param m The shared memory segment structure to destroy.
-     * @return the operation status
-     */
-    public static native int destroy(long m);
-
-    /**
-     * Attach to a shared memory segment that was created
-     * by another process.
-     * @param filename The file used to create the original segment.
-     *        (This MUST match the original filename.)
-     * @param pool the pool from which to allocate the shared memory
-     *        structure for this process.
-     * @return The created shared memory structure.
-     * @throws Error An error occurred
-     */
-    public static native long attach(String filename, long pool)
-        throws Error;
-
-    /**
-     * Detach from a shared memory segment without destroying it.
-     * @param m The shared memory structure representing the segment
-     *        to detach from.
-     * @return the operation status
-     */
-    public static native int detach(long m);
-
-    /**
-     * Retrieve the base address of the shared memory segment.
-     * NOTE: This address is only usable within the callers address
-     * space, since this API does not guarantee that other attaching
-     * processes will maintain the same address mapping.
-     * @param m The shared memory segment from which to retrieve
-     *        the base address.
-     * @return address, aligned by APR_ALIGN_DEFAULT.
-     */
-    public static native long baseaddr(long m);
-
-    /**
-     * Retrieve the length of a shared memory segment in bytes.
-     * @param m The shared memory segment from which to retrieve
-     *        the segment length.
-     * @return the length of the segment
-     */
-    public static native long size(long m);
-
-    /**
-     * Retrieve new ByteBuffer base address of the shared memory segment.
-     * NOTE: This address is only usable within the callers address
-     * space, since this API does not guarantee that other attaching
-     * processes will maintain the same address mapping.
-     * @param m The shared memory segment from which to retrieve
-     *        the base address.
-     * @return address, aligned by APR_ALIGN_DEFAULT.
-     */
-    public static native ByteBuffer buffer(long m);
-
-}

==================================================
Status.java
deleted file mode 100644
index cbc2a01c2d..0000000000
--- a/java/org/apache/tomcat/jni/Socket.java
+++ /dev/null
@@ -1,635 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.jni;
-
-/* Import needed classes */
-import java.nio.ByteBuffer;
-
-/** Socket
- *
- * @author Mladen Turk
- *
- * @deprecated  The scope of the APR/Native Library will be reduced in Tomcat
- *              10.1.x / Tomcat Native 2.x onwards to only include those
- *              components required to provide OpenSSL integration with the NIO
- *              and NIO2 connectors.
- */
-@Deprecated
-public class Socket {
-
-    /* Standard socket defines */
-    public static final int SOCK_STREAM = 0;
-    public static final int SOCK_DGRAM  = 1;
-    /*
-     * apr_sockopt Socket option definitions
-     */
-    public static final int APR_SO_LINGER       = 1;    /** Linger */
-    public static final int APR_SO_KEEPALIVE    = 2;    /** Keepalive */
-    public static final int APR_SO_DEBUG        = 4;    /** Debug */
-    public static final int APR_SO_NONBLOCK     = 8;    /** Non-blocking IO */
-    public static final int APR_SO_REUSEADDR    = 16;   /** Reuse addresses */
-    public static final int APR_SO_SNDBUF       = 64;   /** Send buffer */
-    public static final int APR_SO_RCVBUF       = 128;  /** Receive buffer */
-    public static final int APR_SO_DISCONNECTED = 256;  /** Disconnected */
-    /** For SCTP sockets, this is mapped to STCP_NODELAY internally. */
-    public static final int APR_TCP_NODELAY     = 512;
-    public static final int APR_TCP_NOPUSH      = 1024; /** No push */
-    /** This flag is ONLY set internally when we set APR_TCP_NOPUSH with
-     * APR_TCP_NODELAY set to tell us that APR_TCP_NODELAY should be turned on
-     * again when NOPUSH is turned off
-     */
-    public static final int APR_RESET_NODELAY   = 2048;
-    /** Set on non-blocking sockets (timeout != 0) on which the
-     * previous read() did not fill a buffer completely.  the next
-     * apr_socket_recv()  will first call select()/poll() rather than
-     * going straight into read().  (Can also be set by an application to
-     * force a select()/poll() call before the next read, in cases where
-     * the app expects that an immediate read would fail.)
-     */
-    public static final int APR_INCOMPLETE_READ = 4096;
-    /** like APR_INCOMPLETE_READ, but for write
-     */
-    public static final int APR_INCOMPLETE_WRITE = 8192;
-    /** Don't accept IPv4 connections on an IPv6 listening socket.
-     */
-    public static final int APR_IPV6_V6ONLY      = 16384;
-    /** Delay accepting of new connections until data is available.
-     */
-    public static final int APR_TCP_DEFER_ACCEPT = 32768;
-
-    /** Define what type of socket shutdown should occur.
-     * apr_shutdown_how_e enum
-     */
-    public static final int APR_SHUTDOWN_READ      = 0; /** no longer allow read request */
-    public static final int APR_SHUTDOWN_WRITE     = 1; /** no longer allow write requests */
-    public static final int APR_SHUTDOWN_READWRITE = 2; /** no longer allow read or write requests */
-
-    public static final int APR_IPV4_ADDR_OK = 0x01;
-    public static final int APR_IPV6_ADDR_OK = 0x02;
-
-    public static final int APR_UNSPEC = 0;
-    public static final int APR_INET   = 1;
-    public static final int APR_INET6  = 2;
-    public static final int APR_UNIX   = 3;
-
-    public static final int APR_PROTO_TCP  =   6; /** TCP  */
-    public static final int APR_PROTO_UDP  =  17; /** UDP  */
-    public static final int APR_PROTO_SCTP = 132; /** SCTP */
-
-    /**
-     * Enum to tell us if we're interested in remote or local socket
-     * apr_interface_e
-     */
-    public static final int APR_LOCAL  = 0;
-    public static final int APR_REMOTE = 1;
-
-    /* Socket.get types */
-    public static final int SOCKET_GET_POOL = 0;
-    public static final int SOCKET_GET_IMPL = 1;
-    public static final int SOCKET_GET_APRS = 2;
-    public static final int SOCKET_GET_TYPE = 3;
-
-    /**
-     * Create a socket.
-     * @param family The address family of the socket (e.g., APR_INET).
-     * @param type The type of the socket (e.g., SOCK_STREAM).
-     * @param protocol The protocol of the socket (e.g., APR_PROTO_TCP).
-     * @param cont The parent pool to use
-     * @return The new socket that has been set up.
-     * @throws Exception Error creating socket
-     */
-    public static native long create(int family, int type,
-                                     int protocol, long cont)
-        throws Exception;
-
-
-    /**
-     * Shutdown either reading, writing, or both sides of a socket.
-     * <br>
-     * This does not actually close the socket descriptor, it just
-     *      controls which calls are still valid on the socket.
-     * @param thesocket The socket to close
-     * @param how How to shutdown the socket.  One of:
-     * <PRE>
-     * APR_SHUTDOWN_READ         no longer allow read requests
-     * APR_SHUTDOWN_WRITE        no longer allow write requests
-     * APR_SHUTDOWN_READWRITE    no longer allow read or write requests
-     * </PRE>
-     * @return the operation status
-     */
-    public static native int shutdown(long thesocket, int how);
-
-    /**
-     * Close a socket.
-     * @param thesocket The socket to close
-     * @return the operation status
-     */
-    public static native int close(long thesocket);
-
-    /**
-     * Destroy a pool associated with socket
-     * @param thesocket The destroy
-     */
-    public static native void destroy(long thesocket);
-
-    /**
-     * Bind the socket to its associated port
-     * @param sock The socket to bind
-     * @param sa The socket address to bind to
-     * This may be where we will find out if there is any other process
-     *      using the selected port.
-     * @return the operation status
-     */
-    public static native int bind(long sock, long sa);
-
-    /**
-     * Listen to a bound socket for connections.
-     * @param sock The socket to listen on
-     * @param backlog The number of outstanding connections allowed in the sockets
-     *                listen queue.  If this value is less than zero, the listen
-     *                queue size is set to zero.
-     * @return the operation status
-     */
-    public static native int listen(long sock, int backlog);
-
-    /**
-     * Accept a new connection request
-     * @param sock The socket we are listening on.
-     * @param pool The pool for the new socket.
-     * @return  A copy of the socket that is connected to the socket that
-     *          made the connection request.  This is the socket which should
-     *          be used for all future communication.
-     * @throws Exception Socket accept error
-     */
-    public static native long acceptx(long sock, long pool)
-        throws Exception;
-
-    /**
-     * Accept a new connection request
-     * @param sock The socket we are listening on.
-     * @return  A copy of the socket that is connected to the socket that
-     *          made the connection request.  This is the socket which should
-     *          be used for all future communication.
-     * @throws Exception Socket accept error
-     */
-    public static native long accept(long sock)
-        throws Exception;
-
-    /**
-     * Set an OS level accept filter.
-     * @param sock The socket to put the accept filter on.
-     * @param name The accept filter
-     * @param args Any extra args to the accept filter.  Passing NULL here removes
-     *             the accept filter.
-     * @return the operation status
-     */
-    public static native int acceptfilter(long sock, String name, String args);
-
-    /**
-     * Query the specified socket if at the OOB/Urgent data mark
-     * @param sock The socket to query
-     * @return <code>true</code> if socket is at the OOB/urgent mark,
-     *         otherwise <code>false</code>.
-     */
-    public static native boolean atmark(long sock);
-
-    /**
-     * Issue a connection request to a socket either on the same machine
-     * or a different one.
-     * @param sock The socket we wish to use for our side of the connection
-     * @param sa The address of the machine we wish to connect to.
-     * @return the operation status
-     */
-    public static native int connect(long sock, long sa);
-
-    /**
-     * Send data over a network.
-     * <PRE>
-     * This functions acts like a blocking write by default.  To change
-     * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK
-     * socket option.
-     *
-     * It is possible for both bytes to be sent and an error to be returned.
-     *
-     * APR_EINTR is never returned.
-     * </PRE>
-     * @param sock The socket to send the data over.
-     * @param buf The buffer which contains the data to be sent.
-     * @param offset Offset in the byte buffer.
-     * @param len The number of bytes to write; (-1) for full array.
-     * @return The number of bytes sent
-     */
-    public static native int send(long sock, byte[] buf, int offset, int len);
-
-    /**
-     * Send data over a network.
-     * <PRE>
-     * This functions acts like a blocking write by default.  To change
-     * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK
-     * socket option.
-     *
-     * It is possible for both bytes to be sent and an error to be returned.
-     *
-     * APR_EINTR is never returned.
-     * </PRE>
-     * @param sock The socket to send the data over.
-     * @param buf The Byte buffer which contains the data to be sent.
-     * @param offset The offset within the buffer array of the first buffer from
-     *               which bytes are to be retrieved; must be non-negative
-     *               and no larger than buf.length
-     * @param len The maximum number of buffers to be accessed; must be non-negative
-     *            and no larger than buf.length - offset
-     * @return The number of bytes sent
-     */
-    public static native int sendb(long sock, ByteBuffer buf,
-                                   int offset, int len);
-
-    /**
-     * Send data over a network without retry
-     * <PRE>
-     * This functions acts like a blocking write by default.  To change
-     * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK
-     * socket option.
-     *
-     * It is possible for both bytes to be sent and an error to be returned.
-     *
-     * </PRE>
-     * @param sock The socket to send the data over.
-     * @param buf The Byte buffer which contains the data to be sent.
-     * @param offset The offset within the buffer array of the first buffer from
-     *               which bytes are to be retrieved; must be non-negative
-     *               and no larger than buf.length
-     * @param len The maximum number of buffers to be accessed; must be non-negative
-     *            and no larger than buf.length - offset
-     * @return The number of bytes sent
-     */
-    public static native int sendib(long sock, ByteBuffer buf,
-                                    int offset, int len);
-
-    /**
-     * Send data over a network using internally set ByteBuffer
-     * @param sock The socket to send the data over.
-     * @param offset The offset within the buffer array of the first buffer from
-     *               which bytes are to be retrieved; must be non-negative
-     *               and no larger than buf.length
-     * @param len The maximum number of buffers to be accessed; must be non-negative
-     *            and no larger than buf.length - offset
-     * @return The number of bytes sent
-     */
-    public static native int sendbb(long sock,
-                                   int offset, int len);
-
-    /**
-     * Send data over a network using internally set ByteBuffer
-     * without internal retry.
-     * @param sock The socket to send the data over.
-     * @param offset The offset within the buffer array of the first buffer from
-     *               which bytes are to be retrieved; must be non-negative
-     *               and no larger than buf.length
-     * @param len The maximum number of buffers to be accessed; must be non-negative
-     *            and no larger than buf.length - offset
-     * @return The number of bytes sent
-     */
-    public static native int sendibb(long sock,
-                                     int offset, int len);
-
-    /**
-     * Send multiple packets of data over a network.
-     * <PRE>
-     * This functions acts like a blocking write by default.  To change
-     * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK
-     * socket option.
-     * The number of bytes actually sent is stored in argument 3.
-     *
-     * It is possible for both bytes to be sent and an error to be returned.
-     *
-     * APR_EINTR is never returned.
-     * </PRE>
-     * @param sock The socket to send the data over.
-     * @param vec The array from which to get the data to send.
-     * @return The number of bytes sent
-     */
-    public static native int sendv(long sock, byte[][] vec);
-
-    /**
-     * @param sock The socket to send from
-     * @param where The apr_sockaddr_t describing where to send the data
-     * @param flags The flags to use
-     * @param buf  The data to send
-     * @param offset Offset in the byte buffer.
-     * @param len  The length of the data to send
-     * @return The number of bytes sent
-     */
-    public static native int sendto(long sock, long where, int flags,
-                                    byte[] buf, int offset, int len);
-
-    /**
-     * Read data from a network.
-     *
-     * <PRE>
-     * This functions acts like a blocking read by default.  To change
-     * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK
-     * socket option.
-     * The number of bytes actually received is stored in argument 3.
-     *
-     * It is possible for both bytes to be received and an APR_EOF or
-     * other error to be returned.
-     *
-     * APR_EINTR is never returned.
-     * </PRE>
-     * @param sock The socket to read the data from.
-     * @param buf The buffer to store the data in.
-     * @param offset Offset in the byte buffer.
-     * @param nbytes The number of bytes to read (-1) for full array.
-     * @return the number of bytes received.
-     */
-    public static native int recv(long sock, byte[] buf, int offset, int nbytes);
-
-    /**
-     * Read data from a network with timeout.
-     *
-     * <PRE>
-     * This functions acts like a blocking read by default.  To change
-     * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK
-     * socket option.
-     * The number of bytes actually received is stored in argument 3.
-     *
-     * It is possible for both bytes to be received and an APR_EOF or
-     * other error to be returned.
-     *
-     * APR_EINTR is never returned.
-     * </PRE>
-     * @param sock The socket to read the data from.
-     * @param buf The buffer to store the data in.
-     * @param offset Offset in the byte buffer.
-     * @param nbytes The number of bytes to read (-1) for full array.
-     * @param timeout The socket timeout in microseconds.
-     * @return the number of bytes received.
-     */
-    public static native int recvt(long sock, byte[] buf, int offset,
-                                   int nbytes, long timeout);
-
-    /**
-     * Read data from a network.
-     *
-     * <PRE>
-     * This functions acts like a blocking read by default.  To change
-     * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK
-     * socket option.
-     * The number of bytes actually received is stored in argument 3.
-     *
-     * It is possible for both bytes to be received and an APR_EOF or
-     * other error to be returned.
-     *
-     * APR_EINTR is never returned.
-     * </PRE>
-     * @param sock The socket to read the data from.
-     * @param buf The buffer to store the data in.
-     * @param offset Offset in the byte buffer.
-     * @param nbytes The number of bytes to read (-1) for full array.
-     * @return If &ge; 0, the return value is the number of bytes read. Note a
-     *         non-blocking read with no data current available will return
-     *         {@link Status#EAGAIN} and EOF will return {@link Status#APR_EOF}.
-     */
-    public static native int recvb(long sock, ByteBuffer buf,
-                                   int offset, int nbytes);
-
-    /**
-     * Read data from a network using internally set ByteBuffer.
-     *
-     * @param sock The socket to read the data from.
-     * @param offset Offset in the byte buffer.
-     * @param nbytes The number of bytes to read (-1) for full array.
-     * @return If &gt; 0, the return value is the number of bytes read. If == 0,
-     *         the return value indicates EOF and if &lt; 0 the return value is the
-     *         error code. Note a non-blocking read with no data current
-     *         available will return {@link Status#EAGAIN} not zero.
-     */
-    public static native int recvbb(long sock,
-                                    int offset, int nbytes);
-    /**
-     * Read data from a network with timeout.
-     *
-     * <PRE>
-     * This functions acts like a blocking read by default.  To change
-     * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK
-     * socket option.
-     * The number of bytes actually received is stored in argument 3.
-     *
-     * It is possible for both bytes to be received and an APR_EOF or
-     * other error to be returned.
-     *
-     * APR_EINTR is never returned.
-     * </PRE>
-     * @param sock The socket to read the data from.
-     * @param buf The buffer to store the data in.
-     * @param offset Offset in the byte buffer.
-     * @param nbytes The number of bytes to read (-1) for full array.
-     * @param timeout The socket timeout in microseconds.
-     * @return the number of bytes received.
-     */
-    public static native int recvbt(long sock, ByteBuffer buf,
-                                    int offset, int nbytes, long timeout);
-    /**
-     * Read data from a network with timeout using internally set ByteBuffer
-     * @param sock The socket to read the data from.
-     * @param offset Offset in the byte buffer.
-     * @param nbytes The number of bytes to read (-1) for full array.
-     * @param timeout The socket timeout in microseconds.
-     * @return the number of bytes received.
-     */
-    public static native int recvbbt(long sock,
-                                     int offset, int nbytes, long timeout);
-
-    /**
-     * @param from The apr_sockaddr_t to fill in the recipient info
-     * @param sock The socket to use
-     * @param flags The flags to use
-     * @param buf  The buffer to use
-     * @param offset Offset in the byte buffer.
-     * @param nbytes The number of bytes to read (-1) for full array.
-     * @return the number of bytes received.
-     */
-    public static native int recvfrom(long from, long sock, int flags,
-                                      byte[] buf, int offset, int nbytes);
-
-    /**
-     * Setup socket options for the specified socket
-     * @param sock The socket to set up.
-     * @param opt The option we would like to configure.  One of:
-     * <PRE>
-     * APR_SO_DEBUG      --  turn on debugging information
-     * APR_SO_KEEPALIVE  --  keep connections active
-     * APR_SO_LINGER     --  lingers on close if data is present
-     * APR_SO_NONBLOCK   --  Turns blocking on/off for socket
-     *                       When this option is enabled, use
-     *                       the APR_STATUS_IS_EAGAIN() macro to
-     *                       see if a send or receive function
-     *                       could not transfer data without
-     *                       blocking.
-     * APR_SO_REUSEADDR  --  The rules used in validating addresses
-     *                       supplied to bind should allow reuse
-     *                       of local addresses.
-     * APR_SO_SNDBUF     --  Set the SendBufferSize
-     * APR_SO_RCVBUF     --  Set the ReceiveBufferSize
-     * </PRE>
-     * @param on Value for the option.
-     * @return the operation status
-     */
-    public static native int optSet(long sock, int opt, int on);
-
-    /**
-     * Query socket options for the specified socket
-     * @param sock The socket to query
-     * @param opt The option we would like to query.  One of:
-     * <PRE>
-     * APR_SO_DEBUG      --  turn on debugging information
-     * APR_SO_KEEPALIVE  --  keep connections active
-     * APR_SO_LINGER     --  lingers on close if data is present
-     * APR_SO_NONBLOCK   --  Turns blocking on/off for socket
-     * APR_SO_REUSEADDR  --  The rules used in validating addresses
-     *                       supplied to bind should allow reuse
-     *                       of local addresses.
-     * APR_SO_SNDBUF     --  Set the SendBufferSize
-     * APR_SO_RCVBUF     --  Set the ReceiveBufferSize
-     * APR_SO_DISCONNECTED -- Query the disconnected state of the socket.
-     *                       (Currently only used on Windows)
-     * </PRE>
-     * @return Socket option returned on the call.
-     * @throws Exception An error occurred
-     */
-    public static native int optGet(long sock, int opt)
-        throws Exception;
-
-    /**
-     * Setup socket timeout for the specified socket
-     * @param sock The socket to set up.
-     * @param t Value for the timeout in microseconds.
-     * <PRE>
-     * t &gt; 0  -- read and write calls return APR_TIMEUP if specified time
-     *           elapses with no data read or written
-     * t == 0 -- read and write calls never block
-     * t &lt; 0  -- read and write calls block
-     * </PRE>
-     * @return the operation status
-     */
-    public static native int timeoutSet(long sock, long t);
-
-    /**
-     * Query socket timeout for the specified socket
-     * @param sock The socket to query
-     * @return Socket timeout returned from the query.
-     * @throws Exception An error occurred
-     */
-    public static native long timeoutGet(long sock)
-        throws Exception;
-
-    /**
-     * Send a file from an open file descriptor to a socket, along with
-     * optional headers and trailers.
-     * <br>
-     * This functions acts like a blocking write by default.  To change
-     *         this behavior, use apr_socket_timeout_set() or the
-     *         APR_SO_NONBLOCK socket option.
-     * The number of bytes actually sent is stored in the len parameter.
-     * The offset parameter is passed by reference for no reason; its
-     * value will never be modified by the apr_socket_sendfile() function.
-     * @param sock The socket to which we're writing
-     * @param file The open file from which to read
-     * @param headers Array containing the headers to send
-     * @param trailers Array containing the trailers to send
-     * @param offset Offset into the file where we should begin writing
-     * @param len Number of bytes to send from the file
-     * @param flags APR flags that are mapped to OS specific flags
-     * @return Number of bytes actually sent, including headers,
-     *         file, and trailers
-     */
-    public static native long sendfile(long sock, long file, byte [][] headers,
-                                       byte[][] trailers, long offset,
-                                       long len, int flags);
-
-    /**
-     * Send a file without header and trailer arrays.
-     * @param sock The socket to which we're writing
-     * @param file The open file from which to read
-     * @param offset Offset into the file where we should begin writing
-     * @param len Number of bytes to send from the file
-     * @param flags APR flags that are mapped to OS specific flags
-     * @return Number of bytes actually sent
-     */
-    public static native long sendfilen(long sock, long file, long offset,
-                                        long len, int flags);
-
-    /**
-     * Create a child pool from associated socket pool.
-     * @param thesocket The socket to use
-     * @return a pointer to the pool
-     * @throws Exception An error occurred
-     */
-    public static native long pool(long thesocket)
-        throws Exception;
-
-    /**
-     * Private method for getting the socket struct members
-     * @param socket The socket to use
-     * @param what Struct member to obtain
-     * <PRE>
-     * SOCKET_GET_POOL  - The socket pool
-     * SOCKET_GET_IMPL  - The socket implementation object
-     * SOCKET_GET_APRS  - APR socket
-     * SOCKET_GET_TYPE  - Socket type
-     * </PRE>
-     * @return The structure member address
-     */
-    private static native long get(long socket, int what);
-
-    /**
-     * Set internal send ByteBuffer.
-     * This function will preset internal Java ByteBuffer for
-     * consecutive sendbb calls.
-     * @param sock The socket to use
-     * @param buf The ByteBuffer
-     */
-    public static native void setsbb(long sock, ByteBuffer buf);
-
-    /**
-     * Set internal receive ByteBuffer.
-     * This function will preset internal Java ByteBuffer for
-     * consecutive revcvbb/recvbbt calls.
-     * @param sock The socket to use
-     * @param buf The ByteBuffer
-     */
-    public static native void setrbb(long sock, ByteBuffer buf);
-
-    /**
-     * Set the data associated with the current socket.
-     * @param sock The currently open socket.
-     * @param data The user data to associate with the socket.
-     * @param key The key to associate with the data.
-     * @return the operation status
-     */
-      public static native int dataSet(long sock, String key, Object data);
-
-    /**
-     * Return the data associated with the current socket
-     * @param sock The currently open socket.
-     * @param key The key to associate with the user data.
-     * @return Data or null in case of error.
-     */
-     public static native Object dataGet(long sock, String key);
-
-}

==================================================
Stdlib.java
deleted file mode 100644
index 004340cdae..0000000000
--- a/java/org/apache/tomcat/jni/Status.java
+++ /dev/null
@@ -1,268 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.jni;
-
-/** Status
- *
- * @author Mladen Turk
- *
- * @deprecated  The scope of the APR/Native Library will be reduced in Tomcat
- *              10.1.x / Tomcat Native 2.x onwards to only include those
- *              components required to provide OpenSSL integration with the NIO
- *              and NIO2 connectors.
- */
-@Deprecated
-public class Status {
-
-    /**
-     * APR_OS_START_ERROR is where the APR specific error values start.
-     */
-     public static final int APR_OS_START_ERROR   = 20000;
-    /**
-     * APR_OS_ERRSPACE_SIZE is the maximum number of errors you can fit
-     *    into one of the error/status ranges below -- except for
-     *    APR_OS_START_USERERR, which see.
-     */
-     public static final int APR_OS_ERRSPACE_SIZE = 50000;
-    /**
-     * APR_OS_START_STATUS is where the APR specific status codes start.
-     */
-     public static final int APR_OS_START_STATUS  = (APR_OS_START_ERROR + APR_OS_ERRSPACE_SIZE);
-
-    /**
-     * APR_OS_START_USERERR are reserved for applications that use APR that
-     *     layer their own error codes along with APR's.  Note that the
-     *     error immediately following this one is set ten times farther
-     *     away than usual, so that users of apr have a lot of room in
-     *     which to declare custom error codes.
-     */
-    public static final int APR_OS_START_USERERR  = (APR_OS_START_STATUS + APR_OS_ERRSPACE_SIZE);
-    /**
-     * APR_OS_START_USEERR is obsolete, defined for compatibility only.
-     * Use APR_OS_START_USERERR instead.
-     */
-    public static final int APR_OS_START_USEERR    = APR_OS_START_USERERR;
-    /**
-     * APR_OS_START_CANONERR is where APR versions of errno values are defined
-     *     on systems which don't have the corresponding errno.
-     */
-    public static final int APR_OS_START_CANONERR  = (APR_OS_START_USERERR + (APR_OS_ERRSPACE_SIZE * 10));
-
-    /**
-     * APR_OS_START_EAIERR folds EAI_ error codes from getaddrinfo() into
-     *     apr_status_t values.
-     */
-    public static final int APR_OS_START_EAIERR  = (APR_OS_START_CANONERR + APR_OS_ERRSPACE_SIZE);
-    /**
-     * APR_OS_START_SYSERR folds platform-specific system error values into
-     *     apr_status_t values.
-     */
-    public static final int APR_OS_START_SYSERR  = (APR_OS_START_EAIERR + APR_OS_ERRSPACE_SIZE);
-
-    /** no error. */
-    public static final int APR_SUCCESS = 0;
-
-    /**
-     * APR Error Values
-     * <PRE>
-     * <b>APR ERROR VALUES</b>
-     * APR_ENOSTAT      APR was unable to perform a stat on the file
-     * APR_ENOPOOL      APR was not provided a pool with which to allocate memory
-     * APR_EBADDATE     APR was given an invalid date
-     * APR_EINVALSOCK   APR was given an invalid socket
-     * APR_ENOPROC      APR was not given a process structure
-     * APR_ENOTIME      APR was not given a time structure
-     * APR_ENODIR       APR was not given a directory structure
-     * APR_ENOLOCK      APR was not given a lock structure
-     * APR_ENOPOLL      APR was not given a poll structure
-     * APR_ENOSOCKET    APR was not given a socket
-     * APR_ENOTHREAD    APR was not given a thread structure
-     * APR_ENOTHDKEY    APR was not given a thread key structure
-     * APR_ENOSHMAVAIL  There is no more shared memory available
-     * APR_EDSOOPEN     APR was unable to open the dso object.  For more
-     *                  information call apr_dso_error().
-     * APR_EGENERAL     General failure (specific information not available)
-     * APR_EBADIP       The specified IP address is invalid
-     * APR_EBADMASK     The specified netmask is invalid
-     * APR_ESYMNOTFOUND Could not find the requested symbol
-     * </PRE>
-     *
-     */
-    public static final int APR_ENOSTAT       = (APR_OS_START_ERROR + 1);
-    public static final int APR_ENOPOOL       = (APR_OS_START_ERROR + 2);
-    public static final int APR_EBADDATE      = (APR_OS_START_ERROR + 4);
-    public static final int APR_EINVALSOCK    = (APR_OS_START_ERROR + 5);
-    public static final int APR_ENOPROC       = (APR_OS_START_ERROR + 6);
-    public static final int APR_ENOTIME       = (APR_OS_START_ERROR + 7);
-    public static final int APR_ENODIR        = (APR_OS_START_ERROR + 8);
-    public static final int APR_ENOLOCK       = (APR_OS_START_ERROR + 9);
-    public static final int APR_ENOPOLL       = (APR_OS_START_ERROR + 10);
-    public static final int APR_ENOSOCKET     = (APR_OS_START_ERROR + 11);
-    public static final int APR_ENOTHREAD     = (APR_OS_START_ERROR + 12);
-    public static final int APR_ENOTHDKEY     = (APR_OS_START_ERROR + 13);
-    public static final int APR_EGENERAL      = (APR_OS_START_ERROR + 14);
-    public static final int APR_ENOSHMAVAIL   = (APR_OS_START_ERROR + 15);
-    public static final int APR_EBADIP        = (APR_OS_START_ERROR + 16);
-    public static final int APR_EBADMASK      = (APR_OS_START_ERROR + 17);
-    public static final int APR_EDSOOPEN      = (APR_OS_START_ERROR + 19);
-    public static final int APR_EABSOLUTE     = (APR_OS_START_ERROR + 20);
-    public static final int APR_ERELATIVE     = (APR_OS_START_ERROR + 21);
-    public static final int APR_EINCOMPLETE   = (APR_OS_START_ERROR + 22);
-    public static final int APR_EABOVEROOT    = (APR_OS_START_ERROR + 23);
-    public static final int APR_EBADPATH      = (APR_OS_START_ERROR + 24);
-    public static final int APR_EPATHWILD     = (APR_OS_START_ERROR + 25);
-    public static final int APR_ESYMNOTFOUND  = (APR_OS_START_ERROR + 26);
-    public static final int APR_EPROC_UNKNOWN = (APR_OS_START_ERROR + 27);
-    public static final int APR_ENOTENOUGHENTROPY = (APR_OS_START_ERROR + 28);
-
-    /** APR Status Values
-     * <PRE>
-     * <b>APR STATUS VALUES</b>
-     * APR_INCHILD        Program is currently executing in the child
-     * APR_INPARENT       Program is currently executing in the parent
-     * APR_DETACH         The thread is detached
-     * APR_NOTDETACH      The thread is not detached
-     * APR_CHILD_DONE     The child has finished executing
-     * APR_CHILD_NOTDONE  The child has not finished executing
-     * APR_TIMEUP         The operation did not finish before the timeout
-     * APR_INCOMPLETE     The operation was incomplete although some processing
-     *                    was performed and the results are partially valid
-     * APR_BADCH          Getopt found an option not in the option string
-     * APR_BADARG         Getopt found an option that is missing an argument
-     *                    and an argument was specified in the option string
-     * APR_EOF            APR has encountered the end of the file
-     * APR_NOTFOUND       APR was unable to find the socket in the poll structure
-     * APR_ANONYMOUS      APR is using anonymous shared memory
-     * APR_FILEBASED      APR is using a file name as the key to the shared memory
-     * APR_KEYBASED       APR is using a shared key as the key to the shared memory
-     * APR_EINIT          Initializer value.  If no option has been found, but
-     *                    the status variable requires a value, this should be used
-     * APR_ENOTIMPL       The APR function has not been implemented on this
-     *                    platform, either because nobody has gotten to it yet,
-     *                    or the function is impossible on this platform.
-     * APR_EMISMATCH      Two passwords do not match.
-     * APR_EBUSY          The given lock was busy.
-     * </PRE>
-     *
-     */
-    public static final int APR_INCHILD       = (APR_OS_START_STATUS + 1);
-    public static final int APR_INPARENT      = (APR_OS_START_STATUS + 2);
-    public static final int APR_DETACH        = (APR_OS_START_STATUS + 3);
-    public static final int APR_NOTDETACH     = (APR_OS_START_STATUS + 4);
-    public static final int APR_CHILD_DONE    = (APR_OS_START_STATUS + 5);
-    public static final int APR_CHILD_NOTDONE = (APR_OS_START_STATUS + 6);
-    public static final int APR_TIMEUP        = (APR_OS_START_STATUS + 7);
-    public static final int APR_INCOMPLETE    = (APR_OS_START_STATUS + 8);
-    public static final int APR_BADCH         = (APR_OS_START_STATUS + 12);
-    public static final int APR_BADARG        = (APR_OS_START_STATUS + 13);
-    public static final int APR_EOF           = (APR_OS_START_STATUS + 14);
-    public static final int APR_NOTFOUND      = (APR_OS_START_STATUS + 15);
-    public static final int APR_ANONYMOUS     = (APR_OS_START_STATUS + 19);
-    public static final int APR_FILEBASED     = (APR_OS_START_STATUS + 20);
-    public static final int APR_KEYBASED      = (APR_OS_START_STATUS + 21);
-    public static final int APR_EINIT         = (APR_OS_START_STATUS + 22);
-    public static final int APR_ENOTIMPL      = (APR_OS_START_STATUS + 23);
-    public static final int APR_EMISMATCH     = (APR_OS_START_STATUS + 24);
-    public static final int APR_EBUSY         = (APR_OS_START_STATUS + 25);
-
-    public static final int TIMEUP            = (APR_OS_START_USERERR + 1);
-    public static final int EAGAIN            = (APR_OS_START_USERERR + 2);
-    public static final int EINTR             = (APR_OS_START_USERERR + 3);
-    public static final int EINPROGRESS       = (APR_OS_START_USERERR + 4);
-    public static final int ETIMEDOUT         = (APR_OS_START_USERERR + 5);
-
-    private static native boolean is(int err, int idx);
-    /*
-     * APR_STATUS_IS Status Value Tests
-     * <br><b>Warning :</b> For any particular error condition, more than one of these tests
-     *      may match. This is because platform-specific error codes may not
-     *      always match the semantics of the POSIX codes these tests (and the
-     *      corresponding APR error codes) are named after. A notable example
-     *      are the APR_STATUS_IS_ENOENT and APR_STATUS_IS_ENOTDIR tests on
-     *      Win32 platforms. The programmer should always be aware of this and
-     *      adjust the order of the tests accordingly.
-     *
-     */
-    public static final boolean APR_STATUS_IS_ENOSTAT(int s)    { return is(s, 1); }
-    public static final boolean APR_STATUS_IS_ENOPOOL(int s)    { return is(s, 2); }
-    /* empty slot: +3 */
-    public static final boolean APR_STATUS_IS_EBADDATE(int s)   { return is(s, 4); }
-    public static final boolean APR_STATUS_IS_EINVALSOCK(int s) { return is(s, 5); }
-    public static final boolean APR_STATUS_IS_ENOPROC(int s)    { return is(s, 6); }
-    public static final boolean APR_STATUS_IS_ENOTIME(int s)    { return is(s, 7); }
-    public static final boolean APR_STATUS_IS_ENODIR(int s)     { return is(s, 8); }
-    public static final boolean APR_STATUS_IS_ENOLOCK(int s)    { return is(s, 9); }
-    public static final boolean APR_STATUS_IS_ENOPOLL(int s)    { return is(s, 10); }
-    public static final boolean APR_STATUS_IS_ENOSOCKET(int s)  { return is(s, 11); }
-    public static final boolean APR_STATUS_IS_ENOTHREAD(int s)  { return is(s, 12); }
-    public static final boolean APR_STATUS_IS_ENOTHDKEY(int s)  { return is(s, 13); }
-    public static final boolean APR_STATUS_IS_EGENERAL(int s)   { return is(s, 14); }
-    public static final boolean APR_STATUS_IS_ENOSHMAVAIL(int s){ return is(s, 15); }
-    public static final boolean APR_STATUS_IS_EBADIP(int s)     { return is(s, 16); }
-    public static final boolean APR_STATUS_IS_EBADMASK(int s)   { return is(s, 17); }
-    /* empty slot: +18 */
-    public static final boolean APR_STATUS_IS_EDSOPEN(int s)    { return is(s, 19); }
-    public static final boolean APR_STATUS_IS_EABSOLUTE(int s)  { return is(s, 20); }
-    public static final boolean APR_STATUS_IS_ERELATIVE(int s)  { return is(s, 21); }
-    public static final boolean APR_STATUS_IS_EINCOMPLETE(int s){ return is(s, 22); }
-    public static final boolean APR_STATUS_IS_EABOVEROOT(int s) { return is(s, 23); }
-    public static final boolean APR_STATUS_IS_EBADPATH(int s)   { return is(s, 24); }
-    public static final boolean APR_STATUS_IS_EPATHWILD(int s)  { return is(s, 25); }
-    public static final boolean APR_STATUS_IS_ESYMNOTFOUND(int s)      { return is(s, 26); }
-    public static final boolean APR_STATUS_IS_EPROC_UNKNOWN(int s)     { return is(s, 27); }
-    public static final boolean APR_STATUS_IS_ENOTENOUGHENTROPY(int s) { return is(s, 28); }
-
-    /*
-     * APR_Error
-     */
-    public static final boolean APR_STATUS_IS_INCHILD(int s)    { return is(s, 51); }
-    public static final boolean APR_STATUS_IS_INPARENT(int s)   { return is(s, 52); }
-    public static final boolean APR_STATUS_IS_DETACH(int s)     { return is(s, 53); }
-    public static final boolean APR_STATUS_IS_NOTDETACH(int s)  { return is(s, 54); }
-    public static final boolean APR_STATUS_IS_CHILD_DONE(int s) { return is(s, 55); }
-    public static final boolean APR_STATUS_IS_CHILD_NOTDONE(int s)  { return is(s, 56); }
-    public static final boolean APR_STATUS_IS_TIMEUP(int s)     { return is(s, 57); }
-    public static final boolean APR_STATUS_IS_INCOMPLETE(int s) { return is(s, 58); }
-    /* empty slot: +9 */
-    /* empty slot: +10 */
-    /* empty slot: +11 */
-    public static final boolean APR_STATUS_IS_BADCH(int s)      { return is(s, 62); }
-    public static final boolean APR_STATUS_IS_BADARG(int s)     { return is(s, 63); }
-    public static final boolean APR_STATUS_IS_EOF(int s)        { return is(s, 64); }
-    public static final boolean APR_STATUS_IS_NOTFOUND(int s)   { return is(s, 65); }
-    /* empty slot: +16 */
-    /* empty slot: +17 */
-    /* empty slot: +18 */
-    public static final boolean APR_STATUS_IS_ANONYMOUS(int s)  { return is(s, 69); }
-    public static final boolean APR_STATUS_IS_FILEBASED(int s)  { return is(s, 70); }
-    public static final boolean APR_STATUS_IS_KEYBASED(int s)   { return is(s, 71); }
-    public static final boolean APR_STATUS_IS_EINIT(int s)      { return is(s, 72); }
-    public static final boolean APR_STATUS_IS_ENOTIMPL(int s)   { return is(s, 73); }
-    public static final boolean APR_STATUS_IS_EMISMATCH(int s)  { return is(s, 74); }
-    public static final boolean APR_STATUS_IS_EBUSY(int s)      { return is(s, 75); }
-
-    /* Socket errors */
-    public static final boolean APR_STATUS_IS_EAGAIN(int s)     { return is(s, 90); }
-    public static final boolean APR_STATUS_IS_ETIMEDOUT(int s)  { return is(s, 91); }
-    public static final boolean APR_STATUS_IS_ECONNABORTED(int s) { return is(s, 92); }
-    public static final boolean APR_STATUS_IS_ECONNRESET(int s)   { return is(s, 93); }
-    public static final boolean APR_STATUS_IS_EINPROGRESS(int s)  { return is(s, 94); }
-    public static final boolean APR_STATUS_IS_EINTR(int s)      { return is(s, 95); }
-    public static final boolean APR_STATUS_IS_ENOTSOCK(int s)   { return is(s, 96); }
-    public static final boolean APR_STATUS_IS_EINVAL(int s)     { return is(s, 97); }
-
-}

==================================================
Thread.java
deleted file mode 100644
index 18e8fb2173..0000000000
--- a/java/org/apache/tomcat/jni/Stdlib.java
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.jni;
-
-/** Stdlib
- *
- * @author Mladen Turk
- *
- * @deprecated  The scope of the APR/Native Library will be reduced in Tomcat
- *              10.1.x / Tomcat Native 2.x onwards to only include those
- *              components required to provide OpenSSL integration with the NIO
- *              and NIO2 connectors.
- */
-@Deprecated
-public class Stdlib {
-
-    /**
-     * Read from plain memory
-     * @param dst Destination byte array
-     * @param src Source memory address
-     * @param sz Number of bytes to copy.
-     * @return <code>true</code> if the operation was successful
-     */
-    public static native boolean memread(byte [] dst, long src, int sz);
-
-    /**
-     * Write to plain memory
-     * @param dst Destination memory address
-     * @param src Source byte array
-     * @param sz Number of bytes to copy.
-     * @return <code>true</code> if the operation was successful
-     */
-    public static native boolean memwrite(long dst, byte [] src, int sz);
-
-    /**
-     * Sets buffers to a specified character
-     * @param dst Destination memory address
-     * @param c Character to set.
-     * @param sz Number of characters.
-     * @return <code>true</code> if the operation was successful
-     */
-    public static native boolean memset(long dst, int c, int sz);
-
-    /**
-     * Allocates memory blocks.
-     * @param sz Bytes to allocate.
-     * @return a pointer
-     */
-    public static native long malloc(int sz);
-
-    /**
-     * Reallocate memory blocks.
-     * @param mem Pointer to previously allocated memory block.
-     * @param sz New size in bytes.
-     * @return a pointer
-     */
-    public static native long realloc(long mem, int sz);
-
-    /**
-     * Allocates an array in memory with elements initialized to 0.
-     * @param num Number of elements.
-     * @param sz Length in bytes of each element.
-     * @return a pointer
-     */
-    public static native long calloc(int num, int sz);
-
-    /**
-     * Deallocates or frees a memory block.
-     * @param mem Previously allocated memory block to be freed.
-     */
-    public static native void free(long mem);
-
-    /**
-     * Get current process pid.
-     * @return current pid or &lt; 1 in case of error.
-     */
-    public static native int getpid();
-
-    /**
-     * Get current process parent pid.
-     * @return parent pid or &lt; 1 in case of error.
-     */
-    public static native int getppid();
-
-}

==================================================
Time.java
deleted file mode 100644
index 277cfb61a0..0000000000
--- a/java/org/apache/tomcat/jni/Thread.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.jni;
-
-/** Thread
- *
- * @author Mladen Turk
- *
- * @deprecated  The scope of the APR/Native Library will be reduced in Tomcat
- *              10.1.x / Tomcat Native 2.x onwards to only include those
- *              components required to provide OpenSSL integration with the NIO
- *              and NIO2 connectors.
- */
-@Deprecated
-public class Thread {
-
-    /**
-     * @return the current thread ID handle.
-     */
-    public static native long current();
-
-}

==================================================
User.java
deleted file mode 100644
index 24b054020a..0000000000
--- a/java/org/apache/tomcat/jni/Time.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.jni;
-
-/** Time
- *
- * @author Mladen Turk
- *
- * @deprecated  The scope of the APR/Native Library will be reduced in Tomcat
- *              10.1.x / Tomcat Native 2.x onwards to only include those
- *              components required to provide OpenSSL integration with the NIO
- *              and NIO2 connectors.
- */
-@Deprecated
-public class Time {
-
-    /** number of microseconds per second */
-    public static final long APR_USEC_PER_SEC  = 1000000L;
-    /** number of milliseconds per microsecond */
-    public static final long APR_MSEC_PER_USEC = 1000L;
-
-    /**
-     * @param t The time
-     * @return apr_time_t as a second
-     */
-    public static long sec(long t)
-    {
-        return t / APR_USEC_PER_SEC;
-    }
-
-    /**
-     * @param t The time
-     * @return apr_time_t as a msec
-     */
-    public static long msec(long t)
-    {
-        return t / APR_MSEC_PER_USEC;
-    }
-
-    /**
-     * number of microseconds since 00:00:00 January 1, 1970 UTC
-     * @return the current time
-     */
-    public static native long now();
-
-    /**
-     * Formats dates in the RFC822
-     * format in an efficient manner.
-     * @param t the time to convert
-     * @return the formatted date
-     */
-    public static native String rfc822(long t);
-
-    /**
-     * Formats dates in the ctime() format
-     * in an efficient manner.
-     * Unlike ANSI/ISO C ctime(), apr_ctime() does not include
-     * a \n at the end of the string.
-     * @param t the time to convert
-     * @return the formatted date
-     */
-    public static native String ctime(long t);
-
-    /**
-     * Sleep for the specified number of micro-seconds.
-     * <br><b>Warning :</b> May sleep for longer than the specified time.
-     * @param t desired amount of time to sleep.
-     */
-    public static native void sleep(long t);
-
-}

==================================================
Acceptor.java
deleted file mode 100644
index b9a0547e89..0000000000
--- a/java/org/apache/tomcat/jni/User.java
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.jni;
-
-/** User
- *
- * @author Mladen Turk
- *
- * @deprecated  The scope of the APR/Native Library will be reduced in Tomcat
- *              10.1.x / Tomcat Native 2.x onwards to only include those
- *              components required to provide OpenSSL integration with the NIO
- *              and NIO2 connectors.
- */
-@Deprecated
-public class User {
-
-    /**
-     * Get the userid (and groupid) of the calling process
-     * This function is available only if APR_HAS_USER is defined.
-     * @param p The pool from which to allocate working space
-     * @return Returns the user id
-     * @throws Error If an error occurred
-     */
-     public static native long uidCurrent(long p)
-        throws Error;
-
-    /**
-     * Get the groupid of the calling process
-     * This function is available only if APR_HAS_USER is defined.
-     * @param p The pool from which to allocate working space
-     * @return Returns the group id
-     * @throws Error If an error occurred
-     */
-     public static native long gidCurrent(long p)
-        throws Error;
-
-
-    /**
-     * Get the userid for the specified username
-     * This function is available only if APR_HAS_USER is defined.
-     * @param username The username to lookup
-     * @param p The pool from which to allocate working space
-     * @return Returns the user id
-     * @throws Error If an error occurred
-     */
-     public static native long uid(String username, long p)
-        throws Error;
-
-    /**
-     * Get the groupid for the specified username
-     * This function is available only if APR_HAS_USER is defined.
-     * @param username The username to lookup
-     * @param p The pool from which to allocate working space
-     * @return  Returns the user's group id
-     * @throws Error If an error occurred
-     */
-     public static native long usergid(String username, long p)
-        throws Error;
-
-    /**
-     * Get the groupid for a specified group name
-     * This function is available only if APR_HAS_USER is defined.
-     * @param groupname The group name to look up
-     * @param p The pool from which to allocate working space
-     * @return  Returns the user's group id
-     * @throws Error If an error occurred
-     */
-     public static native long gid(String groupname, long p)
-        throws Error;
-
-    /**
-     * Get the user name for a specified userid
-     * This function is available only if APR_HAS_USER is defined.
-     * @param userid The userid
-     * @param p The pool from which to allocate the string
-     * @return New string containing user name
-     * @throws Error If an error occurred
-     */
-     public static native String username(long userid, long p)
-        throws Error;
-
-    /**
-     * Get the group name for a specified groupid
-     * This function is available only if APR_HAS_USER is defined.
-     * @param groupid The groupid
-     * @param p The pool from which to allocate the string
-     * @return New string containing group name
-     * @throws Error If an error occurred
-     */
-     public static native String groupname(long groupid, long p)
-        throws Error;
-
-    /**
-     * Compare two user identifiers for equality.
-     * This function is available only if APR_HAS_USER is defined.
-     * @param left One uid to test
-     * @param right Another uid to test
-     * @return APR_SUCCESS if the apr_uid_t structures identify the same user,
-     * APR_EMISMATCH if not, APR_BADARG if an apr_uid_t is invalid.
-     */
-     public static native int uidcompare(long left, long right);
-
-    /**
-     * Compare two group identifiers for equality.
-     * This function is available only if APR_HAS_USER is defined.
-     * @param left One gid to test
-     * @param right Another gid to test
-     * @return APR_SUCCESS if the apr_gid_t structures identify the same group,
-     * APR_EMISMATCH if not, APR_BADARG if an apr_gid_t is invalid.
-     */
-     public static native int gidcompare(long left, long right);
-
-    /**
-     * Get the home directory for the named user
-     * This function is available only if APR_HAS_USER is defined.
-     * @param username The named user
-     * @param p The pool from which to allocate the string
-     * @return New string containing directory name
-     * @throws Error If an error occurred
-     */
-     public static native String homepath(String username, long p)
-        throws Error;
-
-}

==================================================
AprEndpoint.java
index 9088854dc0..c5261453e0 100644
--- a/java/org/apache/tomcat/util/net/Acceptor.java
+++ b/java/org/apache/tomcat/util/net/Acceptor.java
@@ -21,7 +21,6 @@ import java.util.concurrent.TimeUnit;
 
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
-import org.apache.tomcat.jni.Error;
 import org.apache.tomcat.util.ExceptionUtils;
 import org.apache.tomcat.util.res.StringManager;
 
@@ -132,21 +131,7 @@ public class Acceptor<U> implements Runnable {
                 } catch (Throwable t) {
                     ExceptionUtils.handleThrowable(t);
                     String msg = sm.getString("endpoint.accept.fail");
-                    // APR specific.
-                    // Could push this down but not sure it is worth the trouble.
-                    if (t instanceof Error) {
-                        Error e = (Error) t;
-                        if (e.getError() == 233) {
-                            // Not an error on HP-UX so log as a warning
-                            // so it can be filtered out on that platform
-                            // See bug 50273
-                            log.warn(msg, t);
-                        } else {
-                            log.error(msg, t);
-                        }
-                    } else {
-                            log.error(msg, t);
-                    }
+                    log.error(msg, t);
                 }
             }
         } finally {

==================================================
AprSSLSupport.java
deleted file mode 100644
index 23160671ff..0000000000
--- a/java/org/apache/tomcat/util/net/AprEndpoint.java
+++ /dev/null
@@ -1,2782 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.util.net;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.net.InetSocketAddress;
-import java.net.SocketTimeoutException;
-import java.nio.ByteBuffer;
-import java.nio.channels.CompletionHandler;
-import java.nio.charset.StandardCharsets;
-import java.nio.file.Files;
-import java.nio.file.Path;
-import java.nio.file.Paths;
-import java.nio.file.attribute.FileAttribute;
-import java.nio.file.attribute.PosixFilePermission;
-import java.nio.file.attribute.PosixFilePermissions;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.RejectedExecutionException;
-import java.util.concurrent.Semaphore;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantReadWriteLock;
-import java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;
-
-import javax.net.ssl.KeyManager;
-
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-import org.apache.tomcat.jni.Address;
-import org.apache.tomcat.jni.Error;
-import org.apache.tomcat.jni.File;
-import org.apache.tomcat.jni.Library;
-import org.apache.tomcat.jni.OS;
-import org.apache.tomcat.jni.Poll;
-import org.apache.tomcat.jni.Pool;
-import org.apache.tomcat.jni.SSL;
-import org.apache.tomcat.jni.SSLContext;
-import org.apache.tomcat.jni.SSLContext.SNICallBack;
-import org.apache.tomcat.jni.SSLSocket;
-import org.apache.tomcat.jni.Sockaddr;
-import org.apache.tomcat.jni.Socket;
-import org.apache.tomcat.jni.Status;
-import org.apache.tomcat.util.ExceptionUtils;
-import org.apache.tomcat.util.buf.ByteBufferUtils;
-import org.apache.tomcat.util.collections.SynchronizedStack;
-import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
-import org.apache.tomcat.util.net.Acceptor.AcceptorState;
-import org.apache.tomcat.util.net.openssl.OpenSSLContext;
-import org.apache.tomcat.util.net.openssl.OpenSSLUtil;
-
-
-/**
- * APR tailored thread pool, providing the following services:
- * <ul>
- * <li>Socket acceptor thread</li>
- * <li>Socket poller thread</li>
- * <li>Sendfile thread</li>
- * <li>Worker threads pool</li>
- * </ul>
- *
- * TODO: Consider using the virtual machine's thread pool.
- *
- * @author Mladen Turk
- * @author Remy Maucherat
- *
- * @deprecated  The APR/Native Connector will be removed in Tomcat 10.1.x
- *              onwards.
- */
-@Deprecated
-public class AprEndpoint extends AbstractEndpoint<Long,Long> implements SNICallBack {
-
-    // -------------------------------------------------------------- Constants
-
-    private static final Log log = LogFactory.getLog(AprEndpoint.class);
-
-    // ----------------------------------------------------------------- Fields
-
-    /**
-     * Root APR memory pool.
-     */
-    protected long rootPool = 0;
-
-
-    /**
-     * Server socket "pointer".
-     */
-    protected volatile long serverSock = 0;
-
-
-    /**
-     * APR memory pool for the server socket.
-     */
-    protected long serverSockPool = 0;
-
-
-    /**
-     * SSL context.
-     */
-    protected long sslContext = 0;
-
-
-    // ------------------------------------------------------------ Constructor
-
-    public AprEndpoint() {
-        // Asynchronous IO has significantly lower performance with APR:
-        // - no IO vectoring
-        // - mandatory use of direct buffers forces output buffering
-        // - needs extra output flushes due to buffering
-        setUseAsyncIO(false);
-    }
-
-    // ------------------------------------------------------------- Properties
-
-
-    /**
-     * Defer accept.
-     */
-    protected boolean deferAccept = true;
-    public void setDeferAccept(boolean deferAccept) { this.deferAccept = deferAccept; }
-    @Override
-    public boolean getDeferAccept() { return deferAccept; }
-
-
-    private boolean ipv6v6only = false;
-    public void setIpv6v6only(boolean ipv6v6only) { this.ipv6v6only = ipv6v6only; }
-    public boolean getIpv6v6only() { return ipv6v6only; }
-
-
-    /**
-     * Size of the sendfile (= concurrent files which can be served).
-     */
-    protected int sendfileSize = 1 * 1024;
-    public void setSendfileSize(int sendfileSize) { this.sendfileSize = sendfileSize; }
-    public int getSendfileSize() { return sendfileSize; }
-
-
-    /**
-     * Poll interval, in microseconds. The smaller the value, the more CPU the poller
-     * will use, but the more responsive to activity it will be.
-     */
-    protected int pollTime = 2000;
-    public int getPollTime() { return pollTime; }
-    public void setPollTime(int pollTime) { if (pollTime > 0) { this.pollTime = pollTime; } }
-
-
-    /*
-     * When the endpoint is created and configured, the APR library will not
-     * have been initialised. This flag is used to determine if the default
-     * value of useSendFile should be changed if the APR library indicates it
-     * supports send file once it has been initialised. If useSendFile is set
-     * by configuration, that configuration will always take priority.
-     */
-    private boolean useSendFileSet = false;
-    @Override
-    public void setUseSendfile(boolean useSendfile) {
-        useSendFileSet = true;
-        super.setUseSendfile(useSendfile);
-    }
-    /*
-     * For internal use to avoid setting the useSendFileSet flag
-     */
-    private void setUseSendfileInternal(boolean useSendfile) {
-        super.setUseSendfile(useSendfile);
-    }
-
-
-    /**
-     * The socket poller.
-     */
-    protected Poller poller = null;
-    public Poller getPoller() {
-        return poller;
-    }
-
-
-    /**
-     * The static file sender.
-     */
-    protected Sendfile sendfile = null;
-    public Sendfile getSendfile() {
-        return sendfile;
-    }
-
-
-    @Override
-    public InetSocketAddress getLocalAddress() throws IOException {
-        long s = serverSock;
-        if (s == 0) {
-            return null;
-        } else {
-            long sa;
-            try {
-                sa = Address.get(Socket.APR_LOCAL, s);
-            } catch (IOException ioe) {
-                // re-throw
-                throw ioe;
-            } catch (Exception e) {
-                // wrap
-                throw new IOException(e);
-            }
-            Sockaddr addr = Address.getInfo(sa);
-            if (addr.hostname == null) {
-                // any local address
-                if (addr.family == Socket.APR_INET6) {
-                    return new InetSocketAddress("::", addr.port);
-                } else {
-                    return new InetSocketAddress("0.0.0.0", addr.port);
-                }
-            }
-            return new InetSocketAddress(addr.hostname, addr.port);
-        }
-    }
-
-
-    /**
-     * This endpoint does not support <code>-1</code> for unlimited connections,
-     * nor does it support setting this attribute while the endpoint is running.
-     *
-     * {@inheritDoc}
-     */
-    @Override
-    public void setMaxConnections(int maxConnections) {
-        if (maxConnections == -1) {
-            log.warn(sm.getString("endpoint.apr.maxConnections.unlimited",
-                    Integer.valueOf(getMaxConnections())));
-            return;
-        }
-        if (running) {
-            log.warn(sm.getString("endpoint.apr.maxConnections.running",
-                    Integer.valueOf(getMaxConnections())));
-            return;
-        }
-        super.setMaxConnections(maxConnections);
-    }
-
-
-     /**
-      * Path for the Unix Domain Socket, used to create the socket address.
-      */
-     private String unixDomainSocketPath = null;
-     public String getUnixDomainSocketPath() { return this.unixDomainSocketPath; }
-     public void setUnixDomainSocketPath(String unixDomainSocketPath) {
-         this.unixDomainSocketPath = unixDomainSocketPath;
-     }
-
-
-     /**
-      * Permissions which will be set on the Unix Domain Socket if it is created.
-      */
-     private String unixDomainSocketPathPermissions = null;
-     public String getUnixDomainSocketPathPermissions() { return this.unixDomainSocketPathPermissions; }
-     public void setUnixDomainSocketPathPermissions(String unixDomainSocketPathPermissions) {
-         this.unixDomainSocketPathPermissions = unixDomainSocketPathPermissions;
-     }
-
-
-    // --------------------------------------------------------- Public Methods
-
-    /**
-     * Obtain the number of kept alive sockets.
-     *
-     * @return The number of open sockets currently managed by the Poller
-     */
-    public int getKeepAliveCount() {
-        if (poller == null) {
-            return 0;
-        }
-
-        return poller.getConnectionCount();
-    }
-
-
-    /**
-     * Obtain the number of sendfile sockets.
-     *
-     * @return The number of sockets currently managed by the Sendfile poller.
-     */
-    public int getSendfileCount() {
-        if (sendfile == null) {
-            return 0;
-        }
-
-        return sendfile.getSendfileCount();
-    }
-
-
-    @Override
-    public String getId() {
-        if (getUnixDomainSocketPath() != null) {
-            return getUnixDomainSocketPath();
-        } else {
-            return null;
-        }
-    }
-
-
-    // ----------------------------------------------- Public Lifecycle Methods
-
-
-    /**
-     * Initialize the endpoint.
-     */
-    @Override
-    public void bind() throws Exception {
-
-        int family;
-        String hostname = null;
-
-        // Create the root APR memory pool
-        try {
-            rootPool = Pool.create(0);
-        } catch (UnsatisfiedLinkError e) {
-            throw new Exception(sm.getString("endpoint.init.notavail"));
-        }
-
-        // Create the pool for the server socket
-        serverSockPool = Pool.create(rootPool);
-
-        // Create the APR address that will be bound
-        if (getUnixDomainSocketPath() != null) {
-            if (Library.APR_HAVE_UNIX) {
-                hostname = getUnixDomainSocketPath();
-                family = Socket.APR_UNIX;
-            }
-            else {
-                throw new Exception(sm.getString("endpoint.init.unixnotavail"));
-            }
-        }
-        else {
-
-            if (getAddress() != null) {
-                hostname = getAddress().getHostAddress();
-            }
-            family = Socket.APR_UNSPEC;
-        }
-
-        long sockAddress = Address.info(hostname, family, getPortWithOffset(), 0, rootPool);
-
-        // Create the APR server socket
-        if (family == Socket.APR_UNIX) {
-            serverSock = Socket.create(family, Socket.SOCK_STREAM, 0, rootPool);
-        }
-        else {
-            int saFamily = Address.getInfo(sockAddress).family;
-            serverSock = Socket.create(saFamily,
-                Socket.SOCK_STREAM,
-                Socket.APR_PROTO_TCP, rootPool);
-            if (OS.IS_UNIX) {
-                Socket.optSet(serverSock, Socket.APR_SO_REUSEADDR, 1);
-            }
-            if (Library.APR_HAVE_IPV6 && saFamily == Socket.APR_INET6) {
-                if (getIpv6v6only()) {
-                    Socket.optSet(serverSock, Socket.APR_IPV6_V6ONLY, 1);
-                } else {
-                    Socket.optSet(serverSock, Socket.APR_IPV6_V6ONLY, 0);
-                }
-            }
-            // Deal with the firewalls that tend to drop the inactive sockets
-            Socket.optSet(serverSock, Socket.APR_SO_KEEPALIVE, 1);
-        }
-
-        // Bind the server socket
-        int ret = Socket.bind(serverSock, sockAddress);
-        if (ret != 0) {
-            throw new Exception(sm.getString("endpoint.init.bind", "" + ret, Error.strerror(ret)));
-        }
-
-        // Start listening on the server socket
-        ret = Socket.listen(serverSock, getAcceptCount());
-        if (ret != 0) {
-            throw new Exception(sm.getString("endpoint.init.listen", "" + ret, Error.strerror(ret)));
-        }
-
-        if (family == Socket.APR_UNIX) {
-            if (getUnixDomainSocketPathPermissions() != null) {
-                FileAttribute<Set<PosixFilePermission>> attrs =
-                         PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(
-                                 getUnixDomainSocketPathPermissions()));
-                Path path = Paths.get(getUnixDomainSocketPath());
-                Files.setAttribute(path, attrs.name(), attrs.value());
-            }
-        } else {
-            if (OS.IS_WIN32 || OS.IS_WIN64) {
-                // On Windows set the reuseaddr flag after the bind/listen
-                Socket.optSet(serverSock, Socket.APR_SO_REUSEADDR, 1);
-            }
-        }
-
-        // Enable Sendfile by default if it has not been configured but usage on
-        // systems which don't support it cause major problems
-        if (!useSendFileSet) {
-            setUseSendfileInternal(Library.APR_HAS_SENDFILE);
-        } else if (getUseSendfile() && !Library.APR_HAS_SENDFILE) {
-            setUseSendfileInternal(false);
-        }
-
-        // Delay accepting of new connections until data is available
-        // Only Linux kernels 2.4 + have that implemented
-        // on other platforms this call is noop and will return APR_ENOTIMPL.
-        if (deferAccept) {
-            if (Socket.optSet(serverSock, Socket.APR_TCP_DEFER_ACCEPT, 1) == Status.APR_ENOTIMPL) {
-                deferAccept = false;
-            }
-        }
-
-        // Initialize SSL if needed
-        if (isSSLEnabled()) {
-            for (SSLHostConfig sslHostConfig : sslHostConfigs.values()) {
-                createSSLContext(sslHostConfig);
-            }
-            SSLHostConfig defaultSSLHostConfig = sslHostConfigs.get(getDefaultSSLHostConfigName());
-            if (defaultSSLHostConfig == null) {
-                throw new IllegalArgumentException(sm.getString("endpoint.noSslHostConfig",
-                        getDefaultSSLHostConfigName(), getName()));
-            }
-            Long defaultSSLContext = defaultSSLHostConfig.getOpenSslContext();
-            sslContext = defaultSSLContext.longValue();
-            SSLContext.registerDefault(defaultSSLContext, this);
-
-            // For now, sendfile is not supported with SSL
-            if (getUseSendfile()) {
-                setUseSendfileInternal(false);
-                if (useSendFileSet) {
-                    log.warn(sm.getString("endpoint.apr.noSendfileWithSSL"));
-                }
-            }
-        }
-    }
-
-
-
-    @Override
-    protected void createSSLContext(SSLHostConfig sslHostConfig) throws Exception {
-        OpenSSLContext sslContext = null;
-        Set<SSLHostConfigCertificate> certificates = sslHostConfig.getCertificates(true);
-        for (SSLHostConfigCertificate certificate : certificates) {
-            if (sslContext == null) {
-                SSLUtil sslUtil = new OpenSSLUtil(certificate);
-                sslHostConfig.setEnabledProtocols(sslUtil.getEnabledProtocols());
-                sslHostConfig.setEnabledCiphers(sslUtil.getEnabledCiphers());
-
-                try {
-                    sslContext = (OpenSSLContext) sslUtil.createSSLContext(negotiableProtocols);
-                } catch (Exception e) {
-                    throw new IllegalArgumentException(e.getMessage(), e);
-                }
-            } else {
-                SSLUtil sslUtil = new OpenSSLUtil(certificate);
-                KeyManager[] kms = sslUtil.getKeyManagers();
-                certificate.setCertificateKeyManager(OpenSSLUtil.chooseKeyManager(kms));
-                sslContext.addCertificate(certificate);
-            }
-
-            certificate.setSslContext(sslContext);
-        }
-
-        if (certificates.size() > 2) {
-            // TODO: Can this limitation be removed?
-            throw new Exception(sm.getString("endpoint.apr.tooManyCertFiles"));
-        }
-    }
-
-
-    @Override
-    public long getSslContext(String sniHostName) {
-        SSLHostConfig sslHostConfig = getSSLHostConfig(sniHostName);
-        Long ctx = sslHostConfig.getOpenSslContext();
-        if (ctx != null) {
-            return ctx.longValue();
-        }
-        // Default
-        return 0;
-    }
-
-
-    /**
-     * Start the APR endpoint, creating acceptor, poller and sendfile threads.
-     */
-    @Override
-    public void startInternal() throws Exception {
-
-        if (!running) {
-            running = true;
-            paused = false;
-
-            if (socketProperties.getProcessorCache() != 0) {
-                processorCache = new SynchronizedStack<>(SynchronizedStack.DEFAULT_SIZE,
-                        socketProperties.getProcessorCache());
-            }
-
-            // Create worker collection
-            if (getExecutor() == null) {
-                createExecutor();
-            }
-
-            initializeConnectionLatch();
-
-            // Start poller thread
-            poller = new Poller();
-            poller.init();
-            poller.start();
-
-            // Start sendfile thread
-            if (getUseSendfile()) {
-                sendfile = new Sendfile();
-                sendfile.init();
-                sendfile.start();
-            }
-
-            startAcceptorThread();
-        }
-    }
-
-
-    /**
-     * Stop the endpoint. This will cause all processing threads to stop.
-     */
-    @Override
-    public void stopInternal() {
-        if (!paused) {
-            pause();
-        }
-        if (running) {
-            running = false;
-            acceptor.stop(10);
-            poller.stop();
-            for (SocketWrapperBase<Long> socketWrapper : connections.values()) {
-                socketWrapper.close();
-            }
-            if (acceptor.getState() != AcceptorState.ENDED && !getBindOnInit()) {
-                log.warn(sm.getString("endpoint.warn.unlockAcceptorFailed", acceptor.getThreadName()));
-                // If the Acceptor is still running force
-                // the hard socket close.
-                if (serverSock != 0) {
-                    Socket.shutdown(serverSock, Socket.APR_SHUTDOWN_READ);
-                    serverSock = 0;
-                }
-            }
-            // Close any sockets not in the poller performing blocking
-            // read/writes. Need to do this before destroying the poller since
-            // that will also destroy the root pool for these sockets.
-            for (Long s : connections.keySet()) {
-                Socket.shutdown(s.longValue(), Socket.APR_SHUTDOWN_READWRITE);
-            }
-            try {
-                poller.destroy();
-            } catch (Exception e) {
-                // Ignore
-            }
-            poller = null;
-            connections.clear();
-            if (getUseSendfile()) {
-                try {
-                    sendfile.stop();
-                    sendfile.destroy();
-                } catch (Exception e) {
-                    // Ignore
-                }
-                sendfile = null;
-            }
-            if (processorCache != null) {
-                processorCache.clear();
-                processorCache = null;
-            }
-        }
-        shutdownExecutor();
-    }
-
-
-    /**
-     * Deallocate APR memory pools, and close server socket.
-     */
-    @Override
-    public void unbind() throws Exception {
-        if (running) {
-            stop();
-        }
-
-        // Destroy pool if it was initialised
-        if (serverSockPool != 0) {
-            Pool.destroy(serverSockPool);
-            serverSockPool = 0;
-        }
-
-        doCloseServerSocket();
-        destroySsl();
-
-        // Close all APR memory pools and resources if initialised
-        if (rootPool != 0) {
-            Pool.destroy(rootPool);
-            rootPool = 0;
-        }
-
-        getHandler().recycle();
-    }
-
-
-    @Override
-    protected void doCloseServerSocket() {
-        // Close server socket if it was initialised
-        if (serverSock != 0) {
-            Socket.close(serverSock);
-            serverSock = 0;
-        }
-    }
-
-
-    // ------------------------------------------------------ Protected Methods
-
-    /**
-     * Process the specified connection.
-     * @param socketWrapper The socket wrapper
-     * @return <code>true</code> if the socket was correctly configured
-     *  and processing may continue, <code>false</code> if the socket needs to be
-     *  close immediately
-     */
-    protected boolean setSocketOptions(SocketWrapperBase<Long> socketWrapper) {
-        long socket = socketWrapper.getSocket().longValue();
-        // Process the connection
-        int step = 1;
-        try {
-
-            // 1: Set socket options: timeout, linger, etc
-            if (socketProperties.getSoLingerOn() && socketProperties.getSoLingerTime() >= 0) {
-                Socket.optSet(socket, Socket.APR_SO_LINGER, socketProperties.getSoLingerTime());
-            }
-            if (socketProperties.getTcpNoDelay()) {
-                Socket.optSet(socket, Socket.APR_TCP_NODELAY, (socketProperties.getTcpNoDelay() ? 1 : 0));
-            }
-            Socket.timeoutSet(socket, socketProperties.getSoTimeout() * 1000);
-
-            // 2: SSL handshake
-            step = 2;
-            if (sslContext != 0) {
-                SSLSocket.attach(sslContext, socket);
-                if (SSLSocket.handshake(socket) != 0) {
-                    if (log.isDebugEnabled()) {
-                        log.debug(sm.getString("endpoint.err.handshake") + ": " + SSL.getLastError());
-                    }
-                    return false;
-                }
-
-                if (negotiableProtocols.size() > 0) {
-                    byte[] negotiated = new byte[256];
-                    int len = SSLSocket.getALPN(socket, negotiated);
-                    String negotiatedProtocol =
-                            new String(negotiated, 0, len, StandardCharsets.UTF_8);
-                    if (negotiatedProtocol.length() > 0) {
-                        socketWrapper.setNegotiatedProtocol(negotiatedProtocol);
-                        if (log.isDebugEnabled()) {
-                            log.debug(sm.getString("endpoint.alpn.negotiated", negotiatedProtocol));
-                        }
-                    }
-                }
-            }
-        } catch (Throwable t) {
-            ExceptionUtils.handleThrowable(t);
-            if (log.isDebugEnabled()) {
-                if (step == 2) {
-                    log.debug(sm.getString("endpoint.err.handshake"), t);
-                } else {
-                    log.debug(sm.getString("endpoint.err.unexpected"), t);
-                }
-            }
-            // Tell to close the socket
-            return false;
-        }
-        return true;
-    }
-
-
-    /**
-     * Allocate a new poller of the specified size.
-     * @param size The size
-     * @param pool The pool from which the poller will be allocated
-     * @param timeout The timeout
-     * @return the poller pointer
-     */
-    protected long allocatePoller(int size, long pool, int timeout) {
-        try {
-            return Poll.create(size, pool, 0, timeout * 1000);
-        } catch (Error e) {
-            if (Status.APR_STATUS_IS_EINVAL(e.getError())) {
-                log.info(sm.getString("endpoint.poll.limitedpollsize", "" + size));
-                return 0;
-            } else {
-                log.error(sm.getString("endpoint.poll.initfail"), e);
-                return -1;
-            }
-        }
-    }
-
-    /**
-     * Process given socket. This is called when the socket has been
-     * accepted.
-     * @param socket The socket
-     * @return <code>true</code> if the socket was correctly configured
-     *  and processing may continue, <code>false</code> if the socket needs to be
-     *  close immediately
-     */
-    @Override
-    protected boolean setSocketOptions(Long socket) {
-        try {
-            if (log.isDebugEnabled()) {
-                log.debug(sm.getString("endpoint.debug.socket", socket));
-            }
-            AprSocketWrapper wrapper = new AprSocketWrapper(socket, this);
-            connections.put(socket, wrapper);
-            wrapper.setKeepAliveLeft(getMaxKeepAliveRequests());
-            wrapper.setReadTimeout(getConnectionTimeout());
-            wrapper.setWriteTimeout(getConnectionTimeout());
-            getExecutor().execute(new SocketWithOptionsProcessor(wrapper));
-            return true;
-        } catch (RejectedExecutionException x) {
-            log.warn(sm.getString("endpoint.rejectedExecution", socket), x);
-        } catch (Throwable t) {
-            ExceptionUtils.handleThrowable(t);
-            // This means we got an OOM or similar creating a thread, or that
-            // the pool and its queue are full
-            log.error(sm.getString("endpoint.process.fail"), t);
-        }
-        return false;
-    }
-
-
-    @Override
-    protected Long serverSocketAccept() throws Exception {
-        long socket = Socket.accept(serverSock);
-        if (log.isDebugEnabled()) {
-            long sa = Address.get(Socket.APR_REMOTE, socket);
-            Sockaddr addr = Address.getInfo(sa);
-            log.debug(sm.getString("endpoint.apr.remoteport",
-                    Long.valueOf(socket),
-                    Long.valueOf(addr.port)));
-        }
-        return Long.valueOf(socket);
-    }
-
-
-    /**
-     * Process the given socket. Typically keep alive or upgraded protocol.
-     *
-     * @param socket    The socket to process
-     * @param event     The event to process
-     *
-     * @return <code>true</code> if the processing completed normally otherwise
-     *         <code>false</code> which indicates an error occurred and that the
-     *         socket should be closed
-     */
-    protected boolean processSocket(long socket, SocketEvent event) {
-        SocketWrapperBase<Long> socketWrapper = connections.get(Long.valueOf(socket));
-        if (socketWrapper == null) {
-            // Socket probably closed from another thread. Triggering another
-            // close in case won't cause an issue.
-            return false;
-        }
-        if (event == SocketEvent.OPEN_READ && socketWrapper.readOperation != null) {
-            return socketWrapper.readOperation.process();
-        } else if (event == SocketEvent.OPEN_WRITE && socketWrapper.writeOperation != null) {
-            return socketWrapper.writeOperation.process();
-        } else {
-            return processSocket(socketWrapper, event, true);
-        }
-    }
-
-
-    @Override
-    protected SocketProcessorBase<Long> createSocketProcessor(
-            SocketWrapperBase<Long> socketWrapper, SocketEvent event) {
-        return new SocketProcessor(socketWrapper, event);
-    }
-
-
-    private void closeSocketInternal(long socket) {
-        closeSocket(Long.valueOf(socket));
-    }
-
-    @Override
-    protected void destroySocket(Long socket) {
-        countDownConnection();
-        destroySocketInternal(socket.longValue());
-    }
-
-    private void destroySocketInternal(long socket) {
-        if (log.isDebugEnabled()) {
-            String msg = sm.getString("endpoint.debug.destroySocket", Long.valueOf(socket));
-            if (log.isTraceEnabled()) {
-                log.trace(msg, new Exception());
-            } else {
-                log.debug(msg);
-            }
-        }
-        // Be VERY careful if you call this method directly. If it is called
-        // twice for the same socket the JVM will core. Currently this is only
-        // called from Poller.closePollset() to ensure kept alive connections
-        // are closed when calling stop() followed by start().
-        if (socket != 0) {
-            Socket.destroy(socket);
-        }
-    }
-
-    @Override
-    protected Log getLog() {
-        return log;
-    }
-
-    // -------------------------------------------------- SocketInfo Inner Class
-
-    public static class SocketInfo {
-        public long socket;
-        public long timeout;
-        public int flags;
-        public boolean read() {
-            return (flags & Poll.APR_POLLIN) == Poll.APR_POLLIN;
-        }
-        public boolean write() {
-            return (flags & Poll.APR_POLLOUT) == Poll.APR_POLLOUT;
-        }
-        public static int merge(int flag1, int flag2) {
-            return ((flag1 & Poll.APR_POLLIN) | (flag2 & Poll.APR_POLLIN))
-                | ((flag1 & Poll.APR_POLLOUT) | (flag2 & Poll.APR_POLLOUT));
-        }
-        @Override
-        public String toString() {
-            StringBuilder sb = new StringBuilder();
-            sb.append("Socket: [");
-            sb.append(socket);
-            sb.append("], timeout: [");
-            sb.append(timeout);
-            sb.append("], flags: [");
-            sb.append(flags);
-            return sb.toString();
-        }
-    }
-
-
-    // ---------------------------------------------- SocketTimeouts Inner Class
-
-    public static class SocketTimeouts {
-        protected int size;
-
-        protected long[] sockets;
-        protected long[] timeouts;
-        protected int pos = 0;
-
-        public SocketTimeouts(int size) {
-            this.size = 0;
-            sockets = new long[size];
-            timeouts = new long[size];
-        }
-
-        public void add(long socket, long timeout) {
-            sockets[size] = socket;
-            timeouts[size] = timeout;
-            size++;
-        }
-
-        /**
-         * Removes the specified socket from the poller.
-         *
-         * @param socket The socket to remove
-         *
-         * @return The configured timeout for the socket or zero if the socket
-         *         was not in the list of socket timeouts
-         */
-        public long remove(long socket) {
-            long result = 0;
-            for (int i = 0; i < size; i++) {
-                if (sockets[i] == socket) {
-                    result = timeouts[i];
-                    sockets[i] = sockets[size - 1];
-                    timeouts[i] = timeouts[size - 1];
-                    size--;
-                    break;
-                }
-            }
-            return result;
-        }
-
-        public long check(long date) {
-            while (pos < size) {
-                if (date >= timeouts[pos]) {
-                    long result = sockets[pos];
-                    sockets[pos] = sockets[size - 1];
-                    timeouts[pos] = timeouts[size - 1];
-                    size--;
-                    return result;
-                }
-                pos++;
-            }
-            pos = 0;
-            return 0;
-        }
-
-    }
-
-
-    // -------------------------------------------------- SocketList Inner Class
-
-    public static class SocketList {
-        protected volatile int size;
-        protected int pos;
-
-        protected long[] sockets;
-        protected long[] timeouts;
-        protected int[] flags;
-
-        protected SocketInfo info = new SocketInfo();
-
-        public SocketList(int size) {
-            this.size = 0;
-            pos = 0;
-            sockets = new long[size];
-            timeouts = new long[size];
-            flags = new int[size];
-        }
-
-        public int size() {
-            return this.size;
-        }
-
-        public SocketInfo get() {
-            if (pos == size) {
-                return null;
-            } else {
-                info.socket = sockets[pos];
-                info.timeout = timeouts[pos];
-                info.flags = flags[pos];
-                pos++;
-                return info;
-            }
-        }
-
-        public void clear() {
-            size = 0;
-            pos = 0;
-        }
-
-        public boolean add(long socket, long timeout, int flag) {
-            if (size == sockets.length) {
-                return false;
-            } else {
-                for (int i = 0; i < size; i++) {
-                    if (sockets[i] == socket) {
-                        flags[i] = SocketInfo.merge(flags[i], flag);
-                        return true;
-                    }
-                }
-                sockets[size] = socket;
-                timeouts[size] = timeout;
-                flags[size] = flag;
-                size++;
-                return true;
-            }
-        }
-
-        public boolean remove(long socket) {
-            for (int i = 0; i < size; i++) {
-                if (sockets[i] == socket) {
-                    sockets[i] = sockets[size - 1];
-                    timeouts[i] = timeouts[size - 1];
-                    flags[size] = flags[size -1];
-                    size--;
-                    return true;
-                }
-            }
-            return false;
-        }
-
-        public void duplicate(SocketList copy) {
-            copy.size = size;
-            copy.pos = pos;
-            System.arraycopy(sockets, 0, copy.sockets, 0, size);
-            System.arraycopy(timeouts, 0, copy.timeouts, 0, size);
-            System.arraycopy(flags, 0, copy.flags, 0, size);
-        }
-
-    }
-
-    // ------------------------------------------------------ Poller Inner Class
-
-    public class Poller implements Runnable {
-
-        /**
-         * Pointer to the poller.
-         */
-        private long aprPoller;
-
-        /**
-         * Actual poller size.
-         */
-        private int pollerSize = 0;
-
-        /**
-         * Root pool.
-         */
-        private long pool = 0;
-
-        /**
-         * Socket descriptors.
-         */
-        private long[] desc;
-
-        /**
-         * List of sockets to be added to the poller.
-         */
-        private SocketList addList = null;  // Modifications guarded by this
-
-
-        /**
-         * List of sockets to be closed.
-         */
-        private SocketList closeList = null; // Modifications guarded by this
-
-
-        /**
-         * Structure used for storing timeouts.
-         */
-        private SocketTimeouts timeouts = null;
-
-
-        /**
-         * Last run of maintain. Maintain will run approximately once every one
-         * second (may be slightly longer between runs).
-         */
-        private long lastMaintain = System.currentTimeMillis();
-
-
-        /**
-         * The number of connections currently inside this Poller. The correct
-         * operation of the Poller depends on this figure being correct. If it
-         * is not, it is possible that the Poller will enter a wait loop where
-         * it waits for the next connection to be added to the Poller before it
-         * calls poll when it should still be polling existing connections.
-         * Although not necessary at the time of writing this comment, it has
-         * been implemented as an AtomicInteger to ensure that it remains
-         * thread-safe.
-         */
-        private AtomicInteger connectionCount = new AtomicInteger(0);
-        public int getConnectionCount() { return connectionCount.get(); }
-
-        private volatile Thread pollerThread;
-        private volatile boolean pollerRunning = true;
-
-        /**
-         * Create the poller.
-         */
-        protected synchronized void init() {
-
-            pool = Pool.create(serverSockPool);
-            pollerSize = getMaxConnections();
-            timeouts = new SocketTimeouts(pollerSize);
-
-            // At the moment, setting the timeout is useless, but it could get
-            // used again as the normal poller could be faster using maintain.
-            // It might not be worth bothering though.
-            aprPoller = allocatePoller(pollerSize, pool, -1);
-
-            /*
-             * x2 - One descriptor for the socket, one for the event(s).
-             * x2 - Some APR implementations return multiple events for the
-             *      same socket as different entries. Each socket is registered
-             *      for a maximum of two events (read and write) at any one
-             *      time.
-             *
-             * Therefore size is poller size *4.
-             */
-            desc = new long[pollerSize * 4];
-            connectionCount.set(0);
-            addList = new SocketList(pollerSize);
-            closeList = new SocketList(pollerSize);
-        }
-
-
-        protected void start() {
-            pollerThread = new Thread(poller, getName() + "-Poller");
-            pollerThread.setPriority(threadPriority);
-            pollerThread.setDaemon(true);
-            pollerThread.start();
-        }
-
-
-        /*
-         * This method is synchronized so that it is not possible for a socket
-         * to be added to the Poller's addList once this method has completed.
-         */
-        protected synchronized void stop() {
-            pollerRunning = false;
-            // In case the poller thread is in the idle wait
-            this.notify();
-        }
-
-
-        /**
-         * Destroy the poller.
-         */
-        protected synchronized void destroy() {
-            // Wait for the poller thread to exit, otherwise parallel
-            // destruction of sockets which are still in the poller can cause
-            // problems.
-            int loops = 50;
-            while (loops > 0 && pollerThread.isAlive()) {
-                try {
-                    this.wait(pollTime / 1000);
-                } catch (InterruptedException e) {
-                    // Ignore
-                }
-                loops--;
-            }
-            if (pollerThread.isAlive()) {
-                log.warn(sm.getString("endpoint.pollerThreadStop"));
-            }
-            // Close all sockets in the close queue
-            SocketInfo info = closeList.get();
-            while (info != null) {
-                // Make sure we aren't trying add the socket as well as close it
-                addList.remove(info.socket);
-                // Make sure the socket isn't in the poller before we close it
-                removeFromPoller(info.socket);
-                // Poller isn't running at this point so use destroySocket()
-                // directly
-                closeSocketInternal(info.socket);
-                destroySocketInternal(info.socket);
-                info = closeList.get();
-            }
-            closeList.clear();
-            // Close all sockets in the add queue
-            info = addList.get();
-            while (info != null) {
-                // Make sure the socket isn't in the poller before we close it
-                removeFromPoller(info.socket);
-                // Poller isn't running at this point so use destroySocket()
-                // directly
-                closeSocketInternal(info.socket);
-                destroySocketInternal(info.socket);
-                info = addList.get();
-            }
-            addList.clear();
-            // Close all sockets still in the poller
-            int rv = Poll.pollset(aprPoller, desc);
-            if (rv > 0) {
-                for (int n = 0; n < rv; n++) {
-                    closeSocketInternal(desc[n*2+1]);
-                    destroySocketInternal(desc[n*2+1]);
-                }
-            }
-            Pool.destroy(pool);
-            connectionCount.set(0);
-        }
-
-
-        /**
-         * Add specified socket and associated pool to the poller. The socket
-         * will be added to a temporary array, and polled first after a maximum
-         * amount of time equal to pollTime (in most cases, latency will be much
-         * lower, however). Note: If both read and write are false, the socket
-         * will only be checked for timeout; if the socket was already present
-         * in the poller, a callback event will be generated and the socket will
-         * be removed from the poller.
-         *
-         * @param socket to add to the poller
-         * @param timeout to use for this connection in milliseconds
-         * @param flags Events to poll for (Poll.APR_POLLIN and/or
-         *              Poll.APR_POLLOUT)
-         */
-        private void add(long socket, long timeout, int flags) {
-            if (log.isDebugEnabled()) {
-                String msg = sm.getString("endpoint.debug.pollerAdd",
-                        Long.valueOf(socket), Long.valueOf(timeout),
-                        Integer.valueOf(flags));
-                if (log.isTraceEnabled()) {
-                    log.trace(msg, new Exception());
-                } else {
-                    log.debug(msg);
-                }
-            }
-            if (timeout <= 0) {
-                // Always put a timeout in
-                timeout = Integer.MAX_VALUE;
-            }
-            synchronized (this) {
-                // Add socket to the list. Newly added sockets will wait
-                // at most for pollTime before being polled.
-                if (addList.add(socket, timeout, flags)) {
-                    // In case the poller thread is in the idle wait
-                    this.notify();
-                }
-            }
-        }
-
-
-        /**
-         * Add specified socket to one of the pollers. Must only be called from
-         * {@link Poller#run()}.
-         */
-        private boolean addToPoller(long socket, int events) {
-            int rv = Poll.add(aprPoller, socket, events);
-            if (rv == Status.APR_SUCCESS) {
-                connectionCount.incrementAndGet();
-                return true;
-            }
-            return false;
-        }
-
-
-        /*
-         * This is only called from the SocketWrapper to ensure that it is only
-         * called once per socket. Calling it more than once typically results
-         * in the JVM crash.
-         */
-        private synchronized void close(long socket) {
-            closeList.add(socket, 0, 0);
-            // In case the poller thread is in the idle wait
-            this.notify();
-        }
-
-
-        /**
-         * Remove specified socket from the pollers. Must only be called from
-         * {@link Poller#run()}.
-         */
-        private void removeFromPoller(long socket) {
-            if (log.isDebugEnabled()) {
-                log.debug(sm.getString("endpoint.debug.pollerRemove",
-                        Long.valueOf(socket)));
-            }
-            int rv = Poll.remove(aprPoller, socket);
-            if (rv != Status.APR_NOTFOUND) {
-                connectionCount.decrementAndGet();
-                if (log.isDebugEnabled()) {
-                    log.debug(sm.getString("endpoint.debug.pollerRemoved",
-                            Long.valueOf(socket)));
-                }
-            }
-            timeouts.remove(socket);
-        }
-
-
-        /**
-         * Timeout checks. Must only be called from {@link Poller#run()}.
-         */
-        private synchronized void maintain() {
-            long date = System.currentTimeMillis();
-            // Maintain runs at most once every 1s, although it will likely get
-            // called more
-            if ((date - lastMaintain) < 1000L) {
-                return;
-            } else {
-                lastMaintain = date;
-            }
-            long socket = timeouts.check(date);
-            while (socket != 0) {
-                if (log.isDebugEnabled()) {
-                    log.debug(sm.getString("endpoint.debug.socketTimeout",
-                            Long.valueOf(socket)));
-                }
-                SocketWrapperBase<Long> socketWrapper = connections.get(Long.valueOf(socket));
-                if (socketWrapper != null) {
-                    socketWrapper.setError(new SocketTimeoutException());
-                    if (socketWrapper.readOperation != null || socketWrapper.writeOperation != null) {
-                        if (socketWrapper.readOperation != null) {
-                            socketWrapper.readOperation.process();
-                        } else {
-                            socketWrapper.writeOperation.process();
-                        }
-                    } else {
-                        processSocket(socketWrapper, SocketEvent.ERROR, true);
-                    }
-                }
-                socket = timeouts.check(date);
-            }
-
-        }
-
-        /**
-         * Displays the list of sockets in the pollers.
-         */
-        @Override
-        public String toString() {
-            StringBuilder buf = new StringBuilder();
-            buf.append("Poller");
-            long[] res = new long[pollerSize * 2];
-            int count = Poll.pollset(aprPoller, res);
-            buf.append(" [ ");
-            for (int j = 0; j < count; j++) {
-                buf.append(desc[2*j+1]).append(' ');
-            }
-            buf.append(']');
-            return buf.toString();
-        }
-
-        /**
-         * The background thread that adds sockets to the Poller, checks the
-         * poller for triggered events and hands the associated socket off to an
-         * appropriate processor as events occur.
-         */
-        @Override
-        public void run() {
-
-            SocketList localAddList = new SocketList(getMaxConnections());
-            SocketList localCloseList = new SocketList(getMaxConnections());
-
-            // Loop until we receive a shutdown command
-            while (pollerRunning) {
-
-                // Check timeouts if the poller is empty.
-                while (pollerRunning && connectionCount.get() < 1 &&
-                        addList.size() < 1 && closeList.size() < 1) {
-                    try {
-                        if (getConnectionTimeout() > 0 && pollerRunning) {
-                            maintain();
-                        }
-                        synchronized (this) {
-                            // Make sure that no sockets have been placed in the
-                            // addList or closeList since the check above.
-                            // Without this check there could be a 10s pause
-                            // with no processing since the notify() call in
-                            // add()/close() would have no effect since it
-                            // happened before this sync block was entered
-                            if (pollerRunning && addList.size() < 1 && closeList.size() < 1) {
-                                this.wait(10000);
-                            }
-                        }
-                    } catch (InterruptedException e) {
-                        // Ignore
-                    } catch (Throwable t) {
-                        ExceptionUtils.handleThrowable(t);
-                        getLog().warn(sm.getString("endpoint.timeout.err"));
-                    }
-                }
-
-                // Don't add or poll if the poller has been stopped
-                if (!pollerRunning) {
-                    break;
-                }
-
-                try {
-                    // Duplicate the add and remove lists so that the syncs are
-                    // minimised
-                    synchronized (this) {
-                        if (closeList.size() > 0) {
-                            // Duplicate to another list, so that the syncing is
-                            // minimal
-                            closeList.duplicate(localCloseList);
-                            closeList.clear();
-                        } else {
-                            localCloseList.clear();
-                        }
-                    }
-                    synchronized (this) {
-                        if (addList.size() > 0) {
-                            // Duplicate to another list, so that the syncing is
-                            // minimal
-                            addList.duplicate(localAddList);
-                            addList.clear();
-                        } else {
-                            localAddList.clear();
-                        }
-                    }
-
-                    // Remove sockets
-                    if (localCloseList.size() > 0) {
-                        SocketInfo info = localCloseList.get();
-                        while (info != null) {
-                            localAddList.remove(info.socket);
-                            removeFromPoller(info.socket);
-                            closeSocketInternal(info.socket);
-                            destroySocketInternal(info.socket);
-                            info = localCloseList.get();
-                        }
-                    }
-
-                    // Add sockets which are waiting to the poller
-                    if (localAddList.size() > 0) {
-                        SocketInfo info = localAddList.get();
-                        while (info != null) {
-                            if (log.isDebugEnabled()) {
-                                log.debug(sm.getString(
-                                        "endpoint.debug.pollerAddDo",
-                                        Long.valueOf(info.socket)));
-                            }
-                            timeouts.remove(info.socket);
-                            AprSocketWrapper wrapper =
-                                    (AprSocketWrapper) connections.get(Long.valueOf(info.socket));
-                            if (wrapper != null) {
-                                if (info.read() || info.write()) {
-                                    wrapper.pollerFlags = wrapper.pollerFlags |
-                                            (info.read() ? Poll.APR_POLLIN : 0) |
-                                            (info.write() ? Poll.APR_POLLOUT : 0);
-                                    // A socket can only be added to the poller
-                                    // once. Adding it twice will return an error
-                                    // which will close the socket. Therefore make
-                                    // sure the socket we are about to add isn't in
-                                    // the poller.
-                                    removeFromPoller(info.socket);
-                                    if (!addToPoller(info.socket, wrapper.pollerFlags)) {
-                                        wrapper.close();
-                                    } else {
-                                        timeouts.add(info.socket,
-                                                System.currentTimeMillis() +
-                                                        info.timeout);
-                                    }
-                                } else {
-                                    // Should never happen.
-                                    wrapper.close();
-                                    getLog().warn(sm.getString(
-                                            "endpoint.apr.pollAddInvalid", info));
-                                }
-                            }
-                            info = localAddList.get();
-                        }
-                    }
-
-                    // Flag to ask to reallocate the pool
-                    boolean reset = false;
-
-                    int rv = Poll.poll(aprPoller, pollTime, desc, true);
-                    if (rv > 0) {
-                        rv = mergeDescriptors(desc, rv);
-                        connectionCount.addAndGet(-rv);
-                        for (int n = 0; n < rv; n++) {
-                            if (getLog().isDebugEnabled()) {
-                                log.debug(sm.getString(
-                                        "endpoint.debug.pollerProcess",
-                                        Long.valueOf(desc[n*2+1]),
-                                        Long.valueOf(desc[n*2])));
-                            }
-                            long timeout = timeouts.remove(desc[n*2+1]);
-                            AprSocketWrapper wrapper = (AprSocketWrapper)
-                                    connections.get(Long.valueOf(desc[n*2+1]));
-                            if (wrapper == null) {
-                                // Socket was closed in another thread while still in
-                                // the Poller but wasn't removed from the Poller before
-                                // new data arrived.
-                                continue;
-                            }
-                            wrapper.pollerFlags = wrapper.pollerFlags & ~((int) desc[n*2]);
-                            // Check for failed sockets and hand this socket off to a worker
-                            if (((desc[n*2] & Poll.APR_POLLHUP) == Poll.APR_POLLHUP)
-                                    || ((desc[n*2] & Poll.APR_POLLERR) == Poll.APR_POLLERR)
-                                    || ((desc[n*2] & Poll.APR_POLLNVAL) == Poll.APR_POLLNVAL)) {
-                                // Need to trigger error handling. Poller may return error
-                                // codes plus the flags it was waiting for or it may just
-                                // return an error code. We could handle the error here but
-                                // if we do, there will be no exception associated with the
-                                // error in application code. By signaling read/write is
-                                // possible, a read/write will be attempted, fail and that
-                                // will trigger an exception the application will see.
-                                // Check the return flags first, followed by what the socket
-                                // was registered for
-                                if ((desc[n*2] & Poll.APR_POLLIN) == Poll.APR_POLLIN) {
-                                    // Error probably occurred during a non-blocking read
-                                    if (!processSocket(desc[n*2+1], SocketEvent.OPEN_READ)) {
-                                        // Close socket and clear pool
-                                        wrapper.close();
-                                    }
-                                } else if ((desc[n*2] & Poll.APR_POLLOUT) == Poll.APR_POLLOUT) {
-                                    // Error probably occurred during a non-blocking write
-                                    if (!processSocket(desc[n*2+1], SocketEvent.OPEN_WRITE)) {
-                                        // Close socket and clear pool
-                                        wrapper.close();
-                                    }
-                                } else if ((wrapper.pollerFlags & Poll.APR_POLLIN) == Poll.APR_POLLIN) {
-                                    // Can't tell what was happening when the error occurred but the
-                                    // socket is registered for non-blocking read so use that
-                                    if (!processSocket(desc[n*2+1], SocketEvent.OPEN_READ)) {
-                                        // Close socket and clear pool
-                                        wrapper.close();
-                                    }
-                                } else if ((wrapper.pollerFlags & Poll.APR_POLLOUT) == Poll.APR_POLLOUT) {
-                                    // Can't tell what was happening when the error occurred but the
-                                    // socket is registered for non-blocking write so use that
-                                    if (!processSocket(desc[n*2+1], SocketEvent.OPEN_WRITE)) {
-                                        // Close socket and clear pool
-                                        wrapper.close();
-                                    }
-                                } else {
-                                    // Close socket and clear pool
-                                    wrapper.close();
-                                }
-                            } else if (((desc[n*2] & Poll.APR_POLLIN) == Poll.APR_POLLIN)
-                                    || ((desc[n*2] & Poll.APR_POLLOUT) == Poll.APR_POLLOUT)) {
-                                boolean error = false;
-                                if (((desc[n*2] & Poll.APR_POLLIN) == Poll.APR_POLLIN) &&
-                                        !processSocket(desc[n*2+1], SocketEvent.OPEN_READ)) {
-                                    error = true;
-                                    // Close socket and clear pool
-                                    wrapper.close();
-                                }
-                                if (!error &&
-                                        ((desc[n*2] & Poll.APR_POLLOUT) == Poll.APR_POLLOUT) &&
-                                        !processSocket(desc[n*2+1], SocketEvent.OPEN_WRITE)) {
-                                    // Close socket and clear pool
-                                    error = true;
-                                    wrapper.close();
-                                }
-                                if (!error && wrapper.pollerFlags != 0) {
-                                    // If socket was registered for multiple events but
-                                    // only some of the occurred, re-register for the
-                                    // remaining events.
-                                    // timeout is the value of System.currentTimeMillis() that
-                                    // was set as the point that the socket will timeout. When
-                                    // adding to the poller, the timeout from now in
-                                    // milliseconds is required.
-                                    // So first, subtract the current timestamp
-                                    if (timeout > 0) {
-                                        timeout = timeout - System.currentTimeMillis();
-                                    }
-                                    // If the socket should have already expired by now,
-                                    // re-add it with a very short timeout
-                                    if (timeout <= 0) {
-                                        timeout = 1;
-                                    }
-                                    // Should be impossible but just in case since timeout will
-                                    // be cast to an int.
-                                    if (timeout > Integer.MAX_VALUE) {
-                                        timeout = Integer.MAX_VALUE;
-                                    }
-                                    add(desc[n*2+1], (int) timeout, wrapper.pollerFlags);
-                                }
-                            } else {
-                                // Unknown event
-                                getLog().warn(sm.getString(
-                                        "endpoint.apr.pollUnknownEvent",
-                                        Long.valueOf(desc[n*2])));
-                                // Close socket and clear pool
-                                wrapper.close();
-                            }
-                        }
-                    } else if (rv < 0) {
-                        int errn = -rv;
-                        // Any non timeup or interrupted error is critical
-                        if ((errn != Status.TIMEUP) && (errn != Status.EINTR)) {
-                            if (errn >  Status.APR_OS_START_USERERR) {
-                                errn -=  Status.APR_OS_START_USERERR;
-                            }
-                            getLog().error(sm.getString(
-                                    "endpoint.apr.pollError",
-                                    Integer.valueOf(errn),
-                                    Error.strerror(errn)));
-                            // Destroy and reallocate the poller
-                            reset = true;
-                        }
-                    }
-
-                    if (reset && pollerRunning) {
-                        // Reallocate the current poller
-                        int count = Poll.pollset(aprPoller, desc);
-                        long newPoller = allocatePoller(pollerSize, pool, -1);
-                        // Don't restore connections for now, since I have not tested it
-                        connectionCount.addAndGet(-count);
-                        Poll.destroy(aprPoller);
-                        aprPoller = newPoller;
-                    }
-                } catch (Throwable t) {
-                    ExceptionUtils.handleThrowable(t);
-                    getLog().warn(sm.getString("endpoint.poll.error"), t);
-                }
-                try {
-                    // Process socket timeouts
-                    if (getConnectionTimeout() > 0 && pollerRunning) {
-                        // This works and uses only one timeout mechanism for everything, but the
-                        // non event poller might be a bit faster by using the old maintain.
-                        maintain();
-                    }
-                } catch (Throwable t) {
-                    ExceptionUtils.handleThrowable(t);
-                    getLog().warn(sm.getString("endpoint.timeout.err"), t);
-                }
-            }
-
-            synchronized (this) {
-                this.notifyAll();
-            }
-        }
-
-
-        private int mergeDescriptors(long[] desc, int startCount) {
-            /*
-             * https://bz.apache.org/bugzilla/show_bug.cgi?id=57653#c6 suggests
-             * this merging is only necessary on OSX and BSD.
-             *
-             * https://bz.apache.org/bugzilla/show_bug.cgi?id=56313 suggests the
-             * same, or a similar, issue is happening on Windows.
-             * Notes: Only the first startCount * 2 elements of the array
-             *        are populated.
-             *        The array is event, socket, event, socket etc.
-             */
-            Map<Long,Long> merged = new HashMap<>(startCount);
-            for (int n = 0; n < startCount; n++) {
-                Long newValue = merged.merge(Long.valueOf(desc[2*n+1]), Long.valueOf(desc[2*n]),
-                        (v1, v2) -> Long.valueOf(v1.longValue() | v2.longValue()));
-                if (log.isDebugEnabled()) {
-                    if (newValue.longValue() != desc[2*n]) {
-                        log.debug(sm.getString("endpoint.apr.pollMergeEvents",
-                                Long.valueOf(desc[2*n+1]), Long.valueOf(desc[2*n]), newValue));
-                    }
-                }
-            }
-            int i = 0;
-            for (Map.Entry<Long,Long> entry : merged.entrySet()) {
-                desc[i++] = entry.getValue().longValue();
-                desc[i++] = entry.getKey().longValue();
-            }
-            return merged.size();
-        }
-    }
-
-
-    // ----------------------------------------------- SendfileData Inner Class
-
-    /**
-     * SendfileData class.
-     */
-    public static class SendfileData extends SendfileDataBase {
-        // File
-        protected long fd;
-        protected long fdpool;
-        // Socket and socket pool
-        protected long socket;
-
-        public SendfileData(String filename, long pos, long length) {
-            super(filename, pos, length);
-        }
-    }
-
-
-    // --------------------------------------------------- Sendfile Inner Class
-
-    public class Sendfile implements Runnable {
-
-        protected long sendfilePollset = 0;
-        protected long pool = 0;
-        protected long[] desc;
-        protected HashMap<Long, SendfileData> sendfileData;
-
-        protected int sendfileCount;
-        public int getSendfileCount() { return sendfileCount; }
-
-        protected ArrayList<SendfileData> addS;
-
-        private volatile Thread sendfileThread;
-        private volatile boolean sendfileRunning = true;
-
-        /**
-         * Create the sendfile poller.
-         */
-        protected void init() {
-            pool = Pool.create(serverSockPool);
-            int size = sendfileSize;
-            if (size <= 0) {
-                size = 16 * 1024;
-            }
-            sendfilePollset = allocatePoller(size, pool, getConnectionTimeout());
-            desc = new long[size * 2];
-            sendfileData = new HashMap<>(size);
-            addS = new ArrayList<>();
-        }
-
-        protected void start() {
-            sendfileThread = new Thread(sendfile, getName() + "-Sendfile");
-            sendfileThread.setPriority(threadPriority);
-            sendfileThread.setDaemon(true);
-            sendfileThread.start();
-        }
-
-        protected synchronized void stop() {
-            sendfileRunning = false;
-            // In case the sendfile thread is in the idle wait
-            this.notify();
-
-            // Wait for the sendfile thread to exit, otherwise parallel
-            // destruction of sockets which are still in the poller can cause
-            // problems.
-            int loops = 50;
-            while (loops > 0 && sendfileThread.isAlive()) {
-                try {
-                    this.wait(pollTime / 1000);
-                } catch (InterruptedException e) {
-                    // Ignore
-                }
-                loops--;
-            }
-            if (sendfileThread.isAlive()) {
-                log.warn(sm.getString("endpoint.sendfileThreadStop"));
-            }
-        }
-
-        /**
-         * Destroy the poller.
-         */
-        protected void destroy() {
-            // Close any socket remaining in the add queue
-            for (int i = (addS.size() - 1); i >= 0; i--) {
-                SendfileData data = addS.get(i);
-                closeSocketInternal(data.socket);
-            }
-            // Close all sockets still in the poller
-            int rv = Poll.pollset(sendfilePollset, desc);
-            if (rv > 0) {
-                for (int n = 0; n < rv; n++) {
-                    closeSocketInternal(desc[n*2+1]);
-                }
-            }
-            Pool.destroy(pool);
-            sendfileData.clear();
-        }
-
-        /**
-         * Add the sendfile data to the sendfile poller. Note that in most cases,
-         * the initial non blocking calls to sendfile will return right away, and
-         * will be handled asynchronously inside the kernel. As a result,
-         * the poller will never be used.
-         *
-         * @param data containing the reference to the data which should be sent
-         * @return true if all the data has been sent right away, and false
-         *              otherwise
-         */
-        public SendfileState add(SendfileData data) {
-            // Initialize fd from data given
-            try {
-                data.fdpool = Socket.pool(data.socket);
-                data.fd = File.open
-                    (data.fileName, File.APR_FOPEN_READ
-                     | File.APR_FOPEN_SENDFILE_ENABLED | File.APR_FOPEN_BINARY,
-                     0, data.fdpool);
-                // Set the socket to nonblocking mode
-                Socket.timeoutSet(data.socket, 0);
-                while (sendfileRunning) {
-                    long nw = Socket.sendfilen(data.socket, data.fd,
-                                               data.pos, data.length, 0);
-                    if (nw < 0) {
-                        if (!(-nw == Status.EAGAIN)) {
-                            Pool.destroy(data.fdpool);
-                            data.socket = 0;
-                            return SendfileState.ERROR;
-                        } else {
-                            // Break the loop and add the socket to poller.
-                            break;
-                        }
-                    } else {
-                        data.pos += nw;
-                        data.length -= nw;
-                        if (data.length == 0) {
-                            // Entire file has been sent
-                            Pool.destroy(data.fdpool);
-                            // Set back socket to blocking mode
-                            Socket.timeoutSet(data.socket, getConnectionTimeout() * 1000);
-                            return SendfileState.DONE;
-                        }
-                    }
-                }
-            } catch (Exception e) {
-                log.warn(sm.getString("endpoint.sendfile.error"), e);
-                return SendfileState.ERROR;
-            }
-            // Add socket to the list. Newly added sockets will wait
-            // at most for pollTime before being polled
-            synchronized (this) {
-                addS.add(data);
-                this.notify();
-            }
-            return SendfileState.PENDING;
-        }
-
-        /**
-         * Remove socket from the poller.
-         *
-         * @param data the sendfile data which should be removed
-         */
-        protected void remove(SendfileData data) {
-            int rv = Poll.remove(sendfilePollset, data.socket);
-            if (rv == Status.APR_SUCCESS) {
-                sendfileCount--;
-            }
-            sendfileData.remove(Long.valueOf(data.socket));
-        }
-
-        /**
-         * The background thread that listens for incoming TCP/IP connections
-         * and hands them off to an appropriate processor.
-         */
-        @Override
-        public void run() {
-
-            long maintainTime = 0;
-            // Loop until we receive a shutdown command
-            while (sendfileRunning) {
-
-                // Loop if endpoint is paused
-                while (sendfileRunning && paused) {
-                    try {
-                        Thread.sleep(pollTime / 1000);
-                    } catch (InterruptedException e) {
-                        // Ignore
-                    }
-                }
-                // Loop if poller is empty
-                while (sendfileRunning && sendfileCount < 1 && addS.size() < 1) {
-                    // Reset maintain time.
-                    maintainTime = 0;
-                    try {
-                        synchronized (this) {
-                            if (sendfileRunning && sendfileCount < 1 && addS.size() < 1) {
-                                this.wait();
-                            }
-                        }
-                    } catch (InterruptedException e) {
-                        // Ignore
-                    }
-                }
-
-                // Don't add or poll if the poller has been stopped
-                if (!sendfileRunning) {
-                    break;
-                }
-
-                try {
-                    // Add socket to the poller
-                    if (addS.size() > 0) {
-                        synchronized (this) {
-                            for (int i = (addS.size() - 1); i >= 0; i--) {
-                                SendfileData data = addS.get(i);
-                                int rv = Poll.add(sendfilePollset, data.socket, Poll.APR_POLLOUT);
-                                if (rv == Status.APR_SUCCESS) {
-                                    sendfileData.put(Long.valueOf(data.socket), data);
-                                    sendfileCount++;
-                                } else {
-                                    getLog().warn(sm.getString(
-                                            "endpoint.sendfile.addfail",
-                                            Integer.valueOf(rv),
-                                            Error.strerror(rv)));
-                                    // Can't do anything: close the socket right away
-                                    closeSocketInternal(data.socket);
-                                }
-                            }
-                            addS.clear();
-                        }
-                    }
-
-                    maintainTime += pollTime;
-                    // Pool for the specified interval
-                    int rv = Poll.poll(sendfilePollset, pollTime, desc, false);
-                    if (rv > 0) {
-                        for (int n = 0; n < rv; n++) {
-                            // Get the sendfile state
-                            SendfileData state =
-                                sendfileData.get(Long.valueOf(desc[n*2+1]));
-                            // Problem events
-                            if (((desc[n*2] & Poll.APR_POLLHUP) == Poll.APR_POLLHUP)
-                                    || ((desc[n*2] & Poll.APR_POLLERR) == Poll.APR_POLLERR)) {
-                                // Close socket and clear pool
-                                remove(state);
-                                // Destroy file descriptor pool, which should close the file
-                                // Close the socket, as the response would be incomplete
-                                closeSocketInternal(state.socket);
-                                continue;
-                            }
-                            // Write some data using sendfile
-                            long nw = Socket.sendfilen(state.socket, state.fd,
-                                                       state.pos,
-                                                       state.length, 0);
-                            if (nw < 0) {
-                                // Close socket and clear pool
-                                remove(state);
-                                // Close the socket, as the response would be incomplete
-                                // This will close the file too.
-                                closeSocketInternal(state.socket);
-                                continue;
-                            }
-
-                            state.pos += nw;
-                            state.length -= nw;
-                            if (state.length == 0) {
-                                remove(state);
-                                switch (state.keepAliveState) {
-                                case NONE: {
-                                    // Close the socket since this is
-                                    // the end of the not keep-alive request.
-                                    closeSocketInternal(state.socket);
-                                    break;
-                                }
-                                case PIPELINED: {
-                                    // Destroy file descriptor pool, which should close the file
-                                    Pool.destroy(state.fdpool);
-                                    Socket.timeoutSet(state.socket, getConnectionTimeout() * 1000);
-                                    // Process the pipelined request data
-                                    if (!processSocket(state.socket, SocketEvent.OPEN_READ)) {
-                                        closeSocketInternal(state.socket);
-                                    }
-                                    break;
-                                }
-                                case OPEN: {
-                                    // Destroy file descriptor pool, which should close the file
-                                    Pool.destroy(state.fdpool);
-                                    Socket.timeoutSet(state.socket, getConnectionTimeout() * 1000);
-                                    // Put the socket back in the poller for
-                                    // processing of further requests
-                                    getPoller().add(state.socket, getKeepAliveTimeout(),
-                                            Poll.APR_POLLIN);
-                                    break;
-                                }
-                                }
-                            }
-                        }
-                    } else if (rv < 0) {
-                        int errn = -rv;
-                        /* Any non timeup or interrupted error is critical */
-                        if ((errn != Status.TIMEUP) && (errn != Status.EINTR)) {
-                            if (errn >  Status.APR_OS_START_USERERR) {
-                                errn -=  Status.APR_OS_START_USERERR;
-                            }
-                            getLog().error(sm.getString(
-                                    "endpoint.apr.pollError",
-                                    Integer.valueOf(errn),
-                                    Error.strerror(errn)));
-                            // Handle poll critical failure
-                            synchronized (this) {
-                                destroy();
-                                init();
-                            }
-                            continue;
-                        }
-                    }
-                    // Call maintain for the sendfile poller
-                    if (getConnectionTimeout() > 0 &&
-                            maintainTime > 1000000L && sendfileRunning) {
-                        rv = Poll.maintain(sendfilePollset, desc, false);
-                        maintainTime = 0;
-                        if (rv > 0) {
-                            for (int n = 0; n < rv; n++) {
-                                // Get the sendfile state
-                                SendfileData state = sendfileData.get(Long.valueOf(desc[n]));
-                                // Close socket and clear pool
-                                remove(state);
-                                // Destroy file descriptor pool, which should close the file
-                                // Close the socket, as the response would be incomplete
-                                closeSocketInternal(state.socket);
-                            }
-                        }
-                    }
-                } catch (Throwable t) {
-                    ExceptionUtils.handleThrowable(t);
-                    getLog().error(sm.getString("endpoint.poll.error"), t);
-                }
-            }
-
-            synchronized (this) {
-                this.notifyAll();
-            }
-
-        }
-
-    }
-
-
-    // --------------------------------- SocketWithOptionsProcessor Inner Class
-
-    /**
-     * This class is the equivalent of the Worker, but will simply use in an
-     * external Executor thread pool. This will also set the socket options
-     * and do the handshake.
-     *
-     * This is called after an accept().
-     */
-    protected class SocketWithOptionsProcessor implements Runnable {
-
-        protected SocketWrapperBase<Long> socket = null;
-
-
-        public SocketWithOptionsProcessor(SocketWrapperBase<Long> socket) {
-            this.socket = socket;
-        }
-
-        @Override
-        public void run() {
-
-            synchronized (socket) {
-                if (!deferAccept) {
-                    if (setSocketOptions(socket)) {
-                        getPoller().add(socket.getSocket().longValue(),
-                                getConnectionTimeout(), Poll.APR_POLLIN);
-                    } else {
-                        // Close socket and pool
-                        getHandler().process(socket, SocketEvent.CONNECT_FAIL);
-                        socket.close();
-                        socket = null;
-                    }
-                } else {
-                    // Process the request from this socket
-                    if (!setSocketOptions(socket)) {
-                        // Close socket and pool
-                        getHandler().process(socket, SocketEvent.CONNECT_FAIL);
-                        socket.close();
-                        socket = null;
-                        return;
-                    }
-                    // Process the request from this socket
-                    Handler.SocketState state = getHandler().process(socket, SocketEvent.OPEN_READ);
-                    if (state == Handler.SocketState.CLOSED) {
-                        // Close socket and pool
-                        socket.close();
-                        socket = null;
-                    }
-                }
-            }
-        }
-
-    }
-
-
-    // -------------------------------------------- SocketProcessor Inner Class
-
-
-    /**
-     * This class is the equivalent of the Worker, but will simply use in an
-     * external Executor thread pool.
-     */
-    protected class SocketProcessor extends SocketProcessorBase<Long> {
-
-        public SocketProcessor(SocketWrapperBase<Long> socketWrapper, SocketEvent event) {
-            super(socketWrapper, event);
-        }
-
-        @Override
-        protected void doRun() {
-            try {
-                // Process the request from this socket
-                SocketState state = getHandler().process(socketWrapper, event);
-                if (state == Handler.SocketState.CLOSED) {
-                    // Close socket and pool
-                    socketWrapper.close();
-                }
-            } finally {
-                socketWrapper = null;
-                event = null;
-                //return to cache
-                if (running && !paused && processorCache != null) {
-                    processorCache.push(this);
-                }
-            }
-        }
-    }
-
-
-    public static class AprSocketWrapper extends SocketWrapperBase<Long> {
-
-        private static final int SSL_OUTPUT_BUFFER_SIZE = 8192;
-
-        private final ByteBuffer sslOutputBuffer;
-
-        // This field should only be used by Poller#run()
-        private int pollerFlags = 0;
-
-        /*
-         * Used if block/non-blocking is set at the socket level. The client is
-         * responsible for the thread-safe use of this field via the locks provided.
-         */
-        private volatile boolean blockingStatus = true;
-        private final Lock blockingStatusReadLock;
-        private final WriteLock blockingStatusWriteLock;
-
-        public AprSocketWrapper(Long socket, AprEndpoint endpoint) {
-            super(socket, endpoint);
-
-            ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
-            this.blockingStatusReadLock = lock.readLock();
-            this.blockingStatusWriteLock = lock.writeLock();
-
-            // TODO Make the socketWriteBuffer size configurable and align the
-            //      SSL and app buffer size settings with NIO & NIO2.
-            if (endpoint.isSSLEnabled()) {
-                sslOutputBuffer = ByteBuffer.allocateDirect(SSL_OUTPUT_BUFFER_SIZE);
-                sslOutputBuffer.position(SSL_OUTPUT_BUFFER_SIZE);
-            } else {
-                sslOutputBuffer = null;
-            }
-
-            socketBufferHandler = new SocketBufferHandler(6 * 1500, 6 * 1500, true);
-        }
-
-        public boolean getBlockingStatus() { return blockingStatus; }
-        public void setBlockingStatus(boolean blockingStatus) {
-            this.blockingStatus = blockingStatus;
-        }
-        public Lock getBlockingStatusReadLock() { return blockingStatusReadLock; }
-        public WriteLock getBlockingStatusWriteLock() {
-            return blockingStatusWriteLock;
-        }
-
-        @Override
-        public int read(boolean block, byte[] b, int off, int len) throws IOException {
-            int nRead = populateReadBuffer(b, off, len);
-            if (nRead > 0) {
-                return nRead;
-                /*
-                 * Since more bytes may have arrived since the buffer was last
-                 * filled, it is an option at this point to perform a
-                 * non-blocking read. However correctly handling the case if
-                 * that read returns end of stream adds complexity. Therefore,
-                 * at the moment, the preference is for simplicity.
-                 */
-            }
-
-            // Fill the read buffer as best we can.
-            nRead = fillReadBuffer(block);
-
-            // Fill as much of the remaining byte array as possible with the
-            // data that was just read
-            if (nRead > 0) {
-                socketBufferHandler.configureReadBufferForRead();
-                nRead = Math.min(nRead, len);
-                socketBufferHandler.getReadBuffer().get(b, off, nRead);
-            }
-            return nRead;
-        }
-
-
-        @Override
-        public int read(boolean block, ByteBuffer to) throws IOException {
-            int nRead = populateReadBuffer(to);
-            if (nRead > 0) {
-                return nRead;
-                /*
-                 * Since more bytes may have arrived since the buffer was last
-                 * filled, it is an option at this point to perform a
-                 * non-blocking read. However correctly handling the case if
-                 * that read returns end of stream adds complexity. Therefore,
-                 * at the moment, the preference is for simplicity.
-                 */
-            }
-
-            // The socket read buffer capacity is socket.appReadBufSize
-            int limit = socketBufferHandler.getReadBuffer().capacity();
-            if (to.isDirect() && to.remaining() >= limit) {
-                to.limit(to.position() + limit);
-                nRead = fillReadBuffer(block, to);
-                if (log.isDebugEnabled()) {
-                    log.debug("Socket: [" + this + "], Read direct from socket: [" + nRead + "]");
-                }
-            } else {
-                // Fill the read buffer as best we can.
-                nRead = fillReadBuffer(block);
-                if (log.isDebugEnabled()) {
-                    log.debug("Socket: [" + this + "], Read into buffer: [" + nRead + "]");
-                }
-
-                // Fill as much of the remaining byte array as possible with the
-                // data that was just read
-                if (nRead > 0) {
-                    nRead = populateReadBuffer(to);
-                }
-            }
-            return nRead;
-        }
-
-
-        private int fillReadBuffer(boolean block) throws IOException {
-            socketBufferHandler.configureReadBufferForWrite();
-            return fillReadBuffer(block, socketBufferHandler.getReadBuffer());
-        }
-
-
-        private int fillReadBuffer(boolean block, ByteBuffer to) throws IOException {
-            Lock readLock = getBlockingStatusReadLock();
-            WriteLock writeLock = getBlockingStatusWriteLock();
-
-            boolean readDone = false;
-            int result = 0;
-            readLock.lock();
-            try {
-                checkClosed();
-                if (getBlockingStatus() == block) {
-                    if (block) {
-                        Socket.timeoutSet(getSocket().longValue(), getReadTimeout() * 1000);
-                    }
-                    result = Socket.recvb(getSocket().longValue(), to, to.position(),
-                            to.remaining());
-                    readDone = true;
-                }
-            } finally {
-                readLock.unlock();
-            }
-
-            if (!readDone) {
-                writeLock.lock();
-                try {
-                    checkClosed();
-                    // Set the current settings for this socket
-                    setBlockingStatus(block);
-                    if (block) {
-                        Socket.timeoutSet(getSocket().longValue(), getReadTimeout() * 1000);
-                    } else {
-                        Socket.timeoutSet(getSocket().longValue(), 0);
-                    }
-                    // Downgrade the lock
-                    readLock.lock();
-                    try {
-                        writeLock.unlock();
-                        result = Socket.recvb(getSocket().longValue(), to, to.position(),
-                                to.remaining());
-                    } finally {
-                        readLock.unlock();
-                    }
-                } finally {
-                    // Should have been released above but may not have been on some
-                    // exception paths
-                    if (writeLock.isHeldByCurrentThread()) {
-                        writeLock.unlock();
-                    }
-                }
-            }
-
-            if (result > 0) {
-                to.position(to.position() + result);
-                return result;
-            } else if (result == 0 || -result == Status.EAGAIN) {
-                return 0;
-            } else if ((-result) == Status.ETIMEDOUT || (-result) == Status.TIMEUP) {
-                if (block) {
-                    throw new SocketTimeoutException(sm.getString("iib.readtimeout"));
-                } else {
-                    // Attempting to read from the socket when the poller
-                    // has not signalled that there is data to read appears
-                    // to behave like a blocking read with a short timeout
-                    // on OSX rather than like a non-blocking read. If no
-                    // data is read, treat the resulting timeout like a
-                    // non-blocking read that returned no data.
-                    return 0;
-                }
-            } else if (-result == Status.APR_EOF) {
-                return -1;
-            } else if ((OS.IS_WIN32 || OS.IS_WIN64) &&
-                    (-result == Status.APR_OS_START_SYSERR + 10053)) {
-                // 10053 on Windows is connection aborted
-                throw new EOFException(sm.getString("socket.apr.clientAbort"));
-            } else {
-                throw new IOException(sm.getString("socket.apr.read.error",
-                        Integer.valueOf(-result), getSocket(), this));
-            }
-        }
-
-
-        @Override
-        public boolean isReadyForRead() throws IOException {
-            socketBufferHandler.configureReadBufferForRead();
-
-            if (socketBufferHandler.getReadBuffer().remaining() > 0) {
-                return true;
-            }
-
-            int read = fillReadBuffer(false);
-
-            boolean isReady = socketBufferHandler.getReadBuffer().position() > 0 || read == -1;
-            return isReady;
-        }
-
-
-        private void checkClosed() throws IOException {
-            if (isClosed()) {
-                throw new IOException(sm.getString("socket.apr.closed", getSocket()));
-            }
-        }
-
-
-        @Override
-        protected void doClose() {
-            if (log.isDebugEnabled()) {
-                log.debug("Calling [" + getEndpoint() + "].closeSocket([" + this + "])");
-            }
-            getEndpoint().connections.remove(getSocket());
-            socketBufferHandler.free();
-            socketBufferHandler = SocketBufferHandler.EMPTY;
-            nonBlockingWriteBuffer.clear();
-            if (sslOutputBuffer != null) {
-                ByteBufferUtils.cleanDirectBuffer(sslOutputBuffer);
-            }
-            ((AprEndpoint) getEndpoint()).getPoller().close(getSocket().longValue());
-        }
-
-
-        @Override
-        protected void doWrite(boolean block, ByteBuffer from) throws IOException {
-            Lock readLock = getBlockingStatusReadLock();
-            WriteLock writeLock = getBlockingStatusWriteLock();
-
-            readLock.lock();
-            try {
-                checkClosed();
-                if (getBlockingStatus() == block) {
-                    if (block) {
-                        Socket.timeoutSet(getSocket().longValue(), getWriteTimeout() * 1000);
-                    }
-                    doWriteInternal(from);
-                    return;
-                }
-            } finally {
-                readLock.unlock();
-            }
-
-            writeLock.lock();
-            try {
-                checkClosed();
-                // Set the current settings for this socket
-                setBlockingStatus(block);
-                if (block) {
-                    Socket.timeoutSet(getSocket().longValue(), getWriteTimeout() * 1000);
-                } else {
-                    Socket.timeoutSet(getSocket().longValue(), 0);
-                }
-
-                // Downgrade the lock
-                readLock.lock();
-                try {
-                    writeLock.unlock();
-                    doWriteInternal(from);
-                } finally {
-                    readLock.unlock();
-                }
-            } finally {
-                // Should have been released above but may not have been on some
-                // exception paths
-                if (writeLock.isHeldByCurrentThread()) {
-                    writeLock.unlock();
-                }
-            }
-        }
-
-
-        private void doWriteInternal(ByteBuffer from) throws IOException {
-
-            if (previousIOException != null) {
-                /*
-                 * Socket has previously seen an IOException on write.
-                 *
-                 * Blocking writes assume that buffer is always fully written so
-                 * there is no code checking for incomplete writes, retaining
-                 * the unwritten data and attempting to write it as part of a
-                 * subsequent write call.
-                 *
-                 * Because of the above, when an IOException is triggered we
-                 * need so skip subsequent attempts to write as otherwise it
-                 * will appear to the client as if some data was dropped just
-                 * before the connection is lost. It is better if the client
-                 * just sees the dropped connection.
-                 */
-                throw new IOException(previousIOException);
-            }
-
-            int thisTime;
-
-            do {
-                thisTime = 0;
-                if (getEndpoint().isSSLEnabled()) {
-                    if (sslOutputBuffer.remaining() == 0) {
-                        // Buffer was fully written last time around
-                        sslOutputBuffer.clear();
-                        transfer(from, sslOutputBuffer);
-                        sslOutputBuffer.flip();
-                    } else {
-                        // Buffer still has data from previous attempt to write
-                        // APR + SSL requires that exactly the same parameters are
-                        // passed when re-attempting the write
-                    }
-                    thisTime = Socket.sendb(getSocket().longValue(), sslOutputBuffer,
-                            sslOutputBuffer.position(), sslOutputBuffer.limit());
-                    if (thisTime > 0) {
-                        sslOutputBuffer.position(sslOutputBuffer.position() + thisTime);
-                    }
-                } else {
-                    thisTime = Socket.sendb(getSocket().longValue(), from, from.position(),
-                            from.remaining());
-                    if (thisTime > 0) {
-                        from.position(from.position() + thisTime);
-                    }
-                }
-                if (Status.APR_STATUS_IS_EAGAIN(-thisTime)) {
-                    thisTime = 0;
-                } else if (-thisTime == Status.APR_EOF) {
-                    throw new EOFException(sm.getString("socket.apr.clientAbort"));
-                } else if ((OS.IS_WIN32 || OS.IS_WIN64) &&
-                        (-thisTime == Status.APR_OS_START_SYSERR + 10053)) {
-                    // 10053 on Windows is connection aborted
-                    throw new EOFException(sm.getString("socket.apr.clientAbort"));
-                } else if (thisTime < 0) {
-                    previousIOException = new IOException(sm.getString("socket.apr.write.error",
-                            Integer.valueOf(-thisTime), getSocket(), this));
-                    throw previousIOException;
-                }
-            } while ((thisTime > 0 || getBlockingStatus()) && from.hasRemaining());
-
-            // If there is data left in the buffer the socket will be registered for
-            // write further up the stack. This is to ensure the socket is only
-            // registered for write once as both container and user code can trigger
-            // write registration.
-        }
-
-
-        @Override
-        public void registerReadInterest() {
-            // Make sure an already closed socket is not added to the poller
-            synchronized (closed) {
-                if (isClosed()) {
-                    return;
-                }
-                if (log.isDebugEnabled()) {
-                    log.debug(sm.getString("endpoint.debug.registerRead", this));
-                }
-                Poller p = ((AprEndpoint) getEndpoint()).getPoller();
-                if (p != null) {
-                    p.add(getSocket().longValue(), getReadTimeout(), Poll.APR_POLLIN);
-                }
-            }
-        }
-
-
-        @Override
-        public void registerWriteInterest() {
-            // Make sure an already closed socket is not added to the poller
-            synchronized (closed) {
-                if (isClosed()) {
-                    return;
-                }
-                if (log.isDebugEnabled()) {
-                    log.debug(sm.getString("endpoint.debug.registerWrite", this));
-                }
-                ((AprEndpoint) getEndpoint()).getPoller().add(
-                        getSocket().longValue(), getWriteTimeout(), Poll.APR_POLLOUT);
-            }
-        }
-
-
-        @Override
-        public SendfileDataBase createSendfileData(String filename, long pos, long length) {
-            return new SendfileData(filename, pos, length);
-        }
-
-
-        @Override
-        public SendfileState processSendfile(SendfileDataBase sendfileData) {
-            ((SendfileData) sendfileData).socket = getSocket().longValue();
-            return ((AprEndpoint) getEndpoint()).getSendfile().add((SendfileData) sendfileData);
-        }
-
-
-        @Override
-        protected void populateRemoteAddr() {
-            if (isClosed()) {
-                return;
-            }
-            try {
-                long socket = getSocket().longValue();
-                long sa = Address.get(Socket.APR_REMOTE, socket);
-                remoteAddr = Address.getip(sa);
-            } catch (Exception e) {
-                log.warn(sm.getString("endpoint.warn.noRemoteAddr", getSocket()), e);
-            }
-        }
-
-
-        @Override
-        protected void populateRemoteHost() {
-            if (isClosed()) {
-                return;
-            }
-            try {
-                long socket = getSocket().longValue();
-                long sa = Address.get(Socket.APR_REMOTE, socket);
-                remoteHost = Address.getnameinfo(sa, 0);
-                if (remoteAddr == null) {
-                    remoteAddr = Address.getip(sa);
-                }
-            } catch (Exception e) {
-                log.warn(sm.getString("endpoint.warn.noRemoteHost", getSocket()), e);
-            }
-        }
-
-
-        @Override
-        protected void populateRemotePort() {
-            if (isClosed()) {
-                return;
-            }
-            try {
-                long socket = getSocket().longValue();
-                long sa = Address.get(Socket.APR_REMOTE, socket);
-                Sockaddr addr = Address.getInfo(sa);
-                remotePort = addr.port;
-            } catch (Exception e) {
-                log.warn(sm.getString("endpoint.warn.noRemotePort", getSocket()), e);
-            }
-        }
-
-
-        @Override
-        protected void populateLocalName() {
-            if (isClosed()) {
-                return;
-            }
-            try {
-                long socket = getSocket().longValue();
-                long sa = Address.get(Socket.APR_LOCAL, socket);
-                localName =Address.getnameinfo(sa, 0);
-            } catch (Exception e) {
-                log.warn(sm.getString("endpoint.warn.noLocalName"), e);
-            }
-        }
-
-
-        @Override
-        protected void populateLocalAddr() {
-            if (isClosed()) {
-                return;
-            }
-            try {
-                long socket = getSocket().longValue();
-                long sa = Address.get(Socket.APR_LOCAL, socket);
-                localAddr = Address.getip(sa);
-            } catch (Exception e) {
-                log.warn(sm.getString("endpoint.warn.noLocalAddr"), e);
-            }
-        }
-
-
-        @Override
-        protected void populateLocalPort() {
-            if (isClosed()) {
-                return;
-            }
-            try {
-                long socket = getSocket().longValue();
-                long sa = Address.get(Socket.APR_LOCAL, socket);
-                Sockaddr addr = Address.getInfo(sa);
-                localPort = addr.port;
-            } catch (Exception e) {
-                log.warn(sm.getString("endpoint.warn.noLocalPort"), e);
-            }
-        }
-
-
-        @Override
-        public SSLSupport getSslSupport(String clientCertProvider) {
-            if (getEndpoint().isSSLEnabled()) {
-                return new  AprSSLSupport(this, clientCertProvider);
-            } else {
-                return null;
-            }
-        }
-
-
-        @Override
-        public void doClientAuth(SSLSupport sslSupport) throws IOException {
-            long socket = getSocket().longValue();
-            // Configure connection to require a certificate. This requires a
-            // re-handshake and must block until the re-handshake completes.
-            // Therefore, make sure socket is in blocking mode.
-            Lock readLock = getBlockingStatusReadLock();
-            WriteLock writeLock = getBlockingStatusWriteLock();
-            boolean renegotiateDone = false;
-            try {
-                readLock.lock();
-                try {
-                    if (getBlockingStatus()) {
-                        Socket.timeoutSet(getSocket().longValue(), getReadTimeout() * 1000);
-
-                        SSLSocket.setVerify(socket, SSL.SSL_CVERIFY_REQUIRE, -1);
-                        SSLSocket.renegotiate(socket);
-
-                        renegotiateDone = true;
-                    }
-                } finally {
-                    readLock.unlock();
-                }
-
-                if (!renegotiateDone) {
-                    writeLock.lock();
-                    try {
-                        // Set the current settings for this socket
-                        setBlockingStatus(true);
-                        Socket.timeoutSet(getSocket().longValue(), getReadTimeout() * 1000);
-                        // Downgrade the lock
-                        readLock.lock();
-                        try {
-                            writeLock.unlock();
-                            SSLSocket.setVerify(socket, SSL.SSL_CVERIFY_REQUIRE, -1);
-                            SSLSocket.renegotiate(socket);
-                        } finally {
-                            readLock.unlock();
-                        }
-                    } finally {
-                        // Should have been released above but may not have been on some
-                        // exception paths
-                        if (writeLock.isHeldByCurrentThread()) {
-                            writeLock.unlock();
-                        }
-                    }
-                }
-            } catch (Throwable t) {
-                ExceptionUtils.handleThrowable(t);
-                throw new IOException(sm.getString("socket.sslreneg"), t);
-            }
-        }
-
-
-        @Override
-        public void setAppReadBufHandler(ApplicationBufferHandler handler) {
-            // no-op
-        }
-
-        String getSSLInfoS(int id) {
-            synchronized (closed) {
-                if (isClosed()) {
-                    return null;
-                }
-                try {
-                    return SSLSocket.getInfoS(getSocket().longValue(), id);
-                } catch (Exception e) {
-                    throw new IllegalStateException(e);
-                }
-            }
-        }
-
-        int getSSLInfoI(int id) {
-            synchronized (closed) {
-                if (isClosed()) {
-                    return 0;
-                }
-                try {
-                    return SSLSocket.getInfoI(getSocket().longValue(), id);
-                } catch (Exception e) {
-                    throw new IllegalStateException(e);
-                }
-            }
-        }
-
-        byte[] getSSLInfoB(int id) {
-            synchronized (closed) {
-                if (isClosed()) {
-                    return null;
-                }
-                try {
-                    return SSLSocket.getInfoB(getSocket().longValue(), id);
-                } catch (Exception e) {
-                    throw new IllegalStateException(e);
-                }
-            }
-        }
-
-        @Override
-        protected <A> OperationState<A> newOperationState(boolean read,
-                ByteBuffer[] buffers, int offset, int length,
-                BlockingMode block, long timeout, TimeUnit unit, A attachment,
-                CompletionCheck check, CompletionHandler<Long, ? super A> handler,
-                Semaphore semaphore, VectoredIOCompletionHandler<A> completion) {
-            return new AprOperationState<>(read, buffers, offset, length, block,
-                    timeout, unit, attachment, check, handler, semaphore, completion);
-        }
-
-        private class AprOperationState<A> extends OperationState<A> {
-            private volatile boolean inline = true;
-            private volatile long flushBytes = 0;
-            private AprOperationState(boolean read, ByteBuffer[] buffers, int offset, int length,
-                    BlockingMode block, long timeout, TimeUnit unit, A attachment, CompletionCheck check,
-                    CompletionHandler<Long, ? super A> handler, Semaphore semaphore,
-                    VectoredIOCompletionHandler<A> completion) {
-                super(read, buffers, offset, length, block,
-                        timeout, unit, attachment, check, handler, semaphore, completion);
-            }
-
-            @Override
-            protected boolean isInline() {
-                return inline;
-            }
-
-            @Override
-            public void run() {
-                // Perform the IO operation
-                // Called from the poller to continue the IO operation
-                long nBytes = 0;
-                if (getError() == null) {
-                    try {
-                        synchronized (this) {
-                            if (!completionDone) {
-                                // This filters out same notification until processing
-                                // of the current one is done
-                                if (log.isDebugEnabled()) {
-                                    log.debug("Skip concurrent " + (read ? "read" : "write") + " notification");
-                                }
-                                return;
-                            }
-                            // Find the buffer on which the operation will be performed (no vectoring with APR)
-                            ByteBuffer buffer = null;
-                            for (int i = 0; i < length; i++) {
-                                if (buffers[i + offset].hasRemaining()) {
-                                    buffer = buffers[i + offset];
-                                    break;
-                                }
-                            }
-                            if (buffer == null && flushBytes == 0) {
-                                // Nothing to do
-                                completion.completed(Long.valueOf(0), this);
-                                return;
-                            }
-                            if (read) {
-                                nBytes = read(false, buffer);
-                            } else {
-                                if (!flush(block == BlockingMode.BLOCK)) {
-                                    if (flushBytes > 0) {
-                                        // Flushing was done, continue processing
-                                        nBytes = flushBytes;
-                                        flushBytes = 0;
-                                    } else {
-                                        @SuppressWarnings("null") // Not possible
-                                        int remaining = buffer.remaining();
-                                        write(block == BlockingMode.BLOCK, buffer);
-                                        nBytes = remaining - buffer.remaining();
-                                        if (nBytes > 0 && flush(block == BlockingMode.BLOCK)) {
-                                            // We have to flush and it's incomplete, save the bytes written until done
-                                            inline = false;
-                                            registerWriteInterest();
-                                            flushBytes = nBytes;
-                                            return;
-                                        }
-                                    }
-                                } else {
-                                    // Continue flushing
-                                    inline = false;
-                                    registerWriteInterest();
-                                    return;
-                                }
-                            }
-                            if (nBytes != 0) {
-                                completionDone = false;
-                            }
-                        }
-                    } catch (IOException e) {
-                        setError(e);
-                    }
-                }
-                if (nBytes > 0) {
-                    // The bytes processed are only updated in the completion handler
-                    completion.completed(Long.valueOf(nBytes), this);
-                } else if (nBytes < 0 || getError() != null) {
-                    IOException error = getError();
-                    if (error == null) {
-                        error = new EOFException();
-                    }
-                    completion.failed(error, this);
-                } else {
-                    // As soon as the operation uses the poller, it is no longer inline
-                    inline = false;
-                    if (read) {
-                        registerReadInterest();
-                    } else {
-                        registerWriteInterest();
-                    }
-                }
-            }
-
-        }
-
-    }
-}

==================================================
ObjectReflectionPropertyInspector.java
index 0216cb1442..38713f8922 100644
--- a/java/org/apache/tomcat/util/net/mbeans-descriptors.xml
+++ b/java/org/apache/tomcat/util/net/mbeans-descriptors.xml
@@ -468,232 +468,6 @@
 
   </mbean>
 
-  <mbean         name="AprEndpoint"
-            className="org.apache.catalina.mbeans.ClassNameMBean"
-               domain="Catalina"
-                group="ThreadPool"
-                 type="org.apache.tomcat.util.net.AprEndpoint">
-
-    <attribute   name="acceptCount"
-                 type="int"/>
-
-    <attribute   name="acceptorThreadCount"
-                 type="int"/>
-
-    <attribute   name="acceptorThreadPriority"
-                 type="int"/>
-
-    <attribute   name="alpnSupported"
-                 type="boolean"
-            writeable="false"
-                   is="true"/>
-
-    <attribute   name="bindOnInit"
-                 type="boolean"/>
-
-    <attribute   name="connectionCount"
-                 type="long"
-            writeable="false"/>
-
-    <attribute   name="connectionLinger"
-                 type="int"/>
-
-    <attribute   name="connectionTimeout"
-                 type="int"/>
-
-    <attribute   name="currentThreadCount"
-                 type="int"
-            writeable="false"/>
-
-    <attribute   name="currentThreadsBusy"
-                 type="int"
-            writeable="false"/>
-
-    <attribute   name="daemon"
-                 type="boolean"/>
-
-    <attribute   name="defaultSSLHostConfigName"
-                 type="java.lang.String"/>
-
-    <attribute   name="deferAccept"
-                 type="boolean"/>
-
-    <attribute   name="domain"
-                 type="java.lang.String"/>
-
-    <attribute   name="executorTerminationTimeoutMillis"
-                 type="long"/>
-
-    <attribute   name="ipv6v6only"
-                 type="boolean"/>
-
-    <attribute   name="keepAliveCount"
-                 type="int"
-            writeable="false"/>
-
-    <attribute   name="keepAliveTimeout"
-                 type="int"/>
-
-    <attribute   name="localPort"
-                 type="int"
-            writeable="false"/>
-
-    <attribute   name="maxConnections"
-                 type="int"/>
-
-    <attribute   name="maxKeepAliveRequests"
-                 type="int"/>
-
-    <attribute   name="maxThreads"
-                 type="int"/>
-
-    <attribute   name="minSpareThreads"
-                 type="int"/>
-
-    <attribute   name="modelerType"
-                 type="java.lang.String"
-            writeable="false"/>
-
-    <attribute   name="name"
-                 type="java.lang.String"/>
-
-    <attribute   name="paused"
-                 type="boolean"
-            writeable="false"
-                   is="true"/>
-
-    <attribute   name="pollTime"
-                 type="int"/>
-
-    <attribute   name="port"
-                 type="int"/>
-
-    <attribute   name="portOffset"
-                 type="int"/>
-
-    <attribute   name="portWithOffset"
-                 type="int"
-            writeable="false"/>
-
-    <attribute   name="running"
-                 type="boolean"
-            writeable="false"
-                   is="true"/>
-
-    <attribute   name="sSLEnabled"
-                 type="boolean"
-                   is="true"/>
-
-    <attribute   name="sendfileCount"
-                 type="int"
-            writeable="false"/>
-
-    <attribute   name="sendfileSize"
-                 type="int"/>
-
-    <attribute   name="tcpNoDelay"
-                 type="boolean"/>
-
-    <attribute   name="threadPriority"
-                 type="int"/>
-
-    <attribute   name="useSendfile"
-                 type="boolean"/>
-
-    <operation       name="addNegotiatedProtocol"
-               returnType="void">
-      <parameter name="param0"
-                 type="java.lang.String"/>
-    </operation>
-
-    <operation       name="bind"
-               returnType="void"/>
-
-    <operation       name="closeServerSocketGraceful"
-               returnType="void"/>
-
-    <operation       name="createExecutor"
-               returnType="void"/>
-
-    <operation       name="destroy"
-               returnType="void"/>
-
-    <operation       name="findSslHostConfigs"
-               returnType="[Lorg.apache.tomcat.util.net.SSLHostConfig;"/>
-
-    <operation       name="getAttribute"
-               returnType="java.lang.Object">
-      <parameter name="param0"
-                 type="java.lang.String"/>
-    </operation>
-
-    <operation       name="getProperty"
-               returnType="java.lang.String">
-      <parameter name="param0"
-                 type="java.lang.String"/>
-    </operation>
-
-    <operation       name="getSslContext"
-               returnType="long">
-      <parameter name="param0"
-                 type="java.lang.String"/>
-    </operation>
-
-    <operation       name="hasNegotiableProtocols"
-               returnType="boolean"/>
-
-    <operation       name="init"
-               returnType="void"/>
-
-    <operation       name="pause"
-               returnType="void"/>
-
-    <operation       name="reloadSslHostConfig"
-               returnType="void">
-      <parameter name="param0"
-                 type="java.lang.String"/>
-    </operation>
-
-    <operation       name="reloadSslHostConfigs"
-               returnType="void"/>
-
-    <operation       name="removeSslHostConfig"
-               returnType="org.apache.tomcat.util.net.SSLHostConfig">
-      <parameter name="param0"
-                 type="java.lang.String"/>
-    </operation>
-
-    <operation       name="resume"
-               returnType="void"/>
-
-    <operation       name="setProperty"
-               returnType="boolean">
-      <parameter name="param0"
-                 type="java.lang.String"/>
-      <parameter name="param1"
-                 type="java.lang.String"/>
-    </operation>
-
-    <operation       name="shutdownExecutor"
-               returnType="void"/>
-
-    <operation       name="start"
-               returnType="void"/>
-
-    <operation       name="startInternal"
-               returnType="void"/>
-
-    <operation       name="stop"
-               returnType="void"/>
-
-    <operation       name="stopInternal"
-               returnType="void"/>
-
-    <operation       name="unbind"
-               returnType="void"/>
-
-  </mbean>
-
 </mbeans-descriptors>
 
 

==================================================
TestRegistration.java
index bbcdcd460b..ff9edc80a5 100644
--- a/res/ide-support/netbeans/nb-tomcat.xml
+++ b/res/ide-support/netbeans/nb-tomcat.xml
@@ -88,8 +88,8 @@
           message="Property 'test.entry' must be set in project.xml."/>
     <!--
          the runtests macro runs a single test if test.entry is a class name
-         Note: we must ONLY run one of the test targets, otherwise test-apr
-               will run last and wipe out the test results!
+         Note: we must ONLY run one of the test targets, otherwise the target
+               that runs last and wipe out the other test results!
          Note: the test targets all depend on deploy
       -->
     <ant target="test-nio" inheritall="false">

==================================================
TomcatBaseTest.java
index bffd2c5e38..cd7a982124 100644
--- a/test/org/apache/catalina/mbeans/TestRegistration.java
+++ b/test/org/apache/catalina/mbeans/TestRegistration.java
@@ -189,8 +189,6 @@ public class TestRegistration extends TomcatBaseTest {
         String protocol = tomcat.getConnector().getProtocolHandlerClassName();
         if (protocol.indexOf("Nio2") > 0) {
             protocol = "nio2";
-        } else if (protocol.indexOf("Apr") > 0) {
-            protocol = "apr";
         } else {
             protocol = "nio";
         }

==================================================
TestAbstractAjpProcessor.java
index 7181e7abc0..638a1914ee 100644
--- a/test/org/apache/catalina/startup/TomcatBaseTest.java
+++ b/test/org/apache/catalina/startup/TomcatBaseTest.java
@@ -56,8 +56,6 @@ import org.apache.catalina.Service;
 import org.apache.catalina.Session;
 import org.apache.catalina.WebResourceRoot;
 import org.apache.catalina.connector.Connector;
-import org.apache.catalina.core.AprLifecycleListener;
-import org.apache.catalina.core.StandardServer;
 import org.apache.catalina.session.ManagerBase;
 import org.apache.catalina.session.StandardManager;
 import org.apache.catalina.util.IOTools;
@@ -178,14 +176,6 @@ public abstract class TomcatBaseTest extends LoggingBaseTest {
         tomcat.getService().addConnector(connector);
         tomcat.setConnector(connector);
 
-        // Add AprLifecycleListener if we are using the Apr connector
-        if (protocol.contains("Apr")) {
-            StandardServer server = (StandardServer) tomcat.getServer();
-            AprLifecycleListener listener = new AprLifecycleListener();
-            listener.setSSLRandomSeed("/dev/urandom");
-            server.addLifecycleListener(listener);
-        }
-
         File catalinaBase = getTemporaryDirectory();
         tomcat.setBaseDir(catalinaBase.getAbsolutePath());
         tomcat.getHost().setAppBase(appBase.getAbsolutePath());

==================================================
AbstractJniTest.java
index 21f5e53fda..dfb4f28f06 100644
--- a/test/org/apache/coyote/ajp/TestAbstractAjpProcessor.java
+++ b/test/org/apache/coyote/ajp/TestAbstractAjpProcessor.java
@@ -68,8 +68,6 @@ public class TestAbstractAjpProcessor extends TomcatBaseTest {
             protocol = "org.apache.coyote.ajp.AjpNioProtocol";
         } else if (protocol.contains("Nio2")) {
             protocol = "org.apache.coyote.ajp.AjpNio2Protocol";
-        } else if (protocol.contains("Apr")) {
-            protocol = "org.apache.coyote.ajp.AjpAprProtocol";
         } else {
             protocol = "org.apache.coyote.ajp.AjpNioProtocol";
         }

==================================================
TestFile.java
deleted file mode 100644
index 84ed1ac29d..0000000000
--- a/test/org/apache/tomcat/jni/AbstractJniTest.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.jni;
-
-import org.junit.After;
-import org.junit.Assume;
-import org.junit.Before;
-
-public abstract class AbstractJniTest {
-
-    private boolean nativeLibraryPresent = false;
-
-    @Before
-    public void initBase() throws Exception {
-        try {
-            Library.initialize(null);
-            nativeLibraryPresent = true;
-        } catch (LibraryNotFoundError lnfe) {
-            nativeLibraryPresent = false;
-        }
-        Assume.assumeTrue("APR Library not found", nativeLibraryPresent);
-    }
-
-
-    @After
-    public void destroyBase() {
-        if (nativeLibraryPresent) {
-            Library.terminate();
-        }
-    }
-
-}

==================================================
TestSocketServer.java
deleted file mode 100644
index 95bb10f463..0000000000
--- a/test/org/apache/tomcat/jni/TestFile.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.jni;
-
-import org.junit.Assert;
-import org.junit.Test;
-
-/*
- * @deprecated  The scope of the APR/Native Library will be reduced in Tomcat
- *              10.1.x onwards to only those components required to provide
- *              OpenSSL integration with the NIO and NIO2 connectors.
- */
-@Deprecated
-public class TestFile extends AbstractJniTest {
-
-    @Test
-    public void testInfoGet() throws Exception {
-        String testFile = "test/org/apache/tomcat/jni/TestFile.java";
-        java.io.File file = new java.io.File(testFile);
-        Assert.assertTrue("File " + testFile + " does not exist!", file.exists());
-
-        Library.initialize(null);
-        long pool = Pool.create(0L);
-        int openFlags = File.APR_FOPEN_READ | File.APR_FOPEN_BUFFERED | File.APR_FOPEN_XTHREAD;
-        int openPermissions = File.APR_FPROT_OS_DEFAULT;
-        int statFlags = File.APR_FINFO_MIN;
-        long fd = File.open(testFile, openFlags, openPermissions, pool);
-        FileInfo fileInfo = new FileInfo();
-        for (int i = 0; i < 100000; i++) {
-            org.apache.tomcat.jni.File.infoGet(fileInfo, statFlags, fd);
-            @SuppressWarnings("unused")
-            String info = inspectFileInfo(fileInfo);
-        }
-    }
-
-    public static String inspectFileInfo(FileInfo fileInfo) {
-        String result = fileInfo.toString() + " : {" +
-                String.format("\n  pool : %d", Long.valueOf(fileInfo.pool)) +
-                String.format("\n  valid : %d", Integer.valueOf(fileInfo.valid)) +
-                String.format("\n  protection : %d", Integer.valueOf(fileInfo.protection)) +
-                String.format("\n  filetype : %d", Integer.valueOf(fileInfo.filetype)) +
-                String.format("\n  user : %d", Integer.valueOf(fileInfo.user)) +
-                String.format("\n  group : %d", Integer.valueOf(fileInfo.group)) +
-                String.format("\n  inode : %d", Integer.valueOf(fileInfo.inode)) +
-                String.format("\n  device : %d", Integer.valueOf(fileInfo.device)) +
-                String.format("\n  nlink : %d", Integer.valueOf(fileInfo.nlink)) +
-                String.format("\n  size : %d", Long.valueOf(fileInfo.size)) +
-                String.format("\n  csize : %d", Long.valueOf(fileInfo.csize)) +
-                String.format("\n  atime : %d", Long.valueOf(fileInfo.atime)) +
-                String.format("\n  mtime : %d", Long.valueOf(fileInfo.mtime)) +
-                String.format("\n  ctime : %d", Long.valueOf(fileInfo.ctime)) +
-                String.format("\n  fname : %s", fileInfo.fname) +
-                String.format("\n  name : %s", fileInfo.name) +
-                String.format("\n  filehand : %d", Long.valueOf(fileInfo.filehand)) +
-                "\n}";
-        return result;
-    }
-}
\ No newline at end of file

==================================================
TestSocketServerAnyLocalAddress.java
deleted file mode 100644
index 1a6d4d6ada..0000000000
--- a/test/org/apache/tomcat/jni/TestSocketServer.java
+++ /dev/null
@@ -1,235 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.jni;
-
-import java.io.OutputStream;
-import java.util.concurrent.CountDownLatch;
-
-import org.junit.After;
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Test;
-
-/*
- * Tests for server-side sockets.
- *
- * While System.nanotime() is available and may have a resolution of ~100ns on
- * some platforms, those same platforms do not use as precise a timer for socket
- * timeouts. Therefore, a much larger error margin (100ms) is used.
- *
- * It is known that this larger error margin is required for Windows 10. It may
- * be worth revisiting the choice of error margin once that platform is no
- * longer supported.
- *
- * @deprecated  The scope of the APR/Native Library will be reduced in Tomcat
- *              10.1.x onwards to only those components required to provide
- *              OpenSSL integration with the NIO and NIO2 connectors.
- */
-@Deprecated
-public class TestSocketServer extends AbstractJniTest {
-
-    private static final String HOST = "localhost";
-    // 100ms == 100,000,000ns
-    private static final long ERROR_MARGIN = 100000000;
-
-    private int port = 0;
-    private long serverSocket = 0;
-    private long clientSocket = 0;
-
-    @Before
-    public void init() throws Exception {
-        long serverPool = Pool.create(0);
-        long inetAddress = Address.info(HOST, Socket.APR_INET,
-                                        0, 0, serverPool);
-        serverSocket = Socket.create(Socket.APR_INET, Socket.SOCK_STREAM,
-                                   Socket.APR_PROTO_TCP, serverPool);
-        if (OS.IS_UNIX) {
-            Socket.optSet(serverSocket, Socket.APR_SO_REUSEADDR, 1);
-        }
-        int rc = Socket.bind(serverSocket, inetAddress);
-        Assert.assertEquals("Can't bind: " + Error.strerror(rc), 0, rc);
-        Socket.listen(serverSocket, 5);
-        if (!OS.IS_UNIX) {
-            Socket.optSet(serverSocket, Socket.APR_SO_REUSEADDR, 1);
-        }
-
-        long localAddress = Address.get(Socket.APR_LOCAL, serverSocket);
-        port = Address.getInfo(localAddress).port;
-    }
-
-
-    @After
-    public void destroy() {
-        if (clientSocket != 0) {
-            Socket.close(clientSocket);
-            Socket.destroy(clientSocket);
-        }
-        if (serverSocket != 0) {
-            Socket.close(serverSocket);
-            Socket.destroy(serverSocket);
-        }
-    }
-
-
-    @Test
-    public void testPort() {
-        Assert.assertTrue(port > 0);
-    }
-
-
-    @Test
-    public void testBlockingReadFromClientWithTimeout() throws Exception {
-        /* Start the client that connects to the server */
-        Client client = new Client(port);
-        client.start();
-
-        /* Accept the client connection */
-        clientSocket = Socket.accept(serverSocket);
-
-        /* Configure a 1s timeout for reading from client */
-        Socket.timeoutSet(clientSocket, 1000000);
-        long timeout = Socket.timeoutGet(clientSocket);
-        Assert.assertEquals("Socket.timeoutGet clientSocket failed", 1000000, timeout);
-
-        byte [] buf = new byte[1];
-        long start = System.nanoTime();
-        while (Socket.recv(clientSocket, buf, 0, 1) == 1) {
-        }
-        long wait = System.nanoTime() - start;
-        Assert.assertFalse("Socket.timeoutSet failed (<1s) [" + wait + "] +-[" + ERROR_MARGIN + "]",
-                wait < 1000000000 - ERROR_MARGIN);
-        Assert.assertFalse("Socket.timeoutSet failed (>2s) [" + wait + "] +-[" + ERROR_MARGIN + "]",
-                wait > 2000000000 + ERROR_MARGIN);
-
-        client.countDown();
-        client.join();
-    }
-
-
-    @Test
-    public void testNonBlockingReadFromClient() throws Exception {
-        /* Start the client that connects to the server */
-        Client client = new Client(port);
-        client.start();
-
-        /* Accept the client connection */
-        clientSocket = Socket.accept(serverSocket);
-
-        /* Configure the connection for non-blocking */
-        Socket.optSet(clientSocket, Socket.APR_SO_NONBLOCK, 1);
-        int val = Socket.optGet(clientSocket, Socket.APR_SO_NONBLOCK);
-        Assert.assertEquals("Socket.optGet clientSocket failed", 1, val);
-
-        byte [] buf = new byte[1];
-        long start = System.nanoTime();
-        while (Socket.recv(clientSocket, buf, 0, 1) == 1) {
-        }
-        long wait = System.nanoTime() - start;
-        Assert.assertFalse("non_blocking client Socket.APR_SO_NONBLOCK failed (>2ms) [" + wait +
-                "] +-[" + ERROR_MARGIN + "]", wait > 2000000 + ERROR_MARGIN);
-
-        client.countDown();
-        client.join();
-    }
-
-
-    @Test
-    public void testNonBlockingReadThenBlockingReadFromClient() throws Exception {
-        /* Start the client that connects to the server */
-        Client client = new Client(port);
-        client.start();
-
-        /* Accept the client connection */
-        clientSocket = Socket.accept(serverSocket);
-
-        /* Configure the connection for non-blocking */
-        Socket.optSet(clientSocket, Socket.APR_SO_NONBLOCK, 1);
-
-        byte [] buf = new byte[1];
-        long start = System.nanoTime();
-        while (Socket.recv(clientSocket, buf, 0, 1) == 1) {
-        }
-        long wait = System.nanoTime() - start;
-        Assert.assertFalse("non_blocking client Socket.APR_SO_NONBLOCK failed (>1ms) [" + wait +
-                "] +-[" + ERROR_MARGIN + "]", wait > 1000000 + ERROR_MARGIN);
-
-        /* Configure for blocking */
-        Socket.optSet(clientSocket, Socket.APR_SO_NONBLOCK, 0);
-        Socket.timeoutSet(clientSocket, 2000);
-        start = System.nanoTime();
-        while (Socket.recv(clientSocket, buf, 0, 1) == 1) {
-        }
-        wait = System.nanoTime() - start;
-        Assert.assertFalse("non_blocking client Socket.APR_SO_NONBLOCK false failed (<1ms) [" +
-                wait + "] +-[" + ERROR_MARGIN + "]", wait < 1000000 - ERROR_MARGIN);
-
-        client.countDown();
-        client.join();
-    }
-
-
-    @Test
-    public void testNonBlockingAcceptWithNoClient() throws Exception {
-        Socket.optSet(serverSocket, Socket.APR_SO_NONBLOCK, 1);
-        int val = Socket.optGet(serverSocket, Socket.APR_SO_NONBLOCK);
-        Assert.assertEquals("Socket.optGet serverSocket failed", 1, val);
-
-        long start = System.nanoTime();
-        boolean ok = false;
-        try {
-            Socket.accept(serverSocket);
-        } catch (Exception ex) {
-            ok = true;
-        }
-        long wait = System.nanoTime() - start;
-        Assert.assertTrue("Timeout failed", ok);
-        Assert.assertFalse("non_blocking accept Socket.APR_SO_NONBLOCK failed (>10ms) [" + wait +
-                "] +-[" + ERROR_MARGIN + "]", wait > 10000000 + ERROR_MARGIN);
-    }
-
-
-    /**
-     * Simple client that connects, sends a single byte then closes the
-     * connection.
-     */
-    private static class Client extends java.lang.Thread {
-
-        private final int port;
-        private final CountDownLatch complete = new CountDownLatch(1);
-
-        public Client(int port) throws Exception {
-            this.port = port;
-        }
-
-        public void countDown() {
-            complete.countDown();
-        }
-
-        @Override
-        public void run() {
-
-            try (java.net.Socket sock = new java.net.Socket(TestSocketServer.HOST, port)) {
-                OutputStream os = sock.getOutputStream();
-                os.write('A');
-                os.flush();
-                complete.await();
-            } catch (Exception ex) {
-                ex.printStackTrace();
-            }
-        }
-    }
-}

==================================================
TestUnixDomainSocketServer.java
deleted file mode 100644
index 8739a1953a..0000000000
--- a/test/org/apache/tomcat/jni/TestSocketServerAnyLocalAddress.java
+++ /dev/null
@@ -1,224 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.jni;
-
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.NetworkInterface;
-import java.util.Enumeration;
-
-import org.junit.After;
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Test;
-
-/**
- * Tests for server-side sockets using any local address (0.0.0.0 or ::).
- *
- * @deprecated  The scope of the APR/Native Library will be reduced in Tomcat
- *              10.1.x onwards to only those components required to provide
- *              OpenSSL integration with the NIO and NIO2 connectors.
- */
-@Deprecated
-public class TestSocketServerAnyLocalAddress extends AbstractJniTest {
-
-    // Excessive but allows for slow systems
-    private static final int TIMEOUT_MICROSECONDS = 10 * 1000 * 1000;
-
-    private long serverSocket = 0;
-    private long clientSocket = 0;
-
-
-    @Before
-    public void init() throws Exception {
-        long serverPool = Pool.create(0);
-        int family;
-        if (Boolean.getBoolean("java.net.preferIPv4Stack")) {
-            family = Socket.APR_INET;
-        } else {
-            family = Socket.APR_UNSPEC;
-        }
-        long inetAddress = Address.info(null, family, 0, 0, serverPool);
-        serverSocket = Socket.create(Address.getInfo(inetAddress).family, Socket.SOCK_STREAM,
-                                   Socket.APR_PROTO_TCP, serverPool);
-        if (OS.IS_UNIX) {
-            Socket.optSet(serverSocket, Socket.APR_SO_REUSEADDR, 1);
-        }
-        int rc = Socket.bind(serverSocket, inetAddress);
-        Assert.assertEquals("Can't bind: " + Error.strerror(rc), 0, rc);
-        Socket.listen(serverSocket, 5);
-        if (!OS.IS_UNIX) {
-            Socket.optSet(serverSocket, Socket.APR_SO_REUSEADDR, 1);
-        }
-    }
-
-
-    @After
-    public void destroy() {
-        if (clientSocket != 0) {
-            Socket.close(clientSocket);
-            Socket.destroy(clientSocket);
-        }
-        if (serverSocket != 0) {
-            Socket.close(serverSocket);
-            Socket.destroy(serverSocket);
-        }
-    }
-
-
-    @Test
-    public void testWithClient() throws Exception {
-        /* Start the client that connects to the server */
-        Client client = new Client(serverSocket);
-        client.start();
-
-        boolean running = true;
-        while (running) {
-            /* Accept the client connection */
-            clientSocket = Socket.accept(serverSocket);
-
-            /* Configure a 10s timeout for reading from client */
-            Socket.timeoutSet(clientSocket, TIMEOUT_MICROSECONDS);
-
-            byte [] buf = new byte[1];
-            while (Socket.recv(clientSocket, buf, 0, 1) == 1) {
-                // If 'A' was read, echo back 'Z'
-                if (buf[0] == 'A') {
-                    buf[0] = 'Z';
-                    Socket.send(clientSocket, buf, 0, 1);
-                }
-            }
-            if (buf[0] == 'E') {
-                running = false;
-            } else if (buf[0] == 'Z') {
-                // NO-OP - connection closing
-            } else {
-                Assert.fail("Unexpected data [" + (char) buf[0] + "]");
-            }
-        }
-
-        client.join();
-    }
-
-
-    /**
-     * Simple client that connects, sends a single byte then closes the
-     * connection.
-     */
-    private static class Client extends java.lang.Thread {
-
-        private final long serverSocket;
-
-        public Client(long serverSocket) throws Exception {
-            this.serverSocket = serverSocket;
-        }
-
-        @Override
-        public void run() {
-
-            try {
-                InetSocketAddress connectAddress = getConnectAddress(serverSocket);
-                System.out.println("Client attempting to connect to [" + connectAddress + "]");
-                java.net.Socket sock = new java.net.Socket();
-                sock.connect(connectAddress, TIMEOUT_MICROSECONDS);
-                sock.setSoTimeout(TIMEOUT_MICROSECONDS);
-                OutputStream ou = sock.getOutputStream();
-                InputStream in =  sock.getInputStream();
-                ou.write('A');
-                ou.flush();
-                int rep = in.read();
-                sock.close();
-                if (rep != 'Z') {
-                     throw new Exception("Read wrong data [" + rep + "]");
-                }
-
-                sock = new java.net.Socket();
-                sock.connect(connectAddress, TIMEOUT_MICROSECONDS);
-                sock.setSoTimeout(TIMEOUT_MICROSECONDS);
-                ou = sock.getOutputStream();
-                ou.write('E');
-                ou.flush();
-                sock.close();
-            } catch (Exception e) {
-                e.printStackTrace();
-                // Prevent the test from hanging on Socket.accept(serverSocket)
-                // if the client fails
-                Socket.shutdown(serverSocket, Socket.APR_SHUTDOWN_READWRITE);
-            }
-        }
-
-
-        /*
-         * Assumes server is listening on any local address
-         */
-        private static InetSocketAddress getConnectAddress(long serverSocket) throws Exception {
-            long sa = Address.get(Socket.APR_LOCAL, serverSocket);
-            Sockaddr addr = Address.getInfo(sa);
-            InetSocketAddress localAddress;
-            if (addr.family == Socket.APR_INET6) {
-                localAddress = new InetSocketAddress("::", addr.port);
-            } else {
-                localAddress = new InetSocketAddress("0.0.0.0", addr.port);
-            }
-            System.out.println("Server is listening at [" + localAddress + "]");
-
-            // Need a local address of the same type (IPv4 or IPV6) as the
-            // configured bind address since the connector may be configured
-            // to not map between types.
-            InetAddress loopbackConnectAddress = null;
-            InetAddress linkLocalConnectAddress = null;
-
-            Enumeration<NetworkInterface> networkInterfaces = NetworkInterface.getNetworkInterfaces();
-            while (networkInterfaces.hasMoreElements()) {
-                NetworkInterface networkInterface = networkInterfaces.nextElement();
-                if (networkInterface.isUp()) {
-                    Enumeration<InetAddress> inetAddresses = networkInterface.getInetAddresses();
-                    while (inetAddresses.hasMoreElements()) {
-                        InetAddress inetAddress = inetAddresses.nextElement();
-                        if (localAddress.getAddress().getClass().isAssignableFrom(inetAddress.getClass())) {
-                            if (inetAddress.isLoopbackAddress()) {
-                                if (loopbackConnectAddress == null) {
-                                    loopbackConnectAddress = inetAddress;
-                                }
-                            } else if (inetAddress.isLinkLocalAddress()) {
-                                if (linkLocalConnectAddress == null) {
-                                    linkLocalConnectAddress = inetAddress;
-                                }
-                            } else {
-                                // Use a non-link local, non-loop back address by default
-                                return new InetSocketAddress(inetAddress, localAddress.getPort());
-                            }
-                        }
-                    }
-                }
-            }
-            // Prefer loop back over link local since on some platforms (e.g.
-            // OSX) some link local addresses are not included when listening on
-            // all local addresses.
-            if (loopbackConnectAddress != null) {
-                return new InetSocketAddress(loopbackConnectAddress, localAddress.getPort());
-            }
-            if (linkLocalConnectAddress != null) {
-                return new InetSocketAddress(linkLocalConnectAddress, localAddress.getPort());
-            }
-            // Fallback
-            return new InetSocketAddress("localhost", localAddress.getPort());
-        }
-    }
-}

==================================================
TestClientCert.java
deleted file mode 100644
index f38ecce2ea..0000000000
--- a/test/org/apache/tomcat/jni/TestUnixDomainSocketServer.java
+++ /dev/null
@@ -1,243 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.jni;
-
-import java.util.concurrent.CountDownLatch;
-
-import org.junit.After;
-import org.junit.Assert;
-import org.junit.Assume;
-import org.junit.Before;
-import org.junit.Test;
-
-import org.apache.tomcat.util.compat.JrePlatform;
-
-/*
- * Tests for Unix Domain Sockets.
- *
- * While System.nanotime() is available and may have a resolution of ~100 ns on
- * some platforms, those same platforms do not use as precise a timer for socket
- * timeouts. Therefore, a much larger error margin (100 ms) is used.
- *
- * It is known that this larger error margin is required for Windows 10. It may
- * be worth revisiting the choice of error margin once that platform is no
- * longer supported.
- *
- * @deprecated  The scope of the APR/Native Library will be reduced in Tomcat
- *              10.1.x onwards to only those components required to provide
- *              OpenSSL integration with the NIO and NIO2 connectors.
- */
-@Deprecated
-public class TestUnixDomainSocketServer extends AbstractJniTest {
-
-    private static final String PATH = System.getProperty("java.io.tmpdir") + System.getProperty("file.separator") + "tomcat.sock";
-    // 100 ms == 100 000 000 ns
-    private static final long ERROR_MARGIN = 100000000;
-
-    private long pool = 0;
-    private long serverSocket = 0;
-    private long clientSocket = 0;
-
-    @Before
-    public void init() throws Exception {
-        Assume.assumeFalse(JrePlatform.IS_WINDOWS);
-        Assume.assumeTrue(Library.APR_HAVE_UNIX);
-        pool = Pool.create(0);
-        long unixAddress = Address.info(PATH, Socket.APR_UNIX,
-                                        0, 0, pool);
-        serverSocket = Socket.create(Socket.APR_UNIX, Socket.SOCK_STREAM,
-                                     0, pool);
-        int rc = Socket.bind(serverSocket, unixAddress);
-        Assert.assertEquals("Can't bind: " + Error.strerror(rc), 0, rc);
-        Socket.listen(serverSocket, 5);
-
-    }
-
-
-    @After
-    public void destroy() {
-        if (clientSocket != 0) {
-            Socket.close(clientSocket);
-            Socket.destroy(clientSocket);
-        }
-        if (serverSocket != 0) {
-            Socket.close(serverSocket);
-            Socket.destroy(serverSocket);
-        }
-        if (pool != 0) {
-            Pool.destroy(pool);
-        }
-    }
-
-
-    @Test
-    public void testBlockingReadFromClientWithTimeout() throws Exception {
-        /* Start the client that connects to the server */
-        Client client = new Client(PATH);
-        client.start();
-
-        /* Accept the client connection */
-        clientSocket = Socket.accept(serverSocket);
-
-        /* Configure a 1s timeout for reading from client */
-        Socket.timeoutSet(clientSocket, 1000000);
-        long timeout = Socket.timeoutGet(clientSocket);
-        Assert.assertEquals("Socket.timeoutGet clientSocket failed", 1000000, timeout);
-
-        byte [] buf = new byte[1];
-        long start = System.nanoTime();
-        while (Socket.recv(clientSocket, buf, 0, 1) == 1) {
-        }
-        long wait = System.nanoTime() - start;
-        Assert.assertFalse("Socket.timeoutSet failed (<1s) [" + wait + "] +-[" + ERROR_MARGIN + "]",
-                wait < 1000000000 - ERROR_MARGIN);
-        Assert.assertFalse("Socket.timeoutSet failed (>2s) [" + wait + "] +-[" + ERROR_MARGIN + "]",
-                wait > 2000000000 + ERROR_MARGIN);
-
-        client.countDown();
-        client.join();
-    }
-
-
-    @Test
-    public void testNonBlockingReadFromClient() throws Exception {
-        /* Start the client that connects to the server */
-        Client client = new Client(PATH);
-        client.start();
-
-        /* Accept the client connection */
-        clientSocket = Socket.accept(serverSocket);
-
-        /* Configure the connection for non-blocking */
-        Socket.optSet(clientSocket, Socket.APR_SO_NONBLOCK, 1);
-        int val = Socket.optGet(clientSocket, Socket.APR_SO_NONBLOCK);
-        Assert.assertEquals("Socket.optGet clientSocket failed", 1, val);
-
-        byte [] buf = new byte[1];
-        long start = System.nanoTime();
-        while (Socket.recv(clientSocket, buf, 0, 1) == 1) {
-        }
-        long wait = System.nanoTime() - start;
-        Assert.assertFalse("non_blocking client Socket.APR_SO_NONBLOCK failed (>2ms) [" + wait +
-                "] +-[" + ERROR_MARGIN + "]", wait > 2000000 + ERROR_MARGIN);
-
-        client.countDown();
-        client.join();
-    }
-
-
-    @Test
-    public void testNonBlockingReadThenBlockingReadFromClient() throws Exception {
-        /* Start the client that connects to the server */
-        Client client = new Client(PATH);
-        client.start();
-
-        /* Accept the client connection */
-        clientSocket = Socket.accept(serverSocket);
-
-        /* Configure the connection for non-blocking */
-        Socket.optSet(clientSocket, Socket.APR_SO_NONBLOCK, 1);
-
-        byte [] buf = new byte[1];
-        long start = System.nanoTime();
-        while (Socket.recv(clientSocket, buf, 0, 1) == 1) {
-        }
-        long wait = System.nanoTime() - start;
-        Assert.assertFalse("non_blocking client Socket.APR_SO_NONBLOCK failed (>1ms) [" + wait +
-                "] +-[" + ERROR_MARGIN + "]", wait > 1000000 + ERROR_MARGIN);
-
-        /* Configure for blocking */
-        Socket.optSet(clientSocket, Socket.APR_SO_NONBLOCK, 0);
-        Socket.timeoutSet(clientSocket, 2000);
-        start = System.nanoTime();
-        while (Socket.recv(clientSocket, buf, 0, 1) == 1) {
-        }
-        wait = System.nanoTime() - start;
-        Assert.assertFalse("non_blocking client Socket.APR_SO_NONBLOCK false failed (<1ms) [" +
-                wait + "] +-[" + ERROR_MARGIN + "]", wait < 1000000 - ERROR_MARGIN);
-
-        client.countDown();
-        client.join();
-    }
-
-
-    @Test
-    public void testNonBlockingAcceptWithNoClient() throws Exception {
-        Socket.optSet(serverSocket, Socket.APR_SO_NONBLOCK, 1);
-        int val = Socket.optGet(serverSocket, Socket.APR_SO_NONBLOCK);
-        Assert.assertEquals("Socket.optGet serverSocket failed", 1, val);
-
-        long start = System.nanoTime();
-        boolean ok = false;
-        try {
-            Socket.accept(serverSocket);
-        } catch (Exception ex) {
-            ok = true;
-        }
-        long wait = System.nanoTime() - start;
-        Assert.assertTrue("Timeout failed", ok);
-        Assert.assertFalse("non_blocking accept Socket.APR_SO_NONBLOCK failed (>10ms) [" + wait +
-                "] +-[" + ERROR_MARGIN + "]", wait > 10000000 + ERROR_MARGIN);
-    }
-
-
-    /**
-     * Simple client that connects, sends a single byte then closes the
-     * connection.
-     */
-    private static class Client extends java.lang.Thread {
-
-        private final String path;
-        private final CountDownLatch complete = new CountDownLatch(1);
-
-        public Client(String path) throws Exception {
-            this.path = path;
-        }
-
-        public void countDown() {
-            complete.countDown();
-        }
-
-        @Override
-        public void run() {
-
-            long clientPool = Pool.create(0);
-            try {
-
-                long unixAddress = Address.info(path, Socket.APR_UNIX,
-                                                0, 0, clientPool);
-                long clientSocket = Socket.create(Socket.APR_UNIX, Socket.SOCK_STREAM,
-                                                  0, clientPool);
-                int rc = Socket.connect(clientSocket, unixAddress);
-                Assert.assertEquals("Can't connect: " + Error.strerror(rc), 0, rc);
-
-                byte[] buf = new byte[1];
-                buf[0] = 'A';
-
-                Socket.send(clientSocket, buf, 0, 1);
-                complete.await();
-                Socket.close(clientSocket);
-
-            } catch (Exception ex) {
-                ex.printStackTrace();
-            } finally {
-                Pool.destroy(clientPool);
-            }
-
-        }
-    }
-}

==================================================
TestCustomSsl.java
index c581b210c9..b7599914ce 100644
--- a/test/org/apache/tomcat/util/net/TestClientCert.java
+++ b/test/org/apache/tomcat/util/net/TestClientCert.java
@@ -19,7 +19,6 @@ package org.apache.tomcat.util.net;
 import java.util.Arrays;
 
 import org.junit.Assert;
-import org.junit.Assume;
 import org.junit.Test;
 
 import org.apache.catalina.Context;
@@ -45,9 +44,6 @@ public class TestClientCert extends TomcatBaseTest {
     }
 
     private void doTestClientCertGet(boolean preemptive) throws Exception {
-        Assume.assumeTrue("SSL renegotiation has to be supported for this test",
-                TesterSupport.isRenegotiationSupported(getTomcatInstance()));
-
         if (preemptive) {
             Tomcat tomcat = getTomcatInstance();
             // Only one context deployed
@@ -120,9 +116,6 @@ public class TestClientCert extends TomcatBaseTest {
 
     private void doTestClientCertPost(int bodySize, boolean expectProtectedFail)
             throws Exception {
-        Assume.assumeTrue("SSL renegotiation has to be supported for this test",
-                TesterSupport.isRenegotiationSupported(getTomcatInstance()));
-
         getTomcatInstance().start();
 
         byte[] body = new byte[bodySize];

==================================================
TestCustomSslTrustManager.java
index e9bb46d77c..fc458cf14e 100644
--- a/test/org/apache/tomcat/util/net/TestCustomSsl.java
+++ b/test/org/apache/tomcat/util/net/TestCustomSsl.java
@@ -17,8 +17,8 @@
 package org.apache.tomcat.util.net;
 
 import java.io.File;
+
 import org.junit.Assert;
-import org.junit.Assume;
 import org.junit.Test;
 
 import org.apache.catalina.Context;
@@ -45,9 +45,6 @@ public class TestCustomSsl extends TomcatBaseTest {
         Tomcat tomcat = getTomcatInstance();
         Connector connector = tomcat.getConnector();
 
-        Assume.assumeFalse("This test is only for JSSE based SSL connectors",
-                connector.getProtocolHandlerClassName().contains("Apr"));
-
         SSLHostConfig sslHostConfig = new SSLHostConfig();
         SSLHostConfigCertificate certificate = new SSLHostConfigCertificate(sslHostConfig, Type.UNDEFINED);
         sslHostConfig.addCertificate(certificate);

==================================================
TestSSLHostConfigCompat.java
index f2afd93806..f5d4c8dd69 100644
--- a/test/org/apache/tomcat/util/net/TestCustomSslTrustManager.java
+++ b/test/org/apache/tomcat/util/net/TestCustomSslTrustManager.java
@@ -21,7 +21,6 @@ import java.net.SocketException;
 import javax.net.ssl.SSLException;
 
 import org.junit.Assert;
-import org.junit.Assume;
 import org.junit.Test;
 
 import org.apache.catalina.connector.Connector;
@@ -64,9 +63,6 @@ public class TestCustomSslTrustManager extends TomcatBaseTest {
 
         Tomcat tomcat = getTomcatInstance();
 
-        Assume.assumeTrue("SSL renegotiation has to be supported for this test",
-                TesterSupport.isRenegotiationSupported(tomcat));
-
         TesterSupport.configureClientCertContext(tomcat);
 
         Connector connector = tomcat.getConnector();

==================================================
TestXxxEndpoint.java
index e098b54d2d..7e35c8e7c4 100644
--- a/test/org/apache/tomcat/util/net/TestSSLHostConfigCompat.java
+++ b/test/org/apache/tomcat/util/net/TestSSLHostConfigCompat.java
@@ -56,9 +56,6 @@ public class TestSSLHostConfigCompat extends TomcatBaseTest {
 
             parameterSets.add(new Object[] {"NIO-OpenSSL", "org.apache.coyote.http11.Http11NioProtocol",
                     "org.apache.tomcat.util.net.openssl.OpenSSLImplementation", storeType});
-
-            parameterSets.add(new Object[] { "APR/Native", "org.apache.coyote.http11.Http11AprProtocol",
-                    "org.apache.tomcat.util.net.openssl.OpenSSLImplementation", storeType});
         }
 
         return parameterSets;
@@ -323,10 +320,6 @@ public class TestSSLHostConfigCompat extends TomcatBaseTest {
         connector.setScheme("https");
         connector.setSecure(true);
         Assert.assertTrue(connector.setProperty("SSLEnabled", "true"));
-        if (!connector.getProtocolHandlerClassName().contains("Apr")) {
-            // Skip this for APR. It is not supported.
-            Assert.assertTrue(connector.setProperty("sslImplementationName", sslImplementationName));
-        }
         sslHostConfig.setProtocols("TLSv1.2");
         connector.addSslHostConfig(sslHostConfig);
 

==================================================
TesterSupport.java
index f270258087..ea97bf8300 100644
--- a/test/org/apache/tomcat/util/net/TestXxxEndpoint.java
+++ b/test/org/apache/tomcat/util/net/TestXxxEndpoint.java
@@ -30,8 +30,6 @@ import org.junit.Test;
 import org.apache.catalina.connector.Connector;
 import org.apache.catalina.startup.Tomcat;
 import org.apache.catalina.startup.TomcatBaseTest;
-import org.apache.tomcat.jni.Error;
-import org.apache.tomcat.jni.Pool;
 import org.apache.tomcat.util.compat.JreCompat;
 
 /**
@@ -40,81 +38,6 @@ import org.apache.tomcat.util.compat.JreCompat;
  */
 public class TestXxxEndpoint extends TomcatBaseTest {
 
-    private long createAprPool() {
-
-        // Create the pool for the server socket
-        try {
-            return Pool.create(0);
-        } catch (UnsatisfiedLinkError e) {
-            log.error("Could not create socket pool", e);
-            return 0;
-        }
-    }
-
-    /*
-     * @deprecated  The scope of the APR/Native Library will be reduced in Tomcat
-     *              10.1.x onwards to only those components required to provide
-     *              OpenSSL integration with the NIO and NIO2 connectors.
-     */
-    @Deprecated
-    private long createAprSocket(int port, long pool)
-                 throws Exception {
-        /**
-         * Server socket "pointer".
-         */
-        long serverSock = 0;
-
-        String address = InetAddress.getByName("localhost").getHostAddress();
-
-        // Create the APR address that will be bound
-        int family = org.apache.tomcat.jni.Socket.APR_UNSPEC;
-
-        long inetAddress = 0;
-        try {
-            inetAddress = org.apache.tomcat.jni.Address.info(address, family,
-                                       port, 0, pool);
-            // Create the APR server socket
-            serverSock = org.apache.tomcat.jni.Socket.create(org.apache.tomcat.jni.Address.getInfo(inetAddress).family,
-                    org.apache.tomcat.jni.Socket.SOCK_STREAM,
-                    org.apache.tomcat.jni.Socket.APR_PROTO_TCP, pool);
-        } catch (Exception ex) {
-            log.error("Could not create socket for address '" + address + "'");
-            return 0;
-        }
-
-        if (org.apache.tomcat.jni.OS.IS_UNIX) {
-            org.apache.tomcat.jni.Socket.optSet(serverSock, org.apache.tomcat.jni.Socket.APR_SO_REUSEADDR, 1);
-        }
-        // Deal with the firewalls that tend to drop the inactive sockets
-        org.apache.tomcat.jni.Socket.optSet(serverSock, org.apache.tomcat.jni.Socket.APR_SO_KEEPALIVE, 1);
-        // Bind the server socket
-        int ret = org.apache.tomcat.jni.Socket.bind(serverSock, inetAddress);
-        if (ret != 0) {
-            log.error("Could not bind: " + Error.strerror(ret));
-            throw (new Exception(Error.strerror(ret)));
-        }
-        return serverSock;
-    }
-
-    /*
-     * @deprecated  The scope of the APR/Native Library will be reduced in Tomcat
-     *              10.1.x onwards to only those components required to provide
-     *              OpenSSL integration with the NIO and NIO2 connectors.
-     */
-    @Deprecated
-    private void destroyAprSocket(long serverSock, long pool) {
-        if (serverSock != 0) {
-            org.apache.tomcat.jni.Socket.shutdown(serverSock, org.apache.tomcat.jni.Socket.APR_SHUTDOWN_READWRITE);
-            org.apache.tomcat.jni.Socket.close(serverSock);
-            org.apache.tomcat.jni.Socket.destroy(serverSock);
-        }
-
-        if (pool != 0) {
-            Pool.destroy(pool);
-            pool = 0;
-        }
-    }
-
     @Test
     public void testStartStopBindOnInit() throws Exception {
         Tomcat tomcat = getTomcatInstance();
@@ -127,31 +50,9 @@ public class TestXxxEndpoint extends TomcatBaseTest {
 
         tomcat.getConnector().stop();
         Exception e = null;
-        ServerSocket s = null;
-        long pool = 0;
-        long nativeSocket = 0;
-        boolean isApr = tomcat.getConnector().getProtocolHandlerClassName().contains("Apr");
-        try {
-            // This should throw an Exception
-            if (isApr) {
-                pool = createAprPool();
-                Assert.assertTrue(pool != 0);
-                nativeSocket = createAprSocket(port, pool);
-                Assert.assertTrue(nativeSocket != 0);
-            } else {
-                s = new ServerSocket(port, 100,
-                        InetAddress.getByName("localhost"));
-            }
+        try (ServerSocket s = new ServerSocket(port, 100, InetAddress.getByName("localhost"))){
         } catch (Exception e1) {
             e = e1;
-        } finally {
-            try {
-                if (isApr) {
-                    destroyAprSocket(nativeSocket, pool);
-                } else if (s != null) {
-                    s.close();
-                }
-            } catch (Exception e2) { /* Ignore */ }
         }
         if (e != null) {
             log.info("Exception was", e);
@@ -175,31 +76,10 @@ public class TestXxxEndpoint extends TomcatBaseTest {
 
         tomcat.getConnector().stop();
         Exception e = null;
-        ServerSocket s = null;
-        long pool = 0;
-        long nativeSocket = 0;
-        boolean isApr = tomcat.getConnector().getProtocolHandlerClassName().contains("Apr");
-        try {
+        try (ServerSocket s = new ServerSocket(port, 100, InetAddress.getByName("localhost"))) {
             // This should not throw an Exception
-            if (isApr) {
-                pool = createAprPool();
-                Assert.assertTrue(pool != 0);
-                nativeSocket = createAprSocket(port, pool);
-                Assert.assertTrue(nativeSocket != 0);
-            } else {
-                s = new ServerSocket(port, 100,
-                        InetAddress.getByName("localhost"));
-            }
         } catch (Exception e1) {
             e = e1;
-        } finally {
-            try {
-                if (isApr) {
-                    destroyAprSocket(nativeSocket, pool);
-                } else if (s != null) {
-                    s.close();
-                }
-            } catch (Exception e2) { /* Ignore */ }
         }
         Assert.assertNull(e);
         tomcat.getConnector().start();

==================================================
TestOpenSSLConf.java
index b1fca54ae2..8ac02c31d5 100644
--- a/test/org/apache/tomcat/util/net/TesterSupport.java
+++ b/test/org/apache/tomcat/util/net/TesterSupport.java
@@ -147,29 +147,22 @@ public final class TesterSupport {
         sslHostConfig.addCertificate(certificate);
         connector.addSslHostConfig(sslHostConfig);
 
-        String protocol = tomcat.getConnector().getProtocolHandlerClassName();
-        if (!protocol.contains("Apr")) {
-            String sslImplementation = System.getProperty("tomcat.test.sslImplementation");
-            if (sslImplementation != null && !"${test.sslImplementation}".equals(sslImplementation)) {
-                StandardServer server = (StandardServer) tomcat.getServer();
-                AprLifecycleListener listener = new AprLifecycleListener();
-                listener.setSSLRandomSeed("/dev/urandom");
-                server.addLifecycleListener(listener);
-                Assert.assertTrue(connector.setProperty("sslImplementationName", sslImplementation));
-            }
-            sslHostConfig.setSslProtocol("tls");
-            certificate.setCertificateKeystoreFile(new File(keystore).getAbsolutePath());
-            sslHostConfig.setTruststoreFile(new File(CA_JKS).getAbsolutePath());
-            if (keystorePass != null) {
-                certificate.setCertificateKeystorePassword(keystorePass);
-            }
-            if (keyPass != null) {
-                certificate.setCertificateKeyPassword(keyPass);
-            }
-        } else {
-            certificate.setCertificateFile(new File(LOCALHOST_RSA_CERT_PEM).getAbsolutePath());
-            certificate.setCertificateKeyFile(new File(LOCALHOST_RSA_KEY_PEM).getAbsolutePath());
-            sslHostConfig.setCaCertificateFile(new File(CA_CERT_PEM).getAbsolutePath());
+        String sslImplementation = System.getProperty("tomcat.test.sslImplementation");
+        if (sslImplementation != null && !"${test.sslImplementation}".equals(sslImplementation)) {
+            StandardServer server = (StandardServer) tomcat.getServer();
+            AprLifecycleListener listener = new AprLifecycleListener();
+            listener.setSSLRandomSeed("/dev/urandom");
+            server.addLifecycleListener(listener);
+            Assert.assertTrue(connector.setProperty("sslImplementationName", sslImplementation));
+        }
+        sslHostConfig.setSslProtocol("tls");
+        certificate.setCertificateKeystoreFile(new File(keystore).getAbsolutePath());
+        sslHostConfig.setTruststoreFile(new File(CA_JKS).getAbsolutePath());
+        if (keystorePass != null) {
+            certificate.setCertificateKeystorePassword(keystorePass);
+        }
+        if (keyPass != null) {
+            certificate.setCertificateKeyPassword(keyPass);
         }
     }
 
@@ -226,22 +219,8 @@ public final class TesterSupport {
         return ks;
     }
 
-    public static boolean isRenegotiationSupported(Tomcat tomcat) {
-        String protocol = tomcat.getConnector().getProtocolHandlerClassName();
-        if (protocol.contains("Apr")) {
-            // Disabled by default in 1.1.20 windows binary (2010-07-27)
-            return false;
-        }
-
-        return true;
-    }
-
     protected static boolean isClientRenegotiationSupported(Tomcat tomcat) {
         String protocol = tomcat.getConnector().getProtocolHandlerClassName();
-        if (protocol.contains("Apr")) {
-            // Disabled by default in 1.1.20 windows binary (2010-07-27)
-            return false;
-        }
         if (protocol.contains("NioProtocol") || (protocol.contains("Nio2Protocol") && JrePlatform.IS_MAC_OS)) {
             // Doesn't work on all platforms - see BZ 56448.
             return false;

==================================================
TestClose.java
index 5c27feab3c..3eb1f7a762 100644
--- a/test/org/apache/tomcat/util/net/openssl/TestOpenSSLConf.java
+++ b/test/org/apache/tomcat/util/net/openssl/TestOpenSSLConf.java
@@ -57,14 +57,11 @@ public class TestOpenSSLConf extends TomcatBaseTest {
 
         TesterSupport.initSsl(tomcat);
 
-        String protocol = tomcat.getConnector().getProtocolHandlerClassName();
-        // The tests are only supported for APR and OpenSSL
-        if (!protocol.contains("Apr")) {
-            String sslImplementation = String.valueOf(
-                    tomcat.getConnector().getProperty("sslImplementationName"));
-            Assume.assumeTrue("This test is only for OpenSSL based SSL connectors",
-                    sslImplementation.contains("openssl"));
-        }
+        // The tests are only supported for OpenSSL
+        String sslImplementation = String.valueOf(
+                tomcat.getConnector().getProperty("sslImplementationName"));
+        Assume.assumeTrue("This test is only for OpenSSL based SSL connectors",
+                sslImplementation.contains("openssl"));
 
         OpenSSLConf conf = new OpenSSLConf();
         for (int i = 0; i < commands.length;) {

==================================================
