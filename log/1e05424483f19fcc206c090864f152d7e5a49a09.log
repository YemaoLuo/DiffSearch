1e05424483f19fcc206c090864f152d7e5a49a09
==================================================
Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=57441
==================================================
Mark Thomas
==================================================
Thu Jan 22 13:53:26 2015 +0000
==================================================
ELFunctionMapper.java
Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=57441
Fix error when defining functions using lambda expressions in JSPs.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1653857 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Validator.java
index 53cf6d5f73..590fdf7f9a 100644
--- a/java/org/apache/jasper/compiler/ELFunctionMapper.java
+++ b/java/org/apache/jasper/compiler/ELFunctionMapper.java
@@ -220,40 +220,46 @@ public class ELFunctionMapper {
                 ELNode.Function f = functions.get(i);
                 FunctionInfo funcInfo = f.getFunctionInfo();
                 String key = f.getPrefix()+ ":" + f.getName();
-                ds.append(funcMethod + "(\"" + key + "\", " +
-                        getCanonicalName(funcInfo.getFunctionClass()) +
-                        ".class, " + '\"' + f.getMethodName() + "\", " +
-                        "new Class[] {");
-                String params[] = f.getParameters();
-                for (int k = 0; k < params.length; k++) {
-                    if (k != 0) {
-                        ds.append(", ");
-                    }
-                    int iArray = params[k].indexOf('[');
-                    if (iArray < 0) {
-                        ds.append(params[k] + ".class");
-                    }
-                    else {
-                        String baseType = params[k].substring(0, iArray);
-                        ds.append("java.lang.reflect.Array.newInstance(");
-                        ds.append(baseType);
-                        ds.append(".class,");
-
-                        // Count the number of array dimension
-                        int aCount = 0;
-                        for (int jj = iArray; jj < params[k].length(); jj++ ) {
-                            if (params[k].charAt(jj) == '[') {
-                                aCount++;
-                            }
+                if (funcInfo == null) {
+                    // Added via Lambda or ImportHandler. EL will expect a
+                    // function mapper even if one isn't used so just pass null
+                    ds.append(funcMethod + "(null, null, null, null);\n");
+                } else {
+                    ds.append(funcMethod + "(\"" + key + "\", " +
+                            getCanonicalName(funcInfo.getFunctionClass()) +
+                            ".class, " + '\"' + f.getMethodName() + "\", " +
+                            "new Class[] {");
+                    String params[] = f.getParameters();
+                    for (int k = 0; k < params.length; k++) {
+                        if (k != 0) {
+                            ds.append(", ");
                         }
-                        if (aCount == 1) {
-                            ds.append("0).getClass()");
-                        } else {
-                            ds.append("new int[" + aCount + "]).getClass()");
+                        int iArray = params[k].indexOf('[');
+                        if (iArray < 0) {
+                            ds.append(params[k] + ".class");
+                        }
+                        else {
+                            String baseType = params[k].substring(0, iArray);
+                            ds.append("java.lang.reflect.Array.newInstance(");
+                            ds.append(baseType);
+                            ds.append(".class,");
+
+                            // Count the number of array dimension
+                            int aCount = 0;
+                            for (int jj = iArray; jj < params[k].length(); jj++ ) {
+                                if (params[k].charAt(jj) == '[') {
+                                    aCount++;
+                                }
+                            }
+                            if (aCount == 1) {
+                                ds.append("0).getClass()");
+                            } else {
+                                ds.append("new int[" + aCount + "]).getClass()");
+                            }
                         }
                     }
+                    ds.append("});\n");
                 }
-                ds.append("});\n");
                 // Put the current name in the global function map
                 gMap.put(f.getPrefix() + ':' + f.getName() + ':' + f.getUri(),
                          decName);

==================================================
ProtectedFunctionMapper.java
index e0ff49936d..2e8c8461b9 100644
--- a/java/org/apache/jasper/resources/LocalStrings_ja.properties
+++ b/java/org/apache/jasper/resources/LocalStrings_ja.properties
@@ -297,7 +297,6 @@ jsp.error.variable.alias=name-from-attribute\u304a\u3088\u3073alias\u5c5e\u6027\
 jsp.error.attribute.null_name=\u7a7a\u306e\u5c5e\u6027\u540d\u3067\u3059
 jsp.error.jsptext.badcontent=\'&lt;\'\u304c&lt;jsp:text&gt;\u306e\u30dc\u30c7\u30a3\u306e\u4e2d\u306b\u73fe\u308c\u308b\u6642\u306f\u3001CDATA\u306e\u4e2d\u306b\u96a0\u853d\u3057\u306a\u3051\u308c\u3070\u3044\u3051\u307e\u305b\u3093
 jsp.error.jsproot.version.invalid=\u7121\u52b9\u306a\u30d0\u30fc\u30b8\u30e7\u30f3\u756a\u53f7\u3067\u3059: \"{0}\"\u3001\"1.2\"\u3000\"2.0\"\u3000\"2.1\"\u3000\"2.2\" \u53c8\u306f \"2.3\"\u3000\u3067\u306a\u3051\u308c\u3070\u3044\u3051\u307e\u305b\u3093
-jsp.error.noFunctionPrefix=\u30c7\u30d5\u30a9\u30eb\u30c8\u306e\u540d\u524d\u7a7a\u9593\u304c\u6307\u5b9a\u3055\u308c\u3066\u3044\u306a\u3044\u6642\u306b\u306f\u3001\u95a2\u6570 {0} \u306f\u30d7\u30ea\u30d5\u30a3\u30af\u30b9\u4ed8\u304d\u3067\u4f7f\u7528\u3057\u306a\u3051\u308c\u3070\u3044\u3051\u307e\u305b\u3093
 jsp.error.noFunction=\u95a2\u6570 {0} \u3092\u6307\u5b9a\u3055\u308c\u305f\u30d7\u30ea\u30d5\u30a3\u30af\u30b9\u3067\u914d\u7f6e\u3067\u304d\u307e\u305b\u3093
 jsp.error.noFunctionMethod=\u95a2\u6570 \"{1}\" \u306e\u30e1\u30bd\u30c3\u30c9 \"{0}\" \u304c \"{2}\" \u4e2d\u3067\u898b\u3064\u304b\u308a\u307e\u305b\u3093
 jsp.error.function.classnotfound=TLD\u306e\u4e2d\u3067\u95a2\u6570 {1} \u306b\u6307\u5b9a\u3055\u308c\u3066\u3044\u308b\u30af\u30e9\u30b9 {0} \u304c\u898b\u3064\u304b\u308a\u307e\u305b\u3093: {2}

==================================================
TestELInJsp.java
index f83b5a1334..284ba2e901 100644
--- a/java/org/apache/jasper/runtime/ProtectedFunctionMapper.java
+++ b/java/org/apache/jasper/runtime/ProtectedFunctionMapper.java
@@ -97,6 +97,12 @@ public final class ProtectedFunctionMapper extends javax.el.FunctionMapper
      */
     public void mapFunction(String fnQName, final Class<?> c,
             final String methodName, final Class<?>[] args) {
+        // Skip if null values were passed in. They indicate a function
+        // added via a lambda or ImportHandler; nether of which need to be
+        // placed in the Map.
+        if (fnQName == null) {
+            return;
+        }
         java.lang.reflect.Method method;
         if (SecurityUtil.isPackageProtectionEnabled()) {
             try {
@@ -143,7 +149,7 @@ public final class ProtectedFunctionMapper extends javax.el.FunctionMapper
      */
     public static ProtectedFunctionMapper getMapForFunction(String fnQName,
             final Class<?> c, final String methodName, final Class<?>[] args) {
-        java.lang.reflect.Method method;
+        java.lang.reflect.Method method = null;
         ProtectedFunctionMapper funcMapper;
         if (SecurityUtil.isPackageProtectionEnabled()) {
             funcMapper = AccessController.doPrivileged(
@@ -153,28 +159,37 @@ public final class ProtectedFunctionMapper extends javax.el.FunctionMapper
                             return new ProtectedFunctionMapper();
                         }
                     });
-
-            try {
-                method = AccessController.doPrivileged(
-                        new PrivilegedExceptionAction<Method>() {
-                            @Override
-                            public Method run() throws Exception {
-                                return c.getDeclaredMethod(methodName, args);
-                            }
-                        });
-            } catch (PrivilegedActionException ex) {
-                throw new RuntimeException(
-                        "Invalid function mapping - no such method: "
-                                + ex.getException().getMessage());
+            // Skip if null values were passed in. They indicate a function
+            // added via a lambda or ImportHandler; nether of which need to be
+            // placed in the Map.
+            if (fnQName != null) {
+                try {
+                    method = AccessController.doPrivileged(
+                            new PrivilegedExceptionAction<Method>() {
+                                @Override
+                                public Method run() throws Exception {
+                                    return c.getDeclaredMethod(methodName, args);
+                                }
+                            });
+                } catch (PrivilegedActionException ex) {
+                    throw new RuntimeException(
+                            "Invalid function mapping - no such method: "
+                                    + ex.getException().getMessage());
+                }
             }
         } else {
             funcMapper = new ProtectedFunctionMapper();
-            try {
-                method = c.getDeclaredMethod(methodName, args);
-            } catch (NoSuchMethodException e) {
-                throw new RuntimeException(
-                        "Invalid function mapping - no such method: "
-                                + e.getMessage());
+            // Skip if null values were passed in. They indicate a function
+            // added via a lambda or ImportHandler; nether of which need to be
+            // placed in the Map.
+            if (fnQName != null) {
+                try {
+                    method = c.getDeclaredMethod(methodName, args);
+                } catch (NoSuchMethodException e) {
+                    throw new RuntimeException(
+                            "Invalid function mapping - no such method: "
+                                    + e.getMessage());
+                }
             }
         }
         funcMapper.theMethod = method;

==================================================
