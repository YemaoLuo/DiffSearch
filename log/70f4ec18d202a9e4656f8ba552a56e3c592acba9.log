70f4ec18d202a9e4656f8ba552a56e3c592acba9
==================================================
Make method names consistent with the names the digester looks for
==================================================
Mark Emlyn
==================================================
Mon Mar 22 14:23:26 2010 +0000
==================================================
WebXml.java
Make method names consistent with the names the digester looks for

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@926101 13f79535-47bb-0310-9956-ffa450edef68



==================================================
TestWebXmlOrdering.java
index d5e95bf2bb..629e0e4332 100644
--- a/java/org/apache/catalina/deploy/WebXml.java
+++ b/java/org/apache/catalina/deploy/WebXml.java
@@ -84,30 +84,30 @@ public class WebXml {
     // web-fragment.xml only elements
     // Relative ordering
     private Set<String> after = new LinkedHashSet<String>();
-    public void addAfterOrder(String fragmentName) {
+    public void addAfterOrdering(String fragmentName) {
         after.add(fragmentName);
     }
-    public void addAfterOrderOthers() {
+    public void addAfterOrderingOthers() {
         if (before.contains(ORDER_OTHERS)) {
             throw new IllegalArgumentException(sm.getString(
                     "webXml.multipleOther"));
         }
         after.add(ORDER_OTHERS);
     }
-    public Set<String> getAfterOrder() { return after; }
+    public Set<String> getAfterOrdering() { return after; }
     
     private Set<String> before = new LinkedHashSet<String>();
-    public void addBeforeOrder(String fragmentName) {
+    public void addBeforeOrdering(String fragmentName) {
         before.add(fragmentName);
     }
-    public void addBeforeOrderOthers() {
+    public void addBeforeOrderingOthers() {
         if (after.contains(ORDER_OTHERS)) {
             throw new IllegalArgumentException(sm.getString(
                     "webXml.multipleOther"));
         }
         before.add(ORDER_OTHERS);
     }
-    public Set<String> getBeforeOrder() { return before; }
+    public Set<String> getBeforeOrdering() { return before; }
 
     // Common elements and attributes
     
@@ -2080,11 +2080,11 @@ public class WebXml {
             // they specify others
             for (WebXml fragment : fragments.values()) {
                 String name = fragment.getName();
-                if (fragment.getBeforeOrder().contains(WebXml.ORDER_OTHERS)) {
+                if (fragment.getBeforeOrdering().contains(WebXml.ORDER_OTHERS)) {
                     // Move to beginning
                     order.remove(name);
                     order.add(0, name);
-                } else if (fragment.getAfterOrder().contains(WebXml.ORDER_OTHERS)) {
+                } else if (fragment.getAfterOrdering().contains(WebXml.ORDER_OTHERS)) {
                     // Move to end
                     order.remove(name);
                     order.add(name);
@@ -2094,7 +2094,7 @@ public class WebXml {
             // Now apply remaining ordering
             for (WebXml fragment : fragments.values()) {
                 String name = fragment.getName();
-                for (String before : fragment.getBeforeOrder()) {
+                for (String before : fragment.getBeforeOrdering()) {
                     if (!before.equals(WebXml.ORDER_OTHERS) &&
                             order.contains(before) &&
                             order.indexOf(before) < order.indexOf(name)) {
@@ -2102,7 +2102,7 @@ public class WebXml {
                         order.add(order.indexOf(before), name);
                     }
                 }
-                for (String after : fragment.getAfterOrder()) {
+                for (String after : fragment.getAfterOrdering()) {
                     if (!after.equals(WebXml.ORDER_OTHERS) &&
                             order.contains(after) &&
                             order.indexOf(after) > order.indexOf(name)) {
@@ -2116,14 +2116,14 @@ public class WebXml {
             // errors then that indicates circular references
             for (WebXml fragment : fragments.values()) {
                 String name = fragment.getName();
-                for (String before : fragment.getBeforeOrder()) {
+                for (String before : fragment.getBeforeOrdering()) {
                     if (!before.equals(WebXml.ORDER_OTHERS) &&
                             order.contains(before) &&
                             order.indexOf(before) < order.indexOf(name)) {
                         throw new IllegalArgumentException(sm.getString(""));
                     }
                 }
-                for (String after : fragment.getAfterOrder()) {
+                for (String after : fragment.getAfterOrdering()) {
                     if (!after.equals(WebXml.ORDER_OTHERS) &&
                             order.contains(after) &&
                             order.indexOf(after) > order.indexOf(name)) {

==================================================
