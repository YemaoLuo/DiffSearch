7d81989dba126510a833c2fe0af1ae4efc3cf43d
==================================================
Clean-up. Reformatting. No functional change.
==================================================
Mark Thomas
==================================================
Wed Feb 22 18:07:54 2023 +0000
==================================================
ArrayELResolver.java
Clean-up. Reformatting. No functional change.


==================================================
BeanELResolver.java
index 116f164e43..f256a069a6 100644
--- a/java/jakarta/el/ArrayELResolver.java
+++ b/java/jakarta/el/ArrayELResolver.java
@@ -36,8 +36,7 @@ public class ArrayELResolver extends ELResolver {
     /**
      * Creates an instance of the standard array resolver.
      *
-     * @param readOnly  {@code true} if the created instance should be read-only
-     *                  otherwise false.
+     * @param readOnly {@code true} if the created instance should be read-only otherwise false.
      */
     public ArrayELResolver(boolean readOnly) {
         this.readOnly = readOnly;
@@ -56,8 +55,8 @@ public class ArrayELResolver extends ELResolver {
                 // ignore
             }
             /*
-             * The resolver may have been created in read-only mode but the
-             * array and its elements will always be read-write.
+             * The resolver may have been created in read-only mode but the array and its elements will always be
+             * read-write.
              */
             if (readOnly) {
                 return null;
@@ -85,24 +84,21 @@ public class ArrayELResolver extends ELResolver {
     }
 
     @Override
-    public void setValue(ELContext context, Object base, Object property,
-            Object value) {
+    public void setValue(ELContext context, Object base, Object property, Object value) {
         Objects.requireNonNull(context);
 
         if (base != null && base.getClass().isArray()) {
             context.setPropertyResolved(base, property);
 
             if (this.readOnly) {
-                throw new PropertyNotWritableException(Util.message(context,
-                        "resolverNotWritable", base.getClass().getName()));
+                throw new PropertyNotWritableException(
+                        Util.message(context, "resolverNotWritable", base.getClass().getName()));
             }
 
             int idx = coerce(property);
             checkBounds(base, idx);
-            if (value != null && !Util.isAssignableFrom(value.getClass(),
-                    base.getClass().getComponentType())) {
-                throw new ClassCastException(Util.message(context,
-                        "objectNotAssignable", value.getClass().getName(),
+            if (value != null && !Util.isAssignableFrom(value.getClass(), base.getClass().getComponentType())) {
+                throw new ClassCastException(Util.message(context, "objectNotAssignable", value.getClass().getName(),
                         base.getClass().getComponentType().getName()));
             }
             Array.set(base, idx, value);
@@ -136,8 +132,7 @@ public class ArrayELResolver extends ELResolver {
 
     private static void checkBounds(Object base, int idx) {
         if (idx < 0 || idx >= Array.getLength(base)) {
-            throw new PropertyNotFoundException(
-                    new ArrayIndexOutOfBoundsException(idx).getMessage());
+            throw new PropertyNotFoundException(new ArrayIndexOutOfBoundsException(idx).getMessage());
         }
     }
 
@@ -154,8 +149,7 @@ public class ArrayELResolver extends ELResolver {
         if (property instanceof String) {
             return Integer.parseInt((String) property);
         }
-        throw new IllegalArgumentException(property != null ?
-                property.toString() : "null");
+        throw new IllegalArgumentException(property != null ? property.toString() : "null");
     }
 
 }

==================================================
BeanNameELResolver.java
index 4a5e93cb31..80d46e171f 100644
--- a/java/jakarta/el/BeanELResolver.java
+++ b/java/jakarta/el/BeanELResolver.java
@@ -54,8 +54,7 @@ public class BeanELResolver extends ELResolver {
     /**
      * Creates an instance of the standard JavaBean resolver.
      *
-     * @param readOnly  {@code true} if the created instance should be read-only
-     *                  otherwise false.
+     * @param readOnly {@code true} if the created instance should be read-only otherwise false.
      */
     public BeanELResolver(boolean readOnly) {
         this.readOnly = readOnly;
@@ -92,16 +91,15 @@ public class BeanELResolver extends ELResolver {
         } catch (InvocationTargetException e) {
             Throwable cause = e.getCause();
             Util.handleThrowable(cause);
-            throw new ELException(Util.message(context, "propertyReadError",
-                    base.getClass().getName(), property.toString()), cause);
+            throw new ELException(
+                    Util.message(context, "propertyReadError", base.getClass().getName(), property.toString()), cause);
         } catch (Exception e) {
             throw new ELException(e);
         }
     }
 
     @Override
-    public void setValue(ELContext context, Object base, Object property,
-            Object value) {
+    public void setValue(ELContext context, Object base, Object property, Object value) {
         Objects.requireNonNull(context);
         if (base == null || property == null) {
             return;
@@ -110,8 +108,8 @@ public class BeanELResolver extends ELResolver {
         context.setPropertyResolved(base, property);
 
         if (this.readOnly) {
-            throw new PropertyNotWritableException(Util.message(context,
-                    "resolverNotWritable", base.getClass().getName()));
+            throw new PropertyNotWritableException(
+                    Util.message(context, "resolverNotWritable", base.getClass().getName()));
         }
 
         Method m = this.property(context, base, property).write(context, base);
@@ -120,8 +118,8 @@ public class BeanELResolver extends ELResolver {
         } catch (InvocationTargetException e) {
             Throwable cause = e.getCause();
             Util.handleThrowable(cause);
-            throw new ELException(Util.message(context, "propertyWriteError",
-                    base.getClass().getName(), property.toString()), cause);
+            throw new ELException(
+                    Util.message(context, "propertyWriteError", base.getClass().getName(), property.toString()), cause);
         } catch (Exception e) {
             throw new ELException(e);
         }
@@ -131,8 +129,7 @@ public class BeanELResolver extends ELResolver {
      * @since EL 2.2
      */
     @Override
-    public Object invoke(ELContext context, Object base, Object method,
-            Class<?>[] paramTypes, Object[] params) {
+    public Object invoke(ELContext context, Object base, Object method, Class<?>[] paramTypes, Object[] params) {
         Objects.requireNonNull(context);
         if (base == null || method == null) {
             return null;
@@ -145,8 +142,8 @@ public class BeanELResolver extends ELResolver {
         // Find the matching method
         Method matchingMethod = Util.findMethod(context, base.getClass(), base, methodName, paramTypes, params);
 
-        Object[] parameters = Util.buildParameters(
-                context, matchingMethod.getParameterTypes(), matchingMethod.isVarArgs(), params);
+        Object[] parameters = Util.buildParameters(context, matchingMethod.getParameterTypes(),
+                matchingMethod.isVarArgs(), params);
 
         Object result = null;
         try {
@@ -194,7 +191,7 @@ public class BeanELResolver extends ELResolver {
             try {
                 BeanInfo info = Introspector.getBeanInfo(this.type);
                 PropertyDescriptor[] pds = info.getPropertyDescriptors();
-                for (PropertyDescriptor pd: pds) {
+                for (PropertyDescriptor pd : pds) {
                     this.properties.put(pd.getName(), new BeanProperty(type, pd));
                 }
                 /*
@@ -214,8 +211,7 @@ public class BeanELResolver extends ELResolver {
                     PropertyDescriptor[] pds = info.getPropertyDescriptors();
                     for (PropertyDescriptor pd : pds) {
                         if (!this.properties.containsKey(pd.getName())) {
-                            this.properties.put(pd.getName(), new BeanProperty(
-                                    this.type, pd));
+                            this.properties.put(pd.getName(), new BeanProperty(this.type, pd));
                         }
                     }
                     populateFromInterfaces(ifs);
@@ -230,8 +226,7 @@ public class BeanELResolver extends ELResolver {
         private BeanProperty get(ELContext ctx, String name) {
             BeanProperty property = this.properties.get(name);
             if (property == null) {
-                throw new PropertyNotFoundException(Util.message(ctx,
-                        "propertyNotFound", type.getName(), name));
+                throw new PropertyNotFoundException(Util.message(ctx, "propertyNotFound", type.getName(), name));
             }
             return property;
         }
@@ -271,9 +266,8 @@ public class BeanELResolver extends ELResolver {
             if (this.write == null) {
                 this.write = Util.getMethod(this.owner, base, descriptor.getWriteMethod());
                 if (this.write == null) {
-                    throw new PropertyNotWritableException(Util.message(ctx,
-                            "propertyNotWritable", new Object[] {
-                                    owner.getName(), descriptor.getName() }));
+                    throw new PropertyNotWritableException(Util.message(ctx, "propertyNotWritable",
+                            new Object[] { owner.getName(), descriptor.getName() }));
                 }
             }
             return this.write;
@@ -283,17 +277,15 @@ public class BeanELResolver extends ELResolver {
             if (this.read == null) {
                 this.read = Util.getMethod(this.owner, base, descriptor.getReadMethod());
                 if (this.read == null) {
-                    throw new PropertyNotFoundException(Util.message(ctx,
-                            "propertyNotReadable", new Object[] {
-                                    owner.getName(), descriptor.getName() }));
+                    throw new PropertyNotFoundException(Util.message(ctx, "propertyNotReadable",
+                            new Object[] { owner.getName(), descriptor.getName() }));
                 }
             }
             return this.read;
         }
     }
 
-    private BeanProperty property(ELContext ctx, Object base,
-            Object property) {
+    private BeanProperty property(ELContext ctx, Object base, Object property) {
         Class<?> type = base.getClass();
         String prop = property.toString();
 
@@ -306,11 +298,11 @@ public class BeanELResolver extends ELResolver {
         return props.get(ctx, prop);
     }
 
-    private static final class ConcurrentCache<K,V> {
+    private static final class ConcurrentCache<K, V> {
 
         private final int size;
-        private final Map<K,V> eden;
-        private final Map<K,V> longterm;
+        private final Map<K, V> eden;
+        private final Map<K, V> longterm;
 
         ConcurrentCache(int size) {
             this.size = size;

==================================================
BeanNameResolver.java
index bb8a93a977..9ef745150a 100644
--- a/java/jakarta/el/BeanNameELResolver.java
+++ b/java/jakarta/el/BeanNameELResolver.java
@@ -53,8 +53,7 @@ public class BeanNameELResolver extends ELResolver {
     }
 
     @Override
-    public void setValue(ELContext context, Object base, Object property,
-            Object value) {
+    public void setValue(ELContext context, Object base, Object property, Object value) {
         Objects.requireNonNull(context);
         if (base != null || !(property instanceof String)) {
             return;
@@ -75,12 +74,10 @@ public class BeanNameELResolver extends ELResolver {
         }
 
         if (isReadOnly) {
-            throw new PropertyNotWritableException(Util.message(context,
-                    "beanNameELResolver.beanReadOnly", beanName));
+            throw new PropertyNotWritableException(Util.message(context, "beanNameELResolver.beanReadOnly", beanName));
         }
 
-        if (beanNameResolver.isNameResolved(beanName) ||
-                beanNameResolver.canCreateBean(beanName)) {
+        if (beanNameResolver.isNameResolved(beanName) || beanNameResolver.canCreateBean(beanName)) {
             try {
                 beanNameResolver.setBeanValue(beanName, value);
                 context.setPropertyResolved(base, property);

==================================================
CompositeELResolver.java
index fbf60f31ef..17754a1553 100644
--- a/java/jakarta/el/BeanNameResolver.java
+++ b/java/jakarta/el/BeanNameResolver.java
@@ -17,8 +17,8 @@
 package jakarta.el;
 
 /**
- * Base implementation that provides a minimal default implementation that is
- * intended to be extended by application developers.
+ * Base implementation that provides a minimal default implementation that is intended to be extended by application
+ * developers.
  *
  * @since EL 3.0
  */
@@ -49,17 +49,15 @@ public abstract class BeanNameResolver {
 
 
     /**
-     * Sets a value of a bean of the given name. If the named bean does not
-     * exist and {@link #canCreateBean} returns <code>true</code> then a bean
-     * is created with the given value.
+     * Sets a value of a bean of the given name. If the named bean does not exist and {@link #canCreateBean} returns
+     * <code>true</code> then a bean is created with the given value.
      *
      * @param beanName The name of the bean to be set/create
      * @param value    The value of the bean to set/create
      *
      * @throws PropertyNotWritableException if the bean is read only
      */
-    public void setBeanValue(String beanName, Object value)
-            throws PropertyNotWritableException {
+    public void setBeanValue(String beanName, Object value) throws PropertyNotWritableException {
         throw new PropertyNotWritableException();
     }
 
@@ -69,8 +67,7 @@ public abstract class BeanNameResolver {
      *
      * @param beanName The name of the bean of interest
      *
-     * @return <code>true</code> if the bean is read only, otherwise
-     *         <code>false</code>
+     * @return <code>true</code> if the bean is read only, otherwise <code>false</code>
      */
     public boolean isReadOnly(String beanName) {
         return true;
@@ -82,8 +79,7 @@ public abstract class BeanNameResolver {
      *
      * @param beanName The name of the bean of interest
      *
-     * @return <code>true</code> if the bean may be created, otherwise
-     *         <code>false</code>
+     * @return <code>true</code> if the bean may be created, otherwise <code>false</code>
      */
     public boolean canCreateBean(String beanName) {
         return false;

==================================================
ELContext.java
index 2190ac869e..4c844371d6 100644
--- a/java/jakarta/el/CompositeELResolver.java
+++ b/java/jakarta/el/CompositeELResolver.java
@@ -68,8 +68,7 @@ public class CompositeELResolver extends ELResolver {
      * @since EL 2.2
      */
     @Override
-    public Object invoke(ELContext context, Object base, Object method,
-            Class<?>[] paramTypes, Object[] params) {
+    public Object invoke(ELContext context, Object base, Object method, Class<?>[] paramTypes, Object[] params) {
         context.setPropertyResolved(false);
         int sz = this.size;
         for (int i = 0; i < sz; i++) {

==================================================
ELContextListener.java
index 6ef3001423..0f6d221cc9 100644
--- a/java/jakarta/el/ELContext.java
+++ b/java/jakarta/el/ELContext.java
@@ -38,7 +38,7 @@ public abstract class ELContext {
 
     private List<EvaluationListener> listeners;
 
-    private Deque<Map<String,Object>> lambdaArguments = new ArrayDeque<>();
+    private Deque<Map<String, Object>> lambdaArguments = new ArrayDeque<>();
 
     public ELContext() {
         this.resolved = false;
@@ -71,8 +71,7 @@ public abstract class ELContext {
      * @param key           The key under which to store the object
      * @param contextObject The object to add
      *
-     * @throws NullPointerException
-     *              If the supplied key or context is <code>null</code>
+     * @throws NullPointerException If the supplied key or context is <code>null</code>
      */
     public void putContext(Class<?> key, Object contextObject) {
         Objects.requireNonNull(key);
@@ -92,8 +91,7 @@ public abstract class ELContext {
      *
      * @return The value of the context object associated with the given key
      *
-     * @throws NullPointerException
-     *              If the supplied key is <code>null</code>
+     * @throws NullPointerException If the supplied key is <code>null</code>
      */
     public Object getContext(Class<?> key) {
         Objects.requireNonNull(key);
@@ -106,8 +104,7 @@ public abstract class ELContext {
     public abstract ELResolver getELResolver();
 
     /**
-     * Obtain the ImportHandler for this ELContext, creating one if necessary.
-     * This method is not thread-safe.
+     * Obtain the ImportHandler for this ELContext, creating one if necessary. This method is not thread-safe.
      *
      * @return the ImportHandler for this ELContext.
      *
@@ -226,18 +223,17 @@ public abstract class ELContext {
     }
 
     /**
-     * Determine if the specified name is recognised as the name of a lambda
-     * argument.
+     * Determine if the specified name is recognised as the name of a lambda argument.
      *
      * @param name The name of the lambda argument
      *
-     * @return <code>true</code> if the name is recognised as the name of a
-     *         lambda argument, otherwise <code>false</code>
+     * @return <code>true</code> if the name is recognised as the name of a lambda argument, otherwise
+     *             <code>false</code>
      *
      * @since EL 3.0
      */
     public boolean isLambdaArgument(String name) {
-        for (Map<String,Object> arguments : lambdaArguments) {
+        for (Map<String, Object> arguments : lambdaArguments) {
             if (arguments.containsKey(name)) {
                 return true;
             }
@@ -255,7 +251,7 @@ public abstract class ELContext {
      * @since EL 3.0
      */
     public Object getLambdaArgument(String name) {
-        for (Map<String,Object> arguments : lambdaArguments) {
+        for (Map<String, Object> arguments : lambdaArguments) {
             Object result = arguments.get(name);
             if (result != null) {
                 return result;
@@ -265,20 +261,19 @@ public abstract class ELContext {
     }
 
     /**
-     * Called when starting to evaluate a lambda expression so that the
-     * arguments are available to the EL context during evaluation.
+     * Called when starting to evaluate a lambda expression so that the arguments are available to the EL context during
+     * evaluation.
+     *
+     * @param arguments The arguments in scope for the current lambda expression.
      *
-     * @param arguments The arguments in scope for the current lambda
-     *                  expression.
      * @since EL 3.0
      */
-    public void enterLambdaScope(Map<String,Object> arguments) {
+    public void enterLambdaScope(Map<String, Object> arguments) {
         lambdaArguments.push(arguments);
     }
 
     /**
-     * Called after evaluating a lambda expression to signal that the arguments
-     * are no longer required.
+     * Called after evaluating a lambda expression to signal that the arguments are no longer required.
      *
      * @since EL 3.0
      */
@@ -290,14 +285,12 @@ public abstract class ELContext {
      * Coerce the supplied object to the requested type.
      *
      * @param <T>  The type to which the object should be coerced
-     *
      * @param obj  The object to be coerced
      * @param type The type to which the object should be coerced
      *
      * @return An instance of the requested type.
      *
-     * @throws ELException
-     *              If the conversion fails
+     * @throws ELException If the conversion fails
      *
      * @since EL 3.0
      */

==================================================
ELException.java
index 99da2c7514..9c7f735607 100644
--- a/java/jakarta/el/ELContextListener.java
+++ b/java/jakarta/el/ELContextListener.java
@@ -18,7 +18,6 @@ package jakarta.el;
 
 /**
  * @author Jacob Hookom [jacob/hookom.net]
- *
  */
 public interface ELContextListener extends java.util.EventListener {
 

==================================================
ELManager.java
index 225a02343a..ab18aeeef6 100644
--- a/java/jakarta/el/ELException.java
+++ b/java/jakarta/el/ELException.java
@@ -17,8 +17,7 @@
 package jakarta.el;
 
 /**
- * Represents any of the exception conditions that can arise during expression
- * evaluation.
+ * Represents any of the exception conditions that can arise during expression evaluation.
  *
  * @since 2.1
  */
@@ -36,8 +35,7 @@ public class ELException extends RuntimeException {
     /**
      * Creates an ELException with the provided detail message.
      *
-     * @param message
-     *            the detail message
+     * @param message the detail message
      */
     public ELException(String message) {
         super(message);
@@ -46,8 +44,7 @@ public class ELException extends RuntimeException {
     /**
      * Creates an ELException with the given cause
      *
-     * @param cause
-     *            the originating cause of this exception
+     * @param cause the originating cause of this exception
      */
     public ELException(Throwable cause) {
         super(cause);
@@ -56,10 +53,8 @@ public class ELException extends RuntimeException {
     /**
      * Creates an ELException with the given detail message and root cause.
      *
-     * @param message
-     *            the detail message
-     * @param cause
-     *            the originating cause of this exception
+     * @param message the detail message
+     * @param cause   the originating cause of this exception
      */
     public ELException(String message, Throwable cause) {
         super(message, cause);

==================================================
ELProcessor.java
index 362368894c..b3787bbd3e 100644
--- a/java/jakarta/el/ELManager.java
+++ b/java/jakarta/el/ELManager.java
@@ -53,16 +53,14 @@ public class ELManager {
     }
 
     public void mapFunction(String prefix, String function, Method method) {
-        getELContext().getFunctionMapper().mapFunction(
-                prefix, function, method);
+        getELContext().getFunctionMapper().mapFunction(prefix, function, method);
     }
 
     public void setVariable(String variable, ValueExpression expression) {
         getELContext().getVariableMapper().setVariable(variable, expression);
     }
 
-    public void importStatic(String staticMemberName)
-            throws jakarta.el.ELException {
+    public void importStatic(String staticMemberName) throws jakarta.el.ELException {
         getELContext().getImportHandler().importStatic(staticMemberName);
     }
 
@@ -75,7 +73,7 @@ public class ELManager {
     }
 
     public Object defineBean(String name, Object bean) {
-        Map<String,Object> localBeans = getELContext().getLocalBeans();
+        Map<String, Object> localBeans = getELContext().getLocalBeans();
 
         if (bean == null) {
             return localBeans.remove(name);

==================================================
ELResolver.java
index c602ad8868..7653413f2b 100644
--- a/java/jakarta/el/ELProcessor.java
+++ b/java/jakarta/el/ELProcessor.java
@@ -58,15 +58,13 @@ public class ELProcessor {
 
 
     public <T> T getValue(String expression, Class<T> expectedType) {
-        ValueExpression ve = factory.createValueExpression(
-                context, bracket(expression), expectedType);
+        ValueExpression ve = factory.createValueExpression(context, bracket(expression), expectedType);
         return ve.getValue(context);
     }
 
 
     public void setValue(String expression, Object value) {
-        ValueExpression ve = factory.createValueExpression(
-                context, bracket(expression), Object.class);
+        ValueExpression ve = factory.createValueExpression(context, bracket(expression), Object.class);
         ve.setValue(context, value);
     }
 
@@ -75,21 +73,17 @@ public class ELProcessor {
         if (expression == null) {
             manager.setVariable(variable, null);
         } else {
-            ValueExpression ve = factory.createValueExpression(
-                    context, bracket(expression), Object.class);
+            ValueExpression ve = factory.createValueExpression(context, bracket(expression), Object.class);
             manager.setVariable(variable, ve);
         }
     }
 
 
-    public void defineFunction(String prefix, String function, String className,
-            String methodName) throws ClassNotFoundException,
-            NoSuchMethodException {
+    public void defineFunction(String prefix, String function, String className, String methodName)
+            throws ClassNotFoundException, NoSuchMethodException {
 
-        if (prefix == null || function == null || className == null ||
-                methodName == null) {
-            throw new NullPointerException(Util.message(
-                    context, "elProcessor.defineFunctionNullParams"));
+        if (prefix == null || function == null || className == null || methodName == null) {
+            throw new NullPointerException(Util.message(context, "elProcessor.defineFunctionNullParams"));
         }
 
         // Check the imports
@@ -100,12 +94,11 @@ public class ELProcessor {
         }
 
         if (!Modifier.isPublic(clazz.getModifiers())) {
-            throw new ClassNotFoundException(Util.message(context,
-                    "elProcessor.defineFunctionInvalidClass", className));
+            throw new ClassNotFoundException(
+                    Util.message(context, "elProcessor.defineFunctionInvalidClass", className));
         }
 
-        MethodSignature sig =
-                new MethodSignature(context, methodName, className);
+        MethodSignature sig = new MethodSignature(context, methodName, className);
 
         if (function.length() == 0) {
             function = sig.getName();
@@ -140,7 +133,7 @@ public class ELProcessor {
                     if (types.length == typeNames.length) {
                         boolean match = true;
                         for (int i = 0; i < types.length; i++) {
-                            if (i == types.length -1 && method.isVarArgs()) {
+                            if (i == types.length - 1 && method.isVarArgs()) {
                                 String typeName = typeNames[i];
                                 if (typeName.endsWith("...")) {
                                     typeName = typeName.substring(0, typeName.length() - 3);
@@ -164,38 +157,33 @@ public class ELProcessor {
             }
         }
 
-        throw new NoSuchMethodException(Util.message(context,
-                "elProcessor.defineFunctionNoMethod", methodName, className));
+        throw new NoSuchMethodException(
+                Util.message(context, "elProcessor.defineFunctionNoMethod", methodName, className));
     }
 
 
     /**
      * Map a method to a function name.
      *
-     * @param prefix    Function prefix
-     * @param function  Function name
-     * @param method    Method
+     * @param prefix   Function prefix
+     * @param function Function name
+     * @param method   Method
      *
-     * @throws NullPointerException
-     *              If any of the arguments are null
-     * @throws NoSuchMethodException
-     *              If the method is not static
+     * @throws NullPointerException  If any of the arguments are null
+     * @throws NoSuchMethodException If the method is not static
      */
-    public void defineFunction(String prefix, String function, Method method)
-            throws java.lang.NoSuchMethodException {
+    public void defineFunction(String prefix, String function, Method method) throws java.lang.NoSuchMethodException {
 
         if (prefix == null || function == null || method == null) {
-            throw new NullPointerException(Util.message(
-                    context, "elProcessor.defineFunctionNullParams"));
+            throw new NullPointerException(Util.message(context, "elProcessor.defineFunctionNullParams"));
         }
 
         int modifiers = method.getModifiers();
 
         // Check for static, public method and module access
         if (!Modifier.isStatic(modifiers) || !Util.canAccess(null, method)) {
-            throw new NoSuchMethodException(Util.message(context,
-                    "elProcessor.defineFunctionInvalidMethod", method.getName(),
-                    method.getDeclaringClass().getName()));
+            throw new NoSuchMethodException(Util.message(context, "elProcessor.defineFunctionInvalidMethod",
+                    method.getName(), method.getDeclaringClass().getName()));
         }
 
         manager.mapFunction(prefix, function, method);
@@ -216,8 +204,7 @@ public class ELProcessor {
         private final String name;
         private final String[] parameterTypeNames;
 
-        MethodSignature(ELContext context, String methodName,
-                String className) throws NoSuchMethodException {
+        MethodSignature(ELContext context, String methodName, String className) throws NoSuchMethodException {
 
             int paramIndex = methodName.indexOf('(');
 
@@ -245,8 +232,7 @@ public class ELProcessor {
                 // We know the params start with '(', check they end with ')'
                 if (!paramString.endsWith(")")) {
                     throw new NoSuchMethodException(Util.message(context,
-                            "elProcessor.defineFunctionInvalidParameterList",
-                            paramString, methodName, className));
+                            "elProcessor.defineFunctionInvalidParameterList", paramString, methodName, className));
                 }
                 // Trim '(' and ')'
                 paramString = paramString.substring(1, paramString.length() - 1).trim();
@@ -260,11 +246,10 @@ public class ELProcessor {
                         int dimension = 0;
                         int bracketPos = parameterTypeName.indexOf('[');
                         if (bracketPos > -1) {
-                            String parameterTypeNameOnly =
-                                    parameterTypeName.substring(0, bracketPos).trim();
+                            String parameterTypeNameOnly = parameterTypeName.substring(0, bracketPos).trim();
                             while (bracketPos > -1) {
                                 dimension++;
-                                bracketPos = parameterTypeName.indexOf('[', bracketPos+ 1);
+                                bracketPos = parameterTypeName.indexOf('[', bracketPos + 1);
                             }
                             parameterTypeName = parameterTypeNameOnly;
                         }
@@ -272,14 +257,12 @@ public class ELProcessor {
                         if (parameterTypeName.endsWith("...")) {
                             varArgs = true;
                             dimension = 1;
-                            parameterTypeName = parameterTypeName.substring(
-                                    0, parameterTypeName.length() -3).trim();
+                            parameterTypeName = parameterTypeName.substring(0, parameterTypeName.length() - 3).trim();
                         }
                         boolean isPrimitive = PRIMITIVES.contains(parameterTypeName);
                         if (isPrimitive && dimension > 0) {
                             // When in an array, class name changes for primitive
-                            switch(parameterTypeName)
-                            {
+                            switch (parameterTypeName) {
                                 case "boolean":
                                     parameterTypeName = "Z";
                                     break;
@@ -308,16 +291,12 @@ public class ELProcessor {
                                     // Should never happen
                                     break;
                             }
-                        } else  if (!isPrimitive &&
-                                !parameterTypeName.contains(".")) {
-                            Class<?> clazz = importHandler.resolveClass(
-                                    parameterTypeName);
+                        } else if (!isPrimitive && !parameterTypeName.contains(".")) {
+                            Class<?> clazz = importHandler.resolveClass(parameterTypeName);
                             if (clazz == null) {
-                                throw new NoSuchMethodException(Util.message(
-                                        context,
-                                        "elProcessor.defineFunctionInvalidParameterTypeName",
-                                        parameterTypeNames[i], methodName,
-                                        className));
+                                throw new NoSuchMethodException(
+                                        Util.message(context, "elProcessor.defineFunctionInvalidParameterTypeName",
+                                                parameterTypeNames[i], methodName, className));
                             }
                             parameterTypeName = clazz.getName();
                         }
@@ -351,9 +330,8 @@ public class ELProcessor {
         }
 
         /**
-         * @return <code>null</code> if just the method name was specified, an
-         *         empty List if an empty parameter list was specified - i.e. ()
-         *         - otherwise an ordered list of parameter type names
+         * @return <code>null</code> if just the method name was specified, an empty List if an empty parameter list was
+         *             specified - i.e. () - otherwise an ordered list of parameter type names
          */
         public String[] getParamTypeNames() {
             return parameterTypeNames;

==================================================
EvaluationListener.java
index f33d3dd25e..49f6a5a105 100644
--- a/java/jakarta/el/ELResolver.java
+++ b/java/jakarta/el/ELResolver.java
@@ -18,7 +18,6 @@ package jakarta.el;
 
 /**
  * @author Jacob Hookom [jacob/hookom.net]
- *
  */
 public abstract class ELResolver {
 
@@ -27,28 +26,24 @@ public abstract class ELResolver {
     public static final String RESOLVABLE_AT_DESIGN_TIME = "resolvableAtDesignTime";
 
     /**
-     * Obtain the value of the given property on the given object using the
-     * given context.
+     * Obtain the value of the given property on the given object using the given context.
      *
-     * @param context The EL context for this evaluation
-     * @param base The base object on which the property is to be found
+     * @param context  The EL context for this evaluation
+     * @param base     The base object on which the property is to be found
      * @param property The property whose value is to be returned
+     *
      * @return the value of the provided property
-     * @throws NullPointerException
-     *              If the supplied context is <code>null</code>
-     * @throws PropertyNotFoundException
-     *              If the base/property combination provided to the resolver is
-     *              one that the resolver can handle but no match was found or a
-     *              match was found but was not readable
-     * @throws ELException
-     *              Wraps any exception throw whilst resolving the property
+     *
+     * @throws NullPointerException      If the supplied context is <code>null</code>
+     * @throws PropertyNotFoundException If the base/property combination provided to the resolver is one that the
+     *                                       resolver can handle but no match was found or a match was found but was not
+     *                                       readable
+     * @throws ELException               Wraps any exception throw whilst resolving the property
      */
-    public abstract Object getValue(ELContext context, Object base,
-            Object property);
+    public abstract Object getValue(ELContext context, Object base, Object property);
 
     /**
-     * Invokes a method on the the given object. This default implementation
-     * always returns <code>null</code>.
+     * Invokes a method on the the given object. This default implementation always returns <code>null</code>.
      *
      * @param context    The EL context for this evaluation
      * @param base       The base object on which the method is to be found
@@ -60,91 +55,74 @@ public abstract class ELResolver {
      *
      * @since EL 2.2
      */
-    public Object invoke(ELContext context, Object base, Object method,
-            Class<?>[] paramTypes, Object[] params) {
+    public Object invoke(ELContext context, Object base, Object method, Class<?>[] paramTypes, Object[] params) {
         return null;
     }
 
     /**
-     * Obtain the type of the given property on the given object using the given
-     * context.
+     * Obtain the type of the given property on the given object using the given context.
      *
-     * @param context The EL context for this evaluation
-     * @param base The base object on which the property is to be found
+     * @param context  The EL context for this evaluation
+     * @param base     The base object on which the property is to be found
      * @param property The property whose type is to be returned
+     *
      * @return the type of the provided property
-     * @throws NullPointerException
-     *              If the supplied context is <code>null</code>
-     * @throws PropertyNotFoundException
-     *              If the base/property combination provided to the resolver is
-     *              one that the resolver can handle but no match was found or a
-     *              match was found but was not readable
-     * @throws ELException
-     *              Wraps any exception throw whilst resolving the property
+     *
+     * @throws NullPointerException      If the supplied context is <code>null</code>
+     * @throws PropertyNotFoundException If the base/property combination provided to the resolver is one that the
+     *                                       resolver can handle but no match was found or a match was found but was not
+     *                                       readable
+     * @throws ELException               Wraps any exception throw whilst resolving the property
      */
-    public abstract Class<?> getType(ELContext context, Object base,
-            Object property);
+    public abstract Class<?> getType(ELContext context, Object base, Object property);
 
     /**
-     * Set the value of the given property on the given object using the given
-     * context.
+     * Set the value of the given property on the given object using the given context.
      *
      * @param context  The EL context for this evaluation
      * @param base     The base object on which the property is to be found
      * @param property The property whose value is to be set
      * @param value    The value to set the property to
-     * @throws NullPointerException
-     *              If the supplied context is <code>null</code>
-     * @throws PropertyNotFoundException
-     *              If the base/property combination provided to the resolver is
-     *              one that the resolver can handle but no match was found
-     * @throws PropertyNotWritableException
-     *              If the base/property combination provided to the resolver is
-     *              one that the resolver can handle but the property was not
-     *              writable
-     * @throws ELException
-     *              Wraps any exception throw whilst resolving the property
+     *
+     * @throws NullPointerException         If the supplied context is <code>null</code>
+     * @throws PropertyNotFoundException    If the base/property combination provided to the resolver is one that the
+     *                                          resolver can handle but no match was found
+     * @throws PropertyNotWritableException If the base/property combination provided to the resolver is one that the
+     *                                          resolver can handle but the property was not writable
+     * @throws ELException                  Wraps any exception throw whilst resolving the property
      */
-    public abstract void setValue(ELContext context, Object base,
-            Object property, Object value);
+    public abstract void setValue(ELContext context, Object base, Object property, Object value);
 
     /**
-     * Determine if the given property on the given object is read-only using
-     * the given context.
+     * Determine if the given property on the given object is read-only using the given context.
      *
-     * @param context The EL context for this evaluation
-     * @param base The base object on which the property is to be found
+     * @param context  The EL context for this evaluation
+     * @param base     The base object on which the property is to be found
      * @param property The property to be checked for read only status
-     * @return <code>true</code> if the identified property is read only,
-     *         otherwise <code>false</code>
-     * @throws NullPointerException
-     *              If the supplied context is <code>null</code>
-     * @throws PropertyNotFoundException
-     *              If the base/property combination provided to the resolver is
-     *              one that the resolver can handle but no match was found
-     * @throws ELException
-     *              Wraps any exception throw whilst resolving the property
+     *
+     * @return <code>true</code> if the identified property is read only, otherwise <code>false</code>
+     *
+     * @throws NullPointerException      If the supplied context is <code>null</code>
+     * @throws PropertyNotFoundException If the base/property combination provided to the resolver is one that the
+     *                                       resolver can handle but no match was found
+     * @throws ELException               Wraps any exception throw whilst resolving the property
      */
-    public abstract boolean isReadOnly(ELContext context, Object base,
-            Object property);
+    public abstract boolean isReadOnly(ELContext context, Object base, Object property);
 
     /**
      * Obtain the most common type that is acceptable for the given base object.
      *
      * @param context The context in which the examination takes place
-     * @param base The object to examine
+     * @param base    The object to examine
      *
-     * @return {code null} if the most common type cannot be determine,
-     *         otherwise the most common type
+     * @return {code null} if the most common type cannot be determine, otherwise the most common type
      */
-    public abstract Class<?> getCommonPropertyType(ELContext context,
-            Object base);
+    public abstract Class<?> getCommonPropertyType(ELContext context, Object base);
 
     /**
-     * Converts the given object to the given type. This default implementation
-     * always returns <code>null</code>.
-     * @param <T>     The type to which the object should be converted
+     * Converts the given object to the given type. This default implementation always returns <code>null</code>.
      *
+     * @param <T>     The type to which the object should be converted
      * @param context The EL context for this evaluation
      * @param obj     The object to convert
      * @param type    The type to which the object should be converted

==================================================
ExpressionFactory.java
index a1bb3d0c91..68c30985e0 100644
--- a/java/jakarta/el/EvaluationListener.java
+++ b/java/jakarta/el/EvaluationListener.java
@@ -24,8 +24,7 @@ public abstract class EvaluationListener {
     /**
      * Fired before the evaluation of the expression.
      *
-     * @param context    The EL context in which the expression will be
-     *                   evaluated
+     * @param context    The EL context in which the expression will be evaluated
      * @param expression The expression that will be evaluated
      */
     public void beforeEvaluation(ELContext context, String expression) {

==================================================
ImportHandler.java
index 1999547313..546c7d2736 100644
--- a/java/jakarta/el/ExpressionFactory.java
+++ b/java/jakarta/el/ExpressionFactory.java
@@ -41,22 +41,21 @@ public abstract class ExpressionFactory {
 
     private static final String PROPERTY_NAME = "jakarta.el.ExpressionFactory";
 
-    private static final String PROPERTY_FILE =
-            System.getProperty("java.home") + File.separator + "lib" + File.separator + "el.properties";
+    private static final String PROPERTY_FILE = System.getProperty("java.home") + File.separator + "lib" +
+            File.separator + "el.properties";
 
     private static final CacheValue nullTcclFactory = new CacheValue();
     private static final Map<CacheKey, CacheValue> factoryCache = new ConcurrentHashMap<>();
 
     /**
-     * Create a new {@link ExpressionFactory}. The class to use is determined by
-     * the following search order:
+     * Create a new {@link ExpressionFactory}. The class to use is determined by the following search order:
      * <ol>
      * <li>services API (META-INF/services/jakarta.el.ExpressionFactory)</li>
      * <li>$JRE_HOME/lib/el.properties - key jakarta.el.ExpressionFactory</li>
      * <li>jakarta.el.ExpressionFactory</li>
-     * <li>Platform default implementation -
-     *     org.apache.el.ExpressionFactoryImpl</li>
+     * <li>Platform default implementation - org.apache.el.ExpressionFactoryImpl</li>
      * </ol>
+     *
      * @return the new ExpressionFactory
      */
     public static ExpressionFactory newInstance() {
@@ -64,10 +63,11 @@ public abstract class ExpressionFactory {
     }
 
     /**
-     * Create a new {@link ExpressionFactory} passing in the provided
-     * {@link Properties}. Search order is the same as {@link #newInstance()}.
+     * Create a new {@link ExpressionFactory} passing in the provided {@link Properties}. Search order is the same as
+     * {@link #newInstance()}.
      *
      * @param properties the properties to be passed to the new instance (may be null)
+     *
      * @return the new ExpressionFactory
      */
     public static ExpressionFactory newInstance(Properties properties) {
@@ -141,8 +141,7 @@ public abstract class ExpressionFactory {
             if (constructor == null) {
                 result = (ExpressionFactory) clazz.getConstructor().newInstance();
             } else {
-                result =
-                    (ExpressionFactory) constructor.newInstance(properties);
+                result = (ExpressionFactory) constructor.newInstance(properties);
             }
 
         } catch (InvocationTargetException e) {
@@ -161,54 +160,43 @@ public abstract class ExpressionFactory {
      *
      * @param context      The EL context for this evaluation
      * @param expression   The String representation of the value expression
-     * @param expectedType The expected type of the result of evaluating the
-     *                     expression
+     * @param expectedType The expected type of the result of evaluating the expression
      *
      * @return A new value expression formed from the input parameters
      *
-     * @throws NullPointerException
-     *              If the expected type is <code>null</code>
-     * @throws ELException
-     *              If there are syntax errors in the provided expression
+     * @throws NullPointerException If the expected type is <code>null</code>
+     * @throws ELException          If there are syntax errors in the provided expression
      */
-    public abstract ValueExpression createValueExpression(ELContext context,
-            String expression, Class<?> expectedType);
+    public abstract ValueExpression createValueExpression(ELContext context, String expression, Class<?> expectedType);
 
-    public abstract ValueExpression createValueExpression(Object instance,
-            Class<?> expectedType);
+    public abstract ValueExpression createValueExpression(Object instance, Class<?> expectedType);
 
     /**
      * Create a new method expression instance.
      *
      * @param context            The EL context for this evaluation
-     * @param expression         The String representation of the method
-     *                           expression
-     * @param expectedReturnType The expected type of the result of invoking the
-     *                           method
+     * @param expression         The String representation of the method expression
+     * @param expectedReturnType The expected type of the result of invoking the method
      * @param expectedParamTypes The expected types of the input parameters
      *
      * @return A new method expression formed from the input parameters.
      *
-     * @throws NullPointerException
-     *              If the expected parameters types are <code>null</code>
-     * @throws ELException
-     *              If there are syntax errors in the provided expression
+     * @throws NullPointerException If the expected parameters types are <code>null</code>
+     * @throws ELException          If there are syntax errors in the provided expression
      */
-    public abstract MethodExpression createMethodExpression(ELContext context,
-            String expression, Class<?> expectedReturnType,
-            Class<?>[] expectedParamTypes);
+    public abstract MethodExpression createMethodExpression(ELContext context, String expression,
+            Class<?> expectedReturnType, Class<?>[] expectedParamTypes);
 
     /**
      * Coerce the supplied object to the requested type.
-     * @param <T>          The type to which the object should be coerced
      *
+     * @param <T>          The type to which the object should be coerced
      * @param obj          The object to be coerced
      * @param expectedType The type to which the object should be coerced
      *
      * @return An instance of the requested type.
      *
-     * @throws ELException
-     *              If the conversion fails
+     * @throws ELException If the conversion fails
      */
     public abstract <T> T coerceToType(Object obj, Class<T> expectedType);
 
@@ -226,14 +214,13 @@ public abstract class ExpressionFactory {
      *
      * @since EL 3.0
      */
-    public Map<String,Method> getInitFunctionMap() {
+    public Map<String, Method> getInitFunctionMap() {
         return null;
     }
 
     /**
-     * Key used to cache ExpressionFactory discovery information per class
-     * loader. The class loader reference is never {@code null}, because
-     * {@code null} tccl is handled separately.
+     * Key used to cache ExpressionFactory discovery information per class loader. The class loader reference is never
+     * {@code null}, because {@code null} tccl is handled separately.
      */
     private static class CacheKey {
         private final int hash;
@@ -297,8 +284,8 @@ public abstract class ExpressionFactory {
     /**
      * Discover the name of class that implements ExpressionFactory.
      *
-     * @param tccl
-     *            {@code ClassLoader}
+     * @param tccl {@code ClassLoader}
+     *
      * @return Class name. There is default, so it is never {@code null}.
      */
     private static String discoverClassName(ClassLoader tccl) {
@@ -341,7 +328,7 @@ public abstract class ExpressionFactory {
     private static String getClassNameJreDir() {
         File file = new File(PROPERTY_FILE);
         if (file.canRead()) {
-            try (InputStream is = new FileInputStream(file)){
+            try (InputStream is = new FileInputStream(file)) {
                 Properties props = new Properties();
                 props.load(is);
                 String value = props.getProperty(PROPERTY_NAME);

==================================================
LambdaExpression.java
index 75faffc689..936ec97bf3 100644
--- a/java/jakarta/el/ImportHandler.java
+++ b/java/jakarta/el/ImportHandler.java
@@ -31,7 +31,7 @@ import java.util.concurrent.ConcurrentHashMap;
  */
 public class ImportHandler {
 
-    private static final Map<String,Set<String>> standardPackages = new HashMap<>();
+    private static final Map<String, Set<String>> standardPackages = new HashMap<>();
 
     static {
         // Servlet 6.0
@@ -118,7 +118,7 @@ public class ImportHandler {
 
         // JSP 3.0
         Set<String> servletJspClassNames = new HashSet<>();
-        //Interfaces
+        // Interfaces
         servletJspClassNames.add("HttpJspPage");
         servletJspClassNames.add("JspApplicationContext");
         servletJspClassNames.add("JspPage");
@@ -154,7 +154,7 @@ public class ImportHandler {
         javaLangClassNames.add("Thread.Builder.OfPlatform");
         javaLangClassNames.add("Thread.Builder.OfVirtual");
         javaLangClassNames.add("Thread.UncaughtExceptionHandler");
-        //Classes
+        // Classes
         javaLangClassNames.add("Boolean");
         javaLangClassNames.add("Byte");
         javaLangClassNames.add("Character");
@@ -200,13 +200,13 @@ public class ImportHandler {
         javaLangClassNames.add("ThreadLocal");
         javaLangClassNames.add("Throwable");
         javaLangClassNames.add("Void");
-        //Enums
+        // Enums
         javaLangClassNames.add("Character.UnicodeScript");
         javaLangClassNames.add("ProcessBuilder.Redirect.Type");
         javaLangClassNames.add("StackWalker.Option");
         javaLangClassNames.add("System.Logger.Level");
         javaLangClassNames.add("Thread.State");
-        //Exceptions
+        // Exceptions
         javaLangClassNames.add("ArithmeticException");
         javaLangClassNames.add("ArrayIndexOutOfBoundsException");
         javaLangClassNames.add("ArrayStoreException");
@@ -238,7 +238,7 @@ public class ImportHandler {
         javaLangClassNames.add("TypeNotPresentException");
         javaLangClassNames.add("UnsupportedOperationException");
         javaLangClassNames.add("WrongThreadException");
-        //Errors
+        // Errors
         javaLangClassNames.add("AbstractMethodError");
         javaLangClassNames.add("AssertionError");
         javaLangClassNames.add("BootstrapMethodError");
@@ -262,7 +262,7 @@ public class ImportHandler {
         javaLangClassNames.add("UnsupportedClassVersionError");
         javaLangClassNames.add("VerifyError");
         javaLangClassNames.add("VirtualMachineError");
-        //Annotation Types
+        // Annotation Types
         javaLangClassNames.add("Deprecated");
         javaLangClassNames.add("FunctionalInterface");
         javaLangClassNames.add("Override");
@@ -272,10 +272,10 @@ public class ImportHandler {
 
     }
 
-    private Map<String,Set<String>> packageNames = new ConcurrentHashMap<>();
-    private Map<String,String> classNames = new ConcurrentHashMap<>();
-    private Map<String,Class<?>> clazzes = new ConcurrentHashMap<>();
-    private Map<String,Class<?>> statics = new ConcurrentHashMap<>();
+    private Map<String, Set<String>> packageNames = new ConcurrentHashMap<>();
+    private Map<String, String> classNames = new ConcurrentHashMap<>();
+    private Map<String, Class<?>> clazzes = new ConcurrentHashMap<>();
+    private Map<String, Class<?>> statics = new ConcurrentHashMap<>();
 
 
     public ImportHandler() {
@@ -287,8 +287,7 @@ public class ImportHandler {
         int lastPeriod = name.lastIndexOf('.');
 
         if (lastPeriod < 0) {
-            throw new ELException(Util.message(
-                    null, "importHandler.invalidStaticName", name));
+            throw new ELException(Util.message(null, "importHandler.invalidStaticName", name));
         }
 
         String className = name.substring(0, lastPeriod);
@@ -297,9 +296,7 @@ public class ImportHandler {
         Class<?> clazz = findClass(className, true);
 
         if (clazz == null) {
-            throw new ELException(Util.message(
-                    null, "importHandler.invalidClassNameForStatic",
-                    className, name));
+            throw new ELException(Util.message(null, "importHandler.invalidClassNameForStatic", className, name));
         }
 
         boolean found = false;
@@ -307,8 +304,7 @@ public class ImportHandler {
         for (Field field : clazz.getFields()) {
             if (field.getName().equals(fieldOrMethodName)) {
                 int modifiers = field.getModifiers();
-                if (Modifier.isStatic(modifiers) &&
-                        Modifier.isPublic(modifiers)) {
+                if (Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers)) {
                     found = true;
                     break;
                 }
@@ -319,8 +315,7 @@ public class ImportHandler {
             for (Method method : clazz.getMethods()) {
                 if (method.getName().equals(fieldOrMethodName)) {
                     int modifiers = method.getModifiers();
-                    if (Modifier.isStatic(modifiers) &&
-                            Modifier.isPublic(modifiers)) {
+                    if (Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers)) {
                         found = true;
                         break;
                     }
@@ -329,16 +324,14 @@ public class ImportHandler {
         }
 
         if (!found) {
-            throw new ELException(Util.message(null,
-                    "importHandler.staticNotFound", fieldOrMethodName,
-                    className, name));
+            throw new ELException(
+                    Util.message(null, "importHandler.staticNotFound", fieldOrMethodName, className, name));
         }
 
         Class<?> conflict = statics.get(fieldOrMethodName);
         if (conflict != null) {
-            throw new ELException(Util.message(null,
-                    "importHandler.ambiguousStaticImport", name,
-                    conflict.getName() + '.' +  fieldOrMethodName));
+            throw new ELException(Util.message(null, "importHandler.ambiguousStaticImport", name,
+                    conflict.getName() + '.' + fieldOrMethodName));
         }
 
         statics.put(fieldOrMethodName, clazz);
@@ -349,8 +342,7 @@ public class ImportHandler {
         int lastPeriodIndex = name.lastIndexOf('.');
 
         if (lastPeriodIndex < 0) {
-            throw new ELException(Util.message(
-                    null, "importHandler.invalidClassName", name));
+            throw new ELException(Util.message(null, "importHandler.invalidClassName", name));
         }
 
         String unqualifiedName = name.substring(lastPeriodIndex + 1);
@@ -358,8 +350,7 @@ public class ImportHandler {
 
         if (currentName != null && !currentName.equals(name)) {
             // Conflict. Same unqualifiedName, different fully qualified names
-            throw new ELException(Util.message(null,
-                    "importHandler.ambiguousImport", name, currentName));
+            throw new ELException(Util.message(null, "importHandler.ambiguousImport", name, currentName));
         }
     }
 
@@ -407,7 +398,7 @@ public class ImportHandler {
 
         // Search the package imports - note there may be multiple matches
         // (which correctly triggers an error)
-        for (Map.Entry<String,Set<String>> entry : packageNames.entrySet()) {
+        for (Map.Entry<String, Set<String>> entry : packageNames.entrySet()) {
             if (!entry.getValue().isEmpty()) {
                 // Standard package where we know all the class names
                 if (!entry.getValue().contains(name)) {
@@ -421,9 +412,8 @@ public class ImportHandler {
             Class<?> clazz = findClass(className, false);
             if (clazz != null) {
                 if (result != null) {
-                    throw new ELException(Util.message(null,
-                            "importHandler.ambiguousImport", className,
-                            result.getName()));
+                    throw new ELException(
+                            Util.message(null, "importHandler.ambiguousImport", className, result.getName()));
                 }
                 result = clazz;
             }
@@ -457,11 +447,10 @@ public class ImportHandler {
         // Class must be public, non-abstract, not an interface and in an
         // exported package
         int modifiers = clazz.getModifiers();
-        if (!Modifier.isPublic(modifiers) || Modifier.isAbstract(modifiers) ||
-                Modifier.isInterface(modifiers) || !isExported(clazz)) {
+        if (!Modifier.isPublic(modifiers) || Modifier.isAbstract(modifiers) || Modifier.isInterface(modifiers) ||
+                !isExported(clazz)) {
             if (throwException) {
-                throw new ELException(Util.message(
-                        null, "importHandler.invalidClass", name));
+                throw new ELException(Util.message(null, "importHandler.invalidClass", name));
             } else {
                 return null;
             }
@@ -479,8 +468,7 @@ public class ImportHandler {
 
 
     /*
-     * Marker class used because null values are not permitted in a
-     * ConcurrentHashMap.
+     * Marker class used because null values are not permitted in a ConcurrentHashMap.
      */
     private static class NotFound {
     }

==================================================
ListELResolver.java
index b12c509ed1..899eacf2f4 100644
--- a/java/jakarta/el/LambdaExpression.java
+++ b/java/jakarta/el/LambdaExpression.java
@@ -25,11 +25,10 @@ public class LambdaExpression {
 
     private final List<String> formalParameters;
     private final ValueExpression expression;
-    private final Map<String,Object> nestedArguments = new HashMap<>();
+    private final Map<String, Object> nestedArguments = new HashMap<>();
     private ELContext context = null;
 
-    public LambdaExpression(List<String> formalParameters,
-            ValueExpression expression) {
+    public LambdaExpression(List<String> formalParameters, ValueExpression expression) {
         this.formalParameters = formalParameters;
         this.expression = expression;
 
@@ -40,8 +39,7 @@ public class LambdaExpression {
     }
 
     @SuppressWarnings("null") // args[i] can't be null due to earlier checks
-    public Object invoke(ELContext context, Object... args)
-            throws ELException {
+    public Object invoke(ELContext context, Object... args) throws ELException {
 
         Objects.requireNonNull(context);
 
@@ -56,9 +54,7 @@ public class LambdaExpression {
         }
 
         if (formalParamCount > argCount) {
-            throw new ELException(Util.message(context,
-                    "lambdaExpression.tooFewArgs",
-                    Integer.valueOf(argCount),
+            throw new ELException(Util.message(context, "lambdaExpression.tooFewArgs", Integer.valueOf(argCount),
                     Integer.valueOf(formalParamCount)));
         }
 
@@ -77,8 +73,7 @@ public class LambdaExpression {
             // Make arguments from this expression available to any nested
             // expression
             if (result instanceof LambdaExpression) {
-                ((LambdaExpression) result).nestedArguments.putAll(
-                        lambdaArguments);
+                ((LambdaExpression) result).nestedArguments.putAll(lambdaArguments);
             }
             return result;
         } finally {
@@ -87,6 +82,6 @@ public class LambdaExpression {
     }
 
     public java.lang.Object invoke(Object... args) {
-        return invoke (context, args);
+        return invoke(context, args);
     }
 }

==================================================
MapELResolver.java
index f0fcc86da7..6cbcab7b85 100644
--- a/java/jakarta/el/ListELResolver.java
+++ b/java/jakarta/el/ListELResolver.java
@@ -26,7 +26,7 @@ public class ListELResolver extends ELResolver {
     private final boolean readOnly;
 
     // TODO - Handle the Lists created by List.of(). Multiple package private
-    //        classes. Java 9 + so a back-port would require JreCompat.
+    // classes. Java 9 + so a back-port would require JreCompat.
     private static final Class<?> UNMODIFIABLE = Collections.unmodifiableList(new ArrayList<>()).getClass();
 
     public ListELResolver() {
@@ -46,13 +46,11 @@ public class ListELResolver extends ELResolver {
             List<?> list = (List<?>) base;
             int idx = coerce(property);
             if (idx < 0 || idx >= list.size()) {
-                throw new PropertyNotFoundException(
-                        new ArrayIndexOutOfBoundsException(idx).getMessage());
+                throw new PropertyNotFoundException(new ArrayIndexOutOfBoundsException(idx).getMessage());
             }
 
             /*
-             * Not perfect as a custom list implementation may be read-only but
-             * consistent with isReadOnly().
+             * Not perfect as a custom list implementation may be read-only but consistent with isReadOnly().
              */
             if (list.getClass() == UNMODIFIABLE || readOnly) {
                 return null;
@@ -82,8 +80,7 @@ public class ListELResolver extends ELResolver {
     }
 
     @Override
-    public void setValue(ELContext context, Object base, Object property,
-            Object value) {
+    public void setValue(ELContext context, Object base, Object property, Object value) {
         Objects.requireNonNull(context);
 
         if (base instanceof List<?>) {
@@ -92,8 +89,8 @@ public class ListELResolver extends ELResolver {
             List<Object> list = (List<Object>) base;
 
             if (this.readOnly) {
-                throw new PropertyNotWritableException(Util.message(context,
-                        "resolverNotWritable", base.getClass().getName()));
+                throw new PropertyNotWritableException(
+                        Util.message(context, "resolverNotWritable", base.getClass().getName()));
             }
 
             int idx = coerce(property);
@@ -117,9 +114,7 @@ public class ListELResolver extends ELResolver {
             try {
                 int idx = coerce(property);
                 if (idx < 0 || idx >= list.size()) {
-                    throw new PropertyNotFoundException(
-                            new ArrayIndexOutOfBoundsException(idx)
-                                    .getMessage());
+                    throw new PropertyNotFoundException(new ArrayIndexOutOfBoundsException(idx).getMessage());
                 }
             } catch (IllegalArgumentException e) {
                 // ignore
@@ -151,7 +146,6 @@ public class ListELResolver extends ELResolver {
         if (property instanceof String) {
             return Integer.parseInt((String) property);
         }
-        throw new IllegalArgumentException(property != null ?
-                property.toString() : "null");
+        throw new IllegalArgumentException(property != null ? property.toString() : "null");
     }
 }

==================================================
MethodExpression.java
index efca33f436..eea566ca88 100644
--- a/java/jakarta/el/MapELResolver.java
+++ b/java/jakarta/el/MapELResolver.java
@@ -23,8 +23,7 @@ import java.util.Objects;
 
 public class MapELResolver extends ELResolver {
 
-    private static final Class<?> UNMODIFIABLE =
-            Collections.unmodifiableMap(new HashMap<>()).getClass();
+    private static final Class<?> UNMODIFIABLE = Collections.unmodifiableMap(new HashMap<>()).getClass();
 
     private final boolean readOnly;
 
@@ -40,7 +39,7 @@ public class MapELResolver extends ELResolver {
     public Class<?> getType(ELContext context, Object base, Object property) {
         Objects.requireNonNull(context);
 
-        if (base instanceof Map<?,?>) {
+        if (base instanceof Map<?, ?>) {
             context.setPropertyResolved(base, property);
 
             Map<?, ?> map = (Map<?, ?>) base;
@@ -58,25 +57,24 @@ public class MapELResolver extends ELResolver {
     public Object getValue(ELContext context, Object base, Object property) {
         Objects.requireNonNull(context);
 
-        if (base instanceof Map<?,?>) {
+        if (base instanceof Map<?, ?>) {
             context.setPropertyResolved(base, property);
-            return ((Map<?,?>) base).get(property);
+            return ((Map<?, ?>) base).get(property);
         }
 
         return null;
     }
 
     @Override
-    public void setValue(ELContext context, Object base, Object property,
-            Object value) {
+    public void setValue(ELContext context, Object base, Object property, Object value) {
         Objects.requireNonNull(context);
 
         if (base instanceof Map<?, ?>) {
             context.setPropertyResolved(base, property);
 
             if (this.readOnly) {
-                throw new PropertyNotWritableException(Util.message(context,
-                        "resolverNotWritable", base.getClass().getName()));
+                throw new PropertyNotWritableException(
+                        Util.message(context, "resolverNotWritable", base.getClass().getName()));
             }
 
             try {

==================================================
MethodReference.java
index 2635960aa7..e8a91c4fb8 100644
--- a/java/jakarta/el/MethodExpression.java
+++ b/java/jakarta/el/MethodExpression.java
@@ -25,15 +25,11 @@ public abstract class MethodExpression extends Expression {
      *
      * @return Information about the method that this expression resolves to
      *
-     * @throws NullPointerException
-     *              If the supplied context is <code>null</code>
-     * @throws PropertyNotFoundException
-     *              If a property/variable resolution failed because no match
-     *              was found or a match was found but was not readable
-     * @throws MethodNotFoundException
-     *              If no matching method can be found
-     * @throws ELException
-     *              Wraps any exception throw whilst resolving the property
+     * @throws NullPointerException      If the supplied context is <code>null</code>
+     * @throws PropertyNotFoundException If a property/variable resolution failed because no match was found or a match
+     *                                       was found but was not readable
+     * @throws MethodNotFoundException   If no matching method can be found
+     * @throws ELException               Wraps any exception throw whilst resolving the property
      */
     public abstract MethodInfo getMethodInfo(ELContext context);
 
@@ -43,21 +39,18 @@ public abstract class MethodExpression extends Expression {
      *
      * @return The result of invoking this method expression
      *
-     * @throws NullPointerException
-     *              If the supplied context is <code>null</code>
-     * @throws PropertyNotFoundException
-     *              If a property/variable resolution failed because no match
-     *              was found or a match was found but was not readable
-     * @throws MethodNotFoundException
-     *              If no matching method can be found
-     * @throws ELException
-     *              Wraps any exception throw whilst resolving the property or
-     *              coercion of the result to the expected return type fails
+     * @throws NullPointerException      If the supplied context is <code>null</code>
+     * @throws PropertyNotFoundException If a property/variable resolution failed because no match was found or a match
+     *                                       was found but was not readable
+     * @throws MethodNotFoundException   If no matching method can be found
+     * @throws ELException               Wraps any exception throw whilst resolving the property or coercion of the
+     *                                       result to the expected return type fails
      */
     public abstract Object invoke(ELContext context, Object[] params);
 
     /**
      * @return This default implementation always returns <code>false</code>
+     *
      * @since EL 3.0
      */
     public boolean isParametersProvided() {
@@ -66,22 +59,17 @@ public abstract class MethodExpression extends Expression {
     }
 
     /**
-     * Obtain the {@link MethodReference} for the method to which this method
-     * expression resolves.
+     * Obtain the {@link MethodReference} for the method to which this method expression resolves.
      *
      * @param context The EL context for this evaluation
      *
      * @return This default implementation always returns <code>null</code>
      *
-     * @throws NullPointerException
-     *              If the supplied context is <code>null</code>
-     * @throws PropertyNotFoundException
-     *              If a property/variable resolution failed because no match
-     *              was found or a match was found but was not readable
-     * @throws MethodNotFoundException
-     *              If no matching method can be found
-     * @throws ELException
-     *              Wraps any exception throw whilst resolving the property
+     * @throws NullPointerException      If the supplied context is <code>null</code>
+     * @throws PropertyNotFoundException If a property/variable resolution failed because no match was found or a match
+     *                                       was found but was not readable
+     * @throws MethodNotFoundException   If no matching method can be found
+     * @throws ELException               Wraps any exception throw whilst resolving the property
      *
      * @since EL 5.0
      */

==================================================
ResourceBundleELResolver.java
index ed59a842d4..30065c5768 100644
--- a/java/jakarta/el/MethodReference.java
+++ b/java/jakarta/el/MethodReference.java
@@ -43,8 +43,7 @@ public class MethodReference {
     /**
      * Obtain the base object on which the method will be invoked.
      *
-     * @return The base object on which the method will be invoked or
-     *         {@code null} for literal method expressions.
+     * @return The base object on which the method will be invoked or {@code null} for literal method expressions.
      */
     public Object getBase() {
         return base;
@@ -52,11 +51,11 @@ public class MethodReference {
 
 
     /**
-     * Obtain the {@link MethodInfo} for the {@link MethodExpression} for which
-     * this {@link MethodReference} has been generated.
+     * Obtain the {@link MethodInfo} for the {@link MethodExpression} for which this {@link MethodReference} has been
+     * generated.
      *
-     * @return The {@link MethodInfo} for the {@link MethodExpression} for which
-     *         this {@link MethodReference} has been generated.
+     * @return The {@link MethodInfo} for the {@link MethodExpression} for which this {@link MethodReference} has been
+     *             generated.
      */
     public MethodInfo getMethodInfo() {
         return this.methodInfo;
@@ -64,12 +63,10 @@ public class MethodReference {
 
 
     /**
-     * Obtain the annotations on the method to which the associated expression
-     * resolves.
+     * Obtain the annotations on the method to which the associated expression resolves.
      *
-     * @return The annotations on the method to which the associated expression
-     *         resolves. If the are no annotations, then an empty array is
-     *         returned.
+     * @return The annotations on the method to which the associated expression resolves. If the are no annotations,
+     *             then an empty array is returned.
      */
     public Annotation[] getAnnotations() {
         return annotations;
@@ -77,10 +74,10 @@ public class MethodReference {
 
 
     /**
-     * Obtain the evaluated parameter values that will be passed to the method
-     * to which the associated expression resolves.
+     * Obtain the evaluated parameter values that will be passed to the method to which the associated expression
+     * resolves.
      *
-     *  @return The evaluated parameters.
+     * @return The evaluated parameters.
      */
     public Object[] getEvaluatedParameters() {
         return evaluatedParameters;

==================================================
StandardELContext.java
index d0723b4484..62e9fd6729 100644
--- a/java/jakarta/el/ResourceBundleELResolver.java
+++ b/java/jakarta/el/ResourceBundleELResolver.java
@@ -35,8 +35,7 @@ public class ResourceBundleELResolver extends ELResolver {
 
             if (property != null) {
                 try {
-                    return ((ResourceBundle) base).getObject(property
-                            .toString());
+                    return ((ResourceBundle) base).getObject(property.toString());
                 } catch (MissingResourceException mre) {
                     return "???" + property.toString() + "???";
                 }
@@ -53,8 +52,7 @@ public class ResourceBundleELResolver extends ELResolver {
         if (base instanceof ResourceBundle) {
             context.setPropertyResolved(base, property);
             /*
-             * ResourceBundles are always read-only so fall-through to return
-             * null
+             * ResourceBundles are always read-only so fall-through to return null
              */
         }
 
@@ -62,14 +60,13 @@ public class ResourceBundleELResolver extends ELResolver {
     }
 
     @Override
-    public void setValue(ELContext context, Object base, Object property,
-            Object value) {
+    public void setValue(ELContext context, Object base, Object property, Object value) {
         Objects.requireNonNull(context);
 
         if (base instanceof ResourceBundle) {
             context.setPropertyResolved(base, property);
-            throw new PropertyNotWritableException(Util.message(context,
-                    "resolverNotWritable", base.getClass().getName()));
+            throw new PropertyNotWritableException(
+                    Util.message(context, "resolverNotWritable", base.getClass().getName()));
         }
     }
 

==================================================
StaticFieldELResolver.java
index 9f04060ac0..092d439f40 100644
--- a/java/jakarta/el/StandardELContext.java
+++ b/java/jakarta/el/StandardELContext.java
@@ -30,22 +30,20 @@ public class StandardELContext extends ELContext {
     private final FunctionMapper functionMapper;
     private final CompositeELResolver standardResolver;
     private final CompositeELResolver customResolvers;
-    private final Map<String,Object> localBeans = new HashMap<>();
+    private final Map<String, Object> localBeans = new HashMap<>();
 
 
     public StandardELContext(ExpressionFactory factory) {
         wrappedContext = null;
         variableMapper = new StandardVariableMapper();
-        functionMapper =
-                new StandardFunctionMapper(factory.getInitFunctionMap());
+        functionMapper = new StandardFunctionMapper(factory.getInitFunctionMap());
         standardResolver = new CompositeELResolver();
         customResolvers = new CompositeELResolver();
 
         ELResolver streamResolver = factory.getStreamELResolver();
 
         // Add resolvers in order
-        standardResolver.add(new BeanNameELResolver(
-                new StandardBeanNameResolver(localBeans)));
+        standardResolver.add(new BeanNameELResolver(new StandardBeanNameResolver(localBeans)));
         standardResolver.add(customResolvers);
         if (streamResolver != null) {
             standardResolver.add(streamResolver);
@@ -66,8 +64,7 @@ public class StandardELContext extends ELContext {
         customResolvers = new CompositeELResolver();
 
         // Add resolvers in order
-        standardResolver.add(new BeanNameELResolver(
-                new StandardBeanNameResolver(localBeans)));
+        standardResolver.add(new BeanNameELResolver(new StandardBeanNameResolver(localBeans)));
         standardResolver.add(customResolvers);
         // Use resolvers from context from this point on
         standardResolver.add(context.getELResolver());
@@ -111,7 +108,7 @@ public class StandardELContext extends ELContext {
     }
 
 
-    Map<String,Object> getLocalBeans() {
+    Map<String, Object> getLocalBeans() {
         return localBeans;
     }
 
@@ -129,8 +126,7 @@ public class StandardELContext extends ELContext {
         }
 
         @Override
-        public ValueExpression setVariable(String variable,
-                ValueExpression expression) {
+        public ValueExpression setVariable(String variable, ValueExpression expression) {
             if (vars == null) {
                 vars = new HashMap<>();
             }
@@ -145,9 +141,9 @@ public class StandardELContext extends ELContext {
 
     private static class StandardBeanNameResolver extends BeanNameResolver {
 
-        private final Map<String,Object> beans;
+        private final Map<String, Object> beans;
 
-        StandardBeanNameResolver(Map<String,Object> beans) {
+        StandardBeanNameResolver(Map<String, Object> beans) {
             this.beans = beans;
         }
 
@@ -162,8 +158,7 @@ public class StandardELContext extends ELContext {
         }
 
         @Override
-        public void setBeanValue(String beanName, Object value)
-                throws PropertyNotWritableException {
+        public void setBeanValue(String beanName, Object value) throws PropertyNotWritableException {
             beans.put(beanName, value);
         }
 
@@ -181,9 +176,9 @@ public class StandardELContext extends ELContext {
 
     private static class StandardFunctionMapper extends FunctionMapper {
 
-        private final Map<String,Method> methods = new HashMap<>();
+        private final Map<String, Method> methods = new HashMap<>();
 
-        StandardFunctionMapper(Map<String,Method> initFunctionMap) {
+        StandardFunctionMapper(Map<String, Method> initFunctionMap) {
             if (initFunctionMap != null) {
                 methods.putAll(initFunctionMap);
             }
@@ -196,8 +191,7 @@ public class StandardELContext extends ELContext {
         }
 
         @Override
-        public void mapFunction(String prefix, String localName,
-                Method method) {
+        public void mapFunction(String prefix, String localName, Method method) {
             String key = prefix + ':' + localName;
             if (method == null) {
                 methods.remove(key);

==================================================
TypeConverter.java
index e29c7a8557..0e7d8a48b5 100644
--- a/java/jakarta/el/StaticFieldELResolver.java
+++ b/java/jakarta/el/StaticFieldELResolver.java
@@ -41,17 +41,13 @@ public class StaticFieldELResolver extends ELResolver {
             try {
                 Field field = clazz.getField(name);
                 int modifiers = field.getModifiers();
-                if (Modifier.isStatic(modifiers) &&
-                        Modifier.isPublic(modifiers) &&
-                        Util.canAccess(null, field)) {
+                if (Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers) && Util.canAccess(null, field)) {
                     return field.get(null);
                 }
-            } catch (IllegalArgumentException | IllegalAccessException |
-                    NoSuchFieldException | SecurityException e) {
+            } catch (IllegalArgumentException | IllegalAccessException | NoSuchFieldException | SecurityException e) {
                 exception = e;
             }
-            String msg = Util.message(context, "staticFieldELResolver.notFound",
-                    name, clazz.getName());
+            String msg = Util.message(context, "staticFieldELResolver.notFound", name, clazz.getName());
             if (exception == null) {
                 throw new PropertyNotFoundException(msg);
             } else {
@@ -63,24 +59,21 @@ public class StaticFieldELResolver extends ELResolver {
 
 
     @Override
-    public void setValue(ELContext context, Object base, Object property,
-            Object value) {
+    public void setValue(ELContext context, Object base, Object property, Object value) {
         Objects.requireNonNull(context);
 
         if (base instanceof ELClass && property instanceof String) {
             Class<?> clazz = ((ELClass) base).getKlass();
             String name = (String) property;
 
-            throw new PropertyNotWritableException(Util.message(context,
-                    "staticFieldELResolver.notWritable", name,
-                    clazz.getName()));
+            throw new PropertyNotWritableException(
+                    Util.message(context, "staticFieldELResolver.notWritable", name, clazz.getName()));
         }
     }
 
 
     @Override
-    public Object invoke(ELContext context, Object base, Object method,
-            Class<?>[] paramTypes, Object[] params) {
+    public Object invoke(ELContext context, Object base, Object method, Class<?>[] paramTypes, Object[] params) {
         Objects.requireNonNull(context);
 
         if (base instanceof ELClass && method instanceof String) {
@@ -92,8 +85,8 @@ public class StaticFieldELResolver extends ELResolver {
             if ("<init>".equals(methodName)) {
                 Constructor<?> match = Util.findConstructor(context, clazz, paramTypes, params);
 
-                Object[] parameters = Util.buildParameters(
-                        context, match.getParameterTypes(), match.isVarArgs(), params);
+                Object[] parameters = Util.buildParameters(context, match.getParameterTypes(), match.isVarArgs(),
+                        params);
 
                 Object result = null;
 
@@ -113,13 +106,12 @@ public class StaticFieldELResolver extends ELResolver {
                 Method match = Util.findMethod(context, clazz, null, methodName, paramTypes, params);
 
                 if (match == null) {
-                    throw new MethodNotFoundException(Util.message(context,
-                            "staticFieldELResolver.methodNotFound", methodName,
-                            clazz.getName()));
+                    throw new MethodNotFoundException(
+                            Util.message(context, "staticFieldELResolver.methodNotFound", methodName, clazz.getName()));
                 }
 
-                Object[] parameters = Util.buildParameters(
-                        context, match.getParameterTypes(), match.isVarArgs(), params);
+                Object[] parameters = Util.buildParameters(context, match.getParameterTypes(), match.isVarArgs(),
+                        params);
 
                 Object result = null;
                 try {
@@ -150,18 +142,14 @@ public class StaticFieldELResolver extends ELResolver {
             try {
                 Field field = clazz.getField(name);
                 int modifiers = field.getModifiers();
-                if (Modifier.isStatic(modifiers) &&
-                        Modifier.isPublic(modifiers) &&
-                        Util.canAccess(null, field)) {
+                if (Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers) && Util.canAccess(null, field)) {
                     // Resolver is read-only so returns null for resolved fields
                     return null;
                 }
-            } catch (IllegalArgumentException | NoSuchFieldException |
-                    SecurityException e) {
+            } catch (IllegalArgumentException | NoSuchFieldException | SecurityException e) {
                 exception = e;
             }
-            String msg = Util.message(context, "staticFieldELResolver.notFound",
-                    name, clazz.getName());
+            String msg = Util.message(context, "staticFieldELResolver.notFound", name, clazz.getName());
             if (exception == null) {
                 throw new PropertyNotFoundException(msg);
             } else {

==================================================
Util.java
index 0804882f9d..532543d3da 100644
--- a/java/jakarta/el/TypeConverter.java
+++ b/java/jakarta/el/TypeConverter.java
@@ -32,8 +32,7 @@ public abstract class TypeConverter extends ELResolver {
     }
 
     @Override
-    public void setValue(ELContext context, Object base, Object property,
-            Object value) {
+    public void setValue(ELContext context, Object base, Object property, Object value) {
         // NO-OP
     }
 

==================================================
ValueExpression.java
index 6a9f313c80..0fa4637105 100644
--- a/java/jakarta/el/Util.java
+++ b/java/jakarta/el/Util.java
@@ -42,8 +42,8 @@ class Util {
     private static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];
 
     /**
-     * Checks whether the supplied Throwable is one that needs to be
-     * rethrown and swallows all others.
+     * Checks whether the supplied Throwable is one that needs to be rethrown and swallows all others.
+     *
      * @param t the Throwable to check
      */
     static void handleThrowable(Throwable t) {
@@ -68,8 +68,7 @@ class Util {
                 return "";
             }
         }
-        ResourceBundle bundle = ResourceBundle.getBundle(
-                "jakarta.el.LocalStrings", locale);
+        ResourceBundle bundle = ResourceBundle.getBundle("jakarta.el.LocalStrings", locale);
         try {
             String template = bundle.getString(name);
             if (props != null) {
@@ -86,8 +85,8 @@ class Util {
     private static final Map<CacheKey, CacheValue> factoryCache = new ConcurrentHashMap<>();
 
     /**
-     * Provides a per class loader cache of ExpressionFactory instances without
-     * pinning any in memory as that could trigger a memory leak.
+     * Provides a per class loader cache of ExpressionFactory instances without pinning any in memory as that could
+     * trigger a memory leak.
      */
     static ExpressionFactory getExpressionFactory() {
 
@@ -137,9 +136,8 @@ class Util {
 
 
     /**
-     * Key used to cache default ExpressionFactory information per class
-     * loader. The class loader reference is never {@code null}, because
-     * {@code null} tccl is handled separately.
+     * Key used to cache default ExpressionFactory information per class loader. The class loader reference is never
+     * {@code null}, because {@code null} tccl is handled separately.
      */
     private static class CacheKey {
         private final int hash;
@@ -193,16 +191,14 @@ class Util {
 
 
     /*
-     * This method duplicates code in org.apache.el.util.ReflectionUtil. When
-     * making changes keep the code in sync.
+     * This method duplicates code in org.apache.el.util.ReflectionUtil. When making changes keep the code in sync.
      */
-    static Method findMethod(ELContext context, Class<?> clazz, Object base, String methodName,
-            Class<?>[] paramTypes, Object[] paramValues) {
+    static Method findMethod(ELContext context, Class<?> clazz, Object base, String methodName, Class<?>[] paramTypes,
+            Object[] paramValues) {
 
         if (clazz == null || methodName == null) {
             throw new MethodNotFoundException(
-                    message(null, "util.method.notfound", clazz, methodName,
-                    paramString(paramTypes)));
+                    message(null, "util.method.notfound", clazz, methodName, paramString(paramTypes)));
         }
 
         if (paramTypes == null) {
@@ -219,14 +215,13 @@ class Util {
     }
 
     /*
-     * This method duplicates code in org.apache.el.util.ReflectionUtil. When
-     * making changes keep the code in sync.
+     * This method duplicates code in org.apache.el.util.ReflectionUtil. When making changes keep the code in sync.
      */
     @SuppressWarnings("null")
-    private static <T> Wrapper<T> findWrapper(ELContext context, Class<?> clazz, List<Wrapper<T>> wrappers,
-            String name, Class<?>[] paramTypes, Object[] paramValues) {
+    private static <T> Wrapper<T> findWrapper(ELContext context, Class<?> clazz, List<Wrapper<T>> wrappers, String name,
+            Class<?>[] paramTypes, Object[] paramValues) {
 
-        Map<Wrapper<T>,MatchResult> candidates = new HashMap<>();
+        Map<Wrapper<T>, MatchResult> candidates = new HashMap<>();
 
         int paramCount = paramTypes.length;
 
@@ -245,17 +240,16 @@ class Util {
                 // Method has wrong number of parameters
                 continue;
             }
-            if (w.isVarArgs() && paramCount < mParamCount -1) {
+            if (w.isVarArgs() && paramCount < mParamCount - 1) {
                 // Method has wrong number of parameters
                 continue;
             }
-            if (w.isVarArgs() && paramCount == mParamCount && paramValues != null &&
-                    paramValues.length > paramCount && !paramTypes[mParamCount -1].isArray()) {
+            if (w.isVarArgs() && paramCount == mParamCount && paramValues != null && paramValues.length > paramCount &&
+                    !paramTypes[mParamCount - 1].isArray()) {
                 // Method arguments don't match
                 continue;
             }
-            if (w.isVarArgs() && paramCount > mParamCount && paramValues != null &&
-                    paramValues.length != paramCount) {
+            if (w.isVarArgs() && paramCount > mParamCount && paramValues != null && paramValues.length != paramCount) {
                 // Might match a different varargs method
                 continue;
             }
@@ -332,8 +326,8 @@ class Util {
                 return w;
             }
 
-            candidates.put(w, new MatchResult(
-                    w.isVarArgs(), exactMatch, assignableMatch, coercibleMatch, varArgsMatch, w.isBridge()));
+            candidates.put(w, new MatchResult(w.isVarArgs(), exactMatch, assignableMatch, coercibleMatch, varArgsMatch,
+                    w.isBridge()));
         }
 
         // Look for the method that has the highest number of parameters where
@@ -363,17 +357,15 @@ class Util {
             if (match == null) {
                 // If multiple methods have the same matching number of parameters
                 // the match is ambiguous so throw an exception
-                throw new MethodNotFoundException(message(
-                        null, "util.method.ambiguous", clazz, name,
-                        paramString(paramTypes)));
+                throw new MethodNotFoundException(
+                        message(null, "util.method.ambiguous", clazz, name, paramString(paramTypes)));
             }
         }
 
         // Handle case where no match at all was found
         if (match == null) {
-            throw new MethodNotFoundException(message(
-                        null, "util.method.notfound", clazz, name,
-                        paramString(paramTypes)));
+            throw new MethodNotFoundException(
+                    message(null, "util.method.notfound", clazz, name, paramString(paramTypes)));
         }
 
         return match;
@@ -400,11 +392,9 @@ class Util {
 
 
     /*
-     * This method duplicates code in org.apache.el.util.ReflectionUtil. When
-     * making changes keep the code in sync.
+     * This method duplicates code in org.apache.el.util.ReflectionUtil. When making changes keep the code in sync.
      */
-    private static <T> Wrapper<T> resolveAmbiguousWrapper(Set<Wrapper<T>> candidates,
-            Class<?>[] paramTypes) {
+    private static <T> Wrapper<T> resolveAmbiguousWrapper(Set<Wrapper<T>> candidates, Class<?>[] paramTypes) {
         // Identify which parameter isn't an exact match
         Wrapper<T> w = candidates.iterator().next();
 
@@ -449,8 +439,7 @@ class Util {
         if (Number.class.isAssignableFrom(nonMatchClass)) {
             for (Wrapper<T> c : candidates) {
                 Class<?> candidateType = c.getParameterTypes()[nonMatchIndex];
-                if (Number.class.isAssignableFrom(candidateType) ||
-                        candidateType.isPrimitive()) {
+                if (Number.class.isAssignableFrom(candidateType) || candidateType.isPrimitive()) {
                     if (match == null) {
                         match = c;
                     } else {
@@ -467,8 +456,7 @@ class Util {
 
 
     /*
-     * This method duplicates code in org.apache.el.util.ReflectionUtil. When
-     * making changes keep the code in sync.
+     * This method duplicates code in org.apache.el.util.ReflectionUtil. When making changes keep the code in sync.
      */
     static boolean isAssignableFrom(Class<?> src, Class<?> target) {
         // src will always be an object
@@ -505,12 +493,11 @@ class Util {
 
 
     /*
-     * This method duplicates code in org.apache.el.util.ReflectionUtil. When
-     * making changes keep the code in sync.
+     * This method duplicates code in org.apache.el.util.ReflectionUtil. When making changes keep the code in sync.
      */
     private static boolean isCoercibleFrom(ELContext context, Object src, Class<?> target) {
         // TODO: This isn't pretty but it works. Significant refactoring would
-        //       be required to avoid the exception.
+        // be required to avoid the exception.
         try {
             context.convertToType(src, target);
         } catch (ELException e) {
@@ -538,13 +525,11 @@ class Util {
 
 
     /*
-     * This method duplicates code in org.apache.el.util.ReflectionUtil. When
-     * making changes keep the code in sync.
+     * This method duplicates code in org.apache.el.util.ReflectionUtil. When making changes keep the code in sync.
      */
     static Method getMethod(Class<?> type, Object base, Method m) {
-        if (m == null ||
-                (Modifier.isPublic(type.getModifiers()) &&
-                        (Modifier.isStatic(m.getModifiers()) && canAccess(null, m) || canAccess(base, m)))) {
+        if (m == null || (Modifier.isPublic(type.getModifiers()) &&
+                (Modifier.isStatic(m.getModifiers()) && canAccess(null, m) || canAccess(base, m)))) {
             return m;
         }
         Class<?>[] interfaces = type.getInterfaces();
@@ -583,8 +568,7 @@ class Util {
 
         if (clazz == null) {
             throw new MethodNotFoundException(
-                    message(null, "util.method.notfound", null, methodName,
-                    paramString(paramTypes)));
+                    message(null, "util.method.notfound", null, methodName, paramString(paramTypes)));
         }
 
         if (paramTypes == null) {
@@ -600,9 +584,8 @@ class Util {
         Constructor<?> constructor = wrapper.unWrap();
 
         if (!Modifier.isPublic(clazz.getModifiers()) || !canAccess(null, constructor)) {
-            throw new MethodNotFoundException(message(
-                    null, "util.method.notfound", clazz, methodName,
-                    paramString(paramTypes)));
+            throw new MethodNotFoundException(
+                    message(null, "util.method.notfound", clazz, methodName, paramString(paramTypes)));
         }
 
         return constructor;
@@ -618,7 +601,7 @@ class Util {
     }
 
 
-    static Object[] buildParameters(ELContext context, Class<?>[] parameterTypes, boolean isVarArgs,Object[] params) {
+    static Object[] buildParameters(ELContext context, Class<?>[] parameterTypes, boolean isVarArgs, Object[] params) {
         Object[] parameters = null;
         if (parameterTypes.length > 0) {
             parameters = new Object[parameterTypes.length];
@@ -672,8 +655,11 @@ class Util {
         }
 
         public abstract T unWrap();
+
         public abstract Class<?>[] getParameterTypes();
+
         public abstract boolean isVarArgs();
+
         public abstract boolean isBridge();
     }
 
@@ -735,8 +721,7 @@ class Util {
     }
 
     /*
-     * This class duplicates code in org.apache.el.util.ReflectionUtil. When
-     * making changes keep the code in sync.
+     * This class duplicates code in org.apache.el.util.ReflectionUtil. When making changes keep the code in sync.
      */
     private static class MatchResult implements Comparable<MatchResult> {
 
@@ -810,14 +795,13 @@ class Util {
 
         @Override
         public boolean equals(Object o) {
-            return o == this || (null != o &&
-                    this.getClass().equals(o.getClass()) &&
-                    ((MatchResult)o).getExactCount() == this.getExactCount() &&
-                    ((MatchResult)o).getAssignableCount() == this.getAssignableCount() &&
-                    ((MatchResult)o).getCoercibleCount() == this.getCoercibleCount() &&
-                    ((MatchResult)o).getVarArgsCount() == this.getVarArgsCount() &&
-                    ((MatchResult)o).isVarArgs() == this.isVarArgs() &&
-                    ((MatchResult)o).isBridge() == this.isBridge());
+            return o == this || (null != o && this.getClass().equals(o.getClass()) &&
+                    ((MatchResult) o).getExactCount() == this.getExactCount() &&
+                    ((MatchResult) o).getAssignableCount() == this.getAssignableCount() &&
+                    ((MatchResult) o).getCoercibleCount() == this.getCoercibleCount() &&
+                    ((MatchResult) o).getVarArgsCount() == this.getVarArgsCount() &&
+                    ((MatchResult) o).isVarArgs() == this.isVarArgs() &&
+                    ((MatchResult) o).isBridge() == this.isBridge());
         }
 
         @Override

==================================================
