8313a146356e480013bddd4ba4c3b10d6cd0c66c
==================================================
Refactor for consistency
==================================================
Mark Thomas
==================================================
Mon Aug 20 16:11:52 2018 +0000
==================================================
AprEndpoint.java
Refactor for consistency

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1838433 13f79535-47bb-0310-9956-ffa450edef68



==================================================
SocketWrapperBase.java
index 2dac86fdb4..6907607398 100644
--- a/java/org/apache/tomcat/util/net/AprEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AprEndpoint.java
@@ -2598,9 +2598,9 @@ public class AprEndpoint extends AbstractEndpoint<Long,Long> implements SNICallB
 
 
         @Override
-        protected boolean writeNonBlockingDirect(ByteBuffer from) throws IOException {
+        protected void writeNonBlockingDirect(ByteBuffer from) throws IOException {
             if (from.isDirect()) {
-                return super.writeNonBlockingDirect(from);
+                super.writeNonBlockingDirect(from);
             } else {
                 // The socket write buffer capacity is socket.appWriteBufSize
                 ByteBuffer writeBuffer = socketBufferHandler.getWriteBuffer();
@@ -2614,7 +2614,6 @@ public class AprEndpoint extends AbstractEndpoint<Long,Long> implements SNICallB
                         // Didn't write the whole amount of data in the last
                         // non-blocking write.
                         // Exit the loop.
-                        return true;
                     }
                 }
 
@@ -2622,8 +2621,6 @@ public class AprEndpoint extends AbstractEndpoint<Long,Long> implements SNICallB
                     socketBufferHandler.configureWriteBufferForWrite();
                     transfer(from, writeBuffer);
                 }
-
-                return false;
             }
         }
 

==================================================
WriteBuffer.java
index 5c293f9419..dcb75443f8 100644
--- a/java/org/apache/tomcat/util/net/SocketWrapperBase.java
+++ b/java/org/apache/tomcat/util/net/SocketWrapperBase.java
@@ -625,26 +625,24 @@ public abstract class SocketWrapperBase<E> {
      * Separate method so it can be re-used by the socket write buffer to write
      * data to the network
      */
-    boolean writeNonBlockingInternal(ByteBuffer from) throws IOException {
+    void writeNonBlockingInternal(ByteBuffer from) throws IOException {
         // TODO Explore refactoring this method back into writeNonBlocking
         if (socketBufferHandler.isWriteBufferEmpty()) {
-            return writeNonBlockingDirect(from);
+            writeNonBlockingDirect(from);
         } else {
             socketBufferHandler.configureWriteBufferForWrite();
             transfer(from, socketBufferHandler.getWriteBuffer());
             if (!socketBufferHandler.isWriteBufferWritable()) {
                 doWrite(false);
                 if (socketBufferHandler.isWriteBufferWritable()) {
-                    return writeNonBlockingDirect(from);
+                    writeNonBlockingDirect(from);
                 }
             }
         }
-
-        return !socketBufferHandler.isWriteBufferWritable();
     }
 
 
-    protected boolean writeNonBlockingDirect(ByteBuffer from) throws IOException {
+    protected void writeNonBlockingDirect(ByteBuffer from) throws IOException {
         // The socket write buffer capacity is socket.appWriteBufSize
         // TODO This only matters when using TLS. For non-TLS connections it
         //      should be possible to write the ByteBuffer in a single write
@@ -659,7 +657,7 @@ public abstract class SocketWrapperBase<E> {
                 // Didn't write the whole amount of data in the last
                 // non-blocking write.
                 // Exit the loop.
-                return true;
+                return;
             }
         }
 
@@ -667,8 +665,6 @@ public abstract class SocketWrapperBase<E> {
             socketBufferHandler.configureWriteBufferForWrite();
             transfer(from, socketBufferHandler.getWriteBuffer());
         }
-
-        return false;
     }
 
 

==================================================
