0e61728713ccb5b47d141c5cb986c21280de7350
==================================================
Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=56652
==================================================
Mark Emlyn
==================================================
Fri Jul 4 18:47:02 2014 +0000
==================================================
ELProcessor.java
Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=56652
Add support for method parameters that use arrays and varargs to ELProcessor.defineFunction()

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1607906 13f79535-47bb-0310-9956-ffa450edef68



==================================================
ELSupport.java
index 0ef2369e07..8b825d802b 100644
--- a/java/javax/el/ELProcessor.java
+++ b/java/javax/el/ELProcessor.java
@@ -134,7 +134,17 @@ public class ELProcessor {
                     if (types.length == typeNames.length) {
                         boolean match = true;
                         for (int i = 0; i < types.length; i++) {
-                            if (!types[i].getName().equals(typeNames[i])) {
+                            if (i == types.length -1 && method.isVarArgs()) {
+                                String typeName = typeNames[i];
+                                if (typeName.endsWith("...")) {
+                                    typeName = typeName.substring(0, typeName.length() - 3);
+                                    if (!typeName.equals(types[i].getName())) {
+                                        match = false;
+                                    }
+                                } else {
+                                    match = false;
+                                }
+                            } else if (!types[i].getName().equals(typeNames[i])) {
                                 match = false;
                                 break;
                             }
@@ -235,7 +245,58 @@ public class ELProcessor {
                     ImportHandler importHandler = context.getImportHandler();
                     for (int i = 0; i < parameterTypeNames.length; i++) {
                         String parameterTypeName = parameterTypeNames[i].trim();
-                        if (!PRIMITIVES.contains(parameterTypeName) &&
+                        int dimension = 0;
+                        int bracketPos = parameterTypeName.indexOf('[');
+                        if (bracketPos > -1) {
+                            String parameterTypeNameOnly =
+                                    parameterTypeName.substring(0, bracketPos).trim();
+                            while (bracketPos > -1) {
+                                dimension++;
+                                bracketPos = parameterTypeName.indexOf('[', bracketPos+ 1);
+                            }
+                            parameterTypeName = parameterTypeNameOnly;
+                        }
+                        boolean varArgs = false;
+                        if (parameterTypeName.endsWith("...")) {
+                            varArgs = true;
+                            dimension = 1;
+                            parameterTypeName = parameterTypeName.substring(
+                                    0, parameterTypeName.length() -3);
+                        }
+                        boolean isPrimitive = PRIMITIVES.contains(parameterTypeName);
+                        if (isPrimitive && dimension > 0) {
+                            // When in an array, class name changes for primitive
+                            switch(parameterTypeName)
+                            {
+                                case "boolean":
+                                    parameterTypeName = "Z";
+                                    break;
+                                case "byte":
+                                    parameterTypeName = "B";
+                                    break;
+                                case "char":
+                                    parameterTypeName = "C";
+                                    break;
+                                case "double":
+                                    parameterTypeName = "D";
+                                    break;
+                                case "float":
+                                    parameterTypeName = "F";
+                                    break;
+                                case "int":
+                                    parameterTypeName = "I";
+                                    break;
+                                case "long":
+                                    parameterTypeName = "J";
+                                    break;
+                                case "short":
+                                    parameterTypeName = "S";
+                                    break;
+                                default:
+                                    // Should never happen
+                                    break;
+                            }
+                        } else  if (!isPrimitive &&
                                 !parameterTypeName.contains(".")) {
                             Class<?> clazz = importHandler.resolveClass(
                                     parameterTypeName);
@@ -246,8 +307,27 @@ public class ELProcessor {
                                         parameterTypeNames[i], methodName,
                                         className));
                             }
-                            parameterTypeNames[i] = clazz.getName();
+                            parameterTypeName = clazz.getName();
+                        }
+                        if (dimension > 0) {
+                            // Convert to array form of class name
+                            StringBuilder sb = new StringBuilder();
+                            for (int j = 0; j < dimension; j++) {
+                                sb.append('[');
+                            }
+                            if (!isPrimitive) {
+                                sb.append('L');
+                            }
+                            sb.append(parameterTypeName);
+                            if (!isPrimitive) {
+                                sb.append(';');
+                            }
+                            parameterTypeName = sb.toString();
+                        }
+                        if (varArgs) {
+                            parameterTypeName += "...";
                         }
+                        parameterTypeNames[i] = parameterTypeName;
                     }
                 }
             }

==================================================
ExpressionBuilder.java
index f8d5d3607e..dcf2a3de88 100644
--- a/java/org/apache/el/lang/ELSupport.java
+++ b/java/org/apache/el/lang/ELSupport.java
@@ -19,6 +19,7 @@ package org.apache.el.lang;
 
 import java.beans.PropertyEditor;
 import java.beans.PropertyEditorManager;
+import java.lang.reflect.Array;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.security.AccessController;
@@ -478,10 +479,34 @@ public class ELSupport {
             return Collections.EMPTY_MAP;
         }
 
+        // Handle arrays
+        if (type.isArray()) {
+            return coerceToArray(obj, type);
+        }
+
         throw new ELException(MessageFactory.get("error.convert",
                 obj, obj.getClass(), type));
     }
 
+    private static Object coerceToArray(final Object obj,
+            final Class<?> type) {
+        // Note: Nested arrays will result in nested calls to this method.
+
+        // Cast the input object to an array (calling method has checked it is
+        // an array)
+        Object[] array = (Object[]) obj;
+        // Get the target type for the array elements
+        Class<?> componentType = type.getComponentType();
+        // Create a new array of the correct type
+        Object result = Array.newInstance(componentType, array.length);
+        // Coerce each element in turn.
+        for (int i = 0; i < array.length; i++) {
+            Array.set(result, i, coerceToType(array[i], componentType));
+        }
+
+        return result;
+    }
+
     public static final boolean isBigDecimalOp(final Object obj0,
             final Object obj1) {
         return (obj0 instanceof BigDecimal || obj1 instanceof BigDecimal);

==================================================
AstFunction.java
index 64fc41c942..eafa507bfe 100644
--- a/java/org/apache/el/lang/ExpressionBuilder.java
+++ b/java/org/apache/el/lang/ExpressionBuilder.java
@@ -210,12 +210,14 @@ public final class ExpressionBuilder implements NodeVisitor {
                         "error.fnMapper.method", funcNode.getOutputName()));
             }
 
-            int pcnt = m.getParameterTypes().length;
+            int methodParameterCount = m.getParameterTypes().length;
             // AstFunction->MethodParameters->Parameters()
-            if (node.jjtGetChild(0).jjtGetNumChildren() != pcnt) {
+            int inputParameterCount = node.jjtGetChild(0).jjtGetNumChildren();
+            if (m.isVarArgs() && inputParameterCount < methodParameterCount - 1 ||
+                    !m.isVarArgs() && inputParameterCount != methodParameterCount) {
                 throw new ELException(MessageFactory.get(
                         "error.fnMapper.paramcount", funcNode.getOutputName(),
-                        "" + pcnt, "" + node.jjtGetNumChildren()));
+                        "" + methodParameterCount, "" + node.jjtGetChild(0).jjtGetNumChildren()));
             }
         } else if (node instanceof AstIdentifier && this.varMapper != null) {
             String variable = ((AstIdentifier) node).getImage();

==================================================
TestELProcessor.java
index edecbd0106..47ffc9a48d 100644
--- a/java/org/apache/el/parser/AstFunction.java
+++ b/java/org/apache/el/parser/AstFunction.java
@@ -161,13 +161,28 @@ public final class AstFunction extends SimpleNode {
         Class<?>[] paramTypes = m.getParameterTypes();
         Object[] params = null;
         Object result = null;
-        int numParams = parameters.jjtGetNumChildren();
-        if (numParams > 0) {
-            params = new Object[numParams];
+        int inputParameterCount = parameters.jjtGetNumChildren();
+        int methodParameterCount = paramTypes.length;
+        if (inputParameterCount > 0) {
+            params = new Object[methodParameterCount];
             try {
-                for (int i = 0; i < numParams; i++) {
-                    params[i] = parameters.jjtGetChild(i).getValue(ctx);
-                    params[i] = coerceToType(params[i], paramTypes[i]);
+                for (int i = 0; i < methodParameterCount; i++) {
+                    if (m.isVarArgs() && i == methodParameterCount - 1) {
+                        if (inputParameterCount < methodParameterCount) {
+                            params[i] = null;
+                        } else {
+                            Object[] varargs =
+                                    new Object[inputParameterCount - methodParameterCount + 1];
+                            Class<?> target = paramTypes[i].getComponentType();
+                            for (int j = i; j < inputParameterCount; j++) {
+                                varargs[j-i] = parameters.jjtGetChild(j).getValue(ctx);
+                                varargs[j-i] = coerceToType(varargs[j-i], target);
+                            }
+                        }
+                    } else {
+                        params[i] = parameters.jjtGetChild(i).getValue(ctx);
+                        params[i] = coerceToType(params[i], paramTypes[i]);
+                    }
                 }
             } catch (ELException ele) {
                 throw new ELException(MessageFactory.get("error.function", this

==================================================
TesterFunctions.java
index 36e8e68e82..18691bc71a 100644
--- a/test/javax/el/TestELProcessor.java
+++ b/test/javax/el/TestELProcessor.java
@@ -129,4 +129,66 @@ public class TestELProcessor {
         elp.eval("fn:doIt(5)");
         Assert.assertEquals("B", TesterFunctions.getCallList());
     }
+
+
+    @Test
+    public void testDefineFunctionName08() throws Exception {
+        TesterFunctions.resetCallList();
+        ELProcessor elp = new ELProcessor();
+        elp.defineFunction("fn", "", "javax.el.TesterFunctions", "void doIt(int[])");
+        elp.eval("fn:doIt([5].stream().toArray())");
+        Assert.assertEquals("D", TesterFunctions.getCallList());
+    }
+
+
+    @Test
+    public void testDefineFunctionName09() throws Exception {
+        TesterFunctions.resetCallList();
+        ELProcessor elp = new ELProcessor();
+        elp.defineFunction("fn", "", "javax.el.TesterFunctions", "void doIt(int[][])");
+        elp.eval("fn:doIt([[5].stream().toArray()].stream().toArray())");
+        Assert.assertEquals("E", TesterFunctions.getCallList());
+    }
+
+
+    @Test
+    public void testDefineFunctionName10() throws Exception {
+        TesterFunctions.resetCallList();
+        ELProcessor elp = new ELProcessor();
+        elp.defineFunction("fn", "test1", "java.lang.Integer", "Integer valueOf(int)");
+        elp.defineFunction("fn", "test2", "javax.el.TesterFunctions", "void doIt(Integer[])");
+        elp.eval("fn:test2([fn:test1(1), fn:test1(2)].stream().toArray())");
+        Assert.assertEquals("F", TesterFunctions.getCallList());
+    }
+
+
+    @Test
+    public void testDefineFunctionName11() throws Exception {
+        TesterFunctions.resetCallList();
+        ELProcessor elp = new ELProcessor();
+        elp.defineFunction("fn", "test1", "java.lang.Integer", "Integer valueOf(int)");
+        elp.defineFunction("fn", "test2", "javax.el.TesterFunctions", "void doIt(Integer[][])");
+        elp.eval("fn:test2([[fn:test1(1), fn:test1(2)].stream().toArray()].stream().toArray())");
+        Assert.assertEquals("G", TesterFunctions.getCallList());
+    }
+
+
+    @Test
+    public void testDefineFunctionName12() throws Exception {
+        TesterFunctions.resetCallList();
+        ELProcessor elp = new ELProcessor();
+        elp.defineFunction("fn", "test", "javax.el.TesterFunctions", "void doIt(long...)");
+        elp.eval("fn:test(1,2)");
+        Assert.assertEquals("H", TesterFunctions.getCallList());
+    }
+
+
+    @Test
+    public void testDefineFunctionName13() throws Exception {
+        TesterFunctions.resetCallList();
+        ELProcessor elp = new ELProcessor();
+        elp.defineFunction("fn", "test", "javax.el.TesterFunctions", "void doIt(Object...)");
+        elp.eval("fn:test(null, null)");
+        Assert.assertEquals("I", TesterFunctions.getCallList());
+    }
 }

==================================================
