e0c76f691936fb4c9a679866adf2bbc575e55383
==================================================
Rework the fix for BZ 64021 for better custom class loader support
==================================================
Mark Thomas
==================================================
Sun Apr 12 17:05:35 2020 +0100
==================================================
WebappServiceLoader.java
Rework the fix for BZ 64021 for better custom class loader support

https://bz.apache.org/bugzilla/show_bug.cgi?id=64021
Better support custom class loaders that load resources from
non-standard locations and do not utilise the WebResources
implementation.


==================================================
TestWebappServiceLoader.java
index bd3bfe54d7..e222940529 100644
--- a/java/org/apache/catalina/startup/WebappServiceLoader.java
+++ b/java/org/apache/catalina/startup/WebappServiceLoader.java
@@ -26,15 +26,16 @@ import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Enumeration;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Set;
 import java.util.regex.Pattern;
 
 import jakarta.servlet.ServletContext;
 
 import org.apache.catalina.Context;
-import org.apache.catalina.WebResource;
 import org.apache.tomcat.util.scan.JarFactory;
 
 /**
@@ -67,6 +68,7 @@ public class WebappServiceLoader<T> {
     private final ServletContext servletContext;
     private final Pattern containerSciFilterPattern;
 
+
     /**
      * Construct a loader to load services from a ServletContext.
      *
@@ -83,8 +85,14 @@ public class WebappServiceLoader<T> {
         }
     }
 
+
     /**
-     * Load the providers for a service type.
+     * Load the providers for a service type. Container defined services will be
+     * loaded before application defined services in case the application
+     * depends on a Container provided service. Note that services are always
+     * loaded via the Context (web application) class loader so it is possible
+     * for an application to provide an alternative implementation of what would
+     * normally be a Container provided service.
      *
      * @param serviceType the type of service to load
      * @return an unmodifiable collection of service providers
@@ -93,21 +101,64 @@ public class WebappServiceLoader<T> {
     public List<T> load(Class<T> serviceType) throws IOException {
         String configFile = SERVICES + serviceType.getName();
 
-        LinkedHashSet<String> applicationServicesFound = new LinkedHashSet<>();
-        LinkedHashSet<String> containerServicesFound = new LinkedHashSet<>();
+        // Obtain the Container provided service configuration files.
+        ClassLoader loader = context.getParentClassLoader();
+        Enumeration<URL> containerResources;
+        if (loader == null) {
+            containerResources = ClassLoader.getSystemResources(configFile);
+        } else {
+            containerResources = loader.getResources(configFile);
+        }
+
+        // Extract the Container provided service class names. Each
+        // configuration file may list more than one service class name. This
+        // uses a LinkedHashSet so if a service class name appears more than
+        // once in the configuration files, only the first one found is used.
+        LinkedHashSet<String> containerServiceClassNames = new LinkedHashSet<>();
+        Set<URL> containerServiceConfigFiles = new HashSet<>();
+        while (containerResources.hasMoreElements()) {
+            URL containerServiceConfigFile = containerResources.nextElement();
+            containerServiceConfigFiles.add(containerServiceConfigFile);
+            parseConfigFile(containerServiceClassNames, containerServiceConfigFile);
+        }
+
+        // Filter the discovered container SCIs if required
+        if (containerSciFilterPattern != null) {
+            Iterator<String> iter = containerServiceClassNames.iterator();
+            while (iter.hasNext()) {
+                if (containerSciFilterPattern.matcher(iter.next()).find()) {
+                    iter.remove();
+                }
+            }
+        }
 
-        // if the ServletContext has ORDERED_LIBS, then use that to specify the
-        // set of JARs from WEB-INF/lib that should be used for loading services
+        // Obtaining the application provided configuration files is a little
+        // more difficult for two reasons:
+        // - The web application may employ a custom class loader. Ideally, we
+        //   would use ClassLoader.findResources() but that method is protected.
+        //   We could force custom class loaders to override that method and
+        //   make it public but that would be a new requirement and break
+        //   backwards compatibility for what is an often customised component.
+        // - If the application web.xml file has defined an order for fragments
+        //   then only those JAR files represented by fragments in that order
+        //   (and arguably WEB-INF/classes) should be scanned for services.
+        LinkedHashSet<String> applicationServiceClassNames = new LinkedHashSet<>();
+
+        // Check to see if the ServletContext has ORDERED_LIBS defined
         @SuppressWarnings("unchecked")
         List<String> orderedLibs = (List<String>) servletContext.getAttribute(ServletContext.ORDERED_LIBS);
 
-        // Handle application SCIs directly...
+        // Obtain the application provided service configuration files
         if (orderedLibs == null) {
-            // No ordered libs, so use every service definition we can find
-            WebResource[] resources = context.getResources().getClassLoaderResources("/" + configFile);
-            for (WebResource resource : resources) {
-                if (resource.isFile()) {
-                    parseConfigFile(applicationServicesFound, resource.getURL());
+            // Because a custom class loader may be being used, we have to use
+            // getResources() which will return application and Container files.
+            Enumeration<URL> allResources = servletContext.getClassLoader().getResources(configFile);
+            while (allResources.hasMoreElements()) {
+                URL serviceConfigFile = allResources.nextElement();
+                // Only process the service configuration file if it is not a
+                // Container level file that has already been processed
+                if (!containerServiceConfigFiles.contains(serviceConfigFile)) {
+                    parseConfigFile(applicationServiceClassNames, serviceConfigFile);
                 }
             }
         } else {
@@ -115,7 +166,7 @@ public class WebappServiceLoader<T> {
             // in WEB-INF/classes
             URL unpacked = servletContext.getResource(CLASSES + configFile);
             if (unpacked != null) {
-                parseConfigFile(applicationServicesFound, unpacked);
+                parseConfigFile(applicationServiceClassNames, unpacked);
             }
 
             for (String lib : orderedLibs) {
@@ -133,49 +184,27 @@ public class WebappServiceLoader<T> {
                     url = JarFactory.getJarEntryURL(jarUrl, configFile);
                 }
                 try {
-                    parseConfigFile(applicationServicesFound, url);
+                    parseConfigFile(applicationServiceClassNames, url);
                 } catch (FileNotFoundException e) {
                     // no provider file found, this is OK
                 }
             }
         }
 
-        // and use the parent ClassLoader for all other SCIs
-        ClassLoader loader = context.getParentClassLoader();
-
-        Enumeration<URL> resources;
-        if (loader == null) {
-            resources = ClassLoader.getSystemResources(configFile);
-        } else {
-            resources = loader.getResources(configFile);
-        }
-        while (resources.hasMoreElements()) {
-            parseConfigFile(containerServicesFound, resources.nextElement());
-        }
-
-        // Filter the discovered container SCIs if required
-        if (containerSciFilterPattern != null) {
-            Iterator<String> iter = containerServicesFound.iterator();
-            while (iter.hasNext()) {
-                if (containerSciFilterPattern.matcher(iter.next()).find()) {
-                    iter.remove();
-                }
-            }
-        }
-
         // Add the application services after the container services to ensure
         // that the container services are loaded first
-        containerServicesFound.addAll(applicationServicesFound);
+        containerServiceClassNames.addAll(applicationServiceClassNames);
 
-        // load the discovered services
-        if (containerServicesFound.isEmpty()) {
+        // Short-cut if no services have been found
+        if (containerServiceClassNames.isEmpty()) {
             return Collections.emptyList();
         }
-        return loadServices(serviceType, containerServicesFound);
+        // Load the discovered services
+        return loadServices(serviceType, containerServiceClassNames);
     }
 
-    void parseConfigFile(LinkedHashSet<String> servicesFound, URL url)
-            throws IOException {
+
+    void parseConfigFile(LinkedHashSet<String> servicesFound, URL url) throws IOException {
         try (InputStream is = url.openStream();
             InputStreamReader in = new InputStreamReader(is, StandardCharsets.UTF_8);
             BufferedReader reader = new BufferedReader(in)) {
@@ -194,8 +223,8 @@ public class WebappServiceLoader<T> {
         }
     }
 
-    List<T> loadServices(Class<T> serviceType, LinkedHashSet<String> servicesFound)
-            throws IOException {
+
+    List<T> loadServices(Class<T> serviceType, LinkedHashSet<String> servicesFound) throws IOException {
         ClassLoader loader = servletContext.getClassLoader();
         List<T> services = new ArrayList<>(servicesFound.size());
         for (String serviceClass : servicesFound) {

==================================================
