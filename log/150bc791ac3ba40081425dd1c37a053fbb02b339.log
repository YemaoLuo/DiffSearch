150bc791ac3ba40081425dd1c37a053fbb02b339
==================================================
Expand UTF-8 tests based on a test case written by Joe Orton for CVE-2008-2938
==================================================
Mark Emlyn
==================================================
Sat Mar 2 20:17:28 2013 +0000
==================================================
Utf8Decoder.java
Expand UTF-8 tests based on a test case written by Joe Orton for CVE-2008-2938
Note the additional failures this generates are not exploitable. They are invalid only because they encode a valid code point in too many bytes.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1451933 13f79535-47bb-0310-9956-ffa450edef68



==================================================
TestUtf8.java
index c11da9b78c..92d85055da 100644
--- a/java/org/apache/tomcat/websocket/Utf8Decoder.java
+++ b/java/org/apache/tomcat/websocket/Utf8Decoder.java
@@ -169,13 +169,31 @@ public class Utf8Decoder extends CharsetDecoder {
                     return CoderResult.malformedForLength(1);
                 }
                 if (inIndexLimit - inIndex < 1 + tail) {
-                    // Apache Tomcat added test - detects invalid sequence as
+                    // Apache Tomcat added tests - detect invalid sequences as
                     // early as possible
                     if (jchar == 0x74 && inIndexLimit > inIndex + 1) {
                         if ((bArr[inIndex + 1] & 0xFF) > 0x8F) {
+                            // 11110100 1yyyxxxx xxxxxxxx xxxxxxxx
+                            // Any non-zero y is > max code point
                             return CoderResult.unmappableForLength(4);
                         }
                     }
+                    if (jchar == 0x60 && inIndexLimit > inIndex +1) {
+                        if ((bArr[inIndex + 1] & 0x7F) == 0) {
+                            // 11100000 10000000 10xxxxxx
+                            // should have been
+                            // 00xxxxxx
+                            return CoderResult.malformedForLength(3);
+                        }
+                    }
+                    if (jchar == 0x70 && inIndexLimit > inIndex +1) {
+                        if ((bArr[inIndex + 1] & 0x7F) < 0x10) {
+                            // 11110000 1000zzzz 1oyyyyyy 1oxxxxxx
+                            // should have been
+                            // 111ozzzz 1oyyyyyy 1oxxxxxx
+                            return CoderResult.malformedForLength(4);
+                        }
+                    }
                     break;
                 }
                 for (int i = 0; i < tail; i++) {

==================================================
