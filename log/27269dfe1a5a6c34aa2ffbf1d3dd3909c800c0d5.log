27269dfe1a5a6c34aa2ffbf1d3dd3909c800c0d5
==================================================
Some initial plumbing for SNI.
==================================================
Mark Thomas
==================================================
Thu Apr 9 15:16:42 2015 +0000
==================================================
Nio2Channel.java
Some initial plumbing for SNI.
While Java 8 supports SNI, if you want different certs for different hosts then you have to manually parse the incoming TLS bytes to look for the SNI extension. This makes it 'interesting'. The idea at this point is to do it as part of the handshake. This will require moving the SSLEngine init code to processSNI() - that is the next step.
Fix some Java 8 Javadoc issues while I was in the area.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1672393 13f79535-47bb-0310-9956-ffa450edef68



==================================================
NioChannel.java
index 8f70958150..edee7cde50 100644
--- a/java/org/apache/tomcat/util/net/Nio2Channel.java
+++ b/java/org/apache/tomcat/util/net/Nio2Channel.java
@@ -70,12 +70,21 @@ public class Nio2Channel implements AsynchronousByteChannel {
         sc.close();
     }
 
+
+    /**
+     * Close the connection.
+     *
+     * @param force Should the underlying socket be forcibly closed?
+     *
+     * @throws IOException If closing the secure channel fails.
+     */
     public void close(boolean force) throws IOException {
         if (isOpen() || force) {
             close();
         }
     }
 
+
     /**
      * Tells whether or not this channel is open.
      *

==================================================
SecureNio2Channel.java
index 8f05e2dda9..8f13482465 100644
--- a/java/org/apache/tomcat/util/net/NioChannel.java
+++ b/java/org/apache/tomcat/util/net/NioChannel.java
@@ -92,9 +92,17 @@ public class NioChannel implements ByteChannel {
         getIOChannel().close();
     }
 
+    /**
+     * Close the connection.
+     *
+     * @param force Should the underlying socket be forcibly closed?
+     *
+     * @throws IOException If closing the secure channel fails.
+     */
     public void close(boolean force) throws IOException {
         if (isOpen() || force ) close();
     }
+
     /**
      * Tells whether or not this channel is open.
      *

==================================================
SecureNioChannel.java
index 3a15505d4b..a4b5fefa44 100644
--- a/java/org/apache/tomcat/util/net/SecureNio2Channel.java
+++ b/java/org/apache/tomcat/util/net/SecureNio2Channel.java
@@ -50,6 +50,8 @@ public class SecureNio2Channel extends Nio2Channel  {
     protected SSLEngine sslEngine;
     protected final Nio2Endpoint endpoint;
 
+    protected boolean sniComplete = false;
+
     protected boolean handshakeComplete;
     protected HandshakeStatus handshakeStatus; //gets set by handshake
 
@@ -191,7 +193,8 @@ public class SecureNio2Channel extends Nio2Channel  {
      * In the event of a positive value coming back, reregister the selection key for the return values interestOps.
      *
      * @return int - 0 if hand shake is complete, otherwise it returns a SelectionKey interestOps value
-     * @throws IOException
+     * @throws IOException If an I/O error occurs during the handshake or if the
+     *                     handshake fails during wrapping or unwrapping
      */
     @Override
     public int handshake() throws IOException {
@@ -199,8 +202,18 @@ public class SecureNio2Channel extends Nio2Channel  {
     }
 
     protected int handshakeInternal(boolean async) throws IOException {
-        if (handshakeComplete)
+        if (handshakeComplete) {
             return 0; //we have done our initial handshake
+        }
+
+        if (!sniComplete) {
+            int sniResult = processSNI();
+            if (sniResult == 0) {
+                sniComplete = true;
+            } else {
+                return sniResult;
+            }
+        }
 
         SSLEngineResult handshake = null;
 
@@ -290,6 +303,17 @@ public class SecureNio2Channel extends Nio2Channel  {
         return handshakeComplete ? 0 : handshakeInternal(async);
     }
 
+
+    /*
+     * Peeks at the initial network bytes to determine if the SNI extension is
+     * present and, if it is, what host name has been requested. Based on the
+     * provided host name, configure the SSLEngine for this connection.
+     */
+    private int processSNI() {
+        return 0;
+    }
+
+
     /**
      * Force a blocking handshake to take place for this key.
      * This requires that both network and application buffers have been emptied out prior to this call taking place, or a
@@ -452,11 +476,6 @@ public class SecureNio2Channel extends Nio2Channel  {
         closed = (!netOutBuffer.hasRemaining() && (handshake.getHandshakeStatus() != HandshakeStatus.NEED_WRAP));
     }
 
-    /**
-     * Force a close, can throw an IOException
-     * @param force boolean
-     * @throws IOException
-     */
     @Override
     public void close(boolean force) throws IOException {
         try {

==================================================
