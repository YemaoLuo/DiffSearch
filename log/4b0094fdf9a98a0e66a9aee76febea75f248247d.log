4b0094fdf9a98a0e66a9aee76febea75f248247d
==================================================
Update javacc from 4.1 to 5.0. Update generated code.
==================================================
Mark Emlyn
==================================================
Fri Jan 1 15:00:52 2010 +0000
==================================================
ELParser.java
Update javacc from 4.1 to 5.0. Update generated code.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@895020 13f79535-47bb-0310-9956-ffa450edef68



==================================================
ELParserTreeConstants.java
index f1ac4bd313..e6b2652281 100644
--- a/java/org/apache/el/parser/ELParser.java
+++ b/java/org/apache/el/parser/ELParser.java
@@ -2074,7 +2074,7 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
       return (jj_ntk = jj_nt.kind);
   }
 
-  private java.util.List jj_expentries = new java.util.ArrayList();
+  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
   private int[] jj_expentry;
   private int jj_kind = -1;
   private int[] jj_lasttokens = new int[100];
@@ -2089,7 +2089,7 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
       for (int i = 0; i < jj_endpos; i++) {
         jj_expentry[i] = jj_lasttokens[i];
       }
-      jj_entries_loop: for (java.util.Iterator it = jj_expentries.iterator(); it.hasNext();) {
+      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
         int[] oldentry = (int[])(it.next());
         if (oldentry.length == jj_expentry.length) {
           for (int i = 0; i < jj_expentry.length; i++) {
@@ -2137,7 +2137,7 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
     jj_add_error_token(0, 0);
     int[][] exptokseq = new int[jj_expentries.size()][];
     for (int i = 0; i < jj_expentries.size(); i++) {
-      exptokseq[i] = (int[])jj_expentries.get(i);
+      exptokseq[i] = jj_expentries.get(i);
     }
     return new ParseException(token, exptokseq, tokenImage);
   }

==================================================
JJTELParserState.java
index 5d911df6d8..87e3522682 100644
--- a/java/org/apache/el/parser/ELParserTreeConstants.java
+++ b/java/org/apache/el/parser/ELParserTreeConstants.java
@@ -1,4 +1,4 @@
-/* Generated By:JavaCC: Do not edit this line. ELParserTreeConstants.java Version 4.1 */
+/* Generated By:JavaCC: Do not edit this line. ELParserTreeConstants.java Version 5.0 */
 package org.apache.el.parser;
 
 public interface ELParserTreeConstants
@@ -74,4 +74,4 @@ public interface ELParserTreeConstants
     "Null",
   };
 }
-/* JavaCC - OriginalChecksum=3f8a43fb30bdf082a70de7eb7b15fdf1 (do not edit this line) */
+/* JavaCC - OriginalChecksum=5af14271a4fcdc582f7dce53f6c6146d (do not edit this line) */

==================================================
ParseException.java
index 267ead9a35..420fe86eee 100644
--- a/java/org/apache/el/parser/JJTELParserState.java
+++ b/java/org/apache/el/parser/JJTELParserState.java
@@ -1,17 +1,17 @@
-/* Generated By:JavaCC: Do not edit this line. JJTELParserState.java Version 4.1 */
+/* Generated By:JavaCC: Do not edit this line. JJTELParserState.java Version 5.0 */
 package org.apache.el.parser;
 
 public class JJTELParserState {
-  private java.util.List nodes;
-  private java.util.List marks;
+  private java.util.List<Node> nodes;
+  private java.util.List<Integer> marks;
 
   private int sp;        // number of nodes on stack
   private int mk;        // current mark
   private boolean node_created;
 
   public JJTELParserState() {
-    nodes = new java.util.ArrayList();
-    marks = new java.util.ArrayList();
+    nodes = new java.util.ArrayList<Node>();
+    marks = new java.util.ArrayList<Integer>();
     sp = 0;
     mk = 0;
   }
@@ -35,7 +35,7 @@ public class JJTELParserState {
   /* Returns the root node of the AST.  It only makes sense to call
      this after a successful parse. */
   public Node rootNode() {
-    return (Node)nodes.get(0);
+    return nodes.get(0);
   }
 
   /* Pushes a node on to the stack. */
@@ -48,14 +48,14 @@ public class JJTELParserState {
      stack.  */
   public Node popNode() {
     if (--sp < mk) {
-      mk = ((Integer)marks.remove(marks.size()-1)).intValue();
+      mk = marks.remove(marks.size()-1);
     }
-    return (Node)nodes.remove(nodes.size()-1);
+    return nodes.remove(nodes.size()-1);
   }
 
   /* Returns the node currently on the top of the stack. */
   public Node peekNode() {
-    return (Node)nodes.get(nodes.size()-1);
+    return nodes.get(nodes.size()-1);
   }
 
   /* Returns the number of children on the stack in the current node
@@ -69,12 +69,12 @@ public class JJTELParserState {
     while (sp > mk) {
       popNode();
     }
-    mk = ((Integer)marks.remove(marks.size()-1)).intValue();
+    mk = marks.remove(marks.size()-1);
   }
 
 
   public void openNodeScope(Node n) {
-    marks.add(new Integer(mk));
+    marks.add(mk);
     mk = sp;
     n.jjtOpen();
   }
@@ -85,7 +85,7 @@ public class JJTELParserState {
      made the children of the definite node.  Then the definite node
      is pushed on to the stack. */
   public void closeNodeScope(Node n, int num) {
-    mk = ((Integer)marks.remove(marks.size()-1)).intValue();
+    mk = marks.remove(marks.size()-1);
     while (num-- > 0) {
       Node c = popNode();
       c.jjtSetParent(n);
@@ -105,7 +105,7 @@ public class JJTELParserState {
   public void closeNodeScope(Node n, boolean condition) {
     if (condition) {
       int a = nodeArity();
-      mk = ((Integer)marks.remove(marks.size()-1)).intValue();
+      mk = marks.remove(marks.size()-1);
       while (a-- > 0) {
         Node c = popNode();
         c.jjtSetParent(n);
@@ -115,9 +115,9 @@ public class JJTELParserState {
       pushNode(n);
       node_created = true;
     } else {
-      mk = ((Integer)marks.remove(marks.size()-1)).intValue();
+      mk = marks.remove(marks.size()-1);
       node_created = false;
     }
   }
 }
-/* JavaCC - OriginalChecksum=9497b88da93266c314e4e50d08492496 (do not edit this line) */
+/* JavaCC - OriginalChecksum=9ea5296a2e1d85c8100fe40283f86cfd (do not edit this line) */

==================================================
SimpleCharStream.java
index 1a6af71a48..e7e6191b65 100644
--- a/java/org/apache/el/parser/ParseException.java
+++ b/java/org/apache/el/parser/ParseException.java
@@ -1,4 +1,4 @@
-/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 4.1 */
+/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 5.0 */
 /* JavaCCOptions:KEEP_LINE_COL=null */
 package org.apache.el.parser;
 
@@ -13,25 +13,25 @@ package org.apache.el.parser;
  */
 public class ParseException extends Exception {
 
+  /**
+   * The version identifier for this Serializable class.
+   * Increment only if the <i>serialized</i> form of the
+   * class changes.
+   */
+  private static final long serialVersionUID = 1L;
+
   /**
    * This constructor is used by the method "generateParseException"
    * in the generated parser.  Calling this constructor generates
    * a new object of this type with the fields "currentToken",
-   * "expectedTokenSequences", and "tokenImage" set.  The boolean
-   * flag "specialConstructor" is also set to true to indicate that
-   * this constructor was used to create this object.
-   * This constructor calls its super class with the empty string
-   * to force the "toString" method of parent class "Throwable" to
-   * print the error message in the form:
-   *     ParseException: <result of getMessage>
+   * "expectedTokenSequences", and "tokenImage" set.
    */
   public ParseException(Token currentTokenVal,
                         int[][] expectedTokenSequencesVal,
                         String[] tokenImageVal
                        )
   {
-    super("");
-    specialConstructor = true;
+    super(initialise(currentTokenVal, expectedTokenSequencesVal, tokenImageVal));
     currentToken = currentTokenVal;
     expectedTokenSequences = expectedTokenSequencesVal;
     tokenImage = tokenImageVal;
@@ -49,21 +49,13 @@ public class ParseException extends Exception {
 
   public ParseException() {
     super();
-    specialConstructor = false;
   }
 
   /** Constructor with message. */
   public ParseException(String message) {
     super(message);
-    specialConstructor = false;
   }
 
-  /**
-   * This variable determines which constructor was used to create
-   * this object and thereby affects the semantics of the
-   * "getMessage" method (see below).
-   */
-  protected boolean specialConstructor;
 
   /**
    * This is the last token that has been consumed successfully.  If
@@ -87,21 +79,17 @@ public class ParseException extends Exception {
   public String[] tokenImage;
 
   /**
-   * This method has the standard behavior when this object has been
-   * created using the standard constructors.  Otherwise, it uses
-   * "currentToken" and "expectedTokenSequences" to generate a parse
+   * It uses "currentToken" and "expectedTokenSequences" to generate a parse
    * error message and returns it.  If this object has been created
    * due to a parse error, and you do not catch it (it gets thrown
-   * from the parser), then this method is called during the printing
-   * of the final stack trace, and hence the correct error message
+   * from the parser) the correct error message
    * gets displayed.
    */
-  @Override
-  public String getMessage() {
-    if (!specialConstructor) {
-      return super.getMessage();
-    }
-    StringBuilder expected = new StringBuilder();
+  private static String initialise(Token currentToken,
+                           int[][] expectedTokenSequences,
+                           String[] tokenImage) {
+    String eol = System.getProperty("line.separator", "\n");
+    StringBuffer expected = new StringBuffer();
     int maxSize = 0;
     for (int i = 0; i < expectedTokenSequences.length; i++) {
       if (maxSize < expectedTokenSequences[i].length) {
@@ -150,7 +138,7 @@ public class ParseException extends Exception {
    * when these raw version cannot be used as part of an ASCII
    * string literal.
    */
-  protected String add_escapes(String str) {
+  static String add_escapes(String str) {
       StringBuilder retval = new StringBuilder();
       char ch;
       for (int i = 0; i < str.length(); i++) {
@@ -196,4 +184,4 @@ public class ParseException extends Exception {
    }
 
 }
-/* JavaCC - OriginalChecksum=a147e4edaa2a39e08e6f250c30247549 (do not edit this line) */
+/* JavaCC - OriginalChecksum=275dbff1ac8d899b542b475adbf177f7 (do not edit this line) */

==================================================
Token.java
index 7e2202b40e..e89778ae33 100644
--- a/java/org/apache/el/parser/SimpleCharStream.java
+++ b/java/org/apache/el/parser/SimpleCharStream.java
@@ -1,5 +1,5 @@
-/* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 4.1 */
-/* JavaCCOptions:STATIC=false */
+/* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 5.0 */
+/* JavaCCOptions:STATIC=false,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
 package org.apache.el.parser;
 
 /**
@@ -38,194 +38,192 @@ public class SimpleCharStream
 
   protected void ExpandBuff(boolean wrapAround)
   {
-     char[] newbuffer = new char[bufsize + 2048];
-     int newbufline[] = new int[bufsize + 2048];
-     int newbufcolumn[] = new int[bufsize + 2048];
+    char[] newbuffer = new char[bufsize + 2048];
+    int newbufline[] = new int[bufsize + 2048];
+    int newbufcolumn[] = new int[bufsize + 2048];
 
-     try
-     {
-        if (wrapAround)
-        {
-           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
-           System.arraycopy(buffer, 0, newbuffer,
-                                             bufsize - tokenBegin, bufpos);
-           buffer = newbuffer;
-
-           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
-           System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
-           bufline = newbufline;
-
-           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
-           System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
-           bufcolumn = newbufcolumn;
-
-           maxNextCharInd = (bufpos += (bufsize - tokenBegin));
-        }
-        else
-        {
-           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
-           buffer = newbuffer;
-
-           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
-           bufline = newbufline;
-
-           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
-           bufcolumn = newbufcolumn;
-
-           maxNextCharInd = (bufpos -= tokenBegin);
-        }
-     }
-     catch (Throwable t)
-     {
-        throw new Error(t.getMessage());
-     }
+    try
+    {
+      if (wrapAround)
+      {
+        System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
+        System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);
+        buffer = newbuffer;
+
+        System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
+        System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
+        bufline = newbufline;
+
+        System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
+        System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
+        bufcolumn = newbufcolumn;
+
+        maxNextCharInd = (bufpos += (bufsize - tokenBegin));
+      }
+      else
+      {
+        System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
+        buffer = newbuffer;
+
+        System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
+        bufline = newbufline;
+
+        System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
+        bufcolumn = newbufcolumn;
+
+        maxNextCharInd = (bufpos -= tokenBegin);
+      }
+    }
+    catch (Throwable t)
+    {
+      throw new Error(t.getMessage());
+    }
 
 
-     bufsize += 2048;
-     available = bufsize;
-     tokenBegin = 0;
+    bufsize += 2048;
+    available = bufsize;
+    tokenBegin = 0;
   }
 
   protected void FillBuff() throws java.io.IOException
   {
-     if (maxNextCharInd == available)
-     {
-        if (available == bufsize)
+    if (maxNextCharInd == available)
+    {
+      if (available == bufsize)
+      {
+        if (tokenBegin > 2048)
         {
-           if (tokenBegin > 2048)
-           {
-              bufpos = maxNextCharInd = 0;
-              available = tokenBegin;
-           }
-           else if (tokenBegin < 0)
-              bufpos = maxNextCharInd = 0;
-           else
-              ExpandBuff(false);
+          bufpos = maxNextCharInd = 0;
+          available = tokenBegin;
         }
-        else if (available > tokenBegin)
-           available = bufsize;
-        else if ((tokenBegin - available) < 2048)
-           ExpandBuff(true);
+        else if (tokenBegin < 0)
+          bufpos = maxNextCharInd = 0;
         else
-           available = tokenBegin;
-     }
+          ExpandBuff(false);
+      }
+      else if (available > tokenBegin)
+        available = bufsize;
+      else if ((tokenBegin - available) < 2048)
+        ExpandBuff(true);
+      else
+        available = tokenBegin;
+    }
 
-     int i;
-     try {
-        if ((i = inputStream.read(buffer, maxNextCharInd,
-                                    available - maxNextCharInd)) == -1)
-        {
-           inputStream.close();
-           throw new java.io.IOException();
-        }
-        else
-           maxNextCharInd += i;
-        return;
-     }
-     catch(java.io.IOException e) {
-        --bufpos;
-        backup(0);
-        if (tokenBegin == -1)
-           tokenBegin = bufpos;
-        throw e;
-     }
+    int i;
+    try {
+      if ((i = inputStream.read(buffer, maxNextCharInd, available - maxNextCharInd)) == -1)
+      {
+        inputStream.close();
+        throw new java.io.IOException();
+      }
+      else
+        maxNextCharInd += i;
+      return;
+    }
+    catch(java.io.IOException e) {
+      --bufpos;
+      backup(0);
+      if (tokenBegin == -1)
+        tokenBegin = bufpos;
+      throw e;
+    }
   }
 
 /** Start. */
   public char BeginToken() throws java.io.IOException
   {
-     tokenBegin = -1;
-     char c = readChar();
-     tokenBegin = bufpos;
+    tokenBegin = -1;
+    char c = readChar();
+    tokenBegin = bufpos;
 
-     return c;
+    return c;
   }
 
   protected void UpdateLineColumn(char c)
   {
-     column++;
+    column++;
 
-     if (prevCharIsLF)
-     {
-        prevCharIsLF = false;
+    if (prevCharIsLF)
+    {
+      prevCharIsLF = false;
+      line += (column = 1);
+    }
+    else if (prevCharIsCR)
+    {
+      prevCharIsCR = false;
+      if (c == '\n')
+      {
+        prevCharIsLF = true;
+      }
+      else
         line += (column = 1);
-     }
-     else if (prevCharIsCR)
-     {
-        prevCharIsCR = false;
-        if (c == '\n')
-        {
-           prevCharIsLF = true;
-        }
-        else
-           line += (column = 1);
-     }
-
-     switch (c)
-     {
-        case '\r' :
-           prevCharIsCR = true;
-           break;
-        case '\n' :
-           prevCharIsLF = true;
-           break;
-        case '\t' :
-           column--;
-           column += (tabSize - (column % tabSize));
-           break;
-        default :
-           break;
-     }
-
-     bufline[bufpos] = line;
-     bufcolumn[bufpos] = column;
+    }
+
+    switch (c)
+    {
+      case '\r' :
+        prevCharIsCR = true;
+        break;
+      case '\n' :
+        prevCharIsLF = true;
+        break;
+      case '\t' :
+        column--;
+        column += (tabSize - (column % tabSize));
+        break;
+      default :
+        break;
+    }
+
+    bufline[bufpos] = line;
+    bufcolumn[bufpos] = column;
   }
 
 /** Read a character. */
   public char readChar() throws java.io.IOException
   {
-     if (inBuf > 0)
-     {
-        --inBuf;
+    if (inBuf > 0)
+    {
+      --inBuf;
 
-        if (++bufpos == bufsize)
-           bufpos = 0;
+      if (++bufpos == bufsize)
+        bufpos = 0;
 
-        return buffer[bufpos];
-     }
+      return buffer[bufpos];
+    }
 
-     if (++bufpos >= maxNextCharInd)
-        FillBuff();
+    if (++bufpos >= maxNextCharInd)
+      FillBuff();
 
-     char c = buffer[bufpos];
+    char c = buffer[bufpos];
 
-     UpdateLineColumn(c);
-     return c;
+    UpdateLineColumn(c);
+    return c;
   }
 
+  @Deprecated
   /**
    * @deprecated
    * @see #getEndColumn
    */
 
-  @Deprecated
-public int getColumn() {
-     return bufcolumn[bufpos];
+  public int getColumn() {
+    return bufcolumn[bufpos];
   }
 
+  @Deprecated
   /**
    * @deprecated
    * @see #getEndLine
    */
 
-  @Deprecated
-public int getLine() {
-     return bufline[bufpos];
+  public int getLine() {
+    return bufline[bufpos];
   }
 
   /** Get token end column number. */
   public int getEndColumn() {
-     return bufcolumn[bufpos];
+    return bufcolumn[bufpos];
   }
 
   /** Get token end line number. */
@@ -235,12 +233,12 @@ public int getLine() {
 
   /** Get token beginning column number. */
   public int getBeginColumn() {
-     return bufcolumn[tokenBegin];
+    return bufcolumn[tokenBegin];
   }
 
   /** Get token beginning line number. */
   public int getBeginLine() {
-     return bufline[tokenBegin];
+    return bufline[tokenBegin];
   }
 
 /** Backup a number of characters. */
@@ -248,7 +246,7 @@ public int getLine() {
 
     inBuf += amount;
     if ((bufpos -= amount) < 0)
-       bufpos += bufsize;
+      bufpos += bufsize;
   }
 
   /** Constructor. */
@@ -269,13 +267,13 @@ public int getLine() {
   public SimpleCharStream(java.io.Reader dstream, int startline,
                           int startcolumn)
   {
-     this(dstream, startline, startcolumn, 4096);
+    this(dstream, startline, startcolumn, 4096);
   }
 
   /** Constructor. */
   public SimpleCharStream(java.io.Reader dstream)
   {
-     this(dstream, 1, 1, 4096);
+    this(dstream, 1, 1, 4096);
   }
 
   /** Reinitialise. */
@@ -302,124 +300,124 @@ public int getLine() {
   public void ReInit(java.io.Reader dstream, int startline,
                      int startcolumn)
   {
-     ReInit(dstream, startline, startcolumn, 4096);
+    ReInit(dstream, startline, startcolumn, 4096);
   }
 
   /** Reinitialise. */
   public void ReInit(java.io.Reader dstream)
   {
-     ReInit(dstream, 1, 1, 4096);
+    ReInit(dstream, 1, 1, 4096);
   }
   /** Constructor. */
   public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline,
   int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
   {
-     this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
+    this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
   }
 
   /** Constructor. */
   public SimpleCharStream(java.io.InputStream dstream, int startline,
   int startcolumn, int buffersize)
   {
-     this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
+    this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
   }
 
   /** Constructor. */
   public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline,
                           int startcolumn) throws java.io.UnsupportedEncodingException
   {
-     this(dstream, encoding, startline, startcolumn, 4096);
+    this(dstream, encoding, startline, startcolumn, 4096);
   }
 
   /** Constructor. */
   public SimpleCharStream(java.io.InputStream dstream, int startline,
                           int startcolumn)
   {
-     this(dstream, startline, startcolumn, 4096);
+    this(dstream, startline, startcolumn, 4096);
   }
 
   /** Constructor. */
   public SimpleCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
   {
-     this(dstream, encoding, 1, 1, 4096);
+    this(dstream, encoding, 1, 1, 4096);
   }
 
   /** Constructor. */
   public SimpleCharStream(java.io.InputStream dstream)
   {
-     this(dstream, 1, 1, 4096);
+    this(dstream, 1, 1, 4096);
   }
 
   /** Reinitialise. */
   public void ReInit(java.io.InputStream dstream, String encoding, int startline,
                           int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
   {
-     ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
+    ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
   }
 
   /** Reinitialise. */
   public void ReInit(java.io.InputStream dstream, int startline,
                           int startcolumn, int buffersize)
   {
-     ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
+    ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
   }
 
   /** Reinitialise. */
   public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
   {
-     ReInit(dstream, encoding, 1, 1, 4096);
+    ReInit(dstream, encoding, 1, 1, 4096);
   }
 
   /** Reinitialise. */
   public void ReInit(java.io.InputStream dstream)
   {
-     ReInit(dstream, 1, 1, 4096);
+    ReInit(dstream, 1, 1, 4096);
   }
   /** Reinitialise. */
   public void ReInit(java.io.InputStream dstream, String encoding, int startline,
                      int startcolumn) throws java.io.UnsupportedEncodingException
   {
-     ReInit(dstream, encoding, startline, startcolumn, 4096);
+    ReInit(dstream, encoding, startline, startcolumn, 4096);
   }
   /** Reinitialise. */
   public void ReInit(java.io.InputStream dstream, int startline,
                      int startcolumn)
   {
-     ReInit(dstream, startline, startcolumn, 4096);
+    ReInit(dstream, startline, startcolumn, 4096);
   }
   /** Get token literal value. */
   public String GetImage()
   {
-     if (bufpos >= tokenBegin)
-        return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
-     else
-        return new String(buffer, tokenBegin, bufsize - tokenBegin) +
-                              new String(buffer, 0, bufpos + 1);
+    if (bufpos >= tokenBegin)
+      return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
+    else
+      return new String(buffer, tokenBegin, bufsize - tokenBegin) +
+                            new String(buffer, 0, bufpos + 1);
   }
 
   /** Get the suffix. */
   public char[] GetSuffix(int len)
   {
-     char[] ret = new char[len];
+    char[] ret = new char[len];
 
-     if ((bufpos + 1) >= len)
-        System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
-     else
-     {
-        System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
-                                                          len - bufpos - 1);
-        System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
-     }
+    if ((bufpos + 1) >= len)
+      System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
+    else
+    {
+      System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
+                                                        len - bufpos - 1);
+      System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
+    }
 
-     return ret;
+    return ret;
   }
 
   /** Reset buffer when finished. */
   public void Done()
   {
-     buffer = null;
-     bufline = null;
-     bufcolumn = null;
+    buffer = null;
+    bufline = null;
+    bufcolumn = null;
   }
 
   /**
@@ -427,48 +425,47 @@ public int getLine() {
    */
   public void adjustBeginLineColumn(int newLine, int newCol)
   {
-     int start = tokenBegin;
-     int len;
-
-     if (bufpos >= tokenBegin)
-     {
-        len = bufpos - tokenBegin + inBuf + 1;
-     }
-     else
-     {
-        len = bufsize - tokenBegin + bufpos + 1 + inBuf;
-     }
-
-     int i = 0, j = 0, k = 0;
-     int nextColDiff = 0, columnDiff = 0;
-
-     while (i < len &&
-            bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
-     {
-        bufline[j] = newLine;
-        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
-        bufcolumn[j] = newCol + columnDiff;
-        columnDiff = nextColDiff;
-        i++;
-     }
-
-     if (i < len)
-     {
-        bufline[j] = newLine++;
-        bufcolumn[j] = newCol + columnDiff;
-
-        while (i++ < len)
-        {
-           if (bufline[j = start % bufsize] != bufline[++start % bufsize])
-              bufline[j] = newLine++;
-           else
-              bufline[j] = newLine;
-        }
-     }
+    int start = tokenBegin;
+    int len;
+
+    if (bufpos >= tokenBegin)
+    {
+      len = bufpos - tokenBegin + inBuf + 1;
+    }
+    else
+    {
+      len = bufsize - tokenBegin + bufpos + 1 + inBuf;
+    }
+
+    int i = 0, j = 0, k = 0;
+    int nextColDiff = 0, columnDiff = 0;
+
+    while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
+    {
+      bufline[j] = newLine;
+      nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
+      bufcolumn[j] = newCol + columnDiff;
+      columnDiff = nextColDiff;
+      i++;
+    }
+
+    if (i < len)
+    {
+      bufline[j] = newLine++;
+      bufcolumn[j] = newCol + columnDiff;
+
+      while (i++ < len)
+      {
+        if (bufline[j = start % bufsize] != bufline[++start % bufsize])
+          bufline[j] = newLine++;
+        else
+          bufline[j] = newLine;
+      }
+    }
 
-     line = bufline[j];
-     column = bufcolumn[j];
+    line = bufline[j];
+    column = bufcolumn[j];
   }
 
 }
-/* JavaCC - OriginalChecksum=07e88967db3720fcfc378bbb17e7f640 (do not edit this line) */
+/* JavaCC - OriginalChecksum=56f6dd1368327bd2c0d7eeacba8a18de (do not edit this line) */

==================================================
TokenMgrError.java
index d139c14b11..86cc1f09fc 100644
--- a/java/org/apache/el/parser/Token.java
+++ b/java/org/apache/el/parser/Token.java
@@ -1,12 +1,19 @@
-/* Generated By:JavaCC: Do not edit this line. Token.java Version 4.1 */
-/* JavaCCOptions:TOKEN_EXTENDS=,KEEP_LINE_COL=null */
+/* Generated By:JavaCC: Do not edit this line. Token.java Version 5.0 */
+/* JavaCCOptions:TOKEN_EXTENDS=,KEEP_LINE_COL=null,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
 package org.apache.el.parser;
 
 /**
  * Describes the input token stream.
  */
 
-public class Token {
+public class Token implements java.io.Serializable {
+
+  /**
+   * The version identifier for this Serializable class.
+   * Increment only if the <i>serialized</i> form of the
+   * class changes.
+   */
+  private static final long serialVersionUID = 1L;
 
   /**
    * An integer that describes the kind of this token.  This numbering
@@ -75,7 +82,7 @@ public class Token {
    */
   public Token(int kind)
   {
-     this(kind, null);
+    this(kind, null);
   }
 
   /**
@@ -83,8 +90,8 @@ public class Token {
    */
   public Token(int kind, String image)
   {
-     this.kind = kind;
-     this.image = image;
+    this.kind = kind;
+    this.image = image;
   }
 
   /**
@@ -93,7 +100,7 @@ public class Token {
   @Override
   public String toString()
   {
-     return image;
+    return image;
   }
 
   /**
@@ -110,16 +117,16 @@ public class Token {
    */
   public static Token newToken(int ofKind, String image)
   {
-     switch(ofKind)
-     {
-       default : return new Token(ofKind, image);
-     }
+    switch(ofKind)
+    {
+      default : return new Token(ofKind, image);
+    }
   }
 
   public static Token newToken(int ofKind)
   {
-     return newToken(ofKind, null);
+    return newToken(ofKind, null);
   }
 
 }
-/* JavaCC - OriginalChecksum=384f0c8d72f06824f8ad2f5b33eb5e59 (do not edit this line) */
+/* JavaCC - OriginalChecksum=30123d1b46e789463a75610c8e254dce (do not edit this line) */

==================================================
