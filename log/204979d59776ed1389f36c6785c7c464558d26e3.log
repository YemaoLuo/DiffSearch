204979d59776ed1389f36c6785c7c464558d26e3
==================================================
Remove remains of generic package
==================================================
Mark Emlyn
==================================================
Mon Dec 7 17:11:10 2009 +0000
==================================================
AnnotationEntry.java
Remove remains of generic package
More clean up

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@888010 13f79535-47bb-0310-9956-ffa450edef68



==================================================
ClassElementValue.java
index fc97b00cba..d5e5309580 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/AnnotationEntry.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/AnnotationEntry.java
@@ -76,13 +76,7 @@ public class AnnotationEntry implements Constants, Serializable {
         return c.getBytes();
     }
     
-    /**
-     * @return the annotation type index
-     */
-    public int getAnnotationTypeIndex()
-    {
-    	return type_index;
-    }
+    
 
 
     
@@ -108,15 +102,9 @@ public class AnnotationEntry implements Constants, Serializable {
 	}
 
 
-	public boolean isRuntimeVisible()
-	{
-		return isRuntimeVisible;
-	}
+	
 
-	public void addElementNameValuePair(ElementValuePair elementNameValuePair)
-	{
-		element_value_pairs.add(elementNameValuePair);
-	}
+	
 
 	
 }

==================================================
ConstantPool.java
index f3dad0f9e1..7b84e4b00b 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ClassElementValue.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ClassElementValue.java
@@ -17,17 +17,9 @@ public class ClassElementValue extends ElementValue
 		this.idx = idx;
 	}
 
-	public int getIndex()
-	{
-		return idx;
-	}
+	
 
-	public String getClassString()
-	{
-		ConstantUtf8 c = (ConstantUtf8) cpool.getConstant(idx,
-				Constants.CONSTANT_Utf8);
-		return c.getBytes();
-	}
+	
 
 	public String stringifyValue()
 	{

==================================================
ElementValue.java
index 42173bf0fd..98e0b102dd 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ConstantPool.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ConstantPool.java
@@ -31,7 +31,6 @@ import org.apache.tomcat.util.bcel.Constants;
 
  * @version $Id$
  * @see     Constant
- * @see     org.apache.tomcat.util.bcel.generic.ConstantPoolGen
  * @author <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
  */
 public class ConstantPool implements Cloneable, Serializable {

==================================================
ElementValuePair.java
index 9a501642e8..05467fcc8c 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ElementValue.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ElementValue.java
@@ -42,10 +42,7 @@ public abstract class ElementValue
 		this.cpool = cpool;
 	}
 
-	public int getElementValueType()
-	{
-		return type;
-	}
+	
 
 	public abstract String stringifyValue();
 

==================================================
EnumElementValue.java
index 5018a1afb8..fd70ab65fa 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ElementValuePair.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ElementValuePair.java
@@ -55,10 +55,7 @@ public class ElementValuePair
 		return elementValue;
 	}
 
-	public int getNameIndex()
-	{
-		return elementNameIndex;
-	}
+	
 
 	
 	

==================================================
SimpleElementValue.java
index 4d2c899291..e8793832f3 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/EnumElementValue.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/EnumElementValue.java
@@ -36,27 +36,11 @@ public class EnumElementValue extends ElementValue
 		return cu8.getBytes();
 	}
 
-	public String getEnumTypeString()
-	{
-		ConstantUtf8 cu8 = (ConstantUtf8) cpool.getConstant(typeIdx,
-				Constants.CONSTANT_Utf8);
-		return cu8.getBytes();// Utility.signatureToString(cu8.getBytes());
-	}
+	
 
-	public String getEnumValueString()
-	{
-		ConstantUtf8 cu8 = (ConstantUtf8) cpool.getConstant(valueIdx,
-				Constants.CONSTANT_Utf8);
-		return cu8.getBytes();
-	}
+	
 
-	public int getValueIndex()
-	{
-		return valueIdx;
-	}
+	
 
-	public int getTypeIndex()
-	{
-		return typeIdx;
-	}
+	
 }

==================================================
Utility.java
index e645cbb973..d545905be4 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/SimpleElementValue.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/SimpleElementValue.java
@@ -40,90 +40,23 @@ public class SimpleElementValue extends ElementValue
 
 	
 
-	public String getValueString()
-	{
-		if (type != STRING)
-			throw new RuntimeException(
-					"Dont call getValueString() on a non STRING ElementValue");
-		ConstantUtf8 c = (ConstantUtf8) cpool.getConstant(getIndex(),
-				Constants.CONSTANT_Utf8);
-		return c.getBytes();
-	}
+	
 
-	public int getValueInt()
-	{
-		if (type != PRIMITIVE_INT)
-			throw new RuntimeException(
-					"Dont call getValueString() on a non STRING ElementValue");
-		ConstantInteger c = (ConstantInteger) cpool.getConstant(getIndex(),
-				Constants.CONSTANT_Integer);
-		return c.getBytes();
-	}
+	
 
-	public byte getValueByte()
-	{
-		if (type != PRIMITIVE_BYTE)
-			throw new RuntimeException(
-					"Dont call getValueByte() on a non BYTE ElementValue");
-		ConstantInteger c = (ConstantInteger) cpool.getConstant(getIndex(),
-				Constants.CONSTANT_Integer);
-		return (byte) c.getBytes();
-	}
+	
 
-	public char getValueChar()
-	{
-		if (type != PRIMITIVE_CHAR)
-			throw new RuntimeException(
-					"Dont call getValueChar() on a non CHAR ElementValue");
-		ConstantInteger c = (ConstantInteger) cpool.getConstant(getIndex(),
-				Constants.CONSTANT_Integer);
-		return (char) c.getBytes();
-	}
+	
 
-	public long getValueLong()
-	{
-		if (type != PRIMITIVE_LONG)
-			throw new RuntimeException(
-					"Dont call getValueLong() on a non LONG ElementValue");
-		ConstantLong j = (ConstantLong) cpool.getConstant(getIndex());
-		return j.getBytes();
-	}
+	
 
-	public float getValueFloat()
-	{
-		if (type != PRIMITIVE_FLOAT)
-			throw new RuntimeException(
-					"Dont call getValueFloat() on a non FLOAT ElementValue");
-		ConstantFloat f = (ConstantFloat) cpool.getConstant(getIndex());
-		return f.getBytes();
-	}
+	
 
-	public double getValueDouble()
-	{
-		if (type != PRIMITIVE_DOUBLE)
-			throw new RuntimeException(
-					"Dont call getValueDouble() on a non DOUBLE ElementValue");
-		ConstantDouble d = (ConstantDouble) cpool.getConstant(getIndex());
-		return d.getBytes();
-	}
+	
 
-	public boolean getValueBoolean()
-	{
-		if (type != PRIMITIVE_BOOLEAN)
-			throw new RuntimeException(
-					"Dont call getValueBoolean() on a non BOOLEAN ElementValue");
-		ConstantInteger bo = (ConstantInteger) cpool.getConstant(getIndex());
-		return (bo.getBytes() != 0);
-	}
+	
 
-	public short getValueShort()
-	{
-		if (type != PRIMITIVE_SHORT)
-			throw new RuntimeException(
-					"Dont call getValueShort() on a non SHORT ElementValue");
-		ConstantInteger s = (ConstantInteger) cpool.getConstant(getIndex());
-		return (short) s.getBytes();
-	}
+	
 
 	public String toString()
 	{

==================================================
AllocationInstruction.java
index a53ec7a2ed..38e588d950 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/Utility.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/Utility.java
@@ -741,19 +741,7 @@ public abstract class Utility {
     }
 
 
-    /**
-     * Return a string for an integer justified left or right and filled up with
-     * `fill' characters if necessary.
-     *
-     * @param i integer to format
-     * @param length length of desired string
-     * @param left_justify format left or right
-     * @param fill fill character
-     * @return formatted int
-     */
-    public static final String format( int i, int length, boolean left_justify, char fill ) {
-        return fillup(Integer.toString(i), length, left_justify, fill);
-    }
+    
 
 
     /**

==================================================
AnnotationElementValueGen.java
deleted file mode 100644
index fd8c322169..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/AllocationInstruction.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * Denote family of instructions that allocates space in the heap.
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public interface AllocationInstruction {
-}

==================================================
AnnotationEntryGen.java
deleted file mode 100644
index c5b07ee95c..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/AnnotationElementValueGen.java
+++ /dev/null
@@ -1,45 +0,0 @@
-package org.apache.tomcat.util.bcel.generic;
-
-import java.io.DataOutputStream;
-import java.io.IOException;
-import org.apache.tomcat.util.bcel.classfile.AnnotationElementValue;
-import org.apache.tomcat.util.bcel.classfile.ElementValue;
-
-public class AnnotationElementValueGen extends ElementValueGen
-{
-	// For annotation element values, this is the annotation
-	private AnnotationEntryGen a;
-
-	
-
-	
-
-	public AnnotationElementValueGen(AnnotationElementValue value,
-			ConstantPoolGen cpool, boolean copyPoolEntries)
-	{
-		super(ANNOTATION, cpool);
-		a = new AnnotationEntryGen(value.getAnnotationEntry(), cpool, copyPoolEntries);
-	}
-
-	public void dump(DataOutputStream dos) throws IOException
-	{
-		dos.writeByte(type); // u1 type of value (ANNOTATION == '@')
-		a.dump(dos);
-	}
-
-	public String stringifyValue()
-	{
-		throw new RuntimeException("Not implemented yet");
-	}
-
-	/**
-	 * Return immutable variant of this AnnotationElementValueGen
-	 */
-	public ElementValue getElementValue()
-	{
-		return new AnnotationElementValue(this.type, a.getAnnotation(), cpGen
-				.getConstantPool());
-	}
-
-	
-}

==================================================
ArrayElementValueGen.java
deleted file mode 100755
index 57857c2f21..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/AnnotationEntryGen.java
+++ /dev/null
@@ -1,128 +0,0 @@
-package org.apache.tomcat.util.bcel.generic;
-
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-import org.apache.tomcat.util.bcel.classfile.AnnotationEntry;
-import org.apache.tomcat.util.bcel.classfile.ConstantUtf8;
-import org.apache.tomcat.util.bcel.classfile.ElementValuePair;
-
-
-public class AnnotationEntryGen
-{
-	private int typeIndex;
-
-	private List /* ElementNameValuePairGen */evs;
-
-	private ConstantPoolGen cpool;
-
-	private boolean isRuntimeVisible = false;
-
-	/**
-	 * Here we are taking a fixed annotation of type Annotation and building a
-	 * modifiable AnnotationGen object. If the pool passed in is for a different
-	 * class file, then copyPoolEntries should have been passed as true as that
-	 * will force us to do a deep copy of the annotation and move the cpool
-	 * entries across. We need to copy the type and the element name value pairs
-	 * and the visibility.
-	 */
-	public AnnotationEntryGen(AnnotationEntry a, ConstantPoolGen cpool,
-			boolean copyPoolEntries)
-	{
-		this.cpool = cpool;
-		if (copyPoolEntries)
-		{
-			typeIndex = cpool.addUtf8(a.getAnnotationType());
-		}
-		else
-		{
-			typeIndex = a.getAnnotationTypeIndex();
-		}
-		isRuntimeVisible = a.isRuntimeVisible();
-		evs = copyValues(a.getElementValuePairs(), cpool, copyPoolEntries);
-	}
-
-	private List copyValues(ElementValuePair[] in, ConstantPoolGen cpool,
-			boolean copyPoolEntries)
-	{
-		List out = new ArrayList();
-		int l = in.length;
-		for (int i = 0; i < l; i++)
-		{
-			ElementValuePair nvp = (ElementValuePair) in[i];
-			out.add(new ElementValuePairGen(nvp, cpool, copyPoolEntries));
-		}
-		return out;
-	}
-
-	/**
-	 * Retrieve an immutable version of this AnnotationGen
-	 */
-	public AnnotationEntry getAnnotation()
-	{
-		AnnotationEntry a = new AnnotationEntry(typeIndex, cpool.getConstantPool(),
-				isRuntimeVisible);
-		for (Iterator iter = evs.iterator(); iter.hasNext();)
-		{
-			ElementValuePairGen element = (ElementValuePairGen) iter
-					.next();
-			a.addElementNameValuePair(element.getElementNameValuePair());
-		}
-		return a;
-	}
-
-	
-
-	
-
-	public void dump(DataOutputStream dos) throws IOException
-	{
-		dos.writeShort(typeIndex); // u2 index of type name in cpool
-		dos.writeShort(evs.size()); // u2 element_value pair count
-		for (int i = 0; i < evs.size(); i++)
-		{
-			ElementValuePairGen envp = (ElementValuePairGen) evs.get(i);
-			envp.dump(dos);
-		}
-	}
-
-	
-
-	
-
-	public final String getTypeSignature()
-	{
-		// ConstantClass c = (ConstantClass)cpool.getConstant(typeIndex);
-		ConstantUtf8 utf8 = (ConstantUtf8) cpool
-				.getConstant(typeIndex/* c.getNameIndex() */);
-		return utf8.getBytes();
-	}
-
-	public final String getTypeName()
-	{
-		return getTypeSignature();// BCELBUG: Should I use this instead?
-									// Utility.signatureToString(getTypeSignature());
-	}
-
-	
-
-	public String toString()
-	{
-		StringBuffer s = new StringBuffer();
-		s.append("AnnotationGen:[" + getTypeName() + " #" + evs.size() + " {");
-		for (int i = 0; i < evs.size(); i++)
-		{
-			s.append(evs.get(i));
-			if (i + 1 < evs.size())
-				s.append(",");
-		}
-		s.append("}]");
-		return s.toString();
-	}
-
-	
-
-	
-}

==================================================
BranchHandle.java
deleted file mode 100644
index 6fb40e213c..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/ArrayElementValueGen.java
+++ /dev/null
@@ -1,84 +0,0 @@
-package org.apache.tomcat.util.bcel.generic;
-
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-import org.apache.tomcat.util.bcel.classfile.ArrayElementValue;
-import org.apache.tomcat.util.bcel.classfile.ElementValue;
-
-public class ArrayElementValueGen extends ElementValueGen
-{
-	// J5TODO: Should we make this an array or a list? A list would be easier to
-	// modify ...
-	private List /* ElementValueGen */evalues;
-
-	
-
-	
-
-	/**
-	 * Return immutable variant of this ArrayElementValueGen
-	 */
-	public ElementValue getElementValue()
-	{
-		ElementValue[] immutableData = new ElementValue[evalues.size()];
-		int i = 0;
-		for (Iterator iter = evalues.iterator(); iter.hasNext();)
-		{
-			ElementValueGen element = (ElementValueGen) iter.next();
-			immutableData[i++] = element.getElementValue();
-		}
-		return new ArrayElementValue(type, immutableData, cpGen
-				.getConstantPool());
-	}
-
-	/**
-	 * @param value
-	 * @param cpool
-	 */
-	public ArrayElementValueGen(ArrayElementValue value, ConstantPoolGen cpool,
-			boolean copyPoolEntries)
-	{
-		super(ARRAY, cpool);
-		evalues = new ArrayList();
-		ElementValue[] in = value.getElementValuesArray();
-		for (int i = 0; i < in.length; i++)
-		{
-			evalues.add(ElementValueGen.copy(in[i], cpool, copyPoolEntries));
-		}
-	}
-
-	public void dump(DataOutputStream dos) throws IOException
-	{
-		dos.writeByte(type); // u1 type of value (ARRAY == '[')
-		dos.writeShort(evalues.size());
-		for (Iterator iter = evalues.iterator(); iter.hasNext();)
-		{
-			ElementValueGen element = (ElementValueGen) iter.next();
-			element.dump(dos);
-		}
-	}
-
-	public String stringifyValue()
-	{
-		StringBuffer sb = new StringBuffer();
-		sb.append("[");
-		for (Iterator iter = evalues.iterator(); iter.hasNext();)
-		{
-			ElementValueGen element = (ElementValueGen) iter.next();
-			sb.append(element.stringifyValue());
-			if (iter.hasNext())
-				sb.append(",");
-		}
-		sb.append("]");
-		return sb.toString();
-	}
-
-	
-
-	
-
-	
-}

==================================================
BranchInstruction.java
deleted file mode 100644
index e0bab1d113..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/BranchHandle.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * BranchHandle is returned by specialized InstructionList.append() whenever a
- * BranchInstruction is appended. This is useful when the target of this
- * instruction is not known at time of creation and must be set later
- * via setTarget().
- *
- * @see InstructionHandle
- * @see Instruction
- * @see InstructionList
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public final class BranchHandle extends InstructionHandle {
-
-    private BranchInstruction bi; // An alias in fact, but saves lots of casts
-
-
-    private BranchHandle(BranchInstruction i) {
-        super(i);
-        bi = i;
-    }
-
-    /** Factory methods.
-     */
-    private static BranchHandle bh_list = null; // List of reusable handles
-
-
-    
-
-
-    /** Handle adds itself to the list of resuable handles.
-     */
-    protected void addHandle() {
-        next = bh_list;
-        bh_list = this;
-    }
-
-
-    /* Override InstructionHandle methods: delegate to branch instruction.
-     * Through this overriding all access to the private i_position field should
-     * be prevented.
-     */
-    public int getPosition() {
-        return bi.position;
-    }
-
-
-    void setPosition( int pos ) {
-        i_position = bi.position = pos;
-    }
-
-
-    /** 
-     * Set new contents. Old instruction is disposed and may not be used anymore.
-     */
-    public void setInstruction( Instruction i ) {
-        super.setInstruction(i);
-        if (!(i instanceof BranchInstruction)) {
-            throw new ClassGenException("Assigning " + i
-                    + " to branch handle which is not a branch instruction");
-        }
-        bi = (BranchInstruction) i;
-    }
-}

==================================================
ClassElementValueGen.java
deleted file mode 100644
index a08444b439..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/BranchInstruction.java
+++ /dev/null
@@ -1,176 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-import java.io.DataOutputStream;
-import java.io.IOException;
-
-/** 
- * Abstract super class for branching instructions like GOTO, IFEQ, etc..
- * Branch instructions may have a variable length, namely GOTO, JSR, 
- * LOOKUPSWITCH and TABLESWITCH.
- *
- * @see InstructionList
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public abstract class BranchInstruction extends Instruction implements InstructionTargeter {
-
-    protected int index; // Branch target relative to this instruction
-    protected InstructionHandle target; // Target object in instruction list
-    protected int position; // Byte code offset
-
-
-    /**
-     * Empty constructor needed for the Class.newInstance() statement in
-     * Instruction.readInstruction(). Not to be used otherwise.
-     */
-    BranchInstruction() {
-    }
-
-
-    
-
-
-    /**
-     * Dump instruction as byte code to stream out.
-     * @param out Output stream
-     */
-    public void dump( DataOutputStream out ) throws IOException {
-        out.writeByte(opcode);
-        index = getTargetOffset();
-        if (Math.abs(index) >= 32767) {
-            throw new ClassGenException("Branch target offset too large for short: " + index);
-        }
-        out.writeShort(index); // May be negative, i.e., point backwards
-    }
-
-
-    /**
-     * @param _target branch target
-     * @return the offset to  `target' relative to this instruction
-     */
-    protected int getTargetOffset( InstructionHandle _target ) {
-        if (_target == null) {
-            throw new ClassGenException("Target of " + super.toString(true)
-                    + " is invalid null handle");
-        }
-        int t = _target.getPosition();
-        if (t < 0) {
-            throw new ClassGenException("Invalid branch target position offset for "
-                    + super.toString(true) + ":" + t + ":" + _target);
-        }
-        return t - position;
-    }
-
-
-    /**
-     * @return the offset to this instruction's target
-     */
-    protected int getTargetOffset() {
-        return getTargetOffset(target);
-    }
-
-
-    /**
-     * Long output format:
-     *
-     * &lt;position in byte code&gt;
-     * &lt;name of opcode&gt; "["&lt;opcode number&gt;"]" 
-     * "("&lt;length of instruction&gt;")"
-     * "&lt;"&lt;target instruction&gt;"&gt;" "@"&lt;branch target offset&gt;
-     *
-     * @param verbose long/short format switch
-     * @return mnemonic for instruction
-     */
-    public String toString( boolean verbose ) {
-        String s = super.toString(verbose);
-        String t = "null";
-        if (verbose) {
-            if (target != null) {
-                if (target.getInstruction() == this) {
-                    t = "<points to itself>";
-                } else if (target.getInstruction() == null) {
-                    t = "<null instruction!!!?>";
-                } else {
-                    t = target.getInstruction().toString(false); // Avoid circles
-                }
-            }
-        } else {
-            if (target != null) {
-                index = getTargetOffset();
-                t = "" + (index + position);
-            }
-        }
-        return s + " -> " + t;
-    }
-
-
-    /**
-     * Set branch target
-     * @param target branch target
-     */
-    public void setTarget( InstructionHandle target ) {
-        notifyTarget(this.target, target, this);
-        this.target = target;
-    }
-
-
-    /**
-     * Used by BranchInstruction, LocalVariableGen, CodeExceptionGen
-     */
-    static final void notifyTarget( InstructionHandle old_ih, InstructionHandle new_ih,
-            InstructionTargeter t ) {
-        if (old_ih != null) {
-            old_ih.removeTargeter(t);
-        }
-        if (new_ih != null) {
-            new_ih.addTargeter(t);
-        }
-    }
-
-
-    /**
-     * @param old_ih old target
-     * @param new_ih new target
-     */
-    public void updateTarget( InstructionHandle old_ih, InstructionHandle new_ih ) {
-        if (target == old_ih) {
-            setTarget(new_ih);
-        } else {
-            throw new ClassGenException("Not targeting " + old_ih + ", but " + target);
-        }
-    }
-
-
-    /**
-     * @return true, if ih is target of this instruction
-     */
-    public boolean containsTarget( InstructionHandle ih ) {
-        return (target == ih);
-    }
-
-
-    /**
-     * Inform target that it's not targeted anymore.
-     */
-    void dispose() {
-        setTarget(null);
-        index = -1;
-        position = -1;
-    }
-}

==================================================
ClassGenException.java
deleted file mode 100644
index 58dd8eb0a2..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/ClassElementValueGen.java
+++ /dev/null
@@ -1,67 +0,0 @@
-package org.apache.tomcat.util.bcel.generic;
-
-import java.io.DataOutputStream;
-import java.io.IOException;
-import org.apache.tomcat.util.bcel.classfile.ElementValue;
-import org.apache.tomcat.util.bcel.classfile.ConstantUtf8;
-import org.apache.tomcat.util.bcel.classfile.ClassElementValue;
-import org.apache.tomcat.util.bcel.generic.ConstantPoolGen;
-import org.apache.tomcat.util.bcel.generic.ElementValueGen;
-
-public class ClassElementValueGen extends ElementValueGen
-{
-	// For primitive types and string type, this points to the value entry in
-	// the cpool
-	// For 'class' this points to the class entry in the cpool
-	private int idx;
-
-	
-
-	
-
-	/**
-	 * Return immutable variant of this ClassElementValueGen
-	 */
-	public ElementValue getElementValue()
-	{
-		return new ClassElementValue(type, idx, cpGen.getConstantPool());
-	}
-
-	public ClassElementValueGen(ClassElementValue value, ConstantPoolGen cpool,
-			boolean copyPoolEntries)
-	{
-		super(CLASS, cpool);
-		if (copyPoolEntries)
-		{
-			// idx = cpool.addClass(value.getClassString());
-			idx = cpool.addUtf8(value.getClassString());
-		}
-		else
-		{
-			idx = value.getIndex();
-		}
-	}
-
-	
-
-	public String getClassString()
-	{
-		ConstantUtf8 cu8 = (ConstantUtf8) getConstantPool().getConstant(idx);
-		return cu8.getBytes();
-		// ConstantClass c = (ConstantClass)getConstantPool().getConstant(idx);
-		// ConstantUtf8 utf8 =
-		// (ConstantUtf8)getConstantPool().getConstant(c.getNameIndex());
-		// return utf8.getBytes();
-	}
-
-	public String stringifyValue()
-	{
-		return getClassString();
-	}
-
-	public void dump(DataOutputStream dos) throws IOException
-	{
-		dos.writeByte(type); // u1 kind of value
-		dos.writeShort(idx);
-	}
-}

==================================================
ConstantPoolGen.java
deleted file mode 100644
index b869b3274b..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/ClassGenException.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * Thrown on internal errors. Extends RuntimeException so it hasn't to be declared
- * in the throws clause every time.
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class ClassGenException extends RuntimeException {
-
-    public ClassGenException() {
-        super();
-    }
-
-
-    public ClassGenException(String s) {
-        super(s);
-    }
-    
-    
-}

==================================================
ConstantPushInstruction.java
deleted file mode 100644
index e0a9884024..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/ConstantPoolGen.java
+++ /dev/null
@@ -1,308 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-import java.util.HashMap;
-import java.util.Map;
-import org.apache.tomcat.util.bcel.classfile.Constant;
-import org.apache.tomcat.util.bcel.classfile.ConstantDouble;
-import org.apache.tomcat.util.bcel.classfile.ConstantFloat;
-import org.apache.tomcat.util.bcel.classfile.ConstantInteger;
-import org.apache.tomcat.util.bcel.classfile.ConstantLong;
-import org.apache.tomcat.util.bcel.classfile.ConstantPool;
-import org.apache.tomcat.util.bcel.classfile.ConstantUtf8;
-
-/** 
- * This class is used to build up a constant pool. The user adds
- * constants via `addXXX' methods, `addString', `addClass',
- * etc.. These methods return an index into the constant
- * pool. Finally, `getFinalConstantPool()' returns the constant pool
- * built up. Intermediate versions of the constant pool can be
- * obtained with `getConstantPool()'. A constant pool has capacity for
- * Constants.MAX_SHORT entries. Note that the first (0) is used by the
- * JVM and that Double and Long constants need two slots.
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- * @see Constant
- */
-public class ConstantPoolGen implements java.io.Serializable {
-
-    protected int size; 
-    protected Constant[] constants;
-    protected int index = 1; // First entry (0) used by JVM
-
-    private static class Index implements java.io.Serializable {
-
-        int index;
-
-
-        Index(int i) {
-            index = i;
-        }
-    }
-
-
-    
-
-
-    
-
-
-    /**
-     * Create empty constant pool.
-     */
-    public ConstantPoolGen() {
-    	size = 256;
-        constants = new Constant[size];
-    }
-
-
-    /** Resize internal array of constants.
-     */
-    protected void adjustSize() {
-        if (index + 3 >= size) {
-            Constant[] cs = constants;
-            size *= 2;
-            constants = new Constant[size];
-            System.arraycopy(cs, 0, constants, 0, index);
-        }
-    }
-
-    /** 
-     * Look for ConstantInteger in ConstantPool.
-     *
-     * @param n integer number to look for
-     * @return index on success, -1 otherwise
-     */
-    public int lookupInteger( int n ) {
-        for (int i = 1; i < index; i++) {
-            if (constants[i] instanceof ConstantInteger) {
-                ConstantInteger c = (ConstantInteger) constants[i];
-                if (c.getBytes() == n) {
-                    return i;
-                }
-            }
-        }
-        return -1;
-    }
-
-
-    /**
-     * Add a new Integer constant to the ConstantPool, if it is not already in there.
-     *
-     * @param n integer number to add
-     * @return index of entry
-     */
-    public int addInteger( int n ) {
-        int ret;
-        if ((ret = lookupInteger(n)) != -1) {
-            return ret; // Already in CP
-        }
-        adjustSize();
-        ret = index;
-        constants[index++] = new ConstantInteger(n);
-        return ret;
-    }
-
-
-    /** 
-     * Look for ConstantFloat in ConstantPool.
-     *
-     * @param n Float number to look for
-     * @return index on success, -1 otherwise
-     */
-    public int lookupFloat( float n ) {
-        int bits = Float.floatToIntBits(n);
-        for (int i = 1; i < index; i++) {
-            if (constants[i] instanceof ConstantFloat) {
-                ConstantFloat c = (ConstantFloat) constants[i];
-                if (Float.floatToIntBits(c.getBytes()) == bits) {
-                    return i;
-                }
-            }
-        }
-        return -1;
-    }
-
-
-    /**
-     * Add a new Float constant to the ConstantPool, if it is not already in there.
-     *
-     * @param n Float number to add
-     * @return index of entry
-     */
-    public int addFloat( float n ) {
-        int ret;
-        if ((ret = lookupFloat(n)) != -1) {
-            return ret; // Already in CP
-        }
-        adjustSize();
-        ret = index;
-        constants[index++] = new ConstantFloat(n);
-        return ret;
-    }
-
-    private Map utf8_table = new HashMap();
-
-
-    /** 
-     * Look for ConstantUtf8 in ConstantPool.
-     *
-     * @param n Utf8 string to look for
-     * @return index on success, -1 otherwise
-     */
-    public int lookupUtf8( String n ) {
-        Index index = (Index) utf8_table.get(n);
-        return (index != null) ? index.index : -1;
-    }
-
-
-    /**
-     * Add a new Utf8 constant to the ConstantPool, if it is not already in there.
-     *
-     * @param n Utf8 string to add
-     * @return index of entry
-     */
-    public int addUtf8( String n ) {
-        int ret;
-        if ((ret = lookupUtf8(n)) != -1) {
-            return ret; // Already in CP
-        }
-        adjustSize();
-        ret = index;
-        constants[index++] = new ConstantUtf8(n);
-        if (!utf8_table.containsKey(n)) {
-            utf8_table.put(n, new Index(ret));
-        }
-        return ret;
-    }
-
-
-    /** 
-     * Look for ConstantLong in ConstantPool.
-     *
-     * @param n Long number to look for
-     * @return index on success, -1 otherwise
-     */
-    public int lookupLong( long n ) {
-        for (int i = 1; i < index; i++) {
-            if (constants[i] instanceof ConstantLong) {
-                ConstantLong c = (ConstantLong) constants[i];
-                if (c.getBytes() == n) {
-                    return i;
-                }
-            }
-        }
-        return -1;
-    }
-
-
-    /**
-     * Add a new long constant to the ConstantPool, if it is not already in there.
-     *
-     * @param n Long number to add
-     * @return index of entry
-     */
-    public int addLong( long n ) {
-        int ret;
-        if ((ret = lookupLong(n)) != -1) {
-            return ret; // Already in CP
-        }
-        adjustSize();
-        ret = index;
-        constants[index] = new ConstantLong(n);
-        index += 2; // Wastes one entry according to spec
-        return ret;
-    }
-
-
-    /** 
-     * Look for ConstantDouble in ConstantPool.
-     *
-     * @param n Double number to look for
-     * @return index on success, -1 otherwise
-     */
-    public int lookupDouble( double n ) {
-        long bits = Double.doubleToLongBits(n);
-        for (int i = 1; i < index; i++) {
-            if (constants[i] instanceof ConstantDouble) {
-                ConstantDouble c = (ConstantDouble) constants[i];
-                if (Double.doubleToLongBits(c.getBytes()) == bits) {
-                    return i;
-                }
-            }
-        }
-        return -1;
-    }
-
-
-    /**
-     * Add a new double constant to the ConstantPool, if it is not already in there.
-     *
-     * @param n Double number to add
-     * @return index of entry
-     */
-    public int addDouble( double n ) {
-        int ret;
-        if ((ret = lookupDouble(n)) != -1) {
-            return ret; // Already in CP
-        }
-        adjustSize();
-        ret = index;
-        constants[index] = new ConstantDouble(n);
-        index += 2; // Wastes one entry according to spec
-        return ret;
-    }
-
-    /**
-     * @param i index in constant pool
-     * @return constant pool entry at index i
-     */
-    public Constant getConstant( int i ) {
-        return constants[i];
-    }
-
-
-    /**
-     * @return intermediate constant pool
-     */
-    public ConstantPool getConstantPool() {
-        return new ConstantPool(constants);
-    }
-
-
-    
-
-
-    
-
-
-    /**
-     * @return String representation.
-     */
-    public String toString() {
-        StringBuffer buf = new StringBuffer();
-        for (int i = 1; i < index; i++) {
-            buf.append(i).append(")").append(constants[i]).append("\n");
-        }
-        return buf.toString();
-    }
-
-
-    
-}

==================================================
ElementValueGen.java
deleted file mode 100644
index 7ff35a7b14..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/ConstantPushInstruction.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * Denotes a push instruction that produces a literal on the stack
- * such as  SIPUSH, BIPUSH, ICONST, etc.
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
-
- * @see ICONST
- * @see SIPUSH
- */
-public interface ConstantPushInstruction extends PushInstruction, TypedInstruction {
-
-    public Number getValue();
-}

==================================================
ElementValuePairGen.java
deleted file mode 100644
index 26979f0386..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/ElementValueGen.java
+++ /dev/null
@@ -1,106 +0,0 @@
-package org.apache.tomcat.util.bcel.generic;
-
-import java.io.DataOutputStream;
-import java.io.IOException;
-
-import org.apache.tomcat.util.bcel.classfile.AnnotationElementValue;
-import org.apache.tomcat.util.bcel.classfile.ArrayElementValue;
-import org.apache.tomcat.util.bcel.classfile.ClassElementValue;
-import org.apache.tomcat.util.bcel.classfile.ElementValue;
-import org.apache.tomcat.util.bcel.classfile.EnumElementValue;
-import org.apache.tomcat.util.bcel.classfile.SimpleElementValue;
-
-public abstract class ElementValueGen
-{
-	protected int type;
-
-	protected ConstantPoolGen cpGen;
-
-	protected ElementValueGen(int type, ConstantPoolGen cpGen)
-	{
-		this.type = type;
-		this.cpGen = cpGen;
-	}
-
-	/**
-	 * Subtypes return an immutable variant of the ElementValueGen
-	 */
-	public abstract ElementValue getElementValue();
-
-	
-
-	public abstract String stringifyValue();
-
-	public abstract void dump(DataOutputStream dos) throws IOException;
-
-	public static final int STRING = 's';
-
-	public static final int ENUM_CONSTANT = 'e';
-
-	public static final int CLASS = 'c';
-
-	public static final int ANNOTATION = '@';
-
-	public static final int ARRAY = '[';
-
-	public static final int PRIMITIVE_INT = 'I';
-
-	public static final int PRIMITIVE_BYTE = 'B';
-
-	public static final int PRIMITIVE_CHAR = 'C';
-
-	public static final int PRIMITIVE_DOUBLE = 'D';
-
-	public static final int PRIMITIVE_FLOAT = 'F';
-
-	public static final int PRIMITIVE_LONG = 'J';
-
-	public static final int PRIMITIVE_SHORT = 'S';
-
-	public static final int PRIMITIVE_BOOLEAN = 'Z';
-
-	
-
-	protected ConstantPoolGen getConstantPool()
-	{
-		return cpGen;
-	}
-
-	/**
-	 * Creates an (modifiable) ElementValueGen copy of an (immutable)
-	 * ElementValue - constant pool is assumed correct.
-	 */
-	public static ElementValueGen copy(ElementValue value,
-			ConstantPoolGen cpool, boolean copyPoolEntries)
-	{
-		switch (value.getElementValueType())
-		{
-		case 'B': // byte
-		case 'C': // char
-		case 'D': // double
-		case 'F': // float
-		case 'I': // int
-		case 'J': // long
-		case 'S': // short
-		case 'Z': // boolean
-		case 's': // String
-			return new SimpleElementValueGen((SimpleElementValue) value, cpool,
-					copyPoolEntries);
-		case 'e': // Enum constant
-			return new EnumElementValueGen((EnumElementValue) value, cpool,
-					copyPoolEntries);
-		case '@': // Annotation
-			return new AnnotationElementValueGen(
-					(AnnotationElementValue) value, cpool, copyPoolEntries);
-		case '[': // Array
-			return new ArrayElementValueGen((ArrayElementValue) value, cpool,
-					copyPoolEntries);
-		case 'c': // Class
-			return new ClassElementValueGen((ClassElementValue) value, cpool,
-					copyPoolEntries);
-		default:
-			throw new RuntimeException("Not implemented yet! ("
-					+ value.getElementValueType() + ")");
-		}
-	}
-}

==================================================
EnumElementValueGen.java
deleted file mode 100755
index 4c40c0c517..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/ElementValuePairGen.java
+++ /dev/null
@@ -1,75 +0,0 @@
-package org.apache.tomcat.util.bcel.generic;
-
-import java.io.DataOutputStream;
-import java.io.IOException;
-import org.apache.tomcat.util.bcel.classfile.ConstantUtf8;
-import org.apache.tomcat.util.bcel.classfile.ElementValue;
-import org.apache.tomcat.util.bcel.classfile.ElementValuePair;
-
-public class ElementValuePairGen
-{
-	private int nameIdx;
-
-	private ElementValueGen value;
-
-	private ConstantPoolGen cpool;
-
-	public ElementValuePairGen(ElementValuePair nvp, ConstantPoolGen cpool,
-			boolean copyPoolEntries)
-	{
-		this.cpool = cpool;
-		// J5ASSERT:
-		// Could assert nvp.getNameString() points to the same thing as
-		// cpool.getConstant(nvp.getNameIndex())
-		// if
-		// (!nvp.getNameString().equals(((ConstantUtf8)cpool.getConstant(nvp.getNameIndex())).getBytes()))
-		// {
-		// throw new RuntimeException("envp buggered");
-		// }
-		if (copyPoolEntries)
-		{
-			nameIdx = cpool.addUtf8(nvp.getNameString());
-		}
-		else
-		{
-			nameIdx = nvp.getNameIndex();
-		}
-		value = ElementValueGen.copy(nvp.getValue(), cpool, copyPoolEntries);
-	}
-
-	/**
-	 * Retrieve an immutable version of this ElementNameValuePairGen
-	 */
-	public ElementValuePair getElementNameValuePair()
-	{
-		ElementValue immutableValue = value.getElementValue();
-		return new ElementValuePair(nameIdx, immutableValue, cpool
-				.getConstantPool());
-	}
-
-	
-
-	
-
-	protected void dump(DataOutputStream dos) throws IOException
-	{
-		dos.writeShort(nameIdx); // u2 name of the element
-		value.dump(dos);
-	}
-
-	
-
-	public final String getNameString()
-	{
-		// ConstantString cu8 = (ConstantString)cpool.getConstant(nameIdx);
-		return ((ConstantUtf8) cpool.getConstant(nameIdx)).getBytes();
-	}
-
-	
-
-	public String toString()
-	{
-		return "ElementValuePair:[" + getNameString() + "="
-				+ value.stringifyValue() + "]";
-	}
-}

==================================================
ExceptionThrower.java
deleted file mode 100644
index afeab83493..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/EnumElementValueGen.java
+++ /dev/null
@@ -1,94 +0,0 @@
-package org.apache.tomcat.util.bcel.generic;
-
-import java.io.DataOutputStream;
-import java.io.IOException;
-import org.apache.tomcat.util.bcel.classfile.ConstantUtf8;
-import org.apache.tomcat.util.bcel.classfile.ElementValue;
-import org.apache.tomcat.util.bcel.classfile.EnumElementValue;
-
-public class EnumElementValueGen extends ElementValueGen
-{
-	// For enum types, these two indices point to the type and value
-	private int typeIdx;
-
-	private int valueIdx;
-
-	
-
-	/**
-	 * Return immutable variant of this EnumElementValue
-	 */
-	public ElementValue getElementValue()
-	{
-		System.err.println("Duplicating value: " + getEnumTypeString() + ":"
-				+ getEnumValueString());
-		return new EnumElementValue(type, typeIdx, valueIdx, cpGen
-				.getConstantPool());
-	}
-
-	
-
-	public EnumElementValueGen(EnumElementValue value, ConstantPoolGen cpool,
-			boolean copyPoolEntries)
-	{
-		super(ENUM_CONSTANT, cpool);
-		if (copyPoolEntries)
-		{
-			typeIdx = cpool.addUtf8(value.getEnumTypeString());// was
-																// addClass(value.getEnumTypeString());
-			valueIdx = cpool.addUtf8(value.getEnumValueString()); // was
-																	// addString(value.getEnumValueString());
-		}
-		else
-		{
-			typeIdx = value.getTypeIndex();
-			valueIdx = value.getValueIndex();
-		}
-	}
-
-	public void dump(DataOutputStream dos) throws IOException
-	{
-		dos.writeByte(type); // u1 type of value (ENUM_CONSTANT == 'e')
-		dos.writeShort(typeIdx); // u2
-		dos.writeShort(valueIdx); // u2
-	}
-
-	public String stringifyValue()
-	{
-		ConstantUtf8 cu8 = (ConstantUtf8) getConstantPool().getConstant(
-				valueIdx);
-		return cu8.getBytes();
-		// ConstantString cu8 =
-		// (ConstantString)getConstantPool().getConstant(valueIdx);
-		// return
-		// ((ConstantUtf8)getConstantPool().getConstant(cu8.getStringIndex())).getBytes();
-	}
-
-	// BCELBUG: Should we need to call utility.signatureToString() on the output
-	// here?
-	public String getEnumTypeString()
-	{
-		// Constant cc = getConstantPool().getConstant(typeIdx);
-		// ConstantClass cu8 =
-		// (ConstantClass)getConstantPool().getConstant(typeIdx);
-		// return
-		// ((ConstantUtf8)getConstantPool().getConstant(cu8.getNameIndex())).getBytes();
-		return ((ConstantUtf8) getConstantPool().getConstant(typeIdx))
-				.getBytes();
-		// return Utility.signatureToString(cu8.getBytes());
-	}
-
-	public String getEnumValueString()
-	{
-		return ((ConstantUtf8) getConstantPool().getConstant(valueIdx))
-				.getBytes();
-		// ConstantString cu8 =
-		// (ConstantString)getConstantPool().getConstant(valueIdx);
-		// return
-		// ((ConstantUtf8)getConstantPool().getConstant(cu8.getStringIndex())).getBytes();
-	}
-
-	
-
-	
-}

==================================================
FieldGen.java
deleted file mode 100644
index b13ab06183..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/ExceptionThrower.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * Denote an instruction that may throw a run-time or a linking
- * exception (or both) during execution.  This is not quite the truth
- * as such; because all instructions may throw an
- * java.lang.VirtualMachineError. These exceptions are omitted.
- * 
- * The Lava Language Specification specifies exactly which
- * <i>RUN-TIME</i> and which <i>LINKING</i> exceptions each
- * instruction may throw which is reflected by the implementers.  Due
- * to the structure of the JVM specification, it may be possible that
- * an Instruction implementing this interface returns a Class[] of
- * size 0.
- *
- * Please note that we speak of an "exception" here when we mean any
- * "Throwable" object; so this term is equally used for "Exception"
- * and "Error" objects.
- *
- * @version $Id$
- * @author  Enver Haase
- */
-public interface ExceptionThrower {
-
-    
-}

==================================================
FieldGenOrMethodGen.java
deleted file mode 100644
index 53907e1c1b..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/FieldGen.java
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-import org.apache.tomcat.util.bcel.classfile.Field;
-import org.apache.tomcat.util.bcel.classfile.Utility;
-import org.apache.tomcat.util.bcel.util.BCELComparator;
-
-/** 
- * Template class for building up a field.  The only extraordinary thing
- * one can do is to add a constant value attribute to a field (which must of
- * course be compatible with to the declared type).
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- * @see Field
- */
-public class FieldGen extends FieldGenOrMethodGen {
-
-    private Object value = null;
-    private static BCELComparator _cmp = new BCELComparator() {
-
-        public boolean equals( Object o1, Object o2 ) {
-            FieldGen THIS = (FieldGen) o1;
-            FieldGen THAT = (FieldGen) o2;
-            return THIS.getName().equals(THAT.getName())
-                    && THIS.getSignature().equals(THAT.getSignature());
-        }
-
-
-        public int hashCode( Object o ) {
-            FieldGen THIS = (FieldGen) o;
-            return THIS.getSignature().hashCode() ^ THIS.getName().hashCode();
-        }
-    };
-
-
-    
-
-
-    
-
-
-    public String getSignature() {
-        return type.getSignature();
-    }
-
-    public String getInitValue() {
-        if (value != null) {
-            return value.toString();
-        } else {
-            return null;
-        }
-    }
-
-
-    /**
-     * Return string representation close to declaration format,
-     * `public static final short MAX = 100', e.g..
-     *
-     * @return String representation of field
-     */
-    public final String toString() {
-        String name, signature, access; // Short cuts to constant pool
-        access = Utility.accessToString(access_flags);
-        access = access.equals("") ? "" : (access + " ");
-        signature = type.toString();
-        name = getName();
-        StringBuffer buf = new StringBuffer(32);
-        buf.append(access).append(signature).append(" ").append(name);
-        String value = getInitValue();
-        if (value != null) {
-            buf.append(" = ").append(value);
-        }
-        return buf.toString();
-    }
-
-
-    
-
-
-    
-
-
-    
-
-
-    /**
-     * Return value as defined by given BCELComparator strategy.
-     * By default two FieldGen objects are said to be equal when
-     * their names and signatures are equal.
-     * 
-     * @see java.lang.Object#equals(java.lang.Object)
-     */
-    public boolean equals( Object obj ) {
-        return _cmp.equals(this, obj);
-    }
-
-
-    /**
-     * Return value as defined by given BCELComparator strategy.
-     * By default return the hashcode of the field's name XOR signature.
-     * 
-     * @see java.lang.Object#hashCode()
-     */
-    public int hashCode() {
-        return _cmp.hashCode(this);
-    }
-}

==================================================
IndexedInstruction.java
deleted file mode 100644
index c32c18e52a..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/FieldGenOrMethodGen.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-import java.util.ArrayList;
-import java.util.List;
-import org.apache.tomcat.util.bcel.classfile.AccessFlags;
-import org.apache.tomcat.util.bcel.classfile.Attribute;
-
-/**
- * Super class for FieldGen and MethodGen objects, since they have
- * some methods in common!
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public abstract class FieldGenOrMethodGen extends AccessFlags implements NamedAndTyped, Cloneable {
-
-    protected String name;
-    protected Type type;
-    protected ConstantPoolGen cp;
-    private List attribute_vec = new ArrayList();
-    
-
-
-    protected FieldGenOrMethodGen() {
-    }
-
-
-    
-
-
-    
-
-
-    /** @return name of method/field.
-     */
-    public String getName() {
-        return name;
-    }
-
-
-    
-
-
-    
-
-
-    
-
-
-    
-    
-    
-
-
-    
-    
-    
-
-
-    
-    
-    
-
-
-    /**
-     * @return all attributes of this method.
-     */
-    public Attribute[] getAttributes() {
-        Attribute[] attributes = new Attribute[attribute_vec.size()];
-        attribute_vec.toArray(attributes);
-        return attributes;
-    }
-    
-    
-
-
-    /** @return signature of method/field.
-     */
-    public abstract String getSignature();
-
-
-    public Object clone() {
-        try {
-            return super.clone();
-        } catch (CloneNotSupportedException e) {
-            System.err.println(e);
-            return null;
-        }
-    }
-}

==================================================
Instruction.java
deleted file mode 100644
index 632f957714..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/IndexedInstruction.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * Denote entity that refers to an index, e.g. local variable instructions,
- * RET, CPInstruction, etc.
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public interface IndexedInstruction {
-
-    public int getIndex();
-
-
-    
-}

==================================================
InstructionComparator.java
deleted file mode 100644
index 5ebe2f2201..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/Instruction.java
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.io.Serializable;
-import org.apache.tomcat.util.bcel.Constants;
-
-/** 
- * Abstract super class for all Java byte codes.
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public abstract class Instruction implements Cloneable, Serializable {
-
-    protected short length = 1; // Length of instruction in bytes 
-    protected short opcode = -1; // Opcode number
-    private static InstructionComparator cmp = InstructionComparator.DEFAULT;
-
-
-    /**
-     * Empty constructor needed for the Class.newInstance() statement in
-     * Instruction.readInstruction(). Not to be used otherwise.
-     */
-    Instruction() {
-    }
-
-
-    public Instruction(short opcode, short length) {
-        this.length = length;
-        this.opcode = opcode;
-    }
-
-
-    /**
-     * Dump instruction as byte code to stream out.
-     * @param out Output stream
-     */
-    public void dump( DataOutputStream out ) throws IOException {
-        out.writeByte(opcode); // Common for all instructions
-    }
-
-
-    /** @return name of instruction, i.e., opcode name
-     */
-    public String getName() {
-        return Constants.OPCODE_NAMES[opcode];
-    }
-
-
-    /**
-     * Long output format:
-     *
-     * &lt;name of opcode&gt; "["&lt;opcode number&gt;"]" 
-     * "("&lt;length of instruction&gt;")"
-     *
-     * @param verbose long/short format switch
-     * @return mnemonic for instruction
-     */
-    public String toString( boolean verbose ) {
-        if (verbose) {
-            return getName() + "[" + opcode + "](" + length + ")";
-        } else {
-            return getName();
-        }
-    }
-
-
-    /**
-     * @return mnemonic for instruction in verbose format
-     */
-    public String toString() {
-        return toString(true);
-    }
-
-
-    /**
-     * @return length (in bytes) of instruction
-     */
-    public int getLength() {
-        return length;
-    }
-
-
-    /** Some instructions may be reused, so don't do anything by default.
-     */
-    void dispose() {
-    }
-
-    /** Check for equality, delegated to comparator
-     * @return true if that is an Instruction and has the same opcode
-     */
-    public boolean equals( Object that ) {
-        return (that instanceof Instruction) ? cmp.equals(this, (Instruction) that) : false;
-    }
-}

==================================================
InstructionHandle.java
deleted file mode 100644
index 71bac694de..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/InstructionComparator.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * Equality of instructions isn't clearly to be defined. You might
- * wish, for example, to compare whether instructions have the same
- * meaning. E.g., whether two INVOKEVIRTUALs describe the same
- * call.<br>The DEFAULT comparator however, considers two instructions
- * to be equal if they have same opcode and point to the same indexes
- * (if any) in the constant pool or the same local variable index. Branch
- * instructions must have the same target.
- *
- * @see Instruction
- * @version $Id$
- * @author <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public interface InstructionComparator {
-
-    public static final InstructionComparator DEFAULT = new InstructionComparator() {
-
-        public boolean equals( Instruction i1, Instruction i2 ) {
-            if (i1.opcode == i2.opcode) {
-                if (i1 instanceof Select) {
-                    InstructionHandle[] t1 = ((Select) i1).getTargets();
-                    InstructionHandle[] t2 = ((Select) i2).getTargets();
-                    if (t1.length == t2.length) {
-                        for (int i = 0; i < t1.length; i++) {
-                            if (t1[i] != t2[i]) {
-                                return false;
-                            }
-                        }
-                        return true;
-                    }
-                } else if (i1 instanceof BranchInstruction) {
-                    return ((BranchInstruction) i1).target == ((BranchInstruction) i2).target;
-                } else if (i1 instanceof ConstantPushInstruction) {
-                    return ((ConstantPushInstruction) i1).getValue().equals(
-                            ((ConstantPushInstruction) i2).getValue());
-                } else if (i1 instanceof IndexedInstruction) {
-                    return ((IndexedInstruction) i1).getIndex() == ((IndexedInstruction) i2)
-                            .getIndex();
-                } else if (i1 instanceof NEWARRAY) {
-                    return ((NEWARRAY) i1).getTypecode() == ((NEWARRAY) i2).getTypecode();
-                } else {
-                    return true;
-                }
-            }
-            return false;
-        }
-    };
-
-
-    public boolean equals( Instruction i1, Instruction i2 );
-}

==================================================
InstructionList.java
deleted file mode 100644
index 885dc25274..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/InstructionHandle.java
+++ /dev/null
@@ -1,170 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-import java.util.HashSet;
-import java.util.Set;
-import org.apache.tomcat.util.bcel.classfile.Utility;
-
-/**
- * Instances of this class give users a handle to the instructions contained in
- * an InstructionList. Instruction objects may be used more than once within a
- * list, this is useful because it saves memory and may be much faster.
- *
- * Within an InstructionList an InstructionHandle object is wrapped
- * around all instructions, i.e., it implements a cell in a
- * doubly-linked list. From the outside only the next and the
- * previous instruction (handle) are accessible. One
- * can traverse the list via an Enumeration returned by
- * InstructionList.elements().
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- * @see Instruction
- * @see BranchHandle
- * @see InstructionList 
- */
-public class InstructionHandle implements java.io.Serializable {
-
-    InstructionHandle next; // Will be set from the outside
-    Instruction instruction;
-    protected int i_position = -1; // byte code offset of instruction
-    private Set targeters;
-
-
-    
-
-
-    
-
-
-    public final Instruction getInstruction() {
-        return instruction;
-    }
-
-
-    /**
-     * Replace current instruction contained in this handle.
-     * Old instruction is disposed using Instruction.dispose().
-     */
-    public void setInstruction( Instruction i ) { // Overridden in BranchHandle
-        if (i == null) {
-            throw new ClassGenException("Assigning null to handle");
-        }
-        if ((this.getClass() != BranchHandle.class) && (i instanceof BranchInstruction)) {
-            throw new ClassGenException("Assigning branch instruction " + i + " to plain handle");
-        }
-        if (instruction != null) {
-            instruction.dispose();
-        }
-        instruction = i;
-    }
-
-
-    
-
-
-    /*private*/protected InstructionHandle(Instruction i) {
-        setInstruction(i);
-    }
-
-    private static InstructionHandle ih_list = null; // List of reusable handles
-
-    /** @return the position, i.e., the byte code offset of the contained
-     * instruction. This is accurate only after
-     * InstructionList.setPositions() has been called.
-     */
-    public int getPosition() {
-        return i_position;
-    }
-
-
-    /** Set the position, i.e., the byte code offset of the contained
-     * instruction.
-     */
-    void setPosition( int pos ) {
-        i_position = pos;
-    }
-
-
-    /** Overridden in BranchHandle
-     */
-    protected void addHandle() {
-        next = ih_list;
-        ih_list = this;
-    }
-
-
-    
-
-
-    
-
-
-    /**
-     * Denote this handle isn't referenced anymore by t.
-     */
-    public void removeTargeter( InstructionTargeter t ) {
-        if (targeters != null) {
-            targeters.remove(t);
-        }
-    }
-
-
-    /**
-     * Denote this handle is being referenced by t.
-     */
-    public void addTargeter( InstructionTargeter t ) {
-        if (targeters == null) {
-            targeters = new HashSet();
-        }
-        //if(!targeters.contains(t))
-        targeters.add(t);
-    }
-
-
-    
-
-
-    
-
-
-    /** @return a (verbose) string representation of the contained instruction. 
-     */
-    public String toString( boolean verbose ) {
-        return Utility.format(i_position, 4, false, ' ') + ": " + instruction.toString(verbose);
-    }
-
-
-    /** @return a string representation of the contained instruction. 
-     */
-    public String toString() {
-        return toString(true);
-    }
-
-
-    
-
-
-    
-
-
-    
-
-
-    
-}

==================================================
InstructionTargeter.java
deleted file mode 100644
index 6e4a8216c3..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/InstructionList.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-import java.io.Serializable;
-
-/** 
- * This class is a container for a list of <a
- * href="Instruction.html">Instruction</a> objects. Instructions can
- * be appended, inserted, moved, deleted, etc.. Instructions are being
- * wrapped into <a
- * href="InstructionHandle.html">InstructionHandles</a> objects that
- * are returned upon append/insert operations. They give the user
- * (read only) access to the list structure, such that it can be traversed and
- * manipulated in a controlled way.
- *
- * A list is finally dumped to a byte code array with <a
- * href="#getByteCode()">getByteCode</a>.
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- * @see     Instruction
- * @see     InstructionHandle
- * @see BranchHandle
- */
-public class InstructionList implements Serializable {
-
-    private InstructionHandle start = null, end = null;
-
-    /**
-     * Create (empty) instruction list.
-     */
-    public InstructionList() {
-    }
-
-    
-    
-
-
-    public String toString() {
-        return toString(true);
-    }
-
-
-    /**
-     * @param verbose toggle output format
-     * @return String containing all instructions in this list.
-     */
-    public String toString( boolean verbose ) {
-        StringBuffer buf = new StringBuffer();
-        for (InstructionHandle ih = start; ih != null; ih = ih.next) {
-            buf.append(ih.toString(verbose)).append("\n");
-        }
-        return buf.toString();
-    }
-
-
-    /**
-     * @return start of list
-     */
-    public InstructionHandle getStart() {
-        return start;
-    }
-
-
-    /**
-     * @return end of list
-     */
-    public InstructionHandle getEnd() {
-        return end;
-    }
-}

==================================================
LocalVariableGen.java
deleted file mode 100644
index 94bef35081..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/InstructionTargeter.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * Denote that a class targets InstructionHandles within an InstructionList. Namely
- * the following implementers:
- *
- * @see BranchHandle
- * @see LocalVariableGen
- * @see CodeExceptionGen
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public interface InstructionTargeter {
-
-    
-
-
-    
-}

==================================================
NEWARRAY.java
deleted file mode 100644
index 1e9ca620d6..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/LocalVariableGen.java
+++ /dev/null
@@ -1,155 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-import org.apache.tomcat.util.bcel.classfile.LocalVariable;
-
-/** 
- * This class represents a local variable within a method. It contains its
- * scope, name and type. The generated LocalVariable object can be obtained
- * with getLocalVariable which needs the instruction list and the constant
- * pool as parameters.
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- * @see     LocalVariable
- */
-public class LocalVariableGen implements InstructionTargeter, NamedAndTyped, Cloneable,
-        java.io.Serializable {
-
-    private int index;
-    private String name;
-    private Type type;
-    private InstructionHandle start, end;
-
-
-    
-
-
-    /**
-     * Get LocalVariable object.
-     *
-     * This relies on that the instruction list has already been dumped to byte code or
-     * or that the `setPositions' methods has been called for the instruction list.
-     *
-     * Note that for local variables whose scope end at the last
-     * instruction of the method's code, the JVM specification is ambiguous:
-     * both a start_pc+length ending at the last instruction and
-     * start_pc+length ending at first index beyond the end of the code are
-     * valid.
-     *
-     * @param cp constant pool
-     */
-    public LocalVariable getLocalVariable( ConstantPoolGen cp ) {
-        int start_pc = start.getPosition();
-        int length = end.getPosition() - start_pc;
-        if (length > 0) {
-            length += end.getInstruction().getLength();
-        }
-        int name_index = cp.addUtf8(name);
-        int signature_index = cp.addUtf8(type.getSignature());
-        return new LocalVariable(start_pc, length, name_index, signature_index, index, cp
-                .getConstantPool());
-    }
-
-
-    
-
-
-    public int getIndex() {
-        return index;
-    }
-
-
-    
-
-
-    public String getName() {
-        return name;
-    }
-
-
-    
-
-
-    
-
-
-    public InstructionHandle getStart() {
-        return start;
-    }
-
-
-    public InstructionHandle getEnd() {
-        return end;
-    }
-
-
-    public void setStart( InstructionHandle start ) {
-        BranchInstruction.notifyTarget(this.start, start, this);
-        this.start = start;
-    }
-
-
-    public void setEnd( InstructionHandle end ) {
-        BranchInstruction.notifyTarget(this.end, end, this);
-        this.end = end;
-    }
-
-
-    
-
-
-    
-
-
-    /** @return a hash code value for the object.
-     */
-    public int hashCode() {
-        //If the user changes the name or type, problems with the targeter hashmap will occur
-        int hc = index ^ name.hashCode() ^ type.hashCode();
-        return hc;
-    }
-
-
-    /**
-     * We consider to local variables to be equal, if the use the same index and
-     * are valid in the same range.
-     */
-    public boolean equals( Object o ) {
-        if (!(o instanceof LocalVariableGen)) {
-            return false;
-        }
-        LocalVariableGen l = (LocalVariableGen) o;
-        return (l.index == index) && (l.start == start) && (l.end == end);
-    }
-
-
-    public String toString() {
-        return "LocalVariableGen(" + name + ", " + type + ", " + start + ", " + end + ")";
-    }
-
-
-    public Object clone() {
-        try {
-            return super.clone();
-        } catch (CloneNotSupportedException e) {
-            System.err.println(e);
-            return null;
-        }
-    }
-}

==================================================
NamedAndTyped.java
deleted file mode 100644
index c1bca1b843..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/NEWARRAY.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-import java.io.DataOutputStream;
-import java.io.IOException;
-
-/** 
- * NEWARRAY -  Create new array of basic type (int, short, ...)
- * <PRE>Stack: ..., count -&gt; ..., arrayref</PRE>
- * type must be one of T_INT, T_SHORT, ...
- * 
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class NEWARRAY extends Instruction implements AllocationInstruction, ExceptionThrower,
-        StackProducer {
-
-    private byte type;
-
-
-    /**
-     * Empty constructor needed for the Class.newInstance() statement in
-     * Instruction.readInstruction(). Not to be used otherwise.
-     */
-    NEWARRAY() {
-    }
-
-
-    
-
-
-    
-
-
-    /**
-     * Dump instruction as byte code to stream out.
-     * @param out Output stream
-     */
-    public void dump( DataOutputStream out ) throws IOException {
-        out.writeByte(opcode);
-        out.writeByte(type);
-    }
-
-
-    /**
-     * @return numeric code for basic element type
-     */
-    public final byte getTypecode() {
-        return type;
-    }
-
-
-    
-
-
-    /**
-     * @return mnemonic for instruction
-     */
-    public String toString( boolean verbose ) {
-        return super.toString(verbose) + " " + org.apache.tomcat.util.bcel.Constants.TYPE_NAMES[type];
-    }
-}

==================================================
PushInstruction.java
deleted file mode 100644
index e8982c4927..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/NamedAndTyped.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * Denote entity that has both name and type. This is true for local variables,
- * methods and fields.
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public interface NamedAndTyped {
-
-    public String getName();
-
-
-    
-
-
-    
-
-
-    
-}

==================================================
ReferenceType.java
deleted file mode 100644
index e3525cbe73..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/PushInstruction.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * Denotes an unparameterized instruction to produce a value on top of the stack,
- * such as ILOAD, LDC, SIPUSH, DUP, ICONST, etc.
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
-
- * @see ILOAD
- * @see ICONST
- * @see LDC
- * @see DUP
- * @see SIPUSH
- * @see GETSTATIC
- */
-public interface PushInstruction extends StackProducer {
-}

==================================================
Select.java
deleted file mode 100644
index e0a6b11e84..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/ReferenceType.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-import org.apache.tomcat.util.bcel.Constants;
-
-/**
- * Super class for object and array types.
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public abstract class ReferenceType extends Type {
-
-    
-
-
-    /** Class is non-abstract but not instantiable from the outside
-     */
-    ReferenceType() {
-        super(Constants.T_OBJECT, "<null object>");
-    }
-
-
-    
-
-
-    
-
-
-    
-
-
-    
-}

==================================================
SimpleElementValueGen.java
deleted file mode 100644
index 5d7ee99d57..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/Select.java
+++ /dev/null
@@ -1,167 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-import java.io.DataOutputStream;
-import java.io.IOException;
-
-/** 
- * Select - Abstract super class for LOOKUPSWITCH and TABLESWITCH instructions.
- * 
- * <p>We use our super's <code>target</code> property as the default target.
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- * @see LOOKUPSWITCH
- * @see TABLESWITCH
- * @see InstructionList
- */
-public abstract class Select extends BranchInstruction implements VariableLengthInstruction,
-        StackProducer {
-
-    protected int[] match; // matches, i.e., case 1: ...
-    protected int[] indices; // target offsets
-    protected InstructionHandle[] targets; // target objects in instruction list
-    
-    protected int match_length; // number of cases
-    protected int padding = 0; // number of pad bytes for alignment
-
-
-    /**
-     * Empty constructor needed for the Class.newInstance() statement in
-     * Instruction.readInstruction(). Not to be used otherwise.
-     */
-    Select() {
-    }
-
-
-    
-    /**
-     * Dump instruction as byte code to stream out.
-     * @param out Output stream
-     */
-    public void dump( DataOutputStream out ) throws IOException {
-        out.writeByte(opcode);
-        for (int i = 0; i < padding; i++) {
-            out.writeByte(0);
-        }
-        index = getTargetOffset(); // Write default target offset
-        out.writeInt(index);
-    }
-
-
-    /**
-     * @return mnemonic for instruction
-     */
-    public String toString( boolean verbose ) {
-        StringBuffer buf = new StringBuffer(super.toString(verbose));
-        if (verbose) {
-            for (int i = 0; i < match_length; i++) {
-                String s = "null";
-                if (targets[i] != null) {
-                    s = targets[i].getInstruction().toString();
-                }
-                buf.append("(").append(match[i]).append(", ").append(s).append(" = {").append(
-                        indices[i]).append("})");
-            }
-        } else {
-            buf.append(" ...");
-        }
-        return buf.toString();
-    }
-
-
-    /**
-     * Set branch target for `i'th case
-     */
-    public void setTarget( int i, InstructionHandle target ) {
-        notifyTarget(targets[i], target, this);
-        targets[i] = target;
-    }
-
-
-    /**
-     * @param old_ih old target
-     * @param new_ih new target
-     */
-    public void updateTarget( InstructionHandle old_ih, InstructionHandle new_ih ) {
-        boolean targeted = false;
-        if (target == old_ih) {
-            targeted = true;
-            setTarget(new_ih);
-        }
-        for (int i = 0; i < targets.length; i++) {
-            if (targets[i] == old_ih) {
-                targeted = true;
-                setTarget(i, new_ih);
-            }
-        }
-        if (!targeted) {
-            throw new ClassGenException("Not targeting " + old_ih);
-        }
-    }
-
-
-    /**
-     * @return true, if ih is target of this instruction
-     */
-    public boolean containsTarget( InstructionHandle ih ) {
-        if (target == ih) {
-            return true;
-        }
-        for (int i = 0; i < targets.length; i++) {
-            if (targets[i] == ih) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-
-    protected Object clone() throws CloneNotSupportedException {
-        Select copy = (Select) super.clone();
-        copy.match = (int[]) match.clone();
-        copy.indices = (int[]) indices.clone();
-        copy.targets = (InstructionHandle[]) targets.clone();
-        return copy;
-    }
-
-
-    /**
-     * Inform targets that they're not targeted anymore.
-     */
-    void dispose() {
-        super.dispose();
-        for (int i = 0; i < targets.length; i++) {
-            targets[i].removeTargeter(this);
-        }
-    }
-
-
-    
-
-
-    
-
-
-    /**
-     * @return array of match targets
-     */
-    public InstructionHandle[] getTargets() {
-        return targets;
-    }
-}

==================================================
StackProducer.java
deleted file mode 100644
index 568a3f6878..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/SimpleElementValueGen.java
+++ /dev/null
@@ -1,179 +0,0 @@
-package org.apache.tomcat.util.bcel.generic;
-
-import java.io.DataOutputStream;
-import java.io.IOException;
-import org.apache.tomcat.util.bcel.classfile.ConstantDouble;
-import org.apache.tomcat.util.bcel.classfile.ConstantFloat;
-import org.apache.tomcat.util.bcel.classfile.ConstantInteger;
-import org.apache.tomcat.util.bcel.classfile.ConstantLong;
-import org.apache.tomcat.util.bcel.classfile.ConstantUtf8;
-import org.apache.tomcat.util.bcel.classfile.ElementValue;
-import org.apache.tomcat.util.bcel.classfile.SimpleElementValue;
-
-public class SimpleElementValueGen extends ElementValueGen
-{
-	// For primitive types and string type, this points to the value entry in
-	// the cpGen
-	// For 'class' this points to the class entry in the cpGen
-	private int idx;
-
-	
-
-	
-
-	
-
-	
-
-	
-
-	
-
-	
-
-	
-
-	
-
-	
-
-	/**
-	 * The boolean controls whether we copy info from the 'old' constant pool to
-	 * the 'new'. You need to use this ctor if the annotation is being copied
-	 * from one file to another.
-	 */
-	public SimpleElementValueGen(SimpleElementValue value,
-			ConstantPoolGen cpool, boolean copyPoolEntries)
-	{
-		super(value.getElementValueType(), cpool);
-		if (!copyPoolEntries)
-		{
-			// J5ASSERT: Could assert value.stringifyValue() is the same as
-			// cpool.getConstant(SimpleElementValuevalue.getIndex())
-			idx = value.getIndex();
-		}
-		else
-		{
-			switch (value.getElementValueType())
-			{
-			case STRING:
-				idx = cpool.addUtf8(value.getValueString());
-				break;
-			case PRIMITIVE_INT:
-				idx = cpool.addInteger(value.getValueInt());
-				break;
-			case PRIMITIVE_BYTE:
-				idx = cpool.addInteger(value.getValueByte());
-				break;
-			case PRIMITIVE_CHAR:
-				idx = cpool.addInteger(value.getValueChar());
-				break;
-			case PRIMITIVE_LONG:
-				idx = cpool.addLong(value.getValueLong());
-				break;
-			case PRIMITIVE_FLOAT:
-				idx = cpool.addFloat(value.getValueFloat());
-				break;
-			case PRIMITIVE_DOUBLE:
-				idx = cpool.addDouble(value.getValueDouble());
-				break;
-			case PRIMITIVE_BOOLEAN:
-				if (value.getValueBoolean())
-				{
-					idx = cpool.addInteger(1);
-				}
-				else
-				{
-					idx = cpool.addInteger(0);
-				}
-				break;
-			case PRIMITIVE_SHORT:
-				idx = cpool.addInteger(value.getValueShort());
-				break;
-			default:
-				throw new RuntimeException(
-						"SimpleElementValueGen class does not know how "
-								+ "to copy this type " + type);
-			}
-		}
-	}
-
-	/**
-	 * Return immutable variant
-	 */
-	public ElementValue getElementValue()
-	{
-		return new SimpleElementValue(type, idx, cpGen.getConstantPool());
-	}
-
-	
-
-	
-
-	
-
-	// Whatever kind of value it is, return it as a string
-	public String stringifyValue()
-	{
-		switch (type)
-		{
-		case PRIMITIVE_INT:
-			ConstantInteger c = (ConstantInteger) cpGen.getConstant(idx);
-			return Integer.toString(c.getBytes());
-		case PRIMITIVE_LONG:
-			ConstantLong j = (ConstantLong) cpGen.getConstant(idx);
-			return Long.toString(j.getBytes());
-		case PRIMITIVE_DOUBLE:
-			ConstantDouble d = (ConstantDouble) cpGen.getConstant(idx);
-			return Double.toString(d.getBytes());
-		case PRIMITIVE_FLOAT:
-			ConstantFloat f = (ConstantFloat) cpGen.getConstant(idx);
-			return Float.toString(f.getBytes());
-		case PRIMITIVE_SHORT:
-			ConstantInteger s = (ConstantInteger) cpGen.getConstant(idx);
-			return Integer.toString(s.getBytes());
-		case PRIMITIVE_BYTE:
-			ConstantInteger b = (ConstantInteger) cpGen.getConstant(idx);
-			return Integer.toString(b.getBytes());
-		case PRIMITIVE_CHAR:
-			ConstantInteger ch = (ConstantInteger) cpGen.getConstant(idx);
-			return Integer.toString(ch.getBytes());
-		case PRIMITIVE_BOOLEAN:
-			ConstantInteger bo = (ConstantInteger) cpGen.getConstant(idx);
-			if (bo.getBytes() == 0)
-				return "false";
-			if (bo.getBytes() != 0)
-				return "true";
-		case STRING:
-			ConstantUtf8 cu8 = (ConstantUtf8) cpGen.getConstant(idx);
-			return cu8.getBytes();
-		default:
-			throw new RuntimeException(
-					"SimpleElementValueGen class does not know how to stringify type "
-							+ type);
-		}
-	}
-
-	public void dump(DataOutputStream dos) throws IOException
-	{
-		dos.writeByte(type); // u1 kind of value
-		switch (type)
-		{
-		case PRIMITIVE_INT:
-		case PRIMITIVE_BYTE:
-		case PRIMITIVE_CHAR:
-		case PRIMITIVE_FLOAT:
-		case PRIMITIVE_LONG:
-		case PRIMITIVE_BOOLEAN:
-		case PRIMITIVE_SHORT:
-		case PRIMITIVE_DOUBLE:
-		case STRING:
-			dos.writeShort(idx);
-			break;
-		default:
-			throw new RuntimeException(
-					"SimpleElementValueGen doesnt know how to write out type "
-							+ type);
-		}
-	}
-}

==================================================
Type.java
deleted file mode 100644
index 6a4f2f5c97..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/StackProducer.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * Denote an instruction that may produce a value on top of the stack
- * (this excludes DUP_X1, e.g.)
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public interface StackProducer {
-
-    
-}

==================================================
TypedInstruction.java
deleted file mode 100644
index 69d19d6ff2..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/Type.java
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-import org.apache.tomcat.util.bcel.Constants;
-import org.apache.tomcat.util.bcel.classfile.Utility;
-
-/** 
- * Abstract super class for all possible java types, namely basic types
- * such as int, object types like String and array types, e.g. int[]
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public abstract class Type implements java.io.Serializable {
-
-    protected byte type;
-    protected String signature; // signature for the type
-    
-    
-    
-    
-    
-    
-    
-    
-    
-    
-    
-    
-    public static final ReferenceType NULL = new ReferenceType() {
-    };
-    
-
-
-    protected Type(byte t, String s) {
-        type = t;
-        signature = s;
-    }
-
-
-    /**
-     * @return hashcode of Type
-     */
-    public int hashCode() {
-    	return type ^ signature.hashCode();
-    }
-    
-    
-    /**
-     * @return whether the Types are equal
-     */
-    public boolean equals(Object o) {
-  		if (o instanceof Type) {
-  			Type t = (Type)o;
-  			return (type == t.type) && signature.equals(t.signature);
-  		}
-  		return false;
-    }
-    
-    
-    /**
-     * @return signature for given type.
-     */
-    public String getSignature() {
-        return signature;
-    }
-
-
-    
-
-
-    
-
-
-    /**
-     * @return Type string, e.g. `int[]'
-     */
-    public String toString() {
-        return ((this.equals(Type.NULL) || (type >= Constants.T_UNKNOWN))) ? signature : Utility
-                .signatureToString(signature, false);
-    }
-
-
-    /**
-     * Convert type to Java method signature, e.g. int[] f(java.lang.String x)
-     * becomes (Ljava/lang/String;)[I
-     *
-     * @param return_type what the method returns
-     * @param arg_types what are the argument types
-     * @return method signature for given type(s).
-     */
-    public static String getMethodSignature( Type return_type, Type[] arg_types ) {
-        StringBuffer buf = new StringBuffer("(");
-        int length = (arg_types == null) ? 0 : arg_types.length;
-        for (int i = 0; i < length; i++) {
-            buf.append(arg_types[i].getSignature());
-        }
-        buf.append(')');
-        buf.append(return_type.getSignature());
-        return buf.toString();
-    }
-
-}

==================================================
VariableLengthInstruction.java
deleted file mode 100644
index e0034b4cf1..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/TypedInstruction.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * Get the type associated with an instruction, int for ILOAD, or the type
- * of the field of a PUTFIELD instruction, e.g..
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public interface TypedInstruction {
-
-    
-}

==================================================
