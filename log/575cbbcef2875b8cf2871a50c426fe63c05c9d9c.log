575cbbcef2875b8cf2871a50c426fe63c05c9d9c
==================================================
Avoid unnecessary processing of async timeouts.
==================================================
Mark Thomas
==================================================
Tue Jun 19 11:58:55 2018 +0000
==================================================
AbstractProcessor.java
Avoid unnecessary processing of async timeouts.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1833825 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AbstractProtocol.java
index ae21353326..5be2cb8c1f 100644
--- a/java/org/apache/coyote/AbstractProcessor.java
+++ b/java/org/apache/coyote/AbstractProcessor.java
@@ -51,6 +51,7 @@ public abstract class AbstractProcessor extends AbstractProcessorLight implement
     protected final Adapter adapter;
     protected final AsyncStateMachine asyncStateMachine;
     private volatile long asyncTimeout = -1;
+    private volatile long asyncTimeoutGeneration = 0;
     protected final Request request;
     protected final Response response;
     protected volatile SocketWrapperBase<?> socketWrapper = null;
@@ -620,10 +621,17 @@ public abstract class AbstractProcessor extends AbstractProcessorLight implement
     private void doTimeoutAsync() {
         // Avoid multiple timeouts
         setAsyncTimeout(-1);
+        asyncTimeoutGeneration = asyncStateMachine.getCurrentGeneration();
         processSocketEvent(SocketEvent.TIMEOUT, true);
     }
 
 
+    @Override
+    public boolean checkAsyncTimeoutGeneration() {
+        return asyncTimeoutGeneration == asyncStateMachine.getCurrentGeneration();
+    }
+
+
     public void setAsyncTimeout(long timeout) {
         asyncTimeout = timeout;
     }

==================================================
AsyncStateMachine.java
index 16db7330d8..b8c9d62ace 100644
--- a/java/org/apache/coyote/AbstractProtocol.java
+++ b/java/org/apache/coyote/AbstractProtocol.java
@@ -683,6 +683,16 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
                         processor, socket));
             }
 
+            // Async timeouts are calculated on a dedicated thread and then
+            // dispatched. Because of delays in the dispatch process, the
+            // timeout may no longer be required. Check here and avoid
+            // unnecessary processing.
+            if (SocketEvent.TIMEOUT == status && (processor == null ||
+                    !processor.isAsync() || !processor.checkAsyncTimeoutGeneration())) {
+                // This is effectively a NO-OP
+                return SocketState.OPEN;
+            }
+
             if (processor != null) {
                 // Make sure an async timeout doesn't fire
                 getProtocol().removeWaitingProcessor(processor);

==================================================
Processor.java
index 60549166b0..6ce2c827c1 100644
--- a/java/org/apache/coyote/AsyncStateMachine.java
+++ b/java/org/apache/coyote/AsyncStateMachine.java
@@ -18,6 +18,7 @@ package org.apache.coyote;
 
 import java.security.AccessController;
 import java.security.PrivilegedAction;
+import java.util.concurrent.atomic.AtomicLong;
 
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.res.StringManager;
@@ -189,6 +190,7 @@ class AsyncStateMachine {
 
     private volatile AsyncState state = AsyncState.DISPATCHED;
     private volatile long lastAsyncStart = 0;
+    private AtomicLong generation = new AtomicLong(0);
     // Need this to fire listener on complete
     private AsyncContextCallback asyncCtxt = null;
     private final AbstractProcessor processor;
@@ -234,8 +236,13 @@ class AsyncStateMachine {
         return lastAsyncStart;
     }
 
+    long getCurrentGeneration() {
+        return generation.get();
+    }
+
     synchronized void asyncStart(AsyncContextCallback asyncCtxt) {
         if (state == AsyncState.DISPATCHED) {
+            generation.incrementAndGet();
             state = AsyncState.STARTING;
             this.asyncCtxt = asyncCtxt;
             lastAsyncStart = System.currentTimeMillis();

==================================================
UpgradeProcessorBase.java
index c016c3ab81..68edff505d 100644
--- a/java/org/apache/coyote/Processor.java
+++ b/java/org/apache/coyote/Processor.java
@@ -110,4 +110,15 @@ public interface Processor {
      * an existing multiplexed connection.
      */
     void pause();
+
+    /**
+     * Check to see if the async generation (each cycle of async increments the
+     * generation of the AsyncStateMachine) is the same as the generation when
+     * the most recent async timeout was triggered. This is intended to be used
+     * to avoid unnecessary processing.
+     *
+     * @return {@code true} If the async generation has not changed since the
+     *         async timeout was triggered
+     */
+    boolean checkAsyncTimeoutGeneration();
 }

==================================================
