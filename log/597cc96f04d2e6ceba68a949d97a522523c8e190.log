597cc96f04d2e6ceba68a949d97a522523c8e190
==================================================
Refactor testing to take account of OpenSSL giving equal preference to some ciphers.
==================================================
Mark Thomas
==================================================
Thu Dec 17 20:09:25 2015 +0000
==================================================
TestOpenSSLCipherConfigurationParser.java
Refactor testing to take account of OpenSSL giving equal preference to some ciphers.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1720640 13f79535-47bb-0310-9956-ffa450edef68



==================================================
TestOpenSSLCipherConfigurationParserOnly.java
index a4a3ce0a4b..c96c46401b 100644
--- a/test/org/apache/tomcat/util/net/openssl/ciphers/TestOpenSSLCipherConfigurationParser.java
+++ b/test/org/apache/tomcat/util/net/openssl/ciphers/TestOpenSSLCipherConfigurationParser.java
@@ -660,16 +660,26 @@ public class TestOpenSSLCipherConfigurationParser {
 
         TesterOpenSSL.removeUnimplementedCiphersJsse(jsseCipherListFromParser);
 
-        Assert.assertEquals("Tested '" + specification + "': ",
-                            listToString(jsseCipherListFromOpenSSL), listToString(jsseCipherListFromParser));
+        // First check the lists have the same entries
+        Assert.assertEquals(jsseCipherListFromOpenSSL.size(), jsseCipherListFromParser.size());
+        Assert.assertTrue(jsseCipherListFromOpenSSL.containsAll(jsseCipherListFromParser));
+
+        // OpenSSL treats many ciphers as having equal preference. The order
+        // returned depends on the order they are requested. The following code
+        // checks that the Parser produces a cipher list that is consistent with
+        // OpenSSL's preference order by confirming that running through OPenSSL
+        // does not change the order.
+        String parserOrderedExpression = listToString(jsseCipherListFromParser, ':');
+        Assert.assertEquals(TesterOpenSSL.getOpenSSLCiphersAsExpression(
+                parserOrderedExpression), parserOrderedExpression);
     }
 
 
-    private String listToString(List<String> list) {
+    private String listToString(List<String> list, char separator) {
         StringBuilder sb = new StringBuilder();
         for (String entry : list) {
             sb.append(entry);
-            sb.append(',');
+            sb.append(separator);
         }
         return sb.toString();
     }

==================================================
