6b4aa7935dd025a805adaf82b927b5ef2626e8a9
==================================================
Update the internal fork of Apache Commons DBCP 2 to abc0484 (2018-08-09) to pick up some bug fixes and enhancements.
==================================================
Mark Thomas
==================================================
Thu Aug 9 16:50:30 2018 +0000
==================================================
BasicDataSource.java
index 8ace25e4a7..4a37b2d5bb 100644
--- a/MERGE.txt
+++ b/MERGE.txt
@@ -69,7 +69,7 @@ Sub-tree
 src/main/java/org/apache/commons/dbcp2
 src/main/resources/org/apache/commons/dbcp2
 The SHA1 ID for the most recent commit to be merged to Tomcat is:
-d7aa662fbbb99e536ae28c47d0c4e1d51e39d5b9
+abc048454398d8c9924a1af9c04501817f44a11d
 
 Pool2
 Sub-tree

==================================================
BasicDataSourceFactory.java
index 82bd55ceec..7f07797bfa 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java
@@ -223,6 +223,11 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
      */
     private volatile String defaultCatalog;
 
+    /**
+     * The default "schema" of connections created by this pool.
+     */
+    private volatile String defaultSchema;
+
     /**
      * Returns the default catalog.
      *
@@ -233,6 +238,17 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
         return this.defaultCatalog;
     }
 
+    /**
+     * Returns the default schema.
+     *
+     * @return the default schema.
+     * @since 2.5.0
+     */
+    @Override
+    public String getDefaultSchema() {
+        return this.defaultSchema;
+    }
+
     /**
      * <p>
      * Sets the default catalog.
@@ -254,6 +270,28 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
         }
     }
 
+    /**
+     * <p>
+     * Sets the default schema.
+     * </p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
+     * time one of the following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code>
+     * </p>
+     *
+     * @param defaultSchema
+     *            the default catalog
+     * @since 2.5.0
+     */
+    public void setDefaultSchema(final String defaultSchema) {
+        if (defaultSchema != null && defaultSchema.trim().length() > 0) {
+            this.defaultSchema = defaultSchema;
+        } else {
+            this.defaultSchema = null;
+        }
+    }
+
     /**
      * The property that controls if the pooled connections cache some state rather than query the database for current
      * state to improve performance.
@@ -2271,11 +2309,11 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
      * Closes the connection pool, silently swallowing any exception that occurs.
      */
     private void closeConnectionPool() {
-        final GenericObjectPool<?> oldpool = connectionPool;
+        final GenericObjectPool<?> oldPool = connectionPool;
         connectionPool = null;
         try {
-            if (oldpool != null) {
-                oldpool.close();
+            if (oldPool != null) {
+                oldPool.close();
             }
         } catch (final Exception e) {
             /* Ignore */
@@ -2330,6 +2368,7 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
             connectionFactory.setDefaultAutoCommit(defaultAutoCommit);
             connectionFactory.setDefaultTransactionIsolation(defaultTransactionIsolation);
             connectionFactory.setDefaultCatalog(defaultCatalog);
+            connectionFactory.setDefaultSchema(defaultSchema);
             connectionFactory.setCacheState(cacheState);
             connectionFactory.setPoolStatements(poolPreparedStatements);
             connectionFactory.setMaxOpenPreparedStatements(maxOpenPreparedStatements);

==================================================
BasicDataSourceMXBean.java
index 671d01287c..200a8fec7d 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/BasicDataSourceFactory.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/BasicDataSourceFactory.java
@@ -63,6 +63,7 @@ public class BasicDataSourceFactory implements ObjectFactory {
     private static final String PROP_DEFAULTREADONLY = "defaultReadOnly";
     private static final String PROP_DEFAULTTRANSACTIONISOLATION = "defaultTransactionIsolation";
     private static final String PROP_DEFAULTCATALOG = "defaultCatalog";
+    private static final String PROP_DEFAULTSCHEMA = "defaultSchema";
     private static final String PROP_CACHESTATE = "cacheState";
     private static final String PROP_DRIVERCLASSNAME = "driverClassName";
     private static final String PROP_LIFO = "lifo";
@@ -130,17 +131,17 @@ public class BasicDataSourceFactory implements ObjectFactory {
     private static final String SILENTPROP_AUTH = "auth";
 
     private static final String[] ALL_PROPERTIES = {PROP_DEFAULTAUTOCOMMIT, PROP_DEFAULTREADONLY,
-            PROP_DEFAULTTRANSACTIONISOLATION, PROP_DEFAULTCATALOG, PROP_CACHESTATE, PROP_DRIVERCLASSNAME, PROP_LIFO,
-            PROP_MAXTOTAL, PROP_MAXIDLE, PROP_MINIDLE, PROP_INITIALSIZE, PROP_MAXWAITMILLIS, PROP_TESTONCREATE,
-            PROP_TESTONBORROW, PROP_TESTONRETURN, PROP_TIMEBETWEENEVICTIONRUNSMILLIS, PROP_NUMTESTSPEREVICTIONRUN,
-            PROP_MINEVICTABLEIDLETIMEMILLIS, PROP_SOFTMINEVICTABLEIDLETIMEMILLIS, PROP_EVICTIONPOLICYCLASSNAME,
-            PROP_TESTWHILEIDLE, PROP_PASSWORD, PROP_URL, PROP_USERNAME, PROP_VALIDATIONQUERY,
-            PROP_VALIDATIONQUERY_TIMEOUT, PROP_CONNECTIONINITSQLS, PROP_ACCESSTOUNDERLYINGCONNECTIONALLOWED,
-            PROP_REMOVEABANDONEDONBORROW, PROP_REMOVEABANDONEDONMAINTENANCE, PROP_REMOVEABANDONEDTIMEOUT,
-            PROP_LOGABANDONED, PROP_ABANDONEDUSAGETRACKING, PROP_POOLPREPAREDSTATEMENTS, PROP_MAXOPENPREPAREDSTATEMENTS,
-            PROP_CONNECTIONPROPERTIES, PROP_MAXCONNLIFETIMEMILLIS, PROP_LOGEXPIREDCONNECTIONS, PROP_ROLLBACK_ON_RETURN,
-            PROP_ENABLE_AUTOCOMMIT_ON_RETURN, PROP_DEFAULT_QUERYTIMEOUT, PROP_FASTFAIL_VALIDATION,
-            PROP_DISCONNECTION_SQL_CODES, PROP_JMX_NAME };
+            PROP_DEFAULTTRANSACTIONISOLATION, PROP_DEFAULTCATALOG, PROP_DEFAULTSCHEMA, PROP_CACHESTATE,
+            PROP_DRIVERCLASSNAME, PROP_LIFO, PROP_MAXTOTAL, PROP_MAXIDLE, PROP_MINIDLE, PROP_INITIALSIZE,
+            PROP_MAXWAITMILLIS, PROP_TESTONCREATE, PROP_TESTONBORROW, PROP_TESTONRETURN,
+            PROP_TIMEBETWEENEVICTIONRUNSMILLIS, PROP_NUMTESTSPEREVICTIONRUN, PROP_MINEVICTABLEIDLETIMEMILLIS,
+            PROP_SOFTMINEVICTABLEIDLETIMEMILLIS, PROP_EVICTIONPOLICYCLASSNAME, PROP_TESTWHILEIDLE, PROP_PASSWORD,
+            PROP_URL, PROP_USERNAME, PROP_VALIDATIONQUERY, PROP_VALIDATIONQUERY_TIMEOUT, PROP_CONNECTIONINITSQLS,
+            PROP_ACCESSTOUNDERLYINGCONNECTIONALLOWED, PROP_REMOVEABANDONEDONBORROW, PROP_REMOVEABANDONEDONMAINTENANCE,
+            PROP_REMOVEABANDONEDTIMEOUT, PROP_LOGABANDONED, PROP_ABANDONEDUSAGETRACKING, PROP_POOLPREPAREDSTATEMENTS,
+            PROP_MAXOPENPREPAREDSTATEMENTS, PROP_CONNECTIONPROPERTIES, PROP_MAXCONNLIFETIMEMILLIS,
+            PROP_LOGEXPIREDCONNECTIONS, PROP_ROLLBACK_ON_RETURN, PROP_ENABLE_AUTOCOMMIT_ON_RETURN,
+            PROP_DEFAULT_QUERYTIMEOUT, PROP_FASTFAIL_VALIDATION, PROP_DISCONNECTION_SQL_CODES, PROP_JMX_NAME };
 
     /**
      * Obsolete properties from DBCP 1.x. with warning strings suggesting new properties. LinkedHashMap will guarantee
@@ -337,6 +338,11 @@ public class BasicDataSourceFactory implements ObjectFactory {
             dataSource.setDefaultCatalog(value);
         }
 
+        value = properties.getProperty(PROP_DEFAULTSCHEMA);
+        if (value != null) {
+            dataSource.setDefaultSchema(value);
+        }
+
         value = properties.getProperty(PROP_CACHESTATE);
         if (value != null) {
             dataSource.setCacheState(Boolean.valueOf(value).booleanValue());

==================================================
DelegatingCallableStatement.java
index 0878d148e2..687786e4fe 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/BasicDataSourceMXBean.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/BasicDataSourceMXBean.java
@@ -58,6 +58,16 @@ public interface BasicDataSourceMXBean {
      */
     String getDefaultCatalog();
 
+    /**
+     * See {@link BasicDataSource#getDefaultSchema()}
+     *
+     * @return {@link BasicDataSource#getDefaultSchema()}
+     * @since 2.5.0
+     */
+    default String getDefaultSchema() {
+        return null;
+    }
+
     /**
      * See {@link BasicDataSource#getCacheState()}
      *

==================================================
DelegatingConnection.java
index 0466ec60c4..e32aac0b82 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/DelegatingCallableStatement.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/DelegatingCallableStatement.java
@@ -30,6 +30,7 @@ import java.sql.NClob;
 import java.sql.Ref;
 import java.sql.RowId;
 import java.sql.SQLException;
+import java.sql.SQLType;
 import java.sql.SQLXML;
 import java.sql.Time;
 import java.sql.Timestamp;
@@ -55,51 +56,55 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement imp
      * Creates a wrapper for the Statement which traces this Statement to the Connection which created it and the code
      * which created it.
      *
-     * @param c
+     * @param connection
      *            the {@link DelegatingConnection} that created this statement
-     * @param s
+     * @param statement
      *            the {@link CallableStatement} to delegate all calls to
      */
-    public DelegatingCallableStatement(final DelegatingConnection<?> c, final CallableStatement s) {
-        super(c, s);
+    public DelegatingCallableStatement(final DelegatingConnection<?> connection, final CallableStatement statement) {
+        super(connection, statement);
     }
 
     @Override
-    public void registerOutParameter(final int parameterIndex, final int sqlType) throws SQLException {
+    public Array getArray(final int parameterIndex) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().registerOutParameter(parameterIndex, sqlType);
+            return getDelegateCallableStatement().getArray(parameterIndex);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void registerOutParameter(final int parameterIndex, final int sqlType, final int scale) throws SQLException {
+    public Array getArray(final String parameterName) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().registerOutParameter(parameterIndex, sqlType, scale);
+            return getDelegateCallableStatement().getArray(parameterName);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public boolean wasNull() throws SQLException {
+    public BigDecimal getBigDecimal(final int parameterIndex) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().wasNull();
+            return getDelegateCallableStatement().getBigDecimal(parameterIndex);
         } catch (final SQLException e) {
             handleException(e);
-            return false;
+            return null;
         }
     }
 
+    /** @deprecated Use {@link #getBigDecimal(int)} or {@link #getBigDecimal(String)} */
     @Override
-    public String getString(final int parameterIndex) throws SQLException {
+    @Deprecated
+    public BigDecimal getBigDecimal(final int parameterIndex, final int scale) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getString(parameterIndex);
+            return getDelegateCallableStatement().getBigDecimal(parameterIndex, scale);
         } catch (final SQLException e) {
             handleException(e);
             return null;
@@ -107,65 +112,65 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement imp
     }
 
     @Override
-    public boolean getBoolean(final int parameterIndex) throws SQLException {
+    public BigDecimal getBigDecimal(final String parameterName) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getBoolean(parameterIndex);
+            return getDelegateCallableStatement().getBigDecimal(parameterName);
         } catch (final SQLException e) {
             handleException(e);
-            return false;
+            return null;
         }
     }
 
     @Override
-    public byte getByte(final int parameterIndex) throws SQLException {
+    public Blob getBlob(final int parameterIndex) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getByte(parameterIndex);
+            return getDelegateCallableStatement().getBlob(parameterIndex);
         } catch (final SQLException e) {
             handleException(e);
-            return 0;
+            return null;
         }
     }
 
     @Override
-    public short getShort(final int parameterIndex) throws SQLException {
+    public Blob getBlob(final String parameterName) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getShort(parameterIndex);
+            return getDelegateCallableStatement().getBlob(parameterName);
         } catch (final SQLException e) {
             handleException(e);
-            return 0;
+            return null;
         }
     }
 
     @Override
-    public int getInt(final int parameterIndex) throws SQLException {
+    public boolean getBoolean(final int parameterIndex) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getInt(parameterIndex);
+            return getDelegateCallableStatement().getBoolean(parameterIndex);
         } catch (final SQLException e) {
             handleException(e);
-            return 0;
+            return false;
         }
     }
 
     @Override
-    public long getLong(final int parameterIndex) throws SQLException {
+    public boolean getBoolean(final String parameterName) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getLong(parameterIndex);
+            return getDelegateCallableStatement().getBoolean(parameterName);
         } catch (final SQLException e) {
             handleException(e);
-            return 0;
+            return false;
         }
     }
 
     @Override
-    public float getFloat(final int parameterIndex) throws SQLException {
+    public byte getByte(final int parameterIndex) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getFloat(parameterIndex);
+            return getDelegateCallableStatement().getByte(parameterIndex);
         } catch (final SQLException e) {
             handleException(e);
             return 0;
@@ -173,23 +178,21 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement imp
     }
 
     @Override
-    public double getDouble(final int parameterIndex) throws SQLException {
+    public byte getByte(final String parameterName) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getDouble(parameterIndex);
+            return getDelegateCallableStatement().getByte(parameterName);
         } catch (final SQLException e) {
             handleException(e);
             return 0;
         }
     }
 
-    /** @deprecated Use {@link #getBigDecimal(int)} or {@link #getBigDecimal(String)} */
     @Override
-    @Deprecated
-    public BigDecimal getBigDecimal(final int parameterIndex, final int scale) throws SQLException {
+    public byte[] getBytes(final int parameterIndex) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getBigDecimal(parameterIndex, scale);
+            return getDelegateCallableStatement().getBytes(parameterIndex);
         } catch (final SQLException e) {
             handleException(e);
             return null;
@@ -197,10 +200,10 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement imp
     }
 
     @Override
-    public byte[] getBytes(final int parameterIndex) throws SQLException {
+    public byte[] getBytes(final String parameterName) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getBytes(parameterIndex);
+            return getDelegateCallableStatement().getBytes(parameterName);
         } catch (final SQLException e) {
             handleException(e);
             return null;
@@ -208,10 +211,10 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement imp
     }
 
     @Override
-    public Date getDate(final int parameterIndex) throws SQLException {
+    public Reader getCharacterStream(final int parameterIndex) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getDate(parameterIndex);
+            return getDelegateCallableStatement().getCharacterStream(parameterIndex);
         } catch (final SQLException e) {
             handleException(e);
             return null;
@@ -219,10 +222,10 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement imp
     }
 
     @Override
-    public Time getTime(final int parameterIndex) throws SQLException {
+    public Reader getCharacterStream(final String parameterName) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getTime(parameterIndex);
+            return getDelegateCallableStatement().getCharacterStream(parameterName);
         } catch (final SQLException e) {
             handleException(e);
             return null;
@@ -230,10 +233,10 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement imp
     }
 
     @Override
-    public Timestamp getTimestamp(final int parameterIndex) throws SQLException {
+    public Clob getClob(final int parameterIndex) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getTimestamp(parameterIndex);
+            return getDelegateCallableStatement().getClob(parameterIndex);
         } catch (final SQLException e) {
             handleException(e);
             return null;
@@ -241,10 +244,10 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement imp
     }
 
     @Override
-    public Object getObject(final int parameterIndex) throws SQLException {
+    public Clob getClob(final String parameterName) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getObject(parameterIndex);
+            return getDelegateCallableStatement().getClob(parameterName);
         } catch (final SQLException e) {
             handleException(e);
             return null;
@@ -252,10 +255,10 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement imp
     }
 
     @Override
-    public BigDecimal getBigDecimal(final int parameterIndex) throws SQLException {
+    public Date getDate(final int parameterIndex) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getBigDecimal(parameterIndex);
+            return getDelegateCallableStatement().getDate(parameterIndex);
         } catch (final SQLException e) {
             handleException(e);
             return null;
@@ -263,10 +266,10 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement imp
     }
 
     @Override
-    public Object getObject(final int i, final Map<String, Class<?>> map) throws SQLException {
+    public Date getDate(final int parameterIndex, final Calendar cal) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getObject(i, map);
+            return getDelegateCallableStatement().getDate(parameterIndex, cal);
         } catch (final SQLException e) {
             handleException(e);
             return null;
@@ -274,10 +277,10 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement imp
     }
 
     @Override
-    public Ref getRef(final int i) throws SQLException {
+    public Date getDate(final String parameterName) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getRef(i);
+            return getDelegateCallableStatement().getDate(parameterName);
         } catch (final SQLException e) {
             handleException(e);
             return null;
@@ -285,119 +288,124 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement imp
     }
 
     @Override
-    public Blob getBlob(final int i) throws SQLException {
+    public Date getDate(final String parameterName, final Calendar cal) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getBlob(i);
+            return getDelegateCallableStatement().getDate(parameterName, cal);
         } catch (final SQLException e) {
             handleException(e);
             return null;
         }
     }
 
+    private CallableStatement getDelegateCallableStatement() {
+        return (CallableStatement) getDelegate();
+    }
+
     @Override
-    public Clob getClob(final int i) throws SQLException {
+    public double getDouble(final int parameterIndex) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getClob(i);
+            return getDelegateCallableStatement().getDouble(parameterIndex);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
+            return 0;
         }
     }
 
     @Override
-    public Array getArray(final int i) throws SQLException {
+    public double getDouble(final String parameterName) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getArray(i);
+            return getDelegateCallableStatement().getDouble(parameterName);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
+            return 0;
         }
     }
 
     @Override
-    public Date getDate(final int parameterIndex, final Calendar cal) throws SQLException {
+    public float getFloat(final int parameterIndex) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getDate(parameterIndex, cal);
+            return getDelegateCallableStatement().getFloat(parameterIndex);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
+            return 0;
         }
     }
 
     @Override
-    public Time getTime(final int parameterIndex, final Calendar cal) throws SQLException {
+    public float getFloat(final String parameterName) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getTime(parameterIndex, cal);
+            return getDelegateCallableStatement().getFloat(parameterName);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
+            return 0;
         }
     }
 
     @Override
-    public Timestamp getTimestamp(final int parameterIndex, final Calendar cal) throws SQLException {
+    public int getInt(final int parameterIndex) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getTimestamp(parameterIndex, cal);
+            return getDelegateCallableStatement().getInt(parameterIndex);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
+            return 0;
         }
     }
 
     @Override
-    public void registerOutParameter(final int paramIndex, final int sqlType, final String typeName)
-            throws SQLException {
+    public int getInt(final String parameterName) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().registerOutParameter(paramIndex, sqlType, typeName);
+            return getDelegateCallableStatement().getInt(parameterName);
         } catch (final SQLException e) {
             handleException(e);
+            return 0;
         }
     }
 
     @Override
-    public void registerOutParameter(final String parameterName, final int sqlType) throws SQLException {
+    public long getLong(final int parameterIndex) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().registerOutParameter(parameterName, sqlType);
+            return getDelegateCallableStatement().getLong(parameterIndex);
         } catch (final SQLException e) {
             handleException(e);
+            return 0;
         }
     }
 
     @Override
-    public void registerOutParameter(final String parameterName, final int sqlType, final int scale)
-            throws SQLException {
+    public long getLong(final String parameterName) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().registerOutParameter(parameterName, sqlType, scale);
+            return getDelegateCallableStatement().getLong(parameterName);
         } catch (final SQLException e) {
             handleException(e);
+            return 0;
         }
     }
 
     @Override
-    public void registerOutParameter(final String parameterName, final int sqlType, final String typeName)
-            throws SQLException {
+    public Reader getNCharacterStream(final int parameterIndex) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().registerOutParameter(parameterName, sqlType, typeName);
+            return getDelegateCallableStatement().getNCharacterStream(parameterIndex);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public URL getURL(final int parameterIndex) throws SQLException {
+    public Reader getNCharacterStream(final String parameterName) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getURL(parameterIndex);
+            return getDelegateCallableStatement().getNCharacterStream(parameterName);
         } catch (final SQLException e) {
             handleException(e);
             return null;
@@ -405,258 +413,285 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement imp
     }
 
     @Override
-    public void setURL(final String parameterName, final URL val) throws SQLException {
+    public NClob getNClob(final int parameterIndex) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setURL(parameterName, val);
+            return getDelegateCallableStatement().getNClob(parameterIndex);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void setNull(final String parameterName, final int sqlType) throws SQLException {
+    public NClob getNClob(final String parameterName) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setNull(parameterName, sqlType);
+            return getDelegateCallableStatement().getNClob(parameterName);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void setBoolean(final String parameterName, final boolean x) throws SQLException {
+    public String getNString(final int parameterIndex) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setBoolean(parameterName, x);
+            return getDelegateCallableStatement().getNString(parameterIndex);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void setByte(final String parameterName, final byte x) throws SQLException {
+    public String getNString(final String parameterName) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setByte(parameterName, x);
+            return getDelegateCallableStatement().getNString(parameterName);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void setShort(final String parameterName, final short x) throws SQLException {
+    public Object getObject(final int parameterIndex) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setShort(parameterName, x);
+            return getDelegateCallableStatement().getObject(parameterIndex);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void setInt(final String parameterName, final int x) throws SQLException {
+    public <T> T getObject(final int parameterIndex, final Class<T> type) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setInt(parameterName, x);
+            return getDelegateCallableStatement().getObject(parameterIndex, type);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void setLong(final String parameterName, final long x) throws SQLException {
+    public Object getObject(final int i, final Map<String, Class<?>> map) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setLong(parameterName, x);
+            return getDelegateCallableStatement().getObject(i, map);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void setFloat(final String parameterName, final float x) throws SQLException {
+    public Object getObject(final String parameterName) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setFloat(parameterName, x);
+            return getDelegateCallableStatement().getObject(parameterName);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void setDouble(final String parameterName, final double x) throws SQLException {
+    public <T> T getObject(final String parameterName, final Class<T> type) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setDouble(parameterName, x);
+            return getDelegateCallableStatement().getObject(parameterName, type);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void setBigDecimal(final String parameterName, final BigDecimal x) throws SQLException {
+    public Object getObject(final String parameterName, final Map<String, Class<?>> map) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setBigDecimal(parameterName, x);
+            return getDelegateCallableStatement().getObject(parameterName, map);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void setString(final String parameterName, final String x) throws SQLException {
+    public Ref getRef(final int parameterIndex) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setString(parameterName, x);
+            return getDelegateCallableStatement().getRef(parameterIndex);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void setBytes(final String parameterName, final byte[] x) throws SQLException {
+    public Ref getRef(final String parameterName) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setBytes(parameterName, x);
+            return getDelegateCallableStatement().getRef(parameterName);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void setDate(final String parameterName, final Date x) throws SQLException {
+    public RowId getRowId(final int parameterIndex) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setDate(parameterName, x);
+            return getDelegateCallableStatement().getRowId(parameterIndex);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void setTime(final String parameterName, final Time x) throws SQLException {
+    public RowId getRowId(final String parameterName) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setTime(parameterName, x);
+            return getDelegateCallableStatement().getRowId(parameterName);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void setTimestamp(final String parameterName, final Timestamp x) throws SQLException {
+    public short getShort(final int parameterIndex) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setTimestamp(parameterName, x);
+            return getDelegateCallableStatement().getShort(parameterIndex);
         } catch (final SQLException e) {
             handleException(e);
+            return 0;
         }
     }
 
     @Override
-    public void setAsciiStream(final String parameterName, final InputStream x, final int length) throws SQLException {
+    public short getShort(final String parameterName) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setAsciiStream(parameterName, x, length);
+            return getDelegateCallableStatement().getShort(parameterName);
         } catch (final SQLException e) {
             handleException(e);
+            return 0;
         }
     }
 
     @Override
-    public void setBinaryStream(final String parameterName, final InputStream x, final int length) throws SQLException {
+    public SQLXML getSQLXML(final int parameterIndex) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setBinaryStream(parameterName, x, length);
+            return getDelegateCallableStatement().getSQLXML(parameterIndex);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void setObject(final String parameterName, final Object x, final int targetSqlType, final int scale)
-            throws SQLException {
+    public SQLXML getSQLXML(final String parameterName) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setObject(parameterName, x, targetSqlType, scale);
+            return getDelegateCallableStatement().getSQLXML(parameterName);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void setObject(final String parameterName, final Object x, final int targetSqlType) throws SQLException {
+    public String getString(final int parameterIndex) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setObject(parameterName, x, targetSqlType);
+            return getDelegateCallableStatement().getString(parameterIndex);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void setObject(final String parameterName, final Object x) throws SQLException {
+    public String getString(final String parameterName) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setObject(parameterName, x);
+            return getDelegateCallableStatement().getString(parameterName);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void setCharacterStream(final String parameterName, final Reader reader, final int length)
-            throws SQLException {
+    public Time getTime(final int parameterIndex) throws SQLException {
         checkOpen();
-        getDelegateCallableStatement().setCharacterStream(parameterName, reader, length);
-    }
-
-    @Override
-    public void setDate(final String parameterName, final Date x, final Calendar cal) throws SQLException {
+        try {
+            return getDelegateCallableStatement().getTime(parameterIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public Time getTime(final int parameterIndex, final Calendar cal) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setDate(parameterName, x, cal);
+            return getDelegateCallableStatement().getTime(parameterIndex, cal);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void setTime(final String parameterName, final Time x, final Calendar cal) throws SQLException {
+    public Time getTime(final String parameterName) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setTime(parameterName, x, cal);
+            return getDelegateCallableStatement().getTime(parameterName);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void setTimestamp(final String parameterName, final Timestamp x, final Calendar cal) throws SQLException {
+    public Time getTime(final String parameterName, final Calendar cal) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setTimestamp(parameterName, x, cal);
+            return getDelegateCallableStatement().getTime(parameterName, cal);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void setNull(final String parameterName, final int sqlType, final String typeName) throws SQLException {
+    public Timestamp getTimestamp(final int parameterIndex) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setNull(parameterName, sqlType, typeName);
+            return getDelegateCallableStatement().getTimestamp(parameterIndex);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public String getString(final String parameterName) throws SQLException {
+    public Timestamp getTimestamp(final int parameterIndex, final Calendar cal) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getString(parameterName);
+            return getDelegateCallableStatement().getTimestamp(parameterIndex, cal);
         } catch (final SQLException e) {
             handleException(e);
             return null;
@@ -664,309 +699,370 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement imp
     }
 
     @Override
-    public boolean getBoolean(final String parameterName) throws SQLException {
+    public Timestamp getTimestamp(final String parameterName) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getBoolean(parameterName);
+            return getDelegateCallableStatement().getTimestamp(parameterName);
         } catch (final SQLException e) {
             handleException(e);
-            return false;
+            return null;
         }
     }
 
     @Override
-    public byte getByte(final String parameterName) throws SQLException {
+    public Timestamp getTimestamp(final String parameterName, final Calendar cal) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getByte(parameterName);
+            return getDelegateCallableStatement().getTimestamp(parameterName, cal);
         } catch (final SQLException e) {
             handleException(e);
-            return 0;
+            return null;
         }
     }
 
     @Override
-    public short getShort(final String parameterName) throws SQLException {
+    public URL getURL(final int parameterIndex) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getShort(parameterName);
+            return getDelegateCallableStatement().getURL(parameterIndex);
         } catch (final SQLException e) {
             handleException(e);
-            return 0;
+            return null;
         }
     }
 
     @Override
-    public int getInt(final String parameterName) throws SQLException {
+    public URL getURL(final String parameterName) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getInt(parameterName);
+            return getDelegateCallableStatement().getURL(parameterName);
         } catch (final SQLException e) {
             handleException(e);
-            return 0;
+            return null;
         }
     }
 
     @Override
-    public long getLong(final String parameterName) throws SQLException {
+    public void registerOutParameter(final int parameterIndex, final int sqlType) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getLong(parameterName);
+            getDelegateCallableStatement().registerOutParameter(parameterIndex, sqlType);
         } catch (final SQLException e) {
             handleException(e);
-            return 0;
         }
     }
 
     @Override
-    public float getFloat(final String parameterName) throws SQLException {
+    public void registerOutParameter(final int parameterIndex, final int sqlType, final int scale) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getFloat(parameterName);
+            getDelegateCallableStatement().registerOutParameter(parameterIndex, sqlType, scale);
         } catch (final SQLException e) {
             handleException(e);
-            return 0;
         }
     }
 
     @Override
-    public double getDouble(final String parameterName) throws SQLException {
+    public void registerOutParameter(final int paramIndex, final int sqlType, final String typeName)
+            throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getDouble(parameterName);
+            getDelegateCallableStatement().registerOutParameter(paramIndex, sqlType, typeName);
         } catch (final SQLException e) {
             handleException(e);
-            return 0;
         }
     }
 
+    /**
+     * @since 2.5.0
+     */
     @Override
-    public byte[] getBytes(final String parameterName) throws SQLException {
+    public void registerOutParameter(final int parameterIndex, final SQLType sqlType) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getBytes(parameterName);
+            getDelegateCallableStatement().registerOutParameter(parameterIndex, sqlType);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
+    /**
+     * @since 2.5.0
+     */
     @Override
-    public Date getDate(final String parameterName) throws SQLException {
+    public void registerOutParameter(final int parameterIndex, final SQLType sqlType, final int scale)
+            throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getDate(parameterName);
+            getDelegateCallableStatement().registerOutParameter(parameterIndex, sqlType, scale);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
+    /**
+     * @since 2.5.0
+     */
     @Override
-    public Time getTime(final String parameterName) throws SQLException {
+    public void registerOutParameter(final int parameterIndex, final SQLType sqlType, final String typeName)
+            throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getTime(parameterName);
+            getDelegateCallableStatement().registerOutParameter(parameterIndex, sqlType, typeName);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public Timestamp getTimestamp(final String parameterName) throws SQLException {
+    public void registerOutParameter(final String parameterName, final int sqlType) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getTimestamp(parameterName);
+            getDelegateCallableStatement().registerOutParameter(parameterName, sqlType);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public Object getObject(final String parameterName) throws SQLException {
+    public void registerOutParameter(final String parameterName, final int sqlType, final int scale)
+            throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getObject(parameterName);
+            getDelegateCallableStatement().registerOutParameter(parameterName, sqlType, scale);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public BigDecimal getBigDecimal(final String parameterName) throws SQLException {
+    public void registerOutParameter(final String parameterName, final int sqlType, final String typeName)
+            throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getBigDecimal(parameterName);
+            getDelegateCallableStatement().registerOutParameter(parameterName, sqlType, typeName);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
+    /**
+     * @since 2.5.0
+     */
     @Override
-    public Object getObject(final String parameterName, final Map<String, Class<?>> map) throws SQLException {
+    public void registerOutParameter(final String parameterName, final SQLType sqlType) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getObject(parameterName, map);
+            getDelegateCallableStatement().registerOutParameter(parameterName, sqlType);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
+    /**
+     * @since 2.5.0
+     */
     @Override
-    public Ref getRef(final String parameterName) throws SQLException {
+    public void registerOutParameter(final String parameterName, final SQLType sqlType, final int scale)
+            throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getRef(parameterName);
+            getDelegateCallableStatement().registerOutParameter(parameterName, sqlType, scale);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
+    /**
+     * @since 2.5.0
+     */
     @Override
-    public Blob getBlob(final String parameterName) throws SQLException {
+    public void registerOutParameter(final String parameterName, final SQLType sqlType, final String typeName)
+            throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getBlob(parameterName);
+            getDelegateCallableStatement().registerOutParameter(parameterName, sqlType, typeName);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public Clob getClob(final String parameterName) throws SQLException {
+    public void setAsciiStream(final String parameterName, final InputStream inputStream) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getClob(parameterName);
+            getDelegateCallableStatement().setAsciiStream(parameterName, inputStream);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public Array getArray(final String parameterName) throws SQLException {
+    public void setAsciiStream(final String parameterName, final InputStream x, final int length) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getArray(parameterName);
+            getDelegateCallableStatement().setAsciiStream(parameterName, x, length);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public Date getDate(final String parameterName, final Calendar cal) throws SQLException {
+    public void setAsciiStream(final String parameterName, final InputStream inputStream, final long length)
+            throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getDate(parameterName, cal);
+            getDelegateCallableStatement().setAsciiStream(parameterName, inputStream, length);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
-    private CallableStatement getDelegateCallableStatement() {
-        return (CallableStatement) getDelegate();
+    @Override
+    public void setBigDecimal(final String parameterName, final BigDecimal x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().setBigDecimal(parameterName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
     }
 
     @Override
-    public Time getTime(final String parameterName, final Calendar cal) throws SQLException {
+    public void setBinaryStream(final String parameterName, final InputStream inputStream) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getTime(parameterName, cal);
+            getDelegateCallableStatement().setBinaryStream(parameterName, inputStream);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public Timestamp getTimestamp(final String parameterName, final Calendar cal) throws SQLException {
+    public void setBinaryStream(final String parameterName, final InputStream x, final int length) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getTimestamp(parameterName, cal);
+            getDelegateCallableStatement().setBinaryStream(parameterName, x, length);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public URL getURL(final String parameterName) throws SQLException {
+    public void setBinaryStream(final String parameterName, final InputStream inputStream, final long length)
+            throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getURL(parameterName);
+            getDelegateCallableStatement().setBinaryStream(parameterName, inputStream, length);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public RowId getRowId(final int parameterIndex) throws SQLException {
+    public void setBlob(final String parameterName, final Blob blob) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getRowId(parameterIndex);
+            getDelegateCallableStatement().setBlob(parameterName, blob);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public RowId getRowId(final String parameterName) throws SQLException {
+    public void setBlob(final String parameterName, final InputStream inputStream) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getRowId(parameterName);
+            getDelegateCallableStatement().setBlob(parameterName, inputStream);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public void setRowId(final String parameterName, final RowId value) throws SQLException {
+    public void setBlob(final String parameterName, final InputStream inputStream, final long length)
+            throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setRowId(parameterName, value);
+            getDelegateCallableStatement().setBlob(parameterName, inputStream, length);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setNString(final String parameterName, final String value) throws SQLException {
+    public void setBoolean(final String parameterName, final boolean x) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setNString(parameterName, value);
+            getDelegateCallableStatement().setBoolean(parameterName, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setNCharacterStream(final String parameterName, final Reader reader, final long length)
+    public void setByte(final String parameterName, final byte x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().setByte(parameterName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setBytes(final String parameterName, final byte[] x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().setBytes(parameterName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setCharacterStream(final String parameterName, final Reader reader) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().setCharacterStream(parameterName, reader);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setCharacterStream(final String parameterName, final Reader reader, final int length)
+            throws SQLException {
+        checkOpen();
+        getDelegateCallableStatement().setCharacterStream(parameterName, reader, length);
+    }
+
+    @Override
+    public void setCharacterStream(final String parameterName, final Reader reader, final long length)
             throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setNCharacterStream(parameterName, reader, length);
+            getDelegateCallableStatement().setCharacterStream(parameterName, reader, length);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setNClob(final String parameterName, final NClob value) throws SQLException {
+    public void setClob(final String parameterName, final Clob clob) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setNClob(parameterName, value);
+            getDelegateCallableStatement().setClob(parameterName, clob);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setClob(final String parameterName, final Reader reader) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().setClob(parameterName, reader);
         } catch (final SQLException e) {
             handleException(e);
         }
@@ -983,288 +1079,302 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement imp
     }
 
     @Override
-    public void setBlob(final String parameterName, final InputStream inputStream, final long length)
-            throws SQLException {
+    public void setDate(final String parameterName, final Date x) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setBlob(parameterName, inputStream, length);
+            getDelegateCallableStatement().setDate(parameterName, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setNClob(final String parameterName, final Reader reader, final long length) throws SQLException {
+    public void setDate(final String parameterName, final Date x, final Calendar cal) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setNClob(parameterName, reader, length);
+            getDelegateCallableStatement().setDate(parameterName, x, cal);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public NClob getNClob(final int parameterIndex) throws SQLException {
+    public void setDouble(final String parameterName, final double x) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getNClob(parameterIndex);
+            getDelegateCallableStatement().setDouble(parameterName, x);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public NClob getNClob(final String parameterName) throws SQLException {
+    public void setFloat(final String parameterName, final float x) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getNClob(parameterName);
+            getDelegateCallableStatement().setFloat(parameterName, x);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public void setSQLXML(final String parameterName, final SQLXML value) throws SQLException {
+    public void setInt(final String parameterName, final int x) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setSQLXML(parameterName, value);
+            getDelegateCallableStatement().setInt(parameterName, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public SQLXML getSQLXML(final int parameterIndex) throws SQLException {
+    public void setLong(final String parameterName, final long x) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getSQLXML(parameterIndex);
+            getDelegateCallableStatement().setLong(parameterName, x);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public SQLXML getSQLXML(final String parameterName) throws SQLException {
+    public void setNCharacterStream(final String parameterName, final Reader reader) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getSQLXML(parameterName);
+            getDelegateCallableStatement().setNCharacterStream(parameterName, reader);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public String getNString(final int parameterIndex) throws SQLException {
+    public void setNCharacterStream(final String parameterName, final Reader reader, final long length)
+            throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getNString(parameterIndex);
+            getDelegateCallableStatement().setNCharacterStream(parameterName, reader, length);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public String getNString(final String parameterName) throws SQLException {
+    public void setNClob(final String parameterName, final NClob value) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getNString(parameterName);
+            getDelegateCallableStatement().setNClob(parameterName, value);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public Reader getNCharacterStream(final int parameterIndex) throws SQLException {
+    public void setNClob(final String parameterName, final Reader reader) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getNCharacterStream(parameterIndex);
+            getDelegateCallableStatement().setNClob(parameterName, reader);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public Reader getNCharacterStream(final String parameterName) throws SQLException {
+    public void setNClob(final String parameterName, final Reader reader, final long length) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getNCharacterStream(parameterName);
+            getDelegateCallableStatement().setNClob(parameterName, reader, length);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public Reader getCharacterStream(final int parameterIndex) throws SQLException {
+    public void setNString(final String parameterName, final String value) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getCharacterStream(parameterIndex);
+            getDelegateCallableStatement().setNString(parameterName, value);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public Reader getCharacterStream(final String parameterName) throws SQLException {
+    public void setNull(final String parameterName, final int sqlType) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getCharacterStream(parameterName);
+            getDelegateCallableStatement().setNull(parameterName, sqlType);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public void setBlob(final String parameterName, final Blob blob) throws SQLException {
+    public void setNull(final String parameterName, final int sqlType, final String typeName) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setBlob(parameterName, blob);
+            getDelegateCallableStatement().setNull(parameterName, sqlType, typeName);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setClob(final String parameterName, final Clob clob) throws SQLException {
+    public void setObject(final String parameterName, final Object x) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setClob(parameterName, clob);
+            getDelegateCallableStatement().setObject(parameterName, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setAsciiStream(final String parameterName, final InputStream inputStream, final long length)
-            throws SQLException {
+    public void setObject(final String parameterName, final Object x, final int targetSqlType) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setAsciiStream(parameterName, inputStream, length);
+            getDelegateCallableStatement().setObject(parameterName, x, targetSqlType);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setBinaryStream(final String parameterName, final InputStream inputStream, final long length)
+    public void setObject(final String parameterName, final Object x, final int targetSqlType, final int scale)
             throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setBinaryStream(parameterName, inputStream, length);
+            getDelegateCallableStatement().setObject(parameterName, x, targetSqlType, scale);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
+    /**
+     * @since 2.5.0
+     */
     @Override
-    public void setCharacterStream(final String parameterName, final Reader reader, final long length)
-            throws SQLException {
+    public void setObject(final String parameterName, final Object x, final SQLType targetSqlType) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setCharacterStream(parameterName, reader, length);
+            getDelegateCallableStatement().setObject(parameterName, x, targetSqlType);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
+    /**
+     * @since 2.5.0
+     */
     @Override
-    public void setAsciiStream(final String parameterName, final InputStream inputStream) throws SQLException {
+    public void setObject(final String parameterName, final Object x, final SQLType targetSqlType,
+            final int scaleOrLength) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setAsciiStream(parameterName, inputStream);
+            getDelegateCallableStatement().setObject(parameterName, x, targetSqlType, scaleOrLength);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setBinaryStream(final String parameterName, final InputStream inputStream) throws SQLException {
+    public void setRowId(final String parameterName, final RowId value) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setBinaryStream(parameterName, inputStream);
+            getDelegateCallableStatement().setRowId(parameterName, value);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setCharacterStream(final String parameterName, final Reader reader) throws SQLException {
+    public void setShort(final String parameterName, final short x) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setCharacterStream(parameterName, reader);
+            getDelegateCallableStatement().setShort(parameterName, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setNCharacterStream(final String parameterName, final Reader reader) throws SQLException {
+    public void setSQLXML(final String parameterName, final SQLXML value) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setNCharacterStream(parameterName, reader);
+            getDelegateCallableStatement().setSQLXML(parameterName, value);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setClob(final String parameterName, final Reader reader) throws SQLException {
+    public void setString(final String parameterName, final String x) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setClob(parameterName, reader);
+            getDelegateCallableStatement().setString(parameterName, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setBlob(final String parameterName, final InputStream inputStream) throws SQLException {
+    public void setTime(final String parameterName, final Time x) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setBlob(parameterName, inputStream);
+            getDelegateCallableStatement().setTime(parameterName, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setNClob(final String parameterName, final Reader reader) throws SQLException {
+    public void setTime(final String parameterName, final Time x, final Calendar cal) throws SQLException {
         checkOpen();
         try {
-            getDelegateCallableStatement().setNClob(parameterName, reader);
+            getDelegateCallableStatement().setTime(parameterName, x, cal);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public <T> T getObject(final int parameterIndex, final Class<T> type) throws SQLException {
+    public void setTimestamp(final String parameterName, final Timestamp x) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getObject(parameterIndex, type);
+            getDelegateCallableStatement().setTimestamp(parameterName, x);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public <T> T getObject(final String parameterName, final Class<T> type) throws SQLException {
+    public void setTimestamp(final String parameterName, final Timestamp x, final Calendar cal) throws SQLException {
         checkOpen();
         try {
-            return getDelegateCallableStatement().getObject(parameterName, type);
+            getDelegateCallableStatement().setTimestamp(parameterName, x, cal);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
+        }
+    }
+
+    @Override
+    public void setURL(final String parameterName, final URL val) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().setURL(parameterName, val);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public boolean wasNull() throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().wasNull();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
         }
     }
 

==================================================
DelegatingDatabaseMetaData.java
index 735d267b5c..3be956cc28 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/DelegatingConnection.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/DelegatingConnection.java
@@ -224,8 +224,20 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace i
             passivate();
         } finally {
             if (connection != null) {
+                boolean connectionIsClosed;
                 try {
-                    connection.close();
+                    connectionIsClosed = connection.isClosed();
+                } catch (final SQLException e) {
+                    // not sure what the state is, so assume the connection is open.
+                    connectionIsClosed = false;
+                }
+                try {
+                    // DBCP-512: Avoid exceptions when closing a connection in mutli-threaded use case.
+                    // Avoid closing again, which should be a no-op, but some drivers like H2 throw an exception when
+                    // closing from multiple threads.
+                    if (!connectionIsClosed) {
+                        connection.close();
+                    }
                 } finally {
                     closed = true;
                 }

==================================================
DelegatingPreparedStatement.java
index d58711d6a0..ea616a3295 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/DelegatingDatabaseMetaData.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/DelegatingDatabaseMetaData.java
@@ -56,48 +56,6 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
         this.databaseMetaData = databaseMetaData;
     }
 
-    /**
-     * Gets the underlying database meta data.
-     *
-     * @return The underlying database meta data.
-     */
-    public DatabaseMetaData getDelegate() {
-        return databaseMetaData;
-    }
-
-    /**
-     * If my underlying {@link ResultSet} is not a {@code DelegatingResultSet}, returns it, otherwise recursively
-     * invokes this method on my delegate.
-     * <p>
-     * Hence this method will return the first delegate that is not a {@code DelegatingResultSet}, or {@code null} when
-     * no non-{@code DelegatingResultSet} delegate can be found by traversing this chain.
-     * </p>
-     * <p>
-     * This method is useful when you may have nested {@code DelegatingResultSet}s, and you want to make sure to obtain
-     * a "genuine" {@link ResultSet}.
-     * </p>
-     *
-     * @return the innermost database meta data.
-     */
-    public DatabaseMetaData getInnermostDelegate() {
-        DatabaseMetaData m = databaseMetaData;
-        while (m != null && m instanceof DelegatingDatabaseMetaData) {
-            m = ((DelegatingDatabaseMetaData) m).getDelegate();
-            if (this == m) {
-                return null;
-            }
-        }
-        return m;
-    }
-
-    protected void handleException(final SQLException e) throws SQLException {
-        if (connection != null) {
-            connection.handleException(e);
-        } else {
-            throw e;
-        }
-    }
-
     @Override
     public boolean allProceduresAreCallable() throws SQLException {
         try {
@@ -118,6 +76,16 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
         }
     }
 
+    @Override
+    public boolean autoCommitFailureClosesAllResultSets() throws SQLException {
+        try {
+            return databaseMetaData.autoCommitFailureClosesAllResultSets();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
+
     @Override
     public boolean dataDefinitionCausesTransactionCommit() throws SQLException {
         try {
@@ -158,6 +126,17 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
         }
     }
 
+    @Override
+    public boolean generatedKeyAlwaysReturned() throws SQLException {
+        connection.checkOpen();
+        try {
+            return databaseMetaData.generatedKeyAlwaysReturned();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
+
     @Override
     public ResultSet getAttributes(final String catalog, final String schemaPattern, final String typeNamePattern,
             final String attributeNamePattern) throws SQLException {
@@ -184,6 +163,17 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
         }
     }
 
+    @Override
+    public ResultSet getCatalogs() throws SQLException {
+        connection.checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(connection, databaseMetaData.getCatalogs());
+        } catch (final SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
     @Override
     public String getCatalogSeparator() throws SQLException {
         try {
@@ -205,10 +195,10 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
     }
 
     @Override
-    public ResultSet getCatalogs() throws SQLException {
+    public ResultSet getClientInfoProperties() throws SQLException {
         connection.checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(connection, databaseMetaData.getCatalogs());
+            return DelegatingResultSet.wrapResultSet(connection, databaseMetaData.getClientInfoProperties());
         } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
@@ -309,6 +299,15 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
         }
     }
 
+    /**
+     * Gets the underlying database meta data.
+     *
+     * @return The underlying database meta data.
+     */
+    public DatabaseMetaData getDelegate() {
+        return databaseMetaData;
+    }
+
     @Override
     public int getDriverMajorVersion() {
         return databaseMetaData.getDriverMajorVersion();
@@ -362,6 +361,32 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
         }
     }
 
+    @Override
+    public ResultSet getFunctionColumns(final String catalog, final String schemaPattern,
+            final String functionNamePattern, final String columnNamePattern) throws SQLException {
+        connection.checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(connection, databaseMetaData.getFunctionColumns(catalog,
+                    schemaPattern, functionNamePattern, columnNamePattern));
+        } catch (final SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public ResultSet getFunctions(final String catalog, final String schemaPattern, final String functionNamePattern)
+            throws SQLException {
+        connection.checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(connection,
+                    databaseMetaData.getFunctions(catalog, schemaPattern, functionNamePattern));
+        } catch (final SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
     @Override
     public String getIdentifierQuoteString() throws SQLException {
         try {
@@ -398,6 +423,31 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
         }
     }
 
+    /**
+     * If my underlying {@link ResultSet} is not a {@code DelegatingResultSet}, returns it, otherwise recursively
+     * invokes this method on my delegate.
+     * <p>
+     * Hence this method will return the first delegate that is not a {@code DelegatingResultSet}, or {@code null} when
+     * no non-{@code DelegatingResultSet} delegate can be found by traversing this chain.
+     * </p>
+     * <p>
+     * This method is useful when you may have nested {@code DelegatingResultSet}s, and you want to make sure to obtain
+     * a "genuine" {@link ResultSet}.
+     * </p>
+     *
+     * @return the innermost database meta data.
+     */
+    public DatabaseMetaData getInnermostDelegate() {
+        DatabaseMetaData m = databaseMetaData;
+        while (m != null && m instanceof DelegatingDatabaseMetaData) {
+            m = ((DelegatingDatabaseMetaData) m).getDelegate();
+            if (this == m) {
+                return null;
+            }
+        }
+        return m;
+    }
+
     @Override
     public int getJDBCMajorVersion() throws SQLException {
         try {
@@ -538,6 +588,19 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
         }
     }
 
+    /**
+     * @since 2.5.0
+     */
+    @Override
+    public long getMaxLogicalLobSize() throws SQLException {
+        try {
+            return databaseMetaData.getMaxLogicalLobSize();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
+
     @Override
     public int getMaxProcedureNameLength() throws SQLException {
         try {
@@ -653,6 +716,19 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
         }
     }
 
+    @Override
+    public ResultSet getProcedures(final String catalog, final String schemaPattern, final String procedureNamePattern)
+            throws SQLException {
+        connection.checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(connection,
+                    databaseMetaData.getProcedures(catalog, schemaPattern, procedureNamePattern));
+        } catch (final SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
     @Override
     public String getProcedureTerm() throws SQLException {
         try {
@@ -664,12 +740,12 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
     }
 
     @Override
-    public ResultSet getProcedures(final String catalog, final String schemaPattern, final String procedureNamePattern)
-            throws SQLException {
+    public ResultSet getPseudoColumns(final String catalog, final String schemaPattern, final String tableNamePattern,
+            final String columnNamePattern) throws SQLException {
         connection.checkOpen();
         try {
             return DelegatingResultSet.wrapResultSet(connection,
-                    databaseMetaData.getProcedures(catalog, schemaPattern, procedureNamePattern));
+                    databaseMetaData.getPseudoColumns(catalog, schemaPattern, tableNamePattern, columnNamePattern));
         } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
@@ -687,9 +763,9 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
     }
 
     @Override
-    public String getSQLKeywords() throws SQLException {
+    public RowIdLifetime getRowIdLifetime() throws SQLException {
         try {
-            return databaseMetaData.getSQLKeywords();
+            return databaseMetaData.getRowIdLifetime();
         } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
@@ -697,19 +773,21 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
     }
 
     @Override
-    public int getSQLStateType() throws SQLException {
+    public ResultSet getSchemas() throws SQLException {
+        connection.checkOpen();
         try {
-            return databaseMetaData.getSQLStateType();
+            return DelegatingResultSet.wrapResultSet(connection, databaseMetaData.getSchemas());
         } catch (final SQLException e) {
             handleException(e);
-            return 0;
+            throw new AssertionError();
         }
     }
 
     @Override
-    public String getSchemaTerm() throws SQLException {
+    public ResultSet getSchemas(final String catalog, final String schemaPattern) throws SQLException {
+        connection.checkOpen();
         try {
-            return databaseMetaData.getSchemaTerm();
+            return DelegatingResultSet.wrapResultSet(connection, databaseMetaData.getSchemas(catalog, schemaPattern));
         } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
@@ -717,10 +795,9 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
     }
 
     @Override
-    public ResultSet getSchemas() throws SQLException {
-        connection.checkOpen();
+    public String getSchemaTerm() throws SQLException {
         try {
-            return DelegatingResultSet.wrapResultSet(connection, databaseMetaData.getSchemas());
+            return databaseMetaData.getSchemaTerm();
         } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
@@ -737,6 +814,26 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
         }
     }
 
+    @Override
+    public String getSQLKeywords() throws SQLException {
+        try {
+            return databaseMetaData.getSQLKeywords();
+        } catch (final SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public int getSQLStateType() throws SQLException {
+        try {
+            return databaseMetaData.getSQLStateType();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
+
     @Override
     public String getStringFunctions() throws SQLException {
         try {
@@ -797,10 +894,12 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
     }
 
     @Override
-    public ResultSet getTableTypes() throws SQLException {
+    public ResultSet getTables(final String catalog, final String schemaPattern, final String tableNamePattern,
+            final String[] types) throws SQLException {
         connection.checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(connection, databaseMetaData.getTableTypes());
+            return DelegatingResultSet.wrapResultSet(connection,
+                    databaseMetaData.getTables(catalog, schemaPattern, tableNamePattern, types));
         } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
@@ -808,12 +907,10 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
     }
 
     @Override
-    public ResultSet getTables(final String catalog, final String schemaPattern, final String tableNamePattern,
-            final String[] types) throws SQLException {
+    public ResultSet getTableTypes() throws SQLException {
         connection.checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(connection,
-                    databaseMetaData.getTables(catalog, schemaPattern, tableNamePattern, types));
+            return DelegatingResultSet.wrapResultSet(connection, databaseMetaData.getTableTypes());
         } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
@@ -887,6 +984,14 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
         }
     }
 
+    protected void handleException(final SQLException e) throws SQLException {
+        if (connection != null) {
+            connection.handleException(e);
+        } else {
+            throw e;
+        }
+    }
+
     @Override
     public boolean insertsAreDetected(final int type) throws SQLException {
         try {
@@ -917,6 +1022,17 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
         }
     }
 
+    @Override
+    public boolean isWrapperFor(final Class<?> iface) throws SQLException {
+        if (iface.isAssignableFrom(getClass())) {
+            return true;
+        } else if (iface.isAssignableFrom(databaseMetaData.getClass())) {
+            return true;
+        } else {
+            return databaseMetaData.isWrapperFor(iface);
+        }
+    }
+
     @Override
     public boolean locatorsUpdateCopy() throws SQLException {
         try {
@@ -1098,9 +1214,9 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
     }
 
     @Override
-    public boolean supportsANSI92EntryLevelSQL() throws SQLException {
+    public boolean supportsAlterTableWithAddColumn() throws SQLException {
         try {
-            return databaseMetaData.supportsANSI92EntryLevelSQL();
+            return databaseMetaData.supportsAlterTableWithAddColumn();
         } catch (final SQLException e) {
             handleException(e);
             return false;
@@ -1108,9 +1224,9 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
     }
 
     @Override
-    public boolean supportsANSI92FullSQL() throws SQLException {
+    public boolean supportsAlterTableWithDropColumn() throws SQLException {
         try {
-            return databaseMetaData.supportsANSI92FullSQL();
+            return databaseMetaData.supportsAlterTableWithDropColumn();
         } catch (final SQLException e) {
             handleException(e);
             return false;
@@ -1118,9 +1234,9 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
     }
 
     @Override
-    public boolean supportsANSI92IntermediateSQL() throws SQLException {
+    public boolean supportsANSI92EntryLevelSQL() throws SQLException {
         try {
-            return databaseMetaData.supportsANSI92IntermediateSQL();
+            return databaseMetaData.supportsANSI92EntryLevelSQL();
         } catch (final SQLException e) {
             handleException(e);
             return false;
@@ -1128,9 +1244,9 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
     }
 
     @Override
-    public boolean supportsAlterTableWithAddColumn() throws SQLException {
+    public boolean supportsANSI92FullSQL() throws SQLException {
         try {
-            return databaseMetaData.supportsAlterTableWithAddColumn();
+            return databaseMetaData.supportsANSI92FullSQL();
         } catch (final SQLException e) {
             handleException(e);
             return false;
@@ -1138,9 +1254,9 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
     }
 
     @Override
-    public boolean supportsAlterTableWithDropColumn() throws SQLException {
+    public boolean supportsANSI92IntermediateSQL() throws SQLException {
         try {
-            return databaseMetaData.supportsAlterTableWithDropColumn();
+            return databaseMetaData.supportsANSI92IntermediateSQL();
         } catch (final SQLException e) {
             handleException(e);
             return false;
@@ -1547,6 +1663,19 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
         }
     }
 
+    /**
+     * @since 2.5.0
+     */
+    @Override
+    public boolean supportsRefCursors() throws SQLException {
+        try {
+            return databaseMetaData.supportsRefCursors();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
+
     @Override
     public boolean supportsResultSetConcurrency(final int type, final int concurrency) throws SQLException {
         try {
@@ -1657,6 +1786,16 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
         }
     }
 
+    @Override
+    public boolean supportsStoredFunctionsUsingCallSyntax() throws SQLException {
+        try {
+            return databaseMetaData.supportsStoredFunctionsUsingCallSyntax();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
+
     @Override
     public boolean supportsStoredProcedures() throws SQLException {
         try {
@@ -1667,6 +1806,8 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
         }
     }
 
+    /* JDBC_4_ANT_KEY_BEGIN */
+
     @Override
     public boolean supportsSubqueriesInComparisons() throws SQLException {
         try {
@@ -1757,48 +1898,7 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
         }
     }
 
-    @Override
-    public boolean updatesAreDetected(final int type) throws SQLException {
-        try {
-            return databaseMetaData.updatesAreDetected(type);
-        } catch (final SQLException e) {
-            handleException(e);
-            return false;
-        }
-    }
-
-    @Override
-    public boolean usesLocalFilePerTable() throws SQLException {
-        try {
-            return databaseMetaData.usesLocalFilePerTable();
-        } catch (final SQLException e) {
-            handleException(e);
-            return false;
-        }
-    }
-
-    @Override
-    public boolean usesLocalFiles() throws SQLException {
-        try {
-            return databaseMetaData.usesLocalFiles();
-        } catch (final SQLException e) {
-            handleException(e);
-            return false;
-        }
-    }
-
-    /* JDBC_4_ANT_KEY_BEGIN */
-
-    @Override
-    public boolean isWrapperFor(final Class<?> iface) throws SQLException {
-        if (iface.isAssignableFrom(getClass())) {
-            return true;
-        } else if (iface.isAssignableFrom(databaseMetaData.getClass())) {
-            return true;
-        } else {
-            return databaseMetaData.isWrapperFor(iface);
-        }
-    }
+    /* JDBC_4_ANT_KEY_END */
 
     @Override
     public <T> T unwrap(final Class<T> iface) throws SQLException {
@@ -1812,30 +1912,9 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
     }
 
     @Override
-    public RowIdLifetime getRowIdLifetime() throws SQLException {
-        try {
-            return databaseMetaData.getRowIdLifetime();
-        } catch (final SQLException e) {
-            handleException(e);
-            throw new AssertionError();
-        }
-    }
-
-    @Override
-    public ResultSet getSchemas(final String catalog, final String schemaPattern) throws SQLException {
-        connection.checkOpen();
-        try {
-            return DelegatingResultSet.wrapResultSet(connection, databaseMetaData.getSchemas(catalog, schemaPattern));
-        } catch (final SQLException e) {
-            handleException(e);
-            throw new AssertionError();
-        }
-    }
-
-    @Override
-    public boolean autoCommitFailureClosesAllResultSets() throws SQLException {
+    public boolean updatesAreDetected(final int type) throws SQLException {
         try {
-            return databaseMetaData.autoCommitFailureClosesAllResultSets();
+            return databaseMetaData.updatesAreDetected(type);
         } catch (final SQLException e) {
             handleException(e);
             return false;
@@ -1843,9 +1922,9 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
     }
 
     @Override
-    public boolean supportsStoredFunctionsUsingCallSyntax() throws SQLException {
+    public boolean usesLocalFilePerTable() throws SQLException {
         try {
-            return databaseMetaData.supportsStoredFunctionsUsingCallSyntax();
+            return databaseMetaData.usesLocalFilePerTable();
         } catch (final SQLException e) {
             handleException(e);
             return false;
@@ -1853,62 +1932,9 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
     }
 
     @Override
-    public ResultSet getClientInfoProperties() throws SQLException {
-        connection.checkOpen();
-        try {
-            return DelegatingResultSet.wrapResultSet(connection, databaseMetaData.getClientInfoProperties());
-        } catch (final SQLException e) {
-            handleException(e);
-            throw new AssertionError();
-        }
-    }
-
-    @Override
-    public ResultSet getFunctions(final String catalog, final String schemaPattern, final String functionNamePattern)
-            throws SQLException {
-        connection.checkOpen();
-        try {
-            return DelegatingResultSet.wrapResultSet(connection,
-                    databaseMetaData.getFunctions(catalog, schemaPattern, functionNamePattern));
-        } catch (final SQLException e) {
-            handleException(e);
-            throw new AssertionError();
-        }
-    }
-
-    @Override
-    public ResultSet getFunctionColumns(final String catalog, final String schemaPattern,
-            final String functionNamePattern, final String columnNamePattern) throws SQLException {
-        connection.checkOpen();
-        try {
-            return DelegatingResultSet.wrapResultSet(connection, databaseMetaData.getFunctionColumns(catalog,
-                    schemaPattern, functionNamePattern, columnNamePattern));
-        } catch (final SQLException e) {
-            handleException(e);
-            throw new AssertionError();
-        }
-    }
-
-    /* JDBC_4_ANT_KEY_END */
-
-    @Override
-    public ResultSet getPseudoColumns(final String catalog, final String schemaPattern, final String tableNamePattern,
-            final String columnNamePattern) throws SQLException {
-        connection.checkOpen();
-        try {
-            return DelegatingResultSet.wrapResultSet(connection,
-                    databaseMetaData.getPseudoColumns(catalog, schemaPattern, tableNamePattern, columnNamePattern));
-        } catch (final SQLException e) {
-            handleException(e);
-            throw new AssertionError();
-        }
-    }
-
-    @Override
-    public boolean generatedKeyAlwaysReturned() throws SQLException {
-        connection.checkOpen();
+    public boolean usesLocalFiles() throws SQLException {
         try {
-            return databaseMetaData.generatedKeyAlwaysReturned();
+            return databaseMetaData.usesLocalFiles();
         } catch (final SQLException e) {
             handleException(e);
             return false;

==================================================
DelegatingResultSet.java
index ca50f67fd6..2bf975cc1f 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/DelegatingPreparedStatement.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/DelegatingPreparedStatement.java
@@ -31,6 +31,7 @@ import java.sql.ResultSet;
 import java.sql.ResultSetMetaData;
 import java.sql.RowId;
 import java.sql.SQLException;
+import java.sql.SQLType;
 import java.sql.SQLXML;
 import java.sql.Statement;
 import java.sql.Time;
@@ -63,6 +64,54 @@ public class DelegatingPreparedStatement extends DelegatingStatement implements
         super(connection, statement);
     }
 
+    @Override
+    public void addBatch() throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().addBatch();
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void clearParameters() throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().clearParameters();
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public boolean execute() throws SQLException {
+        checkOpen();
+        if (getConnectionInternal() != null) {
+            getConnectionInternal().setLastUsed();
+        }
+        try {
+            return getDelegatePreparedStatement().execute();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
+
+    /**
+     * @since 2.5.0
+     */
+    @Override
+    public long executeLargeUpdate() throws SQLException {
+        checkOpen();
+        try {
+            return getDelegatePreparedStatement().executeLargeUpdate();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
+
     @Override
     public ResultSet executeQuery() throws SQLException {
         checkOpen();
@@ -96,559 +145,551 @@ public class DelegatingPreparedStatement extends DelegatingStatement implements
     }
 
     @Override
-    public void setNull(final int parameterIndex, final int sqlType) throws SQLException {
+    public ResultSetMetaData getMetaData() throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setNull(parameterIndex, sqlType);
+            return getDelegatePreparedStatement().getMetaData();
         } catch (final SQLException e) {
             handleException(e);
+            throw new AssertionError();
         }
     }
 
     @Override
-    public void setBoolean(final int parameterIndex, final boolean x) throws SQLException {
+    public java.sql.ParameterMetaData getParameterMetaData() throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setBoolean(parameterIndex, x);
+            return getDelegatePreparedStatement().getParameterMetaData();
         } catch (final SQLException e) {
             handleException(e);
+            throw new AssertionError();
         }
     }
 
     @Override
-    public void setByte(final int parameterIndex, final byte x) throws SQLException {
+    public void setArray(final int i, final Array x) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setByte(parameterIndex, x);
+            getDelegatePreparedStatement().setArray(i, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setShort(final int parameterIndex, final short x) throws SQLException {
+    public void setAsciiStream(final int parameterIndex, final InputStream inputStream) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setShort(parameterIndex, x);
+            getDelegatePreparedStatement().setAsciiStream(parameterIndex, inputStream);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setInt(final int parameterIndex, final int x) throws SQLException {
+    public void setAsciiStream(final int parameterIndex, final InputStream x, final int length) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setInt(parameterIndex, x);
+            getDelegatePreparedStatement().setAsciiStream(parameterIndex, x, length);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setLong(final int parameterIndex, final long x) throws SQLException {
+    public void setAsciiStream(final int parameterIndex, final InputStream inputStream, final long length)
+            throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setLong(parameterIndex, x);
+            getDelegatePreparedStatement().setAsciiStream(parameterIndex, inputStream, length);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setFloat(final int parameterIndex, final float x) throws SQLException {
+    public void setBigDecimal(final int parameterIndex, final BigDecimal x) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setFloat(parameterIndex, x);
+            getDelegatePreparedStatement().setBigDecimal(parameterIndex, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setDouble(final int parameterIndex, final double x) throws SQLException {
+    public void setBinaryStream(final int parameterIndex, final InputStream inputStream) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setDouble(parameterIndex, x);
+            getDelegatePreparedStatement().setBinaryStream(parameterIndex, inputStream);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setBigDecimal(final int parameterIndex, final BigDecimal x) throws SQLException {
+    public void setBinaryStream(final int parameterIndex, final InputStream x, final int length) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setBigDecimal(parameterIndex, x);
+            getDelegatePreparedStatement().setBinaryStream(parameterIndex, x, length);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setString(final int parameterIndex, final String x) throws SQLException {
+    public void setBinaryStream(final int parameterIndex, final InputStream inputStream, final long length)
+            throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setString(parameterIndex, x);
+            getDelegatePreparedStatement().setBinaryStream(parameterIndex, inputStream, length);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setBytes(final int parameterIndex, final byte[] x) throws SQLException {
+    public void setBlob(final int i, final Blob x) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setBytes(parameterIndex, x);
+            getDelegatePreparedStatement().setBlob(i, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setDate(final int parameterIndex, final Date x) throws SQLException {
+    public void setBlob(final int parameterIndex, final InputStream inputStream) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setDate(parameterIndex, x);
+            getDelegatePreparedStatement().setBlob(parameterIndex, inputStream);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setTime(final int parameterIndex, final Time x) throws SQLException {
+    public void setBlob(final int parameterIndex, final InputStream inputStream, final long length)
+            throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setTime(parameterIndex, x);
+            getDelegatePreparedStatement().setBlob(parameterIndex, inputStream, length);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setTimestamp(final int parameterIndex, final Timestamp x) throws SQLException {
+    public void setBoolean(final int parameterIndex, final boolean x) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setTimestamp(parameterIndex, x);
+            getDelegatePreparedStatement().setBoolean(parameterIndex, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setAsciiStream(final int parameterIndex, final InputStream x, final int length) throws SQLException {
+    public void setByte(final int parameterIndex, final byte x) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setAsciiStream(parameterIndex, x, length);
+            getDelegatePreparedStatement().setByte(parameterIndex, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
-    /** @deprecated Use setAsciiStream(), setCharacterStream() or setNCharacterStream() */
-    @Deprecated
     @Override
-    public void setUnicodeStream(final int parameterIndex, final InputStream x, final int length) throws SQLException {
+    public void setBytes(final int parameterIndex, final byte[] x) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setUnicodeStream(parameterIndex, x, length);
+            getDelegatePreparedStatement().setBytes(parameterIndex, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setBinaryStream(final int parameterIndex, final InputStream x, final int length) throws SQLException {
+    public void setCharacterStream(final int parameterIndex, final Reader reader) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setBinaryStream(parameterIndex, x, length);
+            getDelegatePreparedStatement().setCharacterStream(parameterIndex, reader);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void clearParameters() throws SQLException {
+    public void setCharacterStream(final int parameterIndex, final Reader reader, final int length)
+            throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().clearParameters();
+            getDelegatePreparedStatement().setCharacterStream(parameterIndex, reader, length);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setObject(final int parameterIndex, final Object x, final int targetSqlType, final int scale)
+    public void setCharacterStream(final int parameterIndex, final Reader reader, final long length)
             throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setObject(parameterIndex, x, targetSqlType, scale);
+            getDelegatePreparedStatement().setCharacterStream(parameterIndex, reader, length);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setObject(final int parameterIndex, final Object x, final int targetSqlType) throws SQLException {
+    public void setClob(final int i, final Clob x) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setObject(parameterIndex, x, targetSqlType);
+            getDelegatePreparedStatement().setClob(i, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setObject(final int parameterIndex, final Object x) throws SQLException {
+    public void setClob(final int parameterIndex, final Reader reader) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setObject(parameterIndex, x);
+            getDelegatePreparedStatement().setClob(parameterIndex, reader);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public boolean execute() throws SQLException {
+    public void setClob(final int parameterIndex, final Reader reader, final long length) throws SQLException {
         checkOpen();
-        if (getConnectionInternal() != null) {
-            getConnectionInternal().setLastUsed();
-        }
         try {
-            return getDelegatePreparedStatement().execute();
+            getDelegatePreparedStatement().setClob(parameterIndex, reader, length);
         } catch (final SQLException e) {
             handleException(e);
-            return false;
         }
     }
 
     @Override
-    public void addBatch() throws SQLException {
+    public void setDate(final int parameterIndex, final Date x) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().addBatch();
+            getDelegatePreparedStatement().setDate(parameterIndex, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setCharacterStream(final int parameterIndex, final Reader reader, final int length)
-            throws SQLException {
+    public void setDate(final int parameterIndex, final Date x, final Calendar cal) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setCharacterStream(parameterIndex, reader, length);
+            getDelegatePreparedStatement().setDate(parameterIndex, x, cal);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setRef(final int i, final Ref x) throws SQLException {
+    public void setDouble(final int parameterIndex, final double x) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setRef(i, x);
+            getDelegatePreparedStatement().setDouble(parameterIndex, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setBlob(final int i, final Blob x) throws SQLException {
+    public void setFloat(final int parameterIndex, final float x) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setBlob(i, x);
+            getDelegatePreparedStatement().setFloat(parameterIndex, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setClob(final int i, final Clob x) throws SQLException {
+    public void setInt(final int parameterIndex, final int x) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setClob(i, x);
+            getDelegatePreparedStatement().setInt(parameterIndex, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setArray(final int i, final Array x) throws SQLException {
+    public void setLong(final int parameterIndex, final long x) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setArray(i, x);
+            getDelegatePreparedStatement().setLong(parameterIndex, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public ResultSetMetaData getMetaData() throws SQLException {
+    public void setNCharacterStream(final int parameterIndex, final Reader reader) throws SQLException {
         checkOpen();
         try {
-            return getDelegatePreparedStatement().getMetaData();
+            getDelegatePreparedStatement().setNCharacterStream(parameterIndex, reader);
         } catch (final SQLException e) {
             handleException(e);
-            throw new AssertionError();
         }
     }
 
     @Override
-    public void setDate(final int parameterIndex, final Date x, final Calendar cal) throws SQLException {
+    public void setNCharacterStream(final int parameterIndex, final Reader value, final long length)
+            throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setDate(parameterIndex, x, cal);
+            getDelegatePreparedStatement().setNCharacterStream(parameterIndex, value, length);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setTime(final int parameterIndex, final Time x, final Calendar cal) throws SQLException {
+    public void setNClob(final int parameterIndex, final NClob value) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setTime(parameterIndex, x, cal);
+            getDelegatePreparedStatement().setNClob(parameterIndex, value);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setTimestamp(final int parameterIndex, final Timestamp x, final Calendar cal) throws SQLException {
+    public void setNClob(final int parameterIndex, final Reader reader) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setTimestamp(parameterIndex, x, cal);
+            getDelegatePreparedStatement().setNClob(parameterIndex, reader);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setNull(final int paramIndex, final int sqlType, final String typeName) throws SQLException {
+    public void setNClob(final int parameterIndex, final Reader reader, final long length) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setNull(paramIndex, sqlType, typeName);
+            getDelegatePreparedStatement().setNClob(parameterIndex, reader, length);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
-    /**
-     * Returns a String representation of this object.
-     *
-     * @return String
-     */
-    @SuppressWarnings("resource")
     @Override
-    public String toString() {
-        final Statement statement = getDelegate();
-        return statement == null ? "NULL" : statement.toString();
-    }
-
-    @Override
-    public void setURL(final int parameterIndex, final java.net.URL x) throws SQLException {
+    public void setNString(final int parameterIndex, final String value) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setURL(parameterIndex, x);
+            getDelegatePreparedStatement().setNString(parameterIndex, value);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public java.sql.ParameterMetaData getParameterMetaData() throws SQLException {
+    public void setNull(final int parameterIndex, final int sqlType) throws SQLException {
         checkOpen();
         try {
-            return getDelegatePreparedStatement().getParameterMetaData();
+            getDelegatePreparedStatement().setNull(parameterIndex, sqlType);
         } catch (final SQLException e) {
             handleException(e);
-            throw new AssertionError();
         }
     }
 
     @Override
-    public void setRowId(final int parameterIndex, final RowId value) throws SQLException {
+    public void setNull(final int paramIndex, final int sqlType, final String typeName) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setRowId(parameterIndex, value);
+            getDelegatePreparedStatement().setNull(paramIndex, sqlType, typeName);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setNString(final int parameterIndex, final String value) throws SQLException {
+    public void setObject(final int parameterIndex, final Object x) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setNString(parameterIndex, value);
+            getDelegatePreparedStatement().setObject(parameterIndex, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setNCharacterStream(final int parameterIndex, final Reader value, final long length)
-            throws SQLException {
+    public void setObject(final int parameterIndex, final Object x, final int targetSqlType) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setNCharacterStream(parameterIndex, value, length);
+            getDelegatePreparedStatement().setObject(parameterIndex, x, targetSqlType);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setNClob(final int parameterIndex, final NClob value) throws SQLException {
+    public void setObject(final int parameterIndex, final Object x, final int targetSqlType, final int scale)
+            throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setNClob(parameterIndex, value);
+            getDelegatePreparedStatement().setObject(parameterIndex, x, targetSqlType, scale);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
+    /**
+     * @since 2.5.0
+     */
     @Override
-    public void setClob(final int parameterIndex, final Reader reader, final long length) throws SQLException {
+    public void setObject(final int parameterIndex, final Object x, final SQLType targetSqlType) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setClob(parameterIndex, reader, length);
+            getDelegatePreparedStatement().setObject(parameterIndex, x, targetSqlType);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
+    /**
+     * @since 2.5.0
+     */
     @Override
-    public void setBlob(final int parameterIndex, final InputStream inputStream, final long length)
-            throws SQLException {
+    public void setObject(final int parameterIndex, final Object x, final SQLType targetSqlType, final int scaleOrLength) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setBlob(parameterIndex, inputStream, length);
+            getDelegatePreparedStatement().setObject(parameterIndex, x, targetSqlType, scaleOrLength);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setNClob(final int parameterIndex, final Reader reader, final long length) throws SQLException {
+    public void setRef(final int i, final Ref x) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setNClob(parameterIndex, reader, length);
+            getDelegatePreparedStatement().setRef(i, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setSQLXML(final int parameterIndex, final SQLXML value) throws SQLException {
+    public void setRowId(final int parameterIndex, final RowId value) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setSQLXML(parameterIndex, value);
+            getDelegatePreparedStatement().setRowId(parameterIndex, value);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setAsciiStream(final int parameterIndex, final InputStream inputStream, final long length)
-            throws SQLException {
+    public void setShort(final int parameterIndex, final short x) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setAsciiStream(parameterIndex, inputStream, length);
+            getDelegatePreparedStatement().setShort(parameterIndex, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setBinaryStream(final int parameterIndex, final InputStream inputStream, final long length)
-            throws SQLException {
+    public void setSQLXML(final int parameterIndex, final SQLXML value) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setBinaryStream(parameterIndex, inputStream, length);
+            getDelegatePreparedStatement().setSQLXML(parameterIndex, value);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setCharacterStream(final int parameterIndex, final Reader reader, final long length)
-            throws SQLException {
+    public void setString(final int parameterIndex, final String x) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setCharacterStream(parameterIndex, reader, length);
+            getDelegatePreparedStatement().setString(parameterIndex, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setAsciiStream(final int parameterIndex, final InputStream inputStream) throws SQLException {
+    public void setTime(final int parameterIndex, final Time x) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setAsciiStream(parameterIndex, inputStream);
+            getDelegatePreparedStatement().setTime(parameterIndex, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setBinaryStream(final int parameterIndex, final InputStream inputStream) throws SQLException {
+    public void setTime(final int parameterIndex, final Time x, final Calendar cal) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setBinaryStream(parameterIndex, inputStream);
+            getDelegatePreparedStatement().setTime(parameterIndex, x, cal);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setCharacterStream(final int parameterIndex, final Reader reader) throws SQLException {
+    public void setTimestamp(final int parameterIndex, final Timestamp x) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setCharacterStream(parameterIndex, reader);
+            getDelegatePreparedStatement().setTimestamp(parameterIndex, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setNCharacterStream(final int parameterIndex, final Reader reader) throws SQLException {
+    public void setTimestamp(final int parameterIndex, final Timestamp x, final Calendar cal) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setNCharacterStream(parameterIndex, reader);
+            getDelegatePreparedStatement().setTimestamp(parameterIndex, x, cal);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
+    /** @deprecated Use setAsciiStream(), setCharacterStream() or setNCharacterStream() */
+    @Deprecated
     @Override
-    public void setClob(final int parameterIndex, final Reader reader) throws SQLException {
+    public void setUnicodeStream(final int parameterIndex, final InputStream x, final int length) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setClob(parameterIndex, reader);
+            getDelegatePreparedStatement().setUnicodeStream(parameterIndex, x, length);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setBlob(final int parameterIndex, final InputStream inputStream) throws SQLException {
+    public void setURL(final int parameterIndex, final java.net.URL x) throws SQLException {
         checkOpen();
         try {
-            getDelegatePreparedStatement().setBlob(parameterIndex, inputStream);
+            getDelegatePreparedStatement().setURL(parameterIndex, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
+    /**
+     * Returns a String representation of this object.
+     *
+     * @return String
+     */
+    @SuppressWarnings("resource")
     @Override
-    public void setNClob(final int parameterIndex, final Reader reader) throws SQLException {
-        checkOpen();
-        try {
-            getDelegatePreparedStatement().setNClob(parameterIndex, reader);
-        } catch (final SQLException e) {
-            handleException(e);
-        }
+    public String toString() {
+        final Statement statement = getDelegate();
+        return statement == null ? "NULL" : statement.toString();
     }
 }

==================================================
DelegatingStatement.java
index b7e1ba0fd7..b640792bde 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/DelegatingResultSet.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/DelegatingResultSet.java
@@ -31,6 +31,7 @@ import java.sql.ResultSet;
 import java.sql.ResultSetMetaData;
 import java.sql.RowId;
 import java.sql.SQLException;
+import java.sql.SQLType;
 import java.sql.SQLWarning;
 import java.sql.SQLXML;
 import java.sql.Statement;
@@ -54,33 +55,47 @@ import java.util.Map;
  */
 public final class DelegatingResultSet extends AbandonedTrace implements ResultSet {
 
-    /** My delegate. **/
-    private final ResultSet resultSet;
-
-    /** The Statement that created me, if any. **/
-    private Statement statement;
-
-    /** The Connection that created me, if any. **/
-    private Connection connection;
+    /**
+     * Wraps the given result set in a delegate.
+     *
+     * @param connection
+     *            The Connection which created the ResultSet.
+     * @param resultSet
+     *            The ResultSet to wrap.
+     * @return a new delegate.
+     */
+    public static ResultSet wrapResultSet(final Connection connection, final ResultSet resultSet) {
+        if (null == resultSet) {
+            return null;
+        }
+        return new DelegatingResultSet(connection, resultSet);
+    }
 
     /**
-     * Creates a wrapper for the ResultSet which traces this ResultSet to the Statement which created it and the code
-     * which created it.
-     * <p>
-     * Private to ensure all construction is {@link #wrapResultSet(Statement, ResultSet)}
-     * </p>
+     * Wraps the given result set in a delegate.
      *
      * @param statement
      *            The Statement which created the ResultSet.
      * @param resultSet
      *            The ResultSet to wrap.
+     * @return a new delegate.
      */
-    private DelegatingResultSet(final Statement statement, final ResultSet resultSet) {
-        super((AbandonedTrace) statement);
-        this.statement = statement;
-        this.resultSet = resultSet;
+    public static ResultSet wrapResultSet(final Statement statement, final ResultSet resultSet) {
+        if (null == resultSet) {
+            return null;
+        }
+        return new DelegatingResultSet(statement, resultSet);
     }
 
+    /** My delegate. **/
+    private final ResultSet resultSet;
+
+    /** The Statement that created me, if any. **/
+    private Statement statement;
+
+    /** The Connection that created me, if any. **/
+    private Connection connection;
+
     /**
      * Creates a wrapper for the ResultSet which traces this ResultSet to the Connection which created it (via, for
      * example DatabaseMetadata, and the code which created it.
@@ -100,74 +115,67 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     }
 
     /**
-     * Wraps the given result set in a delegate.
+     * Creates a wrapper for the ResultSet which traces this ResultSet to the Statement which created it and the code
+     * which created it.
+     * <p>
+     * Private to ensure all construction is {@link #wrapResultSet(Statement, ResultSet)}
+     * </p>
      *
      * @param statement
      *            The Statement which created the ResultSet.
      * @param resultSet
      *            The ResultSet to wrap.
-     * @return a new delegate.
      */
-    public static ResultSet wrapResultSet(final Statement statement, final ResultSet resultSet) {
-        if (null == resultSet) {
-            return null;
+    private DelegatingResultSet(final Statement statement, final ResultSet resultSet) {
+        super((AbandonedTrace) statement);
+        this.statement = statement;
+        this.resultSet = resultSet;
+    }
+
+    @Override
+    public boolean absolute(final int row) throws SQLException {
+        try {
+            return resultSet.absolute(row);
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
         }
-        return new DelegatingResultSet(statement, resultSet);
     }
 
-    /**
-     * Wraps the given result set in a delegate.
-     *
-     * @param connection
-     *            The Connection which created the ResultSet.
-     * @param resultSet
-     *            The ResultSet to wrap.
-     * @return a new delegate.
-     */
-    public static ResultSet wrapResultSet(final Connection connection, final ResultSet resultSet) {
-        if (null == resultSet) {
-            return null;
+    @Override
+    public void afterLast() throws SQLException {
+        try {
+            resultSet.afterLast();
+        } catch (final SQLException e) {
+            handleException(e);
         }
-        return new DelegatingResultSet(connection, resultSet);
     }
 
-    /**
-     * Gets my delegate.
-     *
-     * @return my delegate.
-     */
-    public ResultSet getDelegate() {
-        return resultSet;
+    @Override
+    public void beforeFirst() throws SQLException {
+        try {
+            resultSet.beforeFirst();
+        } catch (final SQLException e) {
+            handleException(e);
+        }
     }
 
-    /**
-     * If my underlying {@link ResultSet} is not a {@code DelegatingResultSet}, returns it, otherwise recursively
-     * invokes this method on my delegate.
-     * <p>
-     * Hence this method will return the first delegate that is not a {@code DelegatingResultSet}, or {@code null} when
-     * no non-{@code DelegatingResultSet} delegate can be found by traversing this chain.
-     * </p>
-     * <p>
-     * This method is useful when you may have nested {@code DelegatingResultSet}s, and you want to make sure to obtain
-     * a "genuine" {@link ResultSet}.
-     * </p>
-     *
-     * @return the innermost delegate.
-     */
-    public ResultSet getInnermostDelegate() {
-        ResultSet r = resultSet;
-        while (r != null && r instanceof DelegatingResultSet) {
-            r = ((DelegatingResultSet) r).getDelegate();
-            if (this == r) {
-                return null;
-            }
+    @Override
+    public void cancelRowUpdates() throws SQLException {
+        try {
+            resultSet.cancelRowUpdates();
+        } catch (final SQLException e) {
+            handleException(e);
         }
-        return r;
     }
 
     @Override
-    public Statement getStatement() throws SQLException {
-        return statement;
+    public void clearWarnings() throws SQLException {
+        try {
+            resultSet.clearWarnings();
+        } catch (final SQLException e) {
+            handleException(e);
+        }
     }
 
     /**
@@ -191,122 +199,113 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
         }
     }
 
-    protected void handleException(final SQLException e) throws SQLException {
-        if (statement != null && statement instanceof DelegatingStatement) {
-            ((DelegatingStatement) statement).handleException(e);
-        } else if (connection != null && connection instanceof DelegatingConnection) {
-            ((DelegatingConnection<?>) connection).handleException(e);
-        } else {
-            throw e;
-        }
-    }
-
     @Override
-    public boolean next() throws SQLException {
+    public void deleteRow() throws SQLException {
         try {
-            return resultSet.next();
+            resultSet.deleteRow();
         } catch (final SQLException e) {
             handleException(e);
-            return false;
         }
     }
 
     @Override
-    public boolean wasNull() throws SQLException {
+    public int findColumn(final String columnName) throws SQLException {
         try {
-            return resultSet.wasNull();
+            return resultSet.findColumn(columnName);
         } catch (final SQLException e) {
             handleException(e);
-            return false;
+            return 0;
         }
     }
 
     @Override
-    public String getString(final int columnIndex) throws SQLException {
+    public boolean first() throws SQLException {
         try {
-            return resultSet.getString(columnIndex);
+            return resultSet.first();
         } catch (final SQLException e) {
             handleException(e);
-            return null;
+            return false;
         }
     }
 
     @Override
-    public boolean getBoolean(final int columnIndex) throws SQLException {
+    public Array getArray(final int i) throws SQLException {
         try {
-            return resultSet.getBoolean(columnIndex);
+            return resultSet.getArray(i);
         } catch (final SQLException e) {
             handleException(e);
-            return false;
+            return null;
         }
     }
 
     @Override
-    public byte getByte(final int columnIndex) throws SQLException {
+    public Array getArray(final String colName) throws SQLException {
         try {
-            return resultSet.getByte(columnIndex);
+            return resultSet.getArray(colName);
         } catch (final SQLException e) {
             handleException(e);
-            return 0;
+            return null;
         }
     }
 
     @Override
-    public short getShort(final int columnIndex) throws SQLException {
+    public InputStream getAsciiStream(final int columnIndex) throws SQLException {
         try {
-            return resultSet.getShort(columnIndex);
+            return resultSet.getAsciiStream(columnIndex);
         } catch (final SQLException e) {
             handleException(e);
-            return 0;
+            return null;
         }
     }
 
     @Override
-    public int getInt(final int columnIndex) throws SQLException {
+    public InputStream getAsciiStream(final String columnName) throws SQLException {
         try {
-            return resultSet.getInt(columnIndex);
+            return resultSet.getAsciiStream(columnName);
         } catch (final SQLException e) {
             handleException(e);
-            return 0;
+            return null;
         }
     }
 
     @Override
-    public long getLong(final int columnIndex) throws SQLException {
+    public BigDecimal getBigDecimal(final int columnIndex) throws SQLException {
         try {
-            return resultSet.getLong(columnIndex);
+            return resultSet.getBigDecimal(columnIndex);
         } catch (final SQLException e) {
             handleException(e);
-            return 0;
+            return null;
         }
     }
 
+    /** @deprecated Use {@link #getBigDecimal(int)} */
+    @Deprecated
     @Override
-    public float getFloat(final int columnIndex) throws SQLException {
+    public BigDecimal getBigDecimal(final int columnIndex, final int scale) throws SQLException {
         try {
-            return resultSet.getFloat(columnIndex);
+            return resultSet.getBigDecimal(columnIndex);
         } catch (final SQLException e) {
             handleException(e);
-            return 0;
+            return null;
         }
     }
 
     @Override
-    public double getDouble(final int columnIndex) throws SQLException {
+    public BigDecimal getBigDecimal(final String columnName) throws SQLException {
         try {
-            return resultSet.getDouble(columnIndex);
+            return resultSet.getBigDecimal(columnName);
         } catch (final SQLException e) {
             handleException(e);
-            return 0;
+            return null;
         }
     }
 
-    /** @deprecated Use {@link #getBigDecimal(int)} */
+    /** @deprecated Use {@link #getBigDecimal(String)} */
     @Deprecated
     @Override
-    public BigDecimal getBigDecimal(final int columnIndex, final int scale) throws SQLException {
+    public BigDecimal getBigDecimal(final String columnName, final int scale) throws SQLException {
         try {
-            return resultSet.getBigDecimal(columnIndex);
+            return resultSet.getBigDecimal(columnName);
         } catch (final SQLException e) {
             handleException(e);
             return null;
@@ -314,9 +313,9 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     }
 
     @Override
-    public byte[] getBytes(final int columnIndex) throws SQLException {
+    public InputStream getBinaryStream(final int columnIndex) throws SQLException {
         try {
-            return resultSet.getBytes(columnIndex);
+            return resultSet.getBinaryStream(columnIndex);
         } catch (final SQLException e) {
             handleException(e);
             return null;
@@ -324,9 +323,9 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     }
 
     @Override
-    public Date getDate(final int columnIndex) throws SQLException {
+    public InputStream getBinaryStream(final String columnName) throws SQLException {
         try {
-            return resultSet.getDate(columnIndex);
+            return resultSet.getBinaryStream(columnName);
         } catch (final SQLException e) {
             handleException(e);
             return null;
@@ -334,9 +333,9 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     }
 
     @Override
-    public Time getTime(final int columnIndex) throws SQLException {
+    public Blob getBlob(final int i) throws SQLException {
         try {
-            return resultSet.getTime(columnIndex);
+            return resultSet.getBlob(i);
         } catch (final SQLException e) {
             handleException(e);
             return null;
@@ -344,9 +343,9 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     }
 
     @Override
-    public Timestamp getTimestamp(final int columnIndex) throws SQLException {
+    public Blob getBlob(final String colName) throws SQLException {
         try {
-            return resultSet.getTimestamp(columnIndex);
+            return resultSet.getBlob(colName);
         } catch (final SQLException e) {
             handleException(e);
             return null;
@@ -354,123 +353,119 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     }
 
     @Override
-    public InputStream getAsciiStream(final int columnIndex) throws SQLException {
+    public boolean getBoolean(final int columnIndex) throws SQLException {
         try {
-            return resultSet.getAsciiStream(columnIndex);
+            return resultSet.getBoolean(columnIndex);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
+            return false;
         }
     }
 
-    /** @deprecated Use {@link #getCharacterStream(int)} */
-    @Deprecated
     @Override
-    public InputStream getUnicodeStream(final int columnIndex) throws SQLException {
+    public boolean getBoolean(final String columnName) throws SQLException {
         try {
-            return resultSet.getUnicodeStream(columnIndex);
+            return resultSet.getBoolean(columnName);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
+            return false;
         }
     }
 
     @Override
-    public InputStream getBinaryStream(final int columnIndex) throws SQLException {
+    public byte getByte(final int columnIndex) throws SQLException {
         try {
-            return resultSet.getBinaryStream(columnIndex);
+            return resultSet.getByte(columnIndex);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
+            return 0;
         }
     }
 
     @Override
-    public String getString(final String columnName) throws SQLException {
+    public byte getByte(final String columnName) throws SQLException {
         try {
-            return resultSet.getString(columnName);
+            return resultSet.getByte(columnName);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
+            return 0;
         }
     }
 
     @Override
-    public boolean getBoolean(final String columnName) throws SQLException {
+    public byte[] getBytes(final int columnIndex) throws SQLException {
         try {
-            return resultSet.getBoolean(columnName);
+            return resultSet.getBytes(columnIndex);
         } catch (final SQLException e) {
             handleException(e);
-            return false;
+            return null;
         }
     }
 
     @Override
-    public byte getByte(final String columnName) throws SQLException {
+    public byte[] getBytes(final String columnName) throws SQLException {
         try {
-            return resultSet.getByte(columnName);
+            return resultSet.getBytes(columnName);
         } catch (final SQLException e) {
             handleException(e);
-            return 0;
+            return null;
         }
     }
 
     @Override
-    public short getShort(final String columnName) throws SQLException {
+    public Reader getCharacterStream(final int columnIndex) throws SQLException {
         try {
-            return resultSet.getShort(columnName);
+            return resultSet.getCharacterStream(columnIndex);
         } catch (final SQLException e) {
             handleException(e);
-            return 0;
+            return null;
         }
     }
 
     @Override
-    public int getInt(final String columnName) throws SQLException {
+    public Reader getCharacterStream(final String columnName) throws SQLException {
         try {
-            return resultSet.getInt(columnName);
+            return resultSet.getCharacterStream(columnName);
         } catch (final SQLException e) {
             handleException(e);
-            return 0;
+            return null;
         }
     }
 
     @Override
-    public long getLong(final String columnName) throws SQLException {
+    public Clob getClob(final int i) throws SQLException {
         try {
-            return resultSet.getLong(columnName);
+            return resultSet.getClob(i);
         } catch (final SQLException e) {
             handleException(e);
-            return 0;
+            return null;
         }
     }
 
     @Override
-    public float getFloat(final String columnName) throws SQLException {
+    public Clob getClob(final String colName) throws SQLException {
         try {
-            return resultSet.getFloat(columnName);
+            return resultSet.getClob(colName);
         } catch (final SQLException e) {
             handleException(e);
-            return 0;
+            return null;
         }
     }
 
     @Override
-    public double getDouble(final String columnName) throws SQLException {
+    public int getConcurrency() throws SQLException {
         try {
-            return resultSet.getDouble(columnName);
+            return resultSet.getConcurrency();
         } catch (final SQLException e) {
             handleException(e);
             return 0;
         }
     }
 
-    /** @deprecated Use {@link #getBigDecimal(String)} */
-    @Deprecated
     @Override
-    public BigDecimal getBigDecimal(final String columnName, final int scale) throws SQLException {
+    public String getCursorName() throws SQLException {
         try {
-            return resultSet.getBigDecimal(columnName);
+            return resultSet.getCursorName();
         } catch (final SQLException e) {
             handleException(e);
             return null;
@@ -478,9 +473,9 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     }
 
     @Override
-    public byte[] getBytes(final String columnName) throws SQLException {
+    public Date getDate(final int columnIndex) throws SQLException {
         try {
-            return resultSet.getBytes(columnName);
+            return resultSet.getDate(columnIndex);
         } catch (final SQLException e) {
             handleException(e);
             return null;
@@ -488,9 +483,9 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     }
 
     @Override
-    public Date getDate(final String columnName) throws SQLException {
+    public Date getDate(final int columnIndex, final Calendar cal) throws SQLException {
         try {
-            return resultSet.getDate(columnName);
+            return resultSet.getDate(columnIndex, cal);
         } catch (final SQLException e) {
             handleException(e);
             return null;
@@ -498,9 +493,9 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     }
 
     @Override
-    public Time getTime(final String columnName) throws SQLException {
+    public Date getDate(final String columnName) throws SQLException {
         try {
-            return resultSet.getTime(columnName);
+            return resultSet.getDate(columnName);
         } catch (final SQLException e) {
             handleException(e);
             return null;
@@ -508,110 +503,134 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     }
 
     @Override
-    public Timestamp getTimestamp(final String columnName) throws SQLException {
+    public Date getDate(final String columnName, final Calendar cal) throws SQLException {
         try {
-            return resultSet.getTimestamp(columnName);
+            return resultSet.getDate(columnName, cal);
         } catch (final SQLException e) {
             handleException(e);
             return null;
         }
     }
 
+    /**
+     * Gets my delegate.
+     *
+     * @return my delegate.
+     */
+    public ResultSet getDelegate() {
+        return resultSet;
+    }
+
     @Override
-    public InputStream getAsciiStream(final String columnName) throws SQLException {
+    public double getDouble(final int columnIndex) throws SQLException {
         try {
-            return resultSet.getAsciiStream(columnName);
+            return resultSet.getDouble(columnIndex);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
+            return 0;
         }
     }
 
-    /** @deprecated Use {@link #getCharacterStream(String)} */
-    @Deprecated
     @Override
-    public InputStream getUnicodeStream(final String columnName) throws SQLException {
+    public double getDouble(final String columnName) throws SQLException {
         try {
-            return resultSet.getUnicodeStream(columnName);
+            return resultSet.getDouble(columnName);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
+            return 0;
         }
     }
 
     @Override
-    public InputStream getBinaryStream(final String columnName) throws SQLException {
+    public int getFetchDirection() throws SQLException {
         try {
-            return resultSet.getBinaryStream(columnName);
+            return resultSet.getFetchDirection();
         } catch (final SQLException e) {
             handleException(e);
-            return null;
+            return 0;
         }
     }
 
     @Override
-    public SQLWarning getWarnings() throws SQLException {
+    public int getFetchSize() throws SQLException {
         try {
-            return resultSet.getWarnings();
+            return resultSet.getFetchSize();
         } catch (final SQLException e) {
             handleException(e);
-            return null;
+            return 0;
         }
     }
 
     @Override
-    public void clearWarnings() throws SQLException {
+    public float getFloat(final int columnIndex) throws SQLException {
         try {
-            resultSet.clearWarnings();
+            return resultSet.getFloat(columnIndex);
         } catch (final SQLException e) {
             handleException(e);
+            return 0;
         }
     }
 
     @Override
-    public String getCursorName() throws SQLException {
+    public float getFloat(final String columnName) throws SQLException {
         try {
-            return resultSet.getCursorName();
+            return resultSet.getFloat(columnName);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
+            return 0;
         }
     }
 
     @Override
-    public ResultSetMetaData getMetaData() throws SQLException {
+    public int getHoldability() throws SQLException {
         try {
-            return resultSet.getMetaData();
+            return resultSet.getHoldability();
         } catch (final SQLException e) {
             handleException(e);
-            return null;
+            return 0;
         }
     }
 
-    @Override
-    public Object getObject(final int columnIndex) throws SQLException {
-        try {
-            return resultSet.getObject(columnIndex);
-        } catch (final SQLException e) {
-            handleException(e);
-            return null;
+    /**
+     * If my underlying {@link ResultSet} is not a {@code DelegatingResultSet}, returns it, otherwise recursively
+     * invokes this method on my delegate.
+     * <p>
+     * Hence this method will return the first delegate that is not a {@code DelegatingResultSet}, or {@code null} when
+     * no non-{@code DelegatingResultSet} delegate can be found by traversing this chain.
+     * </p>
+     * <p>
+     * This method is useful when you may have nested {@code DelegatingResultSet}s, and you want to make sure to obtain
+     * a "genuine" {@link ResultSet}.
+     * </p>
+     *
+     * @return the innermost delegate.
+     */
+    @SuppressWarnings("resource")
+    public ResultSet getInnermostDelegate() {
+        ResultSet r = resultSet;
+        while (r != null && r instanceof DelegatingResultSet) {
+            r = ((DelegatingResultSet) r).getDelegate();
+            if (this == r) {
+                return null;
+            }
         }
+        return r;
     }
 
     @Override
-    public Object getObject(final String columnName) throws SQLException {
+    public int getInt(final int columnIndex) throws SQLException {
         try {
-            return resultSet.getObject(columnName);
+            return resultSet.getInt(columnIndex);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
+            return 0;
         }
     }
 
     @Override
-    public int findColumn(final String columnName) throws SQLException {
+    public int getInt(final String columnName) throws SQLException {
         try {
-            return resultSet.findColumn(columnName);
+            return resultSet.getInt(columnName);
         } catch (final SQLException e) {
             handleException(e);
             return 0;
@@ -619,29 +638,29 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     }
 
     @Override
-    public Reader getCharacterStream(final int columnIndex) throws SQLException {
+    public long getLong(final int columnIndex) throws SQLException {
         try {
-            return resultSet.getCharacterStream(columnIndex);
+            return resultSet.getLong(columnIndex);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
+            return 0;
         }
     }
 
     @Override
-    public Reader getCharacterStream(final String columnName) throws SQLException {
+    public long getLong(final String columnName) throws SQLException {
         try {
-            return resultSet.getCharacterStream(columnName);
+            return resultSet.getLong(columnName);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
+            return 0;
         }
     }
 
     @Override
-    public BigDecimal getBigDecimal(final int columnIndex) throws SQLException {
+    public ResultSetMetaData getMetaData() throws SQLException {
         try {
-            return resultSet.getBigDecimal(columnIndex);
+            return resultSet.getMetaData();
         } catch (final SQLException e) {
             handleException(e);
             return null;
@@ -649,9 +668,9 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     }
 
     @Override
-    public BigDecimal getBigDecimal(final String columnName) throws SQLException {
+    public Reader getNCharacterStream(final int columnIndex) throws SQLException {
         try {
-            return resultSet.getBigDecimal(columnName);
+            return resultSet.getNCharacterStream(columnIndex);
         } catch (final SQLException e) {
             handleException(e);
             return null;
@@ -659,136 +678,139 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     }
 
     @Override
-    public boolean isBeforeFirst() throws SQLException {
+    public Reader getNCharacterStream(final String columnLabel) throws SQLException {
         try {
-            return resultSet.isBeforeFirst();
+            return resultSet.getNCharacterStream(columnLabel);
         } catch (final SQLException e) {
             handleException(e);
-            return false;
+            return null;
         }
     }
 
     @Override
-    public boolean isAfterLast() throws SQLException {
+    public NClob getNClob(final int columnIndex) throws SQLException {
         try {
-            return resultSet.isAfterLast();
+            return resultSet.getNClob(columnIndex);
         } catch (final SQLException e) {
             handleException(e);
-            return false;
+            return null;
         }
     }
 
     @Override
-    public boolean isFirst() throws SQLException {
+    public NClob getNClob(final String columnLabel) throws SQLException {
         try {
-            return resultSet.isFirst();
+            return resultSet.getNClob(columnLabel);
         } catch (final SQLException e) {
             handleException(e);
-            return false;
+            return null;
         }
     }
 
     @Override
-    public boolean isLast() throws SQLException {
+    public String getNString(final int columnIndex) throws SQLException {
         try {
-            return resultSet.isLast();
+            return resultSet.getNString(columnIndex);
         } catch (final SQLException e) {
             handleException(e);
-            return false;
+            return null;
         }
     }
 
     @Override
-    public void beforeFirst() throws SQLException {
+    public String getNString(final String columnLabel) throws SQLException {
         try {
-            resultSet.beforeFirst();
+            return resultSet.getNString(columnLabel);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void afterLast() throws SQLException {
+    public Object getObject(final int columnIndex) throws SQLException {
         try {
-            resultSet.afterLast();
+            return resultSet.getObject(columnIndex);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public boolean first() throws SQLException {
+    public <T> T getObject(final int columnIndex, final Class<T> type) throws SQLException {
         try {
-            return resultSet.first();
+            return resultSet.getObject(columnIndex, type);
         } catch (final SQLException e) {
             handleException(e);
-            return false;
+            return null;
         }
     }
 
     @Override
-    public boolean last() throws SQLException {
+    public Object getObject(final int i, final Map<String, Class<?>> map) throws SQLException {
         try {
-            return resultSet.last();
+            return resultSet.getObject(i, map);
         } catch (final SQLException e) {
             handleException(e);
-            return false;
+            return null;
         }
     }
 
     @Override
-    public int getRow() throws SQLException {
+    public Object getObject(final String columnName) throws SQLException {
         try {
-            return resultSet.getRow();
+            return resultSet.getObject(columnName);
         } catch (final SQLException e) {
             handleException(e);
-            return 0;
+            return null;
         }
     }
 
     @Override
-    public boolean absolute(final int row) throws SQLException {
+    public <T> T getObject(final String columnLabel, final Class<T> type) throws SQLException {
         try {
-            return resultSet.absolute(row);
+            return resultSet.getObject(columnLabel, type);
         } catch (final SQLException e) {
             handleException(e);
-            return false;
+            return null;
         }
     }
 
     @Override
-    public boolean relative(final int rows) throws SQLException {
+    public Object getObject(final String colName, final Map<String, Class<?>> map) throws SQLException {
         try {
-            return resultSet.relative(rows);
+            return resultSet.getObject(colName, map);
         } catch (final SQLException e) {
             handleException(e);
-            return false;
+            return null;
         }
     }
 
     @Override
-    public boolean previous() throws SQLException {
+    public Ref getRef(final int i) throws SQLException {
         try {
-            return resultSet.previous();
+            return resultSet.getRef(i);
         } catch (final SQLException e) {
             handleException(e);
-            return false;
+            return null;
         }
     }
 
     @Override
-    public void setFetchDirection(final int direction) throws SQLException {
+    public Ref getRef(final String colName) throws SQLException {
         try {
-            resultSet.setFetchDirection(direction);
+            return resultSet.getRef(colName);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public int getFetchDirection() throws SQLException {
+    public int getRow() throws SQLException {
         try {
-            return resultSet.getFetchDirection();
+            return resultSet.getRow();
         } catch (final SQLException e) {
             handleException(e);
             return 0;
@@ -796,28 +818,29 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     }
 
     @Override
-    public void setFetchSize(final int rows) throws SQLException {
+    public RowId getRowId(final int columnIndex) throws SQLException {
         try {
-            resultSet.setFetchSize(rows);
+            return resultSet.getRowId(columnIndex);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public int getFetchSize() throws SQLException {
+    public RowId getRowId(final String columnLabel) throws SQLException {
         try {
-            return resultSet.getFetchSize();
+            return resultSet.getRowId(columnLabel);
         } catch (final SQLException e) {
             handleException(e);
-            return 0;
+            return null;
         }
     }
 
     @Override
-    public int getType() throws SQLException {
+    public short getShort(final int columnIndex) throws SQLException {
         try {
-            return resultSet.getType();
+            return resultSet.getShort(columnIndex);
         } catch (final SQLException e) {
             handleException(e);
             return 0;
@@ -825,9 +848,9 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     }
 
     @Override
-    public int getConcurrency() throws SQLException {
+    public short getShort(final String columnName) throws SQLException {
         try {
-            return resultSet.getConcurrency();
+            return resultSet.getShort(columnName);
         } catch (final SQLException e) {
             handleException(e);
             return 0;
@@ -835,1191 +858,1219 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     }
 
     @Override
-    public boolean rowUpdated() throws SQLException {
+    public SQLXML getSQLXML(final int columnIndex) throws SQLException {
         try {
-            return resultSet.rowUpdated();
+            return resultSet.getSQLXML(columnIndex);
         } catch (final SQLException e) {
             handleException(e);
-            return false;
+            return null;
         }
     }
 
     @Override
-    public boolean rowInserted() throws SQLException {
+    public SQLXML getSQLXML(final String columnLabel) throws SQLException {
         try {
-            return resultSet.rowInserted();
+            return resultSet.getSQLXML(columnLabel);
         } catch (final SQLException e) {
             handleException(e);
-            return false;
+            return null;
         }
     }
 
     @Override
-    public boolean rowDeleted() throws SQLException {
+    public Statement getStatement() throws SQLException {
+        return statement;
+    }
+
+    @Override
+    public String getString(final int columnIndex) throws SQLException {
         try {
-            return resultSet.rowDeleted();
+            return resultSet.getString(columnIndex);
         } catch (final SQLException e) {
             handleException(e);
-            return false;
+            return null;
         }
     }
 
     @Override
-    public void updateNull(final int columnIndex) throws SQLException {
+    public String getString(final String columnName) throws SQLException {
         try {
-            resultSet.updateNull(columnIndex);
+            return resultSet.getString(columnName);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void updateBoolean(final int columnIndex, final boolean x) throws SQLException {
+    public Time getTime(final int columnIndex) throws SQLException {
         try {
-            resultSet.updateBoolean(columnIndex, x);
+            return resultSet.getTime(columnIndex);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void updateByte(final int columnIndex, final byte x) throws SQLException {
+    public Time getTime(final int columnIndex, final Calendar cal) throws SQLException {
         try {
-            resultSet.updateByte(columnIndex, x);
+            return resultSet.getTime(columnIndex, cal);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void updateShort(final int columnIndex, final short x) throws SQLException {
+    public Time getTime(final String columnName) throws SQLException {
         try {
-            resultSet.updateShort(columnIndex, x);
+            return resultSet.getTime(columnName);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void updateInt(final int columnIndex, final int x) throws SQLException {
+    public Time getTime(final String columnName, final Calendar cal) throws SQLException {
         try {
-            resultSet.updateInt(columnIndex, x);
+            return resultSet.getTime(columnName, cal);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void updateLong(final int columnIndex, final long x) throws SQLException {
+    public Timestamp getTimestamp(final int columnIndex) throws SQLException {
         try {
-            resultSet.updateLong(columnIndex, x);
+            return resultSet.getTimestamp(columnIndex);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void updateFloat(final int columnIndex, final float x) throws SQLException {
+    public Timestamp getTimestamp(final int columnIndex, final Calendar cal) throws SQLException {
         try {
-            resultSet.updateFloat(columnIndex, x);
+            return resultSet.getTimestamp(columnIndex, cal);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void updateDouble(final int columnIndex, final double x) throws SQLException {
+    public Timestamp getTimestamp(final String columnName) throws SQLException {
         try {
-            resultSet.updateDouble(columnIndex, x);
+            return resultSet.getTimestamp(columnName);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void updateBigDecimal(final int columnIndex, final BigDecimal x) throws SQLException {
+    public Timestamp getTimestamp(final String columnName, final Calendar cal) throws SQLException {
         try {
-            resultSet.updateBigDecimal(columnIndex, x);
+            return resultSet.getTimestamp(columnName, cal);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void updateString(final int columnIndex, final String x) throws SQLException {
+    public int getType() throws SQLException {
         try {
-            resultSet.updateString(columnIndex, x);
+            return resultSet.getType();
         } catch (final SQLException e) {
             handleException(e);
+            return 0;
         }
     }
 
+    /** @deprecated Use {@link #getCharacterStream(int)} */
+    @Deprecated
     @Override
-    public void updateBytes(final int columnIndex, final byte[] x) throws SQLException {
+    public InputStream getUnicodeStream(final int columnIndex) throws SQLException {
         try {
-            resultSet.updateBytes(columnIndex, x);
+            return resultSet.getUnicodeStream(columnIndex);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
+    /** @deprecated Use {@link #getCharacterStream(String)} */
+    @Deprecated
     @Override
-    public void updateDate(final int columnIndex, final Date x) throws SQLException {
+    public InputStream getUnicodeStream(final String columnName) throws SQLException {
         try {
-            resultSet.updateDate(columnIndex, x);
+            return resultSet.getUnicodeStream(columnName);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void updateTime(final int columnIndex, final Time x) throws SQLException {
+    public java.net.URL getURL(final int columnIndex) throws SQLException {
         try {
-            resultSet.updateTime(columnIndex, x);
+            return resultSet.getURL(columnIndex);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void updateTimestamp(final int columnIndex, final Timestamp x) throws SQLException {
+    public java.net.URL getURL(final String columnName) throws SQLException {
         try {
-            resultSet.updateTimestamp(columnIndex, x);
+            return resultSet.getURL(columnName);
         } catch (final SQLException e) {
             handleException(e);
+            return null;
         }
     }
 
     @Override
-    public void updateAsciiStream(final int columnIndex, final InputStream x, final int length) throws SQLException {
+    public SQLWarning getWarnings() throws SQLException {
         try {
-            resultSet.updateAsciiStream(columnIndex, x, length);
+            return resultSet.getWarnings();
         } catch (final SQLException e) {
             handleException(e);
+            return null;
+        }
+    }
+
+    protected void handleException(final SQLException e) throws SQLException {
+        if (statement != null && statement instanceof DelegatingStatement) {
+            ((DelegatingStatement) statement).handleException(e);
+        } else if (connection != null && connection instanceof DelegatingConnection) {
+            ((DelegatingConnection<?>) connection).handleException(e);
+        } else {
+            throw e;
         }
     }
 
     @Override
-    public void updateBinaryStream(final int columnIndex, final InputStream x, final int length) throws SQLException {
+    public void insertRow() throws SQLException {
         try {
-            resultSet.updateBinaryStream(columnIndex, x, length);
+            resultSet.insertRow();
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateCharacterStream(final int columnIndex, final Reader x, final int length) throws SQLException {
+    public boolean isAfterLast() throws SQLException {
         try {
-            resultSet.updateCharacterStream(columnIndex, x, length);
+            return resultSet.isAfterLast();
         } catch (final SQLException e) {
             handleException(e);
+            return false;
         }
     }
 
     @Override
-    public void updateObject(final int columnIndex, final Object x, final int scale) throws SQLException {
+    public boolean isBeforeFirst() throws SQLException {
         try {
-            resultSet.updateObject(columnIndex, x);
+            return resultSet.isBeforeFirst();
         } catch (final SQLException e) {
             handleException(e);
+            return false;
         }
     }
 
     @Override
-    public void updateObject(final int columnIndex, final Object x) throws SQLException {
+    public boolean isClosed() throws SQLException {
         try {
-            resultSet.updateObject(columnIndex, x);
+            return resultSet.isClosed();
         } catch (final SQLException e) {
             handleException(e);
+            return false;
         }
     }
 
     @Override
-    public void updateNull(final String columnName) throws SQLException {
+    public boolean isFirst() throws SQLException {
         try {
-            resultSet.updateNull(columnName);
+            return resultSet.isFirst();
         } catch (final SQLException e) {
             handleException(e);
+            return false;
         }
     }
 
     @Override
-    public void updateBoolean(final String columnName, final boolean x) throws SQLException {
+    public boolean isLast() throws SQLException {
         try {
-            resultSet.updateBoolean(columnName, x);
+            return resultSet.isLast();
         } catch (final SQLException e) {
             handleException(e);
+            return false;
         }
     }
 
     @Override
-    public void updateByte(final String columnName, final byte x) throws SQLException {
-        try {
-            resultSet.updateByte(columnName, x);
-        } catch (final SQLException e) {
-            handleException(e);
+    public boolean isWrapperFor(final Class<?> iface) throws SQLException {
+        if (iface.isAssignableFrom(getClass())) {
+            return true;
+        } else if (iface.isAssignableFrom(resultSet.getClass())) {
+            return true;
+        } else {
+            return resultSet.isWrapperFor(iface);
         }
     }
 
     @Override
-    public void updateShort(final String columnName, final short x) throws SQLException {
+    public boolean last() throws SQLException {
         try {
-            resultSet.updateShort(columnName, x);
+            return resultSet.last();
         } catch (final SQLException e) {
             handleException(e);
+            return false;
         }
     }
 
     @Override
-    public void updateInt(final String columnName, final int x) throws SQLException {
+    public void moveToCurrentRow() throws SQLException {
         try {
-            resultSet.updateInt(columnName, x);
+            resultSet.moveToCurrentRow();
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateLong(final String columnName, final long x) throws SQLException {
+    public void moveToInsertRow() throws SQLException {
         try {
-            resultSet.updateLong(columnName, x);
+            resultSet.moveToInsertRow();
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateFloat(final String columnName, final float x) throws SQLException {
+    public boolean next() throws SQLException {
         try {
-            resultSet.updateFloat(columnName, x);
+            return resultSet.next();
         } catch (final SQLException e) {
             handleException(e);
+            return false;
         }
     }
 
     @Override
-    public void updateDouble(final String columnName, final double x) throws SQLException {
+    public boolean previous() throws SQLException {
         try {
-            resultSet.updateDouble(columnName, x);
+            return resultSet.previous();
         } catch (final SQLException e) {
             handleException(e);
+            return false;
         }
     }
 
     @Override
-    public void updateBigDecimal(final String columnName, final BigDecimal x) throws SQLException {
+    public void refreshRow() throws SQLException {
         try {
-            resultSet.updateBigDecimal(columnName, x);
+            resultSet.refreshRow();
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateString(final String columnName, final String x) throws SQLException {
+    public boolean relative(final int rows) throws SQLException {
         try {
-            resultSet.updateString(columnName, x);
+            return resultSet.relative(rows);
         } catch (final SQLException e) {
             handleException(e);
+            return false;
         }
     }
 
     @Override
-    public void updateBytes(final String columnName, final byte[] x) throws SQLException {
+    public boolean rowDeleted() throws SQLException {
         try {
-            resultSet.updateBytes(columnName, x);
+            return resultSet.rowDeleted();
         } catch (final SQLException e) {
             handleException(e);
+            return false;
         }
     }
 
     @Override
-    public void updateDate(final String columnName, final Date x) throws SQLException {
+    public boolean rowInserted() throws SQLException {
         try {
-            resultSet.updateDate(columnName, x);
+            return resultSet.rowInserted();
         } catch (final SQLException e) {
             handleException(e);
+            return false;
         }
     }
 
     @Override
-    public void updateTime(final String columnName, final Time x) throws SQLException {
+    public boolean rowUpdated() throws SQLException {
         try {
-            resultSet.updateTime(columnName, x);
+            return resultSet.rowUpdated();
         } catch (final SQLException e) {
             handleException(e);
+            return false;
         }
     }
 
     @Override
-    public void updateTimestamp(final String columnName, final Timestamp x) throws SQLException {
+    public void setFetchDirection(final int direction) throws SQLException {
         try {
-            resultSet.updateTimestamp(columnName, x);
+            resultSet.setFetchDirection(direction);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateAsciiStream(final String columnName, final InputStream x, final int length) throws SQLException {
+    public void setFetchSize(final int rows) throws SQLException {
         try {
-            resultSet.updateAsciiStream(columnName, x, length);
+            resultSet.setFetchSize(rows);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateBinaryStream(final String columnName, final InputStream x, final int length) throws SQLException {
-        try {
-            resultSet.updateBinaryStream(columnName, x, length);
-        } catch (final SQLException e) {
-            handleException(e);
-        }
+    public String toString() {
+        return super.toString() + "[_res=" + resultSet + ", _stmt=" + statement + ", _conn=" + connection + "]";
     }
 
     @Override
-    public void updateCharacterStream(final String columnName, final Reader reader, final int length)
-            throws SQLException {
-        try {
-            resultSet.updateCharacterStream(columnName, reader, length);
-        } catch (final SQLException e) {
-            handleException(e);
+    public <T> T unwrap(final Class<T> iface) throws SQLException {
+        if (iface.isAssignableFrom(getClass())) {
+            return iface.cast(this);
+        } else if (iface.isAssignableFrom(resultSet.getClass())) {
+            return iface.cast(resultSet);
+        } else {
+            return resultSet.unwrap(iface);
         }
     }
 
     @Override
-    public void updateObject(final String columnName, final Object x, final int scale) throws SQLException {
+    public void updateArray(final int columnIndex, final Array x) throws SQLException {
         try {
-            resultSet.updateObject(columnName, x);
+            resultSet.updateArray(columnIndex, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateObject(final String columnName, final Object x) throws SQLException {
+    public void updateArray(final String columnName, final Array x) throws SQLException {
         try {
-            resultSet.updateObject(columnName, x);
+            resultSet.updateArray(columnName, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void insertRow() throws SQLException {
+    public void updateAsciiStream(final int columnIndex, final InputStream inputStream) throws SQLException {
         try {
-            resultSet.insertRow();
+            resultSet.updateAsciiStream(columnIndex, inputStream);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateRow() throws SQLException {
+    public void updateAsciiStream(final int columnIndex, final InputStream x, final int length) throws SQLException {
         try {
-            resultSet.updateRow();
+            resultSet.updateAsciiStream(columnIndex, x, length);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void deleteRow() throws SQLException {
+    public void updateAsciiStream(final int columnIndex, final InputStream inputStream, final long length)
+            throws SQLException {
         try {
-            resultSet.deleteRow();
+            resultSet.updateAsciiStream(columnIndex, inputStream, length);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void refreshRow() throws SQLException {
+    public void updateAsciiStream(final String columnLabel, final InputStream inputStream) throws SQLException {
         try {
-            resultSet.refreshRow();
+            resultSet.updateAsciiStream(columnLabel, inputStream);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void cancelRowUpdates() throws SQLException {
+    public void updateAsciiStream(final String columnName, final InputStream x, final int length) throws SQLException {
         try {
-            resultSet.cancelRowUpdates();
+            resultSet.updateAsciiStream(columnName, x, length);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void moveToInsertRow() throws SQLException {
+    public void updateAsciiStream(final String columnLabel, final InputStream inputStream, final long length)
+            throws SQLException {
         try {
-            resultSet.moveToInsertRow();
+            resultSet.updateAsciiStream(columnLabel, inputStream, length);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void moveToCurrentRow() throws SQLException {
+    public void updateBigDecimal(final int columnIndex, final BigDecimal x) throws SQLException {
         try {
-            resultSet.moveToCurrentRow();
+            resultSet.updateBigDecimal(columnIndex, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public Object getObject(final int i, final Map<String, Class<?>> map) throws SQLException {
+    public void updateBigDecimal(final String columnName, final BigDecimal x) throws SQLException {
         try {
-            return resultSet.getObject(i, map);
+            resultSet.updateBigDecimal(columnName, x);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public Ref getRef(final int i) throws SQLException {
+    public void updateBinaryStream(final int columnIndex, final InputStream inputStream) throws SQLException {
         try {
-            return resultSet.getRef(i);
+            resultSet.updateBinaryStream(columnIndex, inputStream);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public Blob getBlob(final int i) throws SQLException {
+    public void updateBinaryStream(final int columnIndex, final InputStream x, final int length) throws SQLException {
         try {
-            return resultSet.getBlob(i);
+            resultSet.updateBinaryStream(columnIndex, x, length);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public Clob getClob(final int i) throws SQLException {
+    public void updateBinaryStream(final int columnIndex, final InputStream inputStream, final long length)
+            throws SQLException {
         try {
-            return resultSet.getClob(i);
+            resultSet.updateBinaryStream(columnIndex, inputStream, length);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public Array getArray(final int i) throws SQLException {
+    public void updateBinaryStream(final String columnLabel, final InputStream inputStream) throws SQLException {
         try {
-            return resultSet.getArray(i);
+            resultSet.updateBinaryStream(columnLabel, inputStream);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public Object getObject(final String colName, final Map<String, Class<?>> map) throws SQLException {
+    public void updateBinaryStream(final String columnName, final InputStream x, final int length) throws SQLException {
         try {
-            return resultSet.getObject(colName, map);
+            resultSet.updateBinaryStream(columnName, x, length);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public Ref getRef(final String colName) throws SQLException {
+    public void updateBinaryStream(final String columnLabel, final InputStream inputStream, final long length)
+            throws SQLException {
         try {
-            return resultSet.getRef(colName);
+            resultSet.updateBinaryStream(columnLabel, inputStream, length);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public Blob getBlob(final String colName) throws SQLException {
+    public void updateBlob(final int columnIndex, final Blob x) throws SQLException {
         try {
-            return resultSet.getBlob(colName);
+            resultSet.updateBlob(columnIndex, x);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public Clob getClob(final String colName) throws SQLException {
+    public void updateBlob(final int columnIndex, final InputStream inputStream) throws SQLException {
         try {
-            return resultSet.getClob(colName);
+            resultSet.updateBlob(columnIndex, inputStream);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public Array getArray(final String colName) throws SQLException {
+    public void updateBlob(final int columnIndex, final InputStream inputStream, final long length)
+            throws SQLException {
         try {
-            return resultSet.getArray(colName);
+            resultSet.updateBlob(columnIndex, inputStream, length);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public Date getDate(final int columnIndex, final Calendar cal) throws SQLException {
+    public void updateBlob(final String columnName, final Blob x) throws SQLException {
         try {
-            return resultSet.getDate(columnIndex, cal);
+            resultSet.updateBlob(columnName, x);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public Date getDate(final String columnName, final Calendar cal) throws SQLException {
+    public void updateBlob(final String columnLabel, final InputStream inputStream) throws SQLException {
         try {
-            return resultSet.getDate(columnName, cal);
+            resultSet.updateBlob(columnLabel, inputStream);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public Time getTime(final int columnIndex, final Calendar cal) throws SQLException {
+    public void updateBlob(final String columnLabel, final InputStream inputStream, final long length)
+            throws SQLException {
         try {
-            return resultSet.getTime(columnIndex, cal);
+            resultSet.updateBlob(columnLabel, inputStream, length);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public Time getTime(final String columnName, final Calendar cal) throws SQLException {
+    public void updateBoolean(final int columnIndex, final boolean x) throws SQLException {
         try {
-            return resultSet.getTime(columnName, cal);
+            resultSet.updateBoolean(columnIndex, x);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public Timestamp getTimestamp(final int columnIndex, final Calendar cal) throws SQLException {
+    public void updateBoolean(final String columnName, final boolean x) throws SQLException {
         try {
-            return resultSet.getTimestamp(columnIndex, cal);
+            resultSet.updateBoolean(columnName, x);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public Timestamp getTimestamp(final String columnName, final Calendar cal) throws SQLException {
+    public void updateByte(final int columnIndex, final byte x) throws SQLException {
         try {
-            return resultSet.getTimestamp(columnName, cal);
+            resultSet.updateByte(columnIndex, x);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public java.net.URL getURL(final int columnIndex) throws SQLException {
+    public void updateByte(final String columnName, final byte x) throws SQLException {
         try {
-            return resultSet.getURL(columnIndex);
+            resultSet.updateByte(columnName, x);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public java.net.URL getURL(final String columnName) throws SQLException {
+    public void updateBytes(final int columnIndex, final byte[] x) throws SQLException {
         try {
-            return resultSet.getURL(columnName);
+            resultSet.updateBytes(columnIndex, x);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public void updateRef(final int columnIndex, final Ref x) throws SQLException {
+    public void updateBytes(final String columnName, final byte[] x) throws SQLException {
         try {
-            resultSet.updateRef(columnIndex, x);
+            resultSet.updateBytes(columnName, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateRef(final String columnName, final Ref x) throws SQLException {
+    public void updateCharacterStream(final int columnIndex, final Reader reader) throws SQLException {
         try {
-            resultSet.updateRef(columnName, x);
+            resultSet.updateCharacterStream(columnIndex, reader);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateBlob(final int columnIndex, final Blob x) throws SQLException {
+    public void updateCharacterStream(final int columnIndex, final Reader x, final int length) throws SQLException {
         try {
-            resultSet.updateBlob(columnIndex, x);
+            resultSet.updateCharacterStream(columnIndex, x, length);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateBlob(final String columnName, final Blob x) throws SQLException {
+    public void updateCharacterStream(final int columnIndex, final Reader reader, final long length)
+            throws SQLException {
         try {
-            resultSet.updateBlob(columnName, x);
+            resultSet.updateCharacterStream(columnIndex, reader, length);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateClob(final int columnIndex, final Clob x) throws SQLException {
+    public void updateCharacterStream(final String columnLabel, final Reader reader) throws SQLException {
         try {
-            resultSet.updateClob(columnIndex, x);
+            resultSet.updateCharacterStream(columnLabel, reader);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateClob(final String columnName, final Clob x) throws SQLException {
+    public void updateCharacterStream(final String columnName, final Reader reader, final int length)
+            throws SQLException {
         try {
-            resultSet.updateClob(columnName, x);
+            resultSet.updateCharacterStream(columnName, reader, length);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateArray(final int columnIndex, final Array x) throws SQLException {
+    public void updateCharacterStream(final String columnLabel, final Reader reader, final long length)
+            throws SQLException {
         try {
-            resultSet.updateArray(columnIndex, x);
+            resultSet.updateCharacterStream(columnLabel, reader, length);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateArray(final String columnName, final Array x) throws SQLException {
+    public void updateClob(final int columnIndex, final Clob x) throws SQLException {
         try {
-            resultSet.updateArray(columnName, x);
+            resultSet.updateClob(columnIndex, x);
         } catch (final SQLException e) {
             handleException(e);
         }
-    }
-
-    @Override
-    public boolean isWrapperFor(final Class<?> iface) throws SQLException {
-        if (iface.isAssignableFrom(getClass())) {
-            return true;
-        } else if (iface.isAssignableFrom(resultSet.getClass())) {
-            return true;
-        } else {
-            return resultSet.isWrapperFor(iface);
+    }
+
+    @Override
+    public void updateClob(final int columnIndex, final Reader reader) throws SQLException {
+        try {
+            resultSet.updateClob(columnIndex, reader);
+        } catch (final SQLException e) {
+            handleException(e);
         }
     }
 
     @Override
-    public <T> T unwrap(final Class<T> iface) throws SQLException {
-        if (iface.isAssignableFrom(getClass())) {
-            return iface.cast(this);
-        } else if (iface.isAssignableFrom(resultSet.getClass())) {
-            return iface.cast(resultSet);
-        } else {
-            return resultSet.unwrap(iface);
+    public void updateClob(final int columnIndex, final Reader reader, final long length) throws SQLException {
+        try {
+            resultSet.updateClob(columnIndex, reader, length);
+        } catch (final SQLException e) {
+            handleException(e);
         }
     }
 
     @Override
-    public RowId getRowId(final int columnIndex) throws SQLException {
+    public void updateClob(final String columnName, final Clob x) throws SQLException {
         try {
-            return resultSet.getRowId(columnIndex);
+            resultSet.updateClob(columnName, x);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public RowId getRowId(final String columnLabel) throws SQLException {
+    public void updateClob(final String columnLabel, final Reader reader) throws SQLException {
         try {
-            return resultSet.getRowId(columnLabel);
+            resultSet.updateClob(columnLabel, reader);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public void updateRowId(final int columnIndex, final RowId value) throws SQLException {
+    public void updateClob(final String columnLabel, final Reader reader, final long length) throws SQLException {
         try {
-            resultSet.updateRowId(columnIndex, value);
+            resultSet.updateClob(columnLabel, reader, length);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateRowId(final String columnLabel, final RowId value) throws SQLException {
+    public void updateDate(final int columnIndex, final Date x) throws SQLException {
         try {
-            resultSet.updateRowId(columnLabel, value);
+            resultSet.updateDate(columnIndex, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public int getHoldability() throws SQLException {
+    public void updateDate(final String columnName, final Date x) throws SQLException {
         try {
-            return resultSet.getHoldability();
+            resultSet.updateDate(columnName, x);
         } catch (final SQLException e) {
             handleException(e);
-            return 0;
         }
     }
 
     @Override
-    public boolean isClosed() throws SQLException {
+    public void updateDouble(final int columnIndex, final double x) throws SQLException {
         try {
-            return resultSet.isClosed();
+            resultSet.updateDouble(columnIndex, x);
         } catch (final SQLException e) {
             handleException(e);
-            return false;
         }
     }
 
     @Override
-    public void updateNString(final int columnIndex, final String value) throws SQLException {
+    public void updateDouble(final String columnName, final double x) throws SQLException {
         try {
-            resultSet.updateNString(columnIndex, value);
+            resultSet.updateDouble(columnName, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateNString(final String columnLabel, final String value) throws SQLException {
+    public void updateFloat(final int columnIndex, final float x) throws SQLException {
         try {
-            resultSet.updateNString(columnLabel, value);
+            resultSet.updateFloat(columnIndex, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateNClob(final int columnIndex, final NClob value) throws SQLException {
+    public void updateFloat(final String columnName, final float x) throws SQLException {
         try {
-            resultSet.updateNClob(columnIndex, value);
+            resultSet.updateFloat(columnName, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateNClob(final String columnLabel, final NClob value) throws SQLException {
+    public void updateInt(final int columnIndex, final int x) throws SQLException {
         try {
-            resultSet.updateNClob(columnLabel, value);
+            resultSet.updateInt(columnIndex, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public NClob getNClob(final int columnIndex) throws SQLException {
+    public void updateInt(final String columnName, final int x) throws SQLException {
         try {
-            return resultSet.getNClob(columnIndex);
+            resultSet.updateInt(columnName, x);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public NClob getNClob(final String columnLabel) throws SQLException {
+    public void updateLong(final int columnIndex, final long x) throws SQLException {
         try {
-            return resultSet.getNClob(columnLabel);
+            resultSet.updateLong(columnIndex, x);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public SQLXML getSQLXML(final int columnIndex) throws SQLException {
+    public void updateLong(final String columnName, final long x) throws SQLException {
         try {
-            return resultSet.getSQLXML(columnIndex);
+            resultSet.updateLong(columnName, x);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public SQLXML getSQLXML(final String columnLabel) throws SQLException {
+    public void updateNCharacterStream(final int columnIndex, final Reader reader) throws SQLException {
         try {
-            return resultSet.getSQLXML(columnLabel);
+            resultSet.updateNCharacterStream(columnIndex, reader);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public void updateSQLXML(final int columnIndex, final SQLXML value) throws SQLException {
+    public void updateNCharacterStream(final int columnIndex, final Reader reader, final long length)
+            throws SQLException {
         try {
-            resultSet.updateSQLXML(columnIndex, value);
+            resultSet.updateNCharacterStream(columnIndex, reader, length);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateSQLXML(final String columnLabel, final SQLXML value) throws SQLException {
+    public void updateNCharacterStream(final String columnLabel, final Reader reader) throws SQLException {
         try {
-            resultSet.updateSQLXML(columnLabel, value);
+            resultSet.updateNCharacterStream(columnLabel, reader);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public String getNString(final int columnIndex) throws SQLException {
+    public void updateNCharacterStream(final String columnLabel, final Reader reader, final long length)
+            throws SQLException {
         try {
-            return resultSet.getNString(columnIndex);
+            resultSet.updateNCharacterStream(columnLabel, reader, length);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public String getNString(final String columnLabel) throws SQLException {
+    public void updateNClob(final int columnIndex, final NClob value) throws SQLException {
         try {
-            return resultSet.getNString(columnLabel);
+            resultSet.updateNClob(columnIndex, value);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public Reader getNCharacterStream(final int columnIndex) throws SQLException {
+    public void updateNClob(final int columnIndex, final Reader reader) throws SQLException {
         try {
-            return resultSet.getNCharacterStream(columnIndex);
+            resultSet.updateNClob(columnIndex, reader);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public Reader getNCharacterStream(final String columnLabel) throws SQLException {
+    public void updateNClob(final int columnIndex, final Reader reader, final long length) throws SQLException {
         try {
-            return resultSet.getNCharacterStream(columnLabel);
+            resultSet.updateNClob(columnIndex, reader, length);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public void updateNCharacterStream(final int columnIndex, final Reader reader, final long length)
-            throws SQLException {
+    public void updateNClob(final String columnLabel, final NClob value) throws SQLException {
         try {
-            resultSet.updateNCharacterStream(columnIndex, reader, length);
+            resultSet.updateNClob(columnLabel, value);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateNCharacterStream(final String columnLabel, final Reader reader, final long length)
-            throws SQLException {
+    public void updateNClob(final String columnLabel, final Reader reader) throws SQLException {
         try {
-            resultSet.updateNCharacterStream(columnLabel, reader, length);
+            resultSet.updateNClob(columnLabel, reader);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateAsciiStream(final int columnIndex, final InputStream inputStream, final long length)
-            throws SQLException {
+    public void updateNClob(final String columnLabel, final Reader reader, final long length) throws SQLException {
         try {
-            resultSet.updateAsciiStream(columnIndex, inputStream, length);
+            resultSet.updateNClob(columnLabel, reader, length);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateBinaryStream(final int columnIndex, final InputStream inputStream, final long length)
-            throws SQLException {
+    public void updateNString(final int columnIndex, final String value) throws SQLException {
         try {
-            resultSet.updateBinaryStream(columnIndex, inputStream, length);
+            resultSet.updateNString(columnIndex, value);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateCharacterStream(final int columnIndex, final Reader reader, final long length)
-            throws SQLException {
+    public void updateNString(final String columnLabel, final String value) throws SQLException {
         try {
-            resultSet.updateCharacterStream(columnIndex, reader, length);
+            resultSet.updateNString(columnLabel, value);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateAsciiStream(final String columnLabel, final InputStream inputStream, final long length)
-            throws SQLException {
+    public void updateNull(final int columnIndex) throws SQLException {
         try {
-            resultSet.updateAsciiStream(columnLabel, inputStream, length);
+            resultSet.updateNull(columnIndex);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateBinaryStream(final String columnLabel, final InputStream inputStream, final long length)
-            throws SQLException {
+    public void updateNull(final String columnName) throws SQLException {
         try {
-            resultSet.updateBinaryStream(columnLabel, inputStream, length);
+            resultSet.updateNull(columnName);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateCharacterStream(final String columnLabel, final Reader reader, final long length)
-            throws SQLException {
+    public void updateObject(final int columnIndex, final Object x) throws SQLException {
         try {
-            resultSet.updateCharacterStream(columnLabel, reader, length);
+            resultSet.updateObject(columnIndex, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateBlob(final int columnIndex, final InputStream inputStream, final long length)
-            throws SQLException {
+    public void updateObject(final int columnIndex, final Object x, final int scale) throws SQLException {
         try {
-            resultSet.updateBlob(columnIndex, inputStream, length);
+            resultSet.updateObject(columnIndex, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
+    /**
+     * @since 2.5.0
+     */
     @Override
-    public void updateBlob(final String columnLabel, final InputStream inputStream, final long length)
-            throws SQLException {
+    public void updateObject(final int columnIndex, final Object x, final SQLType targetSqlType) throws SQLException {
         try {
-            resultSet.updateBlob(columnLabel, inputStream, length);
+            resultSet.updateObject(columnIndex, x, targetSqlType);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
+    /**
+     * @since 2.5.0
+     */
     @Override
-    public void updateClob(final int columnIndex, final Reader reader, final long length) throws SQLException {
+    public void updateObject(final int columnIndex, final Object x, final SQLType targetSqlType, final int scaleOrLength) throws SQLException {
         try {
-            resultSet.updateClob(columnIndex, reader, length);
+            resultSet.updateObject(columnIndex, x, targetSqlType, scaleOrLength);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateClob(final String columnLabel, final Reader reader, final long length) throws SQLException {
+    public void updateObject(final String columnName, final Object x) throws SQLException {
         try {
-            resultSet.updateClob(columnLabel, reader, length);
+            resultSet.updateObject(columnName, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateNClob(final int columnIndex, final Reader reader, final long length) throws SQLException {
+    public void updateObject(final String columnName, final Object x, final int scale) throws SQLException {
         try {
-            resultSet.updateNClob(columnIndex, reader, length);
+            resultSet.updateObject(columnName, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
+    /**
+     * @since 2.5.0
+     */
     @Override
-    public void updateNClob(final String columnLabel, final Reader reader, final long length) throws SQLException {
+    public void updateObject(final String columnLabel, final Object x, final SQLType targetSqlType) throws SQLException {
         try {
-            resultSet.updateNClob(columnLabel, reader, length);
+            resultSet.updateObject(columnLabel, x, targetSqlType);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
+    /**
+     * @since 2.5.0
+     */
     @Override
-    public void updateNCharacterStream(final int columnIndex, final Reader reader) throws SQLException {
+    public void updateObject(final String columnLabel, final Object x, final SQLType targetSqlType, final int scaleOrLength)
+            throws SQLException {
         try {
-            resultSet.updateNCharacterStream(columnIndex, reader);
+            resultSet.updateObject(columnLabel, x, targetSqlType, scaleOrLength);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateNCharacterStream(final String columnLabel, final Reader reader) throws SQLException {
+    public void updateRef(final int columnIndex, final Ref x) throws SQLException {
         try {
-            resultSet.updateNCharacterStream(columnLabel, reader);
+            resultSet.updateRef(columnIndex, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateAsciiStream(final int columnIndex, final InputStream inputStream) throws SQLException {
+    public void updateRef(final String columnName, final Ref x) throws SQLException {
         try {
-            resultSet.updateAsciiStream(columnIndex, inputStream);
+            resultSet.updateRef(columnName, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateBinaryStream(final int columnIndex, final InputStream inputStream) throws SQLException {
+    public void updateRow() throws SQLException {
         try {
-            resultSet.updateBinaryStream(columnIndex, inputStream);
+            resultSet.updateRow();
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateCharacterStream(final int columnIndex, final Reader reader) throws SQLException {
+    public void updateRowId(final int columnIndex, final RowId value) throws SQLException {
         try {
-            resultSet.updateCharacterStream(columnIndex, reader);
+            resultSet.updateRowId(columnIndex, value);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateAsciiStream(final String columnLabel, final InputStream inputStream) throws SQLException {
+    public void updateRowId(final String columnLabel, final RowId value) throws SQLException {
         try {
-            resultSet.updateAsciiStream(columnLabel, inputStream);
+            resultSet.updateRowId(columnLabel, value);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateBinaryStream(final String columnLabel, final InputStream inputStream) throws SQLException {
+    public void updateShort(final int columnIndex, final short x) throws SQLException {
         try {
-            resultSet.updateBinaryStream(columnLabel, inputStream);
+            resultSet.updateShort(columnIndex, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateCharacterStream(final String columnLabel, final Reader reader) throws SQLException {
+    public void updateShort(final String columnName, final short x) throws SQLException {
         try {
-            resultSet.updateCharacterStream(columnLabel, reader);
+            resultSet.updateShort(columnName, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateBlob(final int columnIndex, final InputStream inputStream) throws SQLException {
+    public void updateSQLXML(final int columnIndex, final SQLXML value) throws SQLException {
         try {
-            resultSet.updateBlob(columnIndex, inputStream);
+            resultSet.updateSQLXML(columnIndex, value);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateBlob(final String columnLabel, final InputStream inputStream) throws SQLException {
+    public void updateSQLXML(final String columnLabel, final SQLXML value) throws SQLException {
         try {
-            resultSet.updateBlob(columnLabel, inputStream);
+            resultSet.updateSQLXML(columnLabel, value);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateClob(final int columnIndex, final Reader reader) throws SQLException {
+    public void updateString(final int columnIndex, final String x) throws SQLException {
         try {
-            resultSet.updateClob(columnIndex, reader);
+            resultSet.updateString(columnIndex, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateClob(final String columnLabel, final Reader reader) throws SQLException {
+    public void updateString(final String columnName, final String x) throws SQLException {
         try {
-            resultSet.updateClob(columnLabel, reader);
+            resultSet.updateString(columnName, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateNClob(final int columnIndex, final Reader reader) throws SQLException {
+    public void updateTime(final int columnIndex, final Time x) throws SQLException {
         try {
-            resultSet.updateNClob(columnIndex, reader);
+            resultSet.updateTime(columnIndex, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateNClob(final String columnLabel, final Reader reader) throws SQLException {
+    public void updateTime(final String columnName, final Time x) throws SQLException {
         try {
-            resultSet.updateNClob(columnLabel, reader);
+            resultSet.updateTime(columnName, x);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public <T> T getObject(final int columnIndex, final Class<T> type) throws SQLException {
+    public void updateTimestamp(final int columnIndex, final Timestamp x) throws SQLException {
         try {
-            return resultSet.getObject(columnIndex, type);
+            resultSet.updateTimestamp(columnIndex, x);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public <T> T getObject(final String columnLabel, final Class<T> type) throws SQLException {
+    public void updateTimestamp(final String columnName, final Timestamp x) throws SQLException {
         try {
-            return resultSet.getObject(columnLabel, type);
+            resultSet.updateTimestamp(columnName, x);
         } catch (final SQLException e) {
             handleException(e);
-            return null;
         }
     }
 
     @Override
-    public String toString() {
-        return super.toString() + "[_res=" + resultSet + ", _stmt=" + statement + ", _conn=" + connection + "]";
+    public boolean wasNull() throws SQLException {
+        try {
+            return resultSet.wasNull();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 }

==================================================
DriverConnectionFactory.java
index fffc70f031..631aa5a19d 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/DelegatingStatement.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/DelegatingStatement.java
@@ -42,6 +42,8 @@ public class DelegatingStatement extends AbandonedTrace implements Statement {
     /** The connection that created me. **/
     private DelegatingConnection<?> connection;
 
+    private boolean closed = false;
+
     /**
      * Create a wrapper for the Statement which traces this Statement to the Connection which created it and the code
      * which created it.
@@ -58,65 +60,60 @@ public class DelegatingStatement extends AbandonedTrace implements Statement {
     }
 
     /**
-     * Returns my underlying {@link Statement}.
      *
-     * @return my underlying {@link Statement}.
-     * @see #getInnermostDelegate
+     * @throws SQLException
+     *             thrown by the delegating statement.
+     * @since 2.4.0 made public, was protected in 2.3.0.
      */
-    public Statement getDelegate() {
-        return statement;
+    public void activate() throws SQLException {
+        if (statement instanceof DelegatingStatement) {
+            ((DelegatingStatement) statement).activate();
+        }
     }
 
-    /**
-     * If my underlying {@link Statement} is not a {@code DelegatingStatement}, returns it, otherwise recursively
-     * invokes this method on my delegate.
-     * <p>
-     * Hence this method will return the first delegate that is not a {@code DelegatingStatement} or {@code null} when
-     * no non-{@code DelegatingStatement} delegate can be found by traversing this chain.
-     * </p>
-     * <p>
-     * This method is useful when you may have nested {@code DelegatingStatement}s, and you want to make sure to obtain
-     * a "genuine" {@link Statement}.
-     * </p>
-     *
-     * @return The innermost delegate.
-     *
-     * @see #getDelegate
-     */
-    public Statement getInnermostDelegate() {
-        Statement s = statement;
-        while (s != null && s instanceof DelegatingStatement) {
-            s = ((DelegatingStatement) s).getDelegate();
-            if (this == s) {
-                return null;
-            }
+    @Override
+    public void addBatch(final String sql) throws SQLException {
+        checkOpen();
+        try {
+            statement.addBatch(sql);
+        } catch (final SQLException e) {
+            handleException(e);
         }
-        return s;
     }
 
-    /**
-     * Sets my delegate.
-     *
-     * @param statement
-     *            my delegate.
-     */
-    public void setDelegate(final Statement statement) {
-        this.statement = statement;
+    @Override
+    public void cancel() throws SQLException {
+        checkOpen();
+        try {
+            statement.cancel();
+        } catch (final SQLException e) {
+            handleException(e);
+        }
     }
 
-    private boolean closed = false;
-
-    protected boolean isClosedInternal() {
-        return closed;
+    protected void checkOpen() throws SQLException {
+        if (isClosed()) {
+            throw new SQLException(this.getClass().getName() + " with address: \"" + this.toString() + "\" is closed.");
+        }
     }
 
-    protected void setClosedInternal(final boolean closed) {
-        this.closed = closed;
+    @Override
+    public void clearBatch() throws SQLException {
+        checkOpen();
+        try {
+            statement.clearBatch();
+        } catch (final SQLException e) {
+            handleException(e);
+        }
     }
 
-    protected void checkOpen() throws SQLException {
-        if (isClosed()) {
-            throw new SQLException(this.getClass().getName() + " with address: \"" + this.toString() + "\" is closed.");
+    @Override
+    public void clearWarnings() throws SQLException {
+        checkOpen();
+        try {
+            statement.clearWarnings();
+        } catch (final SQLException e) {
+            handleException(e);
         }
     }
 
@@ -160,113 +157,169 @@ public class DelegatingStatement extends AbandonedTrace implements Statement {
         }
     }
 
-    protected void handleException(final SQLException e) throws SQLException {
-        if (connection != null) {
-            connection.handleException(e);
-        } else {
-            throw e;
+    @Override
+    public void closeOnCompletion() throws SQLException {
+        checkOpen();
+        try {
+            statement.closeOnCompletion();
+        } catch (final SQLException e) {
+            handleException(e);
         }
     }
 
-    /**
-     *
-     * @throws SQLException
-     *             thrown by the delegating statement.
-     * @since 2.4.0 made public, was protected in 2.3.0.
-     */
-    public void activate() throws SQLException {
-        if (statement instanceof DelegatingStatement) {
-            ((DelegatingStatement) statement).activate();
+    @Override
+    public boolean execute(final String sql) throws SQLException {
+        checkOpen();
+        setLastUsedInParent();
+        try {
+            return statement.execute(sql);
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
         }
     }
 
-    /**
-     *
-     * @throws SQLException
-     *             thrown by the delegating statement.
-     * @since 2.4.0 made public, was protected in 2.3.0.
-     */
-    public void passivate() throws SQLException {
-        if (statement instanceof DelegatingStatement) {
-            ((DelegatingStatement) statement).passivate();
+    @Override
+    public boolean execute(final String sql, final int autoGeneratedKeys) throws SQLException {
+        checkOpen();
+        setLastUsedInParent();
+        try {
+            return statement.execute(sql, autoGeneratedKeys);
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
         }
     }
 
     @Override
-    public Connection getConnection() throws SQLException {
+    public boolean execute(final String sql, final int columnIndexes[]) throws SQLException {
         checkOpen();
-        return getConnectionInternal(); // return the delegating connection that created this
+        setLastUsedInParent();
+        try {
+            return statement.execute(sql, columnIndexes);
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
-    protected DelegatingConnection<?> getConnectionInternal() {
-        return connection;
+    @Override
+    public boolean execute(final String sql, final String columnNames[]) throws SQLException {
+        checkOpen();
+        setLastUsedInParent();
+        try {
+            return statement.execute(sql, columnNames);
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
-    public ResultSet executeQuery(final String sql) throws SQLException {
+    public int[] executeBatch() throws SQLException {
         checkOpen();
-        if (connection != null) {
-            connection.setLastUsed();
-        }
+        setLastUsedInParent();
         try {
-            return DelegatingResultSet.wrapResultSet(this, statement.executeQuery(sql));
+            return statement.executeBatch();
         } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
         }
     }
 
+    /**
+     * @since 2.5.0
+     */
     @Override
-    public ResultSet getResultSet() throws SQLException {
+    public long[] executeLargeBatch() throws SQLException {
         checkOpen();
+        setLastUsedInParent();
         try {
-            return DelegatingResultSet.wrapResultSet(this, statement.getResultSet());
+            return statement.executeLargeBatch();
         } catch (final SQLException e) {
             handleException(e);
-            throw new AssertionError();
+            return null;
         }
     }
 
+    /**
+     * @since 2.5.0
+     */
     @Override
-    public int executeUpdate(final String sql) throws SQLException {
+    public long executeLargeUpdate(final String sql) throws SQLException {
         checkOpen();
-        if (connection != null) {
-            connection.setLastUsed();
+        setLastUsedInParent();
+        try {
+            return statement.executeLargeUpdate(sql);
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
         }
+    }
+
+    /**
+     * @since 2.5.0
+     */
+    @Override
+    public long executeLargeUpdate(final String sql, final int autoGeneratedKeys) throws SQLException {
+        checkOpen();
+        setLastUsedInParent();
         try {
-            return statement.executeUpdate(sql);
+            return statement.executeLargeUpdate(sql, autoGeneratedKeys);
         } catch (final SQLException e) {
             handleException(e);
             return 0;
         }
     }
 
+    /**
+     * @since 2.5.0
+     */
     @Override
-    public int getMaxFieldSize() throws SQLException {
+    public long executeLargeUpdate(final String sql, final int[] columnIndexes) throws SQLException {
         checkOpen();
+        setLastUsedInParent();
         try {
-            return statement.getMaxFieldSize();
+            return statement.executeLargeUpdate(sql, columnIndexes);
         } catch (final SQLException e) {
             handleException(e);
             return 0;
         }
     }
 
+    /**
+     * @since 2.5.0
+     */
     @Override
-    public void setMaxFieldSize(final int max) throws SQLException {
+    public long executeLargeUpdate(final String sql, final String[] columnNames) throws SQLException {
         checkOpen();
+        setLastUsedInParent();
         try {
-            statement.setMaxFieldSize(max);
+            return statement.executeLargeUpdate(sql, columnNames);
         } catch (final SQLException e) {
             handleException(e);
+            return 0;
         }
     }
 
     @Override
-    public int getMaxRows() throws SQLException {
+    public ResultSet executeQuery(final String sql) throws SQLException {
         checkOpen();
+        setLastUsedInParent();
         try {
-            return statement.getMaxRows();
+            return DelegatingResultSet.wrapResultSet(this, statement.executeQuery(sql));
+        } catch (final SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public int executeUpdate(final String sql) throws SQLException {
+        checkOpen();
+        setLastUsedInParent();
+        try {
+            return statement.executeUpdate(sql);
         } catch (final SQLException e) {
             handleException(e);
             return 0;
@@ -274,30 +327,35 @@ public class DelegatingStatement extends AbandonedTrace implements Statement {
     }
 
     @Override
-    public void setMaxRows(final int max) throws SQLException {
+    public int executeUpdate(final String sql, final int autoGeneratedKeys) throws SQLException {
         checkOpen();
+        setLastUsedInParent();
         try {
-            statement.setMaxRows(max);
+            return statement.executeUpdate(sql, autoGeneratedKeys);
         } catch (final SQLException e) {
             handleException(e);
+            return 0;
         }
     }
 
     @Override
-    public void setEscapeProcessing(final boolean enable) throws SQLException {
+    public int executeUpdate(final String sql, final int columnIndexes[]) throws SQLException {
         checkOpen();
+        setLastUsedInParent();
         try {
-            statement.setEscapeProcessing(enable);
+            return statement.executeUpdate(sql, columnIndexes);
         } catch (final SQLException e) {
             handleException(e);
+            return 0;
         }
     }
 
     @Override
-    public int getQueryTimeout() throws SQLException {
+    public int executeUpdate(final String sql, final String columnNames[]) throws SQLException {
         checkOpen();
+        setLastUsedInParent();
         try {
-            return statement.getQueryTimeout();
+            return statement.executeUpdate(sql, columnNames);
         } catch (final SQLException e) {
             handleException(e);
             return 0;
@@ -305,75 +363,144 @@ public class DelegatingStatement extends AbandonedTrace implements Statement {
     }
 
     @Override
-    public void setQueryTimeout(final int seconds) throws SQLException {
+    protected void finalize() throws Throwable {
+        // This is required because of statement pooling. The poolable
+        // statements will always be strongly held by the statement pool. If the
+        // delegating statements that wrap the poolable statement are not
+        // strongly held they will be garbage collected but at that point the
+        // poolable statements need to be returned to the pool else there will
+        // be a leak of statements from the pool. Closing this statement will
+        // close all the wrapped statements and return any poolable statements
+        // to the pool.
+        close();
+        super.finalize();
+    }
+
+    @Override
+    public Connection getConnection() throws SQLException {
+        checkOpen();
+        return getConnectionInternal(); // return the delegating connection that created this
+    }
+
+    protected DelegatingConnection<?> getConnectionInternal() {
+        return connection;
+    }
+
+    /**
+     * Returns my underlying {@link Statement}.
+     *
+     * @return my underlying {@link Statement}.
+     * @see #getInnermostDelegate
+     */
+    public Statement getDelegate() {
+        return statement;
+    }
+
+    @Override
+    public int getFetchDirection() throws SQLException {
         checkOpen();
         try {
-            statement.setQueryTimeout(seconds);
+            return statement.getFetchDirection();
         } catch (final SQLException e) {
             handleException(e);
+            return 0;
         }
     }
 
     @Override
-    public void cancel() throws SQLException {
+    public int getFetchSize() throws SQLException {
         checkOpen();
         try {
-            statement.cancel();
+            return statement.getFetchSize();
         } catch (final SQLException e) {
             handleException(e);
+            return 0;
         }
     }
 
     @Override
-    public SQLWarning getWarnings() throws SQLException {
+    public ResultSet getGeneratedKeys() throws SQLException {
         checkOpen();
         try {
-            return statement.getWarnings();
+            return DelegatingResultSet.wrapResultSet(this, statement.getGeneratedKeys());
         } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
         }
     }
 
+    /**
+     * If my underlying {@link Statement} is not a {@code DelegatingStatement}, returns it, otherwise recursively
+     * invokes this method on my delegate.
+     * <p>
+     * Hence this method will return the first delegate that is not a {@code DelegatingStatement} or {@code null} when
+     * no non-{@code DelegatingStatement} delegate can be found by traversing this chain.
+     * </p>
+     * <p>
+     * This method is useful when you may have nested {@code DelegatingStatement}s, and you want to make sure to obtain
+     * a "genuine" {@link Statement}.
+     * </p>
+     *
+     * @return The innermost delegate.
+     *
+     * @see #getDelegate
+     */
+    @SuppressWarnings("resource")
+    public Statement getInnermostDelegate() {
+        Statement s = statement;
+        while (s != null && s instanceof DelegatingStatement) {
+            s = ((DelegatingStatement) s).getDelegate();
+            if (this == s) {
+                return null;
+            }
+        }
+        return s;
+    }
+
+    /**
+     * @since 2.5.0
+     */
     @Override
-    public void clearWarnings() throws SQLException {
+    public long getLargeMaxRows() throws SQLException {
         checkOpen();
         try {
-            statement.clearWarnings();
+            return statement.getLargeMaxRows();
         } catch (final SQLException e) {
             handleException(e);
+            return 0;
         }
     }
 
+    /**
+     * @since 2.5.0
+     */
     @Override
-    public void setCursorName(final String name) throws SQLException {
+    public long getLargeUpdateCount() throws SQLException {
         checkOpen();
         try {
-            statement.setCursorName(name);
+            return statement.getLargeUpdateCount();
         } catch (final SQLException e) {
             handleException(e);
+            return 0;
         }
     }
 
     @Override
-    public boolean execute(final String sql) throws SQLException {
+    public int getMaxFieldSize() throws SQLException {
         checkOpen();
-        if (connection != null) {
-            connection.setLastUsed();
-        }
         try {
-            return statement.execute(sql);
+            return statement.getMaxFieldSize();
         } catch (final SQLException e) {
             handleException(e);
-            return false;
+            return 0;
         }
     }
 
     @Override
-    public int getUpdateCount() throws SQLException {
+    public int getMaxRows() throws SQLException {
         checkOpen();
         try {
-            return statement.getUpdateCount();
+            return statement.getMaxRows();
         } catch (final SQLException e) {
             handleException(e);
             return 0;
@@ -392,20 +519,21 @@ public class DelegatingStatement extends AbandonedTrace implements Statement {
     }
 
     @Override
-    public void setFetchDirection(final int direction) throws SQLException {
+    public boolean getMoreResults(final int current) throws SQLException {
         checkOpen();
         try {
-            statement.setFetchDirection(direction);
+            return statement.getMoreResults(current);
         } catch (final SQLException e) {
             handleException(e);
+            return false;
         }
     }
 
     @Override
-    public int getFetchDirection() throws SQLException {
+    public int getQueryTimeout() throws SQLException {
         checkOpen();
         try {
-            return statement.getFetchDirection();
+            return statement.getQueryTimeout();
         } catch (final SQLException e) {
             handleException(e);
             return 0;
@@ -413,20 +541,21 @@ public class DelegatingStatement extends AbandonedTrace implements Statement {
     }
 
     @Override
-    public void setFetchSize(final int rows) throws SQLException {
+    public ResultSet getResultSet() throws SQLException {
         checkOpen();
         try {
-            statement.setFetchSize(rows);
+            return DelegatingResultSet.wrapResultSet(this, statement.getResultSet());
         } catch (final SQLException e) {
             handleException(e);
+            throw new AssertionError();
         }
     }
 
     @Override
-    public int getFetchSize() throws SQLException {
+    public int getResultSetConcurrency() throws SQLException {
         checkOpen();
         try {
-            return statement.getFetchSize();
+            return statement.getResultSetConcurrency();
         } catch (final SQLException e) {
             handleException(e);
             return 0;
@@ -434,10 +563,10 @@ public class DelegatingStatement extends AbandonedTrace implements Statement {
     }
 
     @Override
-    public int getResultSetConcurrency() throws SQLException {
+    public int getResultSetHoldability() throws SQLException {
         checkOpen();
         try {
-            return statement.getResultSetConcurrency();
+            return statement.getResultSetHoldability();
         } catch (final SQLException e) {
             handleException(e);
             return 0;
@@ -456,54 +585,52 @@ public class DelegatingStatement extends AbandonedTrace implements Statement {
     }
 
     @Override
-    public void addBatch(final String sql) throws SQLException {
+    public int getUpdateCount() throws SQLException {
         checkOpen();
         try {
-            statement.addBatch(sql);
+            return statement.getUpdateCount();
         } catch (final SQLException e) {
             handleException(e);
+            return 0;
         }
     }
 
     @Override
-    public void clearBatch() throws SQLException {
+    public SQLWarning getWarnings() throws SQLException {
         checkOpen();
         try {
-            statement.clearBatch();
+            return statement.getWarnings();
         } catch (final SQLException e) {
             handleException(e);
+            throw new AssertionError();
         }
     }
 
-    @Override
-    public int[] executeBatch() throws SQLException {
-        checkOpen();
+    protected void handleException(final SQLException e) throws SQLException {
         if (connection != null) {
-            connection.setLastUsed();
-        }
-        try {
-            return statement.executeBatch();
-        } catch (final SQLException e) {
-            handleException(e);
-            throw new AssertionError();
+            connection.handleException(e);
+        } else {
+            throw e;
         }
     }
 
-    /**
-     * Returns a String representation of this object.
-     *
-     * @return String
+    /*
+     * Note was protected prior to JDBC 4
      */
     @Override
-    public String toString() {
-        return statement == null ? "NULL" : statement.toString();
+    public boolean isClosed() throws SQLException {
+        return closed;
+    }
+
+    protected boolean isClosedInternal() {
+        return closed;
     }
 
     @Override
-    public boolean getMoreResults(final int current) throws SQLException {
+    public boolean isCloseOnCompletion() throws SQLException {
         checkOpen();
         try {
-            return statement.getMoreResults(current);
+            return statement.isCloseOnCompletion();
         } catch (final SQLException e) {
             handleException(e);
             return false;
@@ -511,194 +638,170 @@ public class DelegatingStatement extends AbandonedTrace implements Statement {
     }
 
     @Override
-    public ResultSet getGeneratedKeys() throws SQLException {
+    public boolean isPoolable() throws SQLException {
         checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(this, statement.getGeneratedKeys());
+            return statement.isPoolable();
         } catch (final SQLException e) {
             handleException(e);
-            throw new AssertionError();
+            return false;
         }
     }
 
     @Override
-    public int executeUpdate(final String sql, final int autoGeneratedKeys) throws SQLException {
-        checkOpen();
-        if (connection != null) {
-            connection.setLastUsed();
-        }
-        try {
-            return statement.executeUpdate(sql, autoGeneratedKeys);
-        } catch (final SQLException e) {
-            handleException(e);
-            return 0;
+    public boolean isWrapperFor(final Class<?> iface) throws SQLException {
+        if (iface.isAssignableFrom(getClass())) {
+            return true;
+        } else if (iface.isAssignableFrom(statement.getClass())) {
+            return true;
+        } else {
+            return statement.isWrapperFor(iface);
         }
     }
 
-    @Override
-    public int executeUpdate(final String sql, final int columnIndexes[]) throws SQLException {
-        checkOpen();
-        if (connection != null) {
-            connection.setLastUsed();
-        }
-        try {
-            return statement.executeUpdate(sql, columnIndexes);
-        } catch (final SQLException e) {
-            handleException(e);
-            return 0;
+    /**
+     *
+     * @throws SQLException
+     *             thrown by the delegating statement.
+     * @since 2.4.0 made public, was protected in 2.3.0.
+     */
+    public void passivate() throws SQLException {
+        if (statement instanceof DelegatingStatement) {
+            ((DelegatingStatement) statement).passivate();
         }
     }
 
+    protected void setClosedInternal(final boolean closed) {
+        this.closed = closed;
+    }
+
     @Override
-    public int executeUpdate(final String sql, final String columnNames[]) throws SQLException {
+    public void setCursorName(final String name) throws SQLException {
         checkOpen();
-        if (connection != null) {
-            connection.setLastUsed();
-        }
         try {
-            return statement.executeUpdate(sql, columnNames);
+            statement.setCursorName(name);
         } catch (final SQLException e) {
             handleException(e);
-            return 0;
         }
     }
 
+    /**
+     * Sets my delegate.
+     *
+     * @param statement
+     *            my delegate.
+     */
+    public void setDelegate(final Statement statement) {
+        this.statement = statement;
+    }
+
     @Override
-    public boolean execute(final String sql, final int autoGeneratedKeys) throws SQLException {
+    public void setEscapeProcessing(final boolean enable) throws SQLException {
         checkOpen();
-        if (connection != null) {
-            connection.setLastUsed();
-        }
         try {
-            return statement.execute(sql, autoGeneratedKeys);
+            statement.setEscapeProcessing(enable);
         } catch (final SQLException e) {
             handleException(e);
-            return false;
         }
     }
 
     @Override
-    public boolean execute(final String sql, final int columnIndexes[]) throws SQLException {
+    public void setFetchDirection(final int direction) throws SQLException {
         checkOpen();
-        if (connection != null) {
-            connection.setLastUsed();
-        }
         try {
-            return statement.execute(sql, columnIndexes);
+            statement.setFetchDirection(direction);
         } catch (final SQLException e) {
             handleException(e);
-            return false;
         }
     }
 
     @Override
-    public boolean execute(final String sql, final String columnNames[]) throws SQLException {
+    public void setFetchSize(final int rows) throws SQLException {
         checkOpen();
-        if (connection != null) {
-            connection.setLastUsed();
-        }
         try {
-            return statement.execute(sql, columnNames);
+            statement.setFetchSize(rows);
         } catch (final SQLException e) {
             handleException(e);
-            return false;
         }
     }
 
+    /**
+     * @since 2.5.0
+     */
     @Override
-    public int getResultSetHoldability() throws SQLException {
+    public void setLargeMaxRows(final long max) throws SQLException {
         checkOpen();
         try {
-            return statement.getResultSetHoldability();
+            statement.setLargeMaxRows(max);
         } catch (final SQLException e) {
             handleException(e);
-            return 0;
-        }
-    }
-
-    /*
-     * Note was protected prior to JDBC 4
-     */
-    @Override
-    public boolean isClosed() throws SQLException {
-        return closed;
-    }
-
-    @Override
-    public boolean isWrapperFor(final Class<?> iface) throws SQLException {
-        if (iface.isAssignableFrom(getClass())) {
-            return true;
-        } else if (iface.isAssignableFrom(statement.getClass())) {
-            return true;
-        } else {
-            return statement.isWrapperFor(iface);
         }
     }
 
-    @Override
-    public <T> T unwrap(final Class<T> iface) throws SQLException {
-        if (iface.isAssignableFrom(getClass())) {
-            return iface.cast(this);
-        } else if (iface.isAssignableFrom(statement.getClass())) {
-            return iface.cast(statement);
-        } else {
-            return statement.unwrap(iface);
+    private void setLastUsedInParent() {
+        if (connection != null) {
+            connection.setLastUsed();
         }
     }
 
     @Override
-    public void setPoolable(final boolean poolable) throws SQLException {
+    public void setMaxFieldSize(final int max) throws SQLException {
         checkOpen();
         try {
-            statement.setPoolable(poolable);
+            statement.setMaxFieldSize(max);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public boolean isPoolable() throws SQLException {
+    public void setMaxRows(final int max) throws SQLException {
         checkOpen();
         try {
-            return statement.isPoolable();
+            statement.setMaxRows(max);
         } catch (final SQLException e) {
             handleException(e);
-            return false;
         }
     }
 
     @Override
-    public void closeOnCompletion() throws SQLException {
+    public void setPoolable(final boolean poolable) throws SQLException {
         checkOpen();
         try {
-            statement.closeOnCompletion();
+            statement.setPoolable(poolable);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public boolean isCloseOnCompletion() throws SQLException {
+    public void setQueryTimeout(final int seconds) throws SQLException {
         checkOpen();
         try {
-            return statement.isCloseOnCompletion();
+            statement.setQueryTimeout(seconds);
         } catch (final SQLException e) {
             handleException(e);
-            return false;
         }
     }
 
+    /**
+     * Returns a String representation of this object.
+     *
+     * @return String
+     */
     @Override
-    protected void finalize() throws Throwable {
-        // This is required because of statement pooling. The poolable
-        // statements will always be strongly held by the statement pool. If the
-        // delegating statements that wrap the poolable statement are not
-        // strongly held they will be garbage collected but at that point the
-        // poolable statements need to be returned to the pool else there will
-        // be a leak of statements from the pool. Closing this statement will
-        // close all the wrapped statements and return any poolable statements
-        // to the pool.
-        close();
-        super.finalize();
+    public String toString() {
+        return statement == null ? "NULL" : statement.toString();
+    }
+
+    @Override
+    public <T> T unwrap(final Class<T> iface) throws SQLException {
+        if (iface.isAssignableFrom(getClass())) {
+            return iface.cast(this);
+        } else if (iface.isAssignableFrom(statement.getClass())) {
+            return iface.cast(statement);
+        } else {
+            return statement.unwrap(iface);
+        }
     }
 }

==================================================
DriverManagerConnectionFactory.java
index 06f3bd9d99..eebe56fca9 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/DriverConnectionFactory.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/DriverConnectionFactory.java
@@ -15,6 +15,7 @@
  * limitations under the License.
  */
 package org.apache.tomcat.dbcp.dbcp2;
+
 import java.sql.Connection;
 import java.sql.Driver;
 import java.sql.SQLException;

==================================================
PStmtKey.java
index 7b6b060a04..1b5f916641 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/DriverManagerConnectionFactory.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/DriverManagerConnectionFactory.java
@@ -16,6 +16,7 @@
  */
 
 package org.apache.tomcat.dbcp.dbcp2;
+
 import java.sql.Connection;
 import java.sql.DriverManager;
 import java.sql.SQLException;

==================================================
PoolableConnection.java
index 29cc510df2..39d149ab60 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/PStmtKey.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/PStmtKey.java
@@ -17,7 +17,6 @@
 package org.apache.tomcat.dbcp.dbcp2;
 
 import java.sql.Connection;
-import java.sql.PreparedStatement;
 import java.sql.SQLException;
 import java.sql.Statement;
 import java.util.Arrays;
@@ -31,6 +30,105 @@ import org.apache.tomcat.dbcp.dbcp2.PoolingConnection.StatementType;
  */
 public class PStmtKey {
 
+    /**
+     * Builder for prepareCall(String sql).
+     */
+    private class PreparedCallSQL implements StatementBuilder {
+        @Override
+        public Statement createStatement(final Connection connection) throws SQLException {
+            return connection.prepareCall(sql);
+        }
+    }
+
+    /**
+     * Builder for prepareCall(String sql, int resultSetType, int resultSetConcurrency).
+     */
+    private class PreparedCallWithResultSetConcurrency implements StatementBuilder {
+        @Override
+        public Statement createStatement(final Connection connection) throws SQLException {
+            return connection.prepareCall(sql, resultSetType.intValue(), resultSetConcurrency.intValue());
+        }
+    }
+
+    /**
+     * Builder for prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability).
+     */
+    private class PreparedCallWithResultSetHoldability implements StatementBuilder {
+        @Override
+        public Statement createStatement(final Connection connection) throws SQLException {
+            return connection.prepareCall(sql, resultSetType.intValue(), resultSetConcurrency.intValue(),
+                    resultSetHoldability.intValue());
+        }
+    }
+
+    /**
+     * Builder for prepareStatement(String sql).
+     */
+    private class PreparedStatementSQL implements StatementBuilder {
+        @Override
+        public Statement createStatement(final Connection connection) throws SQLException {
+            return connection.prepareStatement(sql);
+        }
+    }
+
+    /**
+     * Builder for prepareStatement(String sql, int autoGeneratedKeys).
+     */
+    private class PreparedStatementWithAutoGeneratedKeys implements StatementBuilder {
+        @Override
+        public Statement createStatement(final Connection connection) throws SQLException {
+            return connection.prepareStatement(sql, autoGeneratedKeys.intValue());
+        }
+    }
+
+    /**
+     * Builder for prepareStatement(String sql, int[] columnIndexes).
+     */
+    private class PreparedStatementWithColumnIndexes implements StatementBuilder {
+        @Override
+        public Statement createStatement(final Connection connection) throws SQLException {
+            return connection.prepareStatement(sql, columnIndexes);
+        }
+    }
+
+    /**
+     * Builder for prepareStatement(String sql, String[] columnNames).
+     */
+    private class PreparedStatementWithColumnNames implements StatementBuilder {
+        @Override
+        public Statement createStatement(final Connection connection) throws SQLException {
+            return connection.prepareStatement(sql, columnNames);
+        }
+    }
+
+    /**
+     * Builder for prepareStatement(String sql, int resultSetType, int resultSetConcurrency).
+     */
+    private class PreparedStatementWithResultSetConcurrency implements StatementBuilder {
+        @Override
+        public Statement createStatement(final Connection connection) throws SQLException {
+            return connection.prepareStatement(sql, resultSetType.intValue(), resultSetConcurrency.intValue());
+        }
+    }
+
+    /**
+     * Builder for prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability).
+     */
+    private class PreparedStatementWithResultSetHoldability implements StatementBuilder {
+        @Override
+        public Statement createStatement(final Connection connection) throws SQLException {
+            return connection.prepareStatement(sql, resultSetType.intValue(), resultSetConcurrency.intValue(),
+                    resultSetHoldability.intValue());
+        }
+    }
+
+    /**
+     * Interface for Prepared or Callable Statement.
+     */
+    private interface StatementBuilder {
+        Statement createStatement(Connection connection) throws SQLException;
+    }
+
     /**
      * SQL defining Prepared or Callable Statement
      */
@@ -54,9 +152,12 @@ public class PStmtKey {
      */
     private final Integer resultSetHoldability;
 
-    /** Database catalog */
+    /** Database catalog. */
     private final String catalog;
 
+    /** Database schema. */
+    private final String schema;
+
     /**
      * A flag indicating whether auto-generated keys should be returned; one of
      * <code>Statement.RETURN_GENERATED_KEYS</code> or <code>Statement.NO_GENERATED_KEYS</code>.
@@ -79,14 +180,16 @@ public class PStmtKey {
     private final StatementType statementType;
 
     /** Statement builder */
-    private StatementBuilder builder;
+    private transient StatementBuilder builder;
 
     /**
      * Constructs a key to uniquely identify a prepared statement.
      *
      * @param sql
      *            The SQL statement.
+     * @deprecated Use {@link #PStmtKey(String, String, String)}.
      */
+    @Deprecated
     public PStmtKey(final String sql) {
         this(sql, null, StatementType.PREPARED_STATEMENT);
     }
@@ -96,11 +199,17 @@ public class PStmtKey {
      *
      * @param sql
      *            The SQL statement.
-     * @param catalog
-     *            The catalog.
+     * @param resultSetType
+     *            A result set type; one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
+     *            <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>.
+     * @param resultSetConcurrency
+     *            A concurrency type; one of <code>ResultSet.CONCUR_READ_ONLY</code> or
+     *            <code>ResultSet.CONCUR_UPDATABLE</code>.
+     * @deprecated Use {@link #PStmtKey(String, String, String, int, int)}.
      */
-    public PStmtKey(final String sql, final String catalog) {
-        this(sql, catalog, StatementType.PREPARED_STATEMENT);
+    @Deprecated
+    public PStmtKey(final String sql, final int resultSetType, final int resultSetConcurrency) {
+        this(sql, null, resultSetType, resultSetConcurrency, StatementType.PREPARED_STATEMENT);
     }
 
     /**
@@ -110,25 +219,11 @@ public class PStmtKey {
      *            The SQL statement.
      * @param catalog
      *            The catalog.
-     * @param statementType
-     *            The SQL statement type, prepared or callable.
+     * @deprecated Use {@link #PStmtKey(String, String, String)}.
      */
-    public PStmtKey(final String sql, final String catalog, final StatementType statementType) {
-        this.sql = sql;
-        this.catalog = catalog;
-        this.statementType = statementType;
-        this.autoGeneratedKeys = null;
-        this.columnIndexes = null;
-        this.columnNames = null;
-        this.resultSetType = null;
-        this.resultSetConcurrency = null;
-        this.resultSetHoldability = null;
-        // create builder
-        if (statementType == StatementType.PREPARED_STATEMENT) {
-            this.builder = new PreparedStatementSQL();
-        } else if (statementType == StatementType.CALLABLE_STATEMENT) {
-            this.builder = new PreparedCallSQL();
-        }
+    @Deprecated
+    public PStmtKey(final String sql, final String catalog) {
+        this(sql, catalog, StatementType.PREPARED_STATEMENT);
     }
 
     /**
@@ -141,7 +236,9 @@ public class PStmtKey {
      * @param autoGeneratedKeys
      *            A flag indicating whether auto-generated keys should be returned; one of
      *            <code>Statement.RETURN_GENERATED_KEYS</code> or <code>Statement.NO_GENERATED_KEYS</code>.
+     * @deprecated Use {@link #PStmtKey(String, String, String, int)}.
      */
+    @Deprecated
     public PStmtKey(final String sql, final String catalog, final int autoGeneratedKeys) {
         this(sql, catalog, StatementType.PREPARED_STATEMENT, Integer.valueOf(autoGeneratedKeys));
     }
@@ -153,54 +250,17 @@ public class PStmtKey {
      *            The SQL statement.
      * @param catalog
      *            The catalog.
-     * @param statementType
-     *            The SQL statement type, prepared or callable.
-     * @param autoGeneratedKeys
-     *            A flag indicating whether auto-generated keys should be returned; one of
-     *            <code>Statement.RETURN_GENERATED_KEYS</code> or <code>Statement.NO_GENERATED_KEYS</code>.
-     */
-    public PStmtKey(final String sql, final String catalog, final StatementType statementType,
-            final Integer autoGeneratedKeys) {
-        this.sql = sql;
-        this.catalog = catalog;
-        this.statementType = statementType;
-        this.autoGeneratedKeys = autoGeneratedKeys;
-        this.columnIndexes = null;
-        this.columnNames = null;
-        this.resultSetType = null;
-        this.resultSetConcurrency = null;
-        this.resultSetHoldability = null;
-        // create builder
-        if (statementType == StatementType.PREPARED_STATEMENT) {
-            this.builder = new PreparedStatementWithAutoGeneratedKeys();
-        } else if (statementType == StatementType.CALLABLE_STATEMENT) {
-            this.builder = new PreparedCallSQL();
-        }
-    }
-
-    /**
-     * Constructs a key to uniquely identify a prepared statement.
-     *
-     * @param sql
-     *            The SQL statement.
-     * @param catalog
-     *            The catalog.
-     * @param columnIndexes
-     *            An array of column indexes indicating the columns that should be returned from the inserted row or
-     *            rows.
+     * @param resultSetType
+     *            A result set type; one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
+     *            <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>.
+     * @param resultSetConcurrency
+     *            A concurrency type; one of <code>ResultSet.CONCUR_READ_ONLY</code> or
+     *            <code>ResultSet.CONCUR_UPDATABLE</code>.
+     * @deprecated Use @link {@link #PStmtKey(String, String, String, int, int)}.
      */
-    public PStmtKey(final String sql, final String catalog, final int[] columnIndexes) {
-        this.sql = sql;
-        this.catalog = catalog;
-        this.statementType = StatementType.PREPARED_STATEMENT;
-        this.autoGeneratedKeys = null;
-        this.columnIndexes = columnIndexes == null ? null : Arrays.copyOf(columnIndexes, columnIndexes.length);
-        this.columnNames = null;
-        this.resultSetType = null;
-        this.resultSetConcurrency = null;
-        this.resultSetHoldability = null;
-        // create builder
-        this.builder = new PreparedStatementWithColumnIndexes();
+    @Deprecated
+    public PStmtKey(final String sql, final String catalog, final int resultSetType, final int resultSetConcurrency) {
+        this(sql, catalog, resultSetType, resultSetConcurrency, StatementType.PREPARED_STATEMENT);
     }
 
     /**
@@ -210,37 +270,21 @@ public class PStmtKey {
      *            The SQL statement.
      * @param catalog
      *            The catalog.
-     * @param columnNames
-     *            An array of column names indicating the columns that should be returned from the inserted row or rows.
-     */
-    public PStmtKey(final String sql, final String catalog, final String[] columnNames) {
-        this.sql = sql;
-        this.catalog = catalog;
-        this.statementType = StatementType.PREPARED_STATEMENT;
-        this.autoGeneratedKeys = null;
-        this.columnIndexes = null;
-        this.columnNames = columnNames == null ? null : Arrays.copyOf(columnNames, columnNames.length);
-        this.resultSetType = null;
-        this.resultSetConcurrency = null;
-        this.resultSetHoldability = null;
-        // create builder
-        builder = new PreparedStatementWithColumnNames();
-    }
-
-    /**
-     * Constructs a key to uniquely identify a prepared statement.
-     *
-     * @param sql
-     *            The SQL statement.
      * @param resultSetType
-     *            A result set type; one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
+     *            a result set type; one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
      *            <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>.
      * @param resultSetConcurrency
      *            A concurrency type; one of <code>ResultSet.CONCUR_READ_ONLY</code> or
-     *            <code>ResultSet.CONCUR_UPDATABLE</code>.
+     *            <code>ResultSet.CONCUR_UPDATABLE</code>
+     * @param resultSetHoldability
+     *            One of the following <code>ResultSet</code> constants: <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code>
+     *            or <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>.
+     * @deprecated Use {@link #PStmtKey(String, String, String, int, int, int)}.
      */
-    public PStmtKey(final String sql, final int resultSetType, final int resultSetConcurrency) {
-        this(sql, null, resultSetType, resultSetConcurrency, StatementType.PREPARED_STATEMENT);
+    @Deprecated
+    public PStmtKey(final String sql, final String catalog, final int resultSetType, final int resultSetConcurrency,
+            final int resultSetHoldability) {
+        this(sql, catalog, resultSetType, resultSetConcurrency, resultSetHoldability, StatementType.PREPARED_STATEMENT);
     }
 
     /**
@@ -251,14 +295,37 @@ public class PStmtKey {
      * @param catalog
      *            The catalog.
      * @param resultSetType
-     *            A result set type; one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
-     *            <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>.
+     *            a result set type; one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
+     *            <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>
      * @param resultSetConcurrency
      *            A concurrency type; one of <code>ResultSet.CONCUR_READ_ONLY</code> or
      *            <code>ResultSet.CONCUR_UPDATABLE</code>.
+     * @param resultSetHoldability
+     *            One of the following <code>ResultSet</code> constants: <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code>
+     *            or <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>.
+     * @param statementType
+     *            The SQL statement type, prepared or callable.
+     * @deprecated Use {@link #PStmtKey(String, String, String, int, int, int, PoolingConnection.StatementType)}
      */
-    public PStmtKey(final String sql, final String catalog, final int resultSetType, final int resultSetConcurrency) {
-        this(sql, catalog, resultSetType, resultSetConcurrency, StatementType.PREPARED_STATEMENT);
+    @Deprecated
+    public PStmtKey(final String sql, final String catalog, final int resultSetType, final int resultSetConcurrency,
+            final int resultSetHoldability, final StatementType statementType) {
+        this.sql = sql;
+        this.catalog = catalog;
+        this.schema = null;
+        this.resultSetType = Integer.valueOf(resultSetType);
+        this.resultSetConcurrency = Integer.valueOf(resultSetConcurrency);
+        this.resultSetHoldability = Integer.valueOf(resultSetHoldability);
+        this.statementType = statementType;
+        this.autoGeneratedKeys = null;
+        this.columnIndexes = null;
+        this.columnNames = null;
+        // create builder
+        if (statementType == StatementType.PREPARED_STATEMENT) {
+            this.builder = new PreparedStatementWithResultSetHoldability();
+        } else if (statementType == StatementType.CALLABLE_STATEMENT) {
+            this.builder = new PreparedCallWithResultSetHoldability();
+        }
     }
 
     /**
@@ -276,11 +343,14 @@ public class PStmtKey {
      *            <code>ResultSet.CONCUR_UPDATABLE</code>.
      * @param statementType
      *            The SQL statement type, prepared or callable.
+     * @deprecated Use {@link #PStmtKey(String, String, String, int, int, PoolingConnection.StatementType)}.
      */
+    @Deprecated
     public PStmtKey(final String sql, final String catalog, final int resultSetType, final int resultSetConcurrency,
             final StatementType statementType) {
         this.sql = sql;
         this.catalog = catalog;
+        this.schema = null;
         this.resultSetType = Integer.valueOf(resultSetType);
         this.resultSetConcurrency = Integer.valueOf(resultSetConcurrency);
         this.resultSetHoldability = null;
@@ -303,28 +373,180 @@ public class PStmtKey {
      *            The SQL statement.
      * @param catalog
      *            The catalog.
-     * @param resultSetType
-     *            a result set type; one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
-     *            <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>.
-     * @param resultSetConcurrency
-     *            A concurrency type; one of <code>ResultSet.CONCUR_READ_ONLY</code> or
-     *            <code>ResultSet.CONCUR_UPDATABLE</code>
-     * @param resultSetHoldability
-     *            One of the following <code>ResultSet</code> constants: <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code>
-     *            or <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>.
+     * @param columnIndexes
+     *            An array of column indexes indicating the columns that should be returned from the inserted row or
+     *            rows.
+     * @deprecated Use {@link #PStmtKey(String, String, String, int[])}.
      */
-    public PStmtKey(final String sql, final String catalog, final int resultSetType, final int resultSetConcurrency,
-            final int resultSetHoldability) {
-        this(sql, catalog, resultSetType, resultSetConcurrency, resultSetHoldability, StatementType.PREPARED_STATEMENT);
-    }
-
-    /**
-     * Constructs a key to uniquely identify a prepared statement.
+    @Deprecated
+    public PStmtKey(final String sql, final String catalog, final int[] columnIndexes) {
+        this.sql = sql;
+        this.catalog = catalog;
+        this.schema = null;
+        this.statementType = StatementType.PREPARED_STATEMENT;
+        this.autoGeneratedKeys = null;
+        this.columnIndexes = columnIndexes == null ? null : Arrays.copyOf(columnIndexes, columnIndexes.length);
+        this.columnNames = null;
+        this.resultSetType = null;
+        this.resultSetConcurrency = null;
+        this.resultSetHoldability = null;
+        // create builder
+        this.builder = new PreparedStatementWithColumnIndexes();
+    }
+
+    /**
+     * Constructs a key to uniquely identify a prepared statement.
      *
      * @param sql
      *            The SQL statement.
      * @param catalog
      *            The catalog.
+     * @param statementType
+     *            The SQL statement type, prepared or callable.
+     * @deprecated Use {@link #PStmtKey(String, String, String, PoolingConnection.StatementType)}.
+     */
+    @Deprecated
+    public PStmtKey(final String sql, final String catalog, final StatementType statementType) {
+        this.sql = sql;
+        this.catalog = catalog;
+        this.schema = null;
+        this.statementType = statementType;
+        this.autoGeneratedKeys = null;
+        this.columnIndexes = null;
+        this.columnNames = null;
+        this.resultSetType = null;
+        this.resultSetConcurrency = null;
+        this.resultSetHoldability = null;
+        // create builder
+        if (statementType == StatementType.PREPARED_STATEMENT) {
+            this.builder = new PreparedStatementSQL();
+        } else if (statementType == StatementType.CALLABLE_STATEMENT) {
+            this.builder = new PreparedCallSQL();
+        }
+    }
+
+    /**
+     * Constructs a key to uniquely identify a prepared statement.
+     *
+     * @param sql
+     *            The SQL statement.
+     * @param catalog
+     *            The catalog.
+     * @param statementType
+     *            The SQL statement type, prepared or callable.
+     * @param autoGeneratedKeys
+     *            A flag indicating whether auto-generated keys should be returned; one of
+     *            <code>Statement.RETURN_GENERATED_KEYS</code> or <code>Statement.NO_GENERATED_KEYS</code>.
+     * @deprecated Use {@link #PStmtKey(String, String, String, PoolingConnection.StatementType, Integer)}
+     */
+    @Deprecated
+    public PStmtKey(final String sql, final String catalog, final StatementType statementType,
+            final Integer autoGeneratedKeys) {
+        this.sql = sql;
+        this.catalog = catalog;
+        this.schema = null;
+        this.statementType = statementType;
+        this.autoGeneratedKeys = autoGeneratedKeys;
+        this.columnIndexes = null;
+        this.columnNames = null;
+        this.resultSetType = null;
+        this.resultSetConcurrency = null;
+        this.resultSetHoldability = null;
+        // create builder
+        if (statementType == StatementType.PREPARED_STATEMENT) {
+            this.builder = new PreparedStatementWithAutoGeneratedKeys();
+        } else if (statementType == StatementType.CALLABLE_STATEMENT) {
+            this.builder = new PreparedCallSQL();
+        }
+    }
+
+    /**
+     * Constructs a key to uniquely identify a prepared statement.
+     *
+     * @param sql
+     *            The SQL statement.
+     * @param catalog
+     *            The catalog.
+     * @param schema
+     *            The schema
+     * @since 2.5.0
+     */
+    public PStmtKey(final String sql, final String catalog, final String schema) {
+        this(sql, catalog, schema, StatementType.PREPARED_STATEMENT);
+    }
+
+    /**
+     * Constructs a key to uniquely identify a prepared statement.
+     *
+     * @param sql
+     *            The SQL statement.
+     * @param catalog
+     *            The catalog.
+     * @param schema
+     *            The schema
+     * @param autoGeneratedKeys
+     *            A flag indicating whether auto-generated keys should be returned; one of
+     *            <code>Statement.RETURN_GENERATED_KEYS</code> or <code>Statement.NO_GENERATED_KEYS</code>.
+     * @since 2.5.0
+     */
+    public PStmtKey(final String sql, final String catalog, final String schema, final int autoGeneratedKeys) {
+        this(sql, catalog, schema, StatementType.PREPARED_STATEMENT, Integer.valueOf(autoGeneratedKeys));
+    }
+
+    /**
+     * Constructs a key to uniquely identify a prepared statement.
+     *
+     * @param sql
+     *            The SQL statement.
+     * @param catalog
+     *            The catalog.
+     * @param schema
+     *            The schema
+     * @param resultSetType
+     *            A result set type; one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
+     *            <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>.
+     * @param resultSetConcurrency
+     *            A concurrency type; one of <code>ResultSet.CONCUR_READ_ONLY</code> or
+     *            <code>ResultSet.CONCUR_UPDATABLE</code>.
+     */
+    public PStmtKey(final String sql, final String catalog, final String schema, final int resultSetType, final int resultSetConcurrency) {
+        this(sql, catalog, schema, resultSetType, resultSetConcurrency, StatementType.PREPARED_STATEMENT);
+    }
+
+    /**
+     * Constructs a key to uniquely identify a prepared statement.
+     *
+     * @param sql
+     *            The SQL statement.
+     * @param catalog
+     *            The catalog.
+     * @param schema
+     *            The schema
+     * @param resultSetType
+     *            a result set type; one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
+     *            <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>.
+     * @param resultSetConcurrency
+     *            A concurrency type; one of <code>ResultSet.CONCUR_READ_ONLY</code> or
+     *            <code>ResultSet.CONCUR_UPDATABLE</code>
+     * @param resultSetHoldability
+     *            One of the following <code>ResultSet</code> constants: <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code>
+     *            or <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>.
+     * @since 2.5.0
+     */
+    public PStmtKey(final String sql, final String catalog, final String schema, final int resultSetType, final int resultSetConcurrency,
+            final int resultSetHoldability) {
+        this(sql, catalog, schema, resultSetType, resultSetConcurrency, resultSetHoldability, StatementType.PREPARED_STATEMENT);
+    }
+
+    /**
+     * Constructs a key to uniquely identify a prepared statement.
+     *
+     * @param sql
+     *            The SQL statement.
+     * @param catalog
+     *            The catalog.
+     * @param schema
+     *            The schema.
      * @param resultSetType
      *            a result set type; one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
      *            <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>
@@ -336,11 +558,13 @@ public class PStmtKey {
      *            or <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>.
      * @param statementType
      *            The SQL statement type, prepared or callable.
+     * @since 2.5.0
      */
-    public PStmtKey(final String sql, final String catalog, final int resultSetType, final int resultSetConcurrency,
+    public PStmtKey(final String sql, final String catalog, final String schema, final int resultSetType, final int resultSetConcurrency,
             final int resultSetHoldability, final StatementType statementType) {
         this.sql = sql;
         this.catalog = catalog;
+        this.schema = schema;
         this.resultSetType = Integer.valueOf(resultSetType);
         this.resultSetConcurrency = Integer.valueOf(resultSetConcurrency);
         this.resultSetHoldability = Integer.valueOf(resultSetHoldability);
@@ -357,88 +581,209 @@ public class PStmtKey {
     }
 
     /**
-     * Gets the SQL statement.
-     *
-     * @return the SQL statement.
-     */
-    public String getSql() {
-        return sql;
-    }
-
-    /**
-     * Gets the result set type, one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
-     * <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>.
-     *
-     * @return the result set type.
-     */
-    public Integer getResultSetType() {
-        return resultSetType;
-    }
-
-    /**
-     * Gets the result set concurrency type; one of <code>ResultSet.CONCUR_READ_ONLY</code> or
-     * <code>ResultSet.CONCUR_UPDATABLE</code>.
+     * Constructs a key to uniquely identify a prepared statement.
      *
-     * @return The result set concurrency type.
+     * @param sql
+     *            The SQL statement.
+     * @param catalog
+     *            The catalog.
+     * @param schema
+     *            The schema.
+     * @param resultSetType
+     *            A result set type; one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
+     *            <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>.
+     * @param resultSetConcurrency
+     *            A concurrency type; one of <code>ResultSet.CONCUR_READ_ONLY</code> or
+     *            <code>ResultSet.CONCUR_UPDATABLE</code>.
+     * @param statementType
+     *            The SQL statement type, prepared or callable.
+     * @since 2.5.0
      */
-    public Integer getResultSetConcurrency() {
-        return resultSetConcurrency;
+    public PStmtKey(final String sql, final String catalog, final String schema, final int resultSetType, final int resultSetConcurrency,
+            final StatementType statementType) {
+        this.sql = sql;
+        this.catalog = catalog;
+        this.schema = schema;
+        this.resultSetType = Integer.valueOf(resultSetType);
+        this.resultSetConcurrency = Integer.valueOf(resultSetConcurrency);
+        this.resultSetHoldability = null;
+        this.statementType = statementType;
+        this.autoGeneratedKeys = null;
+        this.columnIndexes = null;
+        this.columnNames = null;
+        // create builder
+        if (statementType == StatementType.PREPARED_STATEMENT) {
+            this.builder = new PreparedStatementWithResultSetConcurrency();
+        } else if (statementType == StatementType.CALLABLE_STATEMENT) {
+            this.builder = new PreparedCallWithResultSetConcurrency();
+        }
     }
 
     /**
-     * Gets the result set holdability, one of the following <code>ResultSet</code> constants:
-     * <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> or <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>.
+     * Constructs a key to uniquely identify a prepared statement.
      *
-     * @return The result set holdability.
+     * @param sql
+     *            The SQL statement.
+     * @param catalog
+     *            The catalog.
+     * @param schema
+     *            The schema.
+     * @param columnIndexes
+     *            An array of column indexes indicating the columns that should be returned from the inserted row or
+     *            rows.
      */
-    public Integer getResultSetHoldability() {
-        return resultSetHoldability;
+    public PStmtKey(final String sql, final String catalog, final String schema, final int[] columnIndexes) {
+        this.sql = sql;
+        this.catalog = catalog;
+        this.schema = schema;
+        this.statementType = StatementType.PREPARED_STATEMENT;
+        this.autoGeneratedKeys = null;
+        this.columnIndexes = columnIndexes == null ? null : Arrays.copyOf(columnIndexes, columnIndexes.length);
+        this.columnNames = null;
+        this.resultSetType = null;
+        this.resultSetConcurrency = null;
+        this.resultSetHoldability = null;
+        // create builder
+        this.builder = new PreparedStatementWithColumnIndexes();
     }
 
     /**
-     * Gets a flag indicating whether auto-generated keys should be returned; one of
-     * <code>Statement.RETURN_GENERATED_KEYS</code> or <code>Statement.NO_GENERATED_KEYS</code>.
+     * Constructs a key to uniquely identify a prepared statement.
      *
-     * @return a flag indicating whether auto-generated keys should be returned.
+     * @param sql
+     *            The SQL statement.
+     * @param catalog
+     *            The catalog.
+     * @param schema
+     *            The schema.
+     * @param statementType
+     *            The SQL statement type, prepared or callable.
+     * @since 2.5.0
      */
-    public Integer getAutoGeneratedKeys() {
-        return autoGeneratedKeys;
+    public PStmtKey(final String sql, final String catalog, final String schema, final StatementType statementType) {
+        this.sql = sql;
+        this.catalog = catalog;
+        this.schema = schema;
+        this.statementType = statementType;
+        this.autoGeneratedKeys = null;
+        this.columnIndexes = null;
+        this.columnNames = null;
+        this.resultSetType = null;
+        this.resultSetConcurrency = null;
+        this.resultSetHoldability = null;
+        // create builder
+        if (statementType == StatementType.PREPARED_STATEMENT) {
+            this.builder = new PreparedStatementSQL();
+        } else if (statementType == StatementType.CALLABLE_STATEMENT) {
+            this.builder = new PreparedCallSQL();
+        }
     }
 
     /**
-     * Gets an array of column indexes indicating the columns that should be returned from the inserted row or rows.
+     * Constructs a key to uniquely identify a prepared statement.
      *
-     * @return An array of column indexes.
+     * @param sql
+     *            The SQL statement.
+     * @param catalog
+     *            The catalog.
+     * @param schema
+     *            The schema.
+     * @param statementType
+     *            The SQL statement type, prepared or callable.
+     * @param autoGeneratedKeys
+     *            A flag indicating whether auto-generated keys should be returned; one of
+     *            <code>Statement.RETURN_GENERATED_KEYS</code> or <code>Statement.NO_GENERATED_KEYS</code>.
+     * @since 2.5.0
      */
-    public int[] getColumnIndexes() {
-        return columnIndexes;
+    public PStmtKey(final String sql, final String catalog, final String schema, final StatementType statementType,
+            final Integer autoGeneratedKeys) {
+        this.sql = sql;
+        this.catalog = catalog;
+        this.schema = schema;
+        this.statementType = statementType;
+        this.autoGeneratedKeys = autoGeneratedKeys;
+        this.columnIndexes = null;
+        this.columnNames = null;
+        this.resultSetType = null;
+        this.resultSetConcurrency = null;
+        this.resultSetHoldability = null;
+        // create builder
+        if (statementType == StatementType.PREPARED_STATEMENT) {
+            this.builder = new PreparedStatementWithAutoGeneratedKeys();
+        } else if (statementType == StatementType.CALLABLE_STATEMENT) {
+            this.builder = new PreparedCallSQL();
+        }
     }
 
     /**
-     * Gets an array of column names indicating the columns that should be returned from the inserted row or rows.
+     * Constructs a key to uniquely identify a prepared statement.
      *
-     * @return An array of column names.
-     */
-    public String[] getColumnNames() {
-        return columnNames;
+     * @param sql
+     *            The SQL statement.
+     * @param catalog
+     *            The catalog.
+     * @param schema
+     *            The schema.
+     * @param columnNames
+     *            An array of column names indicating the columns that should be returned from the inserted row or rows.
+     * @since 2.5.0
+     */
+    public PStmtKey(final String sql, final String catalog, final String schema, final String[] columnNames) {
+        this.sql = sql;
+        this.catalog = catalog;
+        this.schema = schema;
+        this.statementType = StatementType.PREPARED_STATEMENT;
+        this.autoGeneratedKeys = null;
+        this.columnIndexes = null;
+        this.columnNames = columnNames == null ? null : Arrays.copyOf(columnNames, columnNames.length);
+        this.resultSetType = null;
+        this.resultSetConcurrency = null;
+        this.resultSetHoldability = null;
+        // create builder
+        builder = new PreparedStatementWithColumnNames();
     }
 
     /**
-     * The catalog.
+     * Constructs a key to uniquely identify a prepared statement.
      *
-     * @return The catalog.
+     * @param sql
+     *            The SQL statement.
+     * @param catalog
+     *            The catalog.
+     * @param columnNames
+     *            An array of column names indicating the columns that should be returned from the inserted row or rows.
+     * @deprecated Use {@link #PStmtKey(String, String, String, String[])}.
      */
-    public String getCatalog() {
-        return catalog;
+    @Deprecated
+    public PStmtKey(final String sql, final String catalog, final String[] columnNames) {
+        this.sql = sql;
+        this.catalog = catalog;
+        this.schema = null;
+        this.statementType = StatementType.PREPARED_STATEMENT;
+        this.autoGeneratedKeys = null;
+        this.columnIndexes = null;
+        this.columnNames = columnNames == null ? null : Arrays.copyOf(columnNames, columnNames.length);
+        this.resultSetType = null;
+        this.resultSetConcurrency = null;
+        this.resultSetHoldability = null;
+        // create builder
+        builder = new PreparedStatementWithColumnNames();
     }
 
     /**
-     * The SQL statement type.
+     * Creates a new Statement from the given Connection.
      *
-     * @return The SQL statement type.
+     * @param connection
+     *            The Connection to use to create the statement.
+     * @return The statement.
+     * @throws SQLException
+     *             Thrown when there is a problem creating the statement.
      */
-    public StatementType getStmtType() {
-        return statementType;
+    public Statement createStatement(final Connection connection) throws SQLException {
+        if (builder == null) {
+            throw new IllegalStateException("Prepared statement key is invalid.");
+        }
+        return builder.createStatement(connection);
     }
 
     @Override
@@ -453,6 +798,13 @@ public class PStmtKey {
             return false;
         }
         final PStmtKey other = (PStmtKey) obj;
+        if (autoGeneratedKeys == null) {
+            if (other.autoGeneratedKeys != null) {
+                return false;
+            }
+        } else if (!autoGeneratedKeys.equals(other.autoGeneratedKeys)) {
+            return false;
+        }
         if (catalog == null) {
             if (other.catalog != null) {
                 return false;
@@ -460,6 +812,12 @@ public class PStmtKey {
         } else if (!catalog.equals(other.catalog)) {
             return false;
         }
+        if (!Arrays.equals(columnIndexes, other.columnIndexes)) {
+            return false;
+        }
+        if (!Arrays.equals(columnNames, other.columnNames)) {
+            return false;
+        }
         if (resultSetConcurrency == null) {
             if (other.resultSetConcurrency != null) {
                 return false;
@@ -467,13 +825,6 @@ public class PStmtKey {
         } else if (!resultSetConcurrency.equals(other.resultSetConcurrency)) {
             return false;
         }
-        if (resultSetType == null) {
-            if (other.resultSetType != null) {
-                return false;
-            }
-        } else if (!resultSetType.equals(other.resultSetType)) {
-            return false;
-        }
         if (resultSetHoldability == null) {
             if (other.resultSetHoldability != null) {
                 return false;
@@ -481,17 +832,18 @@ public class PStmtKey {
         } else if (!resultSetHoldability.equals(other.resultSetHoldability)) {
             return false;
         }
-        if (autoGeneratedKeys == null) {
-            if (other.autoGeneratedKeys != null) {
+        if (resultSetType == null) {
+            if (other.resultSetType != null) {
                 return false;
             }
-        } else if (!autoGeneratedKeys.equals(other.autoGeneratedKeys)) {
-            return false;
-        }
-        if (!Arrays.equals(columnIndexes, other.columnIndexes)) {
+        } else if (!resultSetType.equals(other.resultSetType)) {
             return false;
         }
-        if (!Arrays.equals(columnNames, other.columnNames)) {
+        if (schema == null) {
+            if (other.schema != null) {
+                return false;
+            }
+        } else if (!schema.equals(other.schema)) {
             return false;
         }
         if (sql == null) {
@@ -507,169 +859,140 @@ public class PStmtKey {
         return true;
     }
 
-    @Override
-    public int hashCode() {
-        final int prime = 31;
-        int result = 1;
-        result = prime * result + (catalog == null ? 0 : catalog.hashCode());
-        result = prime * result + (resultSetConcurrency == null ? 0 : resultSetConcurrency.hashCode());
-        result = prime * result + (resultSetType == null ? 0 : resultSetType.hashCode());
-        result = prime * result + (resultSetHoldability == null ? 0 : resultSetHoldability.hashCode());
-        result = prime * result + (sql == null ? 0 : sql.hashCode());
-        result = prime * result + (autoGeneratedKeys == null ? 0 : autoGeneratedKeys.hashCode());
-        result = prime * result + Arrays.hashCode(columnIndexes);
-        result = prime * result + Arrays.hashCode(columnNames);
-        result = prime * result + statementType.hashCode();
-        return result;
-    }
-
-    @Override
-    public String toString() {
-        final StringBuffer buf = new StringBuffer();
-        buf.append("PStmtKey: sql=");
-        buf.append(sql);
-        buf.append(", catalog=");
-        buf.append(catalog);
-        buf.append(", resultSetType=");
-        buf.append(resultSetType);
-        buf.append(", resultSetConcurrency=");
-        buf.append(resultSetConcurrency);
-        buf.append(", resultSetHoldability=");
-        buf.append(resultSetHoldability);
-        buf.append(", autoGeneratedKeys=");
-        buf.append(autoGeneratedKeys);
-        buf.append(", columnIndexes=");
-        buf.append(Arrays.toString(columnIndexes));
-        buf.append(", columnNames=");
-        buf.append(Arrays.toString(columnNames));
-        buf.append(", statementType=");
-        buf.append(statementType);
-        return buf.toString();
-    }
-
     /**
-     * Creates a new Statement from the given Connection.
+     * Gets a flag indicating whether auto-generated keys should be returned; one of
+     * <code>Statement.RETURN_GENERATED_KEYS</code> or <code>Statement.NO_GENERATED_KEYS</code>.
      *
-     * @param connection
-     *            The Connection to use to create the statement.
-     * @return The statement.
-     * @throws SQLException
-     *             Thrown when there is a problem creating the statement.
+     * @return a flag indicating whether auto-generated keys should be returned.
      */
-    public Statement createStatement(final Connection connection) throws SQLException {
-        if (builder == null) {
-            throw new IllegalStateException("Prepared statement key is invalid.");
-        }
-        return builder.createStatement(connection);
+    public Integer getAutoGeneratedKeys() {
+        return autoGeneratedKeys;
     }
 
     /**
-     * Interface for Prepared or Callable Statement.
+     * The catalog.
+     *
+     * @return The catalog.
      */
-    private interface StatementBuilder {
-        public Statement createStatement(Connection connection) throws SQLException;
+    public String getCatalog() {
+        return catalog;
     }
 
     /**
-     * Builder for prepareStatement(String sql).
+     * Gets an array of column indexes indicating the columns that should be returned from the inserted row or rows.
+     *
+     * @return An array of column indexes.
      */
-    private class PreparedStatementSQL implements StatementBuilder {
-        @Override
-        public Statement createStatement(final Connection connection) throws SQLException {
-            final PreparedStatement statement = connection.prepareStatement(sql);
-            return statement;
-        }
+    public int[] getColumnIndexes() {
+        return columnIndexes;
     }
 
     /**
-     * Builder for prepareStatement(String sql, int autoGeneratedKeys).
+     * Gets an array of column names indicating the columns that should be returned from the inserted row or rows.
+     *
+     * @return An array of column names.
      */
-    private class PreparedStatementWithAutoGeneratedKeys implements StatementBuilder {
-        @Override
-        public Statement createStatement(final Connection connection) throws SQLException {
-            final PreparedStatement statement = connection.prepareStatement(sql, autoGeneratedKeys.intValue());
-            return statement;
-        }
+    public String[] getColumnNames() {
+        return columnNames;
     }
 
     /**
-     * Builder for prepareStatement(String sql, int[] columnIndexes).
+     * Gets the result set concurrency type; one of <code>ResultSet.CONCUR_READ_ONLY</code> or
+     * <code>ResultSet.CONCUR_UPDATABLE</code>.
+     *
+     * @return The result set concurrency type.
      */
-    private class PreparedStatementWithColumnIndexes implements StatementBuilder {
-        @Override
-        public Statement createStatement(final Connection connection) throws SQLException {
-            final PreparedStatement statement = connection.prepareStatement(sql, columnIndexes);
-            return statement;
-        }
+    public Integer getResultSetConcurrency() {
+        return resultSetConcurrency;
     }
 
     /**
-     * Builder for prepareStatement(String sql, int resultSetType, int resultSetConcurrency).
+     * Gets the result set holdability, one of the following <code>ResultSet</code> constants:
+     * <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> or <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>.
+     *
+     * @return The result set holdability.
      */
-    private class PreparedStatementWithResultSetConcurrency implements StatementBuilder {
-        @Override
-        public Statement createStatement(final Connection connection) throws SQLException {
-            final PreparedStatement statement = connection.prepareStatement(sql, resultSetType.intValue(),
-                    resultSetConcurrency.intValue());
-            return statement;
-        }
+    public Integer getResultSetHoldability() {
+        return resultSetHoldability;
     }
 
     /**
-     * Builder for prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability).
+     * Gets the result set type, one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
+     * <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>.
+     *
+     * @return the result set type.
      */
-    private class PreparedStatementWithResultSetHoldability implements StatementBuilder {
-        @Override
-        public Statement createStatement(final Connection connection) throws SQLException {
-            final PreparedStatement statement = connection.prepareStatement(sql, resultSetType.intValue(),
-                    resultSetConcurrency.intValue(), resultSetHoldability.intValue());
-            return statement;
-        }
+    public Integer getResultSetType() {
+        return resultSetType;
     }
 
     /**
-     * Builder for prepareStatement(String sql, String[] columnNames).
+     * The schema.
+     *
+     * @return The catalog.
      */
-    private class PreparedStatementWithColumnNames implements StatementBuilder {
-        @Override
-        public Statement createStatement(final Connection connection) throws SQLException {
-            final PreparedStatement statement = connection.prepareStatement(sql, columnNames);
-            return statement;
-        }
+    public String getSchema() {
+        return schema;
     }
 
     /**
-     * Builder for prepareCall(String sql).
+     * Gets the SQL statement.
+     *
+     * @return the SQL statement.
      */
-    private class PreparedCallSQL implements StatementBuilder {
-        @Override
-        public Statement createStatement(final Connection connection) throws SQLException {
-            final PreparedStatement statement = connection.prepareCall(sql);
-            return statement;
-        }
+    public String getSql() {
+        return sql;
     }
 
     /**
-     * Builder for prepareCall(String sql, int resultSetType, int resultSetConcurrency).
+     * The SQL statement type.
+     *
+     * @return The SQL statement type.
      */
-    private class PreparedCallWithResultSetConcurrency implements StatementBuilder {
-        @Override
-        public Statement createStatement(final Connection connection) throws SQLException {
-            final PreparedStatement statement = connection.prepareCall(sql, resultSetType.intValue(),
-                    resultSetConcurrency.intValue());
-            return statement;
-        }
+    public StatementType getStmtType() {
+        return statementType;
     }
 
-    /**
-     * Builder for prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability).
-     */
-    private class PreparedCallWithResultSetHoldability implements StatementBuilder {
-        @Override
-        public Statement createStatement(final Connection connection) throws SQLException {
-            final PreparedStatement statement = connection.prepareCall(sql, resultSetType.intValue(),
-                    resultSetConcurrency.intValue(), resultSetHoldability.intValue());
-            return statement;
-        }
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + ((autoGeneratedKeys == null) ? 0 : autoGeneratedKeys.hashCode());
+        result = prime * result + ((catalog == null) ? 0 : catalog.hashCode());
+        result = prime * result + Arrays.hashCode(columnIndexes);
+        result = prime * result + Arrays.hashCode(columnNames);
+        result = prime * result + ((resultSetConcurrency == null) ? 0 : resultSetConcurrency.hashCode());
+        result = prime * result + ((resultSetHoldability == null) ? 0 : resultSetHoldability.hashCode());
+        result = prime * result + ((resultSetType == null) ? 0 : resultSetType.hashCode());
+        result = prime * result + ((schema == null) ? 0 : schema.hashCode());
+        result = prime * result + ((sql == null) ? 0 : sql.hashCode());
+        result = prime * result + ((statementType == null) ? 0 : statementType.hashCode());
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        final StringBuffer buf = new StringBuffer();
+        buf.append("PStmtKey: sql=");
+        buf.append(sql);
+        buf.append(", catalog=");
+        buf.append(catalog);
+        buf.append(", schema=");
+        buf.append(schema);
+        buf.append(", resultSetType=");
+        buf.append(resultSetType);
+        buf.append(", resultSetConcurrency=");
+        buf.append(resultSetConcurrency);
+        buf.append(", resultSetHoldability=");
+        buf.append(resultSetHoldability);
+        buf.append(", autoGeneratedKeys=");
+        buf.append(autoGeneratedKeys);
+        buf.append(", columnIndexes=");
+        buf.append(Arrays.toString(columnIndexes));
+        buf.append(", columnNames=");
+        buf.append(Arrays.toString(columnNames));
+        buf.append(", statementType=");
+        buf.append(statementType);
+        return buf.toString();
     }
 }

==================================================
PoolableConnectionFactory.java
index 5a74747f52..8b0a0f1d79 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/PoolableConnection.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/PoolableConnection.java
@@ -117,7 +117,7 @@ public class PoolableConnection extends DelegatingConnection<Connection> impleme
      */
     public PoolableConnection(final Connection conn, final ObjectPool<PoolableConnection> pool,
             final ObjectName jmxName) {
-        this(conn, pool, jmxName, null, false);
+        this(conn, pool, jmxName, null, true);
     }
 
     @Override

==================================================
PoolingConnection.java
index 469dc7d1eb..27207577d0 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/PoolableConnectionFactory.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/PoolableConnectionFactory.java
@@ -157,6 +157,17 @@ public class PoolableConnectionFactory implements PooledObjectFactory<PoolableCo
         this.defaultCatalog = defaultCatalog;
     }
 
+    /**
+     * Sets the default "schema" setting for borrowed {@link Connection}s
+     *
+     * @param defaultSchema
+     *            the default "schema" setting for borrowed {@link Connection}s
+     * @since 2.5.0
+     */
+    public void setDefaultSchema(final String defaultSchema) {
+        this.defaultSchema = defaultSchema;
+    }
+
     public void setCacheState(final boolean cacheState) {
         this.cacheState = cacheState;
     }
@@ -259,6 +270,7 @@ public class PoolableConnectionFactory implements PooledObjectFactory<PoolableCo
      * @return true if connections created by this factory will fast fail validation.
      * @see #setDisconnectionSqlCodes(Collection)
      * @since 2.1
+     * @since 2.5.0 Defaults to true, previous versions defaulted to false.
      */
     public boolean isFastFailValidation() {
         return fastFailValidation;
@@ -312,10 +324,11 @@ public class PoolableConnectionFactory implements PooledObjectFactory<PoolableCo
             } else {
                 config.setJmxEnabled(false);
             }
+            final PoolingConnection poolingConn = (PoolingConnection) conn;
             final KeyedObjectPool<PStmtKey, DelegatingPreparedStatement> stmtPool = new GenericKeyedObjectPool<>(
-                    (PoolingConnection) conn, config);
-            ((PoolingConnection) conn).setStatementPool(stmtPool);
-            ((PoolingConnection) conn).setCacheState(cacheState);
+                    poolingConn, config);
+            poolingConn.setStatementPool(stmtPool);
+            poolingConn.setCacheState(cacheState);
         }
 
         // Register this connection with JMX
@@ -427,6 +440,9 @@ public class PoolableConnectionFactory implements PooledObjectFactory<PoolableCo
         if (defaultCatalog != null && !defaultCatalog.equals(conn.getCatalog())) {
             conn.setCatalog(defaultCatalog);
         }
+        if (defaultSchema != null && !defaultSchema.equals(conn.getSchema())) {
+            conn.setSchema(defaultSchema);
+        }
         conn.setDefaultQueryTimeout(defaultQueryTimeoutSeconds);
     }
 
@@ -470,7 +486,7 @@ public class PoolableConnectionFactory implements PooledObjectFactory<PoolableCo
     private volatile int validationQueryTimeoutSeconds = -1;
     private Collection<String> connectionInitSqls;
     private Collection<String> disconnectionSqlCodes;
-    private boolean fastFailValidation;
+    private boolean fastFailValidation = true;
     private volatile ObjectPool<PoolableConnection> pool;
     private Boolean defaultReadOnly;
     private Boolean defaultAutoCommit;
@@ -478,6 +494,7 @@ public class PoolableConnectionFactory implements PooledObjectFactory<PoolableCo
     private boolean rollbackOnReturn = true;
     private int defaultTransactionIsolation = UNKNOWN_TRANSACTIONISOLATION;
     private String defaultCatalog;
+    private String defaultSchema;
     private boolean cacheState;
     private boolean poolStatements;
     private int maxOpenPreparedStatements = GenericKeyedObjectPoolConfig.DEFAULT_MAX_TOTAL_PER_KEY;

==================================================
Utils.java
index 494835e1ee..17539b8be3 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/PoolingConnection.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/PoolingConnection.java
@@ -125,23 +125,7 @@ public class PoolingConnection extends DelegatingConnection<Connection>
      * @return the PStmtKey created for the given arguments.
      */
     protected PStmtKey createKey(final String sql) {
-        String catalog = null;
-        try {
-            catalog = getCatalog();
-        } catch (final SQLException e) {
-            // Ignored
-        }
-        return new PStmtKey(normalizeSQL(sql), catalog);
-    }
-
-    protected PStmtKey createKey(final String sql, final int autoGeneratedKeys) {
-        String catalog = null;
-        try {
-            catalog = getCatalog();
-        } catch (final SQLException e) {
-            // Ignored
-        }
-        return new PStmtKey(normalizeSQL(sql), catalog, autoGeneratedKeys);
+        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), getSchemaOrNull());
     }
 
     /**
@@ -155,13 +139,11 @@ public class PoolingConnection extends DelegatingConnection<Connection>
      * @return the PStmtKey created for the given arguments.
      */
     protected PStmtKey createKey(final String sql, final int columnIndexes[]) {
-        String catalog = null;
-        try {
-            catalog = getCatalog();
-        } catch (final SQLException e) {
-            // Ignored
-        }
-        return new PStmtKey(normalizeSQL(sql), catalog, columnIndexes);
+        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), getSchemaOrNull(), columnIndexes);
+    }
+
+    protected PStmtKey createKey(final String sql, final int autoGeneratedKeys) {
+        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), getSchemaOrNull(), autoGeneratedKeys);
     }
 
     /**
@@ -177,13 +159,7 @@ public class PoolingConnection extends DelegatingConnection<Connection>
      * @return the PStmtKey created for the given arguments.
      */
     protected PStmtKey createKey(final String sql, final int resultSetType, final int resultSetConcurrency) {
-        String catalog = null;
-        try {
-            catalog = getCatalog();
-        } catch (final SQLException e) {
-            // Ignored
-        }
-        return new PStmtKey(normalizeSQL(sql), catalog, resultSetType, resultSetConcurrency);
+        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), getSchemaOrNull(), resultSetType, resultSetConcurrency);
     }
 
     /**
@@ -202,13 +178,8 @@ public class PoolingConnection extends DelegatingConnection<Connection>
      */
     protected PStmtKey createKey(final String sql, final int resultSetType, final int resultSetConcurrency,
             final int resultSetHoldability) {
-        String catalog = null;
-        try {
-            catalog = getCatalog();
-        } catch (final SQLException e) {
-            // Ignored
-        }
-        return new PStmtKey(normalizeSQL(sql), catalog, resultSetType, resultSetConcurrency, resultSetHoldability);
+        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), getSchemaOrNull(), resultSetType, resultSetConcurrency,
+                resultSetHoldability);
     }
 
     /**
@@ -222,21 +193,15 @@ public class PoolingConnection extends DelegatingConnection<Connection>
      *            result set concurrency
      * @param resultSetHoldability
      *            result set holdability
-     * @param stmtType
+     * @param statementType
      *            statement type
      *
      * @return the PStmtKey created for the given arguments.
      */
     protected PStmtKey createKey(final String sql, final int resultSetType, final int resultSetConcurrency,
-            final int resultSetHoldability, final StatementType stmtType) {
-        String catalog = null;
-        try {
-            catalog = getCatalog();
-        } catch (final SQLException e) {
-            // Ignored
-        }
-        return new PStmtKey(normalizeSQL(sql), catalog, resultSetType, resultSetConcurrency, resultSetHoldability,
-                stmtType);
+            final int resultSetHoldability, final StatementType statementType) {
+        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), getSchemaOrNull(), resultSetType, resultSetConcurrency,
+                resultSetHoldability, statementType);
     }
 
     /**
@@ -248,20 +213,14 @@ public class PoolingConnection extends DelegatingConnection<Connection>
      *            result set type
      * @param resultSetConcurrency
      *            result set concurrency
-     * @param stmtType
+     * @param statementType
      *            statement type
      *
      * @return the PStmtKey created for the given arguments.
      */
     protected PStmtKey createKey(final String sql, final int resultSetType, final int resultSetConcurrency,
-            final StatementType stmtType) {
-        String catalog = null;
-        try {
-            catalog = getCatalog();
-        } catch (final SQLException e) {
-            // Ignored
-        }
-        return new PStmtKey(normalizeSQL(sql), catalog, resultSetType, resultSetConcurrency, stmtType);
+            final StatementType statementType) {
+        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), getSchemaOrNull(), resultSetType, resultSetConcurrency, statementType);
     }
 
     /**
@@ -269,19 +228,13 @@ public class PoolingConnection extends DelegatingConnection<Connection>
      *
      * @param sql
      *            the SQL string used to define the statement
-     * @param stmtType
+     * @param statementType
      *            statement type
      *
      * @return the PStmtKey created for the given arguments.
      */
-    protected PStmtKey createKey(final String sql, final StatementType stmtType) {
-        String catalog = null;
-        try {
-            catalog = getCatalog();
-        } catch (final SQLException e) {
-            // Ignored
-        }
-        return new PStmtKey(normalizeSQL(sql), catalog, stmtType, null);
+    protected PStmtKey createKey(final String sql, final StatementType statementType) {
+        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), getSchemaOrNull(), statementType, null);
     }
 
     /**
@@ -295,13 +248,7 @@ public class PoolingConnection extends DelegatingConnection<Connection>
      * @return the PStmtKey created for the given arguments.
      */
     protected PStmtKey createKey(final String sql, final String columnNames[]) {
-        String catalog = null;
-        try {
-            catalog = getCatalog();
-        } catch (final SQLException e) {
-            // Ignored
-        }
-        return new PStmtKey(normalizeSQL(sql), catalog, columnNames);
+        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), getSchemaOrNull(), columnNames);
     }
 
     /**
@@ -319,6 +266,26 @@ public class PoolingConnection extends DelegatingConnection<Connection>
         pooledObject.getObject().getInnermostDelegate().close();
     }
 
+    private String getCatalogOrNull() {
+        String catalog = null;
+        try {
+            catalog = getCatalog();
+        } catch (final SQLException e) {
+            // Ignored
+        }
+        return catalog;
+    }
+
+    private String getSchemaOrNull() {
+        String catalog = null;
+        try {
+            catalog = getSchema();
+        } catch (final SQLException e) {
+            // Ignored
+        }
+        return catalog;
+    }
+
     /**
      * {@link KeyedPooledObjectFactory} method for creating {@link PoolablePreparedStatement}s or
      * {@link PoolableCallableStatement}s. The <code>stmtType</code> field in the key determines whether a

==================================================
DriverAdapterCPDS.java
index 0886b18e17..c80de46771 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/Utils.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/Utils.java
@@ -71,6 +71,17 @@ public final class Utils {
         // not instantiable
     }
 
+    /**
+     * Clones the given char[] if not null.
+     *
+     * @param value
+     *            may be null.
+     * @return a cloned char[] or null.
+     */
+    public static char[] clone(final char[] value) {
+        return value == null ? null : value.clone();
+    }
+
     /**
      * Closes the ResultSet (which may be null).
      *
@@ -169,4 +180,5 @@ public final class Utils {
     public static String toString(final char[] value) {
         return value == null ? null : String.valueOf(value);
     }
+
 }

==================================================
PStmtKeyCPDS.java
index af7dbe7abd..902edfb25e 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/cpdsadapter/DriverAdapterCPDS.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/cpdsadapter/DriverAdapterCPDS.java
@@ -423,8 +423,8 @@ public class DriverAdapterCPDS implements ConnectionPoolDataSource, Referenceabl
      */
     public void setPassword(final char[] userPassword) {
         assertInitializationAllowed();
-        this.userPassword = userPassword;
-        update(connectionProperties, KEY_PASSWORD, Utils.toString(userPassword));
+        this.userPassword = Utils.clone(userPassword);
+        update(connectionProperties, KEY_PASSWORD, Utils.toString(this.userPassword));
     }
 
     /**

==================================================
PooledConnectionImpl.java
index 8d7c26394b..0bce400cf8 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/cpdsadapter/PStmtKeyCPDS.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/cpdsadapter/PStmtKeyCPDS.java
@@ -26,27 +26,87 @@ import org.apache.tomcat.dbcp.dbcp2.PStmtKey;
  */
 @Deprecated
 public class PStmtKeyCPDS extends PStmtKey {
+
+    /**
+     * Constructs a key to uniquely identify a prepared statement.
+     *
+     * @param sql
+     *            The SQL statement.
+     */
     public PStmtKeyCPDS(final String sql) {
         super(sql);
     }
 
+    /**
+     * Constructs a key to uniquely identify a prepared statement.
+     *
+     * @param sql
+     *            The SQL statement.
+     * @param autoGeneratedKeys
+     *            A flag indicating whether auto-generated keys should be returned; one of
+     *            <code>Statement.RETURN_GENERATED_KEYS</code> or <code>Statement.NO_GENERATED_KEYS</code>.
+     */
     public PStmtKeyCPDS(final String sql, final int autoGeneratedKeys) {
         super(sql, null, autoGeneratedKeys);
     }
 
+    /**
+     * Constructs a key to uniquely identify a prepared statement.
+     *
+     * @param sql
+     *            The SQL statement.
+     * @param resultSetType
+     *            A result set type; one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
+     *            <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>.
+     * @param resultSetConcurrency
+     *            A concurrency type; one of <code>ResultSet.CONCUR_READ_ONLY</code> or
+     *            <code>ResultSet.CONCUR_UPDATABLE</code>.
+     */
     public PStmtKeyCPDS(final String sql, final int resultSetType, final int resultSetConcurrency) {
         super(sql, resultSetType, resultSetConcurrency);
     }
 
+    /**
+     * Constructs a key to uniquely identify a prepared statement.
+     *
+     * @param sql
+     *            The SQL statement.
+     * @param resultSetType
+     *            a result set type; one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
+     *            <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>.
+     * @param resultSetConcurrency
+     *            A concurrency type; one of <code>ResultSet.CONCUR_READ_ONLY</code> or
+     *            <code>ResultSet.CONCUR_UPDATABLE</code>
+     * @param resultSetHoldability
+     *            One of the following <code>ResultSet</code> constants: <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code>
+     *            or <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>.
+     */
     public PStmtKeyCPDS(final String sql, final int resultSetType, final int resultSetConcurrency,
             final int resultSetHoldability) {
         super(sql, null, resultSetType, resultSetConcurrency, resultSetHoldability);
     }
 
+    /**
+     * Constructs a key to uniquely identify a prepared statement.
+     *
+     * @param sql
+     *            The SQL statement.
+     * @param columnIndexes
+     *            An array of column indexes indicating the columns that should be returned from the inserted row or
+     *            rows.
+     */
     public PStmtKeyCPDS(final String sql, final int columnIndexes[]) {
         super(sql, null, columnIndexes);
     }
 
+    /**
+     * Constructs a key to uniquely identify a prepared statement.
+     *
+     * @param sql
+     *            The SQL statement.
+     * @param columnNames
+     *            An array of column names indicating the columns that should be returned from the inserted row or rows.
+     */
     public PStmtKeyCPDS(final String sql, final String columnNames[]) {
         super(sql, null, columnNames);
     }

==================================================
CPDSConnectionFactory.java
index fca57dfda3..57cf4b01a2 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/cpdsadapter/PooledConnectionImpl.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/cpdsadapter/PooledConnectionImpl.java
@@ -182,28 +182,29 @@ class PooledConnectionImpl
      * Creates a {@link PStmtKey} for the given arguments.
      */
     protected PStmtKey createKey(final String sql) {
-        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull());
+        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), getSchemaOrNull());
     }
 
     /**
      * Creates a {@link PStmtKey} for the given arguments.
      */
     protected PStmtKey createKey(final String sql, final int autoGeneratedKeys) {
-        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), autoGeneratedKeys);
+        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), getSchemaOrNull(), autoGeneratedKeys);
     }
 
     /**
      * Creates a {@link PStmtKey} for the given arguments.
      */
     protected PStmtKey createKey(final String sql, final int columnIndexes[]) {
-        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), columnIndexes);
+        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), getSchemaOrNull(), columnIndexes);
     }
 
     /**
      * Creates a {@link PStmtKey} for the given arguments.
      */
     protected PStmtKey createKey(final String sql, final int resultSetType, final int resultSetConcurrency) {
-        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), resultSetType, resultSetConcurrency);
+        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), getSchemaOrNull(), resultSetType,
+                resultSetConcurrency);
     }
 
     /**
@@ -211,8 +212,8 @@ class PooledConnectionImpl
      */
     protected PStmtKey createKey(final String sql, final int resultSetType, final int resultSetConcurrency,
             final int resultSetHoldability) {
-        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), resultSetType, resultSetConcurrency,
-                resultSetHoldability);
+        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), getSchemaOrNull(), resultSetType,
+                resultSetConcurrency, resultSetHoldability);
     }
 
     /**
@@ -222,8 +223,8 @@ class PooledConnectionImpl
      */
     protected PStmtKey createKey(final String sql, final int resultSetType, final int resultSetConcurrency,
             final int resultSetHoldability, final StatementType statementType) {
-        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), resultSetType, resultSetConcurrency,
-                resultSetHoldability, statementType);
+        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), getSchemaOrNull(), resultSetType,
+                resultSetConcurrency, resultSetHoldability, statementType);
     }
 
     /**
@@ -233,21 +234,22 @@ class PooledConnectionImpl
      */
     protected PStmtKey createKey(final String sql, final int resultSetType, final int resultSetConcurrency,
             final StatementType statementType) {
-        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), resultSetType, resultSetConcurrency, statementType);
+        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), getSchemaOrNull(), resultSetType,
+                resultSetConcurrency, statementType);
     }
 
     /**
      * Creates a {@link PStmtKey} for the given arguments.
      */
     protected PStmtKey createKey(final String sql, final StatementType statementType) {
-        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), statementType);
+        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), getSchemaOrNull(), statementType);
     }
 
     /**
      * Creates a {@link PStmtKey} for the given arguments.
      */
     protected PStmtKey createKey(final String sql, final String columnNames[]) {
-        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), columnNames);
+        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), getSchemaOrNull(), columnNames);
     }
 
     /**
@@ -291,6 +293,14 @@ class PooledConnectionImpl
         }
     }
 
+    private String getSchemaOrNull() {
+        try {
+            return connection == null ? null : connection.getSchema();
+        } catch (final SQLException e) {
+            return null;
+        }
+    }
+
     /**
      * Returns a JDBC connection.
      *

==================================================
BasicManagedDataSource.java
index bc42266ae7..ea609f4040 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/datasources/CPDSConnectionFactory.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/datasources/CPDSConnectionFactory.java
@@ -122,6 +122,15 @@ class CPDSConnectionFactory
                 Utils.toCharArray(userPassword));
     }
 
+    /**
+     * (Testing API) Gets the value of password for the default user.
+     *
+     * @return value of password.
+     */
+    char[] getPasswordCharArray() {
+        return userPassword;
+    }
+
     /**
      * Returns the object pool used to pool connections created by this factory.
      *
@@ -336,7 +345,7 @@ class CPDSConnectionFactory
      *            new password
      */
     public synchronized void setPassword(final char[] userPassword) {
-        this.userPassword = userPassword;
+        this.userPassword =  Utils.clone(userPassword);
     }
 
     /**

==================================================
DataSourceXAConnectionFactory.java
index 7f814d24b3..c41e971ffc 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/managed/BasicManagedDataSource.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/managed/BasicManagedDataSource.java
@@ -22,6 +22,7 @@ import java.sql.SQLException;
 import javax.sql.DataSource;
 import javax.sql.XADataSource;
 import javax.transaction.TransactionManager;
+import javax.transaction.TransactionSynchronizationRegistry;
 
 import org.apache.tomcat.dbcp.dbcp2.BasicDataSource;
 import org.apache.tomcat.dbcp.dbcp2.ConnectionFactory;
@@ -62,6 +63,9 @@ public class BasicManagedDataSource extends BasicDataSource {
     /** XA data source instance */
     private XADataSource xaDataSourceInstance;
 
+    /** Transaction Manager */
+    private transient TransactionSynchronizationRegistry transactionSynchronizationRegistry;
+
     /**
      * Gets the XADataSource instance used by the XAConnectionFactory.
      *
@@ -98,6 +102,16 @@ public class BasicManagedDataSource extends BasicDataSource {
         return transactionManager;
     }
 
+    /**
+     * Gets the optional TransactionSynchronizationRegistry.
+     *
+     * @return the TSR that can be used to register synchronizations.
+     * @since 2.6.0
+     */
+    public TransactionSynchronizationRegistry getTransactionSynchronizationRegistry() {
+        return transactionSynchronizationRegistry;
+    }
+
     /**
      * Gets the transaction registry.
      *
@@ -117,6 +131,18 @@ public class BasicManagedDataSource extends BasicDataSource {
         this.transactionManager = transactionManager;
     }
 
+    /**
+     * Sets the optional TransactionSynchronizationRegistry property.
+     *
+     * @param transactionSynchronizationRegistry
+     *            the TSR used to register synchronizations
+     * @since 2.6.0
+     */
+    public void setTransactionSynchronizationRegistry(
+            final TransactionSynchronizationRegistry transactionSynchronizationRegistry) {
+        this.transactionSynchronizationRegistry = transactionSynchronizationRegistry;
+    }
+
     /**
      * Gets the optional XADataSource class name.
      *
@@ -207,6 +233,7 @@ public class BasicManagedDataSource extends BasicDataSource {
             connectionFactory.setDefaultAutoCommit(getDefaultAutoCommit());
             connectionFactory.setDefaultTransactionIsolation(getDefaultTransactionIsolation());
             connectionFactory.setDefaultCatalog(getDefaultCatalog());
+            connectionFactory.setDefaultSchema(getDefaultSchema());
             connectionFactory.setCacheState(getCacheState());
             connectionFactory.setPoolStatements(isPoolPreparedStatements());
             connectionFactory.setMaxOpenPreparedStatements(getMaxOpenPreparedStatements());

==================================================
ManagedConnection.java
index f05b4e21c1..6e2f2afdfb 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/managed/DataSourceXAConnectionFactory.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/managed/DataSourceXAConnectionFactory.java
@@ -27,6 +27,7 @@ import javax.sql.PooledConnection;
 import javax.sql.XAConnection;
 import javax.sql.XADataSource;
 import javax.transaction.TransactionManager;
+import javax.transaction.TransactionSynchronizationRegistry;
 import javax.transaction.xa.XAResource;
 
 import org.apache.tomcat.dbcp.dbcp2.Utils;
@@ -50,9 +51,25 @@ public class DataSourceXAConnectionFactory implements XAConnectionFactory {
      *            the transaction manager in which connections will be enlisted
      * @param xaDataSource
      *            the data source from which connections will be retrieved
+     * @param transactionSynchronizationRegistry
+     *            register with this TransactionSynchronizationRegistry
+     */
+    public DataSourceXAConnectionFactory(final TransactionManager transactionManager, final XADataSource xaDataSource, final TransactionSynchronizationRegistry transactionSynchronizationRegistry) {
+        this(transactionManager, xaDataSource, null, (char[]) null, transactionSynchronizationRegistry);
+    }
+
+    /**
+     * Creates an DataSourceXAConnectionFactory which uses the specified XADataSource to create database connections.
+     * The connections are enlisted into transactions using the specified transaction manager.
+     *
+     * @param transactionManager
+     *            the transaction manager in which connections will be enlisted
+     * @param xaDataSource
+     *            the data source from which connections will be retrieved
+     * @since 2.6.0
      */
     public DataSourceXAConnectionFactory(final TransactionManager transactionManager, final XADataSource xaDataSource) {
-        this(transactionManager, xaDataSource, null, (char[]) null);
+        this(transactionManager, xaDataSource, null, (char[]) null, null);
     }
 
     /**
@@ -70,9 +87,33 @@ public class DataSourceXAConnectionFactory implements XAConnectionFactory {
      */
     public DataSourceXAConnectionFactory(final TransactionManager transactionManager, final XADataSource xaDataSource,
             final String userName, final char[] userPassword) {
+        this(transactionManager, xaDataSource, userName, userPassword, null);
+    }
+
+    /**
+     * Creates an DataSourceXAConnectionFactory which uses the specified XADataSource to create database connections.
+     * The connections are enlisted into transactions using the specified transaction manager.
+     *
+     * @param transactionManager
+     *            the transaction manager in which connections will be enlisted
+     * @param xaDataSource
+     *            the data source from which connections will be retrieved
+     * @param userName
+     *            the user name used for authenticating new connections or null for unauthenticated
+     * @param userPassword
+     *            the password used for authenticating new connections
+     * @param transactionSynchronizationRegistry
+     *            register with this TransactionSynchronizationRegistry
+     * @since 2.6.0
+     */
+    public DataSourceXAConnectionFactory(final TransactionManager transactionManager, final XADataSource xaDataSource,
+            final String userName, final char[] userPassword, final TransactionSynchronizationRegistry transactionSynchronizationRegistry) {
         Objects.requireNonNull(transactionManager, "transactionManager is null");
         Objects.requireNonNull(xaDataSource, "xaDataSource is null");
-        this.transactionRegistry = new TransactionRegistry(transactionManager);
+
+        // We do allow the transactionSynchronizationRegistry to be null for non-app server environments
+
+        this.transactionRegistry = new TransactionRegistry(transactionManager, transactionSynchronizationRegistry);
         this.xaDataSource = xaDataSource;
         this.userName = userName;
         this.userPassword = userPassword;
@@ -93,7 +134,7 @@ public class DataSourceXAConnectionFactory implements XAConnectionFactory {
      */
     public DataSourceXAConnectionFactory(final TransactionManager transactionManager, final XADataSource xaDataSource,
             final String userName, final String userPassword) {
-        this(transactionManager, xaDataSource, userName, Utils.toCharArray(userPassword));
+        this(transactionManager, xaDataSource, userName, Utils.toCharArray(userPassword), null);
     }
 
     /**

==================================================
PoolableManagedConnection.java
index 89b4c02f47..e47b16f59f 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/managed/ManagedConnection.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/managed/ManagedConnection.java
@@ -105,9 +105,10 @@ public class ManagedConnection<C extends Connection> extends DelegatingConnectio
             // in the transaction, replace our delegate with the enrolled connection
 
             // return current connection to the pool
+            @SuppressWarnings("resource")
             final C connection = getDelegateInternal();
             setDelegate(null);
-            if (connection != null) {
+            if (connection != null && transactionContext.getSharedConnection() != connection) {
                 try {
                     pool.returnObject(connection);
                 } catch (final Exception ignored) {

==================================================
TransactionContext.java
index 1d70d1416f..624e5a499f 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/managed/PoolableManagedConnection.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/managed/PoolableManagedConnection.java
@@ -45,7 +45,7 @@ public class PoolableManagedConnection extends PoolableConnection {
      */
     public PoolableManagedConnection(final TransactionRegistry transactionRegistry, final Connection conn,
             final ObjectPool<PoolableConnection> pool) {
-        this(transactionRegistry, conn, pool, null, false);
+        this(transactionRegistry, conn, pool, null, true);
     }
 
     /**

==================================================
TransactionRegistry.java
index 65a5c2ecba..7aef25dd12 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/managed/TransactionContext.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/managed/TransactionContext.java
@@ -27,6 +27,7 @@ import javax.transaction.Status;
 import javax.transaction.Synchronization;
 import javax.transaction.SystemException;
 import javax.transaction.Transaction;
+import javax.transaction.TransactionSynchronizationRegistry;
 import javax.transaction.xa.XAResource;
 
 /**
@@ -39,6 +40,7 @@ import javax.transaction.xa.XAResource;
 public class TransactionContext {
     private final TransactionRegistry transactionRegistry;
     private final WeakReference<Transaction> transactionRef;
+    private final TransactionSynchronizationRegistry transactionSynchronizationRegistry;
     private Connection sharedConnection;
     private boolean transactionComplete;
 
@@ -50,13 +52,29 @@ public class TransactionContext {
      *            the TransactionRegistry used to obtain the XAResource for the shared connection
      * @param transaction
      *            the transaction
+     * @param transactionSynchronizationRegistry
+     *              The optional TSR to register synchronizations with
+     * @since 2.6.0
      */
-    public TransactionContext(final TransactionRegistry transactionRegistry, final Transaction transaction) {
+    public TransactionContext(final TransactionRegistry transactionRegistry, final Transaction transaction,
+                              final TransactionSynchronizationRegistry transactionSynchronizationRegistry) {
         Objects.requireNonNull(transactionRegistry, "transactionRegistry is null");
         Objects.requireNonNull(transaction, "transaction is null");
         this.transactionRegistry = transactionRegistry;
         this.transactionRef = new WeakReference<>(transaction);
         this.transactionComplete = false;
+        this.transactionSynchronizationRegistry = transactionSynchronizationRegistry;
+    }
+
+    /**
+     * Provided for backwards compatability
+     *
+     * @param transactionRegistry the TransactionRegistry used to obtain the XAResource for the
+     * shared connection
+     * @param transaction the transaction
+     */
+    public TransactionContext(final TransactionRegistry transactionRegistry, final Transaction transaction) {
+        this (transactionRegistry, transaction, null);
     }
 
     /**
@@ -113,7 +131,13 @@ public class TransactionContext {
      */
     public void addTransactionContextListener(final TransactionContextListener listener) throws SQLException {
         try {
-            getTransaction().registerSynchronization(new Synchronization() {
+            if (!isActive()) {
+                Transaction transaction = this.transactionRef.get();
+                listener.afterCompletion(TransactionContext.this,
+                        transaction == null ? false : transaction.getStatus() == Status.STATUS_COMMITTED);
+                return;
+            }
+            final Synchronization s = new Synchronization() {
                 @Override
                 public void beforeCompletion() {
                     // empty
@@ -123,7 +147,12 @@ public class TransactionContext {
                 public void afterCompletion(final int status) {
                     listener.afterCompletion(TransactionContext.this, status == Status.STATUS_COMMITTED);
                 }
-            });
+            };
+            if (transactionSynchronizationRegistry != null) {
+                transactionSynchronizationRegistry.registerInterposedSynchronization(s);
+            } else {
+                getTransaction().registerSynchronization(s);
+            }
         } catch (final RollbackException e) {
             // JTA spec doesn't let us register with a transaction marked rollback only
             // just ignore this and the tx state will be cleared another way.

==================================================
XAConnectionFactory.java
index b3c0e17cab..190c025f1a 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/managed/TransactionRegistry.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/managed/TransactionRegistry.java
@@ -26,6 +26,7 @@ import java.util.WeakHashMap;
 import javax.transaction.SystemException;
 import javax.transaction.Transaction;
 import javax.transaction.TransactionManager;
+import javax.transaction.TransactionSynchronizationRegistry;
 import javax.transaction.xa.XAResource;
 
 import org.apache.tomcat.dbcp.dbcp2.DelegatingConnection;
@@ -43,15 +44,28 @@ public class TransactionRegistry {
     private final TransactionManager transactionManager;
     private final Map<Transaction, TransactionContext> caches = new WeakHashMap<>();
     private final Map<Connection, XAResource> xaResources = new WeakHashMap<>();
+    private final TransactionSynchronizationRegistry transactionSynchronizationRegistry;
 
     /**
      * Creates a TransactionRegistry for the specified transaction manager.
      *
      * @param transactionManager
      *            the transaction manager used to enlist connections.
+     * @param transactionSynchronizationRegistry
+     *              The optional TSR to register synchronizations with
+     * @since 2.6.0
      */
-    public TransactionRegistry(final TransactionManager transactionManager) {
+    public TransactionRegistry(final TransactionManager transactionManager, final TransactionSynchronizationRegistry transactionSynchronizationRegistry) {
         this.transactionManager = transactionManager;
+        this.transactionSynchronizationRegistry = transactionSynchronizationRegistry;
+    }
+
+    /**
+     * Provided for backwards compatability
+     * @param transactionManager the transaction manager used to enlist connections
+     */
+    public TransactionRegistry(final TransactionManager transactionManager) {
+        this (transactionManager, null);
     }
 
     /**
@@ -111,11 +125,11 @@ public class TransactionRegistry {
             throw new SQLException("Unable to determine current transaction ", e);
         }
 
-        // register the the context (or create a new one)
+        // register the context (or create a new one)
         synchronized (this) {
             TransactionContext cache = caches.get(transaction);
             if (cache == null) {
-                cache = new TransactionContext(this, transaction);
+                cache = new TransactionContext(this, transaction, transactionSynchronizationRegistry);
                 caches.put(transaction, cache);
             }
             return cache;

==================================================
