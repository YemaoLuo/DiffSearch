d802bcd4a7435c2f1a25f18cc1f28a1a5d15b576
==================================================
FlushableGZIPOutputStream:
==================================================
Konstantin Kolinko
==================================================
Fri Nov 4 14:06:24 2011 +0000
==================================================
FlushableGZIPOutputStream.java
FlushableGZIPOutputStream:
Reserve one byte of real data and perform standard write() call.
This uses more standard code: deflate() is never called directly and empty byte array trick is not used.

TestFlushableGZIPOutputStream:
Add a check that the decompressed stream equals to the original one.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1197578 13f79535-47bb-0310-9956-ffa450edef68



==================================================
TestFlushableGZIPOutputStream.java
index 25cc3b0bbc..eeb09476eb 100644
--- a/java/org/apache/coyote/http11/filters/FlushableGZIPOutputStream.java
+++ b/java/org/apache/coyote/http11/filters/FlushableGZIPOutputStream.java
@@ -35,69 +35,74 @@ public class FlushableGZIPOutputStream extends GZIPOutputStream {
         super(os);
     }
 
-    private static final byte[] EMPTYBYTEARRAY = new byte[0];
-    private boolean hasData = false;
-    private boolean needReenableCompression = false;
-
     /**
-     * Here we make sure we have received data, so that the header has been for
-     * sure written to the output stream already.
+     * It is used to reserve one byte of real data so that it can be used when
+     * flushing the stream.
      */
+    private byte[] lastByte = new byte[1];
+    private boolean hasLastByte = false;
+
+    @Override
+    public synchronized void write(byte[] bytes) throws IOException {
+        write(bytes, 0, bytes.length);
+    }
+
     @Override
     public synchronized void write(byte[] bytes, int offset, int length)
             throws IOException {
         if (length > 0) {
-            prepareForOutput();
-            super.write(bytes, offset, length);
+            flushLastByte();
+            if (length > 1) {
+                super.write(bytes, offset, length - 1);
+            }
+            rememberLastByte(bytes[offset + length - 1]);
         }
     }
 
     @Override
     public synchronized void write(int i) throws IOException {
-        prepareForOutput();
-        super.write(i);
+        flushLastByte();
+        rememberLastByte((byte) (i & 0xFF));
     }
 
     @Override
-    public synchronized void write(byte[] bytes) throws IOException {
-        write(bytes, 0, bytes.length);
+    public void close() throws IOException {
+        flushLastByte();
+        super.close();
     }
 
-    private void prepareForOutput() throws IOException {
-        hasData = true;
-        if (needReenableCompression) {
-            def.setLevel(Deflater.DEFAULT_COMPRESSION);
-            deflate();
-            needReenableCompression = false;
+    private void rememberLastByte(byte b) {
+        lastByte[0] = b;
+        hasLastByte = true;
+    }
+
+    private void flushLastByte() throws IOException {
+        if (hasLastByte) {
+            super.write(lastByte, 0, 1);
+            hasLastByte = false;
         }
     }
 
     @Override
     public synchronized void flush() throws IOException {
-        if (!hasData) {
-            return; // do not allow the gzip header to be flushed on its own
-        }
-
-        // trick the deflater to flush
-        /**
-         * Now this is tricky: We force the Deflater to flush its data by
-         * switching compression level. As yet, a perplexingly simple workaround
-         * for
-         * http://developer.java.sun.com/developer/bugParade/bugs/4255743.html
-         */
-        if (!def.finished()) {
-            def.setInput(EMPTYBYTEARRAY, 0, 0);
-
-            def.setLevel(Deflater.NO_COMPRESSION);
-            deflate();
-
-            // Cannot reenable compression now. Must wait for data.
-            needReenableCompression = true;
-
-            out.flush();
+        if (hasLastByte) {
+            // - do not allow the gzip header to be flushed on its own
+            // - do not do anything if there is no data to send
+
+            // trick the deflater to flush
+            /**
+             * Now this is tricky: We force the Deflater to flush its data by
+             * switching compression level. As yet, a perplexingly simple workaround
+             * for
+             * http://developer.java.sun.com/developer/bugParade/bugs/4255743.html
+             */
+            if (!def.finished()) {
+                def.setLevel(Deflater.NO_COMPRESSION);
+                flushLastByte();
+                def.setLevel(Deflater.DEFAULT_COMPRESSION);
+            }
         }
-
-        hasData = false; // no more data to flush
+        out.flush();
     }
 
     /*

==================================================
