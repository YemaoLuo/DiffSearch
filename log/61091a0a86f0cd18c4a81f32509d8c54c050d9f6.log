61091a0a86f0cd18c4a81f32509d8c54c050d9f6
==================================================
Pull-up code. No need for this to go all the way to the Endpoint.
==================================================
Mark Thomas
==================================================
Tue Oct 20 09:00:24 2015 +0000
==================================================
AbstractEndpoint.java
Pull-up code. No need for this to go all the way to the Endpoint.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1709544 13f79535-47bb-0310-9956-ffa450edef68



==================================================
SocketWrapperBase.java
index 0e3481e433..bbd448f3ca 100644
--- a/java/org/apache/tomcat/util/net/AbstractEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AbstractEndpoint.java
@@ -22,7 +22,6 @@ import java.net.InetSocketAddress;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -811,34 +810,6 @@ public abstract class AbstractEndpoint<S> {
             SocketStatus socketStatus, boolean dispatch);
 
 
-    public void executeNonBlockingDispatches(SocketWrapperBase<S> socketWrapper,
-            Iterator<DispatchType> dispatches) {
-        /*
-         * This method is called when non-blocking IO is initiated by defining
-         * a read and/or write listener in a non-container thread. It is called
-         * once the non-container thread completes so that the first calls to
-         * onWritePossible() and/or onDataAvailable() as appropriate are made by
-         * the container.
-         *
-         * Processing the dispatches requires (for APR/native at least)
-         * that the socket has been added to the waitingRequests queue. This may
-         * not have occurred by the time that the non-container thread completes
-         * triggering the call to this method. Therefore, the coded syncs on the
-         * SocketWrapper as the container thread that initiated this
-         * non-container thread holds a lock on the SocketWrapper. The container
-         * thread will add the socket to the waitingRequests queue before
-         * releasing the lock on the socketWrapper. Therefore, by obtaining the
-         * lock on socketWrapper before processing the dispatches, we can be
-         * sure that the socket has been added to the waitingRequests queue.
-         */
-        synchronized (socketWrapper) {
-            while (dispatches != null && dispatches.hasNext()) {
-                DispatchType dispatchType = dispatches.next();
-                processSocket(socketWrapper, dispatchType.getSocketStatus(), false);
-            }
-        }
-    }
-
     // ------------------------------------------------------- Lifecycle methods
 
     /*

==================================================
