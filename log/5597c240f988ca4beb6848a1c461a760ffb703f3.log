5597c240f988ca4beb6848a1c461a760ffb703f3
==================================================
Switch from Noggit to a javacc parser generated from a public domain json grammar.
==================================================
Remy Maucherat
==================================================
Tue Oct 9 16:36:54 2018 +0000
==================================================
KubernetesMembershipProvider.java
index e61aae26c0..832dba0149 100644
--- a/build.xml
+++ b/build.xml
@@ -213,7 +213,6 @@
   <path id="compile.classpath">
     <pathelement location="${jdt.jar}"/>
     <pathelement location="${saaj-api.jar}"/>
-    <pathelement location="${noggit.jar}"/>
   </path>
 
   <path id="tomcat.classpath">
@@ -390,6 +389,7 @@
     <include name="org/apache/tomcat/util/res/**" />
     <include name="org/apache/tomcat/util/security/**" />
     <include name="org/apache/tomcat/util/threads/**" />
+    <include name="org/apache/tomcat/util/json/**" />
     <include name="org/apache/tomcat/util/*" />
     <exclude name="org/apache/tomcat/util/bcel" />
     <exclude name="org/apache/tomcat/util/descriptor" />
@@ -596,6 +596,7 @@
         <exclude name="java/org/apache/**/parser/ParseException.java" />
         <exclude name="java/org/apache/**/parser/SimpleCharStream.java" />
         <exclude name="java/org/apache/**/parser/Token*.java" />
+        <exclude name="java/org/apache/tomcat/util/json/*.java" />
         <!-- Exclude simple test files -->
         <exclude name="test/webapp/bug53257/**/*.txt"/>
         <exclude name="test/webapp/bug49nnn/bug49464*"/>
@@ -2718,16 +2719,6 @@ skip.installer property in build.properties" />
       <param name="checksum.value" value="${saaj-api.checksum.value}"/>
     </antcall>
 
-    <!-- Download noggit -->
-    <antcall target="downloadfile">
-      <param name="sourcefile" value="${noggit.loc}"/>
-      <param name="destfile" value="${noggit.jar}"/>
-      <param name="destdir" value="${noggit.home}"/>
-      <param name="checksum.enabled" value="${noggit.checksum.enabled}"/>
-      <param name="checksum.algorithm" value="${noggit.checksum.algorithm}"/>
-      <param name="checksum.value" value="${noggit.checksum.value}"/>
-    </antcall>
-
  </target>
 
   <target name="download-test-compile"

==================================================
JSONParser.java
index 057b32fd83..9ec06aa8c6 100644
--- a/java/org/apache/catalina/tribes/membership/cloud/KubernetesMembershipProvider.java
+++ b/java/org/apache/catalina/tribes/membership/cloud/KubernetesMembershipProvider.java
@@ -27,6 +27,7 @@ import java.nio.file.Files;
 import java.time.Duration;
 import java.time.Instant;
 import java.util.ArrayList;
+import java.util.LinkedHashMap;
 import java.util.List;
 
 import org.apache.catalina.tribes.Member;
@@ -35,7 +36,7 @@ import org.apache.catalina.tribes.membership.MemberImpl;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.codec.binary.StringUtils;
-import org.noggit.JSONParser;
+import org.apache.tomcat.util.json.JSONParser;
 
 
 public class KubernetesMembershipProvider extends CloudMembershipProvider {
@@ -141,170 +142,48 @@ public class KubernetesMembershipProvider extends CloudMembershipProvider {
 
     protected void parsePods(Reader reader, List<MemberImpl> members)
             throws IOException{
-
-        int event = 0;
         JSONParser parser = new JSONParser(reader);
-        boolean parseItems = false;
-        for (;;) {
-            event = parser.nextEvent();
-            switch (event) {
-            case JSONParser.STRING:
-                String value = parser.getString();
-                if (parser.wasKey()) {
-                    if ("items".equals(value) && parser.nextEvent() == JSONParser.ARRAY_START) {
-                        parseItems = true;
-                    }
+        try {
+            LinkedHashMap<String, Object> json = parser.object();
+            @SuppressWarnings("unchecked")
+            List<Object> items = (List<Object>) json.get("items");
+            for (Object podObject : items) {
+                @SuppressWarnings("unchecked")
+                LinkedHashMap<String, Object> pod = (LinkedHashMap<String, Object>) podObject;
+                if (!"Pod".equals(pod.get("kind"))) {
+                    continue;
                 }
-                break;
-            case JSONParser.ARRAY_END:
-                parseItems = false;
-                break;
-            case JSONParser.OBJECT_START:
-                if (parseItems) {
-                    parseItem(parser, members);
+                @SuppressWarnings("unchecked")
+                LinkedHashMap<String, Object> metadata = (LinkedHashMap<String, Object>) pod.get("metadata");
+                String name = metadata.get("name").toString();
+                String creationTimestamp = metadata.get("creationTimestamp").toString();
+                @SuppressWarnings("unchecked")
+                LinkedHashMap<String, Object> status = (LinkedHashMap<String, Object>) pod.get("status");
+                if (!"Running".equals(status.get("phase"))) {
+                    continue;
                 }
-                break;
-            default:
-                break;
-            }
-
-            if (event == JSONParser.EOF)
-                break;
-        }
-
-    }
-
-    private void parseItem(JSONParser parser, List<MemberImpl> members)
-            throws IOException {
-        int event = 0;
-        String podIP = null;
-        // Name in first position, creation in second
-        String[] nameAndCreationTimestamp = null;
-        for (;;) {
-            event = parser.nextEvent();
-            switch (event) {
-            case JSONParser.STRING:
-                String value = parser.getString();
-                if (parser.wasKey()) {
-                    if ("kind".equals(value)) {
-                        // Verify the item is a pod
-                        if (parser.nextEvent() != JSONParser.STRING && (!"Pod".equals(parser.getString()))) {
-                            throw new IllegalStateException();
-                        }
-                    } else if ("status".equals(value)) {
-                        // Verify the status is Running and return the podIP
-                        podIP = parseStatus(parser);
-                    } else if ("metadata".equals(value)) {
-                        nameAndCreationTimestamp = parseMetadata(parser);
-                    }
+                String podIP = status.get("podIP").toString();
+
+                // id = md5(hostname)
+                byte[] id = md5.digest(name.getBytes());
+                long aliveTime = Duration.between(Instant.parse(creationTimestamp), startTime).getSeconds() * 1000; // aliveTime is in ms
+
+                MemberImpl member = null;
+                try {
+                    member = new MemberImpl(podIP, port, aliveTime);
+                } catch (IOException e) {
+                    // Shouldn't happen:
+                    // an exception is thrown if hostname can't be resolved to IP, but we already provide an IP
+                    log.error(sm.getString("kubernetesMembershipProvider.memberError"), e);
+                    continue;
                 }
-                break;
-            case JSONParser.OBJECT_END:
-                // Done
-                if (podIP == null || nameAndCreationTimestamp == null
-                    || nameAndCreationTimestamp[0] == null
-                    || nameAndCreationTimestamp[1] == null) {
-                    throw new IOException(sm.getString("kubernetesMembershipProvider.jsonError"));
-                } else {
-                    // We found ourselves, ignore
-                    if (nameAndCreationTimestamp[0].equals(hostName))
-                        return;
-
-                    // id = md5(hostname)
-                    byte[] id = md5.digest(nameAndCreationTimestamp[0].getBytes());
-                    long aliveTime = Duration.between(Instant.parse(nameAndCreationTimestamp[1]), startTime).getSeconds() * 1000; // aliveTime is in ms
-
-                    MemberImpl member = null;
-                    try {
-                        member = new MemberImpl(podIP, port, aliveTime);
-                    } catch (IOException e) {
-                        // Shouldn't happen:
-                        // an exception is thrown if hostname can't be resolved to IP, but we already provide an IP
-                        log.error(sm.getString("kubernetesMembershipProvider.memberError"), e);
-                        continue;
-                    }
 
-                    member.setUniqueId(id);
-                    members.add(member);
-                }
-                return;
-            default:
-                break;
+                member.setUniqueId(id);
+                members.add(member);
             }
-
-            if (event == JSONParser.EOF)
-                break;
-        }
-
-    }
-
-    private String parseStatus(JSONParser parser)
-            throws IOException {
-        String result = null;
-        int event = 0;
-        for (;;) {
-            event = parser.nextEvent();
-            switch (event) {
-            case JSONParser.STRING:
-                String value = parser.getString();
-                if (parser.wasKey()) {
-                    if ("phase".equals(value)) {
-                        // Verify the item is a pod
-                        if (parser.nextEvent() != JSONParser.STRING && (!"Running".equals(parser.getString()))) {
-                            return null;
-                        }
-                    } else if ("podIP".equals(value)) {
-                        if (parser.nextEvent() == JSONParser.STRING) {
-                            result = parser.getString();
-                        }
-                    }
-                }
-                break;
-            case JSONParser.OBJECT_END:
-                // Done
-                return result;
-            default:
-                break;
-            }
-
-            if (event == JSONParser.EOF)
-                break;
-        }
-        return result;
-    }
-
-    private String[] parseMetadata(JSONParser parser)
-            throws IOException {
-        String[] result = new String[2];
-        int event = 0;
-        for (;;) {
-            event = parser.nextEvent();
-            switch (event) {
-            case JSONParser.STRING:
-                String value = parser.getString();
-                if (parser.wasKey()) {
-                    if ("name".equals(value)) {
-                        if (parser.nextEvent() == JSONParser.STRING) {
-                            result[0] = parser.getString();
-                        }
-                    } else if ("creationTimestamp".equals(value)) {
-                        if (parser.nextEvent() == JSONParser.STRING) {
-                            result[1] = parser.getString();
-                        }
-                    }
-                }
-                break;
-            case JSONParser.OBJECT_END:
-                // Done
-                return result;
-            default:
-                break;
-            }
-
-            if (event == JSONParser.EOF)
-                break;
+        } catch (Exception e) {
+            throw new IOException(sm.getString("kubernetesMembershipProvider.jsonError"), e);
         }
-        return result;
     }
 
 }

==================================================
JSONParserConstants.java
new file mode 100644
index 0000000000..924e050984
--- /dev/null
+++ b/java/org/apache/tomcat/util/json/JSONParser.jj
@@ -0,0 +1,394 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+options {
+    CHOICE_AMBIGUITY_CHECK=3;
+    OTHER_AMBIGUITY_CHECK=2;
+    ERROR_REPORTING=true;
+    JAVA_UNICODE_ESCAPE=true;
+    UNICODE_INPUT=true;
+    IGNORE_CASE=true;
+    SUPPORT_CLASS_VISIBILITY_PUBLIC=true;
+    FORCE_LA_CHECK=true;
+    CACHE_TOKENS=true;
+    SANITY_CHECK = true;
+    STATIC=false;
+  //KEEP_LINE_COLUMN=true;
+}
+
+PARSER_BEGIN(JSONParser)
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.util.json;
+
+import java.io.*;
+import java.util.*;
+import java.math.*;
+
+/**
+* Basic JSON parser generated by JavaCC. It consumes the input provided through the constructor when 
+* {@code parseObject()}, {@code parseList()}, or {@code parse()} are called, and there is no way to directly
+* reset the state.
+* Set the {@code fallbackToString} property if you want to enable
+* unparsable constructs (such as unquoted strings) to be handled as Strings: otherwise, they are a parse
+* error.
+*
+* <p />
+*
+* This class makes no pretenses towards being thread safe.
+*/
+public class JSONParser {
+
+    private boolean nativeNumbers = false;
+
+    public JSONParser(String input) {
+    this(new StringReader(input));
+  }
+
+    /**
+    * Parses a JSON object into a Java {@code Map}.
+    */
+    public LinkedHashMap<String,Object> parseObject() throws ParseException { 
+        LinkedHashMap<String,Object> toReturn = object(); 
+        if(!ensureEOF()) throw new IllegalStateException("Expected EOF, but still had content to parse");
+        return toReturn;
+    }
+
+    /**
+    * Parses a JSON array into a Java {@code List}.
+    */
+    public ArrayList<Object> parseArray() throws ParseException {   
+        ArrayList<Object> toReturn = list(); 
+        if(!ensureEOF()) throw new IllegalStateException("Expected EOF, but still had content to parse");
+        return toReturn;
+    }
+
+    /**
+    * Parses any JSON-parseable object, returning the value. 
+    */
+    public Object parse() throws ParseException { 
+        Object toReturn = anything(); 
+        if(!ensureEOF()) throw new IllegalStateException("Expected EOF, but still had content to parse");
+        return toReturn;
+    }
+
+    private static String substringBefore(String str, char delim) {
+        int pos = str.indexOf(delim);
+        if(pos == -1) return str;
+        return str.substring(0, pos);
+    }
+
+    public void setNativeNumbers(boolean value) {
+        this.nativeNumbers = value;
+    }
+
+    public boolean getNativeNumbers() {
+        return this.nativeNumbers;
+    }
+
+}
+
+PARSER_END(JSONParser)
+
+// Ignore comments
+SKIP: {
+    <C_SINGLE_COMMENT: "//" (~["\n","\r","\f"])* <EOL>>
+| <C_MULTILINE_COMMENT: "/*" (~[])* "*/">
+| <SH_SINGLE_COMMENT: "#" (~["\n","\r","\f"])* <EOL>>
+| <WHITESPACE: " " | "\t"> 
+| <EOL: "\n" | "\r" | "\f"> 
+}
+
+// Common tokens
+TOKEN: {
+    <COMMA: ",">
+}
+
+// Object tokens
+TOKEN:{
+    <BRACE_OPEN: "{">
+| <BRACE_CLOSE: "}">
+| <COLON: ":">
+}
+
+// Array tokens
+TOKEN:{
+    <BRACKET_OPEN: "[">
+| <BRACKET_CLOSE: "]">
+}
+
+// Number token
+TOKEN:{
+    <#ZERO: "0">
+| <#DIGIT_NONZERO: ["1"-"9"]>
+| <#DIGIT: (<DIGIT_NONZERO> | <ZERO>) >
+| <NUMBER_INTEGER:
+        ("-")?
+        ( (<ZERO>)+ | ( <DIGIT_NONZERO> (<DIGIT>)* ) ) 
+    >
+| <NUMBER_DECIMAL: 
+        ("-")?  
+        ( (<ZERO>)+ | ( <DIGIT_NONZERO> (<DIGIT>)* ) ) 
+        ("." 
+            (<DIGIT>)+  
+            (
+                ["e","E"]
+                ("+" | "-")?
+                (<DIGIT>)+
+            )?
+        )
+    >
+}
+
+// Boolean tokens
+TOKEN:{
+    <TRUE: "true">
+| <FALSE: "false">
+}
+
+// Null token
+TOKEN:{
+    <NULL: "null">
+}
+
+// String tokens
+TOKEN:{
+    <#QUOTE_DOUBLE: "\"">
+| <#QUOTE_SINGLE: "'">
+| <STRING_SINGLE_EMPTY: "''">
+| <STRING_DOUBLE_EMPTY: "\"\"">
+| <#STRING_SINGLE_BODY: (
+        (~["'","\\","\r","\n","\f","\t"]) |
+        ( "\\" ( "r" | "n" | "f" | "\\" | "/" | "'" | "b" | "t" ) )
+    )+>
+| <#STRING_DOUBLE_BODY: (
+        (~["\"","\\","\r","\n","\f","\t"]) |
+        ( "\\" ( "r" | "n" | "f" | "\\" | "/" | "\"" | "b" | "t" ) )
+    )+>
+| <STRING_SINGLE_NONEMPTY: <QUOTE_SINGLE> <STRING_SINGLE_BODY> <QUOTE_SINGLE>>
+| <STRING_DOUBLE_NONEMPTY: <QUOTE_DOUBLE> <STRING_DOUBLE_BODY> <QUOTE_DOUBLE>>
+| <RUBY_SYMBOL:  ":" (["a"-"z"] | ["A"-"Z"] | ["0"-"9"] | "_")+>
+}
+
+// Raw symbol tokens
+TOKEN:{
+    <SYMBOL: (["a"-"z", "A"-"Z", "0", "1"-"9"])+ >
+}
+
+
+boolean ensureEOF() : {}{
+    <EOF>
+    { return true; }
+}
+
+Object anything() : { 
+    Object x;
+}{
+    ( x = object()
+    | x = list()
+    | x = value()
+    )
+    { return x; }
+}
+
+String objectKey() : {
+    Object o;
+    String key;
+} {
+    (
+        key = string()
+    | key = symbol()
+    | ( 
+        nullValue()
+        { key = null; }
+        )
+    | (
+            ( o = booleanValue() | o = number() )
+            { key = o.toString(); }
+        )
+    )
+    { return key; }
+}
+
+LinkedHashMap<String,Object> object() : {
+    final LinkedHashMap<String,Object> map = new LinkedHashMap<String,Object>();
+    String key;
+    Object value;
+}{
+    <BRACE_OPEN>
+    [
+        key = objectKey() 
+        <COLON>
+        value = anything()
+        { map.put(key, value); }
+        { key = null; value = null; }
+        (
+            <COMMA>
+            key = objectKey()
+            <COLON>
+            value = anything()
+            { map.put(key, value); }
+            { key = null; value = null; }
+        )*
+    ]
+    <BRACE_CLOSE>
+    { return map; }
+}
+
+ArrayList<Object> list() : {
+    final ArrayList<Object> list = new ArrayList<Object>(); 
+    Object value;
+}{
+    <BRACKET_OPEN>
+    [
+        value = anything()
+        { list.add(value); }
+        { value = null; }
+        (
+            <COMMA>
+            value = anything()
+            { list.add(value); }
+            { value = null; }
+        )*
+    ]
+    <BRACKET_CLOSE>
+    { 
+        list.trimToSize();
+        return list; 
+    }
+}
+
+Object value() : {
+    Object x;
+}{
+    ( x = string()
+    | x = number()
+    | x = booleanValue()
+    | x = nullValue()
+    )
+    { return x; }
+}
+
+Object nullValue(): {}{
+    <NULL>
+    { return null; }
+}
+
+Boolean booleanValue(): {
+    Boolean b;
+}{
+    (
+        (
+            <TRUE>
+            { b = Boolean.TRUE; }
+        ) | (
+            <FALSE>
+            { b = Boolean.FALSE; }
+        )   
+    )
+    { return b; }
+}
+
+Number number(): {
+    Token t;
+}{ 
+    (
+        t = <NUMBER_DECIMAL>
+        { 
+            if(nativeNumbers) {
+                return new Long(t.image);
+            } else {
+                return new BigDecimal(t.image); 
+            }
+        }
+    ) | (
+        t = <NUMBER_INTEGER>
+        { 
+            if(nativeNumbers) {
+                return new Double(t.image);
+            } else {
+                return new BigInteger(substringBefore(t.image, '.')); 
+            }
+        }
+    )
+}
+
+String string() : {
+    String s;
+}{
+    ( s = doubleQuoteString() 
+    | s = singleQuoteString()
+    | s = rubySymbol()
+    )
+    { return s; }
+}
+
+String rubySymbol(): {
+}{
+    <RUBY_SYMBOL>
+    { return token.image.substring(1); }
+}
+
+String doubleQuoteString() : {
+}{
+    (
+        <STRING_DOUBLE_EMPTY>
+        { return ""; }
+    ) | (
+        <STRING_DOUBLE_NONEMPTY>
+        { 
+            String image = token.image;
+            return image.substring(1, image.length()-1); 
+        }
+    )
+}
+
+String singleQuoteString() : {
+}{
+    (
+        <STRING_SINGLE_EMPTY>
+        { return ""; }
+    ) | (
+        <STRING_SINGLE_NONEMPTY>
+        { 
+            String image = token.image;
+            return image.substring(1, image.length()-1); 
+        }
+    )
+}
+
+String symbol() : {
+}{
+    <SYMBOL>
+    { return token.image; }
+}

==================================================
JSONParserTokenManager.java
new file mode 100644
index 0000000000..1e6ad6b450
--- /dev/null
+++ b/java/org/apache/tomcat/util/json/JSONParserConstants.java
@@ -0,0 +1,126 @@
+/* Generated By:JavaCC: Do not edit this line. JSONParserConstants.java */
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.util.json;
+
+
+/**
+ * Token literal values and constants.
+ * Generated by org.javacc.parser.OtherFilesGen#start()
+ */
+public interface JSONParserConstants {
+
+  /** End of File. */
+  int EOF = 0;
+  /** RegularExpression Id. */
+  int C_SINGLE_COMMENT = 1;
+  /** RegularExpression Id. */
+  int C_MULTILINE_COMMENT = 2;
+  /** RegularExpression Id. */
+  int SH_SINGLE_COMMENT = 3;
+  /** RegularExpression Id. */
+  int WHITESPACE = 4;
+  /** RegularExpression Id. */
+  int EOL = 5;
+  /** RegularExpression Id. */
+  int COMMA = 6;
+  /** RegularExpression Id. */
+  int BRACE_OPEN = 7;
+  /** RegularExpression Id. */
+  int BRACE_CLOSE = 8;
+  /** RegularExpression Id. */
+  int COLON = 9;
+  /** RegularExpression Id. */
+  int BRACKET_OPEN = 10;
+  /** RegularExpression Id. */
+  int BRACKET_CLOSE = 11;
+  /** RegularExpression Id. */
+  int ZERO = 12;
+  /** RegularExpression Id. */
+  int DIGIT_NONZERO = 13;
+  /** RegularExpression Id. */
+  int DIGIT = 14;
+  /** RegularExpression Id. */
+  int NUMBER_INTEGER = 15;
+  /** RegularExpression Id. */
+  int NUMBER_DECIMAL = 16;
+  /** RegularExpression Id. */
+  int TRUE = 17;
+  /** RegularExpression Id. */
+  int FALSE = 18;
+  /** RegularExpression Id. */
+  int NULL = 19;
+  /** RegularExpression Id. */
+  int QUOTE_DOUBLE = 20;
+  /** RegularExpression Id. */
+  int QUOTE_SINGLE = 21;
+  /** RegularExpression Id. */
+  int STRING_SINGLE_EMPTY = 22;
+  /** RegularExpression Id. */
+  int STRING_DOUBLE_EMPTY = 23;
+  /** RegularExpression Id. */
+  int STRING_SINGLE_BODY = 24;
+  /** RegularExpression Id. */
+  int STRING_DOUBLE_BODY = 25;
+  /** RegularExpression Id. */
+  int STRING_SINGLE_NONEMPTY = 26;
+  /** RegularExpression Id. */
+  int STRING_DOUBLE_NONEMPTY = 27;
+  /** RegularExpression Id. */
+  int RUBY_SYMBOL = 28;
+  /** RegularExpression Id. */
+  int SYMBOL = 29;
+
+  /** Lexical state. */
+  int DEFAULT = 0;
+
+  /** Literal token values. */
+  String[] tokenImage = {
+    "<EOF>",
+    "<C_SINGLE_COMMENT>",
+    "<C_MULTILINE_COMMENT>",
+    "<SH_SINGLE_COMMENT>",
+    "<WHITESPACE>",
+    "<EOL>",
+    "\",\"",
+    "\"{\"",
+    "\"}\"",
+    "\":\"",
+    "\"[\"",
+    "\"]\"",
+    "\"0\"",
+    "<DIGIT_NONZERO>",
+    "<DIGIT>",
+    "<NUMBER_INTEGER>",
+    "<NUMBER_DECIMAL>",
+    "\"true\"",
+    "\"false\"",
+    "\"null\"",
+    "\"\\\"\"",
+    "\"\\\'\"",
+    "\"\\\'\\\'\"",
+    "\"\\\"\\\"\"",
+    "<STRING_SINGLE_BODY>",
+    "<STRING_DOUBLE_BODY>",
+    "<STRING_SINGLE_NONEMPTY>",
+    "<STRING_DOUBLE_NONEMPTY>",
+    "<RUBY_SYMBOL>",
+    "<SYMBOL>",
+  };
+
+}

==================================================
JavaCharStream.java
new file mode 100644
index 0000000000..5f41aefa5a
--- /dev/null
+++ b/java/org/apache/tomcat/util/json/JSONParserTokenManager.java
@@ -0,0 +1,847 @@
+/* JSONParserTokenManager.java */
+/* Generated By:JavaCC: Do not edit this line. JSONParserTokenManager.java */
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.util.json;
+import java.io.*;
+import java.util.*;
+import java.math.*;
+
+/** Token Manager. */
+public class JSONParserTokenManager implements JSONParserConstants {
+
+  /** Debug output. */
+  public  java.io.PrintStream debugStream = System.out;
+  /** Set debug output. */
+  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
+private final int jjStopStringLiteralDfa_0(int pos, long active0){
+   switch (pos)
+   {
+      case 0:
+         if ((active0 & 0xe0000L) != 0L)
+         {
+            jjmatchedKind = 29;
+            return 17;
+         }
+         if ((active0 & 0x200L) != 0L)
+            return 16;
+         if ((active0 & 0x400000L) != 0L)
+            return 40;
+         if ((active0 & 0x800000L) != 0L)
+            return 41;
+         return -1;
+      case 1:
+         if ((active0 & 0xe0000L) != 0L)
+         {
+            jjmatchedKind = 29;
+            jjmatchedPos = 1;
+            return 17;
+         }
+         return -1;
+      case 2:
+         if ((active0 & 0xe0000L) != 0L)
+         {
+            jjmatchedKind = 29;
+            jjmatchedPos = 2;
+            return 17;
+         }
+         return -1;
+      case 3:
+         if ((active0 & 0x40000L) != 0L)
+         {
+            jjmatchedKind = 29;
+            jjmatchedPos = 3;
+            return 17;
+         }
+         if ((active0 & 0xa0000L) != 0L)
+            return 17;
+         return -1;
+      default :
+         return -1;
+   }
+}
+private final int jjStartNfa_0(int pos, long active0){
+   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1);
+}
+private int jjStopAtPos(int pos, int kind)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   return pos + 1;
+}
+private int jjMoveStringLiteralDfa0_0(){
+   switch(curChar)
+   {
+      case 34:
+         return jjMoveStringLiteralDfa1_0(0x800000L);
+      case 39:
+         return jjMoveStringLiteralDfa1_0(0x400000L);
+      case 44:
+         return jjStopAtPos(0, 6);
+      case 58:
+         return jjStartNfaWithStates_0(0, 9, 16);
+      case 91:
+         return jjStopAtPos(0, 10);
+      case 93:
+         return jjStopAtPos(0, 11);
+      case 70:
+      case 102:
+         return jjMoveStringLiteralDfa1_0(0x40000L);
+      case 78:
+      case 110:
+         return jjMoveStringLiteralDfa1_0(0x80000L);
+      case 84:
+      case 116:
+         return jjMoveStringLiteralDfa1_0(0x20000L);
+      case 123:
+         return jjStopAtPos(0, 7);
+      case 125:
+         return jjStopAtPos(0, 8);
+      default :
+         return jjMoveNfa_0(0, 0);
+   }
+}
+private int jjMoveStringLiteralDfa1_0(long active0){
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(0, active0);
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 34:
+         if ((active0 & 0x800000L) != 0L)
+            return jjStopAtPos(1, 23);
+         break;
+      case 39:
+         if ((active0 & 0x400000L) != 0L)
+            return jjStopAtPos(1, 22);
+         break;
+      case 65:
+      case 97:
+         return jjMoveStringLiteralDfa2_0(active0, 0x40000L);
+      case 82:
+      case 114:
+         return jjMoveStringLiteralDfa2_0(active0, 0x20000L);
+      case 85:
+      case 117:
+         return jjMoveStringLiteralDfa2_0(active0, 0x80000L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(0, active0);
+}
+private int jjMoveStringLiteralDfa2_0(long old0, long active0){
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(0, old0);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(1, active0);
+      return 2;
+   }
+   switch(curChar)
+   {
+      case 76:
+      case 108:
+         return jjMoveStringLiteralDfa3_0(active0, 0xc0000L);
+      case 85:
+      case 117:
+         return jjMoveStringLiteralDfa3_0(active0, 0x20000L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(1, active0);
+}
+private int jjMoveStringLiteralDfa3_0(long old0, long active0){
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(1, old0);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(2, active0);
+      return 3;
+   }
+   switch(curChar)
+   {
+      case 69:
+      case 101:
+         if ((active0 & 0x20000L) != 0L)
+            return jjStartNfaWithStates_0(3, 17, 17);
+         break;
+      case 76:
+      case 108:
+         if ((active0 & 0x80000L) != 0L)
+            return jjStartNfaWithStates_0(3, 19, 17);
+         break;
+      case 83:
+      case 115:
+         return jjMoveStringLiteralDfa4_0(active0, 0x40000L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(2, active0);
+}
+private int jjMoveStringLiteralDfa4_0(long old0, long active0){
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(2, old0);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(3, active0);
+      return 4;
+   }
+   switch(curChar)
+   {
+      case 69:
+      case 101:
+         if ((active0 & 0x40000L) != 0L)
+            return jjStartNfaWithStates_0(4, 18, 17);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(3, active0);
+}
+private int jjStartNfaWithStates_0(int pos, int kind, int state)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { return pos + 1; }
+   return jjMoveNfa_0(state, pos + 1);
+}
+static final long[] jjbitVec0 = {
+   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+static final long[] jjbitVec2 = {
+   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+private int jjMoveNfa_0(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 40;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 40:
+               case 6:
+                  if ((0xffffff7fffffc9ffL & l) != 0L)
+                     { jjCheckNAddStates(0, 2); }
+                  break;
+               case 0:
+                  if ((0x3ff000000000000L & l) != 0L)
+                  {
+                     if (kind > 29)
+                        kind = 29;
+                     { jjCheckNAdd(17); }
+                  }
+                  else if ((0x3400L & l) != 0L)
+                  {
+                     if (kind > 5)
+                        kind = 5;
+                  }
+                  else if ((0x100000200L & l) != 0L)
+                  {
+                     if (kind > 4)
+                        kind = 4;
+                  }
+                  else if (curChar == 45)
+                     { jjCheckNAddStates(3, 6); }
+                  else if (curChar == 47)
+                     { jjAddStates(7, 8); }
+                  else if (curChar == 58)
+                     { jjCheckNAdd(16); }
+                  else if (curChar == 34)
+                     { jjCheckNAddTwoStates(11, 12); }
+                  else if (curChar == 39)
+                     { jjCheckNAddTwoStates(6, 7); }
+                  else if (curChar == 35)
+                     { jjCheckNAddTwoStates(1, 2); }
+                  if ((0x3fe000000000000L & l) != 0L)
+                  {
+                     if (kind > 15)
+                        kind = 15;
+                     { jjCheckNAddStates(9, 11); }
+                  }
+                  else if (curChar == 48)
+                  {
+                     if (kind > 15)
+                        kind = 15;
+                     { jjCheckNAddStates(12, 14); }
+                  }
+                  break;
+               case 41:
+               case 11:
+                  if ((0xfffffffbffffc9ffL & l) != 0L)
+                     { jjCheckNAddStates(15, 17); }
+                  break;
+               case 1:
+                  if ((0xffffffffffffcbffL & l) != 0L)
+                     { jjCheckNAddTwoStates(1, 2); }
+                  break;
+               case 2:
+                  if ((0x3400L & l) != 0L && kind > 3)
+                     kind = 3;
+                  break;
+               case 3:
+                  if ((0x100000200L & l) != 0L && kind > 4)
+                     kind = 4;
+                  break;
+               case 4:
+                  if ((0x3400L & l) != 0L && kind > 5)
+                     kind = 5;
+                  break;
+               case 5:
+                  if (curChar == 39)
+                     { jjCheckNAddTwoStates(6, 7); }
+                  break;
+               case 8:
+                  if ((0x808000000000L & l) != 0L)
+                     { jjCheckNAddStates(0, 2); }
+                  break;
+               case 9:
+                  if (curChar == 39 && kind > 26)
+                     kind = 26;
+                  break;
+               case 10:
+                  if (curChar == 34)
+                     { jjCheckNAddTwoStates(11, 12); }
+                  break;
+               case 13:
+                  if ((0x800400000000L & l) != 0L)
+                     { jjCheckNAddStates(15, 17); }
+                  break;
+               case 14:
+                  if (curChar == 34 && kind > 27)
+                     kind = 27;
+                  break;
+               case 15:
+                  if (curChar == 58)
+                     { jjCheckNAdd(16); }
+                  break;
+               case 16:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 28)
+                     kind = 28;
+                  { jjCheckNAdd(16); }
+                  break;
+               case 17:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 29)
+                     kind = 29;
+                  { jjCheckNAdd(17); }
+                  break;
+               case 18:
+                  if (curChar == 47)
+                     { jjAddStates(7, 8); }
+                  break;
+               case 19:
+                  if (curChar == 47)
+                     { jjCheckNAddTwoStates(20, 21); }
+                  break;
+               case 20:
+                  if ((0xffffffffffffcbffL & l) != 0L)
+                     { jjCheckNAddTwoStates(20, 21); }
+                  break;
+               case 21:
+                  if ((0x3400L & l) != 0L && kind > 1)
+                     kind = 1;
+                  break;
+               case 22:
+                  if (curChar == 42)
+                     { jjCheckNAddTwoStates(23, 25); }
+                  break;
+               case 23:
+                  { jjCheckNAddTwoStates(23, 25); }
+                  break;
+               case 24:
+                  if (curChar == 47 && kind > 2)
+                     kind = 2;
+                  break;
+               case 25:
+                  if (curChar == 42)
+                     jjstateSet[jjnewStateCnt++] = 24;
+                  break;
+               case 26:
+                  if (curChar == 45)
+                     { jjCheckNAddStates(3, 6); }
+                  break;
+               case 27:
+                  if (curChar != 48)
+                     break;
+                  if (kind > 15)
+                     kind = 15;
+                  { jjCheckNAdd(27); }
+                  break;
+               case 28:
+                  if ((0x3fe000000000000L & l) == 0L)
+                     break;
+                  if (kind > 15)
+                     kind = 15;
+                  { jjCheckNAdd(29); }
+                  break;
+               case 29:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 15)
+                     kind = 15;
+                  { jjCheckNAdd(29); }
+                  break;
+               case 30:
+                  if (curChar == 48)
+                     { jjCheckNAddTwoStates(30, 31); }
+                  break;
+               case 31:
+                  if (curChar == 46)
+                     { jjCheckNAdd(32); }
+                  break;
+               case 32:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 16)
+                     kind = 16;
+                  { jjCheckNAddTwoStates(32, 33); }
+                  break;
+               case 34:
+                  if ((0x280000000000L & l) != 0L)
+                     { jjCheckNAdd(35); }
+                  break;
+               case 35:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 16)
+                     kind = 16;
+                  { jjCheckNAdd(35); }
+                  break;
+               case 36:
+                  if ((0x3fe000000000000L & l) != 0L)
+                     { jjCheckNAddTwoStates(37, 31); }
+                  break;
+               case 37:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     { jjCheckNAddTwoStates(37, 31); }
+                  break;
+               case 38:
+                  if (curChar != 48)
+                     break;
+                  if (kind > 15)
+                     kind = 15;
+                  { jjCheckNAddStates(12, 14); }
+                  break;
+               case 39:
+                  if ((0x3fe000000000000L & l) == 0L)
+                     break;
+                  if (kind > 15)
+                     kind = 15;
+                  { jjCheckNAddStates(9, 11); }
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 40:
+                  if ((0xffffffffefffffffL & l) != 0L)
+                     { jjCheckNAddStates(0, 2); }
+                  else if (curChar == 92)
+                     jjstateSet[jjnewStateCnt++] = 8;
+                  break;
+               case 0:
+               case 17:
+                  if ((0x7fffffe07fffffeL & l) == 0L)
+                     break;
+                  if (kind > 29)
+                     kind = 29;
+                  { jjCheckNAdd(17); }
+                  break;
+               case 41:
+                  if ((0xffffffffefffffffL & l) != 0L)
+                     { jjCheckNAddStates(15, 17); }
+                  else if (curChar == 92)
+                     jjstateSet[jjnewStateCnt++] = 13;
+                  break;
+               case 1:
+                  { jjAddStates(18, 19); }
+                  break;
+               case 6:
+                  if ((0xffffffffefffffffL & l) != 0L)
+                     { jjCheckNAddStates(0, 2); }
+                  break;
+               case 7:
+                  if (curChar == 92)
+                     jjstateSet[jjnewStateCnt++] = 8;
+                  break;
+               case 8:
+                  if ((0x14404410144044L & l) != 0L)
+                     { jjCheckNAddStates(0, 2); }
+                  break;
+               case 11:
+                  if ((0xffffffffefffffffL & l) != 0L)
+                     { jjCheckNAddStates(15, 17); }
+                  break;
+               case 12:
+                  if (curChar == 92)
+                     jjstateSet[jjnewStateCnt++] = 13;
+                  break;
+               case 13:
+                  if ((0x14404410144044L & l) != 0L)
+                     { jjCheckNAddStates(15, 17); }
+                  break;
+               case 16:
+                  if ((0x7fffffe87fffffeL & l) == 0L)
+                     break;
+                  if (kind > 28)
+                     kind = 28;
+                  jjstateSet[jjnewStateCnt++] = 16;
+                  break;
+               case 20:
+                  { jjAddStates(20, 21); }
+                  break;
+               case 23:
+                  { jjAddStates(22, 23); }
+                  break;
+               case 33:
+                  if ((0x2000000020L & l) != 0L)
+                     { jjAddStates(24, 25); }
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 40:
+               case 6:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     { jjCheckNAddStates(0, 2); }
+                  break;
+               case 41:
+               case 11:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     { jjCheckNAddStates(15, 17); }
+                  break;
+               case 1:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     { jjAddStates(18, 19); }
+                  break;
+               case 20:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     { jjAddStates(20, 21); }
+                  break;
+               case 23:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     { jjAddStates(22, 23); }
+                  break;
+               default : if (i1 == 0 || l1 == 0 || i2 == 0 ||  l2 == 0) break; else break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 40 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+
+/** Token literal values. */
+public static final String[] jjstrLiteralImages = {
+"", null, null, null, null, null, "\54", "\173", "\175", "\72", "\133", 
+"\135", null, null, null, null, null, null, null, null, null, null, "\47\47", 
+"\42\42", null, null, null, null, null, null, };
+protected Token jjFillToken()
+{
+   final Token t;
+   final String curTokenImage;
+   final int beginLine;
+   final int endLine;
+   final int beginColumn;
+   final int endColumn;
+   String im = jjstrLiteralImages[jjmatchedKind];
+   curTokenImage = (im == null) ? input_stream.GetImage() : im;
+   beginLine = input_stream.getBeginLine();
+   beginColumn = input_stream.getBeginColumn();
+   endLine = input_stream.getEndLine();
+   endColumn = input_stream.getEndColumn();
+   t = Token.newToken(jjmatchedKind);
+   t.kind = jjmatchedKind;
+   t.image = curTokenImage;
+
+   t.beginLine = beginLine;
+   t.endLine = endLine;
+   t.beginColumn = beginColumn;
+   t.endColumn = endColumn;
+
+   return t;
+}
+static final int[] jjnextStates = {
+   6, 7, 9, 27, 28, 30, 36, 19, 22, 29, 37, 31, 27, 30, 31, 11, 
+   12, 14, 1, 2, 20, 21, 23, 25, 34, 35, 
+};
+private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
+{
+   switch(hiByte)
+   {
+      case 0:
+         return ((jjbitVec2[i2] & l2) != 0L);
+      default :
+         if ((jjbitVec0[i1] & l1) != 0L)
+            return true;
+         return false;
+   }
+}
+
+int curLexState = 0;
+int defaultLexState = 0;
+int jjnewStateCnt;
+int jjround;
+int jjmatchedPos;
+int jjmatchedKind;
+
+/** Get the next Token. */
+public Token getNextToken() 
+{
+  Token matchedToken;
+  int curPos = 0;
+
+  EOFLoop :
+  for (;;)
+  {
+   try
+   {
+      curChar = input_stream.BeginToken();
+   }
+   catch(Exception e)
+   {
+      jjmatchedKind = 0;
+      jjmatchedPos = -1;
+      matchedToken = jjFillToken();
+      return matchedToken;
+   }
+
+   jjmatchedKind = 0x7fffffff;
+   jjmatchedPos = 0;
+   curPos = jjMoveStringLiteralDfa0_0();
+   if (jjmatchedKind != 0x7fffffff)
+   {
+      if (jjmatchedPos + 1 < curPos)
+         input_stream.backup(curPos - jjmatchedPos - 1);
+      if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+      {
+         matchedToken = jjFillToken();
+         return matchedToken;
+      }
+      else
+      {
+         continue EOFLoop;
+      }
+   }
+   int error_line = input_stream.getEndLine();
+   int error_column = input_stream.getEndColumn();
+   String error_after = null;
+   boolean EOFSeen = false;
+   try { input_stream.readChar(); input_stream.backup(1); }
+   catch (java.io.IOException e1) {
+      EOFSeen = true;
+      error_after = curPos <= 1 ? "" : input_stream.GetImage();
+      if (curChar == '\n' || curChar == '\r') {
+         error_line++;
+         error_column = 0;
+      }
+      else
+         error_column++;
+   }
+   if (!EOFSeen) {
+      input_stream.backup(1);
+      error_after = curPos <= 1 ? "" : input_stream.GetImage();
+   }
+   throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
+  }
+}
+
+void SkipLexicalActions(Token matchedToken)
+{
+   switch(jjmatchedKind)
+   {
+      default :
+         break;
+   }
+}
+void MoreLexicalActions()
+{
+   jjimageLen += (lengthOfMatch = jjmatchedPos + 1);
+   switch(jjmatchedKind)
+   {
+      default :
+         break;
+   }
+}
+void TokenLexicalActions(Token matchedToken)
+{
+   switch(jjmatchedKind)
+   {
+      default :
+         break;
+   }
+}
+private void jjCheckNAdd(int state)
+{
+   if (jjrounds[state] != jjround)
+   {
+      jjstateSet[jjnewStateCnt++] = state;
+      jjrounds[state] = jjround;
+   }
+}
+private void jjAddStates(int start, int end)
+{
+   do {
+      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
+   } while (start++ != end);
+}
+private void jjCheckNAddTwoStates(int state1, int state2)
+{
+   jjCheckNAdd(state1);
+   jjCheckNAdd(state2);
+}
+
+private void jjCheckNAddStates(int start, int end)
+{
+   do {
+      jjCheckNAdd(jjnextStates[start]);
+   } while (start++ != end);
+}
+
+    /** Constructor. */
+    public JSONParserTokenManager(JavaCharStream stream){
+
+      if (JavaCharStream.staticFlag)
+            throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");
+
+    input_stream = stream;
+  }
+
+  /** Constructor. */
+  public JSONParserTokenManager (JavaCharStream stream, int lexState){
+    ReInit(stream);
+    SwitchTo(lexState);
+  }
+
+  /** Reinitialise parser. */
+  
+  public void ReInit(JavaCharStream stream)
+  {
+
+
+    jjmatchedPos =
+    jjnewStateCnt =
+    0;
+    curLexState = defaultLexState;
+    input_stream = stream;
+    ReInitRounds();
+  }
+
+  private void ReInitRounds()
+  {
+    int i;
+    jjround = 0x80000001;
+    for (i = 40; i-- > 0;)
+      jjrounds[i] = 0x80000000;
+  }
+
+  /** Reinitialise parser. */
+  public void ReInit(JavaCharStream stream, int lexState)
+  
+  {
+    ReInit(stream);
+    SwitchTo(lexState);
+  }
+
+  /** Switch to specified lex state. */
+  public void SwitchTo(int lexState)
+  {
+    if (lexState >= 1 || lexState < 0)
+      throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
+    else
+      curLexState = lexState;
+  }
+
+
+/** Lexer state names. */
+public static final String[] lexStateNames = {
+   "DEFAULT",
+};
+
+/** Lex State array. */
+public static final int[] jjnewLexState = {
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, -1, -1, -1, 
+};
+static final long[] jjtoToken = {
+   0x3ccf8fc1L, 
+};
+static final long[] jjtoSkip = {
+   0x3eL, 
+};
+static final long[] jjtoSpecial = {
+   0x0L, 
+};
+static final long[] jjtoMore = {
+   0x0L, 
+};
+    protected JavaCharStream  input_stream;
+
+    private final int[] jjrounds = new int[40];
+    private final int[] jjstateSet = new int[2 * 40];
+    private final StringBuilder jjimage = new StringBuilder();
+    private StringBuilder image = jjimage;
+    private int jjimageLen;
+    private int lengthOfMatch;
+    protected int curChar;
+}

==================================================
ParseException.java
new file mode 100644
index 0000000000..7ad682faef
--- /dev/null
+++ b/java/org/apache/tomcat/util/json/JavaCharStream.java
@@ -0,0 +1,637 @@
+/* Generated By:JavaCC: Do not edit this line. JavaCharStream.java Version 7.0 */
+/* JavaCCOptions:STATIC=false,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.util.json;
+
+/**
+ * An implementation of interface CharStream, where the stream is assumed to
+ * contain only ASCII characters (with java-like unicode escape processing).
+ */
+
+public
+class JavaCharStream
+{
+  /** Whether parser is static. */
+  public static final boolean staticFlag = false;
+
+  static final int hexval(char c) throws java.io.IOException {
+    switch(c)
+    {
+       case '0' :
+          return 0;
+       case '1' :
+          return 1;
+       case '2' :
+          return 2;
+       case '3' :
+          return 3;
+       case '4' :
+          return 4;
+       case '5' :
+          return 5;
+       case '6' :
+          return 6;
+       case '7' :
+          return 7;
+       case '8' :
+          return 8;
+       case '9' :
+          return 9;
+
+       case 'a' :
+       case 'A' :
+          return 10;
+       case 'b' :
+       case 'B' :
+          return 11;
+       case 'c' :
+       case 'C' :
+          return 12;
+       case 'd' :
+       case 'D' :
+          return 13;
+       case 'e' :
+       case 'E' :
+          return 14;
+       case 'f' :
+       case 'F' :
+          return 15;
+    }
+
+    throw new java.io.IOException(); // Should never come here
+  }
+
+/** Position in buffer. */
+  public int bufpos = -1;
+  int bufsize;
+  int available;
+  int tokenBegin;
+  protected int bufline[];
+  protected int bufcolumn[];
+
+  protected int column = 0;
+  protected int line = 1;
+
+  protected boolean prevCharIsCR = false;
+  protected boolean prevCharIsLF = false;
+
+  protected java.io.Reader inputStream;
+
+  protected char[] nextCharBuf;
+  protected char[] buffer;
+  protected int maxNextCharInd = 0;
+  protected int nextCharInd = -1;
+  protected int inBuf = 0;
+  protected int tabSize = 1;
+  protected boolean trackLineColumn = true;
+
+  public void setTabSize(int i) { tabSize = i; }
+  public int getTabSize() { return tabSize; }
+
+  protected void ExpandBuff(boolean wrapAround)
+  {
+    char[] newbuffer = new char[bufsize + 2048];
+    int newbufline[] = new int[bufsize + 2048];
+    int newbufcolumn[] = new int[bufsize + 2048];
+
+    try
+    {
+      if (wrapAround)
+      {
+        System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
+        System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);
+        buffer = newbuffer;
+
+        System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
+        System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
+        bufline = newbufline;
+
+        System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
+        System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
+        bufcolumn = newbufcolumn;
+
+        bufpos += (bufsize - tokenBegin);
+    }
+    else
+    {
+        System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
+        buffer = newbuffer;
+
+        System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
+        bufline = newbufline;
+
+        System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
+        bufcolumn = newbufcolumn;
+
+        bufpos -= tokenBegin;
+      }
+    }
+    catch (Throwable t)
+    {
+      throw new Error(t.getMessage());
+    }
+
+    available = (bufsize += 2048);
+    tokenBegin = 0;
+  }
+
+  protected void FillBuff() throws java.io.IOException
+  {
+    int i;
+    if (maxNextCharInd == 4096)
+      maxNextCharInd = nextCharInd = 0;
+
+    try {
+      if ((i = inputStream.read(nextCharBuf, maxNextCharInd,
+                                          4096 - maxNextCharInd)) == -1)
+      {
+        inputStream.close();
+        throw new java.io.IOException();
+      }
+      else
+         maxNextCharInd += i;
+      return;
+    }
+    catch(java.io.IOException e) {
+      if (bufpos != 0)
+      {
+        --bufpos;
+        backup(0);
+      }
+      else
+      {
+        bufline[bufpos] = line;
+        bufcolumn[bufpos] = column;
+      }
+      throw e;
+    }
+  }
+
+  protected char ReadByte() throws java.io.IOException
+  {
+    if (++nextCharInd >= maxNextCharInd)
+      FillBuff();
+
+    return nextCharBuf[nextCharInd];
+  }
+
+/** @return starting character for token. */
+  public char BeginToken() throws java.io.IOException
+  {
+    if (inBuf > 0)
+    {
+      --inBuf;
+
+      if (++bufpos == bufsize)
+        bufpos = 0;
+
+      tokenBegin = bufpos;
+      return buffer[bufpos];
+    }
+
+    tokenBegin = 0;
+    bufpos = -1;
+
+    return readChar();
+  }
+
+  protected void AdjustBuffSize()
+  {
+    if (available == bufsize)
+    {
+      if (tokenBegin > 2048)
+      {
+        bufpos = 0;
+        available = tokenBegin;
+      }
+      else
+        ExpandBuff(false);
+    }
+    else if (available > tokenBegin)
+      available = bufsize;
+    else if ((tokenBegin - available) < 2048)
+      ExpandBuff(true);
+    else
+      available = tokenBegin;
+  }
+
+  protected void UpdateLineColumn(char c)
+  {
+    column++;
+
+    if (prevCharIsLF)
+    {
+      prevCharIsLF = false;
+      line += (column = 1);
+    }
+    else if (prevCharIsCR)
+    {
+      prevCharIsCR = false;
+      if (c == '\n')
+      {
+        prevCharIsLF = true;
+      }
+      else
+        line += (column = 1);
+    }
+
+    switch (c)
+    {
+      case '\r' :
+        prevCharIsCR = true;
+        break;
+      case '\n' :
+        prevCharIsLF = true;
+        break;
+      case '\t' :
+        column--;
+        column += (tabSize - (column % tabSize));
+        break;
+      default :
+        break;
+    }
+
+    bufline[bufpos] = line;
+    bufcolumn[bufpos] = column;
+  }
+
+/** Read a character. */
+  public char readChar() throws java.io.IOException
+  {
+    if (inBuf > 0)
+    {
+      --inBuf;
+
+      if (++bufpos == bufsize)
+        bufpos = 0;
+
+      return buffer[bufpos];
+    }
+
+    char c;
+
+    if (++bufpos == available)
+      AdjustBuffSize();
+
+    if ((buffer[bufpos] = c = ReadByte()) == '\\')
+    {
+      if (trackLineColumn) { UpdateLineColumn(c); }
+
+      int backSlashCnt = 1;
+
+      for (;;) // Read all the backslashes
+      {
+        if (++bufpos == available)
+          AdjustBuffSize();
+
+        try
+        {
+          if ((buffer[bufpos] = c = ReadByte()) != '\\')
+          {
+            if (trackLineColumn) { UpdateLineColumn(c); }
+            // found a non-backslash char.
+            if ((c == 'u') && ((backSlashCnt & 1) == 1))
+            {
+              if (--bufpos < 0)
+                bufpos = bufsize - 1;
+
+              break;
+            }
+
+            backup(backSlashCnt);
+            return '\\';
+          }
+        }
+        catch(java.io.IOException e)
+        {
+	  // We are returning one backslash so we should only backup (count-1)
+          if (backSlashCnt > 1)
+            backup(backSlashCnt-1);
+
+          return '\\';
+        }
+
+        if (trackLineColumn) { UpdateLineColumn(c); }
+        backSlashCnt++;
+      }
+
+      // Here, we have seen an odd number of backslash's followed by a 'u'
+      try
+      {
+        while ((c = ReadByte()) == 'u')
+          ++column;
+
+        buffer[bufpos] = c = (char)(hexval(c) << 12 |
+                                    hexval(ReadByte()) << 8 |
+                                    hexval(ReadByte()) << 4 |
+                                    hexval(ReadByte()));
+
+        column += 4;
+      }
+      catch(java.io.IOException e)
+      {
+        throw new Error("Invalid escape character at line " + line +
+                                         " column " + column + ".");
+      }
+
+      if (backSlashCnt == 1)
+        return c;
+      else
+      {
+        backup(backSlashCnt - 1);
+        return '\\';
+      }
+    }
+    else
+    {
+      UpdateLineColumn(c);
+      return c;
+    }
+  }
+
+  @Deprecated
+  /**
+   * @deprecated
+   * @see #getEndColumn
+   */
+  public int getColumn() {
+    return bufcolumn[bufpos];
+  }
+
+  @Deprecated
+  /**
+   * @deprecated
+   * @see #getEndLine
+   */
+  public int getLine() {
+    return bufline[bufpos];
+  }
+
+/** Get end column. */
+  public int getEndColumn() {
+    return bufcolumn[bufpos];
+  }
+
+/** Get end line. */
+  public int getEndLine() {
+    return bufline[bufpos];
+  }
+
+/** @return column of token start */
+  public int getBeginColumn() {
+    return bufcolumn[tokenBegin];
+  }
+
+/** @return line number of token start */
+  public int getBeginLine() {
+    return bufline[tokenBegin];
+  }
+
+/** Retreat. */
+  public void backup(int amount) {
+
+    inBuf += amount;
+    if ((bufpos -= amount) < 0)
+      bufpos += bufsize;
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.Reader dstream,
+                 int startline, int startcolumn, int buffersize)
+  {
+    inputStream = dstream;
+    line = startline;
+    column = startcolumn - 1;
+
+    available = bufsize = buffersize;
+    buffer = new char[buffersize];
+    bufline = new int[buffersize];
+    bufcolumn = new int[buffersize];
+    nextCharBuf = new char[4096];
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.Reader dstream,
+                                        int startline, int startcolumn)
+  {
+    this(dstream, startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.Reader dstream)
+  {
+    this(dstream, 1, 1, 4096);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.Reader dstream,
+                 int startline, int startcolumn, int buffersize)
+  {
+    inputStream = dstream;
+    line = startline;
+    column = startcolumn - 1;
+
+    if (buffer == null || buffersize != buffer.length)
+    {
+      available = bufsize = buffersize;
+      buffer = new char[buffersize];
+      bufline = new int[buffersize];
+      bufcolumn = new int[buffersize];
+      nextCharBuf = new char[4096];
+    }
+    prevCharIsLF = prevCharIsCR = false;
+    tokenBegin = inBuf = maxNextCharInd = 0;
+    nextCharInd = bufpos = -1;
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.Reader dstream,
+                                        int startline, int startcolumn)
+  {
+    ReInit(dstream, startline, startcolumn, 4096);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.Reader dstream)
+  {
+    ReInit(dstream, 1, 1, 4096);
+  }
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, String encoding, int startline,
+  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
+  {
+    this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, int startline,
+  int startcolumn, int buffersize)
+  {
+    this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, String encoding, int startline,
+                        int startcolumn) throws java.io.UnsupportedEncodingException
+  {
+    this(dstream, encoding, startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, int startline,
+                        int startcolumn)
+  {
+    this(dstream, startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
+  {
+    this(dstream, encoding, 1, 1, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream)
+  {
+    this(dstream, 1, 1, 4096);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
+  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
+  {
+    ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, int startline,
+  int startcolumn, int buffersize)
+  {
+    ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
+                     int startcolumn) throws java.io.UnsupportedEncodingException
+  {
+    ReInit(dstream, encoding, startline, startcolumn, 4096);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, int startline,
+                     int startcolumn)
+  {
+    ReInit(dstream, startline, startcolumn, 4096);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
+  {
+    ReInit(dstream, encoding, 1, 1, 4096);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream)
+  {
+    ReInit(dstream, 1, 1, 4096);
+  }
+
+  /** @return token image as String */
+  public String GetImage()
+  {
+    if (bufpos >= tokenBegin)
+      return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
+    else
+      return new String(buffer, tokenBegin, bufsize - tokenBegin) +
+                              new String(buffer, 0, bufpos + 1);
+  }
+
+  /** @return suffix */
+  public char[] GetSuffix(int len)
+  {
+    char[] ret = new char[len];
+
+    if ((bufpos + 1) >= len)
+      System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
+    else
+    {
+      System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
+                                                        len - bufpos - 1);
+      System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
+    }
+
+    return ret;
+  }
+
+  /** Set buffers back to null when finished. */
+  public void Done()
+  {
+    nextCharBuf = null;
+    buffer = null;
+    bufline = null;
+    bufcolumn = null;
+  }
+
+  /**
+   * Method to adjust line and column numbers for the start of a token.
+   */
+  public void adjustBeginLineColumn(int newLine, int newCol)
+  {
+    int start = tokenBegin;
+    int len;
+
+    if (bufpos >= tokenBegin)
+    {
+      len = bufpos - tokenBegin + inBuf + 1;
+    }
+    else
+    {
+      len = bufsize - tokenBegin + bufpos + 1 + inBuf;
+    }
+
+    int i = 0, j = 0, k = 0;
+    int nextColDiff = 0, columnDiff = 0;
+
+    while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
+    {
+      bufline[j] = newLine;
+      nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
+      bufcolumn[j] = newCol + columnDiff;
+      columnDiff = nextColDiff;
+      i++;
+    }
+
+    if (i < len)
+    {
+      bufline[j] = newLine++;
+      bufcolumn[j] = newCol + columnDiff;
+
+      while (i++ < len)
+      {
+        if (bufline[j = start % bufsize] != bufline[++start % bufsize])
+          bufline[j] = newLine++;
+        else
+          bufline[j] = newLine;
+      }
+    }
+
+    line = bufline[j];
+    column = bufcolumn[j];
+  }
+  boolean getTrackLineColumn() { return trackLineColumn; }
+  void setTrackLineColumn(boolean tlc) { trackLineColumn = tlc; }
+
+}
+/* JavaCC - OriginalChecksum=58f718af3466d6064ba0132bca4fbce2 (do not edit this line) */

==================================================
Token.java
new file mode 100644
index 0000000000..a132de1f41
--- /dev/null
+++ b/java/org/apache/tomcat/util/json/ParseException.java
@@ -0,0 +1,210 @@
+/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 7.0 */
+/* JavaCCOptions:KEEP_LINE_COLUMN=true */
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.util.json;
+
+/**
+ * This exception is thrown when parse errors are encountered.
+ * You can explicitly create objects of this exception type by
+ * calling the method generateParseException in the generated
+ * parser.
+ *
+ * You can modify this class to customize your error reporting
+ * mechanisms so long as you retain the public fields.
+ */
+public class ParseException extends Exception {
+
+  /**
+   * The version identifier for this Serializable class.
+   * Increment only if the <i>serialized</i> form of the
+   * class changes.
+   */
+  private static final long serialVersionUID = 1L;
+
+  /**
+   * The end of line string for this machine.
+   */
+  protected static String EOL = System.getProperty("line.separator", "\n");
+
+  /**
+   * This constructor is used by the method "generateParseException"
+   * in the generated parser.  Calling this constructor generates
+   * a new object of this type with the fields "currentToken",
+   * "expectedTokenSequences", and "tokenImage" set.
+   */
+  public ParseException(Token currentTokenVal,
+                        int[][] expectedTokenSequencesVal,
+                        String[] tokenImageVal
+                       )
+  {
+    super(initialise(currentTokenVal, expectedTokenSequencesVal, tokenImageVal));
+    currentToken = currentTokenVal;
+    expectedTokenSequences = expectedTokenSequencesVal;
+    tokenImage = tokenImageVal;
+  }
+
+  /**
+   * The following constructors are for use by you for whatever
+   * purpose you can think of.  Constructing the exception in this
+   * manner makes the exception behave in the normal way - i.e., as
+   * documented in the class "Throwable".  The fields "errorToken",
+   * "expectedTokenSequences", and "tokenImage" do not contain
+   * relevant information.  The JavaCC generated code does not use
+   * these constructors.
+   */
+
+  public ParseException() {
+    super();
+  }
+
+  /** Constructor with message. */
+  public ParseException(String message) {
+    super(message);
+  }
+
+
+  /**
+   * This is the last token that has been consumed successfully.  If
+   * this object has been created due to a parse error, the token
+   * followng this token will (therefore) be the first error token.
+   */
+  public Token currentToken;
+
+  /**
+   * Each entry in this array is an array of integers.  Each array
+   * of integers represents a sequence of tokens (by their ordinal
+   * values) that is expected at this point of the parse.
+   */
+  public int[][] expectedTokenSequences;
+
+  /**
+   * This is a reference to the "tokenImage" array of the generated
+   * parser within which the parse error occurred.  This array is
+   * defined in the generated ...Constants interface.
+   */
+  public String[] tokenImage;
+
+  /**
+   * It uses "currentToken" and "expectedTokenSequences" to generate a parse
+   * error message and returns it.  If this object has been created
+   * due to a parse error, and you do not catch it (it gets thrown
+   * from the parser) the correct error message
+   * gets displayed.
+   */
+  private static String initialise(Token currentToken,
+                           int[][] expectedTokenSequences,
+                           String[] tokenImage) {
+
+    StringBuffer expected = new StringBuffer();
+    int maxSize = 0;
+    for (int i = 0; i < expectedTokenSequences.length; i++) {
+      if (maxSize < expectedTokenSequences[i].length) {
+        maxSize = expectedTokenSequences[i].length;
+      }
+      for (int j = 0; j < expectedTokenSequences[i].length; j++) {
+        expected.append(tokenImage[expectedTokenSequences[i][j]]).append(' ');
+      }
+      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
+        expected.append("...");
+      }
+      expected.append(EOL).append("    ");
+    }
+    String retval = "Encountered \"";
+    Token tok = currentToken.next;
+    for (int i = 0; i < maxSize; i++) {
+      if (i != 0) retval += " ";
+      if (tok.kind == 0) {
+        retval += tokenImage[0];
+        break;
+      }
+      retval += " " + tokenImage[tok.kind];
+      retval += " \"";
+      retval += add_escapes(tok.image);
+      retval += " \"";
+      tok = tok.next;
+    }
+    retval += "\" at line " + currentToken.next.beginLine + ", column " + currentToken.next.beginColumn;
+    retval += "." + EOL;
+    
+    
+    if (expectedTokenSequences.length == 0) {
+        // Nothing to add here
+    } else {
+	    if (expectedTokenSequences.length == 1) {
+	      retval += "Was expecting:" + EOL + "    ";
+	    } else {
+	      retval += "Was expecting one of:" + EOL + "    ";
+	    }
+	    retval += expected.toString();
+    }
+    
+    return retval;
+  }
+
+
+  /**
+   * Used to convert raw characters to their escaped version
+   * when these raw version cannot be used as part of an ASCII
+   * string literal.
+   */
+  static String add_escapes(String str) {
+      StringBuffer retval = new StringBuffer();
+      char ch;
+      for (int i = 0; i < str.length(); i++) {
+        switch (str.charAt(i))
+        {
+           case '\b':
+              retval.append("\\b");
+              continue;
+           case '\t':
+              retval.append("\\t");
+              continue;
+           case '\n':
+              retval.append("\\n");
+              continue;
+           case '\f':
+              retval.append("\\f");
+              continue;
+           case '\r':
+              retval.append("\\r");
+              continue;
+           case '\"':
+              retval.append("\\\"");
+              continue;
+           case '\'':
+              retval.append("\\\'");
+              continue;
+           case '\\':
+              retval.append("\\\\");
+              continue;
+           default:
+              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
+                 String s = "0000" + Integer.toString(ch, 16);
+                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
+              } else {
+                 retval.append(ch);
+              }
+              continue;
+        }
+      }
+      return retval.toString();
+   }
+
+}
+/* JavaCC - OriginalChecksum=1ccce09e6dc04d17e33b6d15b9c1f0c3 (do not edit this line) */

==================================================
TokenMgrError.java
new file mode 100644
index 0000000000..7c2c92e2d6
--- /dev/null
+++ b/java/org/apache/tomcat/util/json/Token.java
@@ -0,0 +1,148 @@
+/* Generated By:JavaCC: Do not edit this line. Token.java Version 7.0 */
+/* JavaCCOptions:TOKEN_EXTENDS=,KEEP_LINE_COLUMN=true,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.util.json;
+
+/**
+ * Describes the input token stream.
+ */
+
+public class Token implements java.io.Serializable {
+
+  /**
+   * The version identifier for this Serializable class.
+   * Increment only if the <i>serialized</i> form of the
+   * class changes.
+   */
+  private static final long serialVersionUID = 1L;
+
+  /**
+   * An integer that describes the kind of this token.  This numbering
+   * system is determined by JavaCCParser, and a table of these numbers is
+   * stored in the file ...Constants.java.
+   */
+  public int kind;
+
+  /** The line number of the first character of this Token. */
+  public int beginLine;
+  /** The column number of the first character of this Token. */
+  public int beginColumn;
+  /** The line number of the last character of this Token. */
+  public int endLine;
+  /** The column number of the last character of this Token. */
+  public int endColumn;
+
+  /**
+   * The string image of the token.
+   */
+  public String image;
+
+  /**
+   * A reference to the next regular (non-special) token from the input
+   * stream.  If this is the last token from the input stream, or if the
+   * token manager has not read tokens beyond this one, this field is
+   * set to null.  This is true only if this token is also a regular
+   * token.  Otherwise, see below for a description of the contents of
+   * this field.
+   */
+  public Token next;
+
+  /**
+   * This field is used to access special tokens that occur prior to this
+   * token, but after the immediately preceding regular (non-special) token.
+   * If there are no such special tokens, this field is set to null.
+   * When there are more than one such special token, this field refers
+   * to the last of these special tokens, which in turn refers to the next
+   * previous special token through its specialToken field, and so on
+   * until the first special token (whose specialToken field is null).
+   * The next fields of special tokens refer to other special tokens that
+   * immediately follow it (without an intervening regular token).  If there
+   * is no such token, this field is null.
+   */
+  public Token specialToken;
+
+  /**
+   * An optional attribute value of the Token.
+   * Tokens which are not used as syntactic sugar will often contain
+   * meaningful values that will be used later on by the compiler or
+   * interpreter. This attribute value is often different from the image.
+   * Any subclass of Token that actually wants to return a non-null value can
+   * override this method as appropriate.
+   */
+  public Object getValue() {
+    return null;
+  }
+
+  /**
+   * No-argument constructor
+   */
+  public Token() {}
+
+  /**
+   * Constructs a new token for the specified Image.
+   */
+  public Token(int kind)
+  {
+    this(kind, null);
+  }
+
+  /**
+   * Constructs a new token for the specified Image and Kind.
+   */
+  public Token(int kind, String image)
+  {
+    this.kind = kind;
+    this.image = image;
+  }
+
+  /**
+   * Returns the image.
+   */
+  public String toString()
+  {
+    return image;
+  }
+
+  /**
+   * Returns a new Token object, by default. However, if you want, you
+   * can create and return subclass objects based on the value of ofKind.
+   * Simply add the cases to the switch for all those special cases.
+   * For example, if you have a subclass of Token called IDToken that
+   * you want to create if ofKind is ID, simply add something like :
+   *
+   *    case MyParserConstants.ID : return new IDToken(ofKind, image);
+   *
+   * to the following switch statement. Then you can cast matchedToken
+   * variable to the appropriate type and use sit in your lexical actions.
+   */
+  public static Token newToken(int ofKind, String image)
+  {
+    switch(ofKind)
+    {
+      default : return new Token(ofKind, image);
+    }
+  }
+
+  public static Token newToken(int ofKind)
+  {
+    return newToken(ofKind, null);
+  }
+
+}
+/* JavaCC - OriginalChecksum=3fa555852689f4df3b05452671ed7031 (do not edit this line) */

==================================================
