0f687bd4ae06f17a3547a4e3ebfc2a73822d2b1c
==================================================
Refactoring.
==================================================
Mark Thomas
==================================================
Tue Jan 5 23:44:37 2016 +0000
==================================================
OpenSSLEngine.java
Refactoring.
Remove the CipherSuiteConverter as it duplicates a lot of info already in Cipher and OpenSSLCipherConfigurationParser.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1723199 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Cipher.java
index 1e8ed24b0f..5f3edadd89 100644
--- a/java/org/apache/tomcat/util/net/openssl/OpenSSLEngine.java
+++ b/java/org/apache/tomcat/util/net/openssl/OpenSSLEngine.java
@@ -51,7 +51,7 @@ import org.apache.tomcat.jni.SSLContext;
 import org.apache.tomcat.util.buf.ByteBufferUtils;
 import org.apache.tomcat.util.net.Constants;
 import org.apache.tomcat.util.net.SSLUtil;
-import org.apache.tomcat.util.net.openssl.ciphers.CipherSuiteConverter;
+import org.apache.tomcat.util.net.openssl.ciphers.OpenSSLCipherConfigurationParser;
 import org.apache.tomcat.util.res.StringManager;
 
 /**
@@ -85,7 +85,7 @@ public final class OpenSSLEngine extends SSLEngine implements SSLUtil.ProtocolIn
                         if (c == null || c.length() == 0 || availableCipherSuites.contains(c)) {
                             continue;
                         }
-                        availableCipherSuites.add(CipherSuiteConverter.toJava(c, "ALL"));
+                        availableCipherSuites.add(OpenSSLCipherConfigurationParser.openSSLToJsse(c));
                     }
                 } finally {
                     SSL.freeSSL(ssl);
@@ -700,7 +700,7 @@ public final class OpenSSLEngine extends SSLEngine implements SSLUtil.ProtocolIn
             return new String[0];
         } else {
             for (int i = 0; i < enabled.length; i++) {
-                String mapped = toJavaCipherSuite(enabled[i]);
+                String mapped = OpenSSLCipherConfigurationParser.openSSLToJsse(enabled[i]);
                 if (mapped != null) {
                     enabled[i] = mapped;
                 }
@@ -719,7 +719,7 @@ public final class OpenSSLEngine extends SSLEngine implements SSLUtil.ProtocolIn
             if (cipherSuite == null) {
                 break;
             }
-            String converted = CipherSuiteConverter.toOpenSsl(cipherSuite);
+            String converted = OpenSSLCipherConfigurationParser.jsseToOpenSSL(cipherSuite);
             if (converted != null) {
                 cipherSuite = converted;
             }
@@ -979,40 +979,6 @@ public final class OpenSSLEngine extends SSLEngine implements SSLUtil.ProtocolIn
         return SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING;
     }
 
-    /**
-     * Converts the specified OpenSSL cipher suite to the Java cipher suite.
-     */
-    private String toJavaCipherSuite(String openSslCipherSuite) {
-        if (openSslCipherSuite == null) {
-            return null;
-        }
-
-        String prefix = toJavaCipherSuitePrefix(SSL.getVersion(ssl));
-        return CipherSuiteConverter.toJava(openSslCipherSuite, prefix);
-    }
-
-    /**
-     * Converts the protocol version string returned by
-     * {@link SSL#getVersion(long)} to protocol family string.
-     */
-    private static String toJavaCipherSuitePrefix(String protocolVersion) {
-        final char c;
-        if (protocolVersion == null || protocolVersion.length() == 0) {
-            c = 0;
-        } else {
-            c = protocolVersion.charAt(0);
-        }
-
-        switch (c) {
-            case 'T':
-                return "TLS";
-            case 'S':
-                return "SSL";
-            default:
-                return "UNKNOWN";
-        }
-    }
-
     @Override
     public void setUseClientMode(boolean clientMode) {
         if (clientMode != this.clientMode) {
@@ -1298,7 +1264,7 @@ public final class OpenSSLEngine extends SSLEngine implements SSLUtil.ProtocolIn
                 return INVALID_CIPHER;
             }
             if (cipher == null) {
-                String c = toJavaCipherSuite(SSL.getCipherForSSL(ssl));
+                String c = OpenSSLCipherConfigurationParser.openSSLToJsse(SSL.getCipherForSSL(ssl));
                 if (c != null) {
                     cipher = c;
                 }

==================================================
CipherSuiteConverter.java
index 1a116f8aa3..614a4b1a79 100644
--- a/java/org/apache/tomcat/util/net/openssl/ciphers/Cipher.java
+++ b/java/org/apache/tomcat/util/net/openssl/ciphers/Cipher.java
@@ -21,6 +21,7 @@ import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Set;
 
@@ -4652,7 +4653,7 @@ public enum Cipher {
         } else {
             this.openSSLAltNames = Collections.emptySet();
         }
-        Set<String> jsseNames = new HashSet<>();
+        Set<String> jsseNames = new LinkedHashSet<>();
         if (jsseAltNames != null && jsseAltNames.length != 0) {
             jsseNames.addAll(Arrays.asList(jsseAltNames));
         }

==================================================
OpenSSLCipherConfigurationParser.java
deleted file mode 100644
index 43e0f5ea0a..0000000000
--- a/java/org/apache/tomcat/util/net/openssl/ciphers/CipherSuiteConverter.java
+++ /dev/null
@@ -1,497 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.tomcat.util.net.openssl.ciphers;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-import org.apache.tomcat.util.res.StringManager;
-
-/**
- * Converts a Java cipher suite string to an OpenSSL cipher suite string and vice versa.
- *
- * @see <a href="http://en.wikipedia.org/wiki/Cipher_suite">Wikipedia page about cipher suite</a>
- */
-public final class CipherSuiteConverter {
-
-    private static final Log logger = LogFactory.getLog(CipherSuiteConverter.class);
-    private static final StringManager sm = StringManager.getManager(CipherSuiteConverter.class);
-
-    /**
-     * A_B_WITH_C_D, where:
-     *
-     * A - TLS or SSL (protocol)
-     * B - handshake algorithm (key exchange and authentication algorithms to be precise)
-     * C - bulk cipher
-     * D - HMAC algorithm
-     *
-     * This regular expression assumes that:
-     *
-     * 1) A is always TLS or SSL, and
-     * 2) D is always a single word.
-     */
-    private static final Pattern JAVA_CIPHERSUITE_PATTERN =
-            Pattern.compile("^(?:TLS|SSL)_((?:(?!_WITH_).)+)_WITH_(.*)_(.*)$");
-
-    /**
-     * A-B-C, where:
-     *
-     * A - handshake algorithm (key exchange and authentication algorithms to be precise)
-     * B - bulk cipher
-     * C - HMAC algorithm
-     *
-     * This regular expression assumes that:
-     *
-     * 1) A has some deterministic pattern as shown below, and
-     * 2) C is always a single word
-     */
-    private static final Pattern OPENSSL_CIPHERSUITE_PATTERN =
-            // Be very careful not to break the indentation while editing.
-            Pattern.compile(
-                    "^(?:(" + // BEGIN handshake algorithm
-                        "(?:(?:EXP-|EXP1024-)?" +
-                            "(?:" +
-                                "(?:DH|DHE|EDH|ECDH|ECDHE|RSA|SRP)-(?:DSS|RSA|ECDSA|PSK)|" +
-                                "(?:ADH|AECDH|KRB5|PSK|SRP)" +
-                            ')' +
-                        ")|" +
-                        "EXP|EXP1024" +
-                    ")-)?" +  // END handshake algorithm
-                    "(.*)-(.*)$");
-
-    private static final Pattern JAVA_AES_CBC_PATTERN = Pattern.compile("^(AES)_([0-9]+)_CBC$");
-    private static final Pattern JAVA_AES_PATTERN = Pattern.compile("^(AES)_([0-9]+)_(.*)$");
-    private static final Pattern OPENSSL_AES_CBC_PATTERN = Pattern.compile("^(AES)([0-9]+)$");
-    private static final Pattern OPENSSL_AES_PATTERN = Pattern.compile("^(AES)([0-9]+)-(.*)$");
-
-    /**
-     * Java-to-OpenSSL cipher suite conversion map
-     * Note that the Java cipher suite has the protocol prefix (TLS_, SSL_)
-     */
-    private static final ConcurrentMap<String, String> j2o = new ConcurrentHashMap<>();
-
-    /**
-     * OpenSSL-to-Java cipher suite conversion map.
-     * Note that one OpenSSL cipher suite can be converted to more than one Java cipher suites because
-     * a Java cipher suite has the protocol name prefix (TLS_, SSL_)
-     */
-    private static final ConcurrentMap<String, Map<String, String>> o2j = new ConcurrentHashMap<>();
-
-    /**
-     * Clears the cache for testing purpose.
-     */
-    static void clearCache() {
-        j2o.clear();
-        o2j.clear();
-    }
-
-    /**
-     * Tests if the specified key-value pair has been cached in Java-to-OpenSSL cache.
-     */
-    static boolean isJ2OCached(String key, String value) {
-        return value.equals(j2o.get(key));
-    }
-
-    /**
-     * Tests if the specified key-value pair has been cached in OpenSSL-to-Java cache.
-     */
-    static boolean isO2JCached(String key, String protocol, String value) {
-        Map<String, String> p2j = o2j.get(key);
-        if (p2j == null) {
-            return false;
-        } else {
-            return value.equals(p2j.get(protocol));
-        }
-    }
-
-    /**
-     * Converts the specified Java cipher suites to the OpenSSL specification.
-     *
-     * @param javaCipherSuites The JSSE cipher suite names to convert
-     *
-     * @return A list of colon-separated OpenSSL cipher suite names
-     */
-    public static String toOpenSsl(Iterable<String> javaCipherSuites) {
-        final StringBuilder buf = new StringBuilder();
-        for (String c: javaCipherSuites) {
-            if (c == null) {
-                break;
-            }
-
-            String converted = toOpenSsl(c);
-            if (converted != null) {
-                c = converted;
-            }
-
-            buf.append(c);
-            buf.append(':');
-        }
-
-        if (buf.length() > 0) {
-            buf.setLength(buf.length() - 1);
-            return buf.toString();
-        } else {
-            return "";
-        }
-    }
-
-    /**
-     * Converts the specified Java cipher suite to its corresponding OpenSSL cipher suite name.
-     *
-     * @param javaCipherSuite The JSSE cipher suite name to convert
-     *
-     * @return {@code null} if the conversion has failed
-     */
-    public static String toOpenSsl(String javaCipherSuite) {
-        String converted = j2o.get(javaCipherSuite);
-        if (converted != null) {
-            return converted;
-        } else {
-            return cacheFromJava(javaCipherSuite);
-        }
-    }
-
-    private static String cacheFromJava(String javaCipherSuite) {
-        String openSslCipherSuite = toOpenSslUncached(javaCipherSuite);
-        if (openSslCipherSuite == null) {
-            return null;
-        }
-
-        // Cache the mapping.
-        j2o.putIfAbsent(javaCipherSuite, openSslCipherSuite);
-
-        // Cache the reverse mapping after stripping the protocol prefix (TLS_ or SSL_)
-        final String javaCipherSuiteSuffix = javaCipherSuite.substring(4);
-        Map<String, String> p2j = new HashMap<>(4);
-        p2j.put("", javaCipherSuiteSuffix);
-        p2j.put("SSL", "SSL_" + javaCipherSuiteSuffix);
-        p2j.put("TLS", "TLS_" + javaCipherSuiteSuffix);
-        o2j.put(openSslCipherSuite, p2j);
-
-        if (logger.isDebugEnabled()) {
-            logger.debug(sm.getString("converter.mapping", javaCipherSuite, openSslCipherSuite));
-        }
-
-        return openSslCipherSuite;
-    }
-
-    static String toOpenSslUncached(String javaCipherSuite) {
-        Matcher m = JAVA_CIPHERSUITE_PATTERN.matcher(javaCipherSuite);
-        if (!m.matches()) {
-            return null;
-        }
-
-        String handshakeAlgo = toOpenSslHandshakeAlgo(m.group(1));
-        String bulkCipher = toOpenSslBulkCipher(m.group(2));
-        String hmacAlgo = toOpenSslHmacAlgo(m.group(3));
-        if (handshakeAlgo.length() == 0) {
-            return bulkCipher + '-' + hmacAlgo;
-        } else {
-            return handshakeAlgo + '-' + bulkCipher + '-' + hmacAlgo;
-        }
-    }
-
-    private static String toOpenSslHandshakeAlgo(String handshakeAlgo) {
-        final EncryptionLevel export;
-        if (handshakeAlgo.endsWith("_EXPORT")) {
-            export = EncryptionLevel.EXP40;
-            handshakeAlgo = handshakeAlgo.substring(0, handshakeAlgo.length() - 7);
-        } else if (handshakeAlgo.endsWith("_EXPORT1024")) {
-            export = EncryptionLevel.EXP56;
-            handshakeAlgo = handshakeAlgo.substring(0, handshakeAlgo.length() - 11);
-        } else {
-            export = null;
-        }
-
-        if ("RSA".equals(handshakeAlgo)) {
-            handshakeAlgo = "";
-        } else if (handshakeAlgo.endsWith("_anon")) {
-            handshakeAlgo = 'A' + handshakeAlgo.substring(0, handshakeAlgo.length() - 5);
-        }
-
-        if (export != null) {
-            if (handshakeAlgo.length() == 0) {
-                if (export == EncryptionLevel.EXP40) {
-                    handshakeAlgo = "EXP";
-                } else {
-                    handshakeAlgo = "EXP1024";
-                }
-            } else {
-                if (export == EncryptionLevel.EXP40) {
-                    handshakeAlgo = "EXP-" + handshakeAlgo;
-                } else {
-                    handshakeAlgo = "EXP1024-" + handshakeAlgo;
-                }
-            }
-        }
-
-        return handshakeAlgo.replace('_', '-');
-    }
-
-    private static String toOpenSslBulkCipher(String bulkCipher) {
-        if (bulkCipher.startsWith("AES_")) {
-            Matcher m = JAVA_AES_CBC_PATTERN.matcher(bulkCipher);
-            if (m.matches()) {
-                return m.replaceFirst("$1$2");
-            }
-
-            m = JAVA_AES_PATTERN.matcher(bulkCipher);
-            if (m.matches()) {
-                return m.replaceFirst("$1$2-$3");
-            }
-        }
-
-        if ("3DES_EDE_CBC".equals(bulkCipher)) {
-            return "DES-CBC3";
-        }
-
-        if ("RC4_128".equals(bulkCipher) || "RC4_40".equals(bulkCipher)) {
-            return "RC4";
-        }
-
-        if ("DES40_CBC".equals(bulkCipher) || "DES_CBC_40".equals(bulkCipher)) {
-            return "DES-CBC";
-        }
-
-        if ("RC2_CBC_40".equals(bulkCipher) || "RC2_CBC_56".equals(bulkCipher)) {
-            return "RC2-CBC";
-        }
-
-        if ("AES_128".equals(bulkCipher)) {
-            return "AES128";
-        }
-
-        if ("AES_256".equals(bulkCipher)) {
-            return "AES256";
-        }
-
-        if ("RSA_EXPORT1024".equals(bulkCipher)) {
-            return "EXP1024";
-        }
-
-        return bulkCipher.replace('_', '-');
-    }
-
-    private static String toOpenSslHmacAlgo(String hmacAlgo) {
-        // Java and OpenSSL use the same algorithm names for:
-        //
-        //   * SHA
-        //   * SHA256
-        //   * MD5
-        //
-        return hmacAlgo;
-    }
-
-    /**
-     * Convert from OpenSSL cipher suite name convention to java cipher suite name convention.
-     * @param openSslCipherSuite An OpenSSL cipher suite name.
-     * @param protocol The cryptographic protocol (i.e. SSL, TLS, ...).
-     * @return The translated cipher suite name according to java conventions. This will not be {@code null}.
-     */
-    public static String toJava(String openSslCipherSuite, String protocol) {
-        Map<String, String> p2j = o2j.get(openSslCipherSuite);
-        if (p2j == null) {
-            p2j = cacheFromOpenSsl(openSslCipherSuite);
-        }
-
-        String javaCipherSuite = p2j.get(protocol);
-        if (javaCipherSuite == null) {
-            javaCipherSuite = protocol + '_' + p2j.get("");
-        }
-
-        return javaCipherSuite;
-    }
-
-    private static Map<String, String> cacheFromOpenSsl(String openSslCipherSuite) {
-        String javaCipherSuiteSuffix = toJavaUncached(openSslCipherSuite);
-        if (javaCipherSuiteSuffix == null) {
-            return null;
-        }
-
-        final String javaCipherSuiteSsl = "SSL_" + javaCipherSuiteSuffix;
-        final String javaCipherSuiteTls = "TLS_" + javaCipherSuiteSuffix;
-
-        // Cache the mapping.
-        Map<String, String> p2j = new HashMap<>(4);
-        p2j.put("", javaCipherSuiteSuffix);
-        p2j.put("SSL", javaCipherSuiteSsl);
-        p2j.put("TLS", javaCipherSuiteTls);
-        Map<String, String> p2jCurrent = o2j.putIfAbsent(openSslCipherSuite, p2j);
-        if (p2jCurrent != null) {
-            p2j = p2jCurrent;
-        }
-
-        // Cache the reverse mapping after adding the protocol prefix (TLS_ or SSL_)
-        j2o.putIfAbsent(javaCipherSuiteTls, openSslCipherSuite);
-        j2o.putIfAbsent(javaCipherSuiteSsl, openSslCipherSuite);
-
-        if (logger.isDebugEnabled()) {
-            logger.debug(sm.getString("converter.mapping", openSslCipherSuite, javaCipherSuiteTls));
-            logger.debug(sm.getString("converter.mapping", openSslCipherSuite, javaCipherSuiteSsl));
-        }
-
-        return p2j;
-    }
-
-    static String toJavaUncached(String openSslCipherSuite) {
-        Matcher m = OPENSSL_CIPHERSUITE_PATTERN.matcher(openSslCipherSuite);
-        if (!m.matches()) {
-            return null;
-        }
-
-        String handshakeAlgo = m.group(1);
-        final EncryptionLevel export;
-        if (handshakeAlgo == null) {
-            handshakeAlgo = "";
-            export = null;
-        } else if (handshakeAlgo.startsWith("EXP-")) {
-            handshakeAlgo = handshakeAlgo.substring(4);
-            export = EncryptionLevel.EXP40;
-        } else if (handshakeAlgo.startsWith("EXP1024-")) {
-            handshakeAlgo = handshakeAlgo.substring(8);
-            export = EncryptionLevel.EXP56;
-        } else if ("EXP".equals(handshakeAlgo)) {
-            handshakeAlgo = "";
-            export = EncryptionLevel.EXP40;
-        } else if ("EXP1024".equals(handshakeAlgo)) {
-            handshakeAlgo = "";
-            export = EncryptionLevel.EXP56;
-        } else {
-            export = null;
-        }
-
-        String bulkCipher = m.group(2);
-        String hmacAlgo = m.group(3);
-
-        // CCM is a special case
-        if ("CCM".equals(hmacAlgo)) {
-            bulkCipher += "-CCM";
-            hmacAlgo = "";
-        } else if ("CCM8".equals(hmacAlgo)) {
-            bulkCipher += "-CCM_8";
-            hmacAlgo = "";
-        }
-
-        handshakeAlgo = toJavaHandshakeAlgo(handshakeAlgo, export);
-        bulkCipher = toJavaBulkCipher(bulkCipher, export);
-        hmacAlgo = toJavaHmacAlgo(hmacAlgo);
-
-        if (hmacAlgo.length() == 0) {
-            return handshakeAlgo + "_WITH_" + bulkCipher;
-        }
-
-        return handshakeAlgo + "_WITH_" + bulkCipher + '_' + hmacAlgo;
-    }
-
-    private static String toJavaHandshakeAlgo(String handshakeAlgo, EncryptionLevel export) {
-        if (handshakeAlgo.length() == 0) {
-            handshakeAlgo = "RSA";
-        } else if ("ADH".equals(handshakeAlgo)) {
-            handshakeAlgo = "DH_anon";
-        } else if ("AECDH".equals(handshakeAlgo)) {
-            handshakeAlgo = "ECDH_anon";
-        }
-
-        handshakeAlgo = handshakeAlgo.replace("EDH", "DHE");
-        handshakeAlgo = handshakeAlgo.replace('-', '_');
-        if (EncryptionLevel.EXP56 == export) {
-            return handshakeAlgo + "_EXPORT1024";
-        } else if (EncryptionLevel.EXP40 == export) {
-            return handshakeAlgo + "_EXPORT";
-        } else {
-            return handshakeAlgo;
-        }
-    }
-
-    private static String toJavaBulkCipher(String bulkCipher, EncryptionLevel export) {
-        if (bulkCipher.startsWith("AES")) {
-            Matcher m = OPENSSL_AES_CBC_PATTERN.matcher(bulkCipher);
-            if (m.matches()) {
-                return m.replaceFirst("$1_$2_CBC");
-            }
-
-            m = OPENSSL_AES_PATTERN.matcher(bulkCipher);
-            if (m.matches()) {
-                return m.replaceFirst("$1_$2_$3");
-            }
-        }
-
-        if ("DES-CBC3".equals(bulkCipher)) {
-            return "3DES_EDE_CBC";
-        }
-
-        if ("RC4".equals(bulkCipher)) {
-            if (EncryptionLevel.EXP56 == export) {
-                return "RC4_56";
-            } else  if (EncryptionLevel.EXP40 == export) {
-                return "RC4_40";
-            } else {
-                return "RC4_128";
-            }
-        }
-
-        if ("DES-CBC".equals(bulkCipher)) {
-            if (EncryptionLevel.EXP40 == export) {
-                return "DES40_CBC";
-            } else {
-                return "DES_CBC";
-            }
-        }
-
-        if ("RC2-CBC".equals(bulkCipher)) {
-            if (EncryptionLevel.EXP56 == export) {
-                return "RC2_CBC_56";
-            } else  if (EncryptionLevel.EXP40 == export) {
-                return "RC2_CBC_40";
-            } else {
-                return "RC2_CBC";
-            }
-        }
-
-        if ("CAMELLIA128".equals(bulkCipher)) {
-            return "CAMELLIA_128_CBC";
-        }
-
-        if ("CAMELLIA256".equals(bulkCipher)) {
-            return "CAMELLIA_256_CBC";
-        }
-
-        if ("SEED".equals(bulkCipher)) {
-            return "SEED_CBC";
-        }
-
-        return bulkCipher.replace('-', '_');
-    }
-
-    private static String toJavaHmacAlgo(String hmacAlgo) {
-        // Java and OpenSSL use the same algorithm names for:
-        //
-        //   * SHA
-        //   * SHA256
-        //   * MD5
-        //
-        return hmacAlgo;
-    }
-
-    private CipherSuiteConverter() { }
-}

==================================================
TestCipherSuiteConverter.java
index 487a8d58b2..f843e90a19 100644
--- a/java/org/apache/tomcat/util/net/openssl/ciphers/OpenSSLCipherConfigurationParser.java
+++ b/java/org/apache/tomcat/util/net/openssl/ciphers/OpenSSLCipherConfigurationParser.java
@@ -714,13 +714,45 @@ public class OpenSSLCipherConfigurationParser {
         return convertForJSSE(parse(expression));
     }
 
-    public static String jsseToOpenSSL(String cipher) {
+
+    /**
+     * Converts a JSSE cipher name to an OpenSSL cipher name.
+     *
+     * @param jsseCipherName The JSSE name for a cipher
+     *
+     * @return The OpenSSL name for the specified JSSE cipher
+     */
+    public static String jsseToOpenSSL(String jsseCipherName) {
         if (!initialized) {
             init();
         }
-        return jsseToOpenSSL.get(cipher);
+        return jsseToOpenSSL.get(jsseCipherName);
     }
 
+
+    /**
+     * Converts an OpenSSL cipher name to a JSSE cipher name.
+     *
+     * @param opensslCipherName The OpenSSL name for a cipher
+     *
+     * @return The JSSE name for the specified OpenSSL cipher. If none is known,
+     *         the IANA standard name will be returned instead
+     */
+    public static String openSSLToJsse(String opensslCipherName) {
+        if (!initialized) {
+            init();
+        }
+        List<Cipher> ciphers = aliases.get(opensslCipherName);
+        if (ciphers == null || ciphers.size() != 1) {
+            // Not an OpenSSL cipher name
+            return null;
+        }
+        Cipher cipher = ciphers.get(0);
+        // Each Cipher always has at least one JSSE name
+        return cipher.getJsseNames().iterator().next();
+    }
+
+
     static String displayResult(Collection<Cipher> ciphers, boolean useJSSEFormat, String separator) {
         if (ciphers.isEmpty()) {
             return "";

==================================================
