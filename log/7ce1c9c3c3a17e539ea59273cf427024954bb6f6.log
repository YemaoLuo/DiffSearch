7ce1c9c3c3a17e539ea59273cf427024954bb6f6
==================================================
- Add the new packetSize attribute.
==================================================
Remy Maucherat
==================================================
Thu Sep 28 22:29:40 2006 +0000
==================================================
AjpAprProcessor.java
- Add the new packetSize attribute.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/tc6.0.x/trunk@451049 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AjpAprProtocol.java
index 2a978d64d2..04d4bc8a8a 100644
--- a/java/org/apache/coyote/ajp/AjpAprProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpAprProcessor.java
@@ -73,7 +73,7 @@ public class AjpAprProcessor implements ActionHook {
     // ----------------------------------------------------------- Constructors
 
 
-    public AjpAprProcessor(AprEndpoint endpoint) {
+    public AjpAprProcessor(int packetSize, AprEndpoint endpoint) {
 
         this.endpoint = endpoint;
 
@@ -85,6 +85,10 @@ public class AjpAprProcessor implements ActionHook {
         response.setOutputBuffer(new SocketOutputBuffer());
         request.setResponse(response);
 
+        requestHeaderMessage = new AjpMessage(packetSize);
+        responseHeaderMessage = new AjpMessage(packetSize);
+        bodyMessage = new AjpMessage(packetSize);
+        
         if (endpoint.getFirstReadTimeout() > 0) {
             readTimeout = endpoint.getFirstReadTimeout() * 1000;
         } else {
@@ -92,9 +96,9 @@ public class AjpAprProcessor implements ActionHook {
         }
 
         // Allocate input and output buffers
-        inputBuffer = ByteBuffer.allocateDirect(Constants.MAX_PACKET_SIZE * 2);
+        inputBuffer = ByteBuffer.allocateDirect(packetSize * 2);
         inputBuffer.limit(0);
-        outputBuffer = ByteBuffer.allocateDirect(Constants.MAX_PACKET_SIZE * 2);
+        outputBuffer = ByteBuffer.allocateDirect(packetSize * 2);
 
         // Cause loading of HexUtils
         int foo = HexUtils.DEC[0];
@@ -131,19 +135,19 @@ public class AjpAprProcessor implements ActionHook {
      * processing of the first message of a "request", so it might not be a request
      * header. It will stay unchanged during the processing of the whole request.
      */
-    protected AjpMessage requestHeaderMessage = new AjpMessage();
+    protected AjpMessage requestHeaderMessage = null;
 
 
     /**
      * Message used for response header composition.
      */
-    protected AjpMessage responseHeaderMessage = new AjpMessage();
+    protected AjpMessage responseHeaderMessage = null;
 
 
     /**
      * Body message.
      */
-    protected AjpMessage bodyMessage = new AjpMessage();
+    protected AjpMessage bodyMessage = null;
 
 
     /**
@@ -267,7 +271,7 @@ public class AjpAprProcessor implements ActionHook {
     static {
 
         // Set the get body message buffer
-        AjpMessage getBodyMessage = new AjpMessage();
+        AjpMessage getBodyMessage = new AjpMessage(128);
         getBodyMessage.reset();
         getBodyMessage.appendByte(Constants.JK_AJP13_GET_BODY_CHUNK);
         getBodyMessage.appendInt(Constants.MAX_READ_SIZE);
@@ -278,7 +282,7 @@ public class AjpAprProcessor implements ActionHook {
                 getBodyMessage.getLen());
 
         // Set the read body message buffer
-        AjpMessage pongMessage = new AjpMessage();
+        AjpMessage pongMessage = new AjpMessage(128);
         pongMessage.reset();
         pongMessage.appendByte(Constants.JK_AJP13_CPONG_REPLY);
         pongMessage.end();
@@ -287,7 +291,7 @@ public class AjpAprProcessor implements ActionHook {
                 pongMessage.getLen());
 
         // Allocate the end message array
-        AjpMessage endMessage = new AjpMessage();
+        AjpMessage endMessage = new AjpMessage(128);
         endMessage.reset();
         endMessage.appendByte(Constants.JK_AJP13_END_RESPONSE);
         endMessage.appendByte(1);
@@ -348,8 +352,6 @@ public class AjpAprProcessor implements ActionHook {
         // Error flag
         error = false;
 
-        long soTimeout = endpoint.getSoTimeout();
-
         int limit = 0;
         if (endpoint.getFirstReadTimeout() > 0) {
             limit = endpoint.getMaxThreads() / 2;

==================================================
AjpMessage.java
index 5fabfdc304..9a3f0387ed 100644
--- a/java/org/apache/coyote/ajp/AjpAprProtocol.java
+++ b/java/org/apache/coyote/ajp/AjpAprProtocol.java
@@ -107,6 +107,12 @@ public class AjpAprProtocol
     protected String requiredSecret = null;
 
 
+    /**
+     * AJP packet size.
+     */
+    protected int packetSize = Constants.MAX_PACKET_SIZE;
+
+    
     /**
      * Adapter which will process the requests recieved by this endpoint.
      */
@@ -417,6 +423,16 @@ public class AjpAprProtocol
     }
     
     
+    public int getPacketSize() {
+        return packetSize;
+    }
+
+
+    public void setPacketSize(int i) {
+        packetSize = i;
+    }
+
+    
     // --------------------------------------  AjpConnectionHandler Inner Class
 
 
@@ -424,7 +440,7 @@ public class AjpAprProtocol
         protected AjpAprProtocol proto;
         protected static int count = 0;
         protected RequestGroupInfo global=new RequestGroupInfo();
-        protected ThreadLocal localProcessor = new ThreadLocal();
+        protected ThreadLocal<AjpAprProcessor> localProcessor = new ThreadLocal<AjpAprProcessor>();
 
         public AjpConnectionHandler(AjpAprProtocol proto) {
             this.proto = proto;
@@ -438,9 +454,9 @@ public class AjpAprProtocol
         public SocketState process(long socket) {
             AjpAprProcessor processor = null;
             try {
-                processor = (AjpAprProcessor) localProcessor.get();
+                processor = localProcessor.get();
                 if (processor == null) {
-                    processor = new AjpAprProcessor(proto.ep);
+                    processor = new AjpAprProcessor(proto.packetSize, proto.ep);
                     processor.setAdapter(proto.adapter);
                     processor.setTomcatAuthentication(proto.tomcatAuthentication);
                     processor.setRequiredSecret(proto.requiredSecret);

==================================================
AjpProcessor.java
index 71dbb3fd22..e0283182dd 100644
--- a/java/org/apache/coyote/ajp/AjpMessage.java
+++ b/java/org/apache/coyote/ajp/AjpMessage.java
@@ -47,13 +47,21 @@ public class AjpMessage {
         StringManager.getManager(Constants.Package);
 
 
+    // ------------------------------------------------------------ Constructor
+
+    
+    public AjpMessage(int packetSize) {
+        buf = new byte[packetSize];
+    }
+    
+
     // ----------------------------------------------------- Instance Variables
 
 
     /**
      * Fixed size buffer.
      */
-    protected byte buf[] = new byte[8 * 1024];
+    protected byte buf[] = null;
 
 
     /**

==================================================
AjpProtocol.java
index 6e09d0fd11..10dcf036ef 100644
--- a/java/org/apache/coyote/ajp/AjpProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpProcessor.java
@@ -73,7 +73,7 @@ public class AjpProcessor implements ActionHook {
     // ----------------------------------------------------------- Constructors
 
 
-    public AjpProcessor(JIoEndpoint endpoint) {
+    public AjpProcessor(int packetSize, JIoEndpoint endpoint) {
 
         this.endpoint = endpoint;
 
@@ -85,6 +85,10 @@ public class AjpProcessor implements ActionHook {
         response.setOutputBuffer(new SocketOutputBuffer());
         request.setResponse(response);
 
+        requestHeaderMessage = new AjpMessage(packetSize);
+        responseHeaderMessage = new AjpMessage(packetSize);
+        bodyMessage = new AjpMessage(packetSize);
+        
         // Cause loading of HexUtils
         int foo = HexUtils.DEC[0];
 
@@ -120,19 +124,19 @@ public class AjpProcessor implements ActionHook {
      * processing of the first message of a "request", so it might not be a request
      * header. It will stay unchanged during the processing of the whole request.
      */
-    protected AjpMessage requestHeaderMessage = new AjpMessage();
+    protected AjpMessage requestHeaderMessage = null;
 
 
     /**
      * Message used for response header composition.
      */
-    protected AjpMessage responseHeaderMessage = new AjpMessage();
+    protected AjpMessage responseHeaderMessage = null;
 
 
     /**
      * Body message.
      */
-    protected AjpMessage bodyMessage = new AjpMessage();
+    protected AjpMessage bodyMessage = null;
 
 
     /**
@@ -256,7 +260,7 @@ public class AjpProcessor implements ActionHook {
     static {
 
         // Set the get body message buffer
-        AjpMessage getBodyMessage = new AjpMessage();
+        AjpMessage getBodyMessage = new AjpMessage(128);
         getBodyMessage.reset();
         getBodyMessage.appendByte(Constants.JK_AJP13_GET_BODY_CHUNK);
         getBodyMessage.appendInt(Constants.MAX_READ_SIZE);
@@ -266,7 +270,7 @@ public class AjpProcessor implements ActionHook {
                 0, getBodyMessage.getLen());
 
         // Set the read body message buffer
-        AjpMessage pongMessage = new AjpMessage();
+        AjpMessage pongMessage = new AjpMessage(128);
         pongMessage.reset();
         pongMessage.appendByte(Constants.JK_AJP13_CPONG_REPLY);
         pongMessage.end();
@@ -275,7 +279,7 @@ public class AjpProcessor implements ActionHook {
                 0, pongMessage.getLen());
 
         // Allocate the end message array
-        AjpMessage endMessage = new AjpMessage();
+        AjpMessage endMessage = new AjpMessage(128);
         endMessage.reset();
         endMessage.appendByte(Constants.JK_AJP13_END_RESPONSE);
         endMessage.appendByte(1);
@@ -336,8 +340,6 @@ public class AjpProcessor implements ActionHook {
         // Error flag
         error = false;
 
-        long soTimeout = endpoint.getSoTimeout();
-
         while (started && !error) {
 
             // Parsing the request header

==================================================
