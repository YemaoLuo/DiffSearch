6a66ee8bb01a6353a1e77de8080fdde5099f457e
==================================================
Some more unused code clean-up.
==================================================
Mark Emlyn
==================================================
Tue Jun 4 12:48:18 2013 +0000
==================================================
FileCleaningTracker.java
Some more unused code clean-up.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1489419 13f79535-47bb-0310-9956-ffa450edef68



==================================================
FileDeleteStrategy.java
deleted file mode 100644
index a1545bfd2b..0000000000
--- a/java/org/apache/tomcat/util/http/fileupload/FileCleaningTracker.java
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.tomcat.util.http.fileupload;
-
-import java.io.File;
-import java.lang.ref.PhantomReference;
-import java.lang.ref.ReferenceQueue;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.List;
-
-/**
- * Keeps track of files awaiting deletion, and deletes them when an associated
- * marker object is reclaimed by the garbage collector.
- * <p>
- * This utility creates a background thread to handle file deletion.
- * Each file to be deleted is registered with a handler object.
- * When the handler object is garbage collected, the file is deleted.
- * <p>
- * In an environment with multiple class loaders (a servlet container, for
- * example), you should consider stopping the background thread if it is no
- * longer needed. This is done by invoking the method
- * {@link #exitWhenFinished}, typically in
- * {@link javax.servlet.ServletContextListener#contextDestroyed} or similar.
- *
- * @version $Id$
- */
-public class FileCleaningTracker {
-    /**
-     * Queue of <code>Tracker</code> instances being watched.
-     */
-    private final ReferenceQueue<Object> q = new ReferenceQueue<>();
-    /**
-     * Collection of <code>Tracker</code> instances in existence.
-     */
-    private final Collection<Tracker> trackers = Collections.synchronizedSet(new HashSet<Tracker>()); // synchronized
-    /**
-     * Collection of File paths that failed to delete.
-     */
-    private final List<String> deleteFailures = Collections.synchronizedList(new ArrayList<String>());
-    /**
-     * Whether to terminate the thread when the tracking is complete.
-     */
-    private volatile boolean exitWhenFinished = false;
-    /**
-     * The thread that will clean up registered files.
-     */
-    private Thread reaper;
-
-    //-----------------------------------------------------------------------
-    /**
-     * Track the specified file, using the provided marker, deleting the file
-     * when the marker instance is garbage collected.
-     * The {@link FileDeleteStrategy#NORMAL normal} deletion strategy will be used.
-     *
-     * @param file  the file to be tracked, not null
-     * @param marker  the marker object used to track the file, not null
-     * @throws NullPointerException if the file is null
-     */
-    public void track(File file, Object marker) {
-        track(file, marker, (FileDeleteStrategy) null);
-    }
-
-    /**
-     * Track the specified file, using the provided marker, deleting the file
-     * when the marker instance is garbage collected.
-     * The speified deletion strategy is used.
-     *
-     * @param file  the file to be tracked, not null
-     * @param marker  the marker object used to track the file, not null
-     * @param deleteStrategy  the strategy to delete the file, null means normal
-     * @throws NullPointerException if the file is null
-     */
-    public void track(File file, Object marker, FileDeleteStrategy deleteStrategy) {
-        if (file == null) {
-            throw new NullPointerException("The file must not be null");
-        }
-        addTracker(file.getPath(), marker, deleteStrategy);
-    }
-
-    /**
-     * Adds a tracker to the list of trackers.
-     *
-     * @param path  the full path to the file to be tracked, not null
-     * @param marker  the marker object used to track the file, not null
-     * @param deleteStrategy  the strategy to delete the file, null means normal
-     */
-    private synchronized void addTracker(String path, Object marker, FileDeleteStrategy deleteStrategy) {
-        // synchronized block protects reaper
-        if (exitWhenFinished) {
-            throw new IllegalStateException("No new trackers can be added once exitWhenFinished() is called");
-        }
-        if (reaper == null) {
-            reaper = new Reaper();
-            reaper.start();
-        }
-        trackers.add(new Tracker(path, deleteStrategy, marker, q));
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * The reaper thread.
-     */
-    private final class Reaper extends Thread {
-        /** Construct a new Reaper */
-        Reaper() {
-            super("File Reaper");
-            setPriority(Thread.MAX_PRIORITY);
-            setDaemon(true);
-        }
-
-        /**
-         * Run the reaper thread that will delete files as their associated
-         * marker objects are reclaimed by the garbage collector.
-         */
-        @Override
-        public void run() {
-            // thread exits when exitWhenFinished is true and there are no more tracked objects
-            while (exitWhenFinished == false || trackers.size() > 0) {
-                try {
-                    // Wait for a tracker to remove.
-                    Tracker tracker = (Tracker) q.remove(); // cannot return null
-                    trackers.remove(tracker);
-                    if (!tracker.delete()) {
-                        deleteFailures.add(tracker.getPath());
-                    }
-                    tracker.clear();
-                } catch (InterruptedException e) {
-                    continue;
-                }
-            }
-        }
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Inner class which acts as the reference for a file pending deletion.
-     */
-    private static final class Tracker extends PhantomReference<Object> {
-
-        /**
-         * The full path to the file being tracked.
-         */
-        private final String path;
-        /**
-         * The strategy for deleting files.
-         */
-        private final FileDeleteStrategy deleteStrategy;
-
-        /**
-         * Constructs an instance of this class from the supplied parameters.
-         *
-         * @param path  the full path to the file to be tracked, not null
-         * @param deleteStrategy  the strategy to delete the file, null means normal
-         * @param marker  the marker object used to track the file, not null
-         * @param queue  the queue on to which the tracker will be pushed, not null
-         */
-        Tracker(String path, FileDeleteStrategy deleteStrategy, Object marker, ReferenceQueue<? super Object> queue) {
-            super(marker, queue);
-            this.path = path;
-            this.deleteStrategy = deleteStrategy == null ? FileDeleteStrategy.NORMAL : deleteStrategy;
-        }
-
-        /**
-         * Return the path.
-         *
-         * @return the path
-         */
-        public String getPath() {
-            return path;
-        }
-
-        /**
-         * Deletes the file associated with this tracker instance.
-         *
-         * @return {@code true} if the file was deleted successfully;
-         *         {@code false} otherwise.
-         */
-        public boolean delete() {
-            return deleteStrategy.deleteQuietly(new File(path));
-        }
-    }
-
-}

==================================================
DiskFileItem.java
deleted file mode 100644
index 3b124ece28..0000000000
--- a/java/org/apache/tomcat/util/http/fileupload/FileDeleteStrategy.java
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.tomcat.util.http.fileupload;
-
-import java.io.File;
-import java.io.IOException;
-
-/**
- * Strategy for deleting files.
- * <p>
- * There is more than one way to delete a file.
- * You may want to limit access to certain directories, to only delete
- * directories if they are empty, or maybe to force deletion.
- * <p>
- * This class captures the strategy to use and is designed for user subclassing.
- *
- * @version $Id$
- * @since 1.3
- */
-public class FileDeleteStrategy {
-
-    /**
-     * The singleton instance for normal file deletion, which does not permit
-     * the deletion of directories that are not empty.
-     */
-    public static final FileDeleteStrategy NORMAL = new FileDeleteStrategy("Normal");
-
-    /** The name of the strategy. */
-    private final String name;
-
-    //-----------------------------------------------------------------------
-    /**
-     * Restricted constructor.
-     *
-     * @param name  the name by which the strategy is known
-     */
-    protected FileDeleteStrategy(String name) {
-        this.name = name;
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Deletes the file object, which may be a file or a directory.
-     * All <code>IOException</code>s are caught and false returned instead.
-     * If the file does not exist or is null, true is returned.
-     * <p>
-     * Subclass writers should override {@link #doDelete(File)}, not this method.
-     *
-     * @param fileToDelete  the file to delete, null returns true
-     * @return true if the file was deleted, or there was no such file
-     */
-    public boolean deleteQuietly(File fileToDelete) {
-        if (fileToDelete == null || fileToDelete.exists() == false) {
-            return true;
-        }
-        try {
-            return doDelete(fileToDelete);
-        } catch (IOException ex) {
-            return false;
-        }
-    }
-
-    /**
-     * Actually deletes the file object, which may be a file or a directory.
-     * <p>
-     * This method is designed for subclasses to override.
-     * The implementation may return either false or an <code>IOException</code>
-     * when deletion fails. The {@link #deleteQuietly(File)} method will handle
-     * either response appropriately.
-     * A check has been made to ensure that the file will exist.
-     * <p>
-     * This implementation uses {@link File#delete()}.
-     *
-     * @param fileToDelete  the file to delete, exists, not null
-     * @return true if the file was deleteds
-     * @throws NullPointerException if the file is null
-     * @throws IOException if an error occurs during file deletion
-     */
-    protected boolean doDelete(File fileToDelete) throws IOException {
-        return fileToDelete.delete();
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Gets a string describing the delete strategy.
-     *
-     * @return a string describing the delete strategy
-     */
-    @Override
-    public String toString() {
-        return "FileDeleteStrategy[" + name + "]";
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Force file deletion strategy.
-     */
-    static class ForceFileDeleteStrategy extends FileDeleteStrategy {
-        /** Default Constructor */
-        ForceFileDeleteStrategy() {
-            super("Force");
-        }
-
-        /**
-         * Deletes the file object.
-         * <p>
-         * This implementation uses <code>FileUtils.forceDelete() <code>
-         * if the file exists.
-         *
-         * @param fileToDelete  the file to delete, not null
-         * @return Always returns {@code true}
-         * @throws NullPointerException if the file is null
-         * @throws IOException if an error occurs during file deletion
-         */
-        @Override
-        protected boolean doDelete(File fileToDelete) throws IOException {
-            FileUtils.forceDelete(fileToDelete);
-            return true;
-        }
-    }
-
-}

==================================================
DiskFileItemFactory.java
index d467ebe088..b4653bbd06 100644
--- a/java/org/apache/tomcat/util/http/fileupload/disk/DiskFileItem.java
+++ b/java/org/apache/tomcat/util/http/fileupload/disk/DiskFileItem.java
@@ -52,19 +52,7 @@ import org.apache.tomcat.util.http.fileupload.util.Streams;
  * it into memory, which may come handy with large files.
  *
  * <p>Temporary files, which are created for file items, should be
- * deleted later on. The best way to do this is using a
- * {@link org.apache.tomcat.util.http.fileupload.FileCleaningTracker
- * FileCleaningTracker}, which you can set on the
- * {@link DiskFileItemFactory}. However, if you do use such a tracker,
- * then you must consider the following: Temporary files are automatically
- * deleted as soon as they are no longer needed. (More precisely, when the
- * corresponding instance of {@link java.io.File} is garbage collected.)
- * This is done by the so-called reaper thread, which is started
- * automatically when the class
- * {@link org.apache.tomcat.util.http.fileupload.FileCleaningTracker} is loaded.
- * It might make sense to terminate that thread, for example, if
- * your web application ends. See the section on "Resource cleanup"
- * in the users guide of commons-fileupload.</p>
+ * deleted later on.</p>
  *
  * @since FileUpload 1.1
  *

==================================================
