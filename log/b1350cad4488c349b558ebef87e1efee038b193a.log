b1350cad4488c349b558ebef87e1efee038b193a
==================================================
Trailing whitespace removal from /modules/jdbc-pool
==================================================
Mark Emlyn
==================================================
Sat Oct 22 21:29:55 2011 +0000
==================================================
GenericNamingResourcesFactory.java
index 203340ed21..ddeef13307 100644
--- a/modules/jdbc-pool/pom.xml
+++ b/modules/jdbc-pool/pom.xml
@@ -7,7 +7,7 @@
     <artifactId>apache</artifactId>
     <version>9</version>
   </parent>
-  
+
   <groupId>org.apache.tomcat</groupId>
   <artifactId>jdbc-pool</artifactId>
   <version>1.2-SNAPSHOT</version>
@@ -15,11 +15,11 @@
 
   <name>jdbc-pool</name>
   <url>http://people.apache.org/~fhanik/jdbc-pool/</url>
-  
+
   <properties>
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
   </properties>
-  
+
   <mailingLists>
     <mailingList>
       <name>Development List</name>
@@ -34,12 +34,12 @@
       <post>users@tomcat.apache.org</post>
     </mailingList>
   </mailingLists>
-  
+
   <scm>
     <connection>scm:svn:https://svn.apache.org/repos/asf/tomcat/trunk/modules/jdbc-pool</connection>
     <developerConnection>scm:svn:https://svn.apache.org/repos/asf/tomcat/trunk/modules/jdbc-pool</developerConnection>
     <url>http://svn.apache.org/viewvc/tomcat/trunk/modules/jdbc-pool</url>
-  </scm>  
+  </scm>
 
   <dependencies>
     <dependency>
@@ -86,8 +86,8 @@
         <configuration>
         </configuration>
       </plugin>
-      
-      
+
+
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-gpg-plugin</artifactId>
@@ -122,7 +122,7 @@
             </goals>
           </execution>
         </executions>
-      </plugin>      
+      </plugin>
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
@@ -134,7 +134,7 @@
             </goals>
           </execution>
         </executions>
-      </plugin>      
-    </plugins>    
-  </build>  
+      </plugin>
+    </plugins>
+  </build>
 </project>

==================================================
ConnectionPool.java
index 2ee0b93317..360022876a 100644
--- a/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/naming/GenericNamingResourcesFactory.java
+++ b/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/naming/GenericNamingResourcesFactory.java
@@ -43,11 +43,11 @@ import org.apache.juli.logging.LogFactory;
  *              serverName=&quot;localhost&quot;
  *              port=&quot;1527&quot;/&gt;
  * </code></pre>
- * 
+ *
  */
 public class GenericNamingResourcesFactory implements ObjectFactory {
     private static final Log log = LogFactory.getLog(GenericNamingResourcesFactory.class);
-    
+
     @Override
     public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable<?, ?> environment) throws Exception {
         if ((obj == null) || !(obj instanceof Reference)) {
@@ -55,10 +55,10 @@ public class GenericNamingResourcesFactory implements ObjectFactory {
         }
         Reference ref = (Reference) obj;
         Enumeration<RefAddr> refs = ref.getAll();
-        
+
         String type = ref.getClassName();
         Object o = Class.forName(type).newInstance();
-        
+
         while (refs.hasMoreElements()) {
             RefAddr addr = refs.nextElement();
             String param = addr.getType();
@@ -67,7 +67,7 @@ public class GenericNamingResourcesFactory implements ObjectFactory {
                 value = addr.getContent().toString();
             }
             if (setProperty(o, param, value,false)) {
-                
+
             } else {
                 log.debug("Property not configured["+param+"]. No setter found on["+o+"].");
             }
@@ -159,9 +159,9 @@ public class GenericNamingResourcesFactory implements ObjectFactory {
                     if (methods[i].getReturnType()==Boolean.TYPE){
                         setPropertyMethodBool = methods[i];
                     }else {
-                        setPropertyMethodVoid = methods[i];    
+                        setPropertyMethodVoid = methods[i];
                     }
-                    
+
                 }
             }
 
@@ -205,8 +205,8 @@ public class GenericNamingResourcesFactory implements ObjectFactory {
                         o.getClass() + " " + name + "=" + value + ")", ie);
         }
         return false;
-    } 
-    
+    }
+
     public static String capitalize(String name) {
         if (name == null || name.length() == 0) {
             return name;

==================================================
DataSource.java
index 9ebc2635b3..2814cd000a 100644
--- a/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java
+++ b/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java
@@ -42,7 +42,7 @@ import org.apache.juli.logging.LogFactory;
  * Implementation of simple connection pool.
  * The ConnectionPool uses a {@link PoolProperties} object for storing all the meta information about the connection pool.
  * As the underlying implementation, the connection pool uses {@link java.util.concurrent.BlockingQueue} to store active and idle connections.
- * A custom implementation of a fair {@link FairBlockingQueue} blocking queue is provided with the connection pool itself. 
+ * A custom implementation of a fair {@link FairBlockingQueue} blocking queue is provided with the connection pool itself.
  * @author Filip Hanik
  * @version 1.0
  */
@@ -52,7 +52,7 @@ public class ConnectionPool {
      * Prefix type for JMX registration
      */
     public static final String POOL_JMX_TYPE_PREFIX = "tomcat.jdbc:type=";
-    
+
     /**
      * Logger
      */
@@ -104,17 +104,17 @@ public class ConnectionPool {
      * Executor service used to cancel Futures
      */
     private ThreadPoolExecutor cancellator = new ThreadPoolExecutor(0,1,1000,TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>());
-    
+
     /**
      * reference to the JMX mbean
      */
     protected org.apache.tomcat.jdbc.pool.jmx.ConnectionPool jmxPool = null;
-    
+
     /**
      * counter to track how many threads are waiting for a connection
      */
     private AtomicInteger waitcount = new AtomicInteger(0);
-    
+
     //===============================================================================
     //         PUBLIC METHODS
     //===============================================================================
@@ -144,7 +144,7 @@ public class ConnectionPool {
             PooledConnection pc = borrowConnection(0, null, null);
             if (pc!=null) {
                 return new ConnectionFuture(pc);
-            } 
+            }
         }catch (SQLException x) {
             if (x.getMessage().indexOf("NoWait")<0) {
                 throw x;
@@ -161,9 +161,9 @@ public class ConnectionPool {
             throw new SQLException("Connection pool is misconfigured, doesn't support async retrieval. Set the 'fair' property to 'true'");
         }
     }
-    
+
     /**
-     * Borrows a connection from the pool. If a connection is available (in the idle queue) or the pool has not reached 
+     * Borrows a connection from the pool. If a connection is available (in the idle queue) or the pool has not reached
      * {@link PoolProperties#maxActive maxActive} connections a connection is returned immediately.
      * If no connection is available, the pool will attempt to fetch a connection for {@link PoolProperties#maxWait maxWait} milliseconds.
      * @return Connection - a java.sql.Connection/javax.sql.PooledConnection reflection proxy, wrapping the underlying object.
@@ -175,14 +175,14 @@ public class ConnectionPool {
         return setupConnection(con);
     }
 
-       
+
     /**
      * Borrows a connection from the pool. If a connection is available (in the
      * idle queue) or the pool has not reached {@link PoolProperties#maxActive
      * maxActive} connections a connection is returned immediately. If no
      * connection is available, the pool will attempt to fetch a connection for
      * {@link PoolProperties#maxWait maxWait} milliseconds.
-     * 
+     *
      * @return Connection - a java.sql.Connection/javax.sql.PooledConnection
      *         reflection proxy, wrapping the underlying object.
      * @throws SQLException
@@ -194,7 +194,7 @@ public class ConnectionPool {
         PooledConnection con = borrowConnection(-1, username, password);
         return setupConnection(con);
     }
-    
+
     /**
      * Returns the name of this pool
      * @return String - the name of the pool
@@ -202,7 +202,7 @@ public class ConnectionPool {
     public String getName() {
         return getPoolProperties().getPoolName();
     }
-    
+
     /**
      * Return the number of threads waiting for a connection
      * @return number of threads waiting for a connection
@@ -214,7 +214,7 @@ public class ConnectionPool {
     /**
      * Returns the pool properties associated with this connection pool
      * @return PoolProperties
-     * 
+     *
      */
     public PoolConfiguration getPoolProperties() {
         return this.poolProperties;
@@ -255,12 +255,12 @@ public class ConnectionPool {
     //===============================================================================
     //         PROTECTED METHODS
     //===============================================================================
-    
-    
+
+
     /**
      * configures a pooled connection as a proxy.
      * This Proxy implements {@link java.sql.Connection} and {@link javax.sql.PooledConnection} interfaces.
-     * All calls on {@link java.sql.Connection} methods will be propagated down to the actual JDBC connection except for the 
+     * All calls on {@link java.sql.Connection} methods will be propagated down to the actual JDBC connection except for the
      * {@link java.sql.Connection#close()} method.
      * @param con a {@link PooledConnection} to wrap in a Proxy
      * @return a {@link java.sql.Connection} object wrapping a pooled connection.
@@ -317,10 +317,10 @@ public class ConnectionPool {
         }
 
     }
-    
+
     /**
      * Creates and caches a {@link java.lang.reflect.Constructor} used to instantiate the proxy object.
-     * We cache this, since the creation of a constructor is fairly slow. 
+     * We cache this, since the creation of a constructor is fairly slow.
      * @return constructor used to instantiate the wrapper object
      * @throws NoSuchMethodException
      */
@@ -433,10 +433,10 @@ public class ConnectionPool {
             poolCleaner = new PoolCleaner("[Pool-Cleaner]:" + properties.getName(), this, properties.getTimeBetweenEvictionRunsMillis());
             poolCleaner.start();
         } //end if
-        
+
         //create JMX MBean
         if (this.getPoolProperties().isJmxEnabled()) createMBean();
-        
+
         //Parse and create an initial set of interceptors. Letting them know the pool has started.
         //These interceptors will not get any connection.
         PoolProperties.InterceptorDefinition[] proxies = getPoolProperties().getJdbcInterceptorsAsArray();
@@ -457,7 +457,7 @@ public class ConnectionPool {
                 throw ex;
             }
         }
-        
+
         //initialize the pool with its initial set of members
         PooledConnection[] initialPool = new PooledConnection[poolProperties.getInitialSize()];
         try {
@@ -477,7 +477,7 @@ public class ConnectionPool {
                 } //end if
             } //for
         } //catch
-        
+
         closed = false;
     }
 
@@ -510,7 +510,7 @@ public class ConnectionPool {
             con.unlock();
         }
     }
-    
+
     /**
      * thread safe way to abandon a connection
      * signals a connection to be abandoned.
@@ -564,8 +564,8 @@ public class ConnectionPool {
 
     /**
      * Thread safe way to retrieve a connection from the pool
-     * @param wait - time to wait, overrides the maxWait from the properties, 
-     * set to -1 if you wish to use maxWait, 0 if you wish no wait time. 
+     * @param wait - time to wait, overrides the maxWait from the properties,
+     * set to -1 if you wish to use maxWait, 0 if you wish no wait time.
      * @return PooledConnection
      * @throws SQLException
      */
@@ -587,10 +587,10 @@ public class ConnectionPool {
                 //null should never be returned, but was in a previous impl.
                 if (result!=null) return result;
             }
-            
+
             //if we get here, see if we need to create one
             //this is not 100% accurate since it doesn't use a shared
-            //atomic variable - a connection can become idle while we are creating 
+            //atomic variable - a connection can become idle while we are creating
             //a new connection
             if (size.get() < getPoolProperties().getMaxActive()) {
                 //atomic duplicate check
@@ -609,7 +609,7 @@ public class ConnectionPool {
             if (wait==-1) {
                 maxWait = (getPoolProperties().getMaxWait()<=0)?Long.MAX_VALUE:getPoolProperties().getMaxWait();
             }
-            
+
             long timetowait = Math.max(0, maxWait - (System.currentTimeMillis() - now));
             waitcount.incrementAndGet();
             try {
@@ -698,29 +698,29 @@ public class ConnectionPool {
 
     /**
      * Validates and configures a previously idle connection
-     * @param now - timestamp  
+     * @param now - timestamp
      * @param con - the connection to validate and configure
      * @return con
      * @throws SQLException if a validation error happens
      */
     protected PooledConnection borrowConnection(long now, PooledConnection con, String username, String password) throws SQLException {
         //we have a connection, lets set it up
-        
+
         //flag to see if we need to nullify
         boolean setToNull = false;
         try {
             con.lock();
             boolean usercheck = con.checkUser(username, password);
-            
+
             if (con.isReleased()) {
                 return null;
             }
-            
+
             if (!con.isDiscarded() && !con.isInitialized()) {
                 //attempt to connect
                 con.connect();
             }
-            
+
             if (usercheck) {
                 if ((!con.isDiscarded()) && con.validate(PooledConnection.VALIDATE_BORROW)) {
                     //set the timestamp
@@ -794,7 +794,7 @@ public class ConnectionPool {
             return false;
         }
     }
-    
+
     /**
      * Returns a connection to the pool
      * If the pool is closed, the connection will be released
@@ -815,7 +815,7 @@ public class ConnectionPool {
                 con.lock();
 
                 if (busy.remove(con)) {
-                    
+
                     if (!shouldClose(con,PooledConnection.VALIDATE_RETURN)) {
                         con.setStackTrace(null);
                         con.setTimestamp(System.currentTimeMillis());
@@ -844,7 +844,7 @@ public class ConnectionPool {
     } //checkIn
 
     /**
-     * Determines if a connection should be abandoned based on 
+     * Determines if a connection should be abandoned based on
      * {@link PoolProperties#abandonWhenPercentageFull} setting.
      * @return true if the connection should be abandoned
      */
@@ -855,7 +855,7 @@ public class ConnectionPool {
         float perc = poolProperties.getAbandonWhenPercentageFull();
         return (used/max*100f)>=perc;
     }
-    
+
     /**
      * Iterates through all the busy connections and checks for connections that have timed out
      */
@@ -1016,7 +1016,7 @@ public class ConnectionPool {
             handler=handler.getNext();
         }
     }
-    
+
     /**
      * Hook to perform final actions on a pooled connection object once it has been disconnected and will be discarded
      * @param con
@@ -1031,7 +1031,7 @@ public class ConnectionPool {
 
     /**
      * Return the object that is potentially registered in JMX for notifications
-     * @return the object implementing the {@link org.apache.tomcat.jdbc.pool.jmx.ConnectionPoolMBean} interface 
+     * @return the object implementing the {@link org.apache.tomcat.jdbc.pool.jmx.ConnectionPoolMBean} interface
      */
     public org.apache.tomcat.jdbc.pool.jmx.ConnectionPool getJmxPool() {
         return jmxPool;
@@ -1051,7 +1051,7 @@ public class ConnectionPool {
     /**
      * Tread safe wrapper around a future for the regular queue
      * This one retrieves the pooled connection object
-     * and performs the initialization according to 
+     * and performs the initialization according to
      * interceptors and validation rules.
      * This class is thread safe and is cancellable
      * @author fhanik
@@ -1068,7 +1068,7 @@ public class ConnectionPool {
         public ConnectionFuture(Future<PooledConnection> pcf) {
             this.pcFuture = pcf;
         }
-        
+
         public ConnectionFuture(PooledConnection pc) throws SQLException {
             this.pc = pc;
             result = ConnectionPool.this.setupConnection(pc);
@@ -1118,7 +1118,7 @@ public class ConnectionPool {
                         latch.countDown();
                     }
                 } else {
-                    //if we reach here, another thread is configuring the actual connection 
+                    //if we reach here, another thread is configuring the actual connection
                     latch.await(timeout,unit); //this shouldn't block for long
                 }
                 if (result==null) throw new ExecutionException(cause);
@@ -1143,7 +1143,7 @@ public class ConnectionPool {
         public boolean isDone() {
             return pc!=null || pcFuture.isDone();
         }
-        
+
         /**
          * run method to be executed when cancelled by an executor
          */
@@ -1158,7 +1158,7 @@ public class ConnectionPool {
                 ConnectionPool.log.error("Unable to cancel ConnectionFuture.",x);
             }
         }
-        
+
     }
 
     protected class PoolCleaner extends Thread {

==================================================
DataSourceFactory.java
index 65bd6c5fdd..8e05077855 100644
--- a/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSource.java
+++ b/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSource.java
@@ -45,7 +45,7 @@ public class DataSource extends DataSourceProxy implements javax.sql.DataSource,
     public DataSource() {
         super();
     }
-    
+
     /**
      * Constructs a DataSource object wrapping a connection
      * @param poolProperties
@@ -53,10 +53,10 @@ public class DataSource extends DataSourceProxy implements javax.sql.DataSource,
     public DataSource(PoolConfiguration poolProperties) {
         super(poolProperties);
     }
-    
-    
-    
-    
+
+
+
+
 
 //===============================================================================
 //  JMX Operations - Register the actual pool itself under the tomcat.jdbc domain
@@ -103,9 +103,9 @@ public class DataSource extends DataSourceProxy implements javax.sql.DataSource,
         }catch (MalformedObjectNameException x) {
             log.error("Unable to create object name for JDBC pool.",x);
         }
-        return name;   
+        return name;
     }
-    
+
     /**
      * Creates the ObjectName for the ConnectionPoolMBean object to be registered
      * @param original the ObjectName for the DataSource
@@ -124,7 +124,7 @@ public class DataSource extends DataSourceProxy implements javax.sql.DataSource,
         ObjectName name = new ObjectName(domain,properties);
         return name;
     }
-    
+
     /**
      * Registers the ConnectionPoolMBean under a unique name based on the ObjectName for the DataSource
      */
@@ -138,9 +138,9 @@ public class DataSource extends DataSourceProxy implements javax.sql.DataSource,
             log.error("Unable to register JDBC pool with JMX",e);
         }
     }
-    
+
     /**
-     * 
+     *
      */
     protected void unregisterJmx() {
         try {

==================================================
DataSourceProxy.java
index d7435787a5..4b9a833ec5 100644
--- a/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java
+++ b/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java
@@ -62,7 +62,7 @@ public class DataSourceFactory implements ObjectFactory {
     protected final static String PROP_DEFAULTREADONLY = "defaultReadOnly";
     protected final static String PROP_DEFAULTTRANSACTIONISOLATION = "defaultTransactionIsolation";
     protected final static String PROP_DEFAULTCATALOG = "defaultCatalog";
-    
+
     protected final static String PROP_DRIVERCLASSNAME = "driverClassName";
     protected final static String PROP_PASSWORD = "password";
     protected final static String PROP_URL = "url";
@@ -74,48 +74,48 @@ public class DataSourceFactory implements ObjectFactory {
     protected final static String PROP_INITIALSIZE = "initialSize";
     protected final static String PROP_MAXWAIT = "maxWait";
     protected final static String PROP_MAXAGE = "maxAge";
-    
+
     protected final static String PROP_TESTONBORROW = "testOnBorrow";
     protected final static String PROP_TESTONRETURN = "testOnReturn";
     protected final static String PROP_TESTWHILEIDLE = "testWhileIdle";
     protected final static String PROP_TESTONCONNECT = "testOnConnect";
     protected final static String PROP_VALIDATIONQUERY = "validationQuery";
     protected final static String PROP_VALIDATOR_CLASS_NAME = "validatorClassName";
-    
+
     protected final static String PROP_TIMEBETWEENEVICTIONRUNSMILLIS = "timeBetweenEvictionRunsMillis";
     protected final static String PROP_NUMTESTSPEREVICTIONRUN = "numTestsPerEvictionRun";
     protected final static String PROP_MINEVICTABLEIDLETIMEMILLIS = "minEvictableIdleTimeMillis";
-    
+
     protected final static String PROP_ACCESSTOUNDERLYINGCONNECTIONALLOWED = "accessToUnderlyingConnectionAllowed";
-    
+
     protected final static String PROP_REMOVEABANDONED = "removeAbandoned";
     protected final static String PROP_REMOVEABANDONEDTIMEOUT = "removeAbandonedTimeout";
     protected final static String PROP_LOGABANDONED = "logAbandoned";
     protected final static String PROP_ABANDONWHENPERCENTAGEFULL = "abandonWhenPercentageFull";
-    
+
     protected final static String PROP_POOLPREPAREDSTATEMENTS = "poolPreparedStatements";
     protected final static String PROP_MAXOPENPREPAREDSTATEMENTS = "maxOpenPreparedStatements";
     protected final static String PROP_CONNECTIONPROPERTIES = "connectionProperties";
-    
+
     protected final static String PROP_INITSQL = "initSQL";
     protected final static String PROP_INTERCEPTORS = "jdbcInterceptors";
     protected final static String PROP_VALIDATIONINTERVAL = "validationInterval";
     protected final static String PROP_JMX_ENABLED = "jmxEnabled";
     protected final static String PROP_FAIR_QUEUE = "fairQueue";
-    
+
     protected static final String PROP_USE_EQUALS = "useEquals";
     protected static final String PROP_USE_CON_LOCK = "useLock";
-    
+
     protected static final String PROP_DATASOURCE= "dataSource";
     protected static final String PROP_DATASOURCE_JNDI = "dataSourceJNDI";
-    
+
     protected static final String PROP_SUSPECT_TIMEOUT = "suspectTimeout";
-    
+
     protected static final String PROP_ALTERNATE_USERNAME_ALLOWED = "alternateUsernameAllowed";
-    
-    
+
+
     public static final int UNKNOWN_TRANSACTIONISOLATION = -1;
-    
+
     public static final String OBJECT_NAME = "object_name";
 
 
@@ -204,12 +204,12 @@ public class DataSourceFactory implements ObjectFactory {
         if (org.apache.tomcat.jdbc.pool.DataSource.class.getName().equals(ref.getClassName())) {
             ok = true;
         }
-        
+
         if (!ok) {
             log.warn(ref.getClassName()+" is not a valid class name/type for this JNDI factory.");
             return null;
         }
-        
+
 
         Properties properties = new Properties();
         for (int i = 0; i < ALL_PROPERTIES.length; i++) {
@@ -223,7 +223,7 @@ public class DataSourceFactory implements ObjectFactory {
 
         return createDataSource(properties,nameCtx,XA);
     }
-    
+
     public static PoolConfiguration parsePoolProperties(Properties properties) {
         PoolConfiguration poolProperties = new PoolProperties();
         String value = null;
@@ -353,7 +353,7 @@ public class DataSourceFactory implements ObjectFactory {
         if (value != null) {
             poolProperties.setValidationQuery(value);
         }
-        
+
         value = properties.getProperty(PROP_VALIDATOR_CLASS_NAME);
         if (value != null) {
             poolProperties.setValidatorClassName(value);
@@ -423,12 +423,12 @@ public class DataSourceFactory implements ObjectFactory {
         if (value != null) {
             poolProperties.setJmxEnabled(Boolean.parseBoolean(value));
         }
-        
+
         value = properties.getProperty(PROP_FAIR_QUEUE);
         if (value != null) {
             poolProperties.setFairQueue(Boolean.parseBoolean(value));
         }
-        
+
         value = properties.getProperty(PROP_USE_EQUALS);
         if (value != null) {
             poolProperties.setUseEquals(Boolean.parseBoolean(value));
@@ -438,29 +438,29 @@ public class DataSourceFactory implements ObjectFactory {
         if (value != null) {
             poolProperties.setName(ObjectName.quote(value));
         }
-        
+
         value = properties.getProperty(PROP_ABANDONWHENPERCENTAGEFULL);
         if (value != null) {
             poolProperties.setAbandonWhenPercentageFull(Integer.parseInt(value));
         }
-        
+
         value = properties.getProperty(PROP_MAXAGE);
         if (value != null) {
             poolProperties.setMaxAge(Long.parseLong(value));
         }
-        
+
         value = properties.getProperty(PROP_USE_CON_LOCK);
         if (value != null) {
             poolProperties.setUseLock(Boolean.parseBoolean(value));
         }
-        
+
         value = properties.getProperty(PROP_DATASOURCE);
         if (value != null) {
             //this should never happen
             throw new IllegalArgumentException("Can't set dataSource property as a string, this must be a javax.sql.DataSource object.");
-            
+
         }
-        
+
         value = properties.getProperty(PROP_DATASOURCE_JNDI);
         if (value != null) {
             poolProperties.setDataSourceJNDI(value);
@@ -470,12 +470,12 @@ public class DataSourceFactory implements ObjectFactory {
         if (value != null) {
             poolProperties.setSuspectTimeout(Integer.parseInt(value));
         }
-        
+
         value = properties.getProperty(PROP_ALTERNATE_USERNAME_ALLOWED);
         if (value != null) {
             poolProperties.setAlternateUsernameAllowed(Boolean.parseBoolean(value));
         }
-        
+
         return poolProperties;
     }
 
@@ -526,7 +526,7 @@ public class DataSourceFactory implements ObjectFactory {
             poolProperties.setDataSource(jndiDS);
         }
     }
-    
+
     /**
      * <p>Parse properties from the string. Format of the string must be [propertyName=property;]*<p>
      * @param propText

==================================================
FairBlockingQueue.java
index 38fa66c6d6..6d29230c53 100644
--- a/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java
+++ b/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java
@@ -31,10 +31,10 @@ import org.apache.tomcat.jdbc.pool.PoolProperties.InterceptorDefinition;
 
 /**
  *
- * The DataSource proxy lets us implements methods that don't exist in the current 
+ * The DataSource proxy lets us implements methods that don't exist in the current
  * compiler JDK but might be methods that are part of a future JDK DataSource interface.
  * <br/>
- * It's a trick to work around compiler issues when implementing interfaces. For example, 
+ * It's a trick to work around compiler issues when implementing interfaces. For example,
  * I could put in Java 6 methods of javax.sql.DataSource here, and compile it with JDK 1.5
  * and still be able to run under Java 6 without getting NoSuchMethodException.
  *
@@ -44,15 +44,15 @@ import org.apache.tomcat.jdbc.pool.PoolProperties.InterceptorDefinition;
 
 public class DataSourceProxy implements PoolConfiguration {
     private static final Log log = LogFactory.getLog(DataSourceProxy.class);
-    
+
     protected volatile ConnectionPool pool = null;
-    
+
     protected PoolConfiguration poolProperties = null;
 
     public DataSourceProxy() {
         this(new PoolProperties());
     }
-    
+
     public DataSourceProxy(PoolConfiguration poolProperties) {
         if (poolProperties == null) throw new NullPointerException("PoolConfiguration can not be null.");
         this.poolProperties = poolProperties;
@@ -99,7 +99,7 @@ public class DataSourceProxy implements PoolConfiguration {
             return pCreatePool();
         }
     }
-    
+
     /**
      * Sets up the connection pool, by creating a pooling driver.
      * @return Driver
@@ -123,10 +123,10 @@ public class DataSourceProxy implements PoolConfiguration {
             return createPool().getConnection();
         return pool.getConnection();
     }
-    
+
     /**
      * Invokes an sync operation to retrieve the connection.
-     * @return a Future containing a reference to the connection when it becomes available 
+     * @return a Future containing a reference to the connection when it becomes available
      * @throws SQLException
      */
     public Future<Connection> getConnectionAsync() throws SQLException {
@@ -134,9 +134,9 @@ public class DataSourceProxy implements PoolConfiguration {
             return createPool().getConnectionAsync();
         return pool.getConnectionAsync();
     }
-    
+
     /**
-     * {@link javax.sql.XADataSource#getXAConnection()} 
+     * {@link javax.sql.XADataSource#getXAConnection()}
      */
     public XAConnection getXAConnection() throws SQLException {
         Connection con = getConnection();
@@ -147,9 +147,9 @@ public class DataSourceProxy implements PoolConfiguration {
             throw new SQLException("Connection from pool does not implement javax.sql.XAConnection");
         }
     }
-    
+
     /**
-     * {@link javax.sql.XADataSource#getXAConnection(String, String)} 
+     * {@link javax.sql.XADataSource#getXAConnection(String, String)}
      */
     public XAConnection getXAConnection(String username, String password) throws SQLException {
         Connection con = getConnection(username, password);
@@ -176,12 +176,12 @@ public class DataSourceProxy implements PoolConfiguration {
                                                 String password) throws SQLException {
         return (javax.sql.PooledConnection) getConnection();
     }
-    
+
     public ConnectionPool getPool() {
         return pool;
     }
 
-    
+
     public void close() {
         close(false);
     }
@@ -205,7 +205,7 @@ public class DataSourceProxy implements PoolConfiguration {
         else return p.getSize();
     }
 
-    
+
     @Override
     public String toString() {
         return super.toString()+"{"+getPoolProperties()+"}";
@@ -215,216 +215,216 @@ public class DataSourceProxy implements PoolConfiguration {
 /*-----------------------------------------------------------------------*/
 //      PROPERTIES WHEN NOT USED WITH FACTORY
 /*------------------------------------------------------------------------*/
-   
-    /** 
+
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public String getPoolName() {
         return pool.getName();
     }
-   
-   
+
+
     public void setPoolProperties(PoolConfiguration poolProperties) {
         this.poolProperties = poolProperties;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setDriverClassName(String driverClassName) {
         this.poolProperties.setDriverClassName(driverClassName);
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setInitialSize(int initialSize) {
         this.poolProperties.setInitialSize(initialSize);
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setInitSQL(String initSQL) {
         this.poolProperties.setInitSQL(initSQL);
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setLogAbandoned(boolean logAbandoned) {
         this.poolProperties.setLogAbandoned(logAbandoned);
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setMaxActive(int maxActive) {
         this.poolProperties.setMaxActive(maxActive);
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setMaxIdle(int maxIdle) {
         this.poolProperties.setMaxIdle(maxIdle);
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setMaxWait(int maxWait) {
         this.poolProperties.setMaxWait(maxWait);
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setMinEvictableIdleTimeMillis(int minEvictableIdleTimeMillis) {
         this.poolProperties.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setMinIdle(int minIdle) {
         this.poolProperties.setMinIdle(minIdle);
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
         this.poolProperties.setNumTestsPerEvictionRun(numTestsPerEvictionRun);
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setPassword(String password) {
         this.poolProperties.setPassword(password);
         this.poolProperties.getDbProperties().setProperty("password",this.poolProperties.getPassword());
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setRemoveAbandoned(boolean removeAbandoned) {
         this.poolProperties.setRemoveAbandoned(removeAbandoned);
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setRemoveAbandonedTimeout(int removeAbandonedTimeout) {
         this.poolProperties.setRemoveAbandonedTimeout(removeAbandonedTimeout);
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setTestOnBorrow(boolean testOnBorrow) {
         this.poolProperties.setTestOnBorrow(testOnBorrow);
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setTestOnConnect(boolean testOnConnect) {
         this.poolProperties.setTestOnConnect(testOnConnect);
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setTestOnReturn(boolean testOnReturn) {
         this.poolProperties.setTestOnReturn(testOnReturn);
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setTestWhileIdle(boolean testWhileIdle) {
         this.poolProperties.setTestWhileIdle(testWhileIdle);
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setTimeBetweenEvictionRunsMillis(int timeBetweenEvictionRunsMillis) {
         this.poolProperties.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setUrl(String url) {
         this.poolProperties.setUrl(url);
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setUsername(String username) {
         this.poolProperties.setUsername(username);
         this.poolProperties.getDbProperties().setProperty("user",getPoolProperties().getUsername());
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setValidationInterval(long validationInterval) {
         this.poolProperties.setValidationInterval(validationInterval);
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setValidationQuery(String validationQuery) {
         this.poolProperties.setValidationQuery(validationQuery);
@@ -433,79 +433,79 @@ public class DataSourceProxy implements PoolConfiguration {
     /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setValidatorClassName(String className) {
         this.poolProperties.setValidatorClassName(className);
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setJdbcInterceptors(String interceptors) {
         this.getPoolProperties().setJdbcInterceptors(interceptors);
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setJmxEnabled(boolean enabled) {
         this.getPoolProperties().setJmxEnabled(enabled);
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setFairQueue(boolean fairQueue) {
         this.getPoolProperties().setFairQueue(fairQueue);
     }
-    
-    /** 
+
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setUseLock(boolean useLock) {
         this.getPoolProperties().setUseLock(useLock);
     }
-    
-    /** 
+
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setDefaultCatalog(String catalog) {
         this.getPoolProperties().setDefaultCatalog(catalog);
     }
-    
-    /** 
+
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setDefaultAutoCommit(Boolean autocommit) {
         this.getPoolProperties().setDefaultAutoCommit(autocommit);
     }
-    
-    /** 
+
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setDefaultTransactionIsolation(int defaultTransactionIsolation) {
         this.getPoolProperties().setDefaultTransactionIsolation(defaultTransactionIsolation);
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setConnectionProperties(String properties) {
         try {
@@ -523,11 +523,11 @@ public class DataSourceProxy implements PoolConfiguration {
             throw new RuntimeException(x);
         }
     }
-    
-    /** 
+
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setUseEquals(boolean useEquals) {
         this.getPoolProperties().setUseEquals(useEquals);
@@ -572,27 +572,27 @@ public class DataSourceProxy implements PoolConfiguration {
             poolProperties.setMaxWait(1000 * i);
         }
 
-    }    
-    
-    
+    }
+
+
     /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public int getSuspectTimeout() {
-        return getPoolProperties().getSuspectTimeout(); 
+        return getPoolProperties().getSuspectTimeout();
     }
 
     /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setSuspectTimeout(int seconds) {
         getPoolProperties().setSuspectTimeout(seconds);
     }
-    
+
   //===============================================================================
 //  Expose JMX attributes through Tomcat's dynamic reflection
 //===============================================================================
@@ -648,7 +648,7 @@ public class DataSourceProxy implements PoolConfiguration {
             throw new RuntimeException(x);
         }
     }
-    
+
     /**
      * @return number of connections in use by the application
      * {@link DataSource#getActive()}
@@ -688,151 +688,151 @@ public class DataSourceProxy implements PoolConfiguration {
         }catch (SQLException x) {
             throw new RuntimeException(x);
         }
-    }    
+    }
     //=========================================================
     //  PROPERTIES / CONFIGURATION
-    //=========================================================    
-    
-    /** 
+    //=========================================================
+
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public String getConnectionProperties() {
         return getPoolProperties().getConnectionProperties();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public Properties getDbProperties() {
         return getPoolProperties().getDbProperties();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public String getDefaultCatalog() {
         return getPoolProperties().getDefaultCatalog();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public int getDefaultTransactionIsolation() {
         return getPoolProperties().getDefaultTransactionIsolation();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public String getDriverClassName() {
         return getPoolProperties().getDriverClassName();
     }
 
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public int getInitialSize() {
         return getPoolProperties().getInitialSize();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public String getInitSQL() {
         return getPoolProperties().getInitSQL();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public String getJdbcInterceptors() {
         return getPoolProperties().getJdbcInterceptors();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public int getMaxActive() {
         return getPoolProperties().getMaxActive();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public int getMaxIdle() {
         return getPoolProperties().getMaxIdle();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public int getMaxWait() {
         return getPoolProperties().getMaxWait();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public int getMinEvictableIdleTimeMillis() {
         return getPoolProperties().getMinEvictableIdleTimeMillis();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public int getMinIdle() {
         return getPoolProperties().getMinIdle();
     }
-    
-    /** 
+
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public long getMaxAge() {
         return getPoolProperties().getMaxAge();
-    }    
+    }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public String getName() {
         return getPoolProperties().getName();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public int getNumTestsPerEvictionRun() {
         return getPoolProperties().getNumTestsPerEvictionRun();
@@ -846,56 +846,56 @@ public class DataSourceProxy implements PoolConfiguration {
         return "Password not available as DataSource/JMX operation.";
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public int getRemoveAbandonedTimeout() {
         return getPoolProperties().getRemoveAbandonedTimeout();
     }
 
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public int getTimeBetweenEvictionRunsMillis() {
         return getPoolProperties().getTimeBetweenEvictionRunsMillis();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public String getUrl() {
         return getPoolProperties().getUrl();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public String getUsername() {
         return getPoolProperties().getUsername();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public long getValidationInterval() {
         return getPoolProperties().getValidationInterval();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public String getValidationQuery() {
         return getPoolProperties().getValidationQuery();
@@ -904,7 +904,7 @@ public class DataSourceProxy implements PoolConfiguration {
     /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public String getValidatorClassName() {
         return getPoolProperties().getValidatorClassName();
@@ -913,13 +913,13 @@ public class DataSourceProxy implements PoolConfiguration {
     /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public Validator getValidator() {
         return getPoolProperties().getValidator();
     }
-    
-    /** 
+
+    /**
      * {@inheritDoc}
      */
     @Override
@@ -928,249 +928,249 @@ public class DataSourceProxy implements PoolConfiguration {
     }
 
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public boolean isAccessToUnderlyingConnectionAllowed() {
         return getPoolProperties().isAccessToUnderlyingConnectionAllowed();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public Boolean isDefaultAutoCommit() {
         return getPoolProperties().isDefaultAutoCommit();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public Boolean isDefaultReadOnly() {
         return getPoolProperties().isDefaultReadOnly();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public boolean isLogAbandoned() {
         return getPoolProperties().isLogAbandoned();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public boolean isPoolSweeperEnabled() {
         return getPoolProperties().isPoolSweeperEnabled();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public boolean isRemoveAbandoned() {
         return getPoolProperties().isRemoveAbandoned();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public int getAbandonWhenPercentageFull() {
         return getPoolProperties().getAbandonWhenPercentageFull();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public boolean isTestOnBorrow() {
         return getPoolProperties().isTestOnBorrow();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public boolean isTestOnConnect() {
         return getPoolProperties().isTestOnConnect();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public boolean isTestOnReturn() {
         return getPoolProperties().isTestOnReturn();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public boolean isTestWhileIdle() {
         return getPoolProperties().isTestWhileIdle();
     }
 
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public Boolean getDefaultAutoCommit() {
         return getPoolProperties().getDefaultAutoCommit();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public Boolean getDefaultReadOnly() {
         return getPoolProperties().getDefaultReadOnly();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public InterceptorDefinition[] getJdbcInterceptorsAsArray() {
         return getPoolProperties().getJdbcInterceptorsAsArray();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public boolean getUseLock() {
         return getPoolProperties().getUseLock();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public boolean isFairQueue() {
         return getPoolProperties().isFairQueue();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public boolean isJmxEnabled() {
         return getPoolProperties().isJmxEnabled();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public boolean isUseEquals() {
         return getPoolProperties().isUseEquals();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setAbandonWhenPercentageFull(int percentage) {
         getPoolProperties().setAbandonWhenPercentageFull(percentage);
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setAccessToUnderlyingConnectionAllowed(boolean accessToUnderlyingConnectionAllowed) {
         getPoolProperties().setAccessToUnderlyingConnectionAllowed(accessToUnderlyingConnectionAllowed);
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setDbProperties(Properties dbProperties) {
         getPoolProperties().setDbProperties(dbProperties);
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setDefaultReadOnly(Boolean defaultReadOnly) {
         getPoolProperties().setDefaultReadOnly(defaultReadOnly);
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setMaxAge(long maxAge) {
         getPoolProperties().setMaxAge(maxAge);
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setName(String name) {
         getPoolProperties().setName(name);
     }
-    
-    /** 
+
+    /**
      * {@inheritDoc}
      */
     @Override
     public void setDataSource(Object ds) {
         getPoolProperties().setDataSource(ds);
     }
-    
-    /** 
+
+    /**
      * {@inheritDoc}
      */
     @Override
     public Object getDataSource() {
         return getPoolProperties().getDataSource();
     }
-    
-    
-    /** 
+
+
+    /**
      * {@inheritDoc}
      */
     @Override
     public void setDataSourceJNDI(String jndiDS) {
         getPoolProperties().setDataSourceJNDI(jndiDS);
     }
-    
-    /** 
+
+    /**
      * {@inheritDoc}
      */
     @Override
@@ -1178,7 +1178,7 @@ public class DataSourceProxy implements PoolConfiguration {
         return getPoolProperties().getDataSourceJNDI();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
     @Override
@@ -1186,12 +1186,12 @@ public class DataSourceProxy implements PoolConfiguration {
         return getPoolProperties().isAlternateUsernameAllowed();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
     @Override
     public void setAlternateUsernameAllowed(boolean alternateUsernameAllowed) {
         getPoolProperties().setAlternateUsernameAllowed(alternateUsernameAllowed);
     }
-    
+
 }

==================================================
JdbcInterceptor.java
index 8e147dcffa..4b59f41db9 100644
--- a/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java
+++ b/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java
@@ -32,7 +32,7 @@ import java.util.concurrent.locks.ReentrantLock;
  *
  * A simple implementation of a blocking queue with fairness waiting.
  * invocations to method poll(...) will get handed out in the order they were received.
- * Locking is fine grained, a shared lock is only used during the first level of contention, waiting is done in a 
+ * Locking is fine grained, a shared lock is only used during the first level of contention, waiting is done in a
  * lock per thread basis so that order is guaranteed once the thread goes into a suspended monitor state.
  * <br/>
  * Not all of the methods of the {@link java.util.concurrent.BlockingQueue} are implemented.
@@ -41,12 +41,12 @@ import java.util.concurrent.locks.ReentrantLock;
  */
 
 public class FairBlockingQueue<E> implements BlockingQueue<E> {
-    
+
     /**
-     * This little sucker is used to reorder the way to do 
+     * This little sucker is used to reorder the way to do
      * {@link java.util.concurrent.locks.Lock#lock()},
      * {@link java.util.concurrent.locks.Lock#unlock()}
-     * and 
+     * and
      * {@link java.util.concurrent.CountDownLatch#countDown()}
      * during the {@link #poll(long, TimeUnit)} operation.
      * On Linux, it performs much better if we count down while we hold the global
@@ -55,10 +55,10 @@ public class FairBlockingQueue<E> implements BlockingQueue<E> {
      */
     final static boolean isLinux = "Linux".equals(System.getProperty("os.name")) &&
                                    (!Boolean.getBoolean(FairBlockingQueue.class.getName()+".ignoreOS"));
-    
+
     /**
-     * Phase one entry lock in order to give out 
-     * per-thread-locks for the waiting phase we have 
+     * Phase one entry lock in order to give out
+     * per-thread-locks for the waiting phase we have
      * a phase one lock during the contention period.
      */
     final ReentrantLock lock = new ReentrantLock(false);
@@ -72,7 +72,7 @@ public class FairBlockingQueue<E> implements BlockingQueue<E> {
      * All threads waiting for an object are stored in a linked list
      */
     final LinkedList<ExchangeCountDownLatch<E>> waiters;
-    
+
     /**
      * Creates a new fair blocking queue.
      */
@@ -117,7 +117,7 @@ public class FairBlockingQueue<E> implements BlockingQueue<E> {
 
     /**
      * Will never timeout, as it invokes the {@link #offer(Object)} method.
-     * Once a lock has been acquired, the  
+     * Once a lock has been acquired, the
      * {@inheritDoc}
      */
     @Override
@@ -168,7 +168,7 @@ public class FairBlockingQueue<E> implements BlockingQueue<E> {
         }
         return result;
     }
-    
+
     /**
      * Request an item from the queue asynchronously
      * @return - a future pending the result from the queue poll request
@@ -202,7 +202,7 @@ public class FairBlockingQueue<E> implements BlockingQueue<E> {
         }
         return result;
     }
-    
+
     /**
      * {@inheritDoc}
      */
@@ -216,7 +216,7 @@ public class FairBlockingQueue<E> implements BlockingQueue<E> {
             lock.unlock();
         }
     }
-    
+
     /**
      * {@inheritDoc}
      */
@@ -286,7 +286,7 @@ public class FairBlockingQueue<E> implements BlockingQueue<E> {
      * {@inheritDoc}
      * @throws UnsupportedOperationException - this operation is not supported
      */
-    
+
     @Override
     public int drainTo(Collection<? super E> c) {
         return drainTo(c,Integer.MAX_VALUE);
@@ -428,15 +428,15 @@ public class FairBlockingQueue<E> implements BlockingQueue<E> {
         protected volatile T item = null;
         protected volatile ExchangeCountDownLatch<T> latch = null;
         protected volatile boolean canceled = false;
-        
+
         public ItemFuture(T item) {
             this.item = item;
         }
-        
+
         public ItemFuture(ExchangeCountDownLatch<T> latch) {
             this.latch = latch;
         }
-        
+
         @Override
         public boolean cancel(boolean mayInterruptIfRunning) {
             return false; //don't allow cancel for now
@@ -476,7 +476,7 @@ public class FairBlockingQueue<E> implements BlockingQueue<E> {
         public boolean isDone() {
             return (item!=null || latch.getItem()!=null);
         }
-        
+
     }
 
     //------------------------------------------------------------------

==================================================
MultiLockFairBlockingQueue.java
index 2cea49d897..1e9a6cc51f 100644
--- a/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/JdbcInterceptor.java
+++ b/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/JdbcInterceptor.java
@@ -24,14 +24,14 @@ import org.apache.tomcat.jdbc.pool.PoolProperties.InterceptorProperty;
 
 /**
  * Abstract class that is to be extended for implementations of interceptors.
- * Everytime an operation is called on the {@link java.sql.Connection} object the 
+ * Everytime an operation is called on the {@link java.sql.Connection} object the
  * {@link #invoke(Object, Method, Object[])} method on the interceptor will be called.
  * Interceptors are useful to change or improve behavior of the connection pool.<br/>
- * Interceptors can receive a set of properties. Each sub class is responsible for parsing the properties during runtime when they 
- * are needed or simply override the {@link #setProperties(Map)} method. 
+ * Interceptors can receive a set of properties. Each sub class is responsible for parsing the properties during runtime when they
+ * are needed or simply override the {@link #setProperties(Map)} method.
  * Properties arrive in a key-value pair of Strings as they were received through the configuration.
  * This method is called once per cached connection object when the object is first configured.
- * 
+ *
  * @author Filip Hanik
  * @version 1.0
  */
@@ -61,12 +61,12 @@ public abstract class JdbcInterceptor implements InvocationHandler {
      */
     public static final String ISWRAPPERFOR_VAL = "isWrapperFor";
 
-    
+
     /**
      * Properties for this interceptor.
      */
-    protected Map<String,InterceptorProperty> properties = null; 
-    
+    protected Map<String,InterceptorProperty> properties = null;
+
     /**
      * The next interceptor in the chain
      */
@@ -89,7 +89,7 @@ public abstract class JdbcInterceptor implements InvocationHandler {
      * Gets invoked each time an operation on {@link java.sql.Connection} is invoked.
      * {@inheritDoc}
      */
-    
+
     @Override
     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
         if (getNext()!=null) return getNext().invoke(proxy,method,args);
@@ -111,7 +111,7 @@ public abstract class JdbcInterceptor implements InvocationHandler {
     public void setNext(JdbcInterceptor next) {
         this.next = next;
     }
-    
+
     /**
      * Performs a string comparison, using references unless the useEquals property is set to true.
      * @param name1
@@ -125,7 +125,7 @@ public abstract class JdbcInterceptor implements InvocationHandler {
             return name1==name2;
         }
     }
-    
+
     /**
      * Compares a method name (String) to a method (Method)
      * {@link #compare(String,String)}
@@ -137,7 +137,7 @@ public abstract class JdbcInterceptor implements InvocationHandler {
     public boolean compare(String methodName, Method method) {
         return compare(methodName, method.getName());
     }
-    
+
     /**
      * Gets called each time the connection is borrowed from the pool
      * This means that if an interceptor holds a reference to the connection
@@ -148,7 +148,7 @@ public abstract class JdbcInterceptor implements InvocationHandler {
      * @param con - the pooled connection
      */
     public abstract void reset(ConnectionPool parent, PooledConnection con);
-    
+
     /**
      * Called when {@link java.sql.Connection#close()} is called on the underlying connection.
      * This is to notify the interceptors, that the physical connection has been released.
@@ -159,8 +159,8 @@ public abstract class JdbcInterceptor implements InvocationHandler {
      */
     public void disconnected(ConnectionPool parent, PooledConnection con, boolean finalizing) {
     }
-        
-    
+
+
     /**
      * Returns the properties configured for this interceptor
      * @return the configured properties for this interceptor
@@ -183,7 +183,7 @@ public abstract class JdbcInterceptor implements InvocationHandler {
             setUseEquals(Boolean.parseBoolean(p.getValue()));
         }
     }
-    
+
     /**
      * @return true if the compare method uses the Object.equals(Object) method
      *         false if comparison is done on a reference level
@@ -191,7 +191,7 @@ public abstract class JdbcInterceptor implements InvocationHandler {
     public boolean isUseEquals() {
         return useEquals;
     }
-    
+
     /**
      * Set to true if string comparisons (for the {@link #compare(String, Method)} and {@link #compare(String, String)} methods) should use the Object.equals(Object) method
      * The default is false
@@ -200,7 +200,7 @@ public abstract class JdbcInterceptor implements InvocationHandler {
     public void setUseEquals(boolean useEquals) {
         this.useEquals = useEquals;
     }
-    
+
     /**
      * This method is invoked by a connection pool when the pool is closed.
      * Interceptor classes can override this method if they keep static

==================================================
PoolConfiguration.java
index 45a5653df8..e7d87ceefd 100644
--- a/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java
+++ b/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java
@@ -36,7 +36,7 @@ import java.util.concurrent.locks.ReentrantLock;
  *
  * An implementation of a blocking queue with fairness waiting and lock dispersal to avoid contention.
  * invocations to method poll(...) will get handed out in the order they were received.
- * Locking is fine grained, a shared lock is only used during the first level of contention, waiting is done in a 
+ * Locking is fine grained, a shared lock is only used during the first level of contention, waiting is done in a
  * lock per thread basis so that order is guaranteed once the thread goes into a suspended monitor state.
  * <br/>
  * Not all of the methods of the {@link java.util.concurrent.BlockingQueue} are implemented.
@@ -45,24 +45,24 @@ import java.util.concurrent.locks.ReentrantLock;
  */
 
 public class MultiLockFairBlockingQueue<E> implements BlockingQueue<E> {
-    
+
     final int LOCK_COUNT = Runtime.getRuntime().availableProcessors();
-    
+
     final AtomicInteger putQueue = new AtomicInteger(0);
     final AtomicInteger pollQueue = new AtomicInteger(0);
-    
+
     public int getNextPut() {
         int idx = Math.abs(putQueue.incrementAndGet()) % LOCK_COUNT;
         return idx;
     }
-    
+
     public int getNextPoll() {
         int idx = Math.abs(pollQueue.incrementAndGet()) % LOCK_COUNT;
         return idx;
     }
     /**
-     * Phase one entry lock in order to give out 
-     * per-thread-locks for the waiting phase we have 
+     * Phase one entry lock in order to give out
+     * per-thread-locks for the waiting phase we have
      * a phase one lock during the contention period.
      */
     private final ReentrantLock[] locks = new ReentrantLock[LOCK_COUNT];
@@ -76,7 +76,7 @@ public class MultiLockFairBlockingQueue<E> implements BlockingQueue<E> {
      * All threads waiting for an object are stored in a linked list
      */
     final LinkedList<ExchangeCountDownLatch<E>>[] waiters;
-    
+
     /**
      * Creates a new fair blocking queue.
      */
@@ -126,7 +126,7 @@ public class MultiLockFairBlockingQueue<E> implements BlockingQueue<E> {
 
     /**
      * Will never timeout, as it invokes the {@link #offer(Object)} method.
-     * Once a lock has been acquired, the  
+     * Once a lock has been acquired, the
      * {@inheritDoc}
      */
     @Override
@@ -178,7 +178,7 @@ public class MultiLockFairBlockingQueue<E> implements BlockingQueue<E> {
         }
         return result;
     }
-    
+
     /**
      * Request an item from the queue asynchronously
      * @return - a future pending the result from the queue poll request
@@ -213,7 +213,7 @@ public class MultiLockFairBlockingQueue<E> implements BlockingQueue<E> {
         }
         return result;
     }
-    
+
     /**
      * {@inheritDoc}
      */
@@ -231,7 +231,7 @@ public class MultiLockFairBlockingQueue<E> implements BlockingQueue<E> {
         }
         return false;
     }
-    
+
     /**
      * {@inheritDoc}
      */
@@ -445,15 +445,15 @@ public class MultiLockFairBlockingQueue<E> implements BlockingQueue<E> {
         protected volatile T item = null;
         protected volatile ExchangeCountDownLatch<T> latch = null;
         protected volatile boolean canceled = false;
-        
+
         public ItemFuture(T item) {
             this.item = item;
         }
-        
+
         public ItemFuture(ExchangeCountDownLatch<T> latch) {
             this.latch = latch;
         }
-        
+
         @Override
         public boolean cancel(boolean mayInterruptIfRunning) {
             return false; //don't allow cancel for now
@@ -493,7 +493,7 @@ public class MultiLockFairBlockingQueue<E> implements BlockingQueue<E> {
         public boolean isDone() {
             return (item!=null || latch.getItem()!=null);
         }
-        
+
     }
 
     //------------------------------------------------------------------
@@ -528,7 +528,7 @@ public class MultiLockFairBlockingQueue<E> implements BlockingQueue<E> {
                 try {
                     elements = (E[]) new Object[MultiLockFairBlockingQueue.this.items[idx].size()];
                     MultiLockFairBlockingQueue.this.items[idx].toArray(elements);
-                    
+
                 } finally {
                     lock.unlock();
                 }
@@ -563,7 +563,7 @@ public class MultiLockFairBlockingQueue<E> implements BlockingQueue<E> {
                     lock.unlock();
                 }
             }
-            
+
         }
 
     }

==================================================
PoolProperties.java
index b4ddb34bc3..e02060f29e 100644
--- a/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolConfiguration.java
+++ b/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolConfiguration.java
@@ -36,20 +36,20 @@ public interface PoolConfiguration {
     public static final String PKG_PREFIX = "org.apache.tomcat.jdbc.pool.interceptor.";
 
     /**
-     * Connections that have been abandoned (timed out) wont get closed and reported up unless the number of connections in use are 
-     * above the percentage defined by abandonWhenPercentageFull. 
-     * The value should be between 0-100. 
-     * The default value is 0, which implies that connections are eligible for 
+     * Connections that have been abandoned (timed out) wont get closed and reported up unless the number of connections in use are
+     * above the percentage defined by abandonWhenPercentageFull.
+     * The value should be between 0-100.
+     * The default value is 0, which implies that connections are eligible for
      * closure as soon as removeAbandonedTimeout has been reached.
      * @param percentage a value between 0 and 100 to indicate when connections that have been abandoned/timed out are considered abandoned
      */
     public void setAbandonWhenPercentageFull(int percentage);
 
     /**
-     * Connections that have been abandoned (timed out) wont get closed and reported up unless the number of connections in use are 
-     * above the percentage defined by abandonWhenPercentageFull. 
-     * The value should be between 0-100. 
-     * The default value is 0, which implies that connections are eligible for 
+     * Connections that have been abandoned (timed out) wont get closed and reported up unless the number of connections in use are
+     * above the percentage defined by abandonWhenPercentageFull.
+     * The value should be between 0-100.
+     * The default value is 0, which implies that connections are eligible for
      * closure as soon as removeAbandonedTimeout has been reached.
      * @return percentage - a value between 0 and 100 to indicate when connections that have been abandoned/timed out are considered abandoned
      */
@@ -62,18 +62,18 @@ public interface PoolConfiguration {
     public boolean isFairQueue();
 
     /**
-     * Set to true if you wish that calls to getConnection 
-     * should be treated fairly in a true FIFO fashion. 
-     * This uses the {@link FairBlockingQueue} implementation for the list of the idle connections. 
-     * The default value is true. 
+     * Set to true if you wish that calls to getConnection
+     * should be treated fairly in a true FIFO fashion.
+     * This uses the {@link FairBlockingQueue} implementation for the list of the idle connections.
+     * The default value is true.
      * This flag is required when you want to use asynchronous connection retrieval.
      * @param fairQueue
      */
     public void setFairQueue(boolean fairQueue);
-    
+
     /**
      * Property not used. Access is always allowed.
-     * Access can be achieved by calling unwrap on the pooled connection. see {@link javax.sql.DataSource} interface 
+     * Access can be achieved by calling unwrap on the pooled connection. see {@link javax.sql.DataSource} interface
      * or call getConnection through reflection or cast the object as {@link javax.sql.PooledConnection}
      * @return true
      */
@@ -84,11 +84,11 @@ public interface PoolConfiguration {
      * @param accessToUnderlyingConnectionAllowed parameter ignored
      */
     public void setAccessToUnderlyingConnectionAllowed(boolean accessToUnderlyingConnectionAllowed);
-    
+
     /**
-     * The connection properties that will be sent to the JDBC driver when establishing new connections. 
+     * The connection properties that will be sent to the JDBC driver when establishing new connections.
      * Format of the string is [propertyName=property;] <br/>
-     * NOTE - The "user" and "password" properties will be passed explicitly, so they do not need to be included here. 
+     * NOTE - The "user" and "password" properties will be passed explicitly, so they do not need to be included here.
      * The default value is null.
      */
     public String getConnectionProperties();
@@ -96,11 +96,11 @@ public interface PoolConfiguration {
     /**
      * The properties that will be passed into {@link java.sql.Driver#connect(String, Properties)} method.
      * Username and password do not need to be stored here, they will be passed into the properties right before the connection is established.
-     * @param connectionProperties properties - Format of the string is [propertyName=property;]* 
+     * @param connectionProperties properties - Format of the string is [propertyName=property;]*
      * Example: prop1=value1;prop2=value2
      */
     public void setConnectionProperties(String connectionProperties);
-    
+
     /**
      * Returns the database properties that are passed into the {@link java.sql.Driver#connect(String, Properties)} method.
      * @return database properties that are passed into the {@link java.sql.Driver#connect(String, Properties)} method.
@@ -112,23 +112,23 @@ public interface PoolConfiguration {
      * @param dbProperties
      */
     public void setDbProperties(Properties dbProperties);
-    
+
     /**
-     * The default auto-commit state of connections created by this pool. 
+     * The default auto-commit state of connections created by this pool.
      * If not set (null), default is JDBC driver default (If set to null then the {@link java.sql.Connection#setAutoCommit(boolean)} method will not be called.)
      * @return the default auto commit setting, null is Driver default.
      */
     public Boolean isDefaultAutoCommit();
-    
+
     /**
-     * The default auto-commit state of connections created by this pool. 
+     * The default auto-commit state of connections created by this pool.
      * If not set (null), default is JDBC driver default (If set to null then the {@link java.sql.Connection#setAutoCommit(boolean)} method will not be called.)
      * @return the default auto commit setting, null is Driver default.
      */
     public Boolean getDefaultAutoCommit();
-    
+
     /**
-     * The default auto-commit state of connections created by this pool. 
+     * The default auto-commit state of connections created by this pool.
      * If not set (null), default is JDBC driver default (If set to null then the {@link java.sql.Connection#setAutoCommit(boolean)} method will not be called.)
      * @param defaultAutoCommit default auto commit setting, null is Driver default.
      */
@@ -139,13 +139,13 @@ public interface PoolConfiguration {
      * @return the default catalog, null if not set and accepting the driver default.
      */
     public String getDefaultCatalog();
-    
+
     /**
      * If non null, during connection creation the method {@link java.sql.Connection#setCatalog(String)} will be called with the set value.
      * @param defaultCatalog null if not set and accepting the driver default.
      */
     public void setDefaultCatalog(String defaultCatalog);
-    
+
     /**
      * If non null, during connection creation the method {@link java.sql.Connection#setReadOnly(boolean)} will be called with the set value.
      * @return null if not set and accepting the driver default otherwise the read only value
@@ -164,20 +164,20 @@ public interface PoolConfiguration {
      */
     public void setDefaultReadOnly(Boolean defaultReadOnly);
 
-    
+
     /**
      * Returns the default transaction isolation level. If set to {@link DataSourceFactory#UNKNOWN_TRANSACTIONISOLATION} the method
      * {@link java.sql.Connection#setTransactionIsolation(int)} will not be called during connection creation.
      * @return driver transaction isolation level, or -1 {@link DataSourceFactory#UNKNOWN_TRANSACTIONISOLATION} if not set.
      */
     public int getDefaultTransactionIsolation();
-    
+
     /**
      * If set to {@link DataSourceFactory#UNKNOWN_TRANSACTIONISOLATION} the method
-     * {@link java.sql.Connection#setTransactionIsolation(int)} will not be called during connection creation. Otherwise the method 
+     * {@link java.sql.Connection#setTransactionIsolation(int)} will not be called during connection creation. Otherwise the method
      * will be called with the isolation level set by this property.
      * @param defaultTransactionIsolation a value of {@link java.sql.Connection#TRANSACTION_NONE}, {@link java.sql.Connection#TRANSACTION_READ_COMMITTED},
-     * {@link java.sql.Connection#TRANSACTION_READ_UNCOMMITTED}, {@link java.sql.Connection#TRANSACTION_REPEATABLE_READ}, 
+     * {@link java.sql.Connection#TRANSACTION_READ_UNCOMMITTED}, {@link java.sql.Connection#TRANSACTION_REPEATABLE_READ},
      * {@link java.sql.Connection#TRANSACTION_SERIALIZABLE} or {@link DataSourceFactory#UNKNOWN_TRANSACTIONISOLATION}
      * The last value will not be set on the connection.
      */
@@ -185,43 +185,43 @@ public interface PoolConfiguration {
 
     /**
      * The fully qualified Java class name of the JDBC driver to be used. The driver has to be accessible from the same classloader as tomcat-jdbc.jar
-     * @return fully qualified JDBC driver name. 
+     * @return fully qualified JDBC driver name.
      */
     public String getDriverClassName();
-    
+
     /**
      * The fully qualified Java class name of the JDBC driver to be used. The driver has to be accessible from the same classloader as tomcat-jdbc.jar
      * @param driverClassName a fully qualified Java class name of a {@link java.sql.Driver} implementation.
      */
     public void setDriverClassName(String driverClassName);
-    
+
     /**
      * Returns the number of connections that will be established when the connection pool is started.
-     * Default value is 10 
+     * Default value is 10
      * @return number of connections to be started when pool is started
      */
     public int getInitialSize();
-    
+
     /**
      * Set the number of connections that will be established when the connection pool is started.
      * Default value is 10.
-     * If this value exceeds {@link #setMaxActive(int)} it will automatically be lowered. 
+     * If this value exceeds {@link #setMaxActive(int)} it will automatically be lowered.
      * @param initialSize the number of connections to be established.
-     * 
+     *
      */
     public void setInitialSize(int initialSize);
 
     /**
-     * boolean flag to set if stack traces should be logged for application code which abandoned a Connection. 
-     * Logging of abandoned Connections adds overhead for every Connection borrow because a stack trace has to be generated. 
+     * boolean flag to set if stack traces should be logged for application code which abandoned a Connection.
+     * Logging of abandoned Connections adds overhead for every Connection borrow because a stack trace has to be generated.
      * The default value is false.
      * @return true if the connection pool logs stack traces when connections are borrowed from the pool.
      */
     public boolean isLogAbandoned();
-    
+
     /**
-     * boolean flag to set if stack traces should be logged for application code which abandoned a Connection. 
-     * Logging of abandoned Connections adds overhead for every Connection borrow because a stack trace has to be generated. 
+     * boolean flag to set if stack traces should be logged for application code which abandoned a Connection.
+     * Logging of abandoned Connections adds overhead for every Connection borrow because a stack trace has to be generated.
      * The default value is false.
      * @param logAbandoned set to true if stack traces should be recorded when {@link DataSource#getConnection()} is called.
      */
@@ -232,79 +232,79 @@ public interface PoolConfiguration {
      * @return the maximum number of connections used by this pool
      */
     public int getMaxActive();
-    
+
     /**
      * The maximum number of active connections that can be allocated from this pool at the same time. The default value is 100
      * @param maxActive hard limit for number of managed connections by this pool
      */
     public void setMaxActive(int maxActive);
 
-    
+
     /**
      * The maximum number of connections that should be kept in the idle pool if {@link #isPoolSweeperEnabled()} returns false.
      * If the If {@link #isPoolSweeperEnabled()} returns true, then the idle pool can grow up to {@link #getMaxActive}
      * and will be shrunk according to {@link #getMinEvictableIdleTimeMillis()} setting.
-     * Default value is maxActive:100  
+     * Default value is maxActive:100
      * @return the maximum number of idle connections.
      */
     public int getMaxIdle();
-    
+
     /**
      * The maximum number of connections that should be kept in the idle pool if {@link #isPoolSweeperEnabled()} returns false.
      * If the If {@link #isPoolSweeperEnabled()} returns true, then the idle pool can grow up to {@link #getMaxActive}
      * and will be shrunk according to {@link #getMinEvictableIdleTimeMillis()} setting.
-     * Default value is maxActive:100  
+     * Default value is maxActive:100
      * @param maxIdle the maximum size of the idle pool
      */
     public void setMaxIdle(int maxIdle);
 
     /**
-     * The maximum number of milliseconds that the pool will wait (when there are no available connections and the 
-     * {@link #getMaxActive} has been reached) for a connection to be returned 
+     * The maximum number of milliseconds that the pool will wait (when there are no available connections and the
+     * {@link #getMaxActive} has been reached) for a connection to be returned
      * before throwing an exception. Default value is 30000 (30 seconds)
      * @return the number of milliseconds to wait for a connection to become available if the pool is maxed out.
      */
     public int getMaxWait();
 
     /**
-     * The maximum number of milliseconds that the pool will wait (when there are no available connections and the 
-     * {@link #getMaxActive} has been reached) for a connection to be returned 
+     * The maximum number of milliseconds that the pool will wait (when there are no available connections and the
+     * {@link #getMaxActive} has been reached) for a connection to be returned
      * before throwing an exception. Default value is 30000 (30 seconds)
      * @param maxWait the maximum number of milliseconds to wait.
      */
     public void setMaxWait(int maxWait);
 
     /**
-     * The minimum amount of time an object must sit idle in the pool before it is eligible for eviction. 
+     * The minimum amount of time an object must sit idle in the pool before it is eligible for eviction.
      * The default value is 60000 (60 seconds).
-     * @return the minimum amount of idle time in milliseconds before a connection is considered idle and eligible for eviction. 
+     * @return the minimum amount of idle time in milliseconds before a connection is considered idle and eligible for eviction.
      */
     public int getMinEvictableIdleTimeMillis();
-    
+
     /**
-     * The minimum amount of time an object must sit idle in the pool before it is eligible for eviction. 
+     * The minimum amount of time an object must sit idle in the pool before it is eligible for eviction.
      * The default value is 60000 (60 seconds).
      * @param minEvictableIdleTimeMillis the number of milliseconds a connection must be idle to be eligible for eviction.
      */
     public void setMinEvictableIdleTimeMillis(int minEvictableIdleTimeMillis);
 
     /**
-     * The minimum number of established connections that should be kept in the pool at all times. 
-     * The connection pool can shrink below this number if validation queries fail and connections get closed. 
+     * The minimum number of established connections that should be kept in the pool at all times.
+     * The connection pool can shrink below this number if validation queries fail and connections get closed.
      * Default value is derived from {@link #getInitialSize()} (also see {@link #setTestWhileIdle(boolean)}
      * The idle pool will not shrink below this value during an eviction run, hence the number of actual connections
      * can be between {@link #getMinIdle()} and somewhere between {@link #getMaxIdle()} and {@link #getMaxActive()}
      * @return the minimum number of idle or established connections
      */
     public int getMinIdle();
-    
+
     /**
-     * The minimum number of established connections that should be kept in the pool at all times. 
-     * The connection pool can shrink below this number if validation queries fail and connections get closed. 
+     * The minimum number of established connections that should be kept in the pool at all times.
+     * The connection pool can shrink below this number if validation queries fail and connections get closed.
      * Default value is derived from {@link #getInitialSize()} (also see {@link #setTestWhileIdle(boolean)}
      * The idle pool will not shrink below this value during an eviction run, hence the number of actual connections
      * can be between {@link #getMinIdle()} and somewhere between {@link #getMaxIdle()} and {@link #getMaxActive()}
-     * 
+     *
      * @param minIdle the minimum number of idle or established connections
      */
     public void setMinIdle(int minIdle);
@@ -314,9 +314,9 @@ public interface PoolConfiguration {
      * @return the name of the pool, should be unique in a JVM
      */
     public String getName();
-    
+
     /**
-     * Sets the name of the connection pool 
+     * Sets the name of the connection pool
      * @param name the name of the pool, should be unique in a runtime JVM
      */
     public void setName(String name);
@@ -326,7 +326,7 @@ public interface PoolConfiguration {
      * @return unknown value
      */
     public int getNumTestsPerEvictionRun();
-    
+
     /**
      * Property not used
      * @param numTestsPerEvictionRun parameter ignored.
@@ -338,11 +338,11 @@ public interface PoolConfiguration {
      * @return the password in string format
      */
     public String getPassword();
-    
+
     /**
      * Sets the password to establish the connection with.
      * The password will be included as a database property with the name 'password'.
-     * @param password 
+     * @param password
      * @see #getDbProperties()
      */
     public void setPassword(String password);
@@ -352,7 +352,7 @@ public interface PoolConfiguration {
      * @return name
      */
     public String getPoolName();
-    
+
     /**
      * Returns the username used to establish the connection with
      * @return the username used to establish the connection with
@@ -369,22 +369,22 @@ public interface PoolConfiguration {
 
 
     /**
-     * boolean flag to remove abandoned connections if they exceed the removeAbandonedTimout. 
-     * If set to true a connection is considered abandoned and eligible for removal if it has 
-     * been in use longer than the {@link #getRemoveAbandonedTimeout()} and the condition for 
+     * boolean flag to remove abandoned connections if they exceed the removeAbandonedTimout.
+     * If set to true a connection is considered abandoned and eligible for removal if it has
+     * been in use longer than the {@link #getRemoveAbandonedTimeout()} and the condition for
      * {@link #getAbandonWhenPercentageFull()} is met.
-     * Setting this to true can recover db connections from applications that fail to close a connection. 
+     * Setting this to true can recover db connections from applications that fail to close a connection.
      * See also {@link #isLogAbandoned()} The default value is false.
      * @return true if abandoned connections can be closed and expelled out of the pool
      */
     public boolean isRemoveAbandoned();
-    
+
     /**
-     * boolean flag to remove abandoned connections if they exceed the removeAbandonedTimout. 
-     * If set to true a connection is considered abandoned and eligible for removal if it has 
-     * been in use longer than the {@link #getRemoveAbandonedTimeout()} and the condition for 
+     * boolean flag to remove abandoned connections if they exceed the removeAbandonedTimout.
+     * If set to true a connection is considered abandoned and eligible for removal if it has
+     * been in use longer than the {@link #getRemoveAbandonedTimeout()} and the condition for
      * {@link #getAbandonWhenPercentageFull()} is met.
-     * Setting this to true can recover db connections from applications that fail to close a connection. 
+     * Setting this to true can recover db connections from applications that fail to close a connection.
      * See also {@link #isLogAbandoned()} The default value is false.
      * @param removeAbandoned set to true if abandoned connections can be closed and expelled out of the pool
      */
@@ -403,35 +403,35 @@ public interface PoolConfiguration {
      * The timer can be reset upon queries using an interceptor.
      * @see org.apache.tomcat.jdbc.pool.interceptor.ResetAbandonedTimer
      * @return the time in seconds before a used connection can be considered abandoned
-     */ 
+     */
     public int getRemoveAbandonedTimeout();
 
     /**
-     * The indication of whether objects will be validated before being borrowed from the pool. 
-     * If the object fails to validate, it will be dropped from the pool, and we will attempt to borrow another. 
-     * NOTE - for a true value to have any effect, the validationQuery parameter must be set to a non-null string. 
+     * The indication of whether objects will be validated before being borrowed from the pool.
+     * If the object fails to validate, it will be dropped from the pool, and we will attempt to borrow another.
+     * NOTE - for a true value to have any effect, the validationQuery parameter must be set to a non-null string.
      * Default value is false
      * In order to have a more efficient validation, see {@link #setValidationInterval(long)}
      * @return true if the connection is to be validated upon borrowing a connection from the pool
      * @see #getValidationInterval()
      */
     public boolean isTestOnBorrow();
-    
+
     /**
-     * The indication of whether objects will be validated before being borrowed from the pool. 
-     * If the object fails to validate, it will be dropped from the pool, and we will attempt to borrow another. 
-     * NOTE - for a true value to have any effect, the validationQuery parameter must be set to a non-null string. 
+     * The indication of whether objects will be validated before being borrowed from the pool.
+     * If the object fails to validate, it will be dropped from the pool, and we will attempt to borrow another.
+     * NOTE - for a true value to have any effect, the validationQuery parameter must be set to a non-null string.
      * Default value is false
      * In order to have a more efficient validation, see {@link #setValidationInterval(long)}
      * @param testOnBorrow set to true if validation should take place before a connection is handed out to the application
      * @see #getValidationInterval()
      */
     public void setTestOnBorrow(boolean testOnBorrow);
-    
+
     /**
-     * The indication of whether objects will be validated after being returned to the pool. 
-     * If the object fails to validate, it will be dropped from the pool. 
-     * NOTE - for a true value to have any effect, the validationQuery parameter must be set to a non-null string. 
+     * The indication of whether objects will be validated after being returned to the pool.
+     * If the object fails to validate, it will be dropped from the pool.
+     * NOTE - for a true value to have any effect, the validationQuery parameter must be set to a non-null string.
      * Default value is false
      * In order to have a more efficient validation, see {@link #setValidationInterval(long)}
      * @return true if validation should take place after a connection is returned to the pool
@@ -440,109 +440,109 @@ public interface PoolConfiguration {
     public boolean isTestOnReturn();
 
     /**
-     * The indication of whether objects will be validated after being returned to the pool. 
-     * If the object fails to validate, it will be dropped from the pool. 
-     * NOTE - for a true value to have any effect, the validationQuery parameter must be set to a non-null string. 
+     * The indication of whether objects will be validated after being returned to the pool.
+     * If the object fails to validate, it will be dropped from the pool.
+     * NOTE - for a true value to have any effect, the validationQuery parameter must be set to a non-null string.
      * Default value is false
      * In order to have a more efficient validation, see {@link #setValidationInterval(long)}
      * @param testOnReturn true if validation should take place after a connection is returned to the pool
      * @see #getValidationInterval()
      */
     public void setTestOnReturn(boolean testOnReturn);
-    
-    
+
+
     /**
      * Set to true if query validation should take place while the connection is idle.
      * @return true if validation should take place during idle checks
      * @see #setTimeBetweenEvictionRunsMillis(int)
      */
     public boolean isTestWhileIdle();
-    
+
     /**
      * Set to true if query validation should take place while the connection is idle.
      * @param testWhileIdle true if validation should take place during idle checks
      * @see #setTimeBetweenEvictionRunsMillis(int)
      */
     public void setTestWhileIdle(boolean testWhileIdle);
-    
+
     /**
-     * The number of milliseconds to sleep between runs of the idle connection validation, abandoned cleaner 
-     * and idle pool resizing. This value should not be set under 1 second. 
+     * The number of milliseconds to sleep between runs of the idle connection validation, abandoned cleaner
+     * and idle pool resizing. This value should not be set under 1 second.
      * It dictates how often we check for idle, abandoned connections, and how often we validate idle connection and resize the idle pool.
      * The default value is 5000 (5 seconds)
      * @return the sleep time in between validations in milliseconds
      */
     public int getTimeBetweenEvictionRunsMillis();
-    
+
     /**
-     * The number of milliseconds to sleep between runs of the idle connection validation, abandoned cleaner 
-     * and idle pool resizing. This value should not be set under 1 second. 
+     * The number of milliseconds to sleep between runs of the idle connection validation, abandoned cleaner
+     * and idle pool resizing. This value should not be set under 1 second.
      * It dictates how often we check for idle, abandoned connections, and how often we validate idle connection and resize the idle pool.
      * The default value is 5000 (5 seconds)
      * @param timeBetweenEvictionRunsMillis the sleep time in between validations in milliseconds
      */
     public void setTimeBetweenEvictionRunsMillis(int timeBetweenEvictionRunsMillis);
-    
+
     /**
      * The URL used to connect to the database
      * @return the configured URL for this connection pool
      * @see java.sql.Driver#connect(String, Properties)
      */
     public String getUrl();
-    
+
     /**
      * Sets the URL used to connect to the database
      * @param url the configured URL for this connection pool
      * @see java.sql.Driver#connect(String, Properties)
      */
     public void setUrl(String url);
-    
-    /**
-     * The SQL query that will be used to validate connections from this 
-     * pool before returning them to the caller or pool. 
-     * If specified, this query does not have to return any data, 
-     * it just can't throw a SQLException. 
-     * The default value is null. 
-     * Example values are SELECT 1(mysql), 
-     * select 1 from dual(oracle), 
+
+    /**
+     * The SQL query that will be used to validate connections from this
+     * pool before returning them to the caller or pool.
+     * If specified, this query does not have to return any data,
+     * it just can't throw a SQLException.
+     * The default value is null.
+     * Example values are SELECT 1(mysql),
+     * select 1 from dual(oracle),
      * SELECT 1(MS Sql Server)
      * @return the query used for validation or null if no validation is performed
      */
     public String getValidationQuery();
-    
-    /**
-     * The SQL query that will be used to validate connections from this 
-     * pool before returning them to the caller or pool. 
-     * If specified, this query does not have to return any data, 
-     * it just can't throw a SQLException. 
-     * The default value is null. 
-     * Example values are SELECT 1(mysql), 
-     * select 1 from dual(oracle), 
+
+    /**
+     * The SQL query that will be used to validate connections from this
+     * pool before returning them to the caller or pool.
+     * If specified, this query does not have to return any data,
+     * it just can't throw a SQLException.
+     * The default value is null.
+     * Example values are SELECT 1(mysql),
+     * select 1 from dual(oracle),
      * SELECT 1(MS Sql Server)
      * @param validationQuery the query used for validation or null if no validation is performed
      */
     public void setValidationQuery(String validationQuery);
-    
+
     /**
      * Return the name of the optional validator class - may be null.
-     *  
+     *
      * @return the name of the optional validator class - may be null
      */
     public String getValidatorClassName();
-    
+
     /**
      * Set the name for an optional validator class which will be used in place of test queries. If set to
      * null, standard validation will be used.
-     * 
+     *
      * @param className the name of the optional validator class
      */
     public void setValidatorClassName(String className);
-    
+
     /**
      * @return the optional validator object - may be null
      */
     public Validator getValidator();
-    
+
     /**
      * Sets the validator object
      * If this is a non null object, it will be used as a validator instead of the validationQuery
@@ -551,36 +551,36 @@ public interface PoolConfiguration {
     public void setValidator(Validator validator);
 
     /**
-     * avoid excess validation, only run validation at most at this frequency - time in milliseconds. 
-     * If a connection is due for validation, but has been validated previously 
-     * within this interval, it will not be validated again. 
+     * avoid excess validation, only run validation at most at this frequency - time in milliseconds.
+     * If a connection is due for validation, but has been validated previously
+     * within this interval, it will not be validated again.
      * The default value is 30000 (30 seconds).
      * @return the validation interval in milliseconds
      */
     public long getValidationInterval();
-    
+
     /**
-     * avoid excess validation, only run validation at most at this frequency - time in milliseconds. 
-     * If a connection is due for validation, but has been validated previously 
-     * within this interval, it will not be validated again. 
+     * avoid excess validation, only run validation at most at this frequency - time in milliseconds.
+     * If a connection is due for validation, but has been validated previously
+     * within this interval, it will not be validated again.
      * The default value is 30000 (30 seconds).
      * @param validationInterval the validation interval in milliseconds
      */
     public void setValidationInterval(long validationInterval);
-    
+
     /**
      * A custom query to be run when a connection is first created. The default value is null.
      * This query only runs once per connection, and that is when a new connection is established to the database.
-     * If this value is non null, it will replace the validation query during connection creation. 
-     * @return the init SQL used to run against the DB or null if not set 
+     * If this value is non null, it will replace the validation query during connection creation.
+     * @return the init SQL used to run against the DB or null if not set
      */
     public String getInitSQL();
-    
+
     /**
      * A custom query to be run when a connection is first created. The default value is null.
      * This query only runs once per connection, and that is when a new connection is established to the database.
-     * If this value is non null, it will replace the validation query during connection creation. 
-     * @param initSQL the init SQL used to run against the DB or null if no query should be executed 
+     * If this value is non null, it will replace the validation query during connection creation.
+     * @param initSQL the init SQL used to run against the DB or null if no query should be executed
      */
     public void setInitSQL(String initSQL);
 
@@ -598,11 +598,11 @@ public interface PoolConfiguration {
      * @param testOnConnect set to true if we should run the validation query upon connect
      */
     public void setTestOnConnect(boolean testOnConnect);
-    
+
     /**
-     * A semicolon separated list of classnames extending {@link org.apache.tomcat.jdbc.pool.JdbcInterceptor} class. 
+     * A semicolon separated list of classnames extending {@link org.apache.tomcat.jdbc.pool.JdbcInterceptor} class.
      * These interceptors will be inserted as an interceptor into the chain of operations on a java.sql.Connection object.
-     * Example interceptors are {@link org.apache.tomcat.jdbc.pool.interceptor.StatementFinalizer StatementFinalizer} to close all 
+     * Example interceptors are {@link org.apache.tomcat.jdbc.pool.interceptor.StatementFinalizer StatementFinalizer} to close all
      * used statements during the session.
      * {@link org.apache.tomcat.jdbc.pool.interceptor.ResetAbandonedTimer ResetAbandonedTimer} resets the timer upon every operation
      * on the connection or a statement.
@@ -612,11 +612,11 @@ public interface PoolConfiguration {
      * Example format: 'ConnectionState(useEquals=true,fast=yes);ResetAbandonedTimer'
      */
     public String getJdbcInterceptors();
-    
+
     /**
-     * A semicolon separated list of classnames extending {@link org.apache.tomcat.jdbc.pool.JdbcInterceptor} class. 
+     * A semicolon separated list of classnames extending {@link org.apache.tomcat.jdbc.pool.JdbcInterceptor} class.
      * These interceptors will be inserted as an interceptor into the chain of operations on a java.sql.Connection object.
-     * Example interceptors are {@link org.apache.tomcat.jdbc.pool.interceptor.StatementFinalizer StatementFinalizer} to close all 
+     * Example interceptors are {@link org.apache.tomcat.jdbc.pool.interceptor.StatementFinalizer StatementFinalizer} to close all
      * used statements during the session.
      * {@link org.apache.tomcat.jdbc.pool.interceptor.ResetAbandonedTimer ResetAbandonedTimer} resets the timer upon every operation
      * on the connection or a statement.
@@ -633,9 +633,9 @@ public interface PoolConfiguration {
      */
     public InterceptorDefinition[] getJdbcInterceptorsAsArray();
 
-    
+
     /**
-     * If set to true, the connection pool creates a {@link org.apache.tomcat.jdbc.pool.jmx.ConnectionPoolMBean} object 
+     * If set to true, the connection pool creates a {@link org.apache.tomcat.jdbc.pool.jmx.ConnectionPoolMBean} object
      * that can be registered with JMX to receive notifications and state about the pool.
      * The ConnectionPool object doesn't register itself, as there is no way to keep a static non changing ObjectName across JVM restarts.
      * @return true if the mbean object will be created upon startup.
@@ -643,7 +643,7 @@ public interface PoolConfiguration {
     public boolean isJmxEnabled();
 
     /**
-     * If set to true, the connection pool creates a {@link org.apache.tomcat.jdbc.pool.jmx.ConnectionPoolMBean} object 
+     * If set to true, the connection pool creates a {@link org.apache.tomcat.jdbc.pool.jmx.ConnectionPoolMBean} object
      * that can be registered with JMX to receive notifications and state about the pool.
      * The ConnectionPool object doesn't register itself, as there is no way to keep a static non changing ObjectName across JVM restarts.
      * @param jmxEnabled set to to if the mbean object should be created upon startup.
@@ -658,15 +658,15 @@ public interface PoolConfiguration {
         result = result && (isRemoveAbandoned() && getRemoveAbandonedTimeout()>0);
         result = result || (isTestWhileIdle() && getValidationQuery()!=null);
         return result;
-       </source> 
+       </source>
      *
      * @return true if a background thread is or will be enabled for this pool
      */
     public boolean isPoolSweeperEnabled();
 
     /**
-     * Set to true if you wish the <code>ProxyConnection</code> class to use <code>String.equals</code> instead of 
-     * <code>==</code> when comparing method names. 
+     * Set to true if you wish the <code>ProxyConnection</code> class to use <code>String.equals</code> instead of
+     * <code>==</code> when comparing method names.
      * This property does not apply to added interceptors as those are configured individually.
      * The default value is <code>false</code>.
      * @return true if pool uses {@link String#equals(Object)} instead of == when comparing method names on {@link java.sql.Connection} methods
@@ -674,8 +674,8 @@ public interface PoolConfiguration {
     public boolean isUseEquals();
 
     /**
-     * Set to true if you wish the <code>ProxyConnection</code> class to use <code>String.equals</code> instead of 
-     * <code>==</code> when comparing method names. 
+     * Set to true if you wish the <code>ProxyConnection</code> class to use <code>String.equals</code> instead of
+     * <code>==</code> when comparing method names.
      * This property does not apply to added interceptors as those are configured individually.
      * The default value is <code>false</code>.
      * @param useEquals set to true if the pool should use {@link String#equals(Object)} instead of ==
@@ -684,11 +684,11 @@ public interface PoolConfiguration {
     public void setUseEquals(boolean useEquals);
 
     /**
-     * Time in milliseconds to keep this connection alive even when used. 
-     * When a connection is returned to the pool, the pool will check to see if the 
-     * ((now - time-when-connected) > maxAge) has been reached, and if so, 
-     * it closes the connection rather than returning it to the pool. 
-     * The default value is 0, which implies that connections will be left open and no 
+     * Time in milliseconds to keep this connection alive even when used.
+     * When a connection is returned to the pool, the pool will check to see if the
+     * ((now - time-when-connected) > maxAge) has been reached, and if so,
+     * it closes the connection rather than returning it to the pool.
+     * The default value is 0, which implies that connections will be left open and no
      * age check will be done upon returning the connection to the pool.
      * This is a useful setting for database sessions that leak memory as it ensures that the session
      * will have a finite life span.
@@ -697,11 +697,11 @@ public interface PoolConfiguration {
     public long getMaxAge();
 
     /**
-     * Time in milliseconds to keep this connection alive even when used. 
-     * When a connection is returned to the pool, the pool will check to see if the 
-     * ((now - time-when-connected) > maxAge) has been reached, and if so, 
-     * it closes the connection rather than returning it to the pool. 
-     * The default value is 0, which implies that connections will be left open and no 
+     * Time in milliseconds to keep this connection alive even when used.
+     * When a connection is returned to the pool, the pool will check to see if the
+     * ((now - time-when-connected) > maxAge) has been reached, and if so,
+     * it closes the connection rather than returning it to the pool.
+     * The default value is 0, which implies that connections will be left open and no
      * age check will be done upon returning the connection to the pool.
      * This is a useful setting for database sessions that leak memory as it ensures that the session
      * will have a finite life span.
@@ -724,75 +724,75 @@ public interface PoolConfiguration {
      * @param useLock set to true if a lock should be used on connection operations
      */
     public void setUseLock(boolean useLock);
-    
+
     /**
      * Similar to {@link #setRemoveAbandonedTimeout(int)} but instead of treating the connection
-     * as abandoned, and potentially closing the connection, this simply logs the warning if 
-     * {@link #isLogAbandoned()} returns true. If this value is equal or less than 0, no suspect 
+     * as abandoned, and potentially closing the connection, this simply logs the warning if
+     * {@link #isLogAbandoned()} returns true. If this value is equal or less than 0, no suspect
      * checking will be performed. Suspect checking only takes place if the timeout value is larger than 0 and
      * the connection was not abandoned or if abandon check is disabled. If a connection is suspect a WARN message gets
-     * logged and a JMX notification gets sent once. 
-     * @param seconds - the amount of time in seconds that has to pass before a connection is marked suspect. 
+     * logged and a JMX notification gets sent once.
+     * @param seconds - the amount of time in seconds that has to pass before a connection is marked suspect.
      */
     public void setSuspectTimeout(int seconds);
-    
+
     /**
      * Returns the time in seconds to pass before a connection is marked an abanoned suspect.
-     * Any value lesser than or equal to 0 means the check is disabled. 
+     * Any value lesser than or equal to 0 means the check is disabled.
      * @return Returns the time in seconds to pass before a connection is marked an abanoned suspect.
      */
     public int getSuspectTimeout();
-    
+
     /**
      * Injects a datasource that will be used to retrieve/create connections.
      * If a data source is set, the {@link PoolConfiguration#getUrl()} and {@link PoolConfiguration#getDriverClassName()} methods are ignored
      * and not used by the pool. If the {@link PoolConfiguration#getUsername()} and {@link PoolConfiguration#getPassword()}
      * values are set, the method {@link javax.sql.DataSource#getConnection(String, String)} method will be called instead of the
      * {@link javax.sql.DataSource#getConnection()} method.
-     * If the data source implements {@link javax.sql.XADataSource} the methods 
+     * If the data source implements {@link javax.sql.XADataSource} the methods
      * {@link javax.sql.XADataSource#getXAConnection()} and {@link javax.sql.XADataSource#getXAConnection(String,String)}
-     * will be invoked.  
+     * will be invoked.
      * @param ds the {@link javax.sql.DataSource} to be used for creating connections to be pooled.
      */
     public void setDataSource(Object ds);
-    
+
     /**
      * Returns a datasource, if one exists that is being used to create connections.
      * This method will return null if the pool is using a {@link java.sql.Driver}
      * @return the {@link javax.sql.DataSource} to be used for creating connections to be pooled or null if a Driver is used.
      */
     public Object getDataSource();
-    
+
     /**
      * Configure the connection pool to use a DataSource according to {@link PoolConfiguration#setDataSource(Object)}
      * But instead of injecting the object, specify the JNDI location.
-     * After a successful JNDI look, the {@link PoolConfiguration#getDataSource()} will not return null. 
+     * After a successful JNDI look, the {@link PoolConfiguration#getDataSource()} will not return null.
      * @param jndiDS -the JNDI string @TODO specify the rules here.
      */
     public void setDataSourceJNDI(String jndiDS);
-    
+
     /**
      * Returns the JNDI string configured for data source usage.
      * @return the JNDI string or null if not set
      */
     public String getDataSourceJNDI();
-    
+
     /**
-     * Returns true if the call {@link DataSource#getConnection(String, String) getConnection(username,password)} is 
+     * Returns true if the call {@link DataSource#getConnection(String, String) getConnection(username,password)} is
      * allowed. This is used for when the pool is used by an application accessing multiple schemas.
      * There is a performance impact turning this option on.
      * @return true if {@link DataSource#getConnection(String, String) getConnection(username,password)} is honored, false if it is ignored.
      */
     public boolean isAlternateUsernameAllowed();
-    
+
     /**
-     * Set to true if the call {@link DataSource#getConnection(String, String) getConnection(username,password)} is 
+     * Set to true if the call {@link DataSource#getConnection(String, String) getConnection(username,password)} is
      * allowed and honored.. This is used for when the pool is used by an application accessing multiple schemas.
      * There is a performance impact turning this option on, even when not used due to username checks.
-     * @param alternateUsernameAllowed - set true if {@link DataSource#getConnection(String, String) getConnection(username,password)} is honored, 
+     * @param alternateUsernameAllowed - set true if {@link DataSource#getConnection(String, String) getConnection(username,password)} is honored,
      * false if it is to be ignored.
      */
     public void setAlternateUsernameAllowed(boolean alternateUsernameAllowed);
-    
+
 
 }
\ No newline at end of file

==================================================
PoolUtilities.java
index 0d7137f141..6072c3c53b 100644
--- a/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java
+++ b/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java
@@ -35,9 +35,9 @@ import org.apache.juli.logging.LogFactory;
  */
 public class PoolProperties implements PoolConfiguration {
     private static final Log log = LogFactory.getLog(PoolProperties.class);
-    
+
     public static final int DEFAULT_MAX_ACTIVE = 100;
-    
+
     protected static AtomicInteger poolCounter = new AtomicInteger(0);
     protected Properties dbProperties = new Properties();
     protected String url = null;
@@ -83,293 +83,293 @@ public class PoolProperties implements PoolConfiguration {
     protected Object dataSource = null;
     protected String dataSourceJNDI = null;
     protected boolean alternateUsernameAllowed = false;
-    
-    
-    /** 
+
+
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setAbandonWhenPercentageFull(int percentage) {
         if (percentage<0) abandonWhenPercentageFull = 0;
         else if (percentage>100) abandonWhenPercentageFull = 100;
         else abandonWhenPercentageFull = percentage;
     }
-    
-    /** 
+
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public int getAbandonWhenPercentageFull() {
         return abandonWhenPercentageFull;
     }
-    
-    /** 
+
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public boolean isFairQueue() {
         return fairQueue;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setFairQueue(boolean fairQueue) {
         this.fairQueue = fairQueue;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public boolean isAccessToUnderlyingConnectionAllowed() {
         return accessToUnderlyingConnectionAllowed;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public String getConnectionProperties() {
         return connectionProperties;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public Properties getDbProperties() {
         return dbProperties;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public Boolean isDefaultAutoCommit() {
         return defaultAutoCommit;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public String getDefaultCatalog() {
         return defaultCatalog;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public Boolean isDefaultReadOnly() {
         return defaultReadOnly;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public int getDefaultTransactionIsolation() {
         return defaultTransactionIsolation;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public String getDriverClassName() {
         return driverClassName;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public int getInitialSize() {
         return initialSize;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public boolean isLogAbandoned() {
         return logAbandoned;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public int getMaxActive() {
         return maxActive;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public int getMaxIdle() {
         return maxIdle;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public int getMaxWait() {
         return maxWait;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public int getMinEvictableIdleTimeMillis() {
         return minEvictableIdleTimeMillis;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public int getMinIdle() {
         return minIdle;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public String getName() {
         return name;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public int getNumTestsPerEvictionRun() {
         return numTestsPerEvictionRun;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public String getPassword() {
         return password;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public String getPoolName() {
         return getName();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public boolean isRemoveAbandoned() {
         return removeAbandoned;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public int getRemoveAbandonedTimeout() {
         return removeAbandonedTimeout;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public boolean isTestOnBorrow() {
         return testOnBorrow;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public boolean isTestOnReturn() {
         return testOnReturn;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public boolean isTestWhileIdle() {
         return testWhileIdle;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public int getTimeBetweenEvictionRunsMillis() {
         return timeBetweenEvictionRunsMillis;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public String getUrl() {
         return url;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public String getUsername() {
         return username;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public String getValidationQuery() {
         return validationQuery;
@@ -378,7 +378,7 @@ public class PoolProperties implements PoolConfiguration {
     /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public String getValidatorClassName() {
         return validatorClassName;
@@ -387,13 +387,13 @@ public class PoolProperties implements PoolConfiguration {
     /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public Validator getValidator() {
         return validator;
     }
-    
-    /** 
+
+    /**
      * {@inheritDoc}
      */
     @Override
@@ -407,46 +407,46 @@ public class PoolProperties implements PoolConfiguration {
     }
 
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public long getValidationInterval() {
         return validationInterval;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public String getInitSQL() {
         return initSQL;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public boolean isTestOnConnect() {
         return testOnConnect;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public String getJdbcInterceptors() {
         return jdbcInterceptors;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public InterceptorDefinition[] getJdbcInterceptorsAsArray() {
         if (interceptors == null) {
@@ -481,255 +481,255 @@ public class PoolProperties implements PoolConfiguration {
         return interceptors;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setAccessToUnderlyingConnectionAllowed(boolean accessToUnderlyingConnectionAllowed) {
         // NOOP
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setConnectionProperties(String connectionProperties) {
         this.connectionProperties = connectionProperties;
         getProperties(connectionProperties, getDbProperties());
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setDbProperties(Properties dbProperties) {
         this.dbProperties = dbProperties;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setDefaultAutoCommit(Boolean defaultAutoCommit) {
         this.defaultAutoCommit = defaultAutoCommit;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setDefaultCatalog(String defaultCatalog) {
         this.defaultCatalog = defaultCatalog;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setDefaultReadOnly(Boolean defaultReadOnly) {
         this.defaultReadOnly = defaultReadOnly;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setDefaultTransactionIsolation(int defaultTransactionIsolation) {
         this.defaultTransactionIsolation = defaultTransactionIsolation;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setDriverClassName(String driverClassName) {
         this.driverClassName = driverClassName;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setInitialSize(int initialSize) {
         this.initialSize = initialSize;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setLogAbandoned(boolean logAbandoned) {
         this.logAbandoned = logAbandoned;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setMaxActive(int maxActive) {
         this.maxActive = maxActive;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setMaxIdle(int maxIdle) {
         this.maxIdle = maxIdle;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setMaxWait(int maxWait) {
         this.maxWait = maxWait;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setMinEvictableIdleTimeMillis(int minEvictableIdleTimeMillis) {
         this.minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setMinIdle(int minIdle) {
         this.minIdle = minIdle;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setName(String name) {
         this.name = name;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
         this.numTestsPerEvictionRun = numTestsPerEvictionRun;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setPassword(String password) {
         this.password = password;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setRemoveAbandoned(boolean removeAbandoned) {
         this.removeAbandoned = removeAbandoned;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setRemoveAbandonedTimeout(int removeAbandonedTimeout) {
         this.removeAbandonedTimeout = removeAbandonedTimeout;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setTestOnBorrow(boolean testOnBorrow) {
         this.testOnBorrow = testOnBorrow;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setTestWhileIdle(boolean testWhileIdle) {
         this.testWhileIdle = testWhileIdle;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setTestOnReturn(boolean testOnReturn) {
         this.testOnReturn = testOnReturn;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setTimeBetweenEvictionRunsMillis(int
                                                  timeBetweenEvictionRunsMillis) {
         this.timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setUrl(String url) {
         this.url = url;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setUsername(String username) {
         this.username = username;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setValidationInterval(long validationInterval) {
         this.validationInterval = validationInterval;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setValidationQuery(String validationQuery) {
         this.validationQuery = validationQuery;
@@ -738,17 +738,17 @@ public class PoolProperties implements PoolConfiguration {
     /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setValidatorClassName(String className) {
         this.validatorClassName = className;
-        
+
         validator = null;
-        
+
         if (className == null) {
             return;
         }
-        
+
         try {
             Class<Validator> validatorClass = (Class<Validator>)Class.forName(className);
             validator = validatorClass.newInstance();
@@ -764,35 +764,35 @@ public class PoolProperties implements PoolConfiguration {
         }
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setInitSQL(String initSQL) {
         this.initSQL = initSQL;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setTestOnConnect(boolean testOnConnect) {
         this.testOnConnect = testOnConnect;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setJdbcInterceptors(String jdbcInterceptors) {
         this.jdbcInterceptors = jdbcInterceptors;
         this.interceptors = null;
     }
 
-    
+
     @Override
     public String toString() {
         StringBuilder buf = new StringBuilder("ConnectionPool[");
@@ -828,47 +828,47 @@ public class PoolProperties implements PoolConfiguration {
         return poolCounter.get();
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public boolean isJmxEnabled() {
         return jmxEnabled;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setJmxEnabled(boolean jmxEnabled) {
         this.jmxEnabled = jmxEnabled;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public Boolean getDefaultAutoCommit() {
         return defaultAutoCommit;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public Boolean getDefaultReadOnly() {
         return defaultReadOnly;
     }
-    
-    
+
+
     /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public int getSuspectTimeout() {
         return this.suspectTimeout;
@@ -877,23 +877,23 @@ public class PoolProperties implements PoolConfiguration {
     /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setSuspectTimeout(int seconds) {
         this.suspectTimeout = seconds;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public boolean isPoolSweeperEnabled() {
         boolean timer = getTimeBetweenEvictionRunsMillis()>0;
         boolean result = timer && (isRemoveAbandoned() && getRemoveAbandonedTimeout()>0);
-        result = result || (timer && getSuspectTimeout()>0); 
+        result = result || (timer && getSuspectTimeout()>0);
         result = result || (timer && isTestWhileIdle() && getValidationQuery()!=null);
-        result = result || (timer && getMinEvictableIdleTimeMillis()>0); 
+        result = result || (timer && getMinEvictableIdleTimeMillis()>0);
         return result;
     }
 
@@ -905,7 +905,7 @@ public class PoolProperties implements PoolConfiguration {
         public InterceptorDefinition(String className) {
             this.className = className;
         }
-        
+
         public InterceptorDefinition(Class<?> cl) {
             this(cl.getName());
             clazz = cl;
@@ -918,15 +918,15 @@ public class PoolProperties implements PoolConfiguration {
             InterceptorProperty p = new InterceptorProperty(name,value);
             addProperty(p);
         }
-        
+
         public void addProperty(InterceptorProperty p) {
             properties.put(p.getName(), p);
         }
-        
+
         public Map<String,InterceptorProperty> getProperties() {
             return properties;
         }
-        
+
         public Class<? extends JdbcInterceptor> getInterceptorClass() throws ClassNotFoundException {
             if (clazz==null) {
                 if (getClassName().indexOf(".")<0) {
@@ -943,8 +943,8 @@ public class PoolProperties implements PoolConfiguration {
             }
             return (Class<? extends JdbcInterceptor>)clazz;
         }
-    } 
-    
+    }
+
     public static class InterceptorProperty {
         String name;
         String value;
@@ -959,14 +959,14 @@ public class PoolProperties implements PoolConfiguration {
         public String getValue() {
             return value;
         }
-        
+
         public boolean getValueAsBoolean(boolean def) {
             if (value==null) return def;
             if ("true".equals(value)) return true;
             if ("false".equals(value)) return false;
             return def;
         }
-        
+
         public int getValueAsInt(int def) {
             if (value==null) return def;
             try {
@@ -976,7 +976,7 @@ public class PoolProperties implements PoolConfiguration {
                 return def;
             }
         }
-        
+
         public long getValueAsLong(long def) {
             if (value==null) return def;
             try {
@@ -994,7 +994,7 @@ public class PoolProperties implements PoolConfiguration {
                 return def;
             }
         }
-        
+
         public short getValueAsShort(short def) {
             if (value==null) return def;
             try {
@@ -1021,7 +1021,7 @@ public class PoolProperties implements PoolConfiguration {
                 return def;
             }
         }
- 
+
         public char getValueAschar(char def) {
             if (value==null) return def;
             try {
@@ -1030,12 +1030,12 @@ public class PoolProperties implements PoolConfiguration {
                 return def;
             }
         }
-        
+
         @Override
         public int hashCode() {
             return name.hashCode();
         }
-        
+
         @Override
         public boolean equals(Object o) {
             if (o==this) return true;
@@ -1047,95 +1047,95 @@ public class PoolProperties implements PoolConfiguration {
         }
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public boolean isUseEquals() {
         return useEquals;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setUseEquals(boolean useEquals) {
         this.useEquals = useEquals;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public long getMaxAge() {
         return maxAge;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setMaxAge(long maxAge) {
         this.maxAge = maxAge;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public boolean getUseLock() {
         return useLock;
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setUseLock(boolean useLock) {
         this.useLock = useLock;
     }
-    
-    
-    /** 
+
+
+    /**
      * {@inheritDoc}
      */
     @Override
     public void setDataSource(Object ds) {
         this.dataSource = ds;
     }
-    
-    /** 
+
+    /**
      * {@inheritDoc}
      */
     @Override
     public Object getDataSource() {
         return dataSource;
     }
-    
-    
-    /** 
+
+
+    /**
      * {@inheritDoc}
      */
     @Override
     public void setDataSourceJNDI(String jndiDS) {
         this.dataSourceJNDI = jndiDS;
     }
-    
-    /** 
+
+    /**
      * {@inheritDoc}
      */
     @Override
     public String getDataSourceJNDI() {
         return this.dataSourceJNDI;
     }
-    
-        
+
+
     public static Properties getProperties(String propText, Properties props) {
         if (props==null) props = new Properties();
         if (propText != null) {
@@ -1147,21 +1147,21 @@ public class PoolProperties implements PoolConfiguration {
         }
         return props;
     }
-    
-    /** 
+
+    /**
      * {@inheritDoc}
      */
     @Override
     public boolean isAlternateUsernameAllowed() {
         return alternateUsernameAllowed;
     }
-    
-    /** 
+
+    /**
      * {@inheritDoc}
      */
     @Override
     public void setAlternateUsernameAllowed(boolean alternateUsernameAllowed) {
         this.alternateUsernameAllowed = alternateUsernameAllowed;
     }
-    
+
 }

==================================================
PooledConnection.java
index 0b2a5ed961..ac25cd1bf9 100644
--- a/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolUtilities.java
+++ b/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolUtilities.java
@@ -19,22 +19,22 @@ package org.apache.tomcat.jdbc.pool;
 import java.util.Properties;
 
 /**
- * 
+ *
  * @author fhanik
  *
  */
 public class PoolUtilities {
-    
+
     public static final String PROP_USER = "user";
-    
+
     public static final String PROP_PASSWORD = "password";
-    
+
     public static Properties clone(Properties p) {
         Properties c = new Properties();
         c.putAll(p);
         return c;
     }
-    
+
     public static Properties cloneWithoutPassword(Properties p) {
         Properties result = clone(p);
         result.remove(PROP_PASSWORD);

==================================================
ProxyConnection.java
index d8f3503003..a3305a2e0e 100644
--- a/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PooledConnection.java
+++ b/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PooledConnection.java
@@ -42,9 +42,9 @@ public class PooledConnection {
     private static final Log log = LogFactory.getLog(PooledConnection.class);
 
     public static final String PROP_USER = PoolUtilities.PROP_USER;
-    
+
     public static final String PROP_PASSWORD = PoolUtilities.PROP_PASSWORD;
-    
+
     /**
      * Validate when connection is borrowed flag
      */
@@ -69,7 +69,7 @@ public class PooledConnection {
      * The underlying database connection
      */
     private volatile java.sql.Connection connection;
-    
+
     /**
      * If using a XAConnection underneath.
      */
@@ -102,7 +102,7 @@ public class PooledConnection {
      * The parent
      */
     protected ConnectionPool parent;
-    
+
     private HashMap<Object, Object> attributes = new HashMap<Object, Object>();
 
     /**
@@ -111,13 +111,13 @@ public class PooledConnection {
      * the connection
      */
     private volatile JdbcInterceptor handler = null;
-    
+
     private AtomicBoolean released = new AtomicBoolean(false);
-    
+
     private volatile boolean suspect = false;
-    
+
     private java.sql.Driver driver = null;
-    
+
     /**
      * Constructor
      * @param prop - pool properties
@@ -130,32 +130,32 @@ public class PooledConnection {
 
     public boolean checkUser(String username, String password) {
         if (!getPoolProperties().isAlternateUsernameAllowed()) return true;
-        
+
         if (username==null) username = poolProperties.getUsername();
         if (password==null) password = poolProperties.getPassword();
-        
+
         String storedUsr = (String)getAttributes().get(PROP_USER);
         String storedPwd = (String)getAttributes().get(PROP_PASSWORD);
-        
+
         boolean result = (username==null && storedUsr==null);
         result = (result || (username!=null && username.equals(storedUsr)));
-                
+
         result = result && ((password==null && storedPwd==null) || (password!=null && password.equals(storedPwd)));
-        
+
         if (username==null)  getAttributes().remove(PROP_USER); else getAttributes().put(PROP_USER, username);
         if (password==null)  getAttributes().remove(PROP_PASSWORD); else getAttributes().put(PROP_PASSWORD, password);
-        
+
         return result;
     }
-    
+
     /**
      * Connects the underlying connection to the database.
      * @throws SQLException if the method {@link #release()} has been called.
      * @throws SQLException if driver instantiation fails
      * @throws SQLException if a call to {@link java.sql.Driver#connect(String, java.util.Properties)} fails.
-     * @throws SQLException if default properties are configured and a call to 
-     * {@link java.sql.Connection#setAutoCommit(boolean)}, {@link java.sql.Connection#setCatalog(String)}, 
-     * {@link java.sql.Connection#setTransactionIsolation(int)} or {@link java.sql.Connection#setReadOnly(boolean)} fails.  
+     * @throws SQLException if default properties are configured and a call to
+     * {@link java.sql.Connection#setAutoCommit(boolean)}, {@link java.sql.Connection#setCatalog(String)},
+     * {@link java.sql.Connection#setTransactionIsolation(int)} or {@link java.sql.Connection#setReadOnly(boolean)} fails.
      */
     public void connect() throws SQLException {
         if (released.get()) throw new SQLException("A connection once released, can't be reestablished.");
@@ -169,24 +169,24 @@ public class PooledConnection {
         if (poolProperties.getDataSource()==null && poolProperties.getDataSourceJNDI()!=null) {
             //TODO lookup JNDI name
         }
-        
+
         if (poolProperties.getDataSource()!=null) {
             connectUsingDataSource();
         } else {
             connectUsingDriver();
         }
-        
+
         //set up the default state, unless we expect the interceptor to do it
         if (poolProperties.getJdbcInterceptors()==null || poolProperties.getJdbcInterceptors().indexOf(ConnectionState.class.getName())<0) {
             if (poolProperties.getDefaultTransactionIsolation()!=DataSourceFactory.UNKNOWN_TRANSACTIONISOLATION) connection.setTransactionIsolation(poolProperties.getDefaultTransactionIsolation());
             if (poolProperties.getDefaultReadOnly()!=null) connection.setReadOnly(poolProperties.getDefaultReadOnly().booleanValue());
             if (poolProperties.getDefaultAutoCommit()!=null) connection.setAutoCommit(poolProperties.getDefaultAutoCommit().booleanValue());
             if (poolProperties.getDefaultCatalog()!=null) connection.setCatalog(poolProperties.getDefaultCatalog());
-        }        
+        }
         this.discarded = false;
         this.lastConnected = System.currentTimeMillis();
     }
-    
+
     protected void connectUsingDataSource() throws SQLException {
         String usr = null;
         String pwd = null;
@@ -230,7 +230,7 @@ public class PooledConnection {
         }
     }
     protected void connectUsingDriver() throws SQLException {
-        
+
         try {
             if (driver==null)
                 driver = (java.sql.Driver) Class.forName(poolProperties.getDriverClassName(),
@@ -285,9 +285,9 @@ public class PooledConnection {
             throw new SQLException("Driver:"+driver+" returned null for URL:"+driverURL);
         }
     }
-    
+
     /**
-     * 
+     *
      * @return true if connect() was called successfully and disconnect has not yet been called
      */
     public boolean isInitialized() {
@@ -295,7 +295,7 @@ public class PooledConnection {
     }
 
     /**
-     * Issues a call to {@link #disconnect(boolean)} with the argument false followed by a call to 
+     * Issues a call to {@link #disconnect(boolean)} with the argument false followed by a call to
      * {@link #connect()}
      * @throws SQLException if the call to {@link #connect()} fails.
      */
@@ -335,7 +335,7 @@ public class PooledConnection {
 
 
 //============================================================================
-//             
+//
 //============================================================================
 
     /**
@@ -351,7 +351,7 @@ public class PooledConnection {
     }
 
     /**
-     * Returns true if the connection pool is configured 
+     * Returns true if the connection pool is configured
      * to do validation for a certain action.
      * @param action
      * @return
@@ -385,23 +385,23 @@ public class PooledConnection {
     }
 
     /**
-     * Validates a connection. 
-     * @param validateAction the action used. One of {@link #VALIDATE_BORROW}, {@link #VALIDATE_IDLE}, 
+     * Validates a connection.
+     * @param validateAction the action used. One of {@link #VALIDATE_BORROW}, {@link #VALIDATE_IDLE},
      * {@link #VALIDATE_INIT} or {@link #VALIDATE_RETURN}
-     * @param sql the SQL to be used during validation. If the {@link PoolConfiguration#setInitSQL(String)} has been called with a non null 
+     * @param sql the SQL to be used during validation. If the {@link PoolConfiguration#setInitSQL(String)} has been called with a non null
      * value and the action is {@link #VALIDATE_INIT} the init SQL will be used for validation.
-     *  
-     * @return true if the connection was validated successfully. It returns true even if validation was not performed, such as when 
-     * {@link PoolConfiguration#setValidationInterval(long)} has been called with a positive value. 
+     *
+     * @return true if the connection was validated successfully. It returns true even if validation was not performed, such as when
+     * {@link PoolConfiguration#setValidationInterval(long)} has been called with a positive value.
      * <p>
-     * false if the validation failed. The caller should close the connection if false is returned since a session could have been left in 
+     * false if the validation failed. The caller should close the connection if false is returned since a session could have been left in
      * an unknown state during initialization.
      */
     public boolean validate(int validateAction,String sql) {
         if (this.isDiscarded()) {
             return false;
         }
-        
+
         if (!doValidate(validateAction)) {
             //no validation required, no init sql and props not set
             return true;
@@ -424,9 +424,9 @@ public class PooledConnection {
                 return false;
             }
         }
-        
+
         String query = sql;
-        
+
         if (validateAction == VALIDATE_INIT && poolProperties.getInitSQL() != null) {
             query = poolProperties.getInitSQL();
         }
@@ -434,7 +434,7 @@ public class PooledConnection {
         if (query == null) {
             query = poolProperties.getValidationQuery();
         }
-        
+
         Statement stmt = null;
         try {
             stmt = connection.createStatement();
@@ -530,7 +530,7 @@ public class PooledConnection {
     /**
      * Set the timestamp the connection was last validated.
      * This flag is used to keep track when we are using a {@link PoolConfiguration#setValidationInterval(long) validation-interval}.
-     * @param lastValidated a timestamp as defined by {@link System#currentTimeMillis()} 
+     * @param lastValidated a timestamp as defined by {@link System#currentTimeMillis()}
      */
     public void setLastValidated(long lastValidated) {
         this.lastValidated = lastValidated;
@@ -546,9 +546,9 @@ public class PooledConnection {
     }
 
     /**
-     * Return the timestamps of last pool action. Timestamps are typically set when connections 
+     * Return the timestamps of last pool action. Timestamps are typically set when connections
      * are borrowed from the pool. It is used to keep track of {@link PoolConfiguration#setRemoveAbandonedTimeout(int) abandon-timeouts}.
-     * This timestamp can also be reset by the {@link org.apache.tomcat.jdbc.pool.interceptor.ResetAbandonedTimer#invoke(Object, java.lang.reflect.Method, Object[])}   
+     * This timestamp can also be reset by the {@link org.apache.tomcat.jdbc.pool.interceptor.ResetAbandonedTimer#invoke(Object, java.lang.reflect.Method, Object[])}
      * @return the timestamp of the last pool action as defined by {@link System#currentTimeMillis()}
      */
     public long getTimestamp() {
@@ -557,7 +557,7 @@ public class PooledConnection {
 
     /**
      * Returns the discarded flag.
-     * @return the discarded flag. If the value is true, 
+     * @return the discarded flag. If the value is true,
      * either {@link #disconnect(boolean)} has been called or it will be called when the connection is returned to the pool.
      */
     public boolean isDiscarded() {
@@ -565,7 +565,7 @@ public class PooledConnection {
     }
 
     /**
-     * Returns the timestamp of the last successful validation query execution. 
+     * Returns the timestamp of the last successful validation query execution.
      * @return the timestamp of the last successful validation query execution as defined by {@link System#currentTimeMillis()}
      */
     public long getLastValidated() {
@@ -581,9 +581,9 @@ public class PooledConnection {
     }
 
     /**
-     * Locks the connection only if either {@link PoolConfiguration#isPoolSweeperEnabled()} or 
+     * Locks the connection only if either {@link PoolConfiguration#isPoolSweeperEnabled()} or
      * {@link PoolConfiguration#getUseLock()} return true. The per connection lock ensures thread safety is
-     * multiple threads are performing operations on the connection. 
+     * multiple threads are performing operations on the connection.
      * Otherwise this is a noop for performance
      */
     public void lock() {
@@ -612,7 +612,7 @@ public class PooledConnection {
     public java.sql.Connection getConnection() {
         return this.connection;
     }
-    
+
     /**
      * Returns the underlying XA connection
      * @return the underlying XA connection as it was returned from the Datasource
@@ -620,8 +620,8 @@ public class PooledConnection {
     public javax.sql.XAConnection getXAConnection() {
         return this.xaConnection;
     }
-    
-    
+
+
     /**
      * Returns the timestamp of when the connection was last connected to the database.
      * ie, a successful call to {@link java.sql.Driver#connect(String, java.util.Properties)}.
@@ -645,16 +645,16 @@ public class PooledConnection {
             while (interceptor!=null) {
                 interceptor.reset(null, null);
                 interceptor = interceptor.getNext();
-            }//while 
+            }//while
         }//end if
         this.handler = handler;
     }
-    
+
     @Override
     public String toString() {
         return "PooledConnection["+(connection!=null?connection.toString():"null")+"]";
     }
-    
+
     /**
      * Returns true if this connection has been released and wont be reused.
      * @return true if the method {@link #release()} has been called
@@ -662,7 +662,7 @@ public class PooledConnection {
     public boolean isReleased() {
         return released.get();
     }
-    
+
     public HashMap<Object,Object> getAttributes() {
         return attributes;
     }

==================================================
TrapException.java
index 617a26228b..02d9f99fec 100644
--- a/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ProxyConnection.java
+++ b/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ProxyConnection.java
@@ -22,7 +22,7 @@ import java.sql.SQLException;
 
 import javax.sql.XAConnection;
 /**
- * A ProxyConnection object is the bottom most interceptor that wraps an object of type 
+ * A ProxyConnection object is the bottom most interceptor that wraps an object of type
  * {@link PooledConnection}. The ProxyConnection intercepts three methods:
  * <ul>
  *   <li>{@link java.sql.Connection#close()} - returns the connection to the pool. May be called multiple times.</li>
@@ -124,7 +124,7 @@ public class ProxyConnection extends JdbcInterceptor {
         try {
             PooledConnection poolc = connection;
             if (poolc!=null) {
-                return method.invoke(poolc.getConnection(),args);    
+                return method.invoke(poolc.getConnection(),args);
             } else {
                 throw new SQLException("Connection has already been closed.");
             }
@@ -137,7 +137,7 @@ public class ProxyConnection extends JdbcInterceptor {
             }
         }
     }
-    
+
     public boolean isClosed() {
         return connection==null || connection.isDiscarded();
     }
@@ -149,7 +149,7 @@ public class ProxyConnection extends JdbcInterceptor {
     public ConnectionPool getParentPool() {
         return pool;
     }
-    
+
     @Override
     public String toString() {
         return "ProxyConnection["+(connection!=null?connection.toString():"null")+"]";

==================================================
Validator.java
index 0fa3920e36..ff1e8be0d9 100644
--- a/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/TrapException.java
+++ b/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/TrapException.java
@@ -31,7 +31,7 @@ import java.sql.SQLException;
  */
 public class TrapException extends JdbcInterceptor {
 
-    
+
     public TrapException() {
     }
 
@@ -43,7 +43,7 @@ public class TrapException extends JdbcInterceptor {
             Throwable exception = t;
             if (t instanceof InvocationTargetException) {
                 exception = t.getCause()!=null?t.getCause():t;
-            } 
+            }
             Class<?> exceptionClass = exception.getClass();
             if (!isDeclaredException(method, exceptionClass)) {
                 if (isDeclaredException(method,SQLException.class)) {
@@ -58,16 +58,16 @@ public class TrapException extends JdbcInterceptor {
             }
             throw exception;
         }
-        
+
     }
-    
+
     public boolean isDeclaredException(Method m, Class<?> clazz) {
         for (Class<?> cl : m.getExceptionTypes()) {
             if (cl.equals(clazz) || cl.isAssignableFrom(clazz)) return true;
         }
         return false;
     }
-    
+
     /**
      * no-op for this interceptor. no state is stored.
      */
@@ -75,5 +75,5 @@ public class TrapException extends JdbcInterceptor {
     public void reset(ConnectionPool parent, PooledConnection con) {
         // NOOP
     }
-    
+
 }

==================================================
AbstractCreateStatementInterceptor.java
index 4f286ef13f..dd7a77877d 100644
--- a/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/Validator.java
+++ b/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/Validator.java
@@ -20,13 +20,13 @@ import java.sql.Connection;
 
 /**
  * Interface to be implemented by custom validator classes.
- * 
+ *
  * @author mpassell
  */
 public interface Validator {
     /**
      * Validate a connection and return a boolean to indicate if it's valid.
-     * 
+     *
      * @param connection the Connection object to test
      * @param validateAction the action used. One of {@link PooledConnection#VALIDATE_BORROW},
      *   {@link PooledConnection#VALIDATE_IDLE}, {@link PooledConnection#VALIDATE_INIT} or

==================================================
AbstractQueryReport.java
index 19a13ed73b..60fc7515da 100644
--- a/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/AbstractCreateStatementInterceptor.java
+++ b/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/AbstractCreateStatementInterceptor.java
@@ -39,7 +39,7 @@ public abstract class  AbstractCreateStatementInterceptor extends JdbcIntercepto
 
     protected static final String[] STATEMENT_TYPES = {CREATE_STATEMENT, PREPARE_STATEMENT, PREPARE_CALL};
     protected static final int    STATEMENT_TYPE_COUNT = STATEMENT_TYPES.length;
-    
+
     protected static final String EXECUTE        = "execute";
     protected static final String EXECUTE_QUERY  = "executeQuery";
     protected static final String EXECUTE_UPDATE = "executeUpdate";
@@ -50,7 +50,7 @@ public abstract class  AbstractCreateStatementInterceptor extends JdbcIntercepto
     public  AbstractCreateStatementInterceptor() {
         super();
     }
-    
+
     /**
      * {@inheritDoc}
      */
@@ -72,7 +72,7 @@ public abstract class  AbstractCreateStatementInterceptor extends JdbcIntercepto
             }
         }
     }
-    
+
     /**
      * This method will be invoked after a successful statement creation. This method can choose to return a wrapper
      * around the statement or return the statement itself.
@@ -85,15 +85,15 @@ public abstract class  AbstractCreateStatementInterceptor extends JdbcIntercepto
      * @return a {@link java.sql.Statement} object
      */
     public abstract Object createStatement(Object proxy, Method method, Object[] args, Object statement, long time);
-    
+
     /**
-     * Method invoked when the operation {@link java.sql.Connection#close()} is invoked. 
+     * Method invoked when the operation {@link java.sql.Connection#close()} is invoked.
      */
     public abstract void closeInvoked();
 
     /**
      * Returns true if the method that is being invoked matches one of the statement types.
-     * 
+     *
      * @param method the method being invoked on the proxy
      * @param process boolean result used for recursion
      * @return returns true if the method name matched
@@ -104,7 +104,7 @@ public abstract class  AbstractCreateStatementInterceptor extends JdbcIntercepto
 
     /**
      * Returns true if the method that is being invoked matches one of the execute types.
-     * 
+     *
      * @param method the method being invoked on the proxy
      * @param process boolean result used for recursion
      * @return returns true if the method name matched
@@ -127,7 +127,7 @@ public abstract class  AbstractCreateStatementInterceptor extends JdbcIntercepto
         }
         return process;
     }
-    
+
     /**
      * no-op for this interceptor. no state is stored.
      */

==================================================
ConnectionState.java
index 42264c4109..74ae4e80dc 100644
--- a/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/AbstractQueryReport.java
+++ b/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/AbstractQueryReport.java
@@ -43,25 +43,25 @@ public abstract class AbstractQueryReport extends AbstractCreateStatementInterce
      * The threshold in milliseconds. If the query is faster than this, we don't measure it
      */
     protected long threshold = 1000; //don't report queries less than this
-    
+
     /**
-     * the constructors that are used to create statement proxies 
+     * the constructors that are used to create statement proxies
      */
     protected static final Constructor<?>[] constructors =
         new Constructor[AbstractCreateStatementInterceptor.STATEMENT_TYPE_COUNT];
 
-    
+
     public AbstractQueryReport() {
         super();
     }
-    
+
     /**
      * Invoked when prepareStatement has been called and completed.
      * @param sql - the string used to prepare the statement with
      * @param time - the time it took to invoke prepare
      */
     protected abstract void prepareStatement(String sql, long time);
-    
+
     /**
      * Invoked when prepareCall has been called and completed.
      * @param query - the string used to prepare the statement with
@@ -76,7 +76,7 @@ public abstract class AbstractQueryReport extends AbstractCreateStatementInterce
      * @param name the name of the method used to execute {@link AbstractCreateStatementInterceptor#isExecute(Method, boolean)}
      * @param start the time the query execution started
      * @param t the exception that happened
-     * @return - the SQL that was executed or the string &quot;batch&quot; if it was a batch execution 
+     * @return - the SQL that was executed or the string &quot;batch&quot; if it was a batch execution
      */
     protected String reportFailedQuery(String query, Object[] args, final String name, long start, Throwable t) {
         //extract the query string
@@ -95,7 +95,7 @@ public abstract class AbstractQueryReport extends AbstractCreateStatementInterce
      * @param name the name of the method used to execute {@link AbstractCreateStatementInterceptor#isExecute(Method, boolean)}
      * @param start the time the query execution started
      * @param delta the time the execution took
-     * @return - the SQL that was executed or the string &quot;batch&quot; if it was a batch execution 
+     * @return - the SQL that was executed or the string &quot;batch&quot; if it was a batch execution
      */
     protected String reportQuery(String query, Object[] args, final String name, long start, long delta) {
         //extract the query string
@@ -114,7 +114,7 @@ public abstract class AbstractQueryReport extends AbstractCreateStatementInterce
      * @param name the name of the method used to execute {@link AbstractCreateStatementInterceptor#isExecute(Method, boolean)}
      * @param start the time the query execution started
      * @param delta the time the execution took
-     * @return - the SQL that was executed or the string &quot;batch&quot; if it was a batch execution 
+     * @return - the SQL that was executed or the string &quot;batch&quot; if it was a batch execution
      */
     protected String reportSlowQuery(String query, Object[] args, final String name, long start, long delta) {
         //extract the query string
@@ -125,7 +125,7 @@ public abstract class AbstractQueryReport extends AbstractCreateStatementInterce
         }
         return sql;
     }
-    
+
     /**
      * returns the query measure threshold.
      * This value is in milliseconds. If the query is faster than this threshold than it wont be accounted for
@@ -211,7 +211,7 @@ public abstract class AbstractQueryReport extends AbstractCreateStatementInterce
             this.delegate = parent;
             this.query = query;
         }
-        
+
         @Override
         public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
             //get the name of the method for comparison
@@ -219,7 +219,7 @@ public abstract class AbstractQueryReport extends AbstractCreateStatementInterce
             //was close invoked?
             boolean close = compare(JdbcInterceptor.CLOSE_VAL,name);
             //allow close to be called multiple times
-            if (close && closed) return null; 
+            if (close && closed) return null;
             //are we calling isClosed?
             if (compare(JdbcInterceptor.ISCLOSED_VAL,name)) return Boolean.valueOf(closed);
             //if we are calling anything else, bail out
@@ -262,6 +262,6 @@ public abstract class AbstractQueryReport extends AbstractCreateStatementInterce
             }
             return result;
         }
-    }    
+    }
 
 }
\ No newline at end of file

==================================================
ResetAbandonedTimer.java
index 6da8bd5e7d..decb0edfbe 100644
--- a/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/ConnectionState.java
+++ b/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/ConnectionState.java
@@ -30,11 +30,11 @@ import org.apache.tomcat.jdbc.pool.PooledConnection;
 /**
  * Interceptor that keep track of connection state to avoid roundtrips to the database.
  * The {@link org.apache.tomcat.jdbc.pool.ConnectionPool} is optimized to do as little work as possible.
- * The pool itself doesn't remember settings like {@link java.sql.Connection#setAutoCommit(boolean)}, 
+ * The pool itself doesn't remember settings like {@link java.sql.Connection#setAutoCommit(boolean)},
  * {@link java.sql.Connection#setReadOnly(boolean)}, {@link java.sql.Connection#setCatalog(String)} or
- * {@link java.sql.Connection#setTransactionIsolation(int)}. It relies on the application to remember how and when 
+ * {@link java.sql.Connection#setTransactionIsolation(int)}. It relies on the application to remember how and when
  * these settings have been applied.
- * In the cases where the application code doesn't know or want to keep track of the state, this interceptor helps cache the 
+ * In the cases where the application code doesn't know or want to keep track of the state, this interceptor helps cache the
  * state, and it also avoids roundtrips to the database asking for it.
  * @author fhanik
  *
@@ -42,7 +42,7 @@ import org.apache.tomcat.jdbc.pool.PooledConnection;
 
 public class ConnectionState extends JdbcInterceptor  {
     private static final Log log = LogFactory.getLog(ConnectionState.class);
-    
+
     protected final String[] readState = {"getAutoCommit","getTransactionIsolation","isReadOnly","getCatalog"};
     protected final String[] writeState = {"setAutoCommit","setTransactionIsolation","setReadOnly","setCatalog"};
 
@@ -50,8 +50,8 @@ public class ConnectionState extends JdbcInterceptor  {
     protected Integer transactionIsolation = null;
     protected Boolean readOnly = null;
     protected String catalog = null;
-    
-    
+
+
     @Override
     public void reset(ConnectionPool parent, PooledConnection con) {
         if (parent==null || con==null) {
@@ -107,7 +107,7 @@ public class ConnectionState extends JdbcInterceptor  {
                 log.error("Unable to reset default catalog state to connection.",x);
             }
         }
-        
+
     }
 
     @Override

==================================================
SlowQueryReport.java
index 328d6be837..0384d63e81 100644
--- a/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/ResetAbandonedTimer.java
+++ b/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/ResetAbandonedTimer.java
@@ -24,7 +24,7 @@ import org.apache.tomcat.jdbc.pool.PooledConnection;
 import org.apache.tomcat.jdbc.pool.ProxyConnection;
 
 /**
- * Class that resets the abandoned timer on any activity on the 
+ * Class that resets the abandoned timer on any activity on the
  * Connection or any successful query executions.
  * This interceptor is useful for when you have a {@link org.apache.tomcat.jdbc.pool.PoolConfiguration#setRemoveAbandonedTimeout(int)}
  * that is fairly low, and you want to reset the abandoned time each time any operation on the connection is performed
@@ -37,7 +37,7 @@ public class ResetAbandonedTimer extends AbstractQueryReport {
     public ResetAbandonedTimer() {
         // TODO Auto-generated constructor stub
     }
-    
+
     public boolean resetTimer() {
         boolean result = false;
         JdbcInterceptor interceptor = this.getNext();

==================================================
SlowQueryReportJmx.java
index 317a7a3d05..e8c3b22d69 100644
--- a/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/SlowQueryReport.java
+++ b/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/SlowQueryReport.java
@@ -44,7 +44,7 @@ public class SlowQueryReport extends AbstractQueryReport  {
     /**
      * we will be keeping track of query stats on a per pool basis
      */
-    protected static ConcurrentHashMap<String,ConcurrentHashMap<String,QueryStats>> perPoolStats = 
+    protected static ConcurrentHashMap<String,ConcurrentHashMap<String,QueryStats>> perPoolStats =
         new ConcurrentHashMap<String,ConcurrentHashMap<String,QueryStats>>();
     /**
      * the queries that are used for this interceptor.
@@ -54,16 +54,16 @@ public class SlowQueryReport extends AbstractQueryReport  {
      * Maximum number of queries we will be storing
      */
     protected int  maxQueries= 1000; //don't store more than this amount of queries
-    
+
     /**
      * Returns the query stats for a given pool
      * @param poolname - the name of the pool we want to retrieve stats for
-     * @return a hash map containing statistics for 0 to maxQueries 
+     * @return a hash map containing statistics for 0 to maxQueries
      */
     public static ConcurrentHashMap<String,QueryStats> getPoolStats(String poolname) {
         return perPoolStats.get(poolname);
     }
-    
+
     /**
      * Creates a slow query report interceptor
      */
@@ -106,19 +106,19 @@ public class SlowQueryReport extends AbstractQueryReport  {
     public void closeInvoked() {
         queries = null;
     }
-    
+
     @Override
     public void prepareStatement(String sql, long time) {
         QueryStats qs = getQueryStats(sql);
         qs.prepare(time, System.currentTimeMillis());
     }
-    
+
     @Override
     public void prepareCall(String sql, long time) {
         QueryStats qs = getQueryStats(sql);
         qs.prepare(time, System.currentTimeMillis());
     }
-    
+
     /**
      * {@inheritDoc}
      */
@@ -138,7 +138,7 @@ public class SlowQueryReport extends AbstractQueryReport  {
             }
         }
     }
-    
+
     /**
      * {@inheritDoc}
      */
@@ -147,7 +147,7 @@ public class SlowQueryReport extends AbstractQueryReport  {
         perPoolStats.remove(pool.getName());
         super.poolClosed(pool);
     }
-    
+
     protected QueryStats getQueryStats(String sql) {
         ConcurrentHashMap<String,QueryStats> queries = SlowQueryReport.this.queries;
         if (queries==null) return null;
@@ -165,7 +165,7 @@ public class SlowQueryReport extends AbstractQueryReport  {
         }
         return qs;
     }
-    
+
     /**
      * TODO - implement a better algorithm
      * @param queries
@@ -176,14 +176,14 @@ public class SlowQueryReport extends AbstractQueryReport  {
             String sql = it.next();
             it.remove();
             if (log.isDebugEnabled()) log.debug("Removing slow query, capacity reached:"+sql);
-        } 
+        }
     }
 
 
     @Override
     public void reset(ConnectionPool parent, PooledConnection con) {
         super.reset(parent, con);
-        if (parent!=null) 
+        if (parent!=null)
             queries = SlowQueryReport.perPoolStats.get(parent.getName());
     }
 
@@ -205,7 +205,7 @@ public class SlowQueryReport extends AbstractQueryReport  {
 
 
     /**
-     * 
+     *
      * @author fhanik
      *
      */
@@ -223,7 +223,7 @@ public class SlowQueryReport extends AbstractQueryReport  {
             "prepareTime",
             "lastInvocation"
         };
-        
+
         static final  String[] FIELD_DESCRIPTIONS = new String[] {
             "The SQL query",
             "The number of query invocations, a call to executeXXX",
@@ -237,8 +237,8 @@ public class SlowQueryReport extends AbstractQueryReport  {
             "The total number of milliseconds spent preparing this query",
             "The date and time of the last invocation"
         };
-        
-        static final OpenType[] FIELD_TYPES = new OpenType[] { 
+
+        static final OpenType[] FIELD_TYPES = new OpenType[] {
             SimpleType.STRING,
             SimpleType.INTEGER,
             SimpleType.LONG,
@@ -249,7 +249,7 @@ public class SlowQueryReport extends AbstractQueryReport  {
             SimpleType.LONG,
             SimpleType.INTEGER,
             SimpleType.LONG,
-            SimpleType.LONG 
+            SimpleType.LONG
         };
 
         private final String query;
@@ -263,19 +263,19 @@ public class SlowQueryReport extends AbstractQueryReport  {
         private volatile int prepareCount;
         private volatile long prepareTime;
         private volatile long lastInvocation = 0;
-        
+
         public static String[] getFieldNames() {
             return FIELD_NAMES;
         }
-        
+
         public static String[] getFieldDescriptions() {
             return FIELD_DESCRIPTIONS;
         }
-        
+
         public static OpenType[] getFieldTypes() {
             return FIELD_TYPES;
         }
-        
+
         @Override
         public String toString() {
             StringBuilder buf = new StringBuilder("QueryStats[query:");
@@ -303,7 +303,7 @@ public class SlowQueryReport extends AbstractQueryReport  {
             buf.append("]");
             return buf.toString();
         }
-        
+
         public CompositeDataSupport getCompositeData(final CompositeType type) throws OpenDataException{
             Object[] values = new Object[] {
                     query,
@@ -320,17 +320,17 @@ public class SlowQueryReport extends AbstractQueryReport  {
             };
             return new CompositeDataSupport(type,FIELD_NAMES,values);
         }
-        
+
         public QueryStats(String query) {
             this.query = query;
         }
-        
+
         public void prepare(long invocationTime, long now) {
             prepareCount++;
             prepareTime+=invocationTime;
-            
+
         }
-        
+
         public void add(long invocationTime, long now) {
             //not thread safe, but don't sacrifice performance for this kind of stuff
             maxInvocationTime = Math.max(invocationTime, maxInvocationTime);
@@ -345,13 +345,13 @@ public class SlowQueryReport extends AbstractQueryReport  {
             totalInvocationTime+=invocationTime;
             lastInvocation = now;
         }
-        
+
         public void failure(long invocationTime, long now) {
             add(invocationTime,now);
             failures++;
-            
+
         }
-        
+
         public String getQuery() {
             return query;
         }
@@ -384,20 +384,20 @@ public class SlowQueryReport extends AbstractQueryReport  {
         public int hashCode() {
             return query.hashCode();
         }
-        
+
         @Override
         public boolean equals(Object other) {
             if (other instanceof QueryStats) {
                 QueryStats qs = (QueryStats)other;
                 return qs.query.equals(this.query);
-            } 
+            }
             return false;
         }
-        
+
         public boolean isOlderThan(QueryStats other) {
             return this.lastInvocation < other.lastInvocation;
         }
     }
-    
-    
+
+
 }

==================================================
StatementCache.java
index 02f47fd42d..aaeb1f6ac9 100644
--- a/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/SlowQueryReportJmx.java
+++ b/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/SlowQueryReportJmx.java
@@ -49,7 +49,7 @@ import org.apache.tomcat.jdbc.pool.ConnectionPool;
 import org.apache.tomcat.jdbc.pool.PooledConnection;
 import org.apache.tomcat.jdbc.pool.PoolProperties.InterceptorProperty;
 /**
- * Publishes data to JMX and provides notifications 
+ * Publishes data to JMX and provides notifications
  * when failures happen.
  * @author fhanik
  *
@@ -58,15 +58,15 @@ public class SlowQueryReportJmx extends SlowQueryReport implements NotificationE
     public static final String SLOW_QUERY_NOTIFICATION = "SLOW QUERY";
     public static final String FAILED_QUERY_NOTIFICATION = "FAILED QUERY";
 
-    protected static CompositeType SLOW_QUERY_TYPE; 
-        
+    protected static CompositeType SLOW_QUERY_TYPE;
+
     private static final Log log = LogFactory.getLog(SlowQueryReportJmx.class);
-    
-    
-    protected static ConcurrentHashMap<String,SlowQueryReportJmxMBean> mbeans = 
-        new ConcurrentHashMap<String,SlowQueryReportJmxMBean>(); 
-    
-    
+
+
+    protected static ConcurrentHashMap<String,SlowQueryReportJmxMBean> mbeans =
+        new ConcurrentHashMap<String,SlowQueryReportJmxMBean>();
+
+
     //==============================JMX STUFF========================
     protected volatile NotificationBroadcasterSupport notifier = new NotificationBroadcasterSupport();
 
@@ -75,7 +75,7 @@ public class SlowQueryReportJmx extends SlowQueryReport implements NotificationE
         notifier.addNotificationListener(listener, filter, handback);
     }
 
-    
+
     @Override
     public MBeanNotificationInfo[] getNotificationInfo() {
         return notifier.getNotificationInfo();
@@ -84,26 +84,26 @@ public class SlowQueryReportJmx extends SlowQueryReport implements NotificationE
     @Override
     public void removeNotificationListener(NotificationListener listener) throws ListenerNotFoundException {
         notifier.removeNotificationListener(listener);
-        
+
     }
 
     @Override
     public void removeNotificationListener(NotificationListener listener, NotificationFilter filter, Object handback) throws ListenerNotFoundException {
         notifier.removeNotificationListener(listener, filter, handback);
-        
+
     }
 
 
-    //==============================JMX STUFF========================    
-    
+    //==============================JMX STUFF========================
+
     protected String poolName = null;
-    
+
     protected static AtomicLong notifySequence = new AtomicLong(0);
-    
+
     protected boolean notifyPool = true;
-    
+
     protected ConnectionPool pool = null;
-    
+
     protected static CompositeType getCompositeType() {
         if (SLOW_QUERY_TYPE==null) {
             try {
@@ -119,7 +119,7 @@ public class SlowQueryReportJmx extends SlowQueryReport implements NotificationE
         }
         return SLOW_QUERY_TYPE;
     }
-    
+
     @Override
     public void reset(ConnectionPool parent, PooledConnection con) {
         // TODO Auto-generated method stub
@@ -156,20 +156,20 @@ public class SlowQueryReportJmx extends SlowQueryReport implements NotificationE
     protected void notifyJmx(String query, String type) {
         try {
             long sequence = notifySequence.incrementAndGet();
-            
+
             if (isNotifyPool()) {
                 if (this.pool!=null && this.pool.getJmxPool()!=null) {
                     this.pool.getJmxPool().notify(type, query);
                 }
             } else {
                 if (notifier!=null) {
-                    Notification notification = 
-                        new Notification(type, 
-                                         this, 
-                                         sequence, 
+                    Notification notification =
+                        new Notification(type,
+                                         this,
+                                         sequence,
                                          System.currentTimeMillis(),
                                          query);
-                    
+
                     notifier.sendNotification(notification);
                 }
             }
@@ -223,7 +223,7 @@ public class SlowQueryReportJmx extends SlowQueryReport implements NotificationE
             while (it.hasNext()) it.remove();
         }
     }
-    
+
     /**
      * JMX operation - returns all the queries we have collected.
      * @return - the slow query report as composite data.
@@ -247,7 +247,7 @@ public class SlowQueryReportJmx extends SlowQueryReport implements NotificationE
         }
         return result;
     }
-    
+
     protected void deregisterJmx() {
         try {
             if (mbeans.remove(poolName)!=null) {
@@ -263,7 +263,7 @@ public class SlowQueryReportJmx extends SlowQueryReport implements NotificationE
         } catch (RuntimeOperationsException e) {
             log.warn("Jmx deregistration failed.",e);
         }
-        
+
     }
 
 
@@ -271,12 +271,12 @@ public class SlowQueryReportJmx extends SlowQueryReport implements NotificationE
         ObjectName oname = new ObjectName(ConnectionPool.POOL_JMX_TYPE_PREFIX+clazz.getName()+",name=" + poolName);
         return oname;
     }
-    
+
     protected void registerJmx() {
         try {
             //only if we notify the pool itself
             if (isNotifyPool()) {
-                
+
             } else if (getCompositeType()!=null) {
                 ObjectName oname = getObjectName(getClass(),poolName);
                 if (mbeans.putIfAbsent(poolName, this)==null) {
@@ -297,7 +297,7 @@ public class SlowQueryReportJmx extends SlowQueryReport implements NotificationE
             log.error("Jmx registration failed, no JMX data will be exposed for the query stats.",e);
         }
     }
-    
+
     @Override
     public void setProperties(Map<String, InterceptorProperty> properties) {
         super.setProperties(properties);

==================================================
StatementDecoratorInterceptor.java
index 533211ce79..ec713f9365 100644
--- a/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/StatementCache.java
+++ b/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/StatementCache.java
@@ -28,11 +28,11 @@ import org.apache.tomcat.jdbc.pool.PooledConnection;
 import org.apache.tomcat.jdbc.pool.PoolProperties.InterceptorProperty;
 
 public class StatementCache extends StatementDecoratorInterceptor {
-    protected static final String[] ALL_TYPES = new String[] {PREPARE_STATEMENT,PREPARE_CALL}; 
-    protected static final String[] CALLABLE_TYPE = new String[] {PREPARE_CALL}; 
-    protected static final String[] PREPARED_TYPE = new String[] {PREPARE_STATEMENT}; 
+    protected static final String[] ALL_TYPES = new String[] {PREPARE_STATEMENT,PREPARE_CALL};
+    protected static final String[] CALLABLE_TYPE = new String[] {PREPARE_CALL};
+    protected static final String[] PREPARED_TYPE = new String[] {PREPARE_STATEMENT};
     protected static final String[] NO_TYPE = new String[] {};
-    
+
     protected static final String STATEMENT_CACHE_ATTR = StatementCache.class.getName() + ".cache";
 
     /*begin properties for the statement cache*/
@@ -41,8 +41,8 @@ public class StatementCache extends StatementDecoratorInterceptor {
     private int maxCacheSize = 50;
     private PooledConnection pcon;
     private String[] types;
-    
-    
+
+
     public boolean isCachePrepared() {
         return cachePrepared;
     }
@@ -81,14 +81,14 @@ public class StatementCache extends StatementDecoratorInterceptor {
         } else {
             this.types = NO_TYPE;
         }
-    
+
     }
     /*end properties for the statement cache*/
-    
+
     /*begin the cache size*/
-    private static ConcurrentHashMap<ConnectionPool,AtomicInteger> cacheSizeMap = 
+    private static ConcurrentHashMap<ConnectionPool,AtomicInteger> cacheSizeMap =
         new ConcurrentHashMap<ConnectionPool,AtomicInteger>();
-    
+
     private AtomicInteger cacheSize;
 
     @Override
@@ -96,14 +96,14 @@ public class StatementCache extends StatementDecoratorInterceptor {
         cacheSizeMap.putIfAbsent(pool, new AtomicInteger(0));
         super.poolStarted(pool);
     }
-    
+
     @Override
     public void poolClosed(ConnectionPool pool) {
         cacheSizeMap.remove(pool);
         super.poolClosed(pool);
     }
     /*end the cache size*/
-    
+
     /*begin the actual statement cache*/
     @Override
     public void reset(ConnectionPool parent, PooledConnection con) {
@@ -120,30 +120,30 @@ public class StatementCache extends StatementDecoratorInterceptor {
             }
         }
     }
-    
+
     @Override
     public void disconnected(ConnectionPool parent, PooledConnection con, boolean finalizing) {
-        ConcurrentHashMap<String,CachedStatement> statements = 
+        ConcurrentHashMap<String,CachedStatement> statements =
             (ConcurrentHashMap<String,CachedStatement>)con.getAttributes().get(STATEMENT_CACHE_ATTR);
-        
+
         if (statements!=null) {
             for (Map.Entry<String, CachedStatement> p : statements.entrySet()) {
                 closeStatement(p.getValue());
             }
             statements.clear();
         }
-        
+
         super.disconnected(parent, con, finalizing);
     }
-    
+
     public void closeStatement(CachedStatement st) {
         if (st==null) return;
         st.forceClose();
     }
-    
+
     @Override
-    protected Object createDecorator(Object proxy, Method method, Object[] args, 
-                                     Object statement, Constructor<?> constructor, String sql) 
+    protected Object createDecorator(Object proxy, Method method, Object[] args,
+                                     Object statement, Constructor<?> constructor, String sql)
     throws InstantiationException, IllegalAccessException, InvocationTargetException {
         boolean process = process(this.types, method, false);
         if (process) {
@@ -175,15 +175,15 @@ public class StatementCache extends StatementDecoratorInterceptor {
             return super.invoke(proxy,method,args);
         }
     }
-    
+
     public CachedStatement isCached(String sql) {
-        ConcurrentHashMap<String,CachedStatement> cache = 
+        ConcurrentHashMap<String,CachedStatement> cache =
             (ConcurrentHashMap<String,CachedStatement>)pcon.getAttributes().get(STATEMENT_CACHE_ATTR);
         return cache.get(sql);
     }
-    
+
     public boolean cacheStatement(CachedStatement proxy) {
-        ConcurrentHashMap<String,CachedStatement> cache = 
+        ConcurrentHashMap<String,CachedStatement> cache =
             (ConcurrentHashMap<String,CachedStatement>)pcon.getAttributes().get(STATEMENT_CACHE_ATTR);
         if (proxy.getSql()==null) {
             return false;
@@ -202,7 +202,7 @@ public class StatementCache extends StatementDecoratorInterceptor {
     }
 
     public boolean removeStatement(CachedStatement proxy) {
-        ConcurrentHashMap<String,CachedStatement> cache = 
+        ConcurrentHashMap<String,CachedStatement> cache =
             (ConcurrentHashMap<String,CachedStatement>)pcon.getAttributes().get(STATEMENT_CACHE_ATTR);
         if (cache.remove(proxy.getSql()) != null) {
             cacheSize.decrementAndGet();
@@ -213,13 +213,13 @@ public class StatementCache extends StatementDecoratorInterceptor {
     }
     /*end the actual statement cache*/
 
-    
+
     protected class CachedStatement extends StatementDecoratorInterceptor.StatementProxy<Statement> {
         boolean cached = false;
         public CachedStatement(Statement parent, String sql) {
             super(parent, sql);
         }
-        
+
         @Override
         public void closeInvoked() {
             //should we cache it
@@ -240,22 +240,22 @@ public class StatementCache extends StatementDecoratorInterceptor {
                 } catch (Exception x) {
                     removeStatement(proxy);
                 }
-            } 
+            }
             closed = true;
             delegate = null;
             if (shouldClose) {
                 super.closeInvoked();
             }
-           
+
         }
-        
+
         public void forceClose() {
             removeStatement(this);
             super.closeInvoked();
         }
-        
+
     }
-    
+
 }
 
 

==================================================
StatementFinalizer.java
index 39fc6dbca9..e75aa06b87 100644
--- a/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/StatementDecoratorInterceptor.java
+++ b/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/StatementDecoratorInterceptor.java
@@ -5,17 +5,17 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
- 
- 
+
+
 package org.apache.tomcat.jdbc.pool.interceptor;
 
 import java.lang.reflect.Constructor;
@@ -61,7 +61,7 @@ public class StatementDecoratorInterceptor extends AbstractCreateStatementInterc
 
     /**
      * Creates a constructor for a proxy class, if one doesn't already exist
-     * 
+     *
      * @param idx
      *            - the index of the constructor
      * @param clazz
@@ -119,8 +119,8 @@ public class StatementDecoratorInterceptor extends AbstractCreateStatementInterc
         return statement;
     }
 
-    protected Object createDecorator(Object proxy, Method method, Object[] args, 
-                                     Object statement, Constructor<?> constructor, String sql) 
+    protected Object createDecorator(Object proxy, Method method, Object[] args,
+                                     Object statement, Constructor<?> constructor, String sql)
     throws InstantiationException, IllegalAccessException, InvocationTargetException {
         Object result = null;
         StatementProxy<Statement> statementProxy =
@@ -142,12 +142,12 @@ public class StatementDecoratorInterceptor extends AbstractCreateStatementInterc
 
     /**
      * Class to measure query execute time
-     * 
+     *
      * @author fhanik
-     * 
+     *
      */
     protected class StatementProxy<T extends java.sql.Statement> implements InvocationHandler {
-        
+
         protected boolean closed = false;
         protected T delegate;
         private Object actualProxy;
@@ -162,13 +162,13 @@ public class StatementDecoratorInterceptor extends AbstractCreateStatementInterc
         public T getDelegate() {
             return this.delegate;
         }
-        
+
         public String getSql() {
             return sql;
         }
 
         public void setConnection(Object proxy) {
-            this.connection = proxy;            
+            this.connection = proxy;
         }
         public Object getConnection() {
             return this.connection;
@@ -180,8 +180,8 @@ public class StatementDecoratorInterceptor extends AbstractCreateStatementInterc
         public Object getActualProxy() {
             return this.actualProxy;
         }
-        
-        
+
+
         public Constructor getConstructor() {
             return constructor;
         }
@@ -198,7 +198,7 @@ public class StatementDecoratorInterceptor extends AbstractCreateStatementInterc
             closed = true;
             delegate = null;
         }
-        
+
         @Override
         public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
             if (compare(TOSTRING_VAL,method)) {
@@ -244,7 +244,7 @@ public class StatementDecoratorInterceptor extends AbstractCreateStatementInterc
             }
             return result;
         }
-        
+
         @Override
         public String toString() {
             StringBuffer buf = new StringBuffer(StatementProxy.class.getName());

==================================================
ConnectionPool.java
index e312d053b6..846b41104c 100644
--- a/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/mbeans-descriptors.xml
+++ b/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/mbeans-descriptors.xml
@@ -17,7 +17,7 @@
 -->
 <mbeans-descriptors>
 
-  <mbean description="Reports " domain="tomcat.jdbc" group="jdbc-pool" name="SlowQueryReportJmx" 
+  <mbean description="Reports " domain="tomcat.jdbc" group="jdbc-pool" name="SlowQueryReportJmx"
          type="org.apache.tomcat.jdbc.pool.interceptor.SlowQueryReportJmx">
 
     <attribute description="The name of the connection pool this Jmx bean is representing" name="poolName" type="java.lang.String" writeable="false"/>
@@ -28,7 +28,7 @@
     <notification description="Notification sent out by the slow query report when a query exceeds the threshhold" name="slow-query">
       <notification-type>Slow query</notification-type>
     </notification>
-    
+
     <notification description="Notification sent out by the slow query report when a query fails execution" name="failed-query">
       <notification-type>Failed query execution</notification-type>
     </notification>

==================================================
ConnectionPoolMBean.java
index 6614822a41..1672aac1f3 100644
--- a/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java
+++ b/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java
@@ -47,11 +47,11 @@ public class ConnectionPool extends NotificationBroadcasterSupport implements Co
      * sequence for JMX notifications
      */
     protected AtomicInteger sequence = new AtomicInteger(0);
-    
+
     /**
      * Listeners that are local and interested in our notifications, no need for JMX
      */
-    protected ConcurrentLinkedQueue<NotificationListener> listeners = new ConcurrentLinkedQueue<NotificationListener>(); 
+    protected ConcurrentLinkedQueue<NotificationListener> listeners = new ConcurrentLinkedQueue<NotificationListener>();
 
     public ConnectionPool(org.apache.tomcat.jdbc.pool.ConnectionPool pool) {
         super();
@@ -61,11 +61,11 @@ public class ConnectionPool extends NotificationBroadcasterSupport implements Co
     public org.apache.tomcat.jdbc.pool.ConnectionPool getPool() {
         return pool;
     }
-    
+
     public PoolConfiguration getPoolProperties() {
         return pool.getPoolProperties();
     }
-    
+
     //=================================================================
     //       NOTIFICATION INFO
     //=================================================================
@@ -77,23 +77,23 @@ public class ConnectionPool extends NotificationBroadcasterSupport implements Co
     public static final String SUSPECT_ABANDONED_NOTIFICATION = "SUSPECT CONNETION ABANDONED";
 
     @Override
-    public MBeanNotificationInfo[] getNotificationInfo() { 
+    public MBeanNotificationInfo[] getNotificationInfo() {
         MBeanNotificationInfo[] pres = super.getNotificationInfo();
         MBeanNotificationInfo[] loc = getDefaultNotificationInfo();
         MBeanNotificationInfo[] aug = new MBeanNotificationInfo[pres.length + loc.length];
         if (pres.length>0) System.arraycopy(pres, 0, aug, 0, pres.length);
-        if (loc.length >0) System.arraycopy(loc, 0, aug, pres.length, loc.length);    
-        return aug; 
-    } 
-    
+        if (loc.length >0) System.arraycopy(loc, 0, aug, pres.length, loc.length);
+        return aug;
+    }
+
     public static MBeanNotificationInfo[] getDefaultNotificationInfo() {
-        String[] types = new String[] {NOTIFY_INIT, NOTIFY_CONNECT, NOTIFY_ABANDON, SLOW_QUERY_NOTIFICATION, FAILED_QUERY_NOTIFICATION, SUSPECT_ABANDONED_NOTIFICATION}; 
-        String name = Notification.class.getName(); 
-        String description = "A connection pool error condition was met."; 
-        MBeanNotificationInfo info = new MBeanNotificationInfo(types, name, description); 
+        String[] types = new String[] {NOTIFY_INIT, NOTIFY_CONNECT, NOTIFY_ABANDON, SLOW_QUERY_NOTIFICATION, FAILED_QUERY_NOTIFICATION, SUSPECT_ABANDONED_NOTIFICATION};
+        String name = Notification.class.getName();
+        String description = "A connection pool error condition was met.";
+        MBeanNotificationInfo info = new MBeanNotificationInfo(types, name, description);
         return new MBeanNotificationInfo[] {info};
     }
-    
+
     /**
      * Return true if the notification was sent successfully, false otherwise.
      * @param type
@@ -119,17 +119,17 @@ public class ConnectionPool extends NotificationBroadcasterSupport implements Co
             }
             return false;
         }
-        
+
     }
-    
+
     public void addListener(NotificationListener list) {
         listeners.add(list);
     }
-    
+
     public boolean removeListener(NotificationListener list) {
         return listeners.remove(list);
     }
-    
+
     //=================================================================
     //       POOL STATS
     //=================================================================
@@ -148,17 +148,17 @@ public class ConnectionPool extends NotificationBroadcasterSupport implements Co
     public int getActive() {
         return pool.getActive();
     }
-    
+
     @Override
     public int getNumIdle() {
         return getIdle();
     }
-    
+
     @Override
     public int getNumActive() {
         return getActive();
     }
-    
+
     @Override
     public int getWaitCount() {
         return pool.getWaitCount();
@@ -186,7 +186,7 @@ public class ConnectionPool extends NotificationBroadcasterSupport implements Co
     //=================================================================
     //=========================================================
     //  PROPERTIES / CONFIGURATION
-    //=========================================================    
+    //=========================================================
 
 
     @Override
@@ -254,11 +254,11 @@ public class ConnectionPool extends NotificationBroadcasterSupport implements Co
     public int getMinIdle() {
         return getPoolProperties().getMinIdle();
     }
-    
+
     @Override
     public long getMaxAge() {
         return getPoolProperties().getMaxAge();
-    }    
+    }
 
     @Override
     public String getName() {
@@ -312,7 +312,7 @@ public class ConnectionPool extends NotificationBroadcasterSupport implements Co
     /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public String getValidatorClassName() {
         return getPoolProperties().getValidatorClassName();
@@ -321,7 +321,7 @@ public class ConnectionPool extends NotificationBroadcasterSupport implements Co
     /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public Validator getValidator() {
         return getPoolProperties().getValidator();
@@ -452,12 +452,12 @@ public class ConnectionPool extends NotificationBroadcasterSupport implements Co
     public String getPoolName() {
         return getPoolProperties().getName();
     }
-    
+
 
     @Override
     public void setConnectionProperties(String connectionProperties) {
         getPoolProperties().setConnectionProperties(connectionProperties);
-        
+
     }
 
     @Override
@@ -479,192 +479,192 @@ public class ConnectionPool extends NotificationBroadcasterSupport implements Co
     public void setDriverClassName(String driverClassName) {
         getPoolProperties().setDriverClassName(driverClassName);
     }
-    
-    
+
+
     @Override
     public void setFairQueue(boolean fairQueue) {
         getPoolProperties().setFairQueue(fairQueue);
     }
 
-    
+
     @Override
     public void setInitialSize(int initialSize) {
         // TODO Auto-generated method stub
-        
+
     }
 
-    
+
     @Override
     public void setInitSQL(String initSQL) {
         // TODO Auto-generated method stub
-        
+
     }
 
-    
+
     @Override
     public void setJdbcInterceptors(String jdbcInterceptors) {
         // TODO Auto-generated method stub
-        
+
     }
 
-    
+
     @Override
     public void setJmxEnabled(boolean jmxEnabled) {
         // TODO Auto-generated method stub
-        
+
     }
 
-    
+
     @Override
     public void setLogAbandoned(boolean logAbandoned) {
         // TODO Auto-generated method stub
-        
+
     }
 
-    
+
     @Override
     public void setMaxActive(int maxActive) {
         // TODO Auto-generated method stub
-        
+
     }
 
-     
+
     @Override
     public void setMaxIdle(int maxIdle) {
         // TODO Auto-generated method stub
-        
+
     }
 
-    
+
     @Override
     public void setMaxWait(int maxWait) {
         // TODO Auto-generated method stub
-        
+
     }
 
-    
+
     @Override
     public void setMinEvictableIdleTimeMillis(int minEvictableIdleTimeMillis) {
         // TODO Auto-generated method stub
-        
+
     }
 
-    
+
     @Override
     public void setMinIdle(int minIdle) {
         // TODO Auto-generated method stub
-        
+
     }
 
-    
+
     @Override
     public void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
         // TODO Auto-generated method stub
-        
+
     }
 
-    
+
     @Override
     public void setPassword(String password) {
         // TODO Auto-generated method stub
-        
+
     }
 
-    
+
     @Override
     public void setRemoveAbandoned(boolean removeAbandoned) {
         // TODO Auto-generated method stub
-        
+
     }
 
-    
+
     @Override
     public void setRemoveAbandonedTimeout(int removeAbandonedTimeout) {
         // TODO Auto-generated method stub
-        
+
     }
 
-    
+
     @Override
     public void setTestOnBorrow(boolean testOnBorrow) {
         // TODO Auto-generated method stub
-        
+
     }
 
-    
+
     @Override
     public void setTestOnConnect(boolean testOnConnect) {
         // TODO Auto-generated method stub
-        
+
     }
 
-    
+
     @Override
     public void setTestOnReturn(boolean testOnReturn) {
         // TODO Auto-generated method stub
-        
+
     }
 
-    
+
     @Override
     public void setTestWhileIdle(boolean testWhileIdle) {
         // TODO Auto-generated method stub
-        
+
     }
 
-    
+
     @Override
     public void setTimeBetweenEvictionRunsMillis(int timeBetweenEvictionRunsMillis) {
         // TODO Auto-generated method stub
-        
+
     }
 
-    
+
     @Override
     public void setUrl(String url) {
         // TODO Auto-generated method stub
-        
+
     }
 
-    
+
     @Override
     public void setUseEquals(boolean useEquals) {
         // TODO Auto-generated method stub
-        
+
     }
 
-    
+
     @Override
     public void setUseLock(boolean useLock) {
         // TODO Auto-generated method stub
-        
+
     }
 
-    
+
     @Override
     public void setUsername(String username) {
         // TODO Auto-generated method stub
-        
+
     }
 
-    
+
     @Override
     public void setValidationInterval(long validationInterval) {
         // TODO Auto-generated method stub
-        
+
     }
 
-    
+
     @Override
     public void setValidationQuery(String validationQuery) {
         // TODO Auto-generated method stub
-        
+
     }
-    
+
     /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setValidatorClassName(String className) {
         getPoolProperties().setValidatorClassName(className);
@@ -673,22 +673,22 @@ public class ConnectionPool extends NotificationBroadcasterSupport implements Co
     /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public int getSuspectTimeout() {
-        return getPoolProperties().getSuspectTimeout(); 
+        return getPoolProperties().getSuspectTimeout();
     }
 
     /**
      * {@inheritDoc}
      */
-    
+
     @Override
     public void setSuspectTimeout(int seconds) {
         //no op
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
     @Override
@@ -696,7 +696,7 @@ public class ConnectionPool extends NotificationBroadcasterSupport implements Co
         getPoolProperties().setDataSource(ds);
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
     @Override
@@ -705,7 +705,7 @@ public class ConnectionPool extends NotificationBroadcasterSupport implements Co
     }
 
 
-    /** 
+    /**
      * {@inheritDoc}
      */
     @Override
@@ -713,23 +713,23 @@ public class ConnectionPool extends NotificationBroadcasterSupport implements Co
         //noop
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
     @Override
     public String getDataSourceJNDI() {
         return getPoolProperties().getDataSourceJNDI();
     }
-    
-    /** 
+
+    /**
      * {@inheritDoc}
      */
     @Override
     public boolean isAlternateUsernameAllowed() {
         return getPoolProperties().isAlternateUsernameAllowed();
     }
-    
-    /** 
+
+    /**
      * {@inheritDoc}
      */
     @Override
@@ -737,14 +737,14 @@ public class ConnectionPool extends NotificationBroadcasterSupport implements Co
         //noop
     }
 
-    /** 
+    /**
      * {@inheritDoc}
      */
     @Override
     public void setValidator(Validator validator) {
         //noop
     }
-    
-    
+
+
 
 }

==================================================
TestInterceptor.java
index 897782bd99..7a204ba6a4 100644
--- a/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/mbeans-descriptors.xml
+++ b/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/mbeans-descriptors.xml
@@ -25,7 +25,7 @@
            description="Fully qualified class name of the managed object"
                   type="java.lang.String"
              writeable="false"/>
-             
+
     <attribute    name="size"
            description="The number of established connections in the pool, idle and in use"
                   type="java.lang.Integer"
@@ -45,7 +45,7 @@
            description="The number of established connections in the pool that are in use"
                   type="java.lang.Integer"
              writeable="false"/>
-    
+
     <attribute    name="numActive"
            description="Same as the active attribute"
                   type="java.lang.Integer"
@@ -108,12 +108,12 @@
            description="The max number of idle connections"
                   type="java.lang.Integer"
              writeable="false"/>
-    
+
     <attribute    name="minIdle"
            description="The minimum number of open connections"
                   type="java.lang.Integer"
              writeable="false"/>
-    
+
     <attribute    name="maxWait"
            description="The time to wait in milliseconds before a SQLException is thrown when a connection is requested"
                   type="java.lang.Integer"
@@ -190,12 +190,12 @@
            description="The name of the connection pool, will be used in the ObjectName of the actual pool"
                   type="java.lang.String"
              writeable="false"/>
-    
+
     <attribute    name="password"
            description="For security purposes,this doesn't return anything"
                   type="java.lang.String"
              writeable="false"/>
-    
+
     <attribute    name="username"
            description="The username used to open connections"
                   type="java.lang.String"
@@ -222,19 +222,19 @@
                   type="java.lang.String"
              writeable="false"/>
 
-    <operation    name="checkIdle" 
-                  description="forces a check of idle connections" 
-                  impact="ACTION" 
+    <operation    name="checkIdle"
+                  description="forces a check of idle connections"
+                  impact="ACTION"
                   returnType="void" />
-                  
-    <operation    name="checkAbandoned" 
-                  description="forces a check of abandoned connections" 
-                  impact="ACTION" 
+
+    <operation    name="checkAbandoned"
+                  description="forces a check of abandoned connections"
+                  impact="ACTION"
                   returnType="void" />
-    
-    <operation    name="testIdle" 
-                  description="forces a validation of abandoned connections" 
-                  impact="ACTION" 
+
+    <operation    name="testIdle"
+                  description="forces a validation of abandoned connections"
+                  impact="ACTION"
                   returnType="void" />
   </mbean>
 

==================================================
AbandonPercentageTest.java
index 739347c8c2..fe2ca270ec 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/pool/interceptor/TestInterceptor.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/pool/interceptor/TestInterceptor.java
@@ -46,7 +46,7 @@ public class TestInterceptor extends JdbcInterceptor {
     @Override
     public void reset(ConnectionPool parent, PooledConnection con) {
         // TODO Auto-generated method stub
-        
+
     }
 
     @Override

==================================================
AlternateUsernameTest.java
index 2e1f620fdd..f213fe5e47 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/AbandonPercentageTest.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/AbandonPercentageTest.java
@@ -25,7 +25,7 @@ public class AbandonPercentageTest extends DefaultTestCase {
     public AbandonPercentageTest(String name) {
         super(name);
     }
-    
+
     public void testDefaultAbandon() throws Exception {
         this.init();
         this.datasource.setMaxActive(100);
@@ -41,7 +41,7 @@ public class AbandonPercentageTest extends DefaultTestCase {
         assertEquals("Number of connections active/busy should be 0",0,datasource.getPool().getActive());
         con.close();
     }
-    
+
     public void testMaxedOutAbandon() throws Exception {
         int size = 100;
         this.init();

==================================================
Async0IdleTestBug50477.java
index c6915b7137..3ff50316dd 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/AlternateUsernameTest.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/AlternateUsernameTest.java
@@ -40,7 +40,7 @@ public class AlternateUsernameTest extends DefaultTestCase {
     public void testUsernameCompare() throws Exception {
         testUsername(true);
     }
-    
+
     private void testUsername(boolean allowUsernameChange) throws Exception {
         long start = System.currentTimeMillis();
         int withoutuser =10;
@@ -51,7 +51,7 @@ public class AlternateUsernameTest extends DefaultTestCase {
         this.datasource.setUrl("jdbc:tomcat:test");
         this.datasource.setAlternateUsernameAllowed(allowUsernameChange);
         this.datasource.getConnection().close();
-        
+
         TestRunner[] runners = new TestRunner[withuser+withoutuser];
         for (int i=0; i<withuser; i++) {
             TestRunner with = new TestRunner("foo","bar",datasource.getPoolProperties().getUsername(),datasource.getPoolProperties().getPassword());
@@ -78,34 +78,34 @@ public class AlternateUsernameTest extends DefaultTestCase {
         System.out.println("Nr of iterations:"+total+" over "+(stop-start)+ " ms.");
 
     }
-    
+
     public void testUsernameCompareAgain() throws Exception {
         testUsernameCompare();
     }
-    
+
     public void testUsernameCompareNotAllowed() throws Exception {
         testUsername(false);
     }
-    
+
     public static class TestResult {
         public int iterations;
         public int failures;
         public String lastMessage;
     }
-    
+
     public class TestRunner implements Callable<TestResult> {
         String username;
         String password;
         volatile boolean done = false;
         TestResult result = null;
         boolean useuser = true;
-        
+
         public TestRunner(String user, String pass, String guser, String gpass) {
             username = user==null?guser : user;
             password = pass==null?gpass : pass;
             useuser = user!=null;
         }
-        
+
         @Override
         public TestResult call() {
             TestResult test = new TestResult();
@@ -113,13 +113,13 @@ public class AlternateUsernameTest extends DefaultTestCase {
             for (int i=0; (!done) && (i<iterations); i++) {
                 test.iterations = i+1;
                 try {
-                    
-                    
+
+
                     pcon = useuser ? (PooledConnection)AlternateUsernameTest.this.datasource.getConnection(username, password) :
                                      (PooledConnection)AlternateUsernameTest.this.datasource.getConnection();
-                    
+
                     Connection con = (Connection)pcon.getConnection();
-                    
+
                     assertTrue("Username mismatch: Requested User:"+username+" Actual user:"+con.getUsername(), con.getUsername().equals(username));
                     assertTrue("Password mismatch: Requested Password:"+password+" Actual password:"+con.getPassword(), con.getPassword().equals(password));
                 }catch (SQLException x) {

==================================================
BorrowWaitTest.java
index 3b65667e35..ec97a029c8 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/Async0IdleTestBug50477.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/Async0IdleTestBug50477.java
@@ -30,8 +30,8 @@ public class Async0IdleTestBug50477 extends DefaultTestCase {
     public Async0IdleTestBug50477(String name) {
         super(name);
     }
-    
- 
+
+
     public void testAsync0Idle0Size() throws Exception {
         System.out.println("[testPoolThreads20Connections10FairAsync] Starting fairness - Tomcat JDBC - Fair - Async");
         init();

==================================================
Bug50571.java
index 3775ef8245..a03f9528c9 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/BorrowWaitTest.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/BorrowWaitTest.java
@@ -25,7 +25,7 @@ public class BorrowWaitTest extends DefaultTestCase {
     public BorrowWaitTest(String name) {
         super(name);
     }
-    
+
     public void testWaitTime() throws Exception {
         int wait = 10000;
         this.init();
@@ -45,7 +45,7 @@ public class BorrowWaitTest extends DefaultTestCase {
         }
         con.close();
     }
-    
+
     public void testWaitTimeInfinite() throws Exception {
         if(true){
             System.err.println("testWaitTimeInfinite() test is disabled.");

==================================================
Bug50805.java
index 2fd5411f4a..c4c3cbce16 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/Bug50571.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/Bug50571.java
@@ -19,11 +19,11 @@ package org.apache.tomcat.jdbc.test;
 import org.apache.tomcat.jdbc.pool.interceptor.ConnectionState;
 
 public class Bug50571 extends DefaultTestCase{
-    
+
     public Bug50571(String name) {
         super(name);
     }
-    
+
     @Override
     public void setUp() throws Exception {
         super.setUp();
@@ -32,7 +32,7 @@ public class Bug50571 extends DefaultTestCase{
         this.datasource.setDefaultTransactionIsolation(-55);
         this.datasource.setInitialSize(1);
     }
-    
+
     public void testBug50571() throws Exception {
         this.datasource.getConnection().close();
     }

==================================================
CheckOutThreadTest.java
index 80fc23e825..df73e2de43 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/Bug50805.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/Bug50805.java
@@ -23,29 +23,29 @@ public class Bug50805 extends DefaultTestCase {
     public Bug50805(String name) {
         super(name);
     }
-    
+
     public void test50805() throws Exception {
         init();
         this.datasource.setInitialSize(0);
         this.datasource.setMaxActive(10);
         this.datasource.setMinIdle(1);
-        
+
         assertEquals("Current size should be 0.", 0, this.datasource.getSize());
-        
+
         this.datasource.getConnection().close();
-        
+
         assertEquals("Current size should be 1.", 1, this.datasource.getSize());
         assertEquals("Idle size should be 1.", 1, this.datasource.getIdle());
         assertEquals("Busy size should be 0.", 0, this.datasource.getActive());
-        
+
         Future<Connection> fc = this.datasource.getConnectionAsync();
-        
+
         Connection con = fc.get();
-        
+
         assertEquals("Current size should be 1.", 1, this.datasource.getSize());
         assertEquals("Idle size should be 0.", 0, this.datasource.getIdle());
         assertEquals("Busy size should be 1.", 1, this.datasource.getActive());
-        
+
         con.close();
         assertEquals("Current size should be 1.", 1, this.datasource.getSize());
         assertEquals("Idle size should be 1.", 1, this.datasource.getIdle());

==================================================
ConnectCountTest.java
index 2c5fa5e77c..d92376d313 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/CheckOutThreadTest.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/CheckOutThreadTest.java
@@ -198,7 +198,7 @@ public class CheckOutThreadTest extends DefaultTestCase {
 //        System.out.println("[testC3P0Threads20Connections10]Test complete:"+delta+" ms. Iterations:"+(threadcount*this.iterations));
 //        tearDown();
 //    }
-    
+
     public void testDBCPThreads10Connections10Validate() throws Exception {
         init();
         this.datasource.getPoolProperties().setMaxActive(10);
@@ -241,7 +241,7 @@ public class CheckOutThreadTest extends DefaultTestCase {
         System.out.println("[testPoolThreads10Connections10Validate]Test complete:"+delta+" ms. Iterations:"+(threadcount*this.iterations));
         tearDown();
     }
-    
+
     public void testPoolThreads10Connections10ValidateFair() throws Exception {
         init();
         this.datasource.getPoolProperties().setMaxActive(10);
@@ -327,7 +327,7 @@ public class CheckOutThreadTest extends DefaultTestCase {
         System.out.println("[testPoolThreads20Connections10Validate]Test complete:"+delta+" ms. Iterations:"+(threadcount*this.iterations));
         tearDown();
     }
-    
+
     public void testPoolThreads10Connections20ValidateFair() throws Exception {
         init();
         this.datasource.getPoolProperties().setMaxActive(10);
@@ -349,7 +349,7 @@ public class CheckOutThreadTest extends DefaultTestCase {
         System.out.println("[testPoolThreads20Connections10ValidateFair]Test complete:"+delta+" ms. Iterations:"+(threadcount*this.iterations));
         tearDown();
     }
-    
+
 //    public void testC3P0Threads10Connections20Validate() throws Exception {
 //        init();
 //        this.datasource.getPoolProperties().setMaxActive(10);

==================================================
CreateTestTable.java
index bcf4ad82f8..d4b8eb994e 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/ConnectCountTest.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/ConnectCountTest.java
@@ -36,7 +36,7 @@ public class ConnectCountTest extends DefaultTestCase {
     public ConnectCountTest(String name) {
         super(name);
     }
-    
+
     protected boolean run = true;
     protected long sleep = Long.getLong("sleep", 10).longValue();
     protected long complete = Long.getLong("complete",20000).longValue();
@@ -83,10 +83,10 @@ public class ConnectCountTest extends DefaultTestCase {
                            (((float)totalfetch))/(float)threads.length);
         System.out.println("["+name+"] Max wait:"+maxwait/1000000f+"ms. Min wait:"+minwait/1000000f+"ms. Average wait:"+(((((float)totalwait))/(float)totalfetch)/1000000f)+" ms.");
         System.out.println("["+name+"] Max active:"+active+" Expected Active:"+expected);
-        
-        
+
+
     }
-    
+
     public void testDBCPThreads20Connections10() throws Exception {
         System.out.println("[testDBCPThreads20Connections10] Starting fairness - DBCP");
         this.threadcount = 20;
@@ -100,7 +100,7 @@ public class ConnectCountTest extends DefaultTestCase {
             threads[i] = new TestThread();
             threads[i].setName("tomcat-dbcp-"+i);
             threads[i].d = this.tDatasource;
-            
+
         }
         for (int i=0; i<threadcount; i++) {
             threads[i].start();
@@ -128,7 +128,7 @@ public class ConnectCountTest extends DefaultTestCase {
             threads[i] = new TestThread();
             threads[i].setName("tomcat-pool-"+i);
             threads[i].d = this.datasource;
-            
+
         }
         for (int i=0; i<threadcount; i++) {
             threads[i].start();
@@ -158,7 +158,7 @@ public class ConnectCountTest extends DefaultTestCase {
             threads[i] = new TestThread();
             threads[i].setName("tomcat-pool-"+i);
             threads[i].d = this.datasource;
-            
+
         }
         for (int i=0; i<threadcount; i++) {
             threads[i].start();
@@ -172,7 +172,7 @@ public class ConnectCountTest extends DefaultTestCase {
         System.out.println("Test completed in: " + delta + "ms.");
         tearDown();
     }
- 
+
     public void testPoolThreads20Connections10FairAsync() throws Exception {
         System.out.println("[testPoolThreads20Connections10FairAsync] Starting fairness - Tomcat JDBC - Fair - Async");
         init();
@@ -189,7 +189,7 @@ public class ConnectCountTest extends DefaultTestCase {
             threads[i].setName("tomcat-pool-"+i);
             threads[i].async = true;
             threads[i].d = this.datasource;
-            
+
         }
         for (int i=0; i<threadcount; i++) {
             threads[i].start();
@@ -203,7 +203,7 @@ public class ConnectCountTest extends DefaultTestCase {
         System.out.println("Test completed in: " + delta + "ms.");
         tearDown();
     }
-    
+
 //    public void testC3P0Threads20Connections10() throws Exception {
 //        System.out.println("[testC3P0Threads20Connections10] Starting fairness - C3P0");
 //        init();
@@ -217,7 +217,7 @@ public class ConnectCountTest extends DefaultTestCase {
 //            threads[i] = new TestThread();
 //            threads[i].setName("tomcat-pool-"+i);
 //            threads[i].d = this.c3p0Datasource;
-//            
+//
 //        }
 //        for (int i=0; i<threadcount; i++) {
 //            threads[i].start();
@@ -232,7 +232,7 @@ public class ConnectCountTest extends DefaultTestCase {
 //
 //    }
 
-    
+
     public class TestThread extends Thread {
         protected DataSource d;
         protected String query = null;
@@ -267,8 +267,8 @@ public class ConnectCountTest extends DefaultTestCase {
                             rs.close();
                             st.close();
                         }
-                        try { 
-                            if (ConnectCountTest.this.sleep>0) sleep(ConnectCountTest.this.sleep); 
+                        try {
+                            if (ConnectCountTest.this.sleep>0) sleep(ConnectCountTest.this.sleep);
                         } catch (InterruptedException x) {
                             interrupted();
                         }

==================================================
DefaultProperties.java
index 825cb0073d..f274f6fd80 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/CreateTestTable.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/CreateTestTable.java
@@ -26,9 +26,9 @@ import java.sql.ResultSet;
 import org.apache.tomcat.jdbc.pool.interceptor.ResetAbandonedTimer;
 
 public class CreateTestTable extends DefaultTestCase {
-    
+
     public static volatile boolean recreate = Boolean.getBoolean("recreate");
-    
+
     public CreateTestTable(String name) {
         super(name);
     }
@@ -43,7 +43,7 @@ public class CreateTestTable extends DefaultTestCase {
         st.close();
         con.close();
     }
-    
+
     public int testCheckData() throws Exception {
         int count = 0;
         String check = "select count (*) from test";
@@ -52,7 +52,7 @@ public class CreateTestTable extends DefaultTestCase {
         Statement st = con.createStatement();
         try {
             ResultSet rs = st.executeQuery(check);
-            
+
             if (rs.next())
                 count = rs.getInt(1);
             rs.close();
@@ -62,7 +62,7 @@ public class CreateTestTable extends DefaultTestCase {
         con.close();
         return count;
     }
-    
+
     public void testPopulateData() throws Exception {
         int count = 100000;
         int actual = testCheckData();
@@ -70,13 +70,13 @@ public class CreateTestTable extends DefaultTestCase {
             System.out.println("Test tables has "+actual+" rows of data. No need to populate.");
             return;
         }
-        
+
         datasource.setJdbcInterceptors(ResetAbandonedTimer.class.getName());
         String insert = "insert into test values (?,?,?,?,?)";
         this.init();
         this.datasource.setRemoveAbandoned(false);
         Connection con = datasource.getConnection();
-        
+
         boolean commit = con.getAutoCommit();
         con.setAutoCommit(false);
         if (recreate) {
@@ -87,8 +87,8 @@ public class CreateTestTable extends DefaultTestCase {
             st.execute("create table test(id int not null, val1 varchar(255), val2 varchar(255), val3 varchar(255), val4 varchar(255))");
             st.close();
         }
-        
-        
+
+
         PreparedStatement ps = con.prepareStatement(insert);
         ps.setQueryTimeout(0);
         for (int i=actual; i<count; i++) {
@@ -117,7 +117,7 @@ public class CreateTestTable extends DefaultTestCase {
         con.setAutoCommit(commit);
         con.close();
     }
-    
+
     public static Random random = new Random(System.currentTimeMillis());
     public static String getRandom() {
         StringBuilder s = new StringBuilder(256);
@@ -128,7 +128,7 @@ public class CreateTestTable extends DefaultTestCase {
         }
         return s.toString();
     }
-    
+
     public static void main(String[] args) throws Exception {
         recreate = true;
         CreateTestTable test = new CreateTestTable("CreateTestTable");

==================================================
DefaultTestCase.java
index 4cd25b4b53..bf74377db6 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/DefaultProperties.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/DefaultProperties.java
@@ -28,22 +28,22 @@ import org.apache.tomcat.jdbc.pool.PoolProperties;
 public class DefaultProperties extends PoolProperties {
     public DefaultProperties() {
         dbProperties = new Properties();
-        
+
         //mysql
-        //url = System.getProperty("url","jdbc:mysql://localhost:3306/mysql?autoReconnect=true"); 
+        //url = System.getProperty("url","jdbc:mysql://localhost:3306/mysql?autoReconnect=true");
         //driverClassName = System.getProperty("driverClassName","com.mysql.jdbc.Driver");
-        
+
         //derby
         //url = System.getProperty("url","jdbc:derby:derbyDB;create=true");
         //driverClassName = System.getProperty("driverClassName","org.apache.derby.jdbc.EmbeddedDriver");
-        
+
         url = System.getProperty("url","jdbc:h2:~/.h2/test;QUERY_TIMEOUT=0;DB_CLOSE_ON_EXIT=FALSE");
         driverClassName = System.getProperty("driverClassName","org.h2.Driver");
         System.setProperty("h2.serverCachedObjects", "10000");
-        
+
         password = System.getProperty("password","password");
         username = System.getProperty("username","root");
-        
+
         validationQuery = System.getProperty("validationQuery","SELECT 1");
         defaultAutoCommit = Boolean.TRUE;
         defaultReadOnly = Boolean.FALSE;
@@ -55,7 +55,7 @@ public class DefaultProperties extends PoolProperties {
         maxIdle = initialSize;
         minIdle = initialSize;
         maxWait = 10000;
-        
+
         testOnBorrow = true;
         testOnReturn = false;
         testWhileIdle = true;

==================================================
FairnessTest.java
index 9b45e42821..c7067cae07 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/DefaultTestCase.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/DefaultTestCase.java
@@ -43,7 +43,7 @@ public class DefaultTestCase extends TestCase {
     public DefaultTestCase(String name) {
         super(name);
     }
-    
+
     @Override
     public void setUp() throws Exception {
         init();
@@ -71,7 +71,7 @@ public class DefaultTestCase extends TestCase {
         datasource.setPoolProperties(p);
         return datasource;
     }
-    
+
     protected void init() throws Exception {
         this.datasource = createDefaultDataSource();
     }
@@ -104,13 +104,13 @@ public class DefaultTestCase extends TestCase {
             x.printStackTrace();
         }
     }
-    
+
     protected void transferPropertiesToC3P0() throws Exception {
 //        System.setProperty("com.mchange.v2.log.FallbackMLog.DEFAULT_CUTOFF_LEVEL", "WARNING");
 //        MLog.getLogger().setLevel(MLevel.WARNING);
 //        MLog.getLogger("com").setLevel(MLevel.WARNING);
 //        //http://www.mchange.com/projects/c3p0/index.html#automaticTestTable
-//        ComboPooledDataSource c3p0 = new ComboPooledDataSource();  
+//        ComboPooledDataSource c3p0 = new ComboPooledDataSource();
 //        c3p0.setAcquireIncrement(1);
 //        c3p0.setAcquireRetryAttempts(2);
 //        c3p0.setAcquireRetryDelay(datasource.getPoolProperties().getMaxWait());
@@ -132,7 +132,7 @@ public class DefaultTestCase extends TestCase {
 //        c3p0.setJdbcUrl(datasource.getPoolProperties().getUrl());
 //        c3p0.setDriverClass(datasource.getPoolProperties().getDriverClassName());
 //        this.c3p0Datasource = c3p0;
-        
+
       /**
         acquireIncrement
         acquireRetryAttempts

==================================================
JmxPasswordTest.java
index a5fe9fafbb..9f8afdc8b4 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/FairnessTest.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/FairnessTest.java
@@ -35,7 +35,7 @@ public class FairnessTest extends DefaultTestCase {
     public FairnessTest(String name) {
         super(name);
     }
-    
+
     protected boolean run = true;
     protected long sleep = Long.getLong("sleep", 10).longValue();
     protected long complete = Long.getLong("complete",20000).longValue();
@@ -59,10 +59,10 @@ public class FairnessTest extends DefaultTestCase {
                            (((float)totalfetch))/(float)threads.length);
         System.out.println("["+name+"] Max wait:"+maxwait/1000000f+"ms. Min wait:"+minwait/1000000f+"ms. Average wait:"+(((((float)totalwait))/(float)totalfetch)/1000000f)+" ms.");
         System.out.println("["+name+"] Max active:"+active+" Expected Active:"+expected);
-        
-        
+
+
     }
-    
+
     public void testDBCPThreads20Connections10() throws Exception {
         System.out.println("[testDBCPThreads20Connections10] Starting fairness - DBCP");
         init();
@@ -77,7 +77,7 @@ public class FairnessTest extends DefaultTestCase {
             threads[i] = new TestThread();
             threads[i].setName("tomcat-dbcp-"+i);
             threads[i].d = this.tDatasource;
-            
+
         }
         for (int i=0; i<threadcount; i++) {
             threads[i].start();
@@ -107,7 +107,7 @@ public class FairnessTest extends DefaultTestCase {
             threads[i] = new TestThread();
             threads[i].setName("tomcat-pool-"+i);
             threads[i].d = this.datasource;
-            
+
         }
         for (int i=0; i<threadcount; i++) {
             threads[i].start();
@@ -137,7 +137,7 @@ public class FairnessTest extends DefaultTestCase {
             threads[i] = new TestThread();
             threads[i].setName("tomcat-pool-"+i);
             threads[i].d = this.datasource;
-            
+
         }
         for (int i=0; i<threadcount; i++) {
             threads[i].start();
@@ -151,7 +151,7 @@ public class FairnessTest extends DefaultTestCase {
         System.out.println("Test completed in: " + delta + "ms.");
         tearDown();
     }
- 
+
     public void testPoolThreads20Connections10FairAsync() throws Exception {
         System.out.println("[testPoolThreads20Connections10FairAsync] Starting fairness - Tomcat JDBC - Fair - Async");
         init();
@@ -168,7 +168,7 @@ public class FairnessTest extends DefaultTestCase {
             threads[i].setName("tomcat-pool-"+i);
             threads[i].async = true;
             threads[i].d = this.datasource;
-            
+
         }
         for (int i=0; i<threadcount; i++) {
             threads[i].start();
@@ -182,7 +182,7 @@ public class FairnessTest extends DefaultTestCase {
         System.out.println("Test completed in: " + delta + "ms.");
         tearDown();
     }
-    
+
 //    public void testC3P0Threads20Connections10() throws Exception {
 //        System.out.println("[testC3P0Threads20Connections10] Starting fairness - C3P0");
 //        init();
@@ -198,7 +198,7 @@ public class FairnessTest extends DefaultTestCase {
 //            threads[i] = new TestThread();
 //            threads[i].setName("tomcat-pool-"+i);
 //            threads[i].d = this.c3p0Datasource;
-//            
+//
 //        }
 //        for (int i=0; i<threadcount; i++) {
 //            threads[i].start();
@@ -213,7 +213,7 @@ public class FairnessTest extends DefaultTestCase {
 //
 //    }
 
-    
+
     public class TestThread extends Thread {
         protected DataSource d;
         protected String query = null;
@@ -248,8 +248,8 @@ public class FairnessTest extends DefaultTestCase {
                             rs.close();
                             st.close();
                         }
-                        try { 
-                            if (FairnessTest.this.sleep>0) sleep(FairnessTest.this.sleep); 
+                        try {
+                            if (FairnessTest.this.sleep>0) sleep(FairnessTest.this.sleep);
                         } catch (InterruptedException x) {
                             interrupted();
                         }

==================================================
SimplePOJOAsyncExample.java
index 5c63f70bb9..42e397747f 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/JmxPasswordTest.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/JmxPasswordTest.java
@@ -33,11 +33,11 @@ public class JmxPasswordTest extends DefaultTestCase{
     public static final String password = "password";
     public static final String username = "username";
     public static ObjectName oname = null;
-    
+
     public JmxPasswordTest(String s) {
         super(s);
     }
-    
+
     @Override
     public void setUp() throws Exception {
         super.setUp();
@@ -55,9 +55,9 @@ public class JmxPasswordTest extends DefaultTestCase{
         ConnectionPool pool = datasource.createPool();
         org.apache.tomcat.jdbc.pool.jmx.ConnectionPool jmxPool = new org.apache.tomcat.jdbc.pool.jmx.ConnectionPool(pool);
         mbs.registerMBean(jmxPool, oname);
-        
+
     }
-    
+
     public void testPassword() throws Exception {
         assertEquals("Passwords should match when not using JMX.",password,datasource.getPoolProperties().getPassword());
         MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
@@ -67,5 +67,5 @@ public class JmxPasswordTest extends DefaultTestCase{
         assertFalse("Passwords should not match.", password.equals(jmxPassword));
         assertFalse("Password property should be missing", jmxProperties.containsKey(PoolUtilities.PROP_PASSWORD));
     }
-    
+
 }

==================================================
SimplePOJOExample.java
index c3cd07100c..611a1eeb74 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/SimplePOJOAsyncExample.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/SimplePOJOAsyncExample.java
@@ -50,10 +50,10 @@ public class SimplePOJOAsyncExample {
         p.setRemoveAbandoned(true);
         p.setJdbcInterceptors("org.apache.tomcat.jdbc.pool.interceptor.ConnectionState;org.apache.tomcat.jdbc.pool.interceptor.StatementFinalizer");
         DataSource datasource = new DataSource();
-        datasource.setPoolProperties(p); 
-        
+        datasource.setPoolProperties(p);
+
         Connection con = null;
-        try {            
+        try {
           Future<Connection> future = datasource.getConnectionAsync();
           while (!future.isDone()) {
               System.out.println("Connection is not yet available. Do some background work");
@@ -63,7 +63,7 @@ public class SimplePOJOAsyncExample {
                   Thread.interrupted();
               }
           }
-          con = future.get(); //should return instantly 
+          con = future.get(); //should return instantly
           Statement st = con.createStatement();
           ResultSet rs = st.executeQuery("select * from user");
           int cnt = 1;
@@ -74,7 +74,7 @@ public class SimplePOJOAsyncExample {
           st.close();
         } finally {
           if (con!=null) try {con.close();}catch (Exception ignore) {}
-        }  
+        }
     }
 
 }
\ No newline at end of file

==================================================
StarvationTest.java
index 50368574bd..38bb39388a 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/SimplePOJOExample.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/SimplePOJOExample.java
@@ -49,10 +49,10 @@ public class SimplePOJOExample {
         p.setLogAbandoned(true);
         p.setRemoveAbandoned(true);
         DataSource datasource = new DataSource();
-        datasource.setPoolProperties(p); 
-        
+        datasource.setPoolProperties(p);
+
         Connection con = null;
-        try {            
+        try {
           con = datasource.getConnection();
           Statement st = con.createStatement();
           ResultSet rs = st.executeQuery("select * from user");
@@ -64,7 +64,7 @@ public class SimplePOJOExample {
           st.close();
         } finally {
           if (con!=null) try {con.close();}catch (Exception ignore) {}
-        }  
+        }
     }
 
 }

==================================================
StatementFinalizerTest.java
index 8013ba5354..81d0dd1030 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/StarvationTest.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/StarvationTest.java
@@ -20,9 +20,9 @@ import java.sql.Connection;
 import java.sql.SQLException;
 
 /**
- * If a connection is abandoned and closed, 
- * then that should free up a spot in the pool, and other threads 
- * that are waiting should not time out and throw an error but be 
+ * If a connection is abandoned and closed,
+ * then that should free up a spot in the pool, and other threads
+ * that are waiting should not time out and throw an error but be
  * able to acquire a connection, since one was just released.
  * @author fhanik
  *
@@ -32,7 +32,7 @@ public class StarvationTest extends DefaultTestCase {
     public StarvationTest(String name) {
         super(name);
     }
-    
+
     private void config() {
         datasource.getPoolProperties().setMaxActive(1);
         datasource.getPoolProperties().setMaxIdle(1);
@@ -43,14 +43,14 @@ public class StarvationTest extends DefaultTestCase {
         datasource.getPoolProperties().setMaxWait(10000);
         datasource.getPoolProperties().setLogAbandoned(true);
     }
-    
+
 //    public void testDBCPConnectionStarvation() throws Exception {
 //        init();
 //        config();
 //        this.transferProperties();
 //        this.tDatasource.getConnection().close();
 //        javax.sql.DataSource datasource = this.tDatasource;
-//        Connection con1 = datasource.getConnection(); 
+//        Connection con1 = datasource.getConnection();
 //        Connection con2 = null;
 //        try {
 //            con2 = datasource.getConnection();
@@ -67,11 +67,11 @@ public class StarvationTest extends DefaultTestCase {
 //        }
 //
 //    }
-    
+
     public void testConnectionStarvation() throws Exception {
         init();
         config();
-        Connection con1 = datasource.getConnection(); 
+        Connection con1 = datasource.getConnection();
         Connection con2 = null;
         try {
             con2 = datasource.getConnection();
@@ -92,7 +92,7 @@ public class StarvationTest extends DefaultTestCase {
         init();
         config();
         datasource.getPoolProperties().setFairQueue(true);
-        Connection con1 = datasource.getConnection(); 
+        Connection con1 = datasource.getConnection();
         Connection con2 = null;
         try {
             con2 = datasource.getConnection();

==================================================
TestAsyncQueue.java
index b2570a5794..89310c7b22 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/StatementFinalizerTest.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/StatementFinalizerTest.java
@@ -27,7 +27,7 @@ public class StatementFinalizerTest extends DefaultTestCase {
     public StatementFinalizerTest(String name) {
         super(name);
     }
-    
+
     public void testStatementFinalization() throws Exception {
         this.init();
         datasource.setJdbcInterceptors(StatementFinalizer.class.getName());

==================================================
TestConcurrency.java
index 7f21c5208b..a287833d6c 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestAsyncQueue.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestAsyncQueue.java
@@ -38,8 +38,8 @@ public class TestAsyncQueue extends TestCase {
         this.queue = null;
         super.tearDown();
     }
-    
-    
+
+
     public void testAsyncPoll1() throws Exception {
         Object item = new Object();
         queue.offer(item);

==================================================
TestConnectionState.java
index 617d4865d4..9e36639d2d 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestConcurrency.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestConcurrency.java
@@ -26,13 +26,13 @@ import org.apache.tomcat.jdbc.test.driver.Driver;
 public class TestConcurrency extends DefaultTestCase {
 
     public static final  boolean debug = Boolean.getBoolean("jdbc.debug");
-    
+
     protected volatile DataSource ds = null;
-    
+
     public TestConcurrency(String name) {
         super(name);
     }
-    
+
     @Override
     public void setUp() {
         // TODO Auto-generated method stub
@@ -57,7 +57,7 @@ public class TestConcurrency extends DefaultTestCase {
         Driver.reset();
         super.tearDown();
     }
-    
+
     public void testSimple() throws Exception {
         ds.getConnection().close();
         final int iter = 1000 * 10;
@@ -106,9 +106,9 @@ public class TestConcurrency extends DefaultTestCase {
         assertEquals("Idle comparison:",10, ds.getPool().getIdle());
         assertEquals("Used comparison:",0, ds.getPool().getActive());
         assertEquals("Connect count",10,Driver.connectCount.get());
-            
+
     }
-    
+
     public void testBrutal() throws Exception {
         ds.getPoolProperties().setRemoveAbandoned(false);
         ds.getPoolProperties().setRemoveAbandonedTimeout(1);
@@ -210,5 +210,5 @@ public class TestConcurrency extends DefaultTestCase {
         assertEquals("Used comparison:",0, ds.getPool().getActive());
         assertEquals("Connect count",10,Driver.connectCount.get());
     }
-    
+
 }

==================================================
TestException.java
index 8ed9bb2bd6..7b351ea0c2 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestConnectionState.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestConnectionState.java
@@ -44,7 +44,7 @@ public class TestConnectionState extends DefaultTestCase {
         d1.close(true);
         assertTrue("Connection should be closed",c1.isClosed());
     }
-    
+
     public void testAutoCommitTrue() throws Exception {
         DataSourceProxy d1 = this.createDefaultDataSource();
         d1.setMaxActive(1);
@@ -59,7 +59,7 @@ public class TestConnectionState extends DefaultTestCase {
         c1 = d1.getConnection();
         assertTrue("Auto commit should be true for a reused connection",c1.getAutoCommit());
     }
-    
+
     public void testDefaultCatalog() throws Exception {
         DataSourceProxy d1 = this.createDefaultDataSource();
         d1.setMaxActive(1);

==================================================
TestGCClose.java
index 0a8df772d2..95ef0b0d8a 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestException.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestException.java
@@ -27,7 +27,7 @@ public class TestException extends DefaultTestCase {
     public TestException(String name) {
         super(name);
     }
-    
+
     public void testException() throws Exception {
         init();
         datasource.getPoolProperties().setJdbcInterceptors(TestInterceptor.class.getName());
@@ -35,20 +35,20 @@ public class TestException extends DefaultTestCase {
         try {
             con.createStatement();
         }catch (Exception x) {
-            
+
         }
     }
-    
-    
+
+
     public static class TestInterceptor extends JdbcInterceptor {
 
         @Override
         public void reset(ConnectionPool parent, PooledConnection con) {
             // TODO Auto-generated method stub
-            
+
         }
 
-    
+
     }
 
 }

==================================================
TestGetConnection.java
index 7bb8157675..7c3eab5b86 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestGCClose.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestGCClose.java
@@ -24,7 +24,7 @@ public class TestGCClose extends DefaultTestCase {
     public TestGCClose(String name) {
         super(name);
     }
-    
+
     public void testGCStop() throws Exception {
         init();
         datasource.getConnection();
@@ -32,7 +32,7 @@ public class TestGCClose extends DefaultTestCase {
         tearDown();
         Thread.sleep(20000);
     }
-    
+
     public void testClose() throws Exception {
         init();
         datasource.getConnection();

==================================================
TestInterceptorShortName.java
index 1d890b47ef..f264aec046 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestGetConnection.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestGetConnection.java
@@ -26,7 +26,7 @@ public class TestGetConnection extends DefaultTestCase {
     public TestGetConnection(String name) {
         super(name);
     }
-    
+
     public void testGetConnection() throws Exception {
         this.init();
         Connection con = this.datasource.getConnection();
@@ -34,7 +34,7 @@ public class TestGetConnection extends DefaultTestCase {
         Connection actual = ((PooledConnection)con).getConnection();
         assertNotNull("Connection delegate should not be null.",actual);
         System.out.println("Actual connection:"+actual.getClass().getName());
-        
+
     }
 
 }

==================================================
TestSizePreservation.java
index 1641bb8b5e..310d9e2eab 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestInterceptorShortName.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestInterceptorShortName.java
@@ -26,7 +26,7 @@ public class TestInterceptorShortName extends DefaultTestCase {
     public TestInterceptorShortName(String name) {
         super(name);
     }
-    
+
     public void testShortInterceptor() throws Exception {
         this.datasource = this.createDefaultDataSource();
         this.datasource.setJdbcInterceptors("TestInterceptor");

==================================================
TestSlowQueryReport.java
index 89c4d7c3f3..1916f21046 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestSizePreservation.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestSizePreservation.java
@@ -25,7 +25,7 @@ import org.apache.tomcat.jdbc.pool.DataSource;
 import org.apache.tomcat.jdbc.pool.PoolConfiguration;
 import org.apache.tomcat.jdbc.test.driver.Driver;
 /**
- * 
+ *
  * @author Jeremy Norris
  * https://issues.apache.org/bugzilla/show_bug.cgi?id=50613
  *

==================================================
TestStatementCache.java
index 2f24ad7d3f..5364c17d66 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestSlowQueryReport.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestSlowQueryReport.java
@@ -37,7 +37,7 @@ public class TestSlowQueryReport extends DefaultTestCase {
     public TestSlowQueryReport(String name) {
         super(name);
     }
-    
+
     public void testSlowSql() throws Exception {
         int count = 3;
         this.init();
@@ -57,7 +57,7 @@ public class TestSlowQueryReport extends DefaultTestCase {
         String key = map.keySet().iterator().next();
         SlowQueryReport.QueryStats stats = map.get(key);
         System.out.println("Stats:"+stats);
-        
+
         for (int i=0; i<count; i++) {
             PreparedStatement st = con.prepareStatement(slowSql);
             ResultSet rs = st.executeQuery();
@@ -65,7 +65,7 @@ public class TestSlowQueryReport extends DefaultTestCase {
             st.close();
         }
         System.out.println("Stats:"+stats);
-        
+
         for (int i=0; i<count; i++) {
             CallableStatement st = con.prepareCall(slowSql);
             ResultSet rs = st.executeQuery();
@@ -102,11 +102,11 @@ public class TestSlowQueryReport extends DefaultTestCase {
         ClientListener listener = new ClientListener();
         ConnectionPool pool = datasource.getPool();
         ManagementFactory.getPlatformMBeanServer().addNotificationListener(
-                SlowQueryReportJmx.getObjectName(SlowQueryReportJmx.class, pool.getName()), 
+                SlowQueryReportJmx.getObjectName(SlowQueryReportJmx.class, pool.getName()),
                 listener,
                 null,
                 null);
-        
+
         for (int i=0; i<count; i++) {
             PreparedStatement st = con.prepareStatement(slowSql);
             ResultSet rs = st.executeQuery();
@@ -114,7 +114,7 @@ public class TestSlowQueryReport extends DefaultTestCase {
             st.close();
         }
         System.out.println("Stats:"+stats);
-        
+
         for (int i=0; i<count; i++) {
             CallableStatement st = con.prepareCall(slowSql);
             ResultSet rs = st.executeQuery();
@@ -129,7 +129,7 @@ public class TestSlowQueryReport extends DefaultTestCase {
         assertNull(SlowQueryReport.getPoolStats(pool.getName()));
     }
 
-    
+
     public void testFastSql() throws Exception {
         int count = 3;
         this.init();
@@ -150,8 +150,8 @@ public class TestSlowQueryReport extends DefaultTestCase {
         con.close();
         tearDown();
         assertNull(SlowQueryReport.getPoolStats(pool.getName()));
-    }    
-    
+    }
+
     public void testFailedSql() throws Exception {
         int count = 3;
         this.init();
@@ -168,7 +168,7 @@ public class TestSlowQueryReport extends DefaultTestCase {
                 // NO-OP
             }
             st.close();
-            
+
         }
         Map<String,SlowQueryReport.QueryStats> map = SlowQueryReport.getPoolStats(datasource.getPool().getName());
         assertNotNull(map);
@@ -180,9 +180,9 @@ public class TestSlowQueryReport extends DefaultTestCase {
         con.close();
         tearDown();
         assertNull(SlowQueryReport.getPoolStats(pool.getName()));
-    }   
-    
-    
+    }
+
+
     public class ClientListener implements NotificationListener {
         volatile int notificationCount = 0;
         @Override

==================================================
TestSuspectTimeout.java
index cc32aee119..e2ab0b0c01 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestStatementCache.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestStatementCache.java
@@ -23,14 +23,14 @@ import org.apache.tomcat.jdbc.pool.interceptor.StatementCache;
 
 public class TestStatementCache extends DefaultTestCase {
 
-    
+
     public TestStatementCache(String name) {
         super(name);
     }
-    
+
     private static volatile TestStatementCacheInterceptor interceptor = null;
-    
-    
+
+
     @Override
     protected void tearDown() throws Exception {
         interceptor = null;
@@ -42,14 +42,14 @@ public class TestStatementCache extends DefaultTestCase {
         datasource.getPoolProperties().setJdbcInterceptors(TestStatementCacheInterceptor.class.getName()+
                 "(prepared="+cachePrepared+",callable="+cacheCallable+",max="+max+")");
     }
-    
+
     public void testIsCacheEnabled() throws Exception {
         init();
         config(true,true,50);
         datasource.getConnection().close();
         assertNotNull("Interceptor was not created.", interceptor);
     }
-    
+
     public void testCacheProperties() throws Exception {
         init();
         config(true,true,50);
@@ -58,7 +58,7 @@ public class TestStatementCache extends DefaultTestCase {
         assertEquals(true, interceptor.isCachePrepared());
         assertEquals(50,interceptor.getMaxCacheSize());
     }
-    
+
     public void testCacheProperties2() throws Exception {
         init();
         config(false,false,100);
@@ -122,7 +122,7 @@ public class TestStatementCache extends DefaultTestCase {
         assertEquals(100,interceptor.getCacheSize().get());
     }
 
-    
+
     public static class TestStatementCacheInterceptor extends StatementCache {
         public TestStatementCacheInterceptor() {
             TestStatementCache.interceptor = this;

==================================================
TwoDataSources.java
index b4b18d98f7..6a6bc7bf51 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestSuspectTimeout.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestSuspectTimeout.java
@@ -27,7 +27,7 @@ public class TestSuspectTimeout extends DefaultTestCase {
     public TestSuspectTimeout(String name) {
         super(name);
     }
-    
+
     public void testSuspect() throws Exception {
         this.init();
         this.datasource.setMaxActive(100);

==================================================
Connection.java
index 2a500e7ae4..3c27cf07c0 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TwoDataSources.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TwoDataSources.java
@@ -24,7 +24,7 @@ public class TwoDataSources extends DefaultTestCase {
     public TwoDataSources(String name) {
         super(name);
     }
-    
+
     public void testTwoDataSources() throws Exception {
         org.apache.tomcat.jdbc.pool.DataSource d1 = this.createDefaultDataSource();
         org.apache.tomcat.jdbc.pool.DataSource d2 = this.createDefaultDataSource();

==================================================
Driver.java
index c3846bf662..1e9a6b4bca 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/driver/Connection.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/driver/Connection.java
@@ -37,19 +37,19 @@ import org.apache.tomcat.jdbc.pool.PooledConnection;
 
 public class Connection implements java.sql.Connection {
     Properties info;
-    
+
     public Connection(Properties info) {
         this.info = info;
     }
-    
+
     public String getUsername() {
         return info.getProperty(PooledConnection.PROP_USER);
     }
-    
+
     public String getPassword() {
         return info.getProperty(PooledConnection.PROP_PASSWORD);
     }
-    
+
     @Override
     public void clearWarnings() throws SQLException {
     }
@@ -198,7 +198,7 @@ public class Connection implements java.sql.Connection {
         return new org.apache.tomcat.jdbc.test.driver.Statement();
     }
 
-    
+
     @Override
     public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
         return new org.apache.tomcat.jdbc.test.driver.Statement();
@@ -214,7 +214,7 @@ public class Connection implements java.sql.Connection {
         return new org.apache.tomcat.jdbc.test.driver.Statement();
     }
 
-    
+
     @Override
     public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
         return new org.apache.tomcat.jdbc.test.driver.Statement();

==================================================
ResultSet.java
index 52c5830c87..2c0b85bcab 100644
--- a/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/driver/Driver.java
+++ b/modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/driver/Driver.java
@@ -32,7 +32,7 @@ public class Driver implements java.sql.Driver {
         connectCount.set(0);
         disconnectCount.set(0);
     }
-    
+
     static {
         try {
             DriverManager.registerDriver(new Driver());
@@ -41,10 +41,10 @@ public class Driver implements java.sql.Driver {
             throw new RuntimeException(x);
         }
     }
-    
+
     public Driver() {
     }
-    
+
     @Override
     public boolean acceptsURL(String url) throws SQLException {
         return url!=null && url.equals(Driver.url);

==================================================
