9486242f29f88aa19699a979b1c7c33c357965d8
==================================================
Fix https://bz.apache.org/bugzilla/show_bug.cgi?id=57767
==================================================
Mark Thomas
==================================================
Wed Aug 2 18:55:44 2017 +0000
==================================================
Constants.java
Fix https://bz.apache.org/bugzilla/show_bug.cgi?id=57767
Add support to the WebSocket client for following redirects when attempting to establish a WebSocket connection.
Patch provided by J Fernandez.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1803901 13f79535-47bb-0310-9956-ffa450edef68



==================================================
WsWebSocketContainer.java
index 9df04dd631..e94327c939 100644
--- a/java/org/apache/tomcat/websocket/LocalStrings.properties
+++ b/java/org/apache/tomcat/websocket/LocalStrings.properties
@@ -136,3 +136,5 @@ wsWebSocketContainer.pathWrongScheme=The scheme [{0}] is not supported. The supp
 wsWebSocketContainer.proxyConnectFail=Failed to connect to the configured Proxy [{0}]. The HTTP response code was [{1}]
 wsWebSocketContainer.sessionCloseFail=Session with ID [{0}] did not close cleanly
 wsWebSocketContainer.sslEngineFail=Unable to create SSLEngine to support SSL/TLS connections
+wsWebSocketContainer.missingLocationHeader=Failed to handle HTTP response code [{0}]. Missing Location header in response
+wsWebSocketContainer.redirectThreshold=Cyclic Location header [{0}] detected / reached max number of redirects [{1}] of max [{2}]
\ No newline at end of file

==================================================
TestWebSocketFrameClient.java
index 8217cae96c..76d94de751 100644
--- a/java/org/apache/tomcat/websocket/WsWebSocketContainer.java
+++ b/java/org/apache/tomcat/websocket/WsWebSocketContainer.java
@@ -26,6 +26,7 @@ import java.net.Proxy;
 import java.net.ProxySelector;
 import java.net.SocketAddress;
 import java.net.URI;
+import java.net.URISyntaxException;
 import java.nio.ByteBuffer;
 import java.nio.channels.AsynchronousChannelGroup;
 import java.nio.channels.AsynchronousSocketChannel;
@@ -98,6 +99,7 @@ public class WsWebSocketContainer implements WebSocketContainer, BackgroundProce
     private volatile long defaultMaxSessionIdleTimeout = 0;
     private int backgroundProcessCount = 0;
     private int processPeriod = Constants.DEFAULT_PROCESS_PERIOD;
+    private Set<URI> redirectSet = null;
 
     private InstanceManager instanceManager;
 
@@ -276,10 +278,11 @@ public class WsWebSocketContainer implements WebSocketContainer, BackgroundProce
                     "wsWebSocketContainer.asynchronousSocketChannelFail"), ioe);
         }
 
+        Map<String,Object> userProperties = clientEndpointConfiguration.getUserProperties();
+
         // Get the connection timeout
         long timeout = Constants.IO_TIMEOUT_MS_DEFAULT;
-        String timeoutValue = (String) clientEndpointConfiguration.getUserProperties().get(
-                Constants.IO_TIMEOUT_MS_PROPERTY);
+        String timeoutValue = (String) userProperties.get(Constants.IO_TIMEOUT_MS_PROPERTY);
         if (timeoutValue != null) {
             timeout = Long.valueOf(timeoutValue).intValue();
         }
@@ -322,8 +325,7 @@ public class WsWebSocketContainer implements WebSocketContainer, BackgroundProce
             // Regardless of whether a non-secure wrapper was created for a
             // proxy CONNECT, need to use TLS from this point on so wrap the
             // original AsynchronousSocketChannel
-            SSLEngine sslEngine = createSSLEngine(
-                    clientEndpointConfiguration.getUserProperties());
+            SSLEngine sslEngine = createSSLEngine(userProperties);
             channel = new AsyncChannelWrapperSecure(socketChannel, sslEngine);
         } else if (channel == null) {
             // Only need to wrap as this point if it wasn't wrapped to process a
@@ -340,8 +342,57 @@ public class WsWebSocketContainer implements WebSocketContainer, BackgroundProce
             writeRequest(channel, request, timeout);
 
             HttpResponse httpResponse = processResponse(response, channel, timeout);
-            // TODO: Handle redirects
+
+            // Check maximum permitted redirects
+            int maxRedirects = Constants.MAX_REDIRECTIONS_DEFAULT;
+            String maxRedirectsValue =
+                    (String) userProperties.get(Constants.MAX_REDIRECTIONS_PROPERTY);
+            if (maxRedirectsValue != null) {
+                maxRedirects = Integer.valueOf(maxRedirectsValue).intValue();
+            }
+
             if (httpResponse.status != 101) {
+                if(isRedirectStatus(httpResponse.status)){
+                    List<String> locationHeader =
+                            httpResponse.getHandshakeResponse().getHeaders().get(
+                                    Constants.LOCATION_HEADER_NAME);
+
+                    if (locationHeader == null || locationHeader.isEmpty() ||
+                            locationHeader.get(0) == null || locationHeader.get(0).isEmpty()) {
+                        throw new DeploymentException(sm.getString(
+                                "wsWebSocketContainer.missingLocationHeader",
+                                Integer.toString(httpResponse.status)));
+                    }
+
+                    URI redirectLocation = URI.create(locationHeader.get(0)).normalize();
+
+                    if (!redirectLocation.isAbsolute()) {
+                        redirectLocation = path.resolve(redirectLocation);
+                    }
+
+                    String redirectScheme = redirectLocation.getScheme().toLowerCase();
+
+                    if (redirectScheme.startsWith("http")) {
+                        redirectLocation = new URI(redirectScheme.replace("http", "ws"),
+                                redirectLocation.getUserInfo(), redirectLocation.getHost(),
+                                redirectLocation.getPort(), redirectLocation.getPath(),
+                                redirectLocation.getQuery(), redirectLocation.getFragment());
+                    }
+
+                    if (redirectSet == null) {
+                        redirectSet = new HashSet<>(maxRedirects);
+                    }
+
+                    if (!redirectSet.add(redirectLocation) || redirectSet.size() > maxRedirects) {
+                        throw new DeploymentException(sm.getString(
+                                "wsWebSocketContainer.redirectThreshold", redirectLocation,
+                                Integer.toString(redirectSet.size()),
+                                Integer.toString(maxRedirects)));
+                    }
+
+                    return connectToServer(endpoint, clientEndpointConfiguration, redirectLocation);
+
+                }
                 throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidStatus",
                         Integer.toString(httpResponse.status)));
             }
@@ -390,7 +441,7 @@ public class WsWebSocketContainer implements WebSocketContainer, BackgroundProce
 
             success = true;
         } catch (ExecutionException | InterruptedException | SSLException |
-                EOFException | TimeoutException e) {
+                EOFException | TimeoutException | URISyntaxException e) {
             throw new DeploymentException(
                     sm.getString("wsWebSocketContainer.httpRequestFailed"), e);
         } finally {
@@ -448,6 +499,27 @@ public class WsWebSocketContainer implements WebSocketContainer, BackgroundProce
     }
 
 
+    private static boolean isRedirectStatus(int httpResponseCode) {
+
+        boolean isRedirect = false;
+
+        switch (httpResponseCode) {
+        case Constants.MULTIPLE_CHOICES:
+        case Constants.MOVED_PERMANENTLY:
+        case Constants.FOUND:
+        case Constants.SEE_OTHER:
+        case Constants.USE_PROXY:
+        case Constants.TEMPORARY_REDIRECT:
+            isRedirect = true;
+            break;
+        default:
+            break;
+        }
+
+        return isRedirect;
+    }
+
+
     private static ByteBuffer createProxyRequest(String host, int port) {
         StringBuilder request = new StringBuilder();
         request.append("CONNECT ");

==================================================
