741e000b2463514971057bdae9133f8815728aa3
==================================================
Fix Bug 49528 - HttpServletRequest.isAsyncStarted() returns false when a Runnable is started
==================================================
Peter Rossbach
==================================================
Sat Jul 3 22:48:16 2010 +0000
==================================================
AsyncContextImpl.java
Fix Bug 49528 - HttpServletRequest.isAsyncStarted() returns false when a Runnable is started
Add isDebugEnabled statements.

Todo: Why we doesn't start directly a container thread with asyncContext.start()?
Currently we start user runnable as an internal forward.


git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@960283 13f79535-47bb-0310-9956-ffa450edef68



==================================================
TestAsyncContextImpl.java
index b3c800f8a6..83aebb56ec 100644
--- a/java/org/apache/catalina/core/AsyncContextImpl.java
+++ b/java/org/apache/catalina/core/AsyncContextImpl.java
@@ -253,7 +253,7 @@ public class AsyncContextImpl implements AsyncContext {
     }
 
     public boolean isStarted() {
-        return (state.get() == AsyncState.STARTED || state.get() == AsyncState.DISPATCHING);
+        return (state.get() == AsyncState.STARTED || state.get() == AsyncState.DISPATCHING || state.get() == AsyncState.DISPATCHED);
     }
 
     public void setStarted(Context context) {
@@ -292,7 +292,8 @@ public class AsyncContextImpl implements AsyncContext {
     
     public void doInternalDispatch() throws ServletException, IOException {
         if (this.state.compareAndSet(AsyncState.TIMING_OUT, AsyncState.COMPLETING)) {
-            log.debug("TIMING OUT!");
+        	if( log.isDebugEnabled())
+        	    log.debug("TIMING OUT!");
             boolean listenerInvoked = false;
             for (AsyncListenerWrapper listener : listeners) {
                 listener.fireOnTimeout(event);
@@ -303,15 +304,18 @@ public class AsyncContextImpl implements AsyncContext {
             }
             doInternalComplete(true);
         } else if (this.state.compareAndSet(AsyncState.ERROR_DISPATCHING, AsyncState.COMPLETING)) {
-            log.debug("ON ERROR!");
+            if( log.isDebugEnabled())
+                log.debug("ON ERROR!");
             boolean listenerInvoked = false;
             for (AsyncListenerWrapper listener : listeners) {
                 try {
                     listener.fireOnError(event);
                 }catch (IllegalStateException x) {
-                    log.debug("Listener invoked invalid state.",x);
+                    if( log.isDebugEnabled())
+                        log.debug("Listener invoked invalid state.",x);
                 }catch (Exception x) {
-                    log.debug("Exception during onError.",x);
+                    if(log.isDebugEnabled())
+                        log.debug("Exception during onError.",x);
                 }
                 listenerInvoked = true;
             }

==================================================
