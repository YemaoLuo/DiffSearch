af51f770ca2f24a0f8a6d176724458af7286d85c
==================================================
Fix spelling in coyote, el, jasper and naming
==================================================
Mark Thomas
==================================================
Wed Sep 16 17:21:31 2020 +0100
==================================================
AsyncStateMachine.java
Fix spelling in coyote, el, jasper and naming

Based on a PR provided by John Bampton
i18n keys, local variables, Javadoc and private methods and private
classes - changes are low risk
There is one change to a public class (o.a.el.util.JreCompat) but that
is effectively an internal API so I think it is safe to make.


==================================================
Http2AsyncParser.java
index be4b953646..7b28ad270a 100644
--- a/java/org/apache/coyote/AsyncStateMachine.java
+++ b/java/org/apache/coyote/AsyncStateMachine.java
@@ -60,7 +60,7 @@ import org.apache.tomcat.util.security.PrivilegedSetTccl;
  * DISPATCHING      - The dispatch is being processed.
  * MUST_ERROR       - ServletRequest.startAsync() has been called from
  *                    Servlet.service() but, before service() exited, an I/O
- *                    error occured on another thread. The container will
+ *                    error occurred on another thread. The container will
  *                    perform the necessary error handling when
  *                    Servlet.service() exits.
  * ERROR            - Something went wrong.

==================================================
AstFunction.java
index 6571b12fe9..1bf600d6d1 100644
--- a/java/org/apache/el/Messages.properties
+++ b/java/org/apache/el/Messages.properties
@@ -59,7 +59,7 @@ error.fnMapper.paramcount=Function [{0}] specifies [{1}] params, but [{2}] were
 error.context.null=ELContext was null
 
 # Parser
-error.funciton.tooManyMethodParameterSets=There are multiple sets of parameters specified for function [{0}]
+error.function.tooManyMethodParameterSets=There are multiple sets of parameters specified for function [{0}]
 error.identifier.noMethod=Identity [{0}] was null and was unable to invoke
 error.identifier.notjava=The identifier [{0}] is not a valid Java identifier as required by section 1.19 of the EL specification (Identifier ::= Java language identifier). This check can be disabled by setting the system property org.apache.el.parser.SKIP_IDENTIFIER_CHECK to true.
 error.identifier.notMethodExpression=Identity [{0}] does not reference a method expression instance, returned type [{1}]

==================================================
Jre9Compat.java
index a95f83c825..2c417c7039 100644
--- a/java/org/apache/el/parser/AstFunction.java
+++ b/java/org/apache/el/parser/AstFunction.java
@@ -104,7 +104,7 @@ public final class AstFunction extends SimpleNode {
                 if (varMapper != null) {
                     obj = varMapper.resolveVariable(this.localName);
                     if (obj instanceof ValueExpression) {
-                        // See if this returns a LambdaEXpression
+                        // See if this returns a LambdaExpression
                         obj = ((ValueExpression) obj).getValue(ctx);
                     }
                 }
@@ -153,7 +153,7 @@ public final class AstFunction extends SimpleNode {
         // single set of method parameters
         if (this.jjtGetNumChildren() != 1) {
             throw new ELException(MessageFactory.get(
-                    "error.funciton.tooManyMethodParameterSets",
+                    "error.function.tooManyMethodParameterSets",
                     getOutputName()));
         }
 

==================================================
JreCompat.java
index 91cd7bc1be..3debecc531 100644
--- a/java/org/apache/el/util/Jre9Compat.java
+++ b/java/org/apache/el/util/Jre9Compat.java
@@ -48,7 +48,7 @@ class Jre9Compat extends JreCompat {
 
 
     @Override
-    public boolean canAcccess(Object base, AccessibleObject accessibleObject) {
+    public boolean canAccess(Object base, AccessibleObject accessibleObject) {
         try {
             return ((Boolean) canAccessMethod.invoke(accessibleObject, base)).booleanValue();
         } catch (ReflectiveOperationException | IllegalArgumentException e) {

==================================================
ReflectionUtil.java
index ac013869c2..5c1fc6a6bf 100644
--- a/java/org/apache/el/util/JreCompat.java
+++ b/java/org/apache/el/util/JreCompat.java
@@ -53,7 +53,7 @@ public class JreCompat {
      * @return {code true} if the AccessibleObject can be accessed otherwise
      *         {code false}
      */
-    public boolean canAcccess(Object base, AccessibleObject accessibleObject) {
+    public boolean canAccess(Object base, AccessibleObject accessibleObject) {
         // Java 8 doesn't support modules so default to true
         return true;
     }

==================================================
ELParser.java
index 2bc4efd903..b8565e8baf 100644
--- a/java/org/apache/el/util/ReflectionUtil.java
+++ b/java/org/apache/el/util/ReflectionUtil.java
@@ -428,7 +428,7 @@ public class ReflectionUtil {
         // If base is non-null, method may be static or non-static
         if (m == null ||
                 (Modifier.isPublic(type.getModifiers()) &&
-                        (jreCompat.canAcccess(base, m) || base != null && jreCompat.canAcccess(null, m)))) {
+                        (jreCompat.canAccess(base, m) || base != null && jreCompat.canAccess(null, m)))) {
             return m;
         }
         Class<?>[] interfaces = type.getInterfaces();

==================================================
Generator.java
index 11276b3b2e..3bcef5bc7f 100644
--- a/java/org/apache/jasper/compiler/ELParser.java
+++ b/java/org/apache/jasper/compiler/ELParser.java
@@ -141,7 +141,7 @@ public class ELParser {
     }
 
     /**
-     * Parse for a function FunctionInvokation ::= (identifier ':')? identifier
+     * Parse for a function FunctionInvocation ::= (identifier ':')? identifier
      * '(' (Expression (,Expression)*)? ')' Note: currently we don't parse
      * arguments
      */

==================================================
BodyContentImpl.java
index ad8b29e36e..bcd0412cd1 100644
--- a/java/org/apache/jasper/compiler/Generator.java
+++ b/java/org/apache/jasper/compiler/Generator.java
@@ -1361,7 +1361,7 @@ class Generator {
                     if (!Modifier.isPublic(modifiers) ||
                             Modifier.isInterface(modifiers) ||
                             Modifier.isAbstract(modifiers) ||
-                            !jreCompat.canAcccess(null, constructor) ) {
+                            !jreCompat.canAccess(null, constructor) ) {
                         throw new Exception(Localizer.getMessage("jsp.error.invalid.bean",
                                 Integer.valueOf(modifiers)));
                     }

==================================================
StringManager.java
index 2164a83916..fcb9778172 100644
--- a/java/org/apache/jasper/runtime/BodyContentImpl.java
+++ b/java/org/apache/jasper/runtime/BodyContentImpl.java
@@ -55,7 +55,7 @@ public class BodyContentImpl extends BodyContent {
      * Constructor.
      * @param enclosingWriter The wrapped writer
      * @param limitBuffer <code>true</code> to discard large buffers
-     * @param tagBufferSize the buffer sise
+     * @param tagBufferSize the buffer size
      */
     public BodyContentImpl(JspWriter enclosingWriter, boolean limitBuffer, int tagBufferSize) {
         super(enclosingWriter);

==================================================
