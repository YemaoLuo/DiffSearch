1f5951ad3224009b98662c8d6b0bbdfcffd2c3b1
==================================================
Hard-code rejectIllegalHeader and allowHostHeaderMismatch to defaults
==================================================
Mark Thomas
==================================================
Tue May 2 18:06:44 2023 +0100
==================================================
AbstractHttp11Protocol.java
Hard-code rejectIllegalHeader and allowHostHeaderMismatch to defaults


==================================================
Http11InputBuffer.java
index e31fbb25a2..9cdd084198 100644
--- a/java/org/apache/coyote/http11/AbstractHttp11Protocol.java
+++ b/java/org/apache/coyote/http11/AbstractHttp11Protocol.java
@@ -172,69 +172,6 @@ public abstract class AbstractHttp11Protocol<S> extends AbstractProtocol<S> {
     }
 
 
-    private boolean allowHostHeaderMismatch = false;
-
-    /**
-     * Will Tomcat accept an HTTP 1.1 request where the host header does not agree with the host specified (if any) in
-     * the request line?
-     *
-     * @return {@code true} if Tomcat will allow such requests, otherwise {@code false}
-     *
-     * @deprecated This will removed in Tomcat 11 onwards where {@code allowHostHeaderMismatch} will be hard-coded to
-     *                 {@code false}.
-     */
-    @Deprecated
-    public boolean getAllowHostHeaderMismatch() {
-        return allowHostHeaderMismatch;
-    }
-
-    /**
-     * Will Tomcat accept an HTTP 1.1 request where the host header does not agree with the host specified (if any) in
-     * the request line?
-     *
-     * @param allowHostHeaderMismatch {@code true} to allow such requests, {@code false} to reject them with a 400
-     *
-     * @deprecated This will removed in Tomcat 11 onwards where {@code allowHostHeaderMismatch} will be hard-coded to
-     *                 {@code false}.
-     */
-    @Deprecated
-    public void setAllowHostHeaderMismatch(boolean allowHostHeaderMismatch) {
-        this.allowHostHeaderMismatch = allowHostHeaderMismatch;
-    }
-
-
-    private boolean rejectIllegalHeader = true;
-
-    /**
-     * If an HTTP request is received that contains an illegal header name or value (e.g. the header name is not a
-     * token) will the request be rejected (with a 400 response) or will the illegal header be ignored?
-     *
-     * @return {@code true} if the request will be rejected or {@code false} if the header will be ignored
-     *
-     * @deprecated This will removed in Tomcat 11 onwards where {@code allowHostHeaderMismatch} will be hard-coded to
-     *                 {@code true}.
-     */
-    @Deprecated
-    public boolean getRejectIllegalHeader() {
-        return rejectIllegalHeader;
-    }
-
-    /**
-     * If an HTTP request is received that contains an illegal header name or value (e.g. the header name is not a
-     * token) should the request be rejected (with a 400 response) or should the illegal header be ignored?
-     *
-     * @param rejectIllegalHeader {@code true} to reject requests with illegal header names or values, {@code false} to
-     *                                ignore the header
-     *
-     * @deprecated This will removed in Tomcat 11 onwards where {@code allowHostHeaderMismatch} will be hard-coded to
-     *                 {@code true}.
-     */
-    @Deprecated
-    public void setRejectIllegalHeader(boolean rejectIllegalHeader) {
-        this.rejectIllegalHeader = rejectIllegalHeader;
-    }
-
-
     private int maxSavePostSize = 4 * 1024;
 
     /**

==================================================
Http11Processor.java
index e6b1595803..36a1bb4f1c 100644
--- a/java/org/apache/coyote/http11/Http11InputBuffer.java
+++ b/java/org/apache/coyote/http11/Http11InputBuffer.java
@@ -65,8 +65,6 @@ public class Http11InputBuffer implements InputBuffer, ApplicationBufferHandler
     private final MimeHeaders headers;
 
 
-    private final boolean rejectIllegalHeader;
-
     /**
      * State.
      */
@@ -148,14 +146,12 @@ public class Http11InputBuffer implements InputBuffer, ApplicationBufferHandler
 
     // ----------------------------------------------------------- Constructors
 
-    public Http11InputBuffer(Request request, int headerBufferSize, boolean rejectIllegalHeader,
-            HttpParser httpParser) {
+    public Http11InputBuffer(Request request, int headerBufferSize, HttpParser httpParser) {
 
         this.request = request;
         headers = request.getMimeHeaders();
 
         this.headerBufferSize = headerBufferSize;
-        this.rejectIllegalHeader = rejectIllegalHeader;
         this.httpParser = httpParser;
 
         filterLibrary = new InputFilter[0];
@@ -886,7 +882,7 @@ public class Http11InputBuffer implements InputBuffer, ApplicationBufferHandler
                 if (headerData.start == pos) {
                     // Zero length header name - not valid.
                     // skipLine() will handle the error
-                    return skipLine(false);
+                    return skipLine();
                 }
                 headerParsePos = HeaderParsePosition.HEADER_VALUE_START;
                 headerData.headerValue = headers.addValue(byteBuffer.array(), headerData.start, pos - headerData.start);
@@ -902,7 +898,7 @@ public class Http11InputBuffer implements InputBuffer, ApplicationBufferHandler
                 headerData.lastSignificantChar = pos;
                 byteBuffer.position(byteBuffer.position() - 1);
                 // skipLine() will handle the error
-                return skipLine(false);
+                return skipLine();
             }
 
             // chr is next byte of header name. Convert to lowercase.
@@ -913,7 +909,7 @@ public class Http11InputBuffer implements InputBuffer, ApplicationBufferHandler
 
         // Skip the line and ignore the header
         if (headerParsePos == HeaderParsePosition.HEADER_SKIPLINE) {
-            return skipLine(false);
+            return skipLine();
         }
 
         //
@@ -971,10 +967,10 @@ public class Http11InputBuffer implements InputBuffer, ApplicationBufferHandler
                         eol = true;
                     } else if (prevChr == Constants.CR) {
                         // Invalid value - also need to delete header
-                        return skipLine(true);
+                        return skipLine();
                     } else if (chr != Constants.HT && HttpParser.isControl(chr)) {
                         // Invalid value - also need to delete header
-                        return skipLine(true);
+                        return skipLine();
                     } else if (chr == Constants.SP || chr == Constants.HT) {
                         byteBuffer.put(headerData.realPos, chr);
                         headerData.realPos++;
@@ -1022,25 +1018,7 @@ public class Http11InputBuffer implements InputBuffer, ApplicationBufferHandler
     }
 
 
-    private HeaderParseStatus skipLine(boolean deleteHeader) throws IOException {
-        boolean rejectThisHeader = rejectIllegalHeader;
-        // Check if rejectIllegalHeader is disabled and needs to be overridden
-        // for this header. The header name is required to determine if this
-        // override is required. The header name is only available once the
-        // header has been created. If the header has been created then
-        // deleteHeader will be true.
-        if (!rejectThisHeader && deleteHeader) {
-            if (headers.getName(headers.size() - 1).equalsIgnoreCase("content-length")) {
-                // Malformed content-length headers must always be rejected
-                // RFC 9112, section 6.3, bullet 5.
-                rejectThisHeader = true;
-            } else {
-                // Only need to delete the header if the request isn't going to
-                // be rejected (it will be the most recent one)
-                headers.removeHeader(headers.size() - 1);
-            }
-        }
-
+    private HeaderParseStatus skipLine() throws IOException {
         // Parse the rest of the invalid header so we can construct a useful
         // exception and/or debug message.
         headerParsePos = HeaderParsePosition.HEADER_SKIPLINE;
@@ -1068,18 +1046,10 @@ public class Http11InputBuffer implements InputBuffer, ApplicationBufferHandler
                 headerData.lastSignificantChar = pos;
             }
         }
-        if (rejectThisHeader || log.isDebugEnabled()) {
-            if (rejectThisHeader) {
-                throw new IllegalArgumentException(
-                        sm.getString("iib.invalidheader.reject", HeaderUtil.toPrintableString(byteBuffer.array(),
-                                headerData.lineStart, headerData.lastSignificantChar - headerData.lineStart + 1)));
-            }
-            log.debug(sm.getString("iib.invalidheader", HeaderUtil.toPrintableString(byteBuffer.array(),
-                    headerData.lineStart, headerData.lastSignificantChar - headerData.lineStart + 1)));
-        }
 
-        headerParsePos = HeaderParsePosition.HEADER_START;
-        return HeaderParseStatus.HAVE_MORE_HEADERS;
+        throw new IllegalArgumentException(
+                sm.getString("iib.invalidheader.reject", HeaderUtil.toPrintableString(byteBuffer.array(),
+                        headerData.lineStart, headerData.lastSignificantChar - headerData.lineStart + 1)));
     }
 
 

==================================================
TestHttp11InputBuffer.java
index bad930c98c..9e2e74914c 100644
--- a/java/org/apache/coyote/http11/Http11Processor.java
+++ b/java/org/apache/coyote/http11/Http11Processor.java
@@ -155,8 +155,7 @@ public class Http11Processor extends AbstractProcessor {
 
         httpParser = new HttpParser(protocol.getRelaxedPathChars(), protocol.getRelaxedQueryChars());
 
-        inputBuffer = new Http11InputBuffer(request, protocol.getMaxHttpRequestHeaderSize(),
-                protocol.getRejectIllegalHeader(), httpParser);
+        inputBuffer = new Http11InputBuffer(request, protocol.getMaxHttpRequestHeaderSize(), httpParser);
         request.setInputBuffer(inputBuffer);
 
         outputBuffer = new Http11OutputBuffer(response, protocol.getMaxHttpResponseHeaderSize());
@@ -733,19 +732,10 @@ public class Http11Processor extends AbstractProcessor {
                         // Any host in the request line must be consistent with
                         // the Host header
                         if (!hostValueMB.getByteChunk().equals(uriB, uriBCStart + pos, slashPos - pos)) {
-                            if (protocol.getAllowHostHeaderMismatch()) {
-                                // The requirements of RFC 2616 are being
-                                // applied. If the host header and the request
-                                // line do not agree, the request line takes
-                                // precedence
-                                hostValueMB = headers.setValue("host");
-                                hostValueMB.setBytes(uriB, uriBCStart + pos, slashPos - pos);
-                            } else {
-                                // The requirements of RFC 7230 are being
-                                // applied. If the host header and the request
-                                // line do not agree, trigger a 400 response.
-                                badRequest("http11processor.request.inconsistentHosts");
-                            }
+                            // The requirements of RFC 7230 are being
+                            // applied. If the host header and the request
+                            // line do not agree, trigger a 400 response.
+                            badRequest("http11processor.request.inconsistentHosts");
                         }
                     }
                 } else {

==================================================
