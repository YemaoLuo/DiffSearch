ee7f53b4abb53dce163a840564427fa54422a128
==================================================
Syncing with Commons Fileupload trunk
==================================================
Mark Emlyn
==================================================
Tue Mar 19 09:51:46 2013 +0000
==================================================
package-info.java
Syncing with Commons Fileupload trunk

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1458192 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Base64Decoder.java
index 8729445062..bc748187ec 100644
--- a/java/org/apache/tomcat/util/http/fileupload/package-info.java
+++ b/java/org/apache/tomcat/util/http/fileupload/package-info.java
@@ -18,7 +18,7 @@
 
 /**
  * <p><b>NOTE:</b> This code has been copied from commons-fileupload trunk
- * revision 1456918 and commons-io 1.4 and package renamed to avoid clashes with
+ * revision 1458080 and commons-io 1.4 and package renamed to avoid clashes with
  * any web apps that may wish to use these libraries.
  * </p>
  * <p>

==================================================
MimeUtility.java
index c101878fe3..44954441e9 100644
--- a/java/org/apache/tomcat/util/http/fileupload/util/mime/Base64Decoder.java
+++ b/java/org/apache/tomcat/util/http/fileupload/util/mime/Base64Decoder.java
@@ -24,26 +24,6 @@ import java.io.OutputStream;
  */
 final class Base64Decoder {
 
-    /**
-     * Bytes per undecoded block.
-     */
-    private static final int BYTES_PER_UNENCODED_BLOCK = 3;
-
-    /**
-     * 2 bits mask.
-     */
-    private static final int MASK_2BITS = 2;
-
-    /**
-     * 4 bits mask.
-     */
-    private static final int MASK_4BITS = 4;
-
-    /**
-     * 6 bits mask.
-     */
-    private static final int MASK_6BITS = 6;
-
     /**
      * Set up the encoding table.
      */
@@ -68,14 +48,11 @@ final class Base64Decoder {
     private static final byte PADDING = (byte) '=';
 
     /**
-     * The decoding table size.
+     * Set up the decoding table; this is indexed by a byte converted to an int,
+     * so must be at least as large as the number of different byte values,
+     * positive and negative and zero.
      */
-    private static final int DECODING_TABLE_SIZE = 256;
-
-    /**
-     * Set up the decoding table.
-     */
-    private static final byte[] DECODING_TABLE = new byte[DECODING_TABLE_SIZE];
+    private static final byte[] DECODING_TABLE = new byte[Byte.MAX_VALUE - Byte.MIN_VALUE + 1];
 
     static {
         for (int i = 0; i < ENCODING_TABLE.length; i++) {
@@ -121,7 +98,8 @@ final class Base64Decoder {
         }
 
         int  i = off;
-        int  finish = end - MASK_4BITS;
+        // CHECKSTYLE IGNORE MagicNumber FOR NEXT 1 LINE
+        int  finish = end - 4; // last set of 4 bytes might include padding
 
         while (i < finish) {
             while ((i < finish) && ignore((char) data[i])) {
@@ -148,40 +126,39 @@ final class Base64Decoder {
 
             b4 = DECODING_TABLE[data[i++]];
 
-            out.write((b1 << MASK_2BITS) | (b2 >> MASK_4BITS));
-            out.write((b2 << MASK_4BITS) | (b3 >> MASK_2BITS));
-            out.write((b3 << MASK_6BITS) | b4);
+            // Convert 4 6-bit bytes to 3 8-bit bytes
+            // CHECKSTYLE IGNORE MagicNumber FOR NEXT 3 LINES
+            out.write((b1 << 2) | (b2 >> 4)); // 6 bits of b1 plus 2 bits of b2
+            out.write((b2 << 4) | (b3 >> 2)); // 4 bits of b2 plus 4 bits of b3
+            out.write((b3 << 6) | b4);        // 2 bits of b3 plus 6 bits of b4
 
-            outLen += BYTES_PER_UNENCODED_BLOCK;
+            // CHECKSTYLE IGNORE MagicNumber FOR NEXT 1 LINE
+            outLen += 3;
         }
 
-        if (data[end - MASK_2BITS] == PADDING) {
-            b1 = DECODING_TABLE[data[end - MASK_4BITS]];
-            b2 = DECODING_TABLE[data[end - BYTES_PER_UNENCODED_BLOCK]];
-
-            out.write((b1 << MASK_2BITS) | (b2 >> MASK_4BITS));
-
-            outLen += 1;
-        } else if (data[end - 1] == PADDING) {
-            b1 = DECODING_TABLE[data[end - MASK_4BITS]];
-            b2 = DECODING_TABLE[data[end - BYTES_PER_UNENCODED_BLOCK]];
-            b3 = DECODING_TABLE[data[end - MASK_2BITS]];
-
-            out.write((b1 << MASK_2BITS) | (b2 >> MASK_4BITS));
-            out.write((b2 << MASK_4BITS) | (b3 >> MASK_2BITS));
-
-            outLen += MASK_2BITS;
-        } else {
-            b1 = DECODING_TABLE[data[end - MASK_4BITS]];
-            b2 = DECODING_TABLE[data[end - BYTES_PER_UNENCODED_BLOCK]];
-            b3 = DECODING_TABLE[data[end - MASK_2BITS]];
-            b4 = DECODING_TABLE[data[end - 1]];
-
-            out.write((b1 << MASK_2BITS) | (b2 >> MASK_4BITS));
-            out.write((b2 << MASK_4BITS) | (b3 >> MASK_2BITS));
-            out.write((b3 << MASK_6BITS) | b4);
-
-            outLen += BYTES_PER_UNENCODED_BLOCK;
+        // Get the last 4 bytes; only last two can be padding
+        b1 = DECODING_TABLE[data[i++]];
+        b2 = DECODING_TABLE[data[i++]];
+
+        // always write the first byte
+        // CHECKSTYLE IGNORE MagicNumber FOR NEXT 1 LINE
+        out.write((b1 << 2) | (b2 >> 4)); // 6 bits of b1 plus 2 bits of b2
+        outLen++;
+
+        byte p1 = data[i++];
+        byte p2 = data[i++];
+
+        b3 = DECODING_TABLE[p1]; // may be needed later
+
+        if (p1 != PADDING) { // Nothing more to do if p1 == PADDING
+            // CHECKSTYLE IGNORE MagicNumber FOR NEXT 1 LINE
+            out.write((b2 << 4) | (b3 >> 2)); // 4 bits of b2 plus 4 bits of b3
+            outLen++;
+        } else if (p2 != PADDING) { // Nothing more to do if p2 == PADDING
+            b4 = DECODING_TABLE[p2];
+            // CHECKSTYLE IGNORE MagicNumber FOR NEXT 1 LINE
+            out.write((b3 << 6) | b4);        // 2 bits of b3 plus 6 bits of b4
+            outLen++;
         }
 
         return outLen;

==================================================
QuotedPrintableDecoder.java
index 7ff3516f39..b10cb7574f 100644
--- a/java/org/apache/tomcat/util/http/fileupload/util/mime/MimeUtility.java
+++ b/java/org/apache/tomcat/util/http/fileupload/util/mime/MimeUtility.java
@@ -225,7 +225,7 @@ public final class MimeUtility {
             if (encoding.equals("B")) {
                 Base64Decoder.decode(encodedData, 0, encodedData.length, out);
             } else if (encoding.equals("Q")) { // maybe quoted printable.
-                QuotedPrintableDecoder.decodeWord(encodedData, 0, encodedData.length, out);
+                QuotedPrintableDecoder.decode(encodedData, 0, encodedData.length, out);
             } else {
                 throw new UnsupportedEncodingException("Unknown RFC 2047 encoding: " + encoding);
             }

==================================================
