8eeed6413e8266d0a54e2c07c4ae1206502eef9a
==================================================
Followup to r1601583:
==================================================
Konstantin Kolinko
==================================================
Tue Jun 17 19:19:20 2014 +0000
==================================================
AbstractEndpoint.java
Followup to r1601583:
Use Collections.newSetFromMap to convert ConcurrentHashMap into a Set.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1603266 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AprEndpoint.java
index 6234bba199..41113a12a5 100644
--- a/java/org/apache/tomcat/util/net/AbstractEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AbstractEndpoint.java
@@ -21,8 +21,10 @@ import java.io.OutputStreamWriter;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
+import java.util.Set;
 import java.util.StringTokenizer;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
@@ -122,9 +124,7 @@ public abstract class AbstractEndpoint<S> {
                     // Ignore
                 }
                 long now = System.currentTimeMillis();
-                Iterator<SocketWrapper<S>> sockets = waitingRequests.keySet().iterator();
-                while (sockets.hasNext()) {
-                    SocketWrapper<S> socket = sockets.next();
+                for (SocketWrapper<S> socket : waitingRequests) {
                     long access = socket.getLastAccess();
                     if (socket.getTimeout() > 0 && (now - access) > socket.getTimeout()) {
                         processSocket(socket, SocketStatus.TIMEOUT, true);
@@ -1026,8 +1026,9 @@ public abstract class AbstractEndpoint<S> {
         }
     }
 
-    protected ConcurrentHashMap<SocketWrapper<S>, SocketWrapper<S>> waitingRequests =
-            new ConcurrentHashMap<>();
+
+    protected final Set<SocketWrapper<S>> waitingRequests = Collections
+            .newSetFromMap(new ConcurrentHashMap<SocketWrapper<S>, Boolean>());
 
 
     /**

==================================================
JIoEndpoint.java
index 21e17d10b0..4d75895143 100644
--- a/java/org/apache/tomcat/util/net/AprEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AprEndpoint.java
@@ -870,7 +870,7 @@ public class AprEndpoint extends AbstractEndpoint<Long> {
             // result of calling AsyncContext.dispatch() from a non-container
             // thread
             synchronized (socket) {
-                if (waitingRequests.remove(socket) != null) {
+                if (waitingRequests.remove(socket)) {
                     SocketProcessor proc = new SocketProcessor(socket, status);
                     Executor executor = getExecutor();
                     if (dispatch && executor != null) {
@@ -2324,7 +2324,7 @@ public class AprEndpoint extends AbstractEndpoint<Long> {
                     } else if (state == Handler.SocketState.LONG) {
                         socket.access();
                         if (socket.isAsync()) {
-                            waitingRequests.put(socket, socket);
+                            waitingRequests.add(socket);
                         }
                     }
                 }
@@ -2386,7 +2386,7 @@ public class AprEndpoint extends AbstractEndpoint<Long> {
             } else if (state == Handler.SocketState.LONG) {
                 socket.access();
                 if (socket.isAsync()) {
-                    waitingRequests.put(socket, socket);
+                    waitingRequests.add(socket);
                 }
             } else if (state == Handler.SocketState.ASYNC_END) {
                 socket.access();

==================================================
Nio2Endpoint.java
index e8aa638fad..749af9672e 100644
--- a/java/org/apache/tomcat/util/net/JIoEndpoint.java
+++ b/java/org/apache/tomcat/util/net/JIoEndpoint.java
@@ -298,7 +298,7 @@ public class JIoEndpoint extends AbstractEndpoint<Socket> {
                         launch = true;
                     } else if (state == SocketState.LONG) {
                         socket.access();
-                        waitingRequests.put(socket, socket);
+                        waitingRequests.add(socket);
                     }
                 } finally {
                     if (launch) {
@@ -514,7 +514,7 @@ public class JIoEndpoint extends AbstractEndpoint<Socket> {
             // result of calling AsyncContext.dispatch() from a non-container
             // thread
             synchronized (socket) {
-                if (waitingRequests.remove(socket) != null) {
+                if (waitingRequests.remove(socket)) {
                     SocketProcessor proc = new SocketProcessor(socket,status);
                     Executor executor = getExecutor();
                     if (dispatch && executor != null) {

==================================================
