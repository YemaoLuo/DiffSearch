79e435df74b31f4acd299160084eac870cb27539
==================================================
Whitespace removal from /java/org/apache/catalina/ha
==================================================
Mark Emlyn
==================================================
Sat Oct 22 21:08:24 2011 +0000
==================================================
CatalinaCluster.java
Whitespace removal from /java/org/apache/catalina/ha

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1187786 13f79535-47bb-0310-9956-ffa450edef68



==================================================
ClusterDeployer.java
index 12fbb541ae..f74a44f508 100644
--- a/java/org/apache/catalina/ha/CatalinaCluster.java
+++ b/java/org/apache/catalina/ha/CatalinaCluster.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -30,7 +30,7 @@ import org.apache.juli.logging.Log;
 
 
 /**
- * A <b>CatalinaCluster</b> interface allows to plug in and out the 
+ * A <b>CatalinaCluster</b> interface allows to plug in and out the
  * different cluster implementations
  *
  * @author Filip Hanik
@@ -45,26 +45,26 @@ public interface CatalinaCluster extends Cluster {
      * @throws Exception - if failure to start cluster
      */
     public void start() throws Exception;
-    
+
     /**
      * Stops the cluster, the owning container will invoke this
      * @throws LifecycleException
      */
     public void stop() throws LifecycleException;
-    
+
     /**
      * Returns the associates logger with this cluster.
      *
      * @return Log
      */
     public Log getLogger();
-    
+
     /**
      * Sends a message to all the members in the cluster
      * @param msg ClusterMessage
      */
     public void send(ClusterMessage msg);
-    
+
     /**
      * Sends a message to a specific member in the cluster.
      *
@@ -84,24 +84,24 @@ public interface CatalinaCluster extends Cluster {
      * @return Member[]
      */
     public Member[] getMembers();
-    
+
     /**
      * Return the member that represents this node.
      *
      * @return Member
      */
     public Member getLocalMember();
-    
+
     public void addValve(Valve valve);
-    
+
     public void addClusterListener(ClusterListener listener);
-    
+
     public void removeClusterListener(ClusterListener listener);
-    
+
     public void setClusterDeployer(ClusterDeployer deployer);
-    
+
     public ClusterDeployer getClusterDeployer();
-    
+
     /**
      * @return The map of managers
      */
@@ -110,9 +110,9 @@ public interface CatalinaCluster extends Cluster {
     public Manager getManager(String name);
     public String getManagerName(String name, Manager manager);
     public Valve[] getValves();
-    
+
     public void setChannel(Channel channel);
     public Channel getChannel();
-    
+
 
 }

==================================================
ClusterListener.java
index e447a6fb7b..3eacb9019c 100644
--- a/java/org/apache/catalina/ha/ClusterDeployer.java
+++ b/java/org/apache/catalina/ha/ClusterDeployer.java
@@ -49,7 +49,7 @@ public interface ClusterDeployer extends ChannelListener {
      * specified URL, into this container and all the other
      * members of the cluster with the specified context name.
      * <p>
-     * If this application is successfully installed locally, 
+     * If this application is successfully installed locally,
      * a ContainerEvent of type
      * <code>INSTALL_EVENT</code> will be sent to all registered listeners,
      * with the newly created <code>Context</code> as an argument.
@@ -92,7 +92,7 @@ public interface ClusterDeployer extends ChannelListener {
      * call from container Background Process
      */
     public void backgroundProcess();
-    
+
     /**
      * Returns the cluster the cluster deployer is associated with
      * @return CatalinaCluster

==================================================
ClusterManager.java
index 73553d92fd..6013f9ac47 100644
--- a/java/org/apache/catalina/ha/ClusterListener.java
+++ b/java/org/apache/catalina/ha/ClusterListener.java
@@ -26,7 +26,7 @@ import org.apache.catalina.tribes.Member;
 /**
  * Receive SessionID cluster change from other backup node after primary session
  * node is failed.
- * 
+ *
  * @author Peter Rossbach
  * @author Filip Hanik
  * @version $Id$
@@ -49,9 +49,9 @@ public abstract class ClusterListener implements ChannelListener {
     public ClusterListener() {
         // NO-OP
     }
-    
+
     //--Instance Getters/Setters--------------------------------
-    
+
     public CatalinaCluster getCluster() {
         return cluster;
     }
@@ -95,16 +95,16 @@ public abstract class ClusterListener implements ChannelListener {
     /**
      * Callback from the cluster, when a message is received, The cluster will
      * broadcast it invoking the messageReceived on the receiver.
-     * 
+     *
      * @param msg
      *            ClusterMessage - the message received from the cluster
      */
     public abstract void messageReceived(ClusterMessage msg) ;
-    
+
 
     /**
      * Accept only SessionIDMessages
-     * 
+     *
      * @param msg
      *            ClusterMessage
      * @return boolean - returns true to indicate that messageReceived should be

==================================================
ClusterMessage.java
index 1fca879f4d..558700495a 100644
--- a/java/org/apache/catalina/ha/ClusterManager.java
+++ b/java/org/apache/catalina/ha/ClusterManager.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -61,21 +61,21 @@ public interface ClusterManager extends Manager {
     * @return String[] The invalidated sessions
     */
    public String[] getInvalidatedSessions();
-   
+
    /**
     * Return the name of the manager, at host /context name and at engine hostname+/context.
     * @return String
     * @since 5.5.10
     */
    public String getName();
-   
+
    /**
     * Set the name of the manager, at host /context name and at engine hostname+/context
     * @param name
     * @since 5.5.10
     */
    public void setName(String name);
-         
+
    public CatalinaCluster getCluster();
 
    public void setCluster(CatalinaCluster cluster);
@@ -83,7 +83,7 @@ public interface ClusterManager extends Manager {
    public ReplicationStream getReplicationStream(byte[] data) throws IOException;
 
    public ReplicationStream getReplicationStream(byte[] data, int offset, int length) throws IOException;
-   
+
    public boolean isNotifyListenersOnReplication();
 
    public ClusterManager cloneFromTemplate();

==================================================
ClusterMessageBase.java
index 2faf20cfef..af66aca9b0 100644
--- a/java/org/apache/catalina/ha/ClusterMessage.java
+++ b/java/org/apache/catalina/ha/ClusterMessage.java
@@ -23,7 +23,7 @@ import org.apache.catalina.tribes.Member;
 
 /**
  * @author Filip Hanik
- * 
+ *
  */
 public interface ClusterMessage extends Serializable {
     public Member getAddress();

==================================================
ClusterRuleSet.java
index 505087d6e1..4b4b5c0e9e 100644
--- a/java/org/apache/catalina/ha/ClusterMessageBase.java
+++ b/java/org/apache/catalina/ha/ClusterMessageBase.java
@@ -31,7 +31,7 @@ import org.apache.catalina.tribes.Member;
  * @version 1.0
  */
 public class ClusterMessageBase implements ClusterMessage {
-    
+
     private static final long serialVersionUID = 1L;
 
     protected transient Member address;

==================================================
ClusterSession.java
index 153d0c87b2..bff7cde544 100644
--- a/java/org/apache/catalina/ha/ClusterRuleSet.java
+++ b/java/org/apache/catalina/ha/ClusterRuleSet.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -148,7 +148,7 @@ public class ClusterRuleSet extends RuleSetBase {
                                 "addInterceptor",
                                 "org.apache.catalina.tribes.ChannelInterceptor");
 
-            
+
             digester.addObjectCreate(channelPrefix + "Interceptor/Member",
                                      null, // MUST be specified in the element
                                      "className");
@@ -165,7 +165,7 @@ public class ClusterRuleSet extends RuleSetBase {
         digester.addSetNext(prefix + "Valve",
                             "addValve",
                             "org.apache.catalina.Valve");
-        
+
         digester.addObjectCreate(prefix + "Deployer",
                                  null, // MUST be specified in the element
                                  "className");
@@ -173,7 +173,7 @@ public class ClusterRuleSet extends RuleSetBase {
         digester.addSetNext(prefix + "Deployer",
                             "setClusterDeployer",
                             "org.apache.catalina.ha.ClusterDeployer");
-        
+
         digester.addObjectCreate(prefix + "Listener",
                 null, // MUST be specified in the element
                 "className");
@@ -181,7 +181,7 @@ public class ClusterRuleSet extends RuleSetBase {
         digester.addSetNext(prefix + "Listener",
                             "addLifecycleListener",
                             "org.apache.catalina.LifecycleListener");
-        
+
         digester.addObjectCreate(prefix + "ClusterListener",
                 null, // MUST be specified in the element
                 "className");

==================================================
ClusterValve.java
index eb124bb6f2..aa598f8222 100644
--- a/java/org/apache/catalina/ha/ClusterSession.java
+++ b/java/org/apache/catalina/ha/ClusterSession.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
ClusterSingleSignOnListener.java
index f33efb6258..178ba6fc64 100644
--- a/java/org/apache/catalina/ha/ClusterValve.java
+++ b/java/org/apache/catalina/ha/ClusterValve.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
SingleSignOnMessage.java
index e8e281da8a..53315094d5 100644
--- a/java/org/apache/catalina/ha/authenticator/ClusterSingleSignOnListener.java
+++ b/java/org/apache/catalina/ha/authenticator/ClusterSingleSignOnListener.java
@@ -29,11 +29,11 @@ import org.apache.juli.logging.LogFactory;
 
 /**
  * Receive replicated SingleSignOnMessage form other cluster node.
- * 
+ *
  * @author Fabien Carrion
  */
 public class ClusterSingleSignOnListener extends ClusterListener {
- 
+
     private static final Log log =
         LogFactory.getLog(ClusterSingleSignOnListener.class);
 
@@ -66,7 +66,7 @@ public class ClusterSingleSignOnListener extends ClusterListener {
     /**
      * Callback from the cluster, when a message is received, The cluster will
      * broadcast it invoking the messageReceived on the receiver.
-     * 
+     *
      * @param myobj
      *            ClusterMessage - the message received from the cluster
      */
@@ -117,7 +117,7 @@ public class ClusterSingleSignOnListener extends ClusterListener {
 
     /**
      * Accept only SingleSignOnMessage
-     * 
+     *
      * @param msg
      *            ClusterMessage
      * @return boolean - returns true to indicate that messageReceived should be
@@ -131,7 +131,7 @@ public class ClusterSingleSignOnListener extends ClusterListener {
 
 
     private Session getSession(String sessionId, String ctxname) {
-        
+
         Map<String,ClusterManager> managers = clusterSSO.getCluster().getManagers();
         Session session = null;
 

==================================================
CollectedInfo.java
index 2abfeb2fa7..f775aa3758 100644
--- a/java/org/apache/catalina/ha/authenticator/SingleSignOnMessage.java
+++ b/java/org/apache/catalina/ha/authenticator/SingleSignOnMessage.java
@@ -55,7 +55,7 @@ public class SingleSignOnMessage implements ClusterMessage {
         this.ssoId = ssoId;
         this.sessionId = sessionId;
     }
-    
+
     /**
      * Get the address that this message originated from.  This would be set
      * if the message was being relayed from a host other than the one

==================================================
HeartbeatListener.java
index c4da0f5997..e9e7a01823 100644
--- a/java/org/apache/catalina/ha/backend/CollectedInfo.java
+++ b/java/org/apache/catalina/ha/backend/CollectedInfo.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -63,7 +63,7 @@ public class CollectedInfo {
             ObjectInstance oi = iterator.next();
             objName = oi.getObjectName();
             String name = objName.getKeyProperty("name");
-              
+
             /* Name are:
              * http-8080
              * jk-10.33.144.3-8009
@@ -86,7 +86,7 @@ public class CollectedInfo {
             throw(new Exception("Can't find connector for " + host + ":" + port));
         this.port = iport;
         this.host = shost;
-        
+
     }
 
     public void refresh() throws Exception {

==================================================
MultiCastSender.java
index 9bfd426904..c99f94836b 100644
--- a/java/org/apache/catalina/ha/backend/HeartbeatListener.java
+++ b/java/org/apache/catalina/ha/backend/HeartbeatListener.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -99,7 +99,7 @@ public class HeartbeatListener
                     log.error("Unable to initialize info collection: " + ex);
                     coll = null;
                     return;
-                } 
+                }
             }
 
             /* Start or restart sender */

==================================================
Proxy.java
index e00ae9feea..cb9596f4d4 100644
--- a/java/org/apache/catalina/ha/backend/MultiCastSender.java
+++ b/java/org/apache/catalina/ha/backend/MultiCastSender.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -58,14 +58,14 @@ public class MultiCastSender
                     s = new MulticastSocket(addrs);
                 } else
                     s = new MulticastSocket(config.getMultiport());
-          
+
                 s.setTimeToLive(config.getTtl());
                 s.joinGroup(group);
             } catch (Exception ex) {
                 log.error("Unable to use multicast: " + ex);
                 s = null;
                 return -1;
-            } 
+            }
         }
 
         byte[] buf;

==================================================
Sender.java
index e6dfc4b0c6..aa967f0863 100644
--- a/java/org/apache/catalina/ha/backend/Proxy.java
+++ b/java/org/apache/catalina/ha/backend/Proxy.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
TcpSender.java
index 02e34621b2..191a19c554 100644
--- a/java/org/apache/catalina/ha/backend/Sender.java
+++ b/java/org/apache/catalina/ha/backend/Sender.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
ReplicatedContext.java
index 2ee0a202f1..6c78e10054 100644
--- a/java/org/apache/catalina/ha/backend/TcpSender.java
+++ b/java/org/apache/catalina/ha/backend/TcpSender.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -101,20 +101,20 @@ public class TcpSender
                         connections[i].bind(addrs);
                         addrs = new InetSocketAddress(proxies[i].address, proxies[i].port);
                         connections[i].connect(addrs);
-                    } else 
+                    } else
                         connections[i] = new Socket(proxies[i].address, proxies[i].port);
                     connectionReaders[i] = new BufferedReader(new InputStreamReader(connections[i].getInputStream()));
                     connectionWriters[i] = new BufferedWriter(new OutputStreamWriter(connections[i].getOutputStream()));
                 } catch (Exception ex) {
                     log.error("Unable to connect to proxy: " + ex);
                     close(i);
-                } 
+                }
             }
             if (connections[i] == null)
                 continue; // try next proxy in the list
             BufferedWriter writer = connectionWriters[i];
             try {
-                writer.write(requestLine); 
+                writer.write(requestLine);
                 writer.write("\r\n");
                 writer.write("Content-Length: " + mess.length() + "\r\n");
                 writer.write("User-Agent: HeartbeatListener/1.0\r\n");
@@ -126,10 +126,10 @@ public class TcpSender
             } catch (Exception ex) {
                 log.error("Unable to send collected load information to proxy: " + ex);
                 close(i);
-            } 
+            }
             if (connections[i] == null)
                 continue; // try next proxy in the list
-            
+
             /* Read httpd answer */
             String responseStatus = connectionReaders[i].readLine();
             if (responseStatus == null) {
@@ -172,7 +172,7 @@ public class TcpSender
                    }
                 }
             }
-               
+
         }
 
         return 0;

==================================================
Constants.java
index 952170d5e3..217d7bcd4e 100644
--- a/java/org/apache/catalina/ha/context/ReplicatedContext.java
+++ b/java/org/apache/catalina/ha/context/ReplicatedContext.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -43,7 +43,7 @@ public class ReplicatedContext extends StandardContext implements MapOwner {
     private int mapSendOptions = Channel.SEND_OPTIONS_DEFAULT;
     private static final Log log = LogFactory.getLog( ReplicatedContext.class );
     protected static long DEFAULT_REPL_TIMEOUT = 15000;//15 seconds
-    
+
     /**
      * Start this component and implement the requirements
      * of {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
@@ -70,7 +70,7 @@ public class ReplicatedContext extends StandardContext implements MapOwner {
             throw new LifecycleException("Failed to start ReplicatedContext",x);
         }
     }
-    
+
     /**
      * Stop this component and implement the requirements
      * of {@link org.apache.catalina.util.LifecycleBase#stopInternal()}.
@@ -80,7 +80,7 @@ public class ReplicatedContext extends StandardContext implements MapOwner {
      */
     @Override
     protected synchronized void stopInternal() throws LifecycleException {
-        
+
         super.stopInternal();
 
         AbstractMap<String,Object> map =
@@ -98,7 +98,7 @@ public class ReplicatedContext extends StandardContext implements MapOwner {
     public int getMapSendOptions() {
         return mapSendOptions;
     }
-    
+
     public ClassLoader[] getClassLoaders() {
         Loader loader = null;
         ClassLoader classLoader = null;
@@ -111,7 +111,7 @@ public class ReplicatedContext extends StandardContext implements MapOwner {
             return new ClassLoader[] {classLoader,Thread.currentThread().getContextClassLoader()};
         }
     }
-    
+
     @Override
     public ServletContext getServletContext() {
         if (context == null) {
@@ -124,38 +124,38 @@ public class ReplicatedContext extends StandardContext implements MapOwner {
 
     }
 
-    
+
     protected static class ReplApplContext extends ApplicationContext {
         protected ConcurrentHashMap<String, Object> tomcatAttributes =
             new ConcurrentHashMap<String, Object>();
-        
+
         public ReplApplContext(ReplicatedContext context) {
             super(context);
         }
-        
+
         protected ReplicatedContext getParent() {
             return (ReplicatedContext)getContext();
         }
-        
+
         @Override
         protected ServletContext getFacade() {
              return super.getFacade();
         }
-        
+
         public AbstractMap<String,Object> getAttributeMap() {
             return (AbstractMap<String,Object>)this.attributes;
         }
         public void setAttributeMap(AbstractMap<String,Object> map) {
             this.attributes = map;
         }
-        
+
         @Override
         public void removeAttribute(String name) {
             tomcatAttributes.remove(name);
             //do nothing
             super.removeAttribute(name);
         }
-        
+
         @Override
         public void setAttribute(String name, Object value) {
             if ( (!getParent().getState().isAvailable()) || "org.apache.jasper.runtime.JspApplicationContextImpl".equals(name) ){
@@ -163,15 +163,15 @@ public class ReplicatedContext extends StandardContext implements MapOwner {
             } else
                 super.setAttribute(name,value);
         }
-        
+
         @Override
         public Object getAttribute(String name) {
             if (tomcatAttributes.containsKey(name) )
                 return tomcatAttributes.get(name);
-            else 
+            else
                 return super.getAttribute(name);
         }
-        
+
         @SuppressWarnings("unchecked")
         @Override
         public Enumeration<String> getAttributeNames() {
@@ -179,7 +179,7 @@ public class ReplicatedContext extends StandardContext implements MapOwner {
                     super.getAttributeNames(),
                     new Enumerator<String>(tomcatAttributes.keySet(), true)});
         }
-        
+
     }
 
     protected static class MultiEnumeration<T> implements Enumeration<T> {
@@ -203,7 +203,7 @@ public class ReplicatedContext extends StandardContext implements MapOwner {
 
         }
     }
-    
+
     @Override
     public void objectMadePrimay(Object key, Object value) {
         //noop

==================================================
FarmWarDeployer.java
index 084c207fdb..9e85e27e41 100644
--- a/java/org/apache/catalina/ha/deploy/Constants.java
+++ b/java/org/apache/catalina/ha/deploy/Constants.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
FileChangeListener.java
index fce1654dbd..4d489e93ec 100644
--- a/java/org/apache/catalina/ha/deploy/FarmWarDeployer.java
+++ b/java/org/apache/catalina/ha/deploy/FarmWarDeployer.java
@@ -55,7 +55,7 @@ import org.apache.tomcat.util.res.StringManager;
  * </ul>
  * Currently we only support deployment of WAR files since they are easier to
  * send across the wire.
- * 
+ *
  * @author Filip Hanik
  * @author Peter Rossbach
  * @version $Revision$
@@ -135,12 +135,12 @@ public class FarmWarDeployer extends ClusterListener
             return ;
         }
         host = (Host) hcontainer;
-    
+
         // Check to correct engine and host setup
         Container econtainer = host.getParent();
         if(!(econtainer instanceof Engine)) {
             log.error(sm.getString("farmWarDeployer.hostParentEngine",
-                    host.getName())); 
+                    host.getName()));
             return ;
         }
         Engine engine = (Engine) econtainer;
@@ -161,7 +161,7 @@ public class FarmWarDeployer extends ClusterListener
                         "farmWarDeployer.watchDir", getWatchDir()));
             }
         }
-         
+
         configBase = new File(
                 System.getProperty(Globals.CATALINA_BASE_PROP), "conf");
         configBase = new File(configBase, engine.getName());
@@ -181,7 +181,7 @@ public class FarmWarDeployer extends ClusterListener
 
     /*
      * stop cluster wide deployments
-     * 
+     *
      * @see org.apache.catalina.ha.ClusterDeployer#stop()
      */
     @Override
@@ -206,7 +206,7 @@ public class FarmWarDeployer extends ClusterListener
     /**
      * Callback from the cluster, when a message is received, The cluster will
      * broadcast it invoking the messageReceived on the receiver.
-     * 
+     *
      * @param msg
      *            ClusterMessage - the message received from the cluster
      */
@@ -288,7 +288,7 @@ public class FarmWarDeployer extends ClusterListener
 
     /**
      * create factory for all transported war files
-     * 
+     *
      * @param msg
      * @return Factory for all app message (war files)
      * @throws java.io.FileNotFoundException
@@ -307,7 +307,7 @@ public class FarmWarDeployer extends ClusterListener
 
     /**
      * Remove file (war) from messages)
-     * 
+     *
      * @param msg
      */
     public void removeFactory(FileMessage msg) {
@@ -318,7 +318,7 @@ public class FarmWarDeployer extends ClusterListener
      * Before the cluster invokes messageReceived the cluster will ask the
      * receiver to accept or decline the message, In the future, when messages
      * get big, the accept method will only take a message header
-     * 
+     *
      * @param msg
      *            ClusterMessage
      * @return boolean - returns true to indicate that messageReceived should be
@@ -338,14 +338,14 @@ public class FarmWarDeployer extends ClusterListener
      * If this application is successfully installed locally, a ContainerEvent
      * of type <code>INSTALL_EVENT</code> will be sent to all registered
      * listeners, with the newly created <code>Context</code> as an argument.
-     * 
+     *
      * @param contextName
      *            The context name to which this application should be installed
      *            (must be unique)
      * @param webapp
      *            A WAR file or unpacked directory structure containing the web
      *            application to be installed
-     * 
+     *
      * @exception IllegalArgumentException
      *                if the specified context name is malformed
      * @exception IllegalStateException
@@ -387,12 +387,12 @@ public class FarmWarDeployer extends ClusterListener
      * listeners, with the removed <code>Context</code> as an argument.
      * Deletes the web application war file and/or directory if they exist in
      * the Host's appBase.
-     * 
+     *
      * @param contextName
      *            The context name of the application to be removed
      * @param undeploy
      *            boolean flag to remove web application from server
-     * 
+     *
      * @exception IllegalArgumentException
      *                if the specified context name is malformed
      * @exception IllegalArgumentException
@@ -437,7 +437,7 @@ public class FarmWarDeployer extends ClusterListener
 
     /*
      * Modification from watchDir war detected!
-     * 
+     *
      * @see org.apache.catalina.ha.deploy.FileChangeListener#fileModified(File)
      */
     @Override
@@ -462,7 +462,7 @@ public class FarmWarDeployer extends ClusterListener
 
     /*
      * War remove from watchDir
-     * 
+     *
      * @see org.apache.catalina.ha.deploy.FileChangeListener#fileRemoved(File)
      */
     @Override
@@ -514,7 +514,7 @@ public class FarmWarDeployer extends ClusterListener
     /**
      * Delete the specified directory, including all of its contents and
      * subdirectories recursively.
-     * 
+     *
      * @param dir
      *            File object representing the directory to be deleted
      */
@@ -541,7 +541,7 @@ public class FarmWarDeployer extends ClusterListener
 
     /*
      * Call watcher to check for deploy changes
-     * 
+     *
      * @see org.apache.catalina.ha.ClusterDeployer#backgroundProcess()
      */
     @Override
@@ -653,7 +653,7 @@ public class FarmWarDeployer extends ClusterListener
 
     /**
      * Set the watcher checks frequency.
-     * 
+     *
      * @param processExpiresFrequency
      *            the new manager checks frequency
      */

==================================================
FileMessage.java
index 4358cacb3d..cb5e026f73 100644
--- a/java/org/apache/catalina/ha/deploy/FileChangeListener.java
+++ b/java/org/apache/catalina/ha/deploy/FileChangeListener.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
FileMessageFactory.java
index f0303473fe..9fb67e819c 100644
--- a/java/org/apache/catalina/ha/deploy/FileMessage.java
+++ b/java/org/apache/catalina/ha/deploy/FileMessage.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -21,7 +21,7 @@ import org.apache.catalina.ha.ClusterMessageBase;
 import org.apache.catalina.tribes.Member;
 
 /**
- * Contains the data for a file being transferred over TCP, this is 
+ * Contains the data for a file being transferred over TCP, this is
  * essentially a fragment of a file, read and written by the FileMessageFactory
  * @author Filip Hanik
  * @version 1.0
@@ -33,12 +33,12 @@ public class FileMessage extends ClusterMessageBase {
     private int messageNumber;
     private byte[] data;
     private int dataLength;
-    
+
     private long totalLength;
     private long totalNrOfMsgs;
     private String fileName;
     private String contextName;
-    
+
     public FileMessage(Member source,
                        String fileName,
                        String contextName) {
@@ -46,17 +46,17 @@ public class FileMessage extends ClusterMessageBase {
         this.fileName=fileName;
         this.contextName=contextName;
     }
-    
+
     /*
     public void writeExternal(ObjectOutput out) throws IOException {
-                   
+
     }
-    
+
     public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
-                  
+
     }
     */
-   
+
     public int getMessageNumber() {
         return messageNumber;
     }
@@ -99,7 +99,7 @@ public class FileMessage extends ClusterMessageBase {
         return result.toString();
     }
 
-    
+
     public String getFileName() {
         return fileName;
     }
@@ -109,5 +109,5 @@ public class FileMessage extends ClusterMessageBase {
     public String getContextName() {
         return contextName;
     }
-    
+
 }

==================================================
UndeployMessage.java
index 8550c20da2..1b8ade4075 100644
--- a/java/org/apache/catalina/ha/deploy/LocalStrings.properties
+++ b/java/org/apache/catalina/ha/deploy/LocalStrings.properties
@@ -21,7 +21,7 @@ farmWarDeployer.fileCopyFail=Unable to copy from [{0}] to [{1}]
 farmWarDeployer.hostOnly=FarmWarDeployer can only work as host cluster subelement!
 farmWarDeployer.hostParentEngine=FarmWarDeployer can only work if parent of [{0}] is an engine!
 farmWarDeployer.mbeanNameFail=Can't construct MBean object name for engine [{0}] and host [{1}]
-farmWarDeployer.modInstall=Installing webapp [{0}] from [{1}] 
+farmWarDeployer.modInstall=Installing webapp [{0}] from [{1}]
 farmWarDeployer.modRemoveFail=No removal
 farmWarDeployer.modInstallFail=Unable to install WAR file
 farmWarDeployer.msgIoe=Unable to read farm deploy file message.

==================================================
WarWatcher.java
index 33d6e58ede..979626330e 100644
--- a/java/org/apache/catalina/ha/deploy/UndeployMessage.java
+++ b/java/org/apache/catalina/ha/deploy/UndeployMessage.java
@@ -92,7 +92,7 @@ public class UndeployMessage implements ClusterMessage {
     }
     /**
      * @return Returns the compress.
-     * @since 5.5.10 
+     * @since 5.5.10
      */
     public int getCompress() {
         return compress;

==================================================
ClusterJmxHelper.java
index 2e7cfaf68d..6471877e45 100644
--- a/java/org/apache/catalina/ha/deploy/WarWatcher.java
+++ b/java/org/apache/catalina/ha/deploy/WarWatcher.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -31,7 +31,7 @@ import org.apache.juli.logging.LogFactory;
  * directory (adding new WAR files->deploy or remove WAR files->undeploy) And
  * notifies a listener of the changes made
  * </p>
- * 
+ *
  * @author Filip Hanik
  * @author Peter Rossbach
  * @version 1.1
@@ -194,7 +194,7 @@ public class WarWatcher {
         /**
          * Returns 1 if the file has been added/modified, 0 if the file is
          * unchanged and -1 if the file has been removed
-         * 
+         *
          * @return int 1=file added; 0=unchanged; -1=file removed
          */
         public int check() {

==================================================
BackupManager.java
index 3b0a173404..dddd159a5c 100644
--- a/java/org/apache/catalina/ha/jmx/ClusterJmxHelper.java
+++ b/java/org/apache/catalina/ha/jmx/ClusterJmxHelper.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -32,19 +32,19 @@ import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.modeler.ManagedBean;
 import org.apache.tomcat.util.modeler.Registry;
 /**
- * 
+ *
  * @author Filip Hanik
  */
 public class ClusterJmxHelper {
-    
+
     protected static Registry registry = Registry.getRegistry(null,null);
-    
+
     private static final Log log = LogFactory.getLog(ClusterJmxHelper.class);
-    
+
     protected static boolean jmxEnabled = true;
-    
+
     protected static MBeanServer mbeanServer = null;
-    
+
     public static Registry getRegistry() {
         return registry;
     }
@@ -59,7 +59,7 @@ public class ClusterJmxHelper {
         }
         return mbeanServer;
     }
-    
+
     protected static boolean initMetaData(Class<?> clazz) {
         try {
             if (clazz==null) return false;
@@ -70,7 +70,7 @@ public class ClusterJmxHelper {
         }
         return true;
     }
-    
+
     public static DynamicMBean getManagedBean(Object object) throws Exception {
         DynamicMBean mbean = null;
         if (getRegistry() != null) {
@@ -80,14 +80,14 @@ public class ClusterJmxHelper {
         return mbean;
     }
 
-    
+
     protected static void initDefaultCluster() {
         initMetaData(SimpleTcpCluster.class);
         initMetaData(DeltaManager.class);
         initMetaData(FarmWarDeployer.class); //not functional yet
         initMetaData(ClusterSingleSignOn.class); //not functional yet
     }
-    
+
     public static boolean registerDefaultCluster(SimpleTcpCluster cluster)  {
         try {
             initDefaultCluster();
@@ -130,5 +130,5 @@ public class ClusterJmxHelper {
         ObjectName clusterName = new ObjectName(domain + clusterType);
         return clusterName;
     }
-    
+
 }
\ No newline at end of file

==================================================
ClusterManagerBase.java
index 26c3d7d966..17932eeb2c 100644
--- a/java/org/apache/catalina/ha/session/BackupManager.java
+++ b/java/org/apache/catalina/ha/session/BackupManager.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -45,14 +45,14 @@ public class BackupManager extends ClusterManagerBase
 
     /** Set to true if we don't want the sessions to expire on shutdown */
     protected boolean mExpireSessionsOnShutdown = true;
-    
+
     /**
      * The name of this manager
      */
     protected String name;
 
     /**
-     * 
+     *
      */
     private int mapSendOptions = Channel.SEND_OPTIONS_SYNCHRONIZED_ACK|Channel.SEND_OPTIONS_USE_ACK;
 
@@ -71,7 +71,7 @@ public class BackupManager extends ClusterManagerBase
 
 
 //******************************************************************************/
-//      ClusterManager Interface     
+//      ClusterManager Interface
 //******************************************************************************/
 
     @Override
@@ -117,7 +117,7 @@ public class BackupManager extends ClusterManagerBase
     public Session createEmptySession() {
         return new DeltaSession(this);
     }
-    
+
 
     @Override
     public String getName() {
@@ -132,13 +132,13 @@ public class BackupManager extends ClusterManagerBase
      * Starts the cluster communication channel, this will connect with the
      * other nodes in the cluster, and request the current session state to be
      * transferred to this node.
-     * 
+     *
      * @exception LifecycleException if this component detects a fatal error
      *  that prevents this component from being used
      */
     @Override
     protected synchronized void startInternal() throws LifecycleException {
-        
+
         super.startInternal();
 
         try {
@@ -156,7 +156,7 @@ public class BackupManager extends ClusterManagerBase
         }
         setState(LifecycleState.STARTING);
     }
-    
+
     public String getMapName() {
         String name = cluster.getManagerName(getName(),this)+"-"+"map";
         if ( log.isDebugEnabled() ) log.debug("Backup manager, Setting map name to:"+name);
@@ -167,7 +167,7 @@ public class BackupManager extends ClusterManagerBase
     /**
      * Stop this component and implement the requirements
      * of {@link org.apache.catalina.util.LifecycleBase#stopInternal()}.
-     * 
+     *
      * This will disconnect the cluster communication channel and stop the
      * listener thread.
      *
@@ -221,7 +221,7 @@ public class BackupManager extends ClusterManagerBase
     public String[] getInvalidatedSessions() {
         return new String[0];
     }
-    
+
     @Override
     public ClusterManager cloneFromTemplate() {
         BackupManager result = new BackupManager();

==================================================
ClusterSessionListener.java
index 542f94d559..4032b6b0cd 100644
--- a/java/org/apache/catalina/ha/session/ClusterManagerBase.java
+++ b/java/org/apache/catalina/ha/session/ClusterManagerBase.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -29,7 +29,7 @@ import org.apache.catalina.session.ManagerBase;
 import org.apache.catalina.tribes.io.ReplicationStream;
 
 /**
- * 
+ *
  * @author Filip Hanik
  * @version $Id$
  */
@@ -61,7 +61,7 @@ public abstract class ClusterManagerBase extends ManagerBase
      */
     private Pattern sessionAttributePattern = null;
 
-    /* 
+    /*
      * @see org.apache.catalina.ha.ClusterManager#getCluster()
      */
     @Override
@@ -147,7 +147,7 @@ public abstract class ClusterManagerBase extends ManagerBase
     /**
      * Open Stream and use correct ClassLoader (Container) Switch
      * ThreadClassLoader
-     * 
+     *
      * @param data
      * @return The object input stream
      * @throws IOException
@@ -161,7 +161,7 @@ public abstract class ClusterManagerBase extends ManagerBase
     public ReplicationStream getReplicationStream(byte[] data, int offset, int length) throws IOException {
         ByteArrayInputStream fis = new ByteArrayInputStream(data, offset, length);
         return new ReplicationStream(fis, getClassLoaders());
-    }    
+    }
 
 
     //  ---------------------------------------------------- persistence handler
@@ -172,7 +172,7 @@ public abstract class ClusterManagerBase extends ManagerBase
      */
     @Override
     public void load() {
-        // NOOP 
+        // NOOP
     }
 
     @Override

==================================================
Constants.java
index 13e9a89740..598f109790 100644
--- a/java/org/apache/catalina/ha/session/ClusterSessionListener.java
+++ b/java/org/apache/catalina/ha/session/ClusterSessionListener.java
@@ -35,7 +35,7 @@ public class ClusterSessionListener extends ClusterListener {
 
     private static final Log log =
         LogFactory.getLog(ClusterSessionListener.class);
-    
+
     //--Constructor---------------------------------------------
 
     public ClusterSessionListener() {
@@ -47,7 +47,7 @@ public class ClusterSessionListener extends ClusterListener {
     /**
      * Callback from the cluster, when a message is received, The cluster will
      * broadcast it invoking the messageReceived on the receiver.
-     * 
+     *
      * @param myobj
      *            ClusterMessage - the message received from the cluster
      */
@@ -85,7 +85,7 @@ public class ClusterSessionListener extends ClusterListener {
 
     /**
      * Accept only SessionMessage
-     * 
+     *
      * @param msg
      *            ClusterMessage
      * @return boolean - returns true to indicate that messageReceived should be

==================================================
DeltaManager.java
index 6fe996b57f..27dcf47478 100644
--- a/java/org/apache/catalina/ha/session/Constants.java
+++ b/java/org/apache/catalina/ha/session/Constants.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
DeltaRequest.java
index 965341f167..45b6731711 100644
--- a/java/org/apache/catalina/ha/session/DeltaManager.java
+++ b/java/org/apache/catalina/ha/session/DeltaManager.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -50,14 +50,14 @@ import org.apache.tomcat.util.res.StringManager;
  * The DeltaManager manages replicated sessions by only replicating the deltas
  * in data. For applications written to handle this, the DeltaManager is the
  * optimal way of replicating data.
- * 
+ *
  * This code is almost identical to StandardManager with a difference in how it
  * persists sessions and some modifications to it.
- * 
+ *
  * <b>IMPLEMENTATION NOTE </b>: Correct behavior of session storing and
  * reloading depends upon external calls to the <code>start()</code> and
  * <code>stop()</code> methods of this class at the correct times.
- * 
+ *
  * @author Filip Hanik
  * @author Craig R. McClanahan
  * @author Jean-Francois Arcand
@@ -87,7 +87,7 @@ public class DeltaManager extends ClusterManagerBase{
      * cached replication valve cluster container!
      */
     private volatile ReplicationValve replicationValve = null ;
-    
+
     private boolean expireSessionsOnShutdown = false;
     private boolean notifySessionListenersOnReplication = true;
     private boolean notifyContainerListenersOnReplication  = true;
@@ -95,19 +95,19 @@ public class DeltaManager extends ClusterManagerBase{
     private int stateTransferTimeout = 60;
     private boolean sendAllSessions = true;
     private int sendAllSessionsSize = 1000 ;
-    
+
     /**
-     * wait time between send session block (default 2 sec) 
+     * wait time between send session block (default 2 sec)
      */
-    private int sendAllSessionsWaitTime = 2 * 1000 ; 
+    private int sendAllSessionsWaitTime = 2 * 1000 ;
     private ArrayList<SessionMessage> receivedMessageQueue =
         new ArrayList<SessionMessage>() ;
     private boolean receiverQueue = false ;
     private boolean stateTimestampDrop = true ;
-    private long stateTransferCreateSendTime; 
-    
+    private long stateTransferCreateSendTime;
+
     // ------------------------------------------------------------------ stats attributes
-    
+
     private long sessionReplaceCounter = 0 ;
     private long counterReceive_EVT_GET_ALL_SESSIONS = 0 ;
     private long counterReceive_EVT_ALL_SESSION_DATA = 0 ;
@@ -133,7 +133,7 @@ public class DeltaManager extends ClusterManagerBase{
     }
 
     // ------------------------------------------------------------- Properties
-    
+
     @Override
     public void setName(String name) {
         this.name = name;
@@ -153,14 +153,14 @@ public class DeltaManager extends ClusterManagerBase{
     public long getCounterSend_EVT_GET_ALL_SESSIONS() {
         return counterSend_EVT_GET_ALL_SESSIONS;
     }
-    
+
     /**
      * @return Returns the counterSend_EVT_SESSION_ACCESSED.
      */
     public long getCounterSend_EVT_SESSION_ACCESSED() {
         return counterSend_EVT_SESSION_ACCESSED;
     }
-    
+
     /**
      * @return Returns the counterSend_EVT_SESSION_CREATED.
      */
@@ -181,7 +181,7 @@ public class DeltaManager extends ClusterManagerBase{
     public long getCounterSend_EVT_SESSION_EXPIRED() {
         return counterSend_EVT_SESSION_EXPIRED;
     }
- 
+
     /**
      * @return Returns the counterSend_EVT_ALL_SESSION_DATA.
      */
@@ -209,43 +209,43 @@ public class DeltaManager extends ClusterManagerBase{
     public long getCounterReceive_EVT_ALL_SESSION_DATA() {
         return counterReceive_EVT_ALL_SESSION_DATA;
     }
-    
+
     /**
      * @return Returns the counterReceive_EVT_GET_ALL_SESSIONS.
      */
     public long getCounterReceive_EVT_GET_ALL_SESSIONS() {
         return counterReceive_EVT_GET_ALL_SESSIONS;
     }
-    
+
     /**
      * @return Returns the counterReceive_EVT_SESSION_ACCESSED.
      */
     public long getCounterReceive_EVT_SESSION_ACCESSED() {
         return counterReceive_EVT_SESSION_ACCESSED;
     }
-    
+
     /**
      * @return Returns the counterReceive_EVT_SESSION_CREATED.
      */
     public long getCounterReceive_EVT_SESSION_CREATED() {
         return counterReceive_EVT_SESSION_CREATED;
     }
-    
+
     /**
      * @return Returns the counterReceive_EVT_SESSION_DELTA.
      */
     public long getCounterReceive_EVT_SESSION_DELTA() {
         return counterReceive_EVT_SESSION_DELTA;
     }
-    
+
     /**
      * @return Returns the counterReceive_EVT_SESSION_EXPIRED.
      */
     public long getCounterReceive_EVT_SESSION_EXPIRED() {
         return counterReceive_EVT_SESSION_EXPIRED;
     }
-    
-    
+
+
     /**
      * @return Returns the counterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE.
      */
@@ -259,7 +259,7 @@ public class DeltaManager extends ClusterManagerBase{
     public long getCounterReceive_EVT_CHANGE_SESSION_ID() {
         return counterReceive_EVT_CHANGE_SESSION_ID;
     }
-    
+
     /**
      * @return Returns the processingTime.
      */
@@ -267,25 +267,25 @@ public class DeltaManager extends ClusterManagerBase{
     public long getProcessingTime() {
         return processingTime;
     }
- 
+
     /**
      * @return Returns the sessionReplaceCounter.
      */
     public long getSessionReplaceCounter() {
         return sessionReplaceCounter;
     }
-    
+
     /**
      * @return Returns the counterNoStateTransfered.
      */
     public int getCounterNoStateTransfered() {
         return counterNoStateTransfered;
     }
-    
+
     public int getReceivedQueueSize() {
         return receivedMessageQueue.size() ;
     }
-    
+
     /**
      * @return Returns the stateTransferTimeout.
      */
@@ -301,92 +301,92 @@ public class DeltaManager extends ClusterManagerBase{
 
     /**
      * is session state transfered complete?
-     * 
+     *
      */
     public boolean getStateTransfered() {
         return stateTransfered;
     }
 
     /**
-     * set that state ist complete transfered  
+     * set that state ist complete transfered
      * @param stateTransfered
      */
     public void setStateTransfered(boolean stateTransfered) {
         this.stateTransfered = stateTransfered;
     }
-    
+
     /**
      * @return Returns the sendAllSessionsWaitTime in msec
      */
     public int getSendAllSessionsWaitTime() {
         return sendAllSessionsWaitTime;
     }
-    
+
     /**
      * @param sendAllSessionsWaitTime The sendAllSessionsWaitTime to set at msec.
      */
     public void setSendAllSessionsWaitTime(int sendAllSessionsWaitTime) {
         this.sendAllSessionsWaitTime = sendAllSessionsWaitTime;
     }
-    
+
     /**
      * @return Returns the stateTimestampDrop.
      */
     public boolean isStateTimestampDrop() {
         return stateTimestampDrop;
     }
-    
+
     /**
      * @param isTimestampDrop The new flag value
      */
     public void setStateTimestampDrop(boolean isTimestampDrop) {
         this.stateTimestampDrop = isTimestampDrop;
     }
-    
+
     /**
-     * 
+     *
      * @return Returns the sendAllSessions.
      */
     public boolean isSendAllSessions() {
         return sendAllSessions;
     }
-    
+
     /**
      * @param sendAllSessions The sendAllSessions to set.
      */
     public void setSendAllSessions(boolean sendAllSessions) {
         this.sendAllSessions = sendAllSessions;
     }
-    
+
     /**
      * @return Returns the sendAllSessionsSize.
      */
     public int getSendAllSessionsSize() {
         return sendAllSessionsSize;
     }
-    
+
     /**
      * @param sendAllSessionsSize The sendAllSessionsSize to set.
      */
     public void setSendAllSessionsSize(int sendAllSessionsSize) {
         this.sendAllSessionsSize = sendAllSessionsSize;
     }
-    
+
     /**
      * @return Returns the notifySessionListenersOnReplication.
      */
     public boolean isNotifySessionListenersOnReplication() {
         return notifySessionListenersOnReplication;
     }
-    
+
     /**
      * @param notifyListenersCreateSessionOnReplication The notifySessionListenersOnReplication to set.
      */
     public void setNotifySessionListenersOnReplication(boolean notifyListenersCreateSessionOnReplication) {
         this.notifySessionListenersOnReplication = notifyListenersCreateSessionOnReplication;
     }
-    
-    
+
+
     public boolean isExpireSessionsOnShutdown() {
         return expireSessionsOnShutdown;
     }
@@ -394,7 +394,7 @@ public class DeltaManager extends ClusterManagerBase{
     public void setExpireSessionsOnShutdown(boolean expireSessionsOnShutdown) {
         this.expireSessionsOnShutdown = expireSessionsOnShutdown;
     }
-    
+
     public boolean isNotifyContainerListenersOnReplication() {
         return notifyContainerListenersOnReplication;
     }
@@ -403,7 +403,7 @@ public class DeltaManager extends ClusterManagerBase{
             boolean notifyContainerListenersOnReplication) {
         this.notifyContainerListenersOnReplication = notifyContainerListenersOnReplication;
     }
-    
+
     // --------------------------------------------------------- Public Methods
 
     /**
@@ -412,16 +412,16 @@ public class DeltaManager extends ClusterManagerBase{
      * by this method, and available via the getId() method of the returned
      * session. If a new session cannot be created for any reason, return
      * <code>null</code>.
-     * 
+     *
      * @exception IllegalStateException
      *                if a new session cannot be instantiated for any reason
-     * 
+     *
      * Construct and return a new session object, based on the default settings
      * specified by this Manager's properties. The session id will be assigned
      * by this method, and available via the getId() method of the returned
      * session. If a new session cannot be created for any reason, return
      * <code>null</code>.
-     * 
+     *
      * @exception IllegalStateException
      *                if a new session cannot be instantiated for any reason
      */
@@ -433,7 +433,7 @@ public class DeltaManager extends ClusterManagerBase{
     /**
      * create new session with check maxActiveSessions and send session creation
      * to other cluster nodes.
-     * 
+     *
      * @param distribute
      * @return The session
      */
@@ -455,10 +455,10 @@ public class DeltaManager extends ClusterManagerBase{
      */
     protected void sendCreateSession(String sessionId, DeltaSession session) {
         if(cluster.getMembers().length > 0 ) {
-            SessionMessage msg = 
+            SessionMessage msg =
                 new SessionMessageImpl(getName(),
-                                       SessionMessage.EVT_SESSION_CREATED, 
-                                       null, 
+                                       SessionMessage.EVT_SESSION_CREATED,
+                                       null,
                                        sessionId,
                                        sessionId + "-" + System.currentTimeMillis());
             if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.sendMessage.newSession",name, sessionId));
@@ -467,7 +467,7 @@ public class DeltaManager extends ClusterManagerBase{
             send(msg);
         }
     }
-    
+
     /**
      * Send messages to other backup member (domain or all)
      * @param msg Session message
@@ -486,7 +486,7 @@ public class DeltaManager extends ClusterManagerBase{
     public Session createEmptySession() {
         return getNewDeltaSession() ;
     }
-    
+
     /**
      * Get new session class to be used in the doLoad() method.
      */
@@ -497,7 +497,7 @@ public class DeltaManager extends ClusterManagerBase{
     /**
      * Change the session ID of the current session to a new randomly generated
      * session ID.
-     * 
+     *
      * @param session   The session to change the session ID for
      */
     @Override
@@ -579,7 +579,7 @@ public class DeltaManager extends ClusterManagerBase{
     /**
      * serialize DeltaRequest
      * @see DeltaRequest#writeExternal(java.io.ObjectOutput)
-     * 
+     *
      * @param deltaRequest
      * @return serialized delta request
      * @throws IOException
@@ -667,7 +667,7 @@ public class DeltaManager extends ClusterManagerBase{
      * Save any currently active sessions in the appropriate persistence
      * mechanism, if any. If persistence is not supported, this method returns
      * without doing anything.
-     * 
+     *
      * @exception IOException
      *                if an input/output error occurs
      */
@@ -682,7 +682,7 @@ public class DeltaManager extends ClusterManagerBase{
             oos = new ObjectOutputStream(new BufferedOutputStream(fos));
             oos.writeObject(Integer.valueOf(currentSessions.length));
             for(int i=0 ; i < currentSessions.length;i++) {
-                ((DeltaSession)currentSessions[i]).writeObjectData(oos);                
+                ((DeltaSession)currentSessions[i]).writeObjectData(oos);
             }
             // Flush and close the output stream
             oos.flush();
@@ -768,7 +768,7 @@ public class DeltaManager extends ClusterManagerBase{
             ExceptionUtils.handleThrowable(t);
             log.error(sm.getString("deltaManager.managerLoad"), t);
         }
-        
+
         setState(LifecycleState.STARTING);
     }
 
@@ -815,7 +815,7 @@ public class DeltaManager extends ClusterManagerBase{
                                 }
                             }
                         }
-                    }        
+                    }
                     receivedMessageQueue.clear();
                     receiverQueue = false ;
                 }
@@ -842,7 +842,7 @@ public class DeltaManager extends ClusterManagerBase{
 
                         if(replicationValve == null && log.isDebugEnabled()) {
                             log.debug("no ReplicationValve found for CrossContext Support");
-                        }//endif 
+                        }//endif
                     }//end if
                 }//endif
             }//end if
@@ -851,10 +851,10 @@ public class DeltaManager extends ClusterManagerBase{
             replicationValve.registerReplicationSession(session);
         }
     }
-    
+
     /**
      * Find the master of the session state
-     * @return master member of sessions 
+     * @return master member of sessions
      */
     protected Member findSessionMasterMember() {
         Member mbr = null;
@@ -919,7 +919,7 @@ public class DeltaManager extends ClusterManagerBase{
             log.debug(sm.getString("deltaManager.stopped", getName()));
 
         setState(LifecycleState.STOPPING);
-        
+
         // Expire all active sessions
         if (log.isInfoEnabled()) log.info(sm.getString("deltaManager.expireSessions", getName()));
         Session sessions[] = findSessions();
@@ -931,7 +931,7 @@ public class DeltaManager extends ClusterManagerBase{
                 session.expire(true, isExpireSessionsOnShutdown());
             } catch (Throwable t) {
                 ExceptionUtils.handleThrowable(t);
-            } 
+            }
         }
 
         // Require a new random number generator if we are restarted
@@ -946,7 +946,7 @@ public class DeltaManager extends ClusterManagerBase{
     /**
      * A message was received from another node, this is the callback method to
      * implement if you are interested in receiving replication messages.
-     * 
+     *
      * @param cmsg -
      *            the message received.
      */
@@ -956,8 +956,8 @@ public class DeltaManager extends ClusterManagerBase{
             SessionMessage msg = (SessionMessage) cmsg;
             switch (msg.getEventType()) {
                 case SessionMessage.EVT_GET_ALL_SESSIONS:
-                case SessionMessage.EVT_SESSION_CREATED: 
-                case SessionMessage.EVT_SESSION_EXPIRED: 
+                case SessionMessage.EVT_SESSION_CREATED:
+                case SessionMessage.EVT_SESSION_EXPIRED:
                 case SessionMessage.EVT_SESSION_ACCESSED:
                 case SessionMessage.EVT_SESSION_DELTA:
                 case SessionMessage.EVT_CHANGE_SESSION_ID: {
@@ -974,7 +974,7 @@ public class DeltaManager extends ClusterManagerBase{
                     break;
                 }
             } //switch
-            
+
             messageReceived(msg, msg.getAddress() != null ? (Member) msg.getAddress() : null);
         }
     }
@@ -985,7 +985,7 @@ public class DeltaManager extends ClusterManagerBase{
      * needed or not. If there is a need for replication, the manager will
      * create a session message and that will be replicated. The cluster
      * determines where it gets sent.
-     * 
+     *
      * @param sessionId -
      *            the sessionId that just completed.
      * @return a SessionMessage to be sent,
@@ -1001,9 +1001,9 @@ public class DeltaManager extends ClusterManagerBase{
       * needed or not. If there is a need for replication, the manager will
       * create a session message and that will be replicated. The cluster
       * determines where it gets sent.
-      * 
+      *
       * Session expiration also calls this method, but with expires == true.
-      * 
+      *
       * @param sessionId -
       *            the sessionId that just completed.
       * @param expires -
@@ -1025,29 +1025,29 @@ public class DeltaManager extends ClusterManagerBase{
             boolean isDeltaRequest = false ;
             synchronized(deltaRequest) {
                 isDeltaRequest = deltaRequest.getSize() > 0 ;
-                if (isDeltaRequest) {    
+                if (isDeltaRequest) {
                     counterSend_EVT_SESSION_DELTA++;
                     byte[] data = serializeDeltaRequest(session,deltaRequest);
                     msg = new SessionMessageImpl(getName(),
-                                                 SessionMessage.EVT_SESSION_DELTA, 
-                                                 data, 
+                                                 SessionMessage.EVT_SESSION_DELTA,
+                                                 data,
                                                  sessionId,
                                                  sessionId + "-" + System.currentTimeMillis());
                     session.resetDeltaRequest();
-                }  
+                }
             }
             if(!isDeltaRequest) {
                 if(!expires && !session.isPrimarySession()) {
                     counterSend_EVT_SESSION_ACCESSED++;
                     msg = new SessionMessageImpl(getName(),
-                                                 SessionMessage.EVT_SESSION_ACCESSED, 
-                                                 null, 
+                                                 SessionMessage.EVT_SESSION_ACCESSED,
+                                                 null,
                                                  sessionId,
                                                  sessionId + "-" + System.currentTimeMillis());
                     if (log.isDebugEnabled()) {
                         log.debug(sm.getString("deltaManager.createMessage.accessChangePrimary",getName(), sessionId));
                     }
-                }    
+                }
             } else { // log only outside synch block!
                 if (log.isDebugEnabled()) {
                     log.debug(sm.getString("deltaManager.createMessage.delta",getName(), sessionId));
@@ -1058,13 +1058,13 @@ public class DeltaManager extends ClusterManagerBase{
             //check to see if we need to send out an access message
             if (!expires && (msg == null)) {
                 long replDelta = System.currentTimeMillis() - session.getLastTimeReplicated();
-                if (session.getMaxInactiveInterval() >=0 && 
+                if (session.getMaxInactiveInterval() >=0 &&
                         replDelta > (session.getMaxInactiveInterval() * 1000)) {
                     counterSend_EVT_SESSION_ACCESSED++;
                     msg = new SessionMessageImpl(getName(),
-                                                 SessionMessage.EVT_SESSION_ACCESSED, 
+                                                 SessionMessage.EVT_SESSION_ACCESSED,
                                                  null,
-                                                 sessionId, 
+                                                 sessionId,
                                                  sessionId + "-" + System.currentTimeMillis());
                     if (log.isDebugEnabled()) {
                         log.debug(sm.getString("deltaManager.createMessage.access", getName(),sessionId));
@@ -1128,14 +1128,14 @@ public class DeltaManager extends ClusterManagerBase{
         counterSend_EVT_SESSION_EXPIRED = 0 ;
         counterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE = 0;
         counterSend_EVT_CHANGE_SESSION_ID = 0;
-        
+
     }
-   
+
     //  -------------------------------------------------------- expire
 
     /**
      * send session expired to other cluster nodes
-     * 
+     *
      * @param id
      *            session id
      */
@@ -1156,7 +1156,7 @@ public class DeltaManager extends ClusterManagerBase{
         Session sessions[] = findSessions();
         int expireDirect  = 0 ;
         int expireIndirect = 0 ;
-        
+
         if(log.isDebugEnabled()) log.debug("Start expire all sessions " + getName() + " at " + timeNow + " sessioncount " + sessions.length);
         for (int i = 0; i < sessions.length; i++) {
             if (sessions[i] instanceof DeltaSession) {
@@ -1173,14 +1173,14 @@ public class DeltaManager extends ClusterManagerBase{
         }//for
         long timeEnd = System.currentTimeMillis();
         if(log.isDebugEnabled()) log.debug("End expire sessions " + getName() + " exipre processingTime " + (timeEnd - timeNow) + " expired direct sessions: " + expireDirect + " expired direct sessions: " + expireIndirect);
-      
+
     }
-    
+
     /**
      * When the manager expires session not tied to a request. The cluster will
      * periodically ask for a list of sessions that should expire and that
      * should be sent across the wire.
-     * 
+     *
      * @return The invalidated sessions array
      */
     @Override
@@ -1197,8 +1197,8 @@ public class DeltaManager extends ClusterManagerBase{
         boolean sameDomain= true;
         if (!sameDomain && log.isWarnEnabled()) {
                 log.warn(sm.getString("deltaManager.receiveMessage.fromWrongDomain",
-                         new Object[] {getName(), 
-                         msg.getEventTypeString(), 
+                         new Object[] {getName(),
+                         msg.getEventTypeString(),
                          sender,
                          "",
                          "" }));
@@ -1209,7 +1209,7 @@ public class DeltaManager extends ClusterManagerBase{
     /**
      * This method is called by the received thread when a SessionMessage has
      * been received from one of the other nodes in the cluster.
-     * 
+     *
      * @param msg -
      *            the message received
      * @param sender -
@@ -1223,11 +1223,11 @@ public class DeltaManager extends ClusterManagerBase{
         }
         ClassLoader contextLoader = Thread.currentThread().getContextClassLoader();
         try {
-            
+
             ClassLoader[] loaders = getClassLoaders();
             if ( loaders != null && loaders.length > 0) Thread.currentThread().setContextClassLoader(loaders[0]);
             if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.eventType",getName(), msg.getEventTypeString(), sender));
- 
+
             switch (msg.getEventType()) {
                 case SessionMessage.EVT_GET_ALL_SESSIONS: {
                     handleGET_ALL_SESSIONS(msg,sender);
@@ -1416,7 +1416,7 @@ public class DeltaManager extends ClusterManagerBase{
                 }//end if
             }//for
         }//end if
-        
+
         SessionMessage newmsg = new SessionMessageImpl(name,SessionMessage.EVT_ALL_SESSION_TRANSFERCOMPLETE, null,"SESSION-STATE-TRANSFERED", "SESSION-STATE-TRANSFERED"+ getName());
         newmsg.setTimestamp(findSessionTimestamp);
         if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.createMessage.allSessionTransfered",getName()));
@@ -1472,10 +1472,10 @@ public class DeltaManager extends ClusterManagerBase{
         result.stateTransferTimeout = stateTransferTimeout;
         result.sendAllSessions = sendAllSessions;
         result.sendAllSessionsSize = sendAllSessionsSize;
-        result.sendAllSessionsWaitTime = sendAllSessionsWaitTime ; 
+        result.sendAllSessionsWaitTime = sendAllSessionsWaitTime ;
         result.receiverQueue = receiverQueue ;
         result.stateTimestampDrop = stateTimestampDrop ;
-        result.stateTransferCreateSendTime = stateTransferCreateSendTime; 
+        result.stateTransferCreateSendTime = stateTransferCreateSendTime;
         return result;
     }
 }

==================================================
DeltaSession.java
index 6f02cdd094..1ecd3efabf 100644
--- a/java/org/apache/catalina/ha/session/DeltaRequest.java
+++ b/java/org/apache/catalina/ha/session/DeltaRequest.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -20,7 +20,7 @@ package org.apache.catalina.ha.session;
 
 /**
  * This class is used to track the series of actions that happens when
- * a request is executed. These actions will then translate into invocations of methods 
+ * a request is executed. These actions will then translate into invocations of methods
  * on the actual session.
  * This class is NOT thread safe. One DeltaRequest per session
  * @author <a href="mailto:fhanik@apache.org">Filip Hanik</a>
@@ -67,13 +67,13 @@ public class DeltaRequest implements Externalizable {
     private LinkedList<AttributeInfo> actions = new LinkedList<AttributeInfo>();
     private LinkedList<AttributeInfo> actionPool =
         new LinkedList<AttributeInfo>();
-    
+
     private boolean recordAllActions = false;
 
     public DeltaRequest() {
-        
+
     }
-    
+
     public DeltaRequest(String sessionId, boolean recordAllActions) {
         this.recordAllActions=recordAllActions;
         if(sessionId != null)
@@ -95,7 +95,7 @@ public class DeltaRequest implements Externalizable {
         int action = ACTION_SET;
         addAction(TYPE_MAXINTERVAL,action,NAME_MAXINTERVAL,Integer.valueOf(interval));
     }
-    
+
     /**
      * convert principal at SerializablePrincipal for backup nodes.
      * Only support principals from type {@link GenericPrincipal GenericPrincipal}
@@ -154,7 +154,7 @@ public class DeltaRequest implements Externalizable {
         //add the action
         actions.addLast(info);
     }
-    
+
     public void execute(DeltaSession session, boolean notifyListeners) {
         if ( !this.sessionId.equals( session.getId() ) )
             throw new java.lang.IllegalArgumentException("Session id mismatch, not executing the delta request");
@@ -170,7 +170,7 @@ public class DeltaRequest implements Externalizable {
                         if ( log.isTraceEnabled() ) log.trace("Session.removeAttribute('"+info.getName()+"')");
                         session.removeAttribute(info.getName(),notifyListeners,false);
                     }
-                        
+
                     break;
                 }//case
                 case TYPE_ISNEW: {
@@ -219,7 +219,7 @@ public class DeltaRequest implements Externalizable {
         }
         actions.clear();
     }
-    
+
     public String getSessionId() {
         return sessionId;
     }
@@ -232,12 +232,12 @@ public class DeltaRequest implements Externalizable {
     public int getSize() {
         return actions.size();
     }
-    
+
     public void clear() {
         actions.clear();
         actionPool.clear();
     }
-    
+
     @Override
     public void readExternal(java.io.ObjectInput in) throws IOException,ClassNotFoundException {
         //sessionId - String
@@ -285,11 +285,11 @@ public class DeltaRequest implements Externalizable {
             info.writeExternal(out);
         }
     }
-    
+
     /**
      * serialize DeltaRequest
      * @see DeltaRequest#writeExternal(java.io.ObjectOutput)
-     * 
+     *
      * @return serialized delta request
      * @throws IOException
      */
@@ -301,7 +301,7 @@ public class DeltaRequest implements Externalizable {
         oos.close();
         return bos.toByteArray();
     }
-    
+
     private static class AttributeInfo implements java.io.Externalizable {
         private String name = null;
         private Object value = null;
@@ -349,7 +349,7 @@ public class DeltaRequest implements Externalizable {
         public String getName() {
             return name;
         }
-        
+
         public void recycle() {
             name = null;
             value = null;
@@ -363,7 +363,7 @@ public class DeltaRequest implements Externalizable {
             AttributeInfo other =  (AttributeInfo)o;
             return other.getName().equals(this.getName());
         }
-        
+
         @Override
         public void readExternal(java.io.ObjectInput in ) throws IOException,ClassNotFoundException {
             //type - int
@@ -391,7 +391,7 @@ public class DeltaRequest implements Externalizable {
             out.writeBoolean(getValue()!=null);
             if (getValue()!=null) out.writeObject(getValue());
         }
-        
+
         @Override
         public String toString() {
             StringBuilder buf = new StringBuilder("AttributeInfo[type=");

==================================================
JvmRouteSessionIDBinderListener.java
index 6b6907c7ff..7ac35302fd 100644
--- a/java/org/apache/catalina/ha/session/DeltaSession.java
+++ b/java/org/apache/catalina/ha/session/DeltaSession.java
@@ -328,7 +328,7 @@ public class DeltaSession extends StandardSession implements Externalizable,Clus
     }
 
     public void setPrincipal(Principal principal, boolean addDeltaRequest) {
-        try { 
+        try {
             lock();
             super.setPrincipal(principal);
             if (addDeltaRequest && (deltaRequest != null))
@@ -350,7 +350,7 @@ public class DeltaSession extends StandardSession implements Externalizable,Clus
     }
 
     public void setAuthType(String authType, boolean addDeltaRequest) {
-        try { 
+        try {
             lock();
             super.setAuthType(authType);
             if (addDeltaRequest && (deltaRequest != null))
@@ -409,7 +409,7 @@ public class DeltaSession extends StandardSession implements Externalizable,Clus
             ((DeltaManager)manager).registerSessionAtReplicationValve(this);
         }
     }
-    
+
     // ------------------------------------------------- Session Public Methods
 
     /**
@@ -444,8 +444,8 @@ public class DeltaSession extends StandardSession implements Externalizable,Clus
         if (notifyCluster) {
             if (log.isDebugEnabled())
                 log.debug(sm.getString("deltaSession.notifying",
-                                       ((ClusterManager)manager).getName(), 
-                                       Boolean.valueOf(isPrimarySession()), 
+                                       ((ClusterManager)manager).getName(),
+                                       Boolean.valueOf(isPrimarySession()),
                                        expiredId));
             if ( manager instanceof DeltaManager ) {
                 ( (DeltaManager) manager).sessionExpired(expiredId);
@@ -770,7 +770,7 @@ public class DeltaSession extends StandardSession implements Externalizable,Clus
     protected void writeObject(ObjectOutputStream stream) throws IOException {
         writeObject((ObjectOutput)stream);
     }
-    
+
     private void writeObject(ObjectOutput stream) throws IOException {
         // Write the scalar instance variables (except Manager)
         stream.writeObject(Long.valueOf(creationTime));

==================================================
SerializablePrincipal.java
index 6b419d3416..ae84619a64 100644
--- a/java/org/apache/catalina/ha/session/LocalStrings_es.properties
+++ b/java/org/apache/catalina/ha/session/LocalStrings_es.properties
@@ -45,7 +45,7 @@ deltaManager.receiveMessage.unloadingAfter = Gestor [{0}]\: completada la descar
 deltaManager.receiveMessage.unloadingBegin = Gestor [{0}]\: iniciada descarga de sesiones
 deltaManager.receiveMessage.allSessionDataAfter = Gestor [{0}]\: estado de sesi\u00F3n deserializado
 deltaManager.receiveMessage.allSessionDataBegin = Gestor [{0}]\: recibidos datos de estado de sesi\u00F3n
-deltaManager.receiveMessage.fromWrongDomain = Gestor [{0}]\: Recibido SessionMessage equivocado de tipo\=({1}) desde [{2}] con dominio [{3}] (dominio local [{4}] 
+deltaManager.receiveMessage.fromWrongDomain = Gestor [{0}]\: Recibido SessionMessage equivocado de tipo\=({1}) desde [{2}] con dominio [{3}] (dominio local [{4}]
 deltaManager.registerCluster = Registrar gestor {0} a elemento de cl\u00FAster {1} con nombre {2}
 deltaManager.sessionReceived = Gestor [{0}]; estado de sesi\u00F3n enviado a las {1} recibido en {2} ms.
 deltaManager.startClustering = Iniciando gestor de cl\u00FAster a las {0}

==================================================
SessionIDMessage.java
index 5d1101fd4c..28c3e673c6 100644
--- a/java/org/apache/catalina/ha/session/SerializablePrincipal.java
+++ b/java/org/apache/catalina/ha/session/SerializablePrincipal.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -46,7 +46,7 @@ public class SerializablePrincipal  implements java.io.Serializable {
 
     private static final org.apache.juli.logging.Log log =
         org.apache.juli.logging.LogFactory.getLog(SerializablePrincipal.class);
-    
+
     /**
      * The string manager for this package.
      */
@@ -58,8 +58,8 @@ public class SerializablePrincipal  implements java.io.Serializable {
     public SerializablePrincipal() {
         super();
     }
-    
-    
+
+
     /**
      * Construct a new Principal, associated with the specified Realm, for the
      * specified username and password.
@@ -88,7 +88,7 @@ public class SerializablePrincipal  implements java.io.Serializable {
         this(name, password, roles, null);
     }
 
-    
+
     /**
      * Construct a new Principal, associated with the specified Realm, for the
      * specified username and password, with the specified role names
@@ -169,7 +169,7 @@ public class SerializablePrincipal  implements java.io.Serializable {
      * The user principal, if present.
      */
     protected Principal userPrincipal = null;
-    
+
     // --------------------------------------------------------- Public Methods
 
 
@@ -202,7 +202,7 @@ public class SerializablePrincipal  implements java.io.Serializable {
                 getRoles()!=null?Arrays.asList(getRoles()):null,
                 userPrincipal);
     }
-    
+
     public static GenericPrincipal readPrincipal(ObjectInput in)
             throws IOException, ClassNotFoundException {
         String name = in.readUTF();
@@ -226,7 +226,7 @@ public class SerializablePrincipal  implements java.io.Serializable {
         return new GenericPrincipal(name,pwd,Arrays.asList(roles),
                 userPrincipal);
     }
-    
+
     public static void writePrincipal(GenericPrincipal p, ObjectOutput out)
             throws IOException {
         out.writeUTF(p.getName());

==================================================
SessionMessage.java
index 4aa07468cb..a7314b1290 100644
--- a/java/org/apache/catalina/ha/session/SessionIDMessage.java
+++ b/java/org/apache/catalina/ha/session/SessionIDMessage.java
@@ -20,9 +20,9 @@ import org.apache.catalina.ha.ClusterMessageBase;
 
 /**
  * Session id change cluster message
- * 
+ *
  * @author Peter Rossbach
- * 
+ *
  * @version $Id$
  */
 public class SessionIDMessage extends ClusterMessageBase {
@@ -65,7 +65,7 @@ public class SessionIDMessage extends ClusterMessageBase {
     public void setHost(String host) {
         this.host = host;
     }
-    
+
     /**
      * @return Returns the context name.
      */
@@ -93,7 +93,7 @@ public class SessionIDMessage extends ClusterMessageBase {
         this.messageNumber = messageNumber;
     }
 
-    
+
     /**
      * @return Returns the backupSessionID.
      */

==================================================
SessionMessageImpl.java
index 7c09309703..199772b03c 100644
--- a/java/org/apache/catalina/ha/session/SessionMessage.java
+++ b/java/org/apache/catalina/ha/session/SessionMessage.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -70,7 +70,7 @@ public interface SessionMessage extends ClusterMessage {
      * When a session state is transferred, this is the event.
      */
     public static final int EVT_ALL_SESSION_DATA = 12;
-    
+
     /**
      * When a session state is complete transferred, this is the event.
      */
@@ -81,16 +81,16 @@ public interface SessionMessage extends ClusterMessage {
      */
     public static final int EVT_CHANGE_SESSION_ID = 15;
 
-    
+
     public String getContextName();
-    
+
     public String getEventTypeString();
-    
+
     /**
      * returns the event type
      * @return one of the event types EVT_XXXX
      */
-    public int getEventType(); 
+    public int getEventType();
     /**
      * @return the serialized data for the session
      */

==================================================
Constants.java
index 4c6fc5c773..1c086a7377 100644
--- a/java/org/apache/catalina/ha/session/mbeans-descriptors.xml
+++ b/java/org/apache/catalina/ha/session/mbeans-descriptors.xml
@@ -307,7 +307,7 @@
       name="stateTransfered"
       is="true"
       description="Is session state transfered complete? "
-      type="boolean"/>  
+      type="boolean"/>
     <attribute
       name="stateTransferTimeout"
       description="state transfer timeout in sec"
@@ -352,7 +352,7 @@
       description="Return the set of active Sessions associated with this Manager."
       impact="ACTION"
       returnType="[Lorg.apache.catalina.Session;">
-    </operation>  
+    </operation>
     <operation
       name="getAllClusterSessions"
       description="send to oldest cluster member that this node need all cluster sessions (resync member)"
@@ -367,7 +367,7 @@
         name="sessionId"
         description="The session id for the session "
         type="java.lang.String"/>
-    </operation>   
+    </operation>
     <operation
       name="getLastAccessedTime"
       description="Get the last access time. This one gets updated whenever a request finishes. "
@@ -377,7 +377,7 @@
         name="sessionId"
         description="Id of the session"
         type="java.lang.String"/>
-    </operation> 
+    </operation>
     <operation
       name="getSessionAttribute"
       description="Return a session attribute"
@@ -401,7 +401,7 @@
         name="sessionId"
         description="Id of the session"
         type="java.lang.String"/>
-    </operation> 
+    </operation>
     <operation
       name="listSessionIds"
       description="Return the list of active primary session ids"
@@ -568,7 +568,7 @@
       description="Return the set of active Sessions associated with this Manager."
       impact="ACTION"
       returnType="[Lorg.apache.catalina.Session;">
-    </operation>  
+    </operation>
     <operation
       name="getCreationTime"
       description="Return the creatio time for this session"
@@ -578,7 +578,7 @@
         name="sessionId"
         description="The session id for the session "
         type="java.lang.String"/>
-    </operation>   
+    </operation>
     <operation
       name="getLastAccessedTime"
       description="Get the last access time. This one gets updated whenever a request finishes. "
@@ -588,7 +588,7 @@
         name="sessionId"
         description="Id of the session"
         type="java.lang.String"/>
-    </operation> 
+    </operation>
     <operation
       name="getSessionAttribute"
       description="Return a session attribute"
@@ -612,7 +612,7 @@
         name="sessionId"
         description="Id of the session"
         type="java.lang.String"/>
-    </operation> 
+    </operation>
     <operation
       name="listSessionIds"
       description="Return the list of active primary session ids"

==================================================
SendMessageData.java
index 93afd75f48..cf213e3447 100644
--- a/java/org/apache/catalina/ha/tcp/LocalStrings_es.properties
+++ b/java/org/apache/catalina/ha/tcp/LocalStrings_es.properties
@@ -37,5 +37,5 @@ SimpleTcpCluster.default.addClusterReceiver = Add Default ClusterReceiver at clu
 SimpleTcpCluster.default.addClusterSender = Add Default ClusterSender at cluster {0}
 SimpleTcpCluster.default.addMembershipService = Add Default Membership Service at cluster {0}
 SimpleTcpCluster.log.receive = RECEIVE {0,date}\:{0,time} {1,number} {2}\:{3,number,integer} {4} {5}
-SimpleTcpCluster.log.send = SEND {0,date}\:{0,time} {1,number} {2}\:{3,number,integer} {4} 
+SimpleTcpCluster.log.send = SEND {0,date}\:{0,time} {1,number} {2}\:{3,number,integer} {4}
 SimpleTcpCluster.log.send.all = SEND {0,date}\:{0,time} {1,number} - {2}

==================================================
SimpleTcpCluster.java
index 097ddf29f4..6a5c7b97d2 100644
--- a/java/org/apache/catalina/ha/tcp/SendMessageData.java
+++ b/java/org/apache/catalina/ha/tcp/SendMessageData.java
@@ -28,8 +28,8 @@ public class SendMessageData {
     private Object message ;
     private Member destination ;
     private Exception exception ;
-    
-    
+
+
     /**
      * @param message
      * @param destination
@@ -42,7 +42,7 @@ public class SendMessageData {
         this.destination = destination;
         this.exception = exception;
     }
-    
+
     /**
      * @return Returns the destination.
      */

==================================================
IDynamicProperty.java
index 91ef55bcad..142212e63e 100644
--- a/java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java
+++ b/java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -63,10 +63,10 @@ import org.apache.tomcat.util.res.StringManager;
  * A <b>Cluster </b> implementation using simple multicast. Responsible for
  * setting up a cluster and provides callers with a valid multicast
  * receiver/sender.
- * 
+ *
  * FIXME remove install/remove/start/stop context dummys
- * FIXME wrote testcases 
- * 
+ * FIXME wrote testcases
+ *
  * @author Filip Hanik
  * @author Remy Maucherat
  * @author Peter Rossbach
@@ -99,7 +99,7 @@ public class SimpleTcpCluster extends LifecycleBase
     public static final String SEND_MESSAGE_FAILURE_EVENT = "send_message_failure";
 
     public static final String RECEIVE_MESSAGE_FAILURE_EVENT = "receive_message_failure";
-    
+
     /**
      * Group channel.
      */
@@ -126,7 +126,7 @@ public class SimpleTcpCluster extends LifecycleBase
      * @see org.apache.catalina.tribes.group.GroupChannel#heartbeat()
      */
     protected boolean heartbeatBackgroundEnabled =false ;
-    
+
     /**
      * The Container associated with this Cluster.
      */
@@ -163,9 +163,9 @@ public class SimpleTcpCluster extends LifecycleBase
      * dynamic sender <code>properties</code>
      */
     private Map<String, Object> properties = new HashMap<String, Object>();
-    
+
     private int channelSendOptions = Channel.SEND_OPTIONS_ASYNCHRONOUS;
-    
+
     private int channelStartOptions = Channel.DEFAULT;
 
     // ------------------------------------------------------------- Properties
@@ -193,7 +193,7 @@ public class SimpleTcpCluster extends LifecycleBase
     /**
      * Set the name of the cluster to join, if no cluster with this name is
      * present create one.
-     * 
+     *
      * @param clusterName
      *            The clustername to join
      */
@@ -205,7 +205,7 @@ public class SimpleTcpCluster extends LifecycleBase
     /**
      * Return the name of the cluster that this Server is currently configured
      * to operate within.
-     * 
+     *
      * @return The name of the cluster associated with this server
      */
     @Override
@@ -217,7 +217,7 @@ public class SimpleTcpCluster extends LifecycleBase
 
     /**
      * Set the Container associated with our Cluster
-     * 
+     *
      * @param container
      *            The Container to use
      */
@@ -230,7 +230,7 @@ public class SimpleTcpCluster extends LifecycleBase
 
     /**
      * Get the Container associated with our Cluster
-     * 
+     *
      * @return The Container associated with our Cluster
      */
     @Override
@@ -259,7 +259,7 @@ public class SimpleTcpCluster extends LifecycleBase
     }
 
     /**
-     * Add cluster valve 
+     * Add cluster valve
      * Cluster Valves are only add to container when cluster is started!
      * @param valve The new cluster Valve.
      */
@@ -294,7 +294,7 @@ public class SimpleTcpCluster extends LifecycleBase
 
     /**
      * Add cluster message listener and register cluster to this listener.
-     * 
+     *
      * @see org.apache.catalina.ha.CatalinaCluster#addClusterListener(org.apache.catalina.ha.ClusterListener)
      */
     @Override
@@ -307,7 +307,7 @@ public class SimpleTcpCluster extends LifecycleBase
 
     /**
      * Remove message listener and deregister Cluster from listener.
-     * 
+     *
      * @see org.apache.catalina.ha.CatalinaCluster#removeClusterListener(org.apache.catalina.ha.ClusterListener)
      */
     @Override
@@ -356,10 +356,10 @@ public class SimpleTcpCluster extends LifecycleBase
     public boolean hasMembers() {
         return hasMembers;
     }
-    
+
     /**
      * Get all current cluster members
-     * @return all members or empty array 
+     * @return all members or empty array
      */
     @Override
     public Member[] getMembers() {
@@ -368,7 +368,7 @@ public class SimpleTcpCluster extends LifecycleBase
 
     /**
      * Return the member that represents this node.
-     * 
+     *
      * @return Member
      */
     @Override
@@ -381,7 +381,7 @@ public class SimpleTcpCluster extends LifecycleBase
 
     /**
      * JMX hack to direct use at jconsole
-     * 
+     *
      * @param name
      * @param value
      */
@@ -391,7 +391,7 @@ public class SimpleTcpCluster extends LifecycleBase
 
     /**
      * set config attributes with reflect and propagate to all managers
-     * 
+     *
      * @param name
      * @param value
      */
@@ -409,7 +409,7 @@ public class SimpleTcpCluster extends LifecycleBase
 
     /**
      * get current config
-     * 
+     *
      * @param key
      * @return The property
      */
@@ -422,7 +422,7 @@ public class SimpleTcpCluster extends LifecycleBase
 
     /**
      * Get all properties keys
-     * 
+     *
      * @return An iterator over the property names.
      */
     @Override
@@ -432,7 +432,7 @@ public class SimpleTcpCluster extends LifecycleBase
 
     /**
      * remove a configured property.
-     * 
+     *
      * @param key
      */
     @Override
@@ -483,7 +483,7 @@ public class SimpleTcpCluster extends LifecycleBase
 
     /**
      * Create new Manager without add to cluster (comes with start the manager)
-     * 
+     *
      * @param name
      *            Context Name of this manager
      * @see org.apache.catalina.Cluster#createManager(java.lang.String)
@@ -507,10 +507,10 @@ public class SimpleTcpCluster extends LifecycleBase
         }
         return manager;
     }
-    
+
     @Override
     public void registerManager(Manager manager) {
-    
+
         if (! (manager instanceof ClusterManager)) {
             log.warn("Manager [ " + manager + "] does not implement ClusterManager, addition to cluster has been aborted.");
             return;
@@ -522,15 +522,15 @@ public class SimpleTcpCluster extends LifecycleBase
         String clusterName = getManagerName(cmanager.getName(), manager);
         cmanager.setName(clusterName);
         cmanager.setCluster(this);
-    
+
         managers.put(clusterName, cmanager);
         // Notify our interested LifecycleListeners
-        fireLifecycleEvent(AFTER_MANAGERREGISTER_EVENT, manager);    
+        fireLifecycleEvent(AFTER_MANAGERREGISTER_EVENT, manager);
     }
 
     /**
      * Remove an application from cluster replication bus.
-     * 
+     *
      * @see org.apache.catalina.Cluster#removeManager(Manager)
      */
     @Override
@@ -559,7 +559,7 @@ public class SimpleTcpCluster extends LifecycleBase
             Container context = manager.getContainer() ;
             if(context != null && context instanceof Context) {
                 Container host = ((Context)context).getParent();
-                if(host != null && host instanceof Host && clusterName!=null && 
+                if(host != null && host instanceof Host && clusterName!=null &&
                         !(clusterName.startsWith(host.getName() +"#"))) {
                     clusterName = host.getName() +"#" + clusterName ;
                 }
@@ -570,14 +570,14 @@ public class SimpleTcpCluster extends LifecycleBase
 
     /*
      * Get Manager
-     * 
+     *
      * @see org.apache.catalina.ha.CatalinaCluster#getManager(java.lang.String)
      */
     @Override
     public Manager getManager(String name) {
         return managers.get(name);
     }
-    
+
     // ------------------------------------------------------ Lifecycle Methods
 
     /**
@@ -587,13 +587,13 @@ public class SimpleTcpCluster extends LifecycleBase
      * @see org.apache.catalina.ha.deploy.FarmWarDeployer#backgroundProcess()
      * @see org.apache.catalina.tribes.group.GroupChannel#heartbeat()
      * @see org.apache.catalina.tribes.group.GroupChannel.HeartbeatThread#run()
-     * 
+     *
      */
     @Override
     public void backgroundProcess() {
         if (clusterDeployer != null) clusterDeployer.backgroundProcess();
-       
-        //send a heartbeat through the channel        
+
+        //send a heartbeat through the channel
         if ( isHeartbeatBackgroundEnabled() && channel !=null ) channel.heartbeat();
     }
 
@@ -601,7 +601,7 @@ public class SimpleTcpCluster extends LifecycleBase
     /**
      * Use as base to handle start/stop/periodic Events from host. Currently
      * only log the messages as trace level.
-     * 
+     *
      * @see org.apache.catalina.LifecycleListener#lifecycleEvent(org.apache.catalina.LifecycleEvent)
      */
     @Override
@@ -616,8 +616,8 @@ public class SimpleTcpCluster extends LifecycleBase
     protected void initInternal() {
         // NOOP
     }
-    
-    
+
+
     /**
      * Start Cluster and implement the requirements
      * of {@link LifecycleBase#startInternal()}.
@@ -644,13 +644,13 @@ public class SimpleTcpCluster extends LifecycleBase
             log.error("Unable to start cluster.", x);
             throw new LifecycleException(x);
         }
-        
+
         setState(LifecycleState.STARTING);
     }
 
     protected void checkDefaults() {
         if ( clusterListeners.size() == 0 ) {
-            addClusterListener(new JvmRouteSessionIDBinderListener()); 
+            addClusterListener(new JvmRouteSessionIDBinderListener());
             addClusterListener(new ClusterSessionListener());
         }
         if ( valves.size() == 0 ) {
@@ -708,7 +708,7 @@ public class SimpleTcpCluster extends LifecycleBase
         }
     }
 
-    
+
     /**
      * Stop Cluster and implement the requirements
      * of {@link LifecycleBase#startInternal()}.
@@ -737,13 +737,13 @@ public class SimpleTcpCluster extends LifecycleBase
         }
     }
 
-    
+
     @Override
     protected void destroyInternal() {
         // NOOP
     }
 
-    
+
     /**
      * Return a String rendering of this object.
      */
@@ -759,22 +759,22 @@ public class SimpleTcpCluster extends LifecycleBase
         sb.append(']');
         return sb.toString();
     }
-    
+
 
     /**
      * send message to all cluster members
      * @param msg message to transfer
-     * 
+     *
      * @see org.apache.catalina.ha.CatalinaCluster#send(org.apache.catalina.ha.ClusterMessage)
      */
     @Override
     public void send(ClusterMessage msg) {
         send(msg, null);
     }
-    
+
     /**
      * send a cluster message to one member
-     * 
+     *
      * @param msg message to transfer
      * @param dest Receiver member
      * @see org.apache.catalina.ha.CatalinaCluster#send(org.apache.catalina.ha.ClusterMessage,
@@ -793,7 +793,7 @@ public class SimpleTcpCluster extends LifecycleBase
                 Member[] destmembers = channel.getMembers();
                 if (destmembers.length>0)
                     channel.send(destmembers,msg,channelSendOptions);
-                else if (log.isDebugEnabled()) 
+                else if (log.isDebugEnabled())
                     log.debug("No members in cluster, ignoring message:"+msg);
             }
         } catch (Exception x) {
@@ -803,7 +803,7 @@ public class SimpleTcpCluster extends LifecycleBase
 
     /**
      * New cluster member is registered
-     * 
+     *
      * @see org.apache.catalina.tribes.MembershipListener#memberAdded(org.apache.catalina.tribes.Member)
      */
     @Override
@@ -823,13 +823,13 @@ public class SimpleTcpCluster extends LifecycleBase
 
     /**
      * Cluster member is gone
-     * 
+     *
      * @see org.apache.catalina.tribes.MembershipListener#memberDisappeared(org.apache.catalina.tribes.Member)
      */
     @Override
     public void memberDisappeared(Member member) {
         try {
-            hasMembers = channel.hasMembers();            
+            hasMembers = channel.hasMembers();
             if (log.isInfoEnabled()) log.info("Received member disappeared:" + member);
             // Notify our interested LifecycleListeners
             fireLifecycleEvent(BEFORE_MEMBERUNREGISTER_EVENT, member);
@@ -846,7 +846,7 @@ public class SimpleTcpCluster extends LifecycleBase
     /**
      * notify all listeners from receiving a new message is not ClusterMessage
      * emit Failure Event to LifecylceListener
-     * 
+     *
      * @param msg
      *            received Message
      */
@@ -854,8 +854,8 @@ public class SimpleTcpCluster extends LifecycleBase
     public boolean accept(Serializable msg, Member sender) {
         return (msg instanceof ClusterMessage);
     }
-    
-    
+
+
     @Override
     public void messageReceived(Serializable message, Member sender) {
         ClusterMessage fwd = (ClusterMessage)message;
@@ -908,7 +908,7 @@ public class SimpleTcpCluster extends LifecycleBase
     // ------------------------------------------------------------- deprecated
 
     /**
-     * 
+     *
      * @see org.apache.catalina.Cluster#setProtocol(java.lang.String)
      */
     @Override

==================================================
