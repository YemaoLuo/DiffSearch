ba2a6fcb387597392cc2c74c636d9ec25c3e7f76
==================================================
Partial fix for https://bz.apache.org/bugzilla/show_bug.cgi?id=57489
==================================================
Mark Thomas
==================================================
Fri Dec 11 10:07:14 2015 +0000
==================================================
WsRemoteEndpointImplBase.java
index 971fbdc51b..f39ff82ef6 100644
--- a/java/org/apache/tomcat/websocket/LocalStrings.properties
+++ b/java/org/apache/tomcat/websocket/LocalStrings.properties
@@ -71,6 +71,7 @@ wsFrame.wrongRsv=The client frame set the reserved bits to [{0}] for a message w
 
 wsFrameClient.ioe=Failure while reading data sent by server
 
+wsRemoteEndpoint.acquireTimeout=The current message was not fully sent within the specified timeout
 wsRemoteEndpoint.closed=Message will not be sent because the WebSocket session has been closed
 wsRemoteEndpoint.closedDuringMessage=The remainder of the message will not be sent because the WebSocket session has been closed
 wsRemoteEndpoint.closedOutputStream=This method may not be called as the OutputStream has been closed

==================================================
WsSession.java
index 91431ad41f..1358c3a6fa 100644
--- a/java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java
+++ b/java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java
@@ -33,6 +33,8 @@ import java.util.concurrent.Semaphore;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
+import javax.websocket.CloseReason;
+import javax.websocket.CloseReason.CloseCodes;
 import javax.websocket.DeploymentException;
 import javax.websocket.EncodeException;
 import javax.websocket.Encoder;
@@ -291,16 +293,26 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
         long timeout = timeoutExpiry - System.currentTimeMillis();
         try {
             if (!messagePartInProgress.tryAcquire(timeout, TimeUnit.MILLISECONDS)) {
-                throw new SocketTimeoutException();
+                String msg = sm.getString("wsRemoteEndpoint.acquireTimeout");
+                wsSession.doClose(new CloseReason(CloseCodes.GOING_AWAY, msg),
+                        new CloseReason(CloseCodes.CLOSED_ABNORMALLY, msg));
+                throw new SocketTimeoutException(msg);
             }
         } catch (InterruptedException e) {
-            throw new IOException(sm.getString("wsRemoteEndpoint.sendInterupt"), e);
+            String msg = sm.getString("wsRemoteEndpoint.sendInterupt");
+            wsSession.doClose(new CloseReason(CloseCodes.GOING_AWAY, msg),
+                    new CloseReason(CloseCodes.CLOSED_ABNORMALLY, msg));
+            throw new IOException(msg, e);
         }
 
         for (MessagePart mp : messageParts) {
             writeMessagePart(mp);
             if (!bsh.getSendResult().isOK()) {
-                throw new IOException (bsh.getSendResult().getException());
+                messagePartInProgress.release();
+                Throwable t = bsh.getSendResult().getException();
+                wsSession.doClose(new CloseReason(CloseCodes.GOING_AWAY, t.getMessage()),
+                        new CloseReason(CloseCodes.CLOSED_ABNORMALLY, t.getMessage()));
+                throw new IOException (t);
             }
             // The BlockingSendHandler doesn't call end message so update the
             // flags.

==================================================
