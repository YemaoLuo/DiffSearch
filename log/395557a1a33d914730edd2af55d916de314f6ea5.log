395557a1a33d914730edd2af55d916de314f6ea5
==================================================
The container is responsible for the first call to each of onWritePossible() and onDataAvailable() once a listener has been set.
==================================================
Mark Emlyn
==================================================
Thu Aug 15 10:32:15 2013 +0000
==================================================
InputBuffer.java
The container is responsible for the first call to each of onWritePossible() and onDataAvailable() once a listener has been set.
Main component is the addition to the SocketWrapper of a list of dispatch types that need to be made. "Dispatch type" in this case meaning "process the socket using the specified SocketStatus". This is used to register trigger the first call to each of onWritePossible() and onDataAvailable() for which the container is responsible.
Fix some additional issues identified in the test case.


git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1514228 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AbstractProtocol.java
index 0a8b1df6ad..e8ad001c0c 100644
--- a/java/org/apache/catalina/connector/InputBuffer.java
+++ b/java/org/apache/catalina/connector/InputBuffer.java
@@ -249,6 +249,18 @@ public class InputBuffer extends Reader
 
     public void setReadListener(ReadListener listener) {
         coyoteRequest.setReadListener(listener);
+
+        // The container is responsible for the first call to
+        // listener.onDataAvailable(). If isReady() returns true, the container
+        // needs to call listener.onDataAvailable() from a new thread. If
+        // isReady() returns false, the socket will be registered for read and
+        // the container will call listener.onDataAvailable() once data arrives.
+        // Must call isFinished() first as a call to isReady() if the request
+        // has been finished will register the socket for read interest and that
+        // is not required.
+        if (isFinished() || isReady()) {
+            coyoteRequest.action(ActionCode.DISPATCH_READ, null);
+        }
     }
 
 

==================================================
ActionCode.java
index 590fef3b39..11d96307c0 100644
--- a/java/org/apache/coyote/AbstractProtocol.java
+++ b/java/org/apache/coyote/AbstractProtocol.java
@@ -38,6 +38,7 @@ import org.apache.tomcat.util.collections.SynchronizedStack;
 import org.apache.tomcat.util.modeler.Registry;
 import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler;
+import org.apache.tomcat.util.net.DispatchType;
 import org.apache.tomcat.util.net.SocketStatus;
 import org.apache.tomcat.util.net.SocketWrapper;
 import org.apache.tomcat.util.res.StringManager;
@@ -616,7 +617,11 @@ public abstract class AbstractProtocol implements ProtocolHandler,
 
                 SocketState state = SocketState.CLOSED;
                 do {
-                    if (status == SocketStatus.DISCONNECT &&
+                    if (wrapper.hasNextDispatch()) {
+                        DispatchType nextDispatch = wrapper.getNextDispatch();
+                        state = processor.asyncDispatch(
+                                nextDispatch.getSocketStatus());
+                    } else if (status == SocketStatus.DISCONNECT &&
                             !processor.isComet()) {
                         // Do nothing here, just wait for it to get recycled
                         // Don't do this for Comet we need to generate an end
@@ -663,7 +668,8 @@ public abstract class AbstractProtocol implements ProtocolHandler,
                                 "], State out: [" + state + "]");
                     }
                 } while (state == SocketState.ASYNC_END ||
-                        state == SocketState.UPGRADING);
+                        state == SocketState.UPGRADING ||
+                        wrapper.hasNextDispatch());
 
                 if (state == SocketState.LONG) {
                     // In the middle of processing a request/response. Keep the

==================================================
Response.java
index 891e142d0d..5d4ccc179f 100644
--- a/java/org/apache/coyote/ActionCode.java
+++ b/java/org/apache/coyote/ActionCode.java
@@ -215,5 +215,17 @@ public enum ActionCode {
     /**
      * Indicates if the request body has been fully read.
      */
-    REQUEST_BODY_FULLY_READ
+    REQUEST_BODY_FULLY_READ,
+
+    /**
+     * Indicates that the container needs to trigger a call to onDataAvailable()
+     * for the registered non-blocking read listener.
+     */
+    DISPATCH_READ,
+
+    /**
+     * Indicates that the container needs to trigger a call to onWritePossible()
+     * for the registered non-blocking write listener.
+     */
+    DISPATCH_WRITE
 }

==================================================
AbstractHttp11Processor.java
index e544065fe6..9840fe0ad6 100644
--- a/java/org/apache/coyote/Response.java
+++ b/java/org/apache/coyote/Response.java
@@ -593,6 +593,21 @@ public final class Response {
         }
 
         this.listener = listener;
+
+        // The container is responsible for the first call to
+        // listener.onWritePossible(). If isReady() returns true, the container
+        // needs to call listener.onWritePossible() from a new thread. If
+        // isReady() returns false, the socket will be registered for write and
+        // the container will call listener.onWritePossible() once data can be
+        // written.
+        if (isReady()) {
+            action(ActionCode.DISPATCH_WRITE, null);
+            // Need to set the fireListener flag otherwise when the container
+            // tries to trigger onWritePossible, nothing will happen
+            synchronized (nonBlockingStateLock) {
+                fireListener = true;
+            }
+        }
     }
 
     public boolean isReady() {

==================================================
InternalInputBuffer.java
index 043ce28d23..bb18678fe1 100644
--- a/java/org/apache/coyote/http11/AbstractHttp11Processor.java
+++ b/java/org/apache/coyote/http11/AbstractHttp11Processor.java
@@ -51,6 +51,7 @@ import org.apache.tomcat.util.http.MimeHeaders;
 import org.apache.tomcat.util.log.UserDataHelper;
 import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
+import org.apache.tomcat.util.net.DispatchType;
 import org.apache.tomcat.util.net.SocketStatus;
 import org.apache.tomcat.util.net.SocketWrapper;
 import org.apache.tomcat.util.res.StringManager;
@@ -828,6 +829,10 @@ public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
         } else if (actionCode == ActionCode.REQUEST_BODY_FULLY_READ) {
             AtomicBoolean result = (AtomicBoolean) param;
             result.set(getInputBuffer().isFinished());
+        } else if (actionCode == ActionCode.DISPATCH_READ) {
+            socketWrapper.addDispatch(DispatchType.NON_BLOCKING_READ);
+        } else if (actionCode == ActionCode.DISPATCH_WRITE) {
+            socketWrapper.addDispatch(DispatchType.NON_BLOCKING_WRITE);
         } else {
             actionInternal(actionCode, param);
         }

==================================================
AprEndpoint.java
index 1684686e73..ddc53f3e22 100644
--- a/java/org/apache/coyote/http11/InternalInputBuffer.java
+++ b/java/org/apache/coyote/http11/InternalInputBuffer.java
@@ -554,7 +554,10 @@ public class InternalInputBuffer extends AbstractInputBuffer<Socket> {
 
     @Override
     protected int nbRead() throws IOException {
-        throw new IllegalStateException("This method is unused for BIO");
+        // If this gets called for BIO need to make caller think there is data
+        // to read as BIO always reads whether there is data or not (and blocks
+        // until there is data to read).
+        return 1;
     }
 
 

==================================================
DispatchType.java
index 2d7f41521b..f4766dac92 100644
--- a/java/org/apache/tomcat/util/net/AprEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AprEndpoint.java
@@ -1718,16 +1718,30 @@ public class AprEndpoint extends AbstractEndpoint {
                                         // application code. By signalling read/write is possible, a
                                         // read/write will be attempted, fail and that will trigger
                                         // an exception the application will see.
-                                        if ((desc[n*2] & Poll.APR_POLLIN) == Poll.APR_POLLIN ||
-                                                (wrapper.pollerFlags & Poll.APR_POLLIN) == Poll.APR_POLLIN) {
-                                            // Must be doing a non-blocking read
+                                        // Check the return flags first, followed by what the socket
+                                        // was registered for
+                                        if ((desc[n*2] & Poll.APR_POLLIN) == Poll.APR_POLLIN) {
+                                            // Error probably occurred during a non-blocking read
                                             if (!processSocket(desc[n*2+1], SocketStatus.OPEN_READ)) {
                                                 // Close socket and clear pool
                                                 destroySocket(desc[n*2+1]);
                                             }
-                                        } else if ((desc[n*2] & Poll.APR_POLLOUT) == Poll.APR_POLLOUT ||
-                                                (wrapper.pollerFlags & Poll.APR_POLLOUT) == Poll.APR_POLLOUT) {
-                                            // Must be doing an non-blocking write write
+                                        } else if ((desc[n*2] & Poll.APR_POLLOUT) == Poll.APR_POLLOUT) {
+                                            // Error probably occurred during a non-blocking write
+                                            if (!processSocket(desc[n*2+1], SocketStatus.OPEN_WRITE)) {
+                                                // Close socket and clear pool
+                                                destroySocket(desc[n*2+1]);
+                                            }
+                                        } else if ((wrapper.pollerFlags & Poll.APR_POLLIN) == Poll.APR_POLLIN) {
+                                            // Can't tell what was happening when the error occurred but the
+                                            // socket is registered for non-blocking read so use that
+                                            if (!processSocket(desc[n*2+1], SocketStatus.OPEN_READ)) {
+                                                // Close socket and clear pool
+                                                destroySocket(desc[n*2+1]);
+                                            }
+                                        } else if ((wrapper.pollerFlags & Poll.APR_POLLOUT) == Poll.APR_POLLOUT) {
+                                            // Can't tell what was happening when the error occurred but the
+                                            // socket is registered for non-blocking write so use that
                                             if (!processSocket(desc[n*2+1], SocketStatus.OPEN_WRITE)) {
                                                 // Close socket and clear pool
                                                 destroySocket(desc[n*2+1]);

==================================================
SocketWrapper.java
new file mode 100644
index 0000000000..cd104b26bd
--- /dev/null
+++ b/java/org/apache/tomcat/util/net/DispatchType.java
@@ -0,0 +1,38 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.tomcat.util.net;
+
+/**
+ * This enumeration lists the different types of dispatches that request
+ * processing can trigger. In this instance, dispatch means re-process this
+ * request using the given socket status.
+ */
+public enum DispatchType {
+
+    NON_BLOCKING_READ(SocketStatus.OPEN_READ),
+    NON_BLOCKING_WRITE(SocketStatus.OPEN_WRITE);
+
+    private final SocketStatus status;
+
+    private DispatchType(SocketStatus status) {
+        this.status = status;
+    }
+
+    public SocketStatus getSocketStatus() {
+        return status;
+    }
+}

==================================================
TestNonBlockingAPI.java
index 527d058812..b16136ff4b 100644
--- a/java/org/apache/tomcat/util/net/SocketWrapper.java
+++ b/java/org/apache/tomcat/util/net/SocketWrapper.java
@@ -16,6 +16,9 @@
  */
 package org.apache.tomcat.util.net;
 
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.Set;
 import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;
@@ -60,6 +63,8 @@ public class SocketWrapper<E> {
     private final Object writeThreadLock = new Object();
     public Object getWriteThreadLock() { return writeThreadLock; }
 
+    private Set<DispatchType> dispatches = new LinkedHashSet<>();
+
     public SocketWrapper(E socket) {
         this.socket = socket;
         ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
@@ -108,4 +113,19 @@ public class SocketWrapper<E> {
     public WriteLock getBlockingStatusWriteLock() {
         return blockingStatusWriteLock;
     }
+    public void addDispatch(DispatchType dispatchType) {
+        dispatches.add(dispatchType);
+    }
+    public boolean hasNextDispatch() {
+        return dispatches.size() > 0;
+    }
+    public DispatchType getNextDispatch() {
+        DispatchType result = null;
+        Iterator<DispatchType> iter = dispatches.iterator();
+        if (iter.hasNext()) {
+            result = iter.next();
+            iter.remove();
+        }
+        return result;
+    }
 }

==================================================
