f1daf9d05e1a64bf5a89fb94743408d62c0899ff
==================================================
Clean-up, formatting. No functional change.
==================================================
Mark Thomas
==================================================
Fri May 5 16:44:34 2023 +0100
==================================================
Authorization.java
Clean-up, formatting. No functional change.

Preparation before back-porting RFC 918 priorities.


==================================================
Cookie.java
index 8afba9bd1c..bb7b1a16e9 100644
--- a/java/org/apache/tomcat/util/http/parser/Authorization.java
+++ b/java/org/apache/tomcat/util/http/parser/Authorization.java
@@ -32,8 +32,8 @@ public class Authorization {
     static {
         // Digest field types.
         // Note: These are more relaxed than RFC2617. This adheres to the
-        //       recommendation of RFC2616 that servers are tolerant of buggy
-        //       clients when they can be so without ambiguity.
+        // recommendation of RFC2616 that servers are tolerant of buggy
+        // clients when they can be so without ambiguity.
         fieldTypes.put("username", FieldType.QUOTED_STRING);
         fieldTypes.put("realm", FieldType.QUOTED_STRING);
         fieldTypes.put("nonce", FieldType.QUOTED_STRING);
@@ -58,21 +58,18 @@ public class Authorization {
 
 
     /**
-     * Parses an HTTP Authorization header for DIGEST authentication as per RFC
-     * 2617 section 3.2.2.
+     * Parses an HTTP Authorization header for DIGEST authentication as per RFC 2617 section 3.2.2.
      *
      * @param input The header value to parse
      *
-     * @return  A map of directives and values as {@link String}s or
-     *          <code>null</code> if a parsing error occurs. Although the
-     *          values returned are {@link String}s they will have been
-     *          validated to ensure that they conform to RFC 2617.
+     * @return A map of directives and values as {@link String}s or <code>null</code> if a parsing error occurs.
+     *             Although the values returned are {@link String}s they will have been validated to ensure that they
+     *             conform to RFC 2617.
      *
-     * @throws IllegalArgumentException If the header does not conform to RFC
-     *                                  2617
-     * @throws java.io.IOException If an error occurs while reading the input
+     * @throws IllegalArgumentException If the header does not conform to RFC 2617
+     * @throws java.io.IOException      If an error occurs while reading the input
      */
-    public static Map<String,String> parseAuthorizationDigest (StringReader input)
+    public static Map<String,String> parseAuthorizationDigest(StringReader input)
             throws IllegalArgumentException, IOException {
 
         Map<String,String> result = new HashMap<>();

==================================================
EntityTag.java
index 8b80543bf9..1a44e9e627 100644
--- a/java/org/apache/tomcat/util/http/parser/Cookie.java
+++ b/java/org/apache/tomcat/util/http/parser/Cookie.java
@@ -27,27 +27,28 @@ import org.apache.tomcat.util.res.StringManager;
 
 
 /**
- * <p>Cookie header parser based on RFC6265</p>
- * <p>The parsing of cookies using RFC6265 is more relaxed that the
- * specification in the following ways:</p>
+ * <p>
+ * Cookie header parser based on RFC6265
+ * </p>
+ * <p>
+ * The parsing of cookies using RFC6265 is more relaxed that the specification in the following ways:
+ * </p>
  * <ul>
- *   <li>Values 0x80 to 0xFF are permitted in cookie-octet to support the use of
- *       UTF-8 in cookie values as used by HTML 5.</li>
- *   <li>For cookies without a value, the '=' is not required after the name as
- *       some browsers do not sent it.</li>
+ * <li>Values 0x80 to 0xFF are permitted in cookie-octet to support the use of UTF-8 in cookie values as used by HTML
+ * 5.</li>
+ * <li>For cookies without a value, the '=' is not required after the name as some browsers do not sent it.</li>
  * </ul>
- *
- * <p>Implementation note:<br>
- * This class has been carefully tuned. Before committing any changes, ensure
- * that the TesterCookiePerformance unit test continues to give results within
- * 1% for the old and new parsers.</p>
+ * <p>
+ * Implementation note:<br>
+ * This class has been carefully tuned. Before committing any changes, ensure that the TesterCookiePerformance unit test
+ * continues to give results within 1% for the old and new parsers.
+ * </p>
  */
 public class Cookie {
 
     private static final Log log = LogFactory.getLog(Cookie.class);
     private static final UserDataHelper invalidCookieLog = new UserDataHelper(log);
-    private static final StringManager sm =
-            StringManager.getManager("org.apache.tomcat.util.http.parser");
+    private static final StringManager sm = StringManager.getManager("org.apache.tomcat.util.http.parser");
 
     private static final boolean isCookieOctet[] = new boolean[256];
     private static final boolean isText[] = new boolean[256];
@@ -64,10 +65,10 @@ public class Cookie {
 
     static {
         // %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E (RFC6265)
-        // %x80 to %xFF                                 (UTF-8)
+        // %x80 to %xFF (UTF-8)
         for (int i = 0; i < 256; i++) {
-            if (i < 0x21 || i == QUOTE_BYTE || i == COMMA_BYTE ||
-                    i == SEMICOLON_BYTE || i == SLASH_BYTE || i == DEL_BYTE) {
+            if (i < 0x21 || i == QUOTE_BYTE || i == COMMA_BYTE || i == SEMICOLON_BYTE || i == SLASH_BYTE ||
+                    i == DEL_BYTE) {
                 isCookieOctet[i] = false;
             } else {
                 isCookieOctet[i] = true;
@@ -88,8 +89,7 @@ public class Cookie {
     }
 
 
-    public static void parseCookie(byte[] bytes, int offset, int len,
-            ServerCookies serverCookies) {
+    public static void parseCookie(byte[] bytes, int offset, int len, ServerCookies serverCookies) {
 
         // ByteBuffer is used throughout this parser as it allows the byte[]
         // and position information to be easily passed between parsing methods
@@ -146,7 +146,7 @@ public class Cookie {
 
 
     private static void skipLWS(ByteBuffer bb) {
-        while(bb.hasRemaining()) {
+        while (bb.hasRemaining()) {
             byte b = bb.get();
             if (b != TAB_BYTE && b != SPACE_BYTE) {
                 bb.rewind();
@@ -157,7 +157,7 @@ public class Cookie {
 
 
     private static void skipUntilSemiColon(ByteBuffer bb) {
-        while(bb.hasRemaining()) {
+        while (bb.hasRemaining()) {
             if (bb.get() == SEMICOLON_BYTE) {
                 break;
             }
@@ -180,8 +180,7 @@ public class Cookie {
 
 
     /**
-     * Similar to readCookieValue() but treats a comma as part of an invalid
-     * value.
+     * Similar to readCookieValue() but treats a comma as part of an invalid value.
      */
     private static ByteBuffer readCookieValueRfc6265(ByteBuffer bb) {
         boolean quoted = false;
@@ -195,7 +194,7 @@ public class Cookie {
                 end = bb.position() - 1;
                 bb.position(end);
                 break;
-            } else if (b == QUOTE_BYTE && start == bb.position() -1) {
+            } else if (b == QUOTE_BYTE && start == bb.position() - 1) {
                 quoted = true;
             } else if (quoted && b == QUOTE_BYTE) {
                 end = bb.position();
@@ -245,8 +244,7 @@ public class Cookie {
 
 
     /**
-     * Custom implementation that skips many of the safety checks in
-     * {@link java.nio.ByteBuffer}.
+     * Custom implementation that skips many of the safety checks in {@link java.nio.ByteBuffer}.
      */
     private static class ByteBuffer {
 

==================================================
Host.java
index f863ccca9f..132b480ca3 100644
--- a/java/org/apache/tomcat/util/http/parser/EntityTag.java
+++ b/java/org/apache/tomcat/util/http/parser/EntityTag.java
@@ -22,16 +22,14 @@ import java.io.StringReader;
 public class EntityTag {
 
     /**
-     * Parse the given input as (per RFC 7232) 1#entity-tag.
-     * Compare an ETag header with a resource ETag as described in RFC 7232
-     * section 2.3.2.
+     * Parse the given input as (per RFC 7232) 1#entity-tag. Compare an ETag header with a resource ETag as described in
+     * RFC 7232 section 2.3.2.
      *
      * @param input        The input to parse
      * @param compareWeak  Use weak comparison e.g. match "etag" with W/"etag"
      * @param resourceETag Resource's ETag
      *
-     * @return {@code true} if ETag matches, {@code false} if ETag doesn't match
-     *         or {@code null} if the input is invalid
+     * @return {@code true} if ETag matches, {@code false} if ETag doesn't match or {@code null} if the input is invalid
      *
      * @throws IOException If an I/O occurs during the parsing
      */
@@ -65,7 +63,7 @@ public class EntityTag {
             }
 
             // Note: RFC 2616 allowed quoted string
-            //       RFC 7232 does not allow " in the entity-tag
+            // RFC 7232 does not allow " in the entity-tag
             String value = HttpParser.readQuotedString(input, true);
             if (value == null) {
                 // Not a quoted string so the header is invalid

==================================================
HttpParser.java
index b867adc205..f9cb602bfe 100644
--- a/java/org/apache/tomcat/util/http/parser/Host.java
+++ b/java/org/apache/tomcat/util/http/parser/Host.java
@@ -35,11 +35,9 @@ public class Host {
      *
      * @param mb The host header value
      *
-     * @return The position of ':' that separates the host from the port or -1
-     *         if it is not present
+     * @return The position of ':' that separates the host from the port or -1 if it is not present
      *
-     * @throws IllegalArgumentException If the host header value is not
-     *         specification compliant
+     * @throws IllegalArgumentException If the host header value is not specification compliant
      */
     public static int parse(MessageBytes mb) {
         return parse(new MessageBytesReader(mb));
@@ -51,11 +49,9 @@ public class Host {
      *
      * @param string The host header value
      *
-     * @return The position of ':' that separates the host from the port or -1
-     *         if it is not present
+     * @return The position of ':' that separates the host from the port or -1 if it is not present
      *
-     * @throws IllegalArgumentException If the host header value is not
-     *         specification compliant
+     * @throws IllegalArgumentException If the host header value is not specification compliant
      */
     public static int parse(String string) {
         return parse(new StringReader(string));

==================================================
MediaType.java
index 6975e3b53f..dbc3f7edb7 100644
--- a/java/org/apache/tomcat/util/http/parser/HttpParser.java
+++ b/java/org/apache/tomcat/util/http/parser/HttpParser.java
@@ -22,17 +22,12 @@ import java.io.Reader;
 import org.apache.tomcat.util.res.StringManager;
 
 /**
- * HTTP header value parser implementation. Parsing HTTP headers as per RFC2616
- * is not always as simple as it first appears. For headers that only use tokens
- * the simple approach will normally be sufficient. However, for the other
- * headers, while simple code meets 99.9% of cases, there are often some edge
- * cases that make things far more complicated.
- *
- * The purpose of this parser is to let the parser worry about the edge cases.
- * It provides tolerant (where safe to do so) parsing of HTTP header values
- * assuming that wrapped header lines have already been unwrapped. (The Tomcat
- * header processing code does the unwrapping.)
- *
+ * HTTP header value parser implementation. Parsing HTTP headers as per RFC2616 is not always as simple as it first
+ * appears. For headers that only use tokens the simple approach will normally be sufficient. However, for the other
+ * headers, while simple code meets 99.9% of cases, there are often some edge cases that make things far more
+ * complicated. The purpose of this parser is to let the parser worry about the edge cases. It provides tolerant (where
+ * safe to do so) parsing of HTTP header values assuming that wrapped header lines have already been unwrapped. (The
+ * Tomcat header processing code does the unwrapping.)
  */
 public class HttpParser {
 
@@ -64,10 +59,9 @@ public class HttpParser {
             }
 
             // Separator
-            if (    i == '(' || i == ')' || i == '<' || i == '>'  || i == '@'  ||
-                    i == ',' || i == ';' || i == ':' || i == '\\' || i == '\"' ||
-                    i == '/' || i == '[' || i == ']' || i == '?'  || i == '='  ||
-                    i == '{' || i == '}' || i == ' ' || i == '\t') {
+            if (i == '(' || i == ')' || i == '<' || i == '>' || i == '@' || i == ',' || i == ';' || i == ':' ||
+                    i == '\\' || i == '\"' || i == '/' || i == '[' || i == ']' || i == '?' || i == '=' || i == '{' ||
+                    i == '}' || i == ' ' || i == '\t') {
                 IS_SEPARATOR[i] = true;
             }
 
@@ -77,7 +71,7 @@ public class HttpParser {
             }
 
             // Hex: 0-9, a-f, A-F
-            if ((i >= '0' && i <='9') || (i >= 'a' && i <= 'f') || (i >= 'A' && i <= 'F')) {
+            if ((i >= '0' && i <= '9') || (i >= 'a' && i <= 'f') || (i >= 'A' && i <= 'F')) {
                 IS_HEX[i] = true;
             }
 
@@ -103,12 +97,12 @@ public class HttpParser {
                 IS_UNRESERVED[i] = true;
             }
 
-            if (i == '!' || i == '$' || i == '&' || i == '\'' || i == '(' || i == ')' || i == '*' ||
-                    i == '+' || i == ',' || i == ';' || i == '=') {
+            if (i == '!' || i == '$' || i == '&' || i == '\'' || i == '(' || i == ')' || i == '*' || i == '+' ||
+                    i == ',' || i == ';' || i == '=') {
                 IS_SUBDELIM[i] = true;
             }
 
-            // userinfo    = *( unreserved / pct-encoded / sub-delims / ":" )
+            // userinfo = *( unreserved / pct-encoded / sub-delims / ":" )
             if (IS_UNRESERVED[i] || i == '%' || IS_SUBDELIM[i] || i == ':') {
                 IS_USERINFO[i] = true;
             }
@@ -116,8 +110,8 @@ public class HttpParser {
             // The characters that are normally not permitted for which the
             // restrictions may be relaxed when used in the path and/or query
             // string
-            if (i == '\"' || i == '<' || i == '>' || i == '[' || i == '\\' || i == ']' ||
-                    i == '^' || i == '`'  || i == '{' || i == '|' || i == '}') {
+            if (i == '\"' || i == '<' || i == '>' || i == '[' || i == '\\' || i == ']' || i == '^' || i == '`' ||
+                    i == '{' || i == '|' || i == '}') {
                 IS_RELAXABLE[i] = true;
             }
         }
@@ -136,16 +130,14 @@ public class HttpParser {
             // Not valid for request target.
             // Combination of multiple rules from RFC7230 and RFC 3986. Must be
             // ASCII, no controls plus a few additional characters excluded
-            if (IS_CONTROL[i] ||
-                    i == ' ' || i == '\"' || i == '#' || i == '<' || i == '>' || i == '\\' ||
-                    i == '^' || i == '`'  || i == '{' || i == '|' || i == '}') {
+            if (IS_CONTROL[i] || i == ' ' || i == '\"' || i == '#' || i == '<' || i == '>' || i == '\\' || i == '^' ||
+                    i == '`' || i == '{' || i == '|' || i == '}') {
                 IS_NOT_REQUEST_TARGET[i] = true;
             }
 
             /*
-             * absolute-path  = 1*( "/" segment )
-             * segment        = *pchar
-             * pchar          = unreserved / pct-encoded / sub-delims / ":" / "@"
+             * absolute-path = 1*( "/" segment ) segment = *pchar pchar = unreserved / pct-encoded / sub-delims / ":" /
+             * "@"
              *
              * Note pchar allows everything userinfo allows plus "@"
              */
@@ -154,7 +146,7 @@ public class HttpParser {
             }
 
             /*
-             * query          = *( pchar / "/" / "?" )
+             * query = *( pchar / "/" / "?" )
              *
              * Note query allows everything absolute-path allows plus "?"
              */
@@ -219,7 +211,7 @@ public class HttpParser {
         }
 
         StringBuilder result = new StringBuilder();
-        for (int i = start ; i < end; i++) {
+        for (int i = start; i < end; i++) {
             char c = input.charAt(i);
             if (input.charAt(i) == '\\') {
                 i++;
@@ -248,17 +240,14 @@ public class HttpParser {
 
 
     /**
-     * Is the provided String a token as per RFC 7230?
-     * <br>
-     * Note: token = 1 * tchar (RFC 7230)
-     * <br>
-     * Since a token requires at least 1 tchar, {@code null} and the empty
-     * string ({@code ""}) are not considered to be valid tokens.
+     * Is the provided String a token as per RFC 7230? <br>
+     * Note: token = 1 * tchar (RFC 7230) <br>
+     * Since a token requires at least 1 tchar, {@code null} and the empty string ({@code ""}) are not considered to be
+     * valid tokens.
      *
      * @param s The string to test
      *
-     * @return {@code true} if the string is a valid token, otherwise
-     *         {@code false}
+     * @return {@code true} if the string is a valid token, otherwise {@code false}
      */
     public static boolean isToken(String s) {
         if (s == null) {
@@ -336,17 +325,14 @@ public class HttpParser {
 
 
     /**
-     * Is the provided String a scheme as per RFC 3986?
-     * <br>
-     * Note: scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
-     * <br>
-     * Since a scheme requires at least 1 ALPHA, {@code null} and the empty
-     * string ({@code ""}) are not considered to be valid tokens.
+     * Is the provided String a scheme as per RFC 3986? <br>
+     * Note: scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." ) <br>
+     * Since a scheme requires at least 1 ALPHA, {@code null} and the empty string ({@code ""}) are not considered to be
+     * valid tokens.
      *
      * @param s The string to test
      *
-     * @return {@code true} if the string is a valid scheme, otherwise
-     *         {@code false}
+     * @return {@code true} if the string is a valid scheme, otherwise {@code false}
      */
     public static boolean isScheme(String s) {
         if (s == null) {
@@ -453,9 +439,8 @@ public class HttpParser {
     }
 
     /**
-     * @return  the token if one was found, the empty string if no data was
-     *          available to read or <code>null</code> if data other than a
-     *          token was found
+     * @return the token if one was found, the empty string if no data was available to read or <code>null</code> if
+     *             data other than a token was found
      */
     static String readToken(Reader input) throws IOException {
         StringBuilder result = new StringBuilder();
@@ -481,8 +466,8 @@ public class HttpParser {
     }
 
     /**
-     * @return  the digits if any were found, the empty string if no data was
-     *          found or if data other than digits was found
+     * @return the digits if any were found, the empty string if no data was found or if data other than digits was
+     *             found
      */
     static String readDigits(Reader input) throws IOException {
         StringBuilder result = new StringBuilder();
@@ -504,8 +489,7 @@ public class HttpParser {
     }
 
     /**
-     * @return  the number if digits were found, -1 if no data was found
-     *          or if data other than digits was found
+     * @return the number if digits were found, -1 if no data was found or if data other than digits was found
      */
     static long readLong(Reader input) throws IOException {
         String digits = readDigits(input);
@@ -518,9 +502,8 @@ public class HttpParser {
     }
 
     /**
-     * @return the quoted string if one was found, null if data other than a
-     *         quoted string was found or null if the end of data was reached
-     *         before the quoted string was terminated
+     * @return the quoted string if one was found, null if data other than a quoted string was found or null if the end
+     *             of data was reached before the quoted string was terminated
      */
     static String readQuotedString(Reader input, boolean returnQuoted) throws IOException {
 
@@ -558,8 +541,7 @@ public class HttpParser {
         return result.toString();
     }
 
-    static String readTokenOrQuotedString(Reader input, boolean returnQuoted)
-            throws IOException {
+    static String readTokenOrQuotedString(Reader input, boolean returnQuoted) throws IOException {
 
         // Peek at next character to enable correct method to be called
         int c = skipLws(input);
@@ -572,16 +554,13 @@ public class HttpParser {
     }
 
     /**
-     * Token can be read unambiguously with or without surrounding quotes so
-     * this parsing method for token permits optional surrounding double quotes.
-     * This is not defined in any RFC. It is a special case to handle data from
-     * buggy clients (known buggy clients for DIGEST auth include Microsoft IE 8
-     * &amp; 9, Apple Safari for OSX and iOS) that add quotes to values that
-     * should be tokens.
+     * Token can be read unambiguously with or without surrounding quotes so this parsing method for token permits
+     * optional surrounding double quotes. This is not defined in any RFC. It is a special case to handle data from
+     * buggy clients (known buggy clients for DIGEST auth include Microsoft IE 8 &amp; 9, Apple Safari for OSX and iOS)
+     * that add quotes to values that should be tokens.
      *
-     * @return the token if one was found, null if data other than a token or
-     *         quoted token was found or null if the end of data was reached
-     *         before a quoted token was terminated
+     * @return the token if one was found, null if data other than a token or quoted token was found or null if the end
+     *             of data was reached before a quoted token was terminated
      */
     static String readQuotedToken(Reader input) throws IOException {
 
@@ -626,18 +605,15 @@ public class HttpParser {
     }
 
     /**
-     * LHEX can be read unambiguously with or without surrounding quotes so this
-     * parsing method for LHEX permits optional surrounding double quotes. Some
-     * buggy clients (libwww-perl for DIGEST auth) are known to send quoted LHEX
-     * when the specification requires just LHEX.
-     *
+     * LHEX can be read unambiguously with or without surrounding quotes so this parsing method for LHEX permits
+     * optional surrounding double quotes. Some buggy clients (libwww-perl for DIGEST auth) are known to send quoted
+     * LHEX when the specification requires just LHEX.
      * <p>
-     * LHEX are, literally, lower-case hexadecimal digits. This implementation
-     * allows for upper-case digits as well, converting the returned value to
-     * lower-case.
+     * LHEX are, literally, lower-case hexadecimal digits. This implementation allows for upper-case digits as well,
+     * converting the returned value to lower-case.
      *
-     * @return  the sequence of LHEX (minus any surrounding quotes) if any was
-     *          found, or <code>null</code> if data other LHEX was found
+     * @return the sequence of LHEX (minus any surrounding quotes) if any was found, or <code>null</code> if data other
+     *             LHEX was found
      */
     static String readLhex(Reader input) throws IOException {
 
@@ -762,9 +738,8 @@ public class HttpParser {
 
 
     /**
-     * @return If inIPv6 is false, the position of ':' that separates the host
-     *         from the port or -1 if it is not present. If inIPv6 is true, the
-     *         number of characters read
+     * @return If inIPv6 is false, the position of ':' that separates the host from the port or -1 if it is not present.
+     *             If inIPv6 is true, the number of characters read
      */
     static int readHostIPv4(Reader reader, boolean inIPv6) throws IOException {
         int octet = -1;
@@ -783,8 +758,7 @@ public class HttpParser {
                     octetCount++;
                     octet = -1;
                 } else if (inIPv6 || octet == -1) {
-                    throw new IllegalArgumentException(
-                            sm.getString("http.invalidOctet", Integer.toString(octet)));
+                    throw new IllegalArgumentException(sm.getString("http.invalidOctet", Integer.toString(octet)));
                 } else {
                     // Might not be an IPv4 address. Could be a host / FQDN with
                     // a fully numeric component.
@@ -831,8 +805,8 @@ public class HttpParser {
                 reader.reset();
                 return readHostDomainName(reader);
             } else {
-                throw new IllegalArgumentException(sm.getString(
-                        "http.illegalCharacterIpv4", Character.toString((char) c)));
+                throw new IllegalArgumentException(
+                        sm.getString("http.illegalCharacterIpv4", Character.toString((char) c)));
             }
             pos++;
         } while (true);
@@ -854,8 +828,7 @@ public class HttpParser {
 
 
     /**
-     * @return The position of ':' that separates the host from the port or -1
-     *         if it is not present
+     * @return The position of ':' that separates the host from the port or -1 if it is not present
      */
     static int readHostIPv6(Reader reader) throws IOException {
         // Must start with '['
@@ -887,16 +860,15 @@ public class HttpParser {
                     throw new IllegalArgumentException(sm.getString("http.invalidHextet"));
                 }
             } else if (c == ':') {
-                if (precedingColonsCount >=2 ) {
+                if (precedingColonsCount >= 2) {
                     // ::: is not allowed
                     throw new IllegalArgumentException(sm.getString("http.tooManyColons"));
                 } else {
-                    if(precedingColonsCount == 1) {
+                    if (precedingColonsCount == 1) {
                         // End of ::
-                        if (parsedDoubleColon ) {
+                        if (parsedDoubleColon) {
                             // Only allowed one :: sequence
-                            throw new IllegalArgumentException(
-                                    sm.getString("http.tooManyDoubleColons"));
+                            throw new IllegalArgumentException(sm.getString("http.tooManyDoubleColons"));
                         }
                         parsedDoubleColon = true;
                         // :: represents at least one h16 block
@@ -925,35 +897,31 @@ public class HttpParser {
                     throw new IllegalArgumentException(sm.getString("http.invalidIpv4Location"));
                 }
             } else {
-                throw new IllegalArgumentException(sm.getString(
-                        "http.illegalCharacterIpv6", Character.toString((char) c)));
+                throw new IllegalArgumentException(
+                        sm.getString("http.illegalCharacterIpv6", Character.toString((char) c)));
             }
             pos++;
         } while (true);
 
         if (h16Count > 8) {
-            throw new IllegalArgumentException(
-                    sm.getString("http.tooManyHextets", Integer.toString(h16Count)));
+            throw new IllegalArgumentException(sm.getString("http.tooManyHextets", Integer.toString(h16Count)));
         } else if (h16Count != 8 && !parsedDoubleColon) {
-            throw new IllegalArgumentException(
-                    sm.getString("http.tooFewHextets", Integer.toString(h16Count)));
+            throw new IllegalArgumentException(sm.getString("http.tooFewHextets", Integer.toString(h16Count)));
         }
 
         c = reader.read();
         if (c == ':') {
             return validatePort(reader, pos);
         } else {
-            if(c == -1) {
+            if (c == -1) {
                 return -1;
             }
-            throw new IllegalArgumentException(
-                    sm.getString("http.illegalAfterIpv6", Character.toString((char) c)));
+            throw new IllegalArgumentException(sm.getString("http.illegalAfterIpv6", Character.toString((char) c)));
         }
     }
 
     /**
-     * @return The position of ':' that separates the host from the port or -1
-     *         if it is not present
+     * @return The position of ':' that separates the host from the port or -1 if it is not present
      */
     static int readHostDomainName(Reader reader) throws IOException {
         DomainParseState state = DomainParseState.NEW;
@@ -986,9 +954,9 @@ public class HttpParser {
     }
 
 
-     /**
-     * Skips all characters until EOF or the specified target is found. Normally
-     * used to skip invalid input until the next separator.
+    /**
+     * Skips all characters until EOF or the specified target is found. Normally used to skip invalid input until the
+     * next separator.
      */
     static SkipResult skipUntil(Reader input, int c, char target) throws IOException {
         while (c != -1 && c != target) {
@@ -1016,13 +984,13 @@ public class HttpParser {
 
 
     private enum DomainParseState {
-        NEW(     true, false, false, false, "http.invalidCharacterDomain.atStart"),
-        ALPHA(   true,  true,  true,  true, "http.invalidCharacterDomain.afterLetter"),
-        NUMERIC( true,  true,  true,  true, "http.invalidCharacterDomain.afterNumber"),
-        PERIOD(  true, false, false,  true, "http.invalidCharacterDomain.afterPeriod"),
-        HYPHEN(  true,  true, false, false, "http.invalidCharacterDomain.afterHyphen"),
-        COLON(  false, false, false, false, "http.invalidCharacterDomain.afterColon"),
-        END(    false, false, false, false, "http.invalidCharacterDomain.atEnd");
+        NEW(true, false, false, false, "http.invalidCharacterDomain.atStart"),
+        ALPHA(true, true, true, true, "http.invalidCharacterDomain.afterLetter"),
+        NUMERIC(true, true, true, true, "http.invalidCharacterDomain.afterNumber"),
+        PERIOD(true, false, false, true, "http.invalidCharacterDomain.afterPeriod"),
+        HYPHEN(true, true, false, false, "http.invalidCharacterDomain.afterHyphen"),
+        COLON(false, false, false, false, "http.invalidCharacterDomain.afterColon"),
+        END(false, false, false, false, "http.invalidCharacterDomain.atEnd");
 
         private final boolean mayContinue;
         private final boolean allowsHyphen;
@@ -1030,8 +998,8 @@ public class HttpParser {
         private final boolean allowsEnd;
         private final String errorMsg;
 
-        DomainParseState(boolean mayContinue, boolean allowsHyphen, boolean allowsPeriod,
-                boolean allowsEnd, String errorMsg) {
+        DomainParseState(boolean mayContinue, boolean allowsHyphen, boolean allowsPeriod, boolean allowsEnd,
+                String errorMsg) {
             this.mayContinue = mayContinue;
             this.allowsHyphen = allowsHyphen;
             this.allowsPeriod = allowsPeriod;
@@ -1048,8 +1016,7 @@ public class HttpParser {
                 if (allowsEnd) {
                     return END;
                 } else {
-                    throw new IllegalArgumentException(
-                            sm.getString("http.invalidSegmentEndState", this.name()));
+                    throw new IllegalArgumentException(sm.getString("http.invalidSegmentEndState", this.name()));
                 }
             } else if (HttpParser.isAlpha(c)) {
                 return ALPHA;
@@ -1059,26 +1026,23 @@ public class HttpParser {
                 if (allowsPeriod) {
                     return PERIOD;
                 } else {
-                    throw new IllegalArgumentException(sm.getString(errorMsg,
-                            Character.toString((char) c)));
+                    throw new IllegalArgumentException(sm.getString(errorMsg, Character.toString((char) c)));
                 }
             } else if (c == ':') {
                 if (allowsEnd) {
                     return COLON;
                 } else {
-                    throw new IllegalArgumentException(sm.getString(errorMsg,
-                            Character.toString((char) c)));
+                    throw new IllegalArgumentException(sm.getString(errorMsg, Character.toString((char) c)));
                 }
             } else if (c == '-') {
                 if (allowsHyphen) {
                     return HYPHEN;
                 } else {
-                    throw new IllegalArgumentException(sm.getString(errorMsg,
-                            Character.toString((char) c)));
+                    throw new IllegalArgumentException(sm.getString(errorMsg, Character.toString((char) c)));
                 }
             } else {
-                throw new IllegalArgumentException(sm.getString(
-                        "http.illegalCharacterDomain", Character.toString((char) c)));
+                throw new IllegalArgumentException(
+                        sm.getString("http.illegalCharacterDomain", Character.toString((char) c)));
             }
         }
     }

==================================================
MediaTypeCache.java
index 52203cf3de..f89f12444b 100644
--- a/java/org/apache/tomcat/util/http/parser/MediaType.java
+++ b/java/org/apache/tomcat/util/http/parser/MediaType.java
@@ -72,7 +72,7 @@ public class MediaType {
                     result.append(type);
                     result.append('/');
                     result.append(subtype);
-                    for (Map.Entry<String, String> entry : parameters.entrySet()) {
+                    for (Map.Entry<String,String> entry : parameters.entrySet()) {
                         String value = entry.getValue();
                         if (value == null || value.length() == 0) {
                             continue;
@@ -98,7 +98,7 @@ public class MediaType {
                     result.append(type);
                     result.append('/');
                     result.append(subtype);
-                    for (Map.Entry<String, String> entry : parameters.entrySet()) {
+                    for (Map.Entry<String,String> entry : parameters.entrySet()) {
                         if (entry.getKey().equalsIgnoreCase("charset")) {
                             continue;
                         }
@@ -119,7 +119,9 @@ public class MediaType {
      * Parses a MediaType value, either from an HTTP header or from an application.
      *
      * @param input a reader over the header text
+     *
      * @return a MediaType parsed from the input, or null if not valid
+     *
      * @throws IOException if there was a problem reading the input
      */
     public static MediaType parseMediaType(StringReader input) throws IOException {

==================================================
StructuredField.java
index 191aef307c..5495d55bec 100644
--- a/java/org/apache/tomcat/util/http/parser/MediaTypeCache.java
+++ b/java/org/apache/tomcat/util/http/parser/MediaTypeCache.java
@@ -33,14 +33,13 @@ public class MediaTypeCache {
     }
 
     /**
-     * Looks in the cache and returns the cached value if one is present. If no
-     * match exists in the cache, a new parser is created, the input parsed and
-     * the results placed in the cache and returned to the user.
+     * Looks in the cache and returns the cached value if one is present. If no match exists in the cache, a new parser
+     * is created, the input parsed and the results placed in the cache and returned to the user.
      *
      * @param input The content-type header value to parse
-     * @return      The results are provided as a two element String array. The
-     *                  first element is the media type less the charset and
-     *                  the second element is the charset
+     *
+     * @return The results are provided as a two element String array. The first element is the media type less the
+     *             charset and the second element is the charset
      */
     public String[] parse(String input) {
         String[] result = cache.get(input);
@@ -56,7 +55,7 @@ public class MediaTypeCache {
             // Ignore - return null
         }
         if (m != null) {
-            result = new String[] {m.toStringNoCharset(), m.getCharset()};
+            result = new String[] { m.toStringNoCharset(), m.getCharset() };
             cache.put(input, result);
         }
 

==================================================
TokenList.java
index 5b8a695440..ab31edfe99 100644
--- a/java/org/apache/tomcat/util/http/parser/StructuredField.java
+++ b/java/org/apache/tomcat/util/http/parser/StructuredField.java
@@ -29,9 +29,8 @@ import org.apache.tomcat.util.res.StringManager;
 /**
  * Parsing of structured fields as per RFC 8941.
  * <p>
- * The parsing implementation is complete but not all elements are currently
- * exposed via getters. Additional getters will be added as required as the
- * use of structured fields expands.
+ * The parsing implementation is complete but not all elements are currently exposed via getters. Additional getters
+ * will be added as required as the use of structured fields expands.
  * <p>
  * The serialization of structured fields has not been implemented.
  */
@@ -52,7 +51,7 @@ public class StructuredField {
             if (i == '*' || i >= 'a' && i <= 'z') {
                 IS_KEY_FIRST[i] = true;
                 IS_KEY[i] = true;
-            } else if (i  >= '0' && i <= '9' || i == '_' || i == '-' || i == '.'){
+            } else if (i >= '0' && i <= '9' || i == '_' || i == '-' || i == '.') {
                 IS_KEY[i] = true;
             }
         }

==================================================
Upgrade.java
index d805c61841..b2c15fb909 100644
--- a/java/org/apache/tomcat/util/http/parser/TokenList.java
+++ b/java/org/apache/tomcat/util/http/parser/TokenList.java
@@ -31,16 +31,13 @@ public class TokenList {
 
 
     /**
-     * Parses an enumeration of header values of the form 1#token, forcing all
-     * parsed values to lower case.
+     * Parses an enumeration of header values of the form 1#token, forcing all parsed values to lower case.
      *
      * @param inputs     The headers to parse
-     * @param collection The Collection (usually a list or a set) to which the
-     *                       parsed tokens should be added
+     * @param collection The Collection (usually a list or a set) to which the parsed tokens should be added
      *
-     * @return {@code true} if the header values were parsed cleanly and at
-     *         least one token was found, otherwise {@code false} (e.g. if a
-     *         non-token value was encountered)
+     * @return {@code true} if the header values were parsed cleanly and at least one token was found, otherwise
+     *             {@code false} (e.g. if a non-token value was encountered)
      *
      * @throws IOException If an I/O error occurs reading the header
      */
@@ -59,16 +56,13 @@ public class TokenList {
 
 
     /**
-     * Parses a header of the form 1#token, forcing all parsed values to lower
-     * case.
+     * Parses a header of the form 1#token, forcing all parsed values to lower case.
      *
      * @param input      The header to parse
-     * @param collection The Collection (usually a list or a set) to which the
-     *                       parsed tokens should be added
+     * @param collection The Collection (usually a list or a set) to which the parsed tokens should be added
      *
-     * @return {@code true} if the header values were parsed cleanly and at
-     *         least one token was found, otherwise {@code false} (e.g. if a
-     *         non-token value was encountered)
+     * @return {@code true} if the header values were parsed cleanly and at least one token was found, otherwise
+     *             {@code false} (e.g. if a non-token value was encountered)
      *
      * @throws IOException If an I/O error occurs reading the header
      */

==================================================
