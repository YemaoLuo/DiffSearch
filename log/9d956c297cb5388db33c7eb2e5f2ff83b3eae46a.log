9d956c297cb5388db33c7eb2e5f2ff83b3eae46a
==================================================
Further work for
==================================================
Mark Emlyn
==================================================
Tue Jan 21 14:08:03 2014 +0000
==================================================
ELNode.java
Further work for
https://issues.apache.org/bugzilla/show_bug.cgi?id=56029
Review from kkolinko
- Fix bug in parsing functions and whitespace
- More efficient resetting of StringBuidler
- Use String.substring() for token and whitespace
- avoid unnecessary use of trim()

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1560017 13f79535-47bb-0310-9956-ffa450edef68



==================================================
ELParser.java
index 8f16cc3bd5..ea9984ce33 100644
--- a/java/org/apache/jasper/compiler/ELNode.java
+++ b/java/org/apache/jasper/compiler/ELNode.java
@@ -122,14 +122,16 @@ abstract class ELNode {
 
         private final String prefix;
         private final String name;
+        private final String originalText;
         private String uri;
         private FunctionInfo functionInfo;
         private String methodName;
         private String[] parameters;
 
-        Function(String prefix, String name) {
+        Function(String prefix, String name, String originalText) {
             this.prefix = prefix;
             this.name = name;
+            this.originalText = originalText;
         }
 
         @Override
@@ -145,6 +147,10 @@ abstract class ELNode {
             return name;
         }
 
+        public String getOriginalText() {
+            return originalText;
+        }
+
         public void setUri(String uri) {
             this.uri = uri;
         }

==================================================
TestELInJsp.java
index c4e22b3ee3..67191d40f8 100644
--- a/java/org/apache/jasper/compiler/ELParser.java
+++ b/java/org/apache/jasper/compiler/ELParser.java
@@ -38,7 +38,7 @@ public class ELParser {
 
     private Token curToken;  // current token
     private Token prevToken; // previous token
-    private StringBuilder whiteSpace = new StringBuilder();
+    private String whiteSpace = "";
 
     private final ELNode.Nodes expr;
 
@@ -96,7 +96,9 @@ public class ELParser {
      *
      * @return An ELNode.Nodes representing the EL expression
      *
-     * TODO: Can this be refactored to use the standard EL implementation?
+     * Note: This can not be refactored to use the standard EL implementation as
+     *       the EL API does not provide the level of access required to the
+     *       parsed expression.
      */
     private ELNode.Nodes parseEL() {
 
@@ -115,7 +117,7 @@ public class ELParser {
                 // Output whatever is in buffer
                 if (buf.length() > 0) {
                     ELexpr.add(new ELNode.ELText(buf.toString()));
-                    buf = new StringBuilder();
+                    buf.setLength(0);
                 }
                 if (!parseFunction()) {
                     ELexpr.add(new ELNode.ELText(curToken.toString()));
@@ -138,12 +140,13 @@ public class ELParser {
      * arguments
      */
     private boolean parseFunction() {
-        if (!(curToken instanceof Id) || isELReserved(curToken.toString()) ||
+        if (!(curToken instanceof Id) || isELReserved(curToken.toTrimmedString()) ||
                 prevToken instanceof Char && prevToken.toChar() == '.') {
             return false;
         }
         String s1 = null; // Function prefix
-        String s2 = curToken.toString(); // Function name
+        String s2 = curToken.toTrimmedString(); // Function name
+        int start = index - curToken.toString().length();
         Token original = curToken;
         if (hasNext()) {
             int mark = getIndex() - whiteSpace.length();
@@ -153,7 +156,7 @@ public class ELParser {
                     Token t2 = nextToken();
                     if (t2 instanceof Id) {
                         s1 = s2.trim();
-                        s2 = t2.toString();
+                        s2 = t2.toTrimmedString();
                         if (hasNext()) {
                             curToken = nextToken();
                         }
@@ -161,7 +164,7 @@ public class ELParser {
                 }
             }
             if (curToken.toChar() == '(') {
-                ELexpr.add(new ELNode.Function(s1, s2.trim()));
+                ELexpr.add(new ELNode.Function(s1, s2, expression.substring(start, index - 1)));
                 return true;
             }
             curToken = original;
@@ -245,29 +248,29 @@ public class ELParser {
     }
 
     private String getAndResetWhiteSpace() {
-        String result = whiteSpace.toString();
-        whiteSpace = new StringBuilder();
+        String result = whiteSpace;
+        whiteSpace = "";
         return result;
     }
 
     /*
+     * Implementation note: This method assumes that it is always preceded by a
+     * call to hasNext() in order for whitespace handling to be correct.
+     *
      * @return The next token in the EL expression buffer.
      */
     private Token nextToken() {
         prevToken = curToken;
-        skipSpaces();
         if (hasNextChar()) {
             char ch = nextChar();
             if (Character.isJavaIdentifierStart(ch)) {
-                StringBuilder buf = new StringBuilder();
-                buf.append(ch);
+                int start = index - 1;
                 while (index < expression.length() &&
                         Character.isJavaIdentifierPart(
                                 ch = expression.charAt(index))) {
-                    buf.append(ch);
                     nextChar();
                 }
-                return new Id(getAndResetWhiteSpace(), buf.toString());
+                return new Id(getAndResetWhiteSpace(), expression.substring(start, index));
             }
 
             if (ch == '\'' || ch == '"') {
@@ -311,13 +314,14 @@ public class ELParser {
      */
 
     private void skipSpaces() {
+        int start = index;
         while (hasNextChar()) {
             char c = expression.charAt(index);
             if (c > ' ')
                 break;
-            whiteSpace.append(c);
             index++;
         }
+        whiteSpace = expression.substring(start, index);
     }
 
     private boolean hasNextChar() {
@@ -359,6 +363,10 @@ public class ELParser {
             return whiteSpace;
         }
 
+        String toTrimmedString() {
+            return "";
+        }
+
         String getWhiteSpace() {
             return whiteSpace;
         }
@@ -379,6 +387,11 @@ public class ELParser {
         public String toString() {
             return whiteSpace + id;
         }
+
+        @Override
+        String toTrimmedString() {
+            return id;
+        }
     }
 
     /*
@@ -402,6 +415,11 @@ public class ELParser {
         public String toString() {
             return whiteSpace + ch;
         }
+
+        @Override
+        String toTrimmedString() {
+            return "" + ch;
+        }
     }
 
     /*
@@ -420,6 +438,11 @@ public class ELParser {
         public String toString() {
             return whiteSpace + value;
         }
+
+        @Override
+        String toTrimmedString() {
+            return value;
+        }
     }
 
     public char getType() {
@@ -445,11 +468,7 @@ public class ELParser {
 
         @Override
         public void visit(Function n) throws JasperException {
-            if (n.getPrefix() != null) {
-                output.append(n.getPrefix());
-                output.append(':');
-            }
-            output.append(n.getName());
+            output.append(n.getOriginalText());
             output.append('(');
         }
 

==================================================
TestELParser.java
index acc39ca72d..550e5daadf 100644
--- a/test/org/apache/el/TestELInJsp.java
+++ b/test/org/apache/el/TestELInJsp.java
@@ -472,7 +472,7 @@ public class TestELInJsp extends TomcatBaseTest {
 
         String result = res.toString();
 
-        Assert.assertTrue(result.contains("[1]"));
+        Assert.assertTrue(result.contains("[1]:[1]"));
     }
 
 

==================================================
