f2520dc0d3d836501e248f417fceada88e2f82f3
==================================================
Follow-on to r1617445
==================================================
Mark Emlyn
==================================================
Tue Aug 12 12:42:18 2014 +0000
==================================================
AuthenticatorBase.java
Follow-on to r1617445
If a client certificate is required and one is not available then force renegotiation to obtain it.
If a client certificate is optional then do not force renegotiation before trying to obtain it.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1617461 13f79535-47bb-0310-9956-ffa450edef68



==================================================
SSLAuthenticator.java
index 43a8472a1c..086019ac14 100644
--- a/java/org/apache/catalina/authenticator/AuthenticatorBase.java
+++ b/java/org/apache/catalina/authenticator/AuthenticatorBase.java
@@ -567,7 +567,7 @@ public abstract class AuthenticatorBase extends ValveBase
         }
 
         if (!authRequired && context.getPreemptiveAuthentication()) {
-            X509Certificate[] certs = getRequestCertificates(request);
+            X509Certificate[] certs = getRequestCertificates(request, false);
             authRequired = certs != null && certs.length > 0;
         }
 
@@ -625,11 +625,13 @@ public abstract class AuthenticatorBase extends ValveBase
      * extracting the certificate chain from the Coyote request.
      *
      * @param request   Request to be processed
+     * @param force     Should a renegotiation be forced to request certificates
+     *                  from the user agent if none have been provided
      *
      * @return          The X509 certificate chain if found, <code>null</code>
      *                  otherwise.
      */
-    protected X509Certificate[] getRequestCertificates(final Request request)
+    protected X509Certificate[] getRequestCertificates(final Request request, boolean force)
             throws IllegalStateException {
 
         X509Certificate certs[] =
@@ -637,7 +639,7 @@ public abstract class AuthenticatorBase extends ValveBase
 
         if ((certs == null) || (certs.length < 1)) {
             try {
-                request.getCoyoteRequest().action (ActionCode.REQ_SSL_CERTIFICATE, null);
+                request.getCoyoteRequest().action(ActionCode.REQ_SSL_CERTIFICATE, Boolean.valueOf(force));
                 certs = (X509Certificate[]) request.getAttribute(Globals.CERTIFICATES_ATTR);
             } catch (IllegalStateException ise) {
                 // Request body was too large for save buffer

==================================================
Http11AprProcessor.java
index 0269ee4b9d..56376bf4cc 100644
--- a/java/org/apache/catalina/authenticator/SSLAuthenticator.java
+++ b/java/org/apache/catalina/authenticator/SSLAuthenticator.java
@@ -95,7 +95,7 @@ public class SSLAuthenticator extends AuthenticatorBase {
             containerLog.debug(" Looking up certificates");
         }
 
-        X509Certificate certs[] = getRequestCertificates(request);
+        X509Certificate certs[] = getRequestCertificates(request, true);
 
         if ((certs == null) || (certs.length < 1)) {
             if (containerLog.isDebugEnabled()) {

==================================================
Http11Nio2Processor.java
index e4ecd1a370..30d3225c79 100644
--- a/java/org/apache/coyote/http11/Http11AprProcessor.java
+++ b/java/org/apache/coyote/http11/Http11AprProcessor.java
@@ -419,18 +419,26 @@ public class Http11AprProcessor extends AbstractHttp11Processor<Long> {
         }
         case REQ_SSL_CERTIFICATE: {
             if (endpoint.isSSLEnabled() && (socketRef != 0)) {
-                // Consume and buffer the request body, so that it does not
-                // interfere with the client's handshake messages
-                InputFilter[] inputFilters = inputBuffer.getFilters();
-                ((BufferedInputFilter) inputFilters[Constants.BUFFERED_FILTER]).setLimit(maxSavePostSize);
-                inputBuffer.addActiveFilter(inputFilters[Constants.BUFFERED_FILTER]);
+                boolean force = ((Boolean) param).booleanValue();
+                if (force) {
+                    /* Forced triggers a handshake so consume and buffer the
+                     * request body, so that it does not interfere with the
+                     * client's handshake messages
+                     */
+                    InputFilter[] inputFilters = inputBuffer.getFilters();
+                    ((BufferedInputFilter) inputFilters[Constants.BUFFERED_FILTER])
+                            .setLimit(maxSavePostSize);
+                    inputBuffer.addActiveFilter(inputFilters[Constants.BUFFERED_FILTER]);
+                }
                 try {
-                    // Configure connection to require a certificate
-                    SSLSocket.setVerify(socketRef, SSL.SSL_CVERIFY_REQUIRE,
-                            ((AprEndpoint)endpoint).getSSLVerifyDepth());
-                    // Renegotiate certificates
-                    if (SSLSocket.renegotiate(socketRef) == 0) {
-                        // Don't look for certs unless we know renegotiation worked.
+                    if (force) {
+                        // Configure connection to require a certificate
+                        SSLSocket.setVerify(socketRef, SSL.SSL_CVERIFY_REQUIRE,
+                                ((AprEndpoint)endpoint).getSSLVerifyDepth());
+                    }
+                    if (!force || SSLSocket.renegotiate(socketRef) == 0) {
+                        // Only look for certs if not forcing a renegotiation or
+                        // if we know renegotiation worked.
                         // Get client certificate and the certificate chain if present
                         // certLength == -1 indicates an error
                         int certLength = SSLSocket.getInfoI(socketRef,SSL.SSL_INFO_CLIENT_CERT_CHAIN);

==================================================
Http11NioProcessor.java
index 6abd2004b8..6ee96f5bc6 100644
--- a/java/org/apache/coyote/http11/Http11Nio2Processor.java
+++ b/java/org/apache/coyote/http11/Http11Nio2Processor.java
@@ -465,18 +465,20 @@ public class Http11Nio2Processor extends AbstractHttp11Processor<Nio2Channel> {
         }
         case REQ_SSL_CERTIFICATE: {
             if (sslSupport != null && socketWrapper.getSocket() != null) {
-                /*
-                 * Consume and buffer the request body, so that it does not
-                 * interfere with the client's handshake messages
-                 */
-                InputFilter[] inputFilters = inputBuffer.getFilters();
-                ((BufferedInputFilter) inputFilters[Constants.BUFFERED_FILTER])
-                    .setLimit(maxSavePostSize);
-                inputBuffer.addActiveFilter
-                    (inputFilters[Constants.BUFFERED_FILTER]);
+                boolean force = ((Boolean) param).booleanValue();
+                if (force) {
+                    /* Forced triggers a handshake so consume and buffer the
+                     * request body, so that it does not interfere with the
+                     * client's handshake messages
+                     */
+                    InputFilter[] inputFilters = inputBuffer.getFilters();
+                    ((BufferedInputFilter) inputFilters[Constants.BUFFERED_FILTER])
+                            .setLimit(maxSavePostSize);
+                    inputBuffer.addActiveFilter(inputFilters[Constants.BUFFERED_FILTER]);
+                }
                 SecureNio2Channel sslChannel = (SecureNio2Channel) socketWrapper.getSocket();
                 SSLEngine engine = sslChannel.getSslEngine();
-                if (!engine.getNeedClientAuth()) {
+                if (!engine.getNeedClientAuth() && force) {
                     // Need to re-negotiate SSL connection
                     engine.setNeedClientAuth(true);
                     try {
@@ -493,9 +495,8 @@ public class Http11Nio2Processor extends AbstractHttp11Processor<Nio2Channel> {
                     // use force=false since re-negotiation is handled above
                     // (and it is a NO-OP for NIO anyway)
                     Object sslO = sslSupport.getPeerCertificateChain(false);
-                    if( sslO != null) {
-                        request.setAttribute
-                            (SSLSupport.CERTIFICATE_KEY, sslO);
+                    if (sslO != null) {
+                        request.setAttribute(SSLSupport.CERTIFICATE_KEY, sslO);
                     }
                 } catch (Exception e) {
                     log.warn(sm.getString("http11processor.socket.ssl"), e);

==================================================
Http11Processor.java
index 30aa9e9697..c3045c6328 100644
--- a/java/org/apache/coyote/http11/Http11NioProcessor.java
+++ b/java/org/apache/coyote/http11/Http11NioProcessor.java
@@ -434,18 +434,20 @@ public class Http11NioProcessor extends AbstractHttp11Processor<NioChannel> {
         }
         case REQ_SSL_CERTIFICATE: {
             if (sslSupport != null) {
-                /*
-                 * Consume and buffer the request body, so that it does not
-                 * interfere with the client's handshake messages
-                 */
-                InputFilter[] inputFilters = inputBuffer.getFilters();
-                ((BufferedInputFilter) inputFilters[Constants.BUFFERED_FILTER])
-                    .setLimit(maxSavePostSize);
-                inputBuffer.addActiveFilter
-                    (inputFilters[Constants.BUFFERED_FILTER]);
+                boolean force = ((Boolean) param).booleanValue();
+                if (force) {
+                    /* Forced triggers a handshake so consume and buffer the
+                     * request body, so that it does not interfere with the
+                     * client's handshake messages
+                     */
+                    InputFilter[] inputFilters = inputBuffer.getFilters();
+                    ((BufferedInputFilter) inputFilters[Constants.BUFFERED_FILTER])
+                            .setLimit(maxSavePostSize);
+                    inputBuffer.addActiveFilter(inputFilters[Constants.BUFFERED_FILTER]);
+                }
                 SecureNioChannel sslChannel = (SecureNioChannel) socketWrapper.getSocket();
                 SSLEngine engine = sslChannel.getSslEngine();
-                if (!engine.getNeedClientAuth()) {
+                if (!engine.getNeedClientAuth() && force) {
                     // Need to re-negotiate SSL connection
                     engine.setNeedClientAuth(true);
                     try {
@@ -462,9 +464,8 @@ public class Http11NioProcessor extends AbstractHttp11Processor<NioChannel> {
                     // use force=false since re-negotiation is handled above
                     // (and it is a NO-OP for NIO anyway)
                     Object sslO = sslSupport.getPeerCertificateChain(false);
-                    if( sslO != null) {
-                        request.setAttribute
-                            (SSLSupport.CERTIFICATE_KEY, sslO);
+                    if (sslO != null) {
+                        request.setAttribute(SSLSupport.CERTIFICATE_KEY, sslO);
                     }
                 } catch (Exception e) {
                     log.warn(sm.getString("http11processor.socket.ssl"), e);

==================================================
TestClientCert.java
index 98f8dbad16..0deb42c923 100644
--- a/java/org/apache/coyote/http11/Http11Processor.java
+++ b/java/org/apache/coyote/http11/Http11Processor.java
@@ -350,17 +350,19 @@ public class Http11Processor extends AbstractHttp11Processor<Socket> {
         }
         case REQ_SSL_CERTIFICATE: {
             if (sslSupport != null) {
-                /*
-                 * Consume and buffer the request body, so that it does not
-                 * interfere with the client's handshake messages
-                 */
-                InputFilter[] inputFilters = inputBuffer.getFilters();
-                ((BufferedInputFilter) inputFilters[Constants.BUFFERED_FILTER])
-                    .setLimit(maxSavePostSize);
-                inputBuffer.addActiveFilter
-                    (inputFilters[Constants.BUFFERED_FILTER]);
+                boolean force = ((Boolean) param).booleanValue();
+                if (force) {
+                    /* Forced triggers a handshake so consume and buffer the
+                     * request body, so that it does not interfere with the
+                     * client's handshake messages
+                     */
+                    InputFilter[] inputFilters = inputBuffer.getFilters();
+                    ((BufferedInputFilter) inputFilters[Constants.BUFFERED_FILTER])
+                            .setLimit(maxSavePostSize);
+                    inputBuffer.addActiveFilter(inputFilters[Constants.BUFFERED_FILTER]);
+                }
                 try {
-                    Object sslO = sslSupport.getPeerCertificateChain(true);
+                    Object sslO = sslSupport.getPeerCertificateChain(force);
                     if( sslO != null) {
                         request.setAttribute
                             (SSLSupport.CERTIFICATE_KEY, sslO);

==================================================
