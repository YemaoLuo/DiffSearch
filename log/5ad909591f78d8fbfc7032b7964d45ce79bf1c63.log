5ad909591f78d8fbfc7032b7964d45ce79bf1c63
==================================================
With the changes to the behaviour AsyncContext.isStarted() this method can no longer be used to determine if complete needs to be called to add a new method that can provide this information.
==================================================
Mark Emlyn
==================================================
Wed Oct 29 21:01:06 2014 +0000
==================================================
Request.java
With the changes to the behaviour AsyncContext.isStarted() this method can no longer be used to determine if complete needs to be called to add a new method that can provide this information.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1635301 13f79535-47bb-0310-9956-ffa450edef68



==================================================
ErrorReportValve.java
index 34a5344599..2de51cb48b 100644
--- a/java/org/apache/catalina/connector/Request.java
+++ b/java/org/apache/catalina/connector/Request.java
@@ -1634,6 +1634,16 @@ public class Request
         return result.get();
     }
 
+    public boolean canAsyncComplete() {
+        if (asyncContext == null) {
+            return false;
+        }
+
+        AtomicBoolean result = new AtomicBoolean(false);
+        coyoteRequest.action(ActionCode.ASYNC_CAN_COMPLETE, result);
+        return result.get();
+    }
+
     public boolean isAsync() {
         if (asyncContext == null) {
             return false;

==================================================
ActionCode.java
index eb3508086d..9a5faa5a12 100644
--- a/java/org/apache/catalina/valves/ErrorReportValve.java
+++ b/java/org/apache/catalina/valves/ErrorReportValve.java
@@ -123,7 +123,7 @@ public class ErrorReportValve extends ValveBase {
             ExceptionUtils.handleThrowable(tt);
         }
 
-        if (request.isAsyncStarted()) {
+        if (request.canAsyncComplete()) {
             request.getAsyncContext().complete();
         }
     }

==================================================
AsyncStateMachine.java
index 263771ad01..8a6ff33bdc 100644
--- a/java/org/apache/coyote/ActionCode.java
+++ b/java/org/apache/coyote/ActionCode.java
@@ -157,6 +157,12 @@ public enum ActionCode {
      */
     ASYNC_RUN,
 
+    /**
+     * Call back to see if it is currently possible to call
+     * {@link javax.servlet.AsyncContext#complete()} without error.
+     */
+    ASYNC_CAN_COMPLETE,
+
     /**
      * Callback for an async call to
      * {@link javax.servlet.AsyncContext#complete()}

==================================================
AbstractAjpProcessor.java
index ff8fbc067f..7908dd335c 100644
--- a/java/org/apache/coyote/AsyncStateMachine.java
+++ b/java/org/apache/coyote/AsyncStateMachine.java
@@ -19,7 +19,6 @@ package org.apache.coyote;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 
-import org.apache.catalina.Globals;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.res.StringManager;
 import org.apache.tomcat.util.security.PrivilegedGetTccl;
@@ -107,38 +106,44 @@ public class AsyncStateMachine {
         StringManager.getManager(Constants.Package);
 
     private static enum AsyncState {
-        DISPATCHED(false, false, false),
-        STARTING(true, true, false),
-        STARTED(true, true, false),
-        MUST_COMPLETE(true, Globals.STRICT_SERVLET_COMPLIANCE, false),
-        COMPLETING(true, false, false),
-        TIMING_OUT(true, false, false),
-        MUST_DISPATCH(true, true, true),
-        DISPATCHING(true, false, true),
-        READ_WRITE_OP(true,true,false),
-        ERROR(true,false,false);
-
-        private boolean isAsync;
-        private boolean isStarted;
-        private boolean isDispatching;
-
-        private AsyncState(boolean isAsync, boolean isStarted,
+        DISPATCHED(false, false, false, false),
+        STARTING(true, true, true, false),
+        STARTED(true, true, true, false),
+        MUST_COMPLETE(true, true, false, false),
+        COMPLETING(true, false, false, false),
+        TIMING_OUT(true, false, false, false),
+        MUST_DISPATCH(true, true, false, true),
+        DISPATCHING(true, false, false, true),
+        READ_WRITE_OP(true, true, true, false),
+        ERROR(true, false, false, false);
+
+        private final boolean isAsync;
+        private final boolean isStarted;
+        private final boolean canComplete;
+        private final boolean isDispatching;
+
+        private AsyncState(boolean isAsync, boolean isStarted, boolean canComplete,
                 boolean isDispatching) {
             this.isAsync = isAsync;
             this.isStarted = isStarted;
+            this.canComplete = canComplete;
             this.isDispatching = isDispatching;
         }
 
         public boolean isAsync() {
-            return this.isAsync;
+            return isAsync;
         }
 
         public boolean isStarted() {
-            return this.isStarted;
+            return isStarted;
         }
 
         public boolean isDispatching() {
-            return this.isDispatching;
+            return isDispatching;
+        }
+
+        public boolean canComplete() {
+            return canComplete;
         }
     }
 
@@ -174,6 +179,10 @@ public class AsyncStateMachine {
         return state == AsyncState.ERROR;
     }
 
+    public boolean canComplete() {
+        return state.canComplete();
+    }
+
     public synchronized void asyncStart(AsyncContextCallback asyncCtxt) {
         if (state == AsyncState.DISPATCHED) {
             state = AsyncState.STARTING;

==================================================
