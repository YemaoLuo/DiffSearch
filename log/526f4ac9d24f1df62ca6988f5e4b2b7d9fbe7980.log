526f4ac9d24f1df62ca6988f5e4b2b7d9fbe7980
==================================================
Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=48738
==================================================
Mark Emlyn
==================================================
Tue Aug 24 10:02:14 2010 +0000
==================================================
AbstractOutputBuffer.java
Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=48738
Workaround a couple of long standing JDK bugs to enable GZIP compressed output streams to be flushed. Based on a patch provided by Jiong Wang.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@988459 13f79535-47bb-0310-9956-ffa450edef68



==================================================
FlushableGZIPOutputStream.java
index 34c2a1b7a1..9be5bdcae8 100644
--- a/java/org/apache/coyote/http11/AbstractOutputBuffer.java
+++ b/java/org/apache/coyote/http11/AbstractOutputBuffer.java
@@ -23,6 +23,7 @@ import java.security.PrivilegedAction;
 import org.apache.coyote.ActionCode;
 import org.apache.coyote.OutputBuffer;
 import org.apache.coyote.Response;
+import org.apache.coyote.http11.filters.GzipOutputFilter;
 import org.apache.tomcat.util.buf.ByteChunk;
 import org.apache.tomcat.util.buf.CharChunk;
 import org.apache.tomcat.util.buf.MessageBytes;
@@ -103,6 +104,12 @@ public abstract class AbstractOutputBuffer implements OutputBuffer{
      */
     protected static final StringManager sm =
         StringManager.getManager(Constants.Package);
+    
+    /**
+     * Logger.
+     */
+    protected static org.apache.juli.logging.Log log
+        = org.apache.juli.logging.LogFactory.getLog(AbstractOutputBuffer.class);
 
     // ------------------------------------------------------------- Properties
 
@@ -221,6 +228,19 @@ public abstract class AbstractOutputBuffer implements OutputBuffer{
             response.action(ActionCode.ACTION_COMMIT, null);
 
         }
+        
+        // go through the filters and if there is gzip filter
+        // invoke it to flush
+        for (int i = 0; i <= lastActiveFilter; i++) {
+            if (activeFilters[i] instanceof GzipOutputFilter) {
+                if (log.isDebugEnabled()) {
+                    log.debug("Flushing the gzip filter at position " + i +
+                            " of the filter chain...");
+                }
+                ((GzipOutputFilter) activeFilters[i]).flush();
+                break;
+            }
+        }
     }
     
     /**

==================================================
GzipOutputFilter.java
new file mode 100644
index 0000000000..1656a9c281
--- /dev/null
+++ b/java/org/apache/coyote/http11/filters/FlushableGZIPOutputStream.java
@@ -0,0 +1,108 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package org.apache.coyote.http11.filters;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.zip.Deflater;
+import java.util.zip.GZIPOutputStream;
+
+/**
+ * Extension of {@link GZIPOutputStream} to workaround for a couple of long
+ * standing JDK bugs
+ * (<a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4255743">Bug
+ * 4255743</a> and
+ * <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4813885">Bug
+ * 4813885</a>) so the GZIP'd output can be flushed. 
+ */
+public class FlushableGZIPOutputStream extends GZIPOutputStream {
+    public FlushableGZIPOutputStream(OutputStream os) throws IOException {
+        super(os);
+    }
+
+    private static final byte[] EMPTYBYTEARRAY = new byte[0];
+    private boolean hasData = false;
+
+    /**
+     * Here we make sure we have received data, so that the header has been for
+     * sure written to the output stream already.
+     */
+    @Override
+    public synchronized void write(byte[] bytes, int i, int i1)
+            throws IOException {
+        super.write(bytes, i, i1);
+        hasData = true;
+    }
+
+    @Override
+    public synchronized void write(int i) throws IOException {
+        super.write(i);
+        hasData = true;
+    }
+
+    @Override
+    public synchronized void write(byte[] bytes) throws IOException {
+        super.write(bytes);
+        hasData = true;
+    }
+
+    @Override
+    public synchronized void flush() throws IOException {
+        if (!hasData) {
+            return; // do not allow the gzip header to be flushed on its own
+        }
+
+        // trick the deflater to flush
+        /**
+         * Now this is tricky: We force the Deflater to flush its data by
+         * switching compression level. As yet, a perplexingly simple workaround
+         * for
+         * http://developer.java.sun.com/developer/bugParade/bugs/4255743.html
+         */
+        if (!def.finished()) {
+            def.setInput(EMPTYBYTEARRAY, 0, 0);
+
+            def.setLevel(Deflater.NO_COMPRESSION);
+            deflate();
+
+            def.setLevel(Deflater.DEFAULT_COMPRESSION);
+            deflate();
+
+            out.flush();
+        }
+
+        hasData = false; // no more data to flush
+    }
+
+    /*
+     * Keep on calling deflate until it runs dry. The default implementation
+     * only does it once and can therefore hold onto data when they need to be
+     * flushed out.
+     */
+    @Override
+    protected void deflate() throws IOException {
+        int len;
+        do {
+            len = def.deflate(buf, 0, buf.length);
+            if (len > 0) {
+                out.write(buf, 0, len);
+            }
+        } while (len != 0);
+    }
+
+}

==================================================
TestGzipOutputFilter.java
index c353db76db..d69133691d 100644
--- a/java/org/apache/coyote/http11/filters/GzipOutputFilter.java
+++ b/java/org/apache/coyote/http11/filters/GzipOutputFilter.java
@@ -41,6 +41,13 @@ public class GzipOutputFilter implements OutputFilter {
     protected static final ByteChunk ENCODING = new ByteChunk();
 
 
+    /**
+     * Logger.
+     */
+    protected static org.apache.juli.logging.Log log =
+        org.apache.juli.logging.LogFactory.getLog(GzipOutputFilter.class);
+
+
     // ----------------------------------------------------- Static Initializer
 
 
@@ -81,7 +88,7 @@ public class GzipOutputFilter implements OutputFilter {
     public int doWrite(ByteChunk chunk, Response res)
         throws IOException {
         if (compressionStream == null) {
-            compressionStream = new GZIPOutputStream(fakeOutputStream);
+            compressionStream = new FlushableGZIPOutputStream(fakeOutputStream);
         }
         compressionStream.write(chunk.getBytes(), chunk.getStart(), 
                                 chunk.getLength());
@@ -91,6 +98,23 @@ public class GzipOutputFilter implements OutputFilter {
 
     // --------------------------------------------------- OutputFilter Methods
 
+    /**
+     * Added to allow flushing to happen for the gzip'ed outputstream
+     */
+    public void flush() {
+        if (compressionStream != null) {
+            try {
+                if (log.isDebugEnabled()) {
+                    log.debug("Flushing the compression stream!");
+                }
+                compressionStream.flush();
+            } catch (IOException e) {
+                if (log.isDebugEnabled()) {
+                    log.debug("Ignored exception while flushing gzip filter", e);
+                }
+            }
+        }
+    }
 
     /**
      * Some filters need additional parameters from the response. All the 
@@ -117,7 +141,7 @@ public class GzipOutputFilter implements OutputFilter {
     public long end()
         throws IOException {
         if (compressionStream == null) {
-            compressionStream = new GZIPOutputStream(fakeOutputStream);
+            compressionStream = new FlushableGZIPOutputStream(fakeOutputStream);
         }
         compressionStream.finish();
         compressionStream.close();

==================================================
