91ead6dc2756fef95591e04dc252646f0fc01883
==================================================
- The poller now has good performance, so remove firstReadTimeout (the algorithm can still be retrieved from
==================================================
Remy Maucherat
==================================================
Wed Mar 28 14:01:53 2007 +0000
==================================================
AjpAprProcessor.java
- The poller now has good performance, so remove firstReadTimeout (the algorithm can still be retrieved from
  svn if needed).

git-svn-id: https://svn.apache.org/repos/asf/tomcat/tc6.0.x/trunk@523331 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AjpAprProtocol.java
index a9659ee8bb..786b32943c 100644
--- a/java/org/apache/coyote/ajp/AjpAprProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpAprProcessor.java
@@ -90,13 +90,6 @@ public class AjpAprProcessor implements ActionHook {
         responseHeaderMessage = new AjpMessage(packetSize);
         bodyMessage = new AjpMessage(packetSize);
         
-        readTimeout = endpoint.getFirstReadTimeout() * 1000;
-        if (readTimeout == 0) {
-            readTimeout = 100 * 1000;
-        } else if (readTimeout < 0) {
-            readTimeout = -1;
-        }
-
         // Allocate input and output buffers
         inputBuffer = ByteBuffer.allocateDirect(packetSize * 2);
         inputBuffer.limit(0);
@@ -188,13 +181,6 @@ public class AjpAprProcessor implements ActionHook {
     protected AprEndpoint endpoint;
 
 
-    /**
-     * The socket timeout used when reading the first block of the request
-     * header.
-     */
-    protected long readTimeout;
-
-
     /**
      * Temp message bytes used for processing.
      */
@@ -371,11 +357,6 @@ public class AjpAprProcessor implements ActionHook {
         // Error flag
         error = false;
 
-        int limit = 0;
-        if (endpoint.getFirstReadTimeout() > 0) {
-            limit = endpoint.getMaxThreads() / 2;
-        }
-
         boolean openSocket = true;
         boolean keptAlive = false;
 
@@ -384,8 +365,7 @@ public class AjpAprProcessor implements ActionHook {
             // Parsing the request header
             try {
                 // Get first message of the request
-                if (!readMessage(requestHeaderMessage, true,
-                        keptAlive && (endpoint.getCurrentThreadsBusy() >= limit))) {
+                if (!readMessage(requestHeaderMessage, true, keptAlive)) {
                     // This means that no data is available right now
                     // (long keepalive), so that the processor should be recycled
                     // and the method should return true
@@ -1061,15 +1041,9 @@ public class AjpAprProcessor implements ActionHook {
         }
         int nRead;
         while (inputBuffer.remaining() < n) {
-            if (readTimeout > 0) {
-                nRead = Socket.recvbbt
-                    (socket, inputBuffer.limit(),
-                        inputBuffer.capacity() - inputBuffer.limit(), readTimeout);
-            } else {
-                nRead = Socket.recvbb
-                    (socket, inputBuffer.limit(),
-                        inputBuffer.capacity() - inputBuffer.limit());
-            }
+            nRead = Socket.recvbb
+                (socket, inputBuffer.limit(),
+                    inputBuffer.capacity() - inputBuffer.limit());
             if (nRead > 0) {
                 inputBuffer.limit(inputBuffer.limit() + nRead);
             } else {

==================================================
Http11AprProcessor.java
index df040652e1..ae8e2b5e58 100644
--- a/java/org/apache/coyote/ajp/AjpAprProtocol.java
+++ b/java/org/apache/coyote/ajp/AjpAprProtocol.java
@@ -364,17 +364,6 @@ public class AjpAprProtocol
     }
 
 
-    public int getFirstReadTimeout() {
-        return ep.getFirstReadTimeout();
-    }
-
-
-    public void setFirstReadTimeout(int i) {
-        ep.setFirstReadTimeout(i);
-        setAttribute("firstReadTimeout", "" + i);
-    }
-
-
     public int getPollTime() {
         return ep.getPollTime();
     }

==================================================
Http11AprProtocol.java
index 124a72c26f..265068ea4b 100644
--- a/java/org/apache/coyote/http11/Http11AprProcessor.java
+++ b/java/org/apache/coyote/http11/Http11AprProcessor.java
@@ -87,14 +87,7 @@ public class Http11AprProcessor implements ActionHook {
         this.endpoint = endpoint;
         
         request = new Request();
-        int readTimeout = endpoint.getFirstReadTimeout();
-        if (readTimeout == 0) {
-            readTimeout = 100;
-        } else if (readTimeout < 0) {
-            readTimeout = -1;
-        }
-        inputBuffer = new InternalAprInputBuffer(request, headerBufferSize,
-                readTimeout);
+        inputBuffer = new InternalAprInputBuffer(request, headerBufferSize);
         request.setInputBuffer(inputBuffer);
 
         response = new Response();
@@ -800,11 +793,6 @@ public class Http11AprProcessor implements ActionHook {
         int keepAliveLeft = maxKeepAliveRequests;
         long soTimeout = endpoint.getSoTimeout();
         
-        int limit = 0;
-        if (endpoint.getFirstReadTimeout() > 0 || endpoint.getFirstReadTimeout() < -1) {
-            limit = endpoint.getMaxThreads() / 2;
-        }
-
         boolean keptAlive = false;
         boolean openSocket = false;
 
@@ -815,8 +803,7 @@ public class Http11AprProcessor implements ActionHook {
                 if( !disableUploadTimeout && keptAlive && soTimeout > 0 ) {
                     Socket.timeoutSet(socket, soTimeout * 1000);
                 }
-                if (!inputBuffer.parseRequestLine
-                        (keptAlive && (endpoint.getCurrentThreadsBusy() >= limit))) {
+                if (!inputBuffer.parseRequestLine(keptAlive)) {
                     // This means that no data is available right now
                     // (long keepalive), so that the processor should be recycled
                     // and the method should return true

==================================================
InternalAprInputBuffer.java
index 1f12d153d6..ecec00da38 100644
--- a/java/org/apache/coyote/http11/Http11AprProtocol.java
+++ b/java/org/apache/coyote/http11/Http11AprProtocol.java
@@ -264,15 +264,6 @@ public class Http11AprProtocol implements ProtocolHandler, MBeanRegistration
         setAttribute("port", "" + port);
     }
 
-    public int getFirstReadTimeout() {
-        return ep.getFirstReadTimeout();
-    }
-
-    public void setFirstReadTimeout( int i ) {
-        ep.setFirstReadTimeout(i);
-        setAttribute("firstReadTimeout", "" + i);
-    }
-
     public int getPollTime() {
         return ep.getPollTime();
     }

==================================================
AprEndpoint.java
index bb62a2b6f1..7366eea3b1 100644
--- a/java/org/apache/coyote/http11/InternalAprInputBuffer.java
+++ b/java/org/apache/coyote/http11/InternalAprInputBuffer.java
@@ -51,8 +51,7 @@ public class InternalAprInputBuffer implements InputBuffer {
     /**
      * Alternate constructor.
      */
-    public InternalAprInputBuffer(Request request, int headerBufferSize, 
-                                  long readTimeout) {
+    public InternalAprInputBuffer(Request request, int headerBufferSize) {
 
         this.request = request;
         headers = request.getMimeHeaders();
@@ -73,12 +72,6 @@ public class InternalAprInputBuffer implements InputBuffer {
         parsingHeader = true;
         swallowInput = true;
         
-        if (readTimeout < 0) {
-            this.readTimeout = -1;
-        } else {
-            this.readTimeout = readTimeout * 1000;
-        }
-
     }
 
 
@@ -181,13 +174,6 @@ public class InternalAprInputBuffer implements InputBuffer {
     protected int lastActiveFilter;
 
 
-    /**
-     * The socket timeout used when reading the first block of the request
-     * header.
-     */
-    protected long readTimeout;
-    
-    
     // ------------------------------------------------------------- Properties
 
 
@@ -381,26 +367,8 @@ public class InternalAprInputBuffer implements InputBuffer {
                 if (useAvailableData) {
                     return false;
                 }
-                if (readTimeout == -1) {
-                    if (!fill())
-                        throw new EOFException(sm.getString("iib.eof.error"));
-                } else {
-                    // Do a simple read with a short timeout
-                    bbuf.clear();
-                    int nRead = Socket.recvbbt
-                    (socket, 0, buf.length - lastValid, readTimeout);
-                    if (nRead > 0) {
-                        bbuf.limit(nRead);
-                        bbuf.get(buf, pos, nRead);
-                        lastValid = pos + nRead;
-                    } else {
-                        if ((-nRead) == Status.ETIMEDOUT || (-nRead) == Status.TIMEUP) {
-                            return false;
-                        } else {
-                            throw new IOException(sm.getString("iib.failedread"));
-                        }
-                    }
-                }
+                if (!fill())
+                    throw new EOFException(sm.getString("iib.eof.error"));
             }
 
             chr = buf[pos++];
@@ -416,26 +384,8 @@ public class InternalAprInputBuffer implements InputBuffer {
             if (useAvailableData) {
                 return false;
             }
-            if (readTimeout == -1) {
-                if (!fill())
-                    throw new EOFException(sm.getString("iib.eof.error"));
-            } else {
-                // Do a simple read with a short timeout
-                bbuf.clear();
-                int nRead = Socket.recvbbt
-                    (socket, 0, buf.length - lastValid, readTimeout);
-                if (nRead > 0) {
-                    bbuf.limit(nRead);
-                    bbuf.get(buf, pos, nRead);
-                    lastValid = pos + nRead;
-                } else {
-                    if ((-nRead) == Status.ETIMEDOUT || (-nRead) == Status.TIMEUP) {
-                        return false;
-                    } else {
-                        throw new IOException(sm.getString("iib.failedread"));
-                    }
-                }
-            }
+            if (!fill())
+                throw new EOFException(sm.getString("iib.eof.error"));
         }
 
         //

==================================================
