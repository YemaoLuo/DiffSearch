0d2cfa5acdd5716904fdb0d2e046616701447dd1
==================================================
Fix https://bz.apache.org/bugzilla/show_bug.cgi?id=59825
==================================================
Mark Thomas
==================================================
Fri Apr 7 18:42:21 2017 +0000
==================================================
Pipeline.java
Fix https://bz.apache.org/bugzilla/show_bug.cgi?id=59825
Log a message that lists the components in the processing chain that do not support async processing when a call to ServletRequest.startAsync() fails.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1790614 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Request.java
index f27047f197..02923913b6 100644
--- a/java/org/apache/catalina/connector/LocalStrings.properties
+++ b/java/org/apache/catalina/connector/LocalStrings.properties
@@ -52,7 +52,9 @@ coyoteRequest.authenticate.ise=Cannot call authenticate() after the response has
 coyoteRequest.uploadLocationInvalid=The temporary upload location [{0}] is not valid
 coyoteRequest.sessionEndAccessFail=Exception triggered ending access to session while recycling request
 coyoteRequest.sendfileNotCanonical=Unable to determine canonical name of file [{0}] specified for use with sendfile
+coyoteRequest.filterAsyncSupportUnknown=Unable to determine if any filters do not support async processing
 coyoteRequest.maxPostSizeExceeded=The multi-part request contained parameter data (excluding uploaded files) that exceeded the limit for maxPostSize set on the associated connector
+coyoteRequest.noAsync=Unable to start async because the following classes in the processing chain do not support async [{0}]
 coyoteRequest.noMultipartConfig=Unable to process parts as no multi-part configuration has been provided
 
 coyoteResponse.getOutputStream.ise=getWriter() has already been called for this response

==================================================
ApplicationFilterChain.java
index 4fa2dec116..16f2810878 100644
--- a/java/org/apache/catalina/connector/Request.java
+++ b/java/org/apache/catalina/connector/Request.java
@@ -76,6 +76,7 @@ import org.apache.catalina.Realm;
 import org.apache.catalina.Session;
 import org.apache.catalina.TomcatPrincipal;
 import org.apache.catalina.Wrapper;
+import org.apache.catalina.core.ApplicationFilterChain;
 import org.apache.catalina.core.ApplicationMapping;
 import org.apache.catalina.core.ApplicationPart;
 import org.apache.catalina.core.ApplicationPushBuilder;
@@ -95,6 +96,7 @@ import org.apache.tomcat.util.ExceptionUtils;
 import org.apache.tomcat.util.buf.B2CConverter;
 import org.apache.tomcat.util.buf.ByteChunk;
 import org.apache.tomcat.util.buf.MessageBytes;
+import org.apache.tomcat.util.buf.StringUtils;
 import org.apache.tomcat.util.buf.UDecoder;
 import org.apache.tomcat.util.http.CookieProcessor;
 import org.apache.tomcat.util.http.FastHttpDateFormat;
@@ -1617,7 +1619,11 @@ public class Request implements HttpServletRequest {
     public AsyncContext startAsync(ServletRequest request,
             ServletResponse response) {
         if (!isAsyncSupported()) {
-            throw new IllegalStateException(sm.getString("request.asyncNotSupported"));
+            IllegalStateException ise =
+                    new IllegalStateException(sm.getString("request.asyncNotSupported"));
+            log.warn(sm.getString("coyoteRequest.noAsync",
+                    StringUtils.join(getNonAsyncClassNames())), ise);
+            throw ise;
         }
 
         if (asyncContext == null) {
@@ -1631,6 +1637,31 @@ public class Request implements HttpServletRequest {
         return asyncContext;
     }
 
+
+    private Set<String> getNonAsyncClassNames() {
+        Set<String> result = new HashSet<>();
+
+        Wrapper wrapper = getWrapper();
+        if (!wrapper.isAsyncSupported()) {
+            result.add(wrapper.getServletClass());
+        }
+
+        FilterChain filterChain = getFilterChain();
+        if (filterChain instanceof ApplicationFilterChain) {
+            ((ApplicationFilterChain) filterChain).findNonAsyncFilters(result);
+        } else {
+            result.add(sm.getString("coyoteRequest.filterAsyncSupportUnknown"));
+        }
+
+        Container c = wrapper;
+        while (c != null) {
+            c.getPipeline().findNonAsyncValves(result);
+            c = c.getParent();
+        }
+
+        return result;
+    }
+
     @Override
     public boolean isAsyncStarted() {
         if (asyncContext == null) {

==================================================
StandardPipeline.java
index 18e30bb187..f212c46207 100644
--- a/java/org/apache/catalina/core/ApplicationFilterChain.java
+++ b/java/org/apache/catalina/core/ApplicationFilterChain.java
@@ -19,6 +19,7 @@ package org.apache.catalina.core;
 import java.io.IOException;
 import java.security.Principal;
 import java.security.PrivilegedActionException;
+import java.util.Set;
 
 import javax.servlet.Filter;
 import javax.servlet.FilterChain;
@@ -43,7 +44,7 @@ import org.apache.tomcat.util.res.StringManager;
  *
  * @author Craig R. McClanahan
  */
-final class ApplicationFilterChain implements FilterChain {
+public final class ApplicationFilterChain implements FilterChain {
 
     // Used to enforce requirements of SRV.8.2 / SRV.14.2.5.1
     private static final ThreadLocal<ServletRequest> lastServicedRequest;
@@ -326,4 +327,22 @@ final class ApplicationFilterChain implements FilterChain {
     void setServletSupportsAsync(boolean servletSupportsAsync) {
         this.servletSupportsAsync = servletSupportsAsync;
     }
+
+
+    /**
+     * Identifies the Filters, if any, in this FilterChain that do not support
+     * async.
+     *
+     * @param result The Set to which the fully qualified class names of each
+     *               Filter in this FilterChain that does not support async will
+     *               be added
+     */
+    public void findNonAsyncFilters(Set<String> result) {
+        for (int i = 0; i < n ; i++) {
+            ApplicationFilterConfig filter = filters[i];
+            if ("false".equalsIgnoreCase(filter.getFilterDef().getAsyncSupported())) {
+                result.add(filter.getFilterClass());
+            }
+        }
+    }
 }

==================================================
