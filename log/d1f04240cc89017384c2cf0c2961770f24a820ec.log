d1f04240cc89017384c2cf0c2961770f24a820ec
==================================================
Now make the classes checking session idleness
==================================================
Rainer Jung
==================================================
Wed Nov 5 22:15:53 2008 +0000
==================================================
SingleSignOn.java
Now make the classes checking session idleness
use thisAccessedTime.
This is not for invalidation, only for displaying
idle times and making persistance decisions.


git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@711720 13f79535-47bb-0310-9956-ffa450edef68



==================================================
ManagerServlet.java
index f01a4206d6..f646c7ad5f 100644
--- a/java/org/apache/catalina/authenticator/SingleSignOn.java
+++ b/java/org/apache/catalina/authenticator/SingleSignOn.java
@@ -323,7 +323,7 @@ public class SingleSignOn
         // SSO.  If the session was logged out, we'll log out
         // of all session associated with the SSO.
         if (((session.getMaxInactiveInterval() > 0)
-            && (System.currentTimeMillis() - session.getLastAccessedTimeInternal() >=
+            && (System.currentTimeMillis() - session.getThisAccessedTimeInternal() >=
                 session.getMaxInactiveInterval() * 1000)) 
             || (Session.SESSION_PASSIVATED_EVENT.equals(event.getType()))) {
             removeSession(ssoId, session);

==================================================
SessionUtils.java
index 2a5f1293f6..ab6935f3df 100644
--- a/java/org/apache/catalina/manager/ManagerServlet.java
+++ b/java/org/apache/catalina/manager/ManagerServlet.java
@@ -1064,7 +1064,7 @@ public class ManagerServlet
 
     /**
      * Session information for the web application at the specified context path.
-     * Displays a profile of session lastAccessedTime listing number
+     * Displays a profile of session thisAccessedTime listing number
      * of sessions for each 10 minute interval up to 10 hours.
      *
      * @param writer Writer to render to
@@ -1118,7 +1118,7 @@ public class ManagerServlet
             int expired = 0;
             long now = System.currentTimeMillis();
             for (int i = 0; i < sessions.length; i++) {
-                int time = (int)((now-sessions[i].getLastAccessedTimeInternal())/1000);
+                int time = (int)((now-sessions[i].getThisAccessedTimeInternal())/1000);
                 if (idle >= 0 && time >= idle*60) {
                     sessions[i].expire();
                     idle++;
@@ -1161,7 +1161,7 @@ public class ManagerServlet
 
     /**
      * Session information for the web application at the specified context path.
-     * Displays a profile of session lastAccessedTime listing number
+     * Displays a profile of session thisAccessedTime listing number
      * of sessions for each 10 minute interval up to 10 hours.
      *
      * @param writer Writer to render to

==================================================
PersistentManagerBase.java
index 17722d2a59..54a3c4993d 100644
--- a/java/org/apache/catalina/manager/util/SessionUtils.java
+++ b/java/org/apache/catalina/manager/util/SessionUtils.java
@@ -237,7 +237,7 @@ public class SessionUtils {
 
     public static long getUsedTimeForSession(Session in_session) {
         try {
-            long diffMilliSeconds = in_session.getLastAccessedTime() - in_session.getCreationTime();
+            long diffMilliSeconds = in_session.getThisAccessedTime() - in_session.getCreationTime();
             return diffMilliSeconds;
         } catch (IllegalStateException ise) {
             //ignore: invalidated session
@@ -247,7 +247,7 @@ public class SessionUtils {
 
     public static long getTTLForSession(Session in_session) {
         try {
-            long diffMilliSeconds = (1000*in_session.getMaxInactiveInterval()) - (System.currentTimeMillis() - in_session.getLastAccessedTime());
+            long diffMilliSeconds = (1000*in_session.getMaxInactiveInterval()) - (System.currentTimeMillis() - in_session.getThisAccessedTime());
             return diffMilliSeconds;
         } catch (IllegalStateException ise) {
             //ignore: invalidated session
@@ -257,7 +257,7 @@ public class SessionUtils {
 
     public static long getInactiveTimeForSession(Session in_session) {
         try {
-            long diffMilliSeconds =  System.currentTimeMillis() - in_session.getLastAccessedTime();
+            long diffMilliSeconds =  System.currentTimeMillis() - in_session.getThisAccessedTime();
             return diffMilliSeconds;
         } catch (IllegalStateException ise) {
             //ignore: invalidated session

==================================================
PersistentValve.java
index ce8fc1164e..e0d7c0d1f0 100644
--- a/java/org/apache/catalina/session/PersistentManagerBase.java
+++ b/java/org/apache/catalina/session/PersistentManagerBase.java
@@ -1048,7 +1048,7 @@ public abstract class PersistentManagerBase
                     if (!session.isValid())
                         continue;
                     int timeIdle = // Truncate, do not round up
-                        (int) ((timeNow - session.getLastAccessedTime()) / 1000L);
+                        (int) ((timeNow - session.getThisAccessedTime()) / 1000L);
                     if (timeIdle > maxIdleSwap && timeIdle > minIdleSwap) {
                         if (log.isDebugEnabled())
                             log.debug(sm.getString
@@ -1092,7 +1092,7 @@ public abstract class PersistentManagerBase
         for (int i = 0; i < sessions.length && toswap > 0; i++) {
             synchronized (sessions[i]) {
                 int timeIdle = // Truncate, do not round up
-                    (int) ((timeNow - sessions[i].getLastAccessedTime()) / 1000L);
+                    (int) ((timeNow - sessions[i].getThisAccessedTime()) / 1000L);
                 if (timeIdle > minIdleSwap) {
                     if(log.isDebugEnabled())
                         log.debug(sm.getString
@@ -1130,7 +1130,7 @@ public abstract class PersistentManagerBase
                     if (!session.isValid())
                         continue;
                     int timeIdle = // Truncate, do not round up
-                        (int) ((timeNow - session.getLastAccessedTime()) / 1000L);
+                        (int) ((timeNow - session.getThisAccessedTime()) / 1000L);
                     if (timeIdle > maxIdleBackup) {
                         if (log.isDebugEnabled())
                             log.debug(sm.getString

==================================================
