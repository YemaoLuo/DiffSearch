fb096de761254980f779ff99057cd3b055e6459d
==================================================
Remove unused code - thanks to UCDetector
==================================================
Mark Thomas
==================================================
Fri Jun 17 12:29:10 2022 +0100
==================================================
Base64.java
Remove unused code - thanks to UCDetector


==================================================
BaseNCodec.java
index 3cd4f1a558..5666e9ba3e 100644
--- a/java/org/apache/tomcat/util/codec/binary/Base64.java
+++ b/java/org/apache/tomcat/util/codec/binary/Base64.java
@@ -16,9 +16,6 @@
  */
 package org.apache.tomcat.util.codec.binary;
 
-import java.math.BigInteger;
-import java.util.Objects;
-
 /**
  * Provides Base64 encoding and decoding as defined by <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>.
  *
@@ -138,20 +135,6 @@ public class Base64 extends BaseNCodec {
     // The private member fields below are used with the new streaming approach, which requires
     // some state be preserved between calls of encode() and decode().
 
-    /**
-     * Decodes Base64 data into octets.
-     * <p>
-     * <b>Note:</b> this method seamlessly handles data encoded in URL-safe or normal mode.
-     * </p>
-     *
-     * @param base64Data
-     *            Byte array containing Base64 data
-     * @return Array containing decoded data.
-     */
-    public static byte[] decodeBase64(final byte[] base64Data) {
-        return decodeBase64(base64Data, 0, base64Data.length);
-    }
-
     public  static byte[] decodeBase64(
             final byte[] base64Data, final int off, final int len) {
         return new Base64().decode(base64Data, off, len);
@@ -177,29 +160,6 @@ public class Base64 extends BaseNCodec {
     }
 
     // Implementation of integer encoding used for crypto
-    /**
-     * Decodes a byte64-encoded integer according to crypto standards such as W3C's XML-Signature.
-     *
-     * @param pArray
-     *            a byte array containing base64 character data
-     * @return A BigInteger
-     * @since 1.4
-     */
-    public static BigInteger decodeInteger(final byte[] pArray) {
-        return new BigInteger(1, decodeBase64(pArray));
-    }
-
-    /**
-     * Encodes binary data using the base64 algorithm but does not chunk the output.
-     *
-     * @param binaryData
-     *            binary data to encode
-     * @return byte[] containing Base64 characters in their UTF-8 representation.
-     */
-    public static byte[] encodeBase64(final byte[] binaryData) {
-        return encodeBase64(binaryData, false);
-    }
-
     /**
      * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
      *
@@ -269,17 +229,6 @@ public class Base64 extends BaseNCodec {
         return b64.encode(binaryData);
     }
 
-    /**
-     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks
-     *
-     * @param binaryData
-     *            binary data to encode
-     * @return Base64 characters chunked in 76 character blocks
-     */
-    public static byte[] encodeBase64Chunked(final byte[] binaryData) {
-        return encodeBase64(binaryData, true);
-    }
-
     /**
      * Encodes binary data using the base64 algorithm but does not chunk the output.
      *
@@ -295,19 +244,6 @@ public class Base64 extends BaseNCodec {
         return StringUtils.newStringUsAscii(encodeBase64(binaryData, false));
     }
 
-    /**
-     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The
-     * url-safe variation emits - and _ instead of + and / characters.
-     * <b>Note: no padding is added.</b>
-     * @param binaryData
-     *            binary data to encode
-     * @return byte[] containing Base64 characters in their UTF-8 representation.
-     * @since 1.4
-     */
-    public static byte[] encodeBase64URLSafe(final byte[] binaryData) {
-        return encodeBase64(binaryData, false, true);
-    }
-
     /**
      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The
      * url-safe variation emits - and _ instead of + and / characters.
@@ -321,97 +257,6 @@ public class Base64 extends BaseNCodec {
         return StringUtils.newStringUsAscii(encodeBase64(binaryData, false, true));
     }
 
-    /**
-     * Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature.
-     *
-     * @param bigInteger
-     *            a BigInteger
-     * @return A byte array containing base64 character data
-     * @throws NullPointerException
-     *             if null is passed in
-     * @since 1.4
-     */
-    public static byte[] encodeInteger(final BigInteger bigInteger) {
-        Objects.requireNonNull(bigInteger,sm.getString("base64.nullEncodeParameter"));
-        return encodeBase64(toIntegerBytes(bigInteger), false);
-    }
-
-    /**
-     * Returns whether or not the {@code octet} is in the base 64 alphabet.
-     *
-     * @param octet
-     *            The value to test
-     * @return {@code true} if the value is defined in the the base 64 alphabet, {@code false} otherwise.
-     * @since 1.4
-     */
-    public static boolean isBase64(final byte octet) {
-        return octet == PAD_DEFAULT || (octet >= 0 && octet < STANDARD_DECODE_TABLE.length && STANDARD_DECODE_TABLE[octet] != -1);
-    }
-
-    /**
-     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the
-     * method treats whitespace as valid.
-     *
-     * @param arrayOctet
-     *            byte array to test
-     * @return {@code true} if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;
-     *         {@code false}, otherwise
-     * @since 1.5
-     */
-    public static boolean isBase64(final byte[] arrayOctet) {
-        for (final byte element : arrayOctet) {
-            if (!isBase64(element) && !isWhiteSpace(element)) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /**
-     * Tests a given String to see if it contains only valid characters within the Base64 alphabet. Currently the
-     * method treats whitespace as valid.
-     *
-     * @param base64
-     *            String to test
-     * @return {@code true} if all characters in the String are valid characters in the Base64 alphabet or if
-     *         the String is empty; {@code false}, otherwise
-     *  @since 1.5
-     */
-    public static boolean isBase64(final String base64) {
-        return isBase64(StringUtils.getBytesUtf8(base64));
-    }
-
-    /**
-     * Returns a byte-array representation of a {@code BigInteger} without sign bit.
-     *
-     * @param bigInt
-     *            {@code BigInteger} to be converted
-     * @return a byte array representation of the BigInteger parameter
-     */
-    static byte[] toIntegerBytes(final BigInteger bigInt) {
-        int bitlen = bigInt.bitLength();
-        // round bitlen
-        bitlen = ((bitlen + 7) >> 3) << 3;
-        final byte[] bigBytes = bigInt.toByteArray();
-
-        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
-            return bigBytes;
-        }
-        // set up params for copying everything but sign bit
-        int startSrc = 0;
-        int len = bigBytes.length;
-
-        // if bigInt is exactly byte-aligned, just skip signbit in copy
-        if ((bigInt.bitLength() % 8) == 0) {
-            startSrc = 1;
-            len--;
-        }
-        final int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
-        final byte[] resizedBytes = new byte[bitlen / 8];
-        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
-        return resizedBytes;
-    }
-
     /**
      * Validates whether decoding the final trailing character is possible in the context
      * of the set of possible base 64 values.

==================================================
