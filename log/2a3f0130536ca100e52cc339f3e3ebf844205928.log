2a3f0130536ca100e52cc339f3e3ebf844205928
==================================================
Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=57252
==================================================
Mark Thomas
==================================================
Fri Dec 5 09:36:12 2014 +0000
==================================================
StandardHostValve.java
Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=57252
Provide application configured error pages with a chance to handle an
async error before the built-in error reporting.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1643210 13f79535-47bb-0310-9956-ffa450edef68



==================================================
ErrorReportValve.java
index 1dbded4c20..69e8150503 100644
--- a/java/org/apache/catalina/core/StandardHostValve.java
+++ b/java/org/apache/catalina/core/StandardHostValve.java
@@ -120,9 +120,6 @@ final class StandardHostValve extends ValveBase {
 
         boolean asyncAtStart = request.isAsync();
         boolean asyncDispatching = request.isAsyncDispatching();
-        // An async error page may dispatch to another resource. This flag helps
-        // ensure an infinite error handling loop is not entered
-        boolean errorAtStart = response.isError();
 
         try {
             context.bind(Globals.IS_SECURITY_ENABLED, MY_CLASSLOADER);
@@ -135,18 +132,26 @@ final class StandardHostValve extends ValveBase {
                 return;
             }
 
-            // Ask this Context to process this request
+            // Ask this Context to process this request. Requests that are in
+            // async mode and are not being dispatched to this resource must be
+            // in error and have been routed here to check for application
+            // defined error pages.
             try {
                 if (!asyncAtStart || asyncDispatching) {
                     context.getPipeline().getFirst().invoke(request, response);
                 } else {
-                    if (!errorAtStart) {
+                    // Make sure this request/response is here because an error
+                    // report is required.
+                    if (!response.isErrorReportRequired()) {
                         throw new IllegalStateException(sm.getString("standardHost.asyncStateError"));
                     }
                 }
             } catch (Throwable t) {
                 ExceptionUtils.handleThrowable(t);
-                if (errorAtStart) {
+                // If a new error occurred while trying to report a previous
+                // error simply log the new error and allow the original error
+                // to be reported.
+                if (response.isErrorReportRequired()) {
                     container.getLogger().error("Exception Processing " +
                             request.getRequestURI(), t);
                 } else {
@@ -157,28 +162,27 @@ final class StandardHostValve extends ValveBase {
 
             Throwable t = (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);
 
-            // If the request was async at the start and an error occurred
-            // then the async error handling will kick-in and that will fire
-            // the request destroyed event *after* the error handling has
-            // taken place.
-            if (!(request.isAsync() || (asyncAtStart && t != null))) {
-                // Protect against NPEs if context was destroyed during a
-                // long running request.
-                if (context.getState().isAvailable()) {
-                    if (!errorAtStart) {
-                        // Error page processing
-                        response.setSuspended(false);
-
-                        if (t != null) {
-                            throwable(request, response, t);
-                        } else {
-                            status(request, response);
-                        }
-                    }
+            // Protect against NPEs if the context was destroyed during a
+            // long running request.
+            if (!context.getState().isAvailable()) {
+                return;
+            }
+
+            // Look for (and render if found) an application level error page
+            if (response.isErrorReportRequired()) {
+                // Error page processing
+                response.setSuspended(false);
 
-                    context.fireRequestDestroyEvent(request);
+                if (t != null) {
+                    throwable(request, response, t);
+                } else {
+                    status(request, response);
                 }
             }
+
+            if (!request.isAsync() && !response.isErrorReportRequired()) {
+                context.fireRequestDestroyEvent(request);
+            }
         } finally {
             // Access a session (if present) to update last accessed time, based
             // on a strict interpretation of the specification

==================================================
