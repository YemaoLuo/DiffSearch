8d4aecf76b566407c125061e81456f69d60f379c
==================================================
Drop the non-JSR356 WebSocket implementation
==================================================
Mark Emlyn
==================================================
Wed Mar 20 09:56:29 2013 +0000
==================================================
Constants.java
Drop the non-JSR356 WebSocket implementation

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1458709 13f79535-47bb-0310-9956-ffa450edef68



==================================================
MessageHandler.java
deleted file mode 100644
index 9a02f871f0..0000000000
--- a/java/org/apache/catalina/websocket/LocalStrings.properties
+++ /dev/null
@@ -1,29 +0,0 @@
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the "License"); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-frame.eos=The end of the stream was reached before the expected number of payload bytes could be read
-frame.invalidUtf8=A sequence of bytes was received that did not represent valid UTF-8
-frame.readFailed=Failed to read the first byte of the next WebSocket frame. The return value from the read was [{0}]
-frame.readEos=The end of the stream was reached when trying to read the first byte of a new WebSocket frame
-frame.notMasked=The client frame was not masked but all client frames must be masked
-
-is.notContinuation=A frame with the OpCode [{0}] was received when a continuation frame was expected
-is.unknownOpCode=A frame with the unrecognized OpCode [{0}] was received
-
-message.bufferTooSmall=The buffer is not big enough to contain the message currently being processed
-
-outbound.closed=The WebSocket connection has been closed
-
-wrapper.invalid=An attempt was made to access the request object passed to WebSocketServlet.createWebSocketInbound() outside of that method
\ No newline at end of file

==================================================
StreamHandler.java
deleted file mode 100644
index e17517f827..0000000000
--- a/java/org/apache/catalina/websocket/MessageHandler.java
+++ /dev/null
@@ -1,182 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.websocket;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.Reader;
-import java.nio.ByteBuffer;
-import java.nio.CharBuffer;
-
-import org.apache.tomcat.util.res.StringManager;
-
-/**
- * Base implementation of the class used to process WebSocket connections based
- * on messages. Applications should extend this class to provide application
- * specific functionality. Applications that wish to operate on a stream basis
- * rather than a message basis should use {@link StreamHandler}.
- */
-public abstract class MessageHandler extends StreamHandler {
-
-    private static final StringManager sm =
-            StringManager.getManager(Constants.Package);
-
-
-    // 2MB - like maxPostSize
-    private int byteBufferMaxSize = 2097152;
-    private int charBufferMaxSize = 2097152;
-
-    private ByteBuffer bb = ByteBuffer.allocate(8192);
-    private CharBuffer cb = CharBuffer.allocate(8192);
-
-
-    @Override
-    protected final void onBinaryData(InputStream is) throws IOException {
-        int read = 0;
-        while (read > -1) {
-            bb.position(bb.position() + read);
-            if (bb.remaining() == 0) {
-                resizeByteBuffer();
-            }
-            read = is.read(bb.array(), bb.position(), bb.remaining());
-        }
-        bb.flip();
-        onBinaryMessage(bb);
-        bb.clear();
-    }
-
-
-    @Override
-    protected final void onTextData(Reader r) throws IOException {
-        int read = 0;
-        while (read > -1) {
-            cb.position(cb.position() + read);
-            if (cb.remaining() == 0) {
-                resizeCharBuffer();
-            }
-            read = r.read(cb.array(), cb.position(), cb.remaining());
-        }
-        cb.flip();
-        onTextMessage(cb);
-        cb.clear();
-    }
-
-
-    private void resizeByteBuffer() throws IOException {
-        int maxSize = getByteBufferMaxSize();
-        if (bb.limit() >= maxSize) {
-            throw new IOException(sm.getString("message.bufferTooSmall"));
-        }
-
-        long newSize = bb.limit() * 2;
-        if (newSize > maxSize) {
-            newSize = maxSize;
-        }
-
-        // Cast is safe. newSize < maxSize and maxSize is an int
-        ByteBuffer newBuffer = ByteBuffer.allocate((int) newSize);
-        bb.rewind();
-        newBuffer.put(bb);
-        bb = newBuffer;
-    }
-
-
-    private void resizeCharBuffer() throws IOException {
-        int maxSize = getCharBufferMaxSize();
-        if (cb.limit() >= maxSize) {
-            throw new IOException(sm.getString("message.bufferTooSmall"));
-        }
-
-        long newSize = cb.limit() * 2;
-        if (newSize > maxSize) {
-            newSize = maxSize;
-        }
-
-        // Cast is safe. newSize < maxSize and maxSize is an int
-        CharBuffer newBuffer = CharBuffer.allocate((int) newSize);
-        cb.rewind();
-        newBuffer.put(cb);
-        cb = newBuffer;
-    }
-
-
-    /**
-     * Obtain the current maximum size (in bytes) of the buffer used for binary
-     * messages.
-     */
-    public final int getByteBufferMaxSize() {
-        return byteBufferMaxSize;
-    }
-
-
-    /**
-     * Set the maximum size (in bytes) of the buffer used for binary messages.
-     */
-    public final void setByteBufferMaxSize(int byteBufferMaxSize) {
-        this.byteBufferMaxSize = byteBufferMaxSize;
-    }
-
-
-    /**
-     * Obtain the current maximum size (in characters) of the buffer used for
-     * binary messages.
-     */
-    public final int getCharBufferMaxSize() {
-        return charBufferMaxSize;
-    }
-
-
-    /**
-     * Set the maximum size (in characters) of the buffer used for textual
-     * messages.
-     */
-    public final void setCharBufferMaxSize(int charBufferMaxSize) {
-        this.charBufferMaxSize = charBufferMaxSize;
-    }
-
-
-    /**
-     * This method is called when there is a binary WebSocket message available
-     * to process. The message is presented via a ByteBuffer and may have been
-     * formed from one or more frames. The number of frames used to transmit the
-     * message is not made visible to the application.
-     *
-     * @param message       The WebSocket message
-     *
-     * @throws IOException  If a problem occurs processing the message. Any
-     *                      exception will trigger the closing of the WebSocket
-     *                      connection.
-     */
-    protected abstract void onBinaryMessage(ByteBuffer message)
-            throws IOException;
-
-
-    /**
-     * This method is called when there is a textual WebSocket message available
-     * to process. The message is presented via a CharBuffer and may have been
-     * formed from one or more frames. The number of frames used to transmit the
-     * message is not made visible to the application.
-     *
-     * @param message       The WebSocket message
-     *
-     * @throws IOException  If a problem occurs processing the message. Any
-     *                      exception will trigger the closing of the WebSocket
-     *                      connection.
-     */
-    protected abstract void onTextMessage(CharBuffer message)
-            throws IOException;
-}

==================================================
WebSocketServlet.java
deleted file mode 100644
index d655b649f3..0000000000
--- a/java/org/apache/catalina/websocket/StreamHandler.java
+++ /dev/null
@@ -1,292 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.websocket;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
-import java.nio.ByteBuffer;
-import java.nio.charset.MalformedInputException;
-import java.nio.charset.UnmappableCharacterException;
-
-import javax.servlet.http.HttpUpgradeHandler;
-import javax.servlet.http.WebConnection;
-
-import org.apache.tomcat.util.buf.Utf8Decoder;
-import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
-
-/**
- * Base implementation of the class used to process WebSocket connections based
- * on streams. Applications should extend this class to provide application
- * specific functionality. Applications that wish to operate on a message basis
- * rather than a stream basis should use {@link MessageHandler}.
- */
-public abstract class StreamHandler implements HttpUpgradeHandler {
-
-    private final ClassLoader applicationClassLoader;
-    private WsOutbound outbound;
-    private InputStream inputStream;
-    private int outboundByteBufferSize = WsOutbound.DEFAULT_BUFFER_SIZE;
-    private int outboundCharBufferSize = WsOutbound.DEFAULT_BUFFER_SIZE;
-
-
-    public StreamHandler() {
-        applicationClassLoader = Thread.currentThread().getContextClassLoader();
-    }
-
-
-    public int getOutboundByteBufferSize() {
-        return outboundByteBufferSize;
-    }
-
-
-    public int getOutboundCharBufferSize() {
-        return outboundCharBufferSize;
-    }
-
-
-    /**
-     * Obtain the outbound side of this WebSocket connection used for writing
-     * data to the client.
-     */
-    public final WsOutbound getWsOutbound() {
-        return outbound;
-    }
-
-
-    public final SocketState onData() {
-        // Must be start the start of a message (which may consist of multiple
-        // frames)
-        WsInputStream wsIs = new WsInputStream(inputStream, getWsOutbound());
-
-        try {
-            WsFrame frame = wsIs.nextFrame(false);
-
-            while (frame != null) {
-                // TODO User defined extensions may define values for rsv
-                if (frame.getRsv() > 0) {
-                    closeOutboundConnection(
-                            Constants.STATUS_PROTOCOL_ERROR, null);
-                    return SocketState.CLOSED;
-                }
-
-                byte opCode = frame.getOpCode();
-
-                if (opCode == Constants.OPCODE_BINARY) {
-                    doOnBinaryData(wsIs);
-                } else if (opCode == Constants.OPCODE_TEXT) {
-                    InputStreamReader r =
-                            new InputStreamReader(wsIs, new Utf8Decoder());
-                    doOnTextData(r);
-                } else if (opCode == Constants.OPCODE_CLOSE){
-                    closeOutboundConnection(frame);
-                    return SocketState.CLOSED;
-                } else if (opCode == Constants.OPCODE_PING) {
-                    getWsOutbound().pong(frame.getPayLoad());
-                } else if (opCode == Constants.OPCODE_PONG) {
-                    doOnPong(frame.getPayLoad());
-                } else {
-                    // Unknown OpCode
-                    closeOutboundConnection(
-                            Constants.STATUS_PROTOCOL_ERROR, null);
-                    return SocketState.CLOSED;
-                }
-                frame = wsIs.nextFrame(false);
-            }
-        } catch (MalformedInputException mie) {
-            // Invalid UTF-8
-            try {
-                closeOutboundConnection(Constants.STATUS_BAD_DATA, null);
-            } catch (IOException e) {
-                // TODO
-            }
-            return SocketState.CLOSED;
-        } catch (UnmappableCharacterException uce) {
-            // Invalid UTF-8
-            try {
-                closeOutboundConnection(Constants.STATUS_BAD_DATA, null);
-            } catch (IOException e) {
-                // TODO
-            }
-            return SocketState.CLOSED;
-        } catch (IOException ioe) {
-            // Given something must have gone to reach this point, this
-            // might not work but try it anyway.
-            try {
-                closeOutboundConnection(Constants.STATUS_PROTOCOL_ERROR, null);
-            } catch (IOException e) {
-                // TODO
-            }
-            return SocketState.CLOSED;
-        }
-        return SocketState.UPGRADED;
-    }
-
-    private void doOnBinaryData(InputStream is) throws IOException {
-        // Need to call onBinaryData using the web application's class loader
-        Thread t = Thread.currentThread();
-        ClassLoader cl = t.getContextClassLoader();
-        t.setContextClassLoader(applicationClassLoader);
-        try {
-            onBinaryData(is);
-        } finally {
-            t.setContextClassLoader(cl);
-        }
-    }
-
-
-    private void doOnTextData(Reader r) throws IOException {
-        // Need to call onTextData using the web application's class loader
-        Thread t = Thread.currentThread();
-        ClassLoader cl = t.getContextClassLoader();
-        t.setContextClassLoader(applicationClassLoader);
-        try {
-            onTextData(r);
-        } finally {
-            t.setContextClassLoader(cl);
-        }
-    }
-
-
-    private void closeOutboundConnection(int status, ByteBuffer data) throws IOException {
-        try {
-            getWsOutbound().close(status, data);
-        } finally {
-            doOnClose(status);
-        }
-    }
-
-    private void closeOutboundConnection(WsFrame frame) throws IOException {
-        try {
-            getWsOutbound().close(frame);
-        } finally {
-            doOnClose(Constants.STATUS_CLOSE_NORMAL);
-        }
-    }
-
-    private void doOnClose(int status) {
-        // Need to call onClose using the web application's class loader
-        Thread t = Thread.currentThread();
-        ClassLoader cl = t.getContextClassLoader();
-        t.setContextClassLoader(applicationClassLoader);
-        try {
-            onClose(status);
-        } finally {
-            t.setContextClassLoader(cl);
-        }
-    }
-
-    private void doOnPong(ByteBuffer payload) {
-        // Need to call onPong using the web application's class loader
-        Thread t = Thread.currentThread();
-        ClassLoader cl = t.getContextClassLoader();
-        t.setContextClassLoader(applicationClassLoader);
-        try {
-            onPong(payload);
-        } finally {
-            t.setContextClassLoader(cl);
-        }
-    }
-
-    @Override
-    public final void init(WebConnection webConnection) {
-
-        // TODO Make these buffer sizes configurable via the constructor
-        try {
-            inputStream = webConnection.getInputStream();
-            outbound = new WsOutbound(webConnection.getOutputStream(),
-                    outboundByteBufferSize, outboundCharBufferSize);
-        } catch (IOException ioe) {
-            // TODO i18n
-            throw new IllegalStateException(ioe);
-        }
-
-        // Need to call onOpen using the web application's class loader
-        Thread t = Thread.currentThread();
-        ClassLoader cl = t.getContextClassLoader();
-        t.setContextClassLoader(applicationClassLoader);
-        try {
-            onOpen(outbound);
-        } finally {
-            t.setContextClassLoader(cl);
-        }
-
-        onData();
-    }
-
-    /**
-     * Intended to be overridden by sub-classes that wish to be notified
-     * when the outbound connection is established. The default implementation
-     * is a NO-OP.
-     *
-     * @param outbound    The outbound WebSocket connection.
-     */
-    protected void onOpen(WsOutbound outbound) {
-        // NO-OP
-    }
-
-    /**
-     * Intended to be overridden by sub-classes that wish to be notified
-     * when the outbound connection is closed. The default implementation
-     * is a NO-OP.
-     *
-     * @param status    The status code of the close reason.
-     */
-    protected void onClose(int status) {
-        // NO-OP
-    }
-
-    /**
-     * Intended to be overridden by sub-classes that wish to be notified
-     * when a pong is received. The default implementation is a NO-OP.
-     *
-     * @param payload   The payload included in the pong.
-     */
-    protected void onPong(ByteBuffer payload) {
-        // NO-OP
-    }
-
-    /**
-     * This method is called when there is a binary WebSocket message available
-     * to process. The message is presented via a stream and may be formed from
-     * one or more frames. The number of frames used to transmit the message is
-     * not made visible to the application.
-     *
-     * @param is    The WebSocket message
-     *
-     * @throws IOException  If a problem occurs processing the message. Any
-     *                      exception will trigger the closing of the WebSocket
-     *                      connection.
-     */
-    protected abstract void onBinaryData(InputStream is) throws IOException;
-
-
-    /**
-     * This method is called when there is a textual WebSocket message available
-     * to process. The message is presented via a reader and may be formed from
-     * one or more frames. The number of frames used to transmit the message is
-     * not made visible to the application.
-     *
-     * @param r     The WebSocket message
-     *
-     * @throws IOException  If a problem occurs processing the message. Any
-     *                      exception will trigger the closing of the WebSocket
-     *                      connection.
-     */
-    protected abstract void onTextData(Reader r) throws IOException;
-}

==================================================
WsFrame.java
deleted file mode 100644
index 33f9ed67dc..0000000000
--- a/java/org/apache/catalina/websocket/WebSocketServlet.java
+++ /dev/null
@@ -1,233 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.websocket;
-
-import java.io.IOException;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Enumeration;
-import java.util.List;
-import java.util.Queue;
-import java.util.concurrent.ConcurrentLinkedQueue;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServlet;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import javax.servlet.http.HttpUpgradeHandler;
-
-import org.apache.catalina.util.Base64;
-import org.apache.tomcat.util.buf.B2CConverter;
-
-/**
- * Provides the base implementation of a Servlet for processing WebSocket
- * connections as per RFC6455. It is expected that applications will extend this
- * implementation and provide application specific functionality.
- */
-public abstract class WebSocketServlet extends HttpServlet {
-
-    private static final long serialVersionUID = 1L;
-    private static final byte[] WS_ACCEPT =
-            "258EAFA5-E914-47DA-95CA-C5AB0DC85B11".getBytes(
-                    B2CConverter.ISO_8859_1);
-
-    private final Queue<MessageDigest> sha1Helpers =
-            new ConcurrentLinkedQueue<>();
-
-
-    @Override
-    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
-            throws ServletException, IOException {
-
-        // Information required to send the server handshake message
-        String key;
-        String subProtocol = null;
-        List<String> extensions = Collections.emptyList();
-
-        if (!headerContainsToken(req, "upgrade", "websocket")) {
-            resp.sendError(HttpServletResponse.SC_BAD_REQUEST);
-            return;
-        }
-
-        if (!headerContainsToken(req, "connection", "upgrade")) {
-            resp.sendError(HttpServletResponse.SC_BAD_REQUEST);
-            return;
-        }
-
-        if (!headerContainsToken(req, "sec-websocket-version", "13")) {
-            resp.setStatus(426);
-            resp.setHeader("Sec-WebSocket-Version", "13");
-            return;
-        }
-
-        key = req.getHeader("Sec-WebSocket-Key");
-        if (key == null) {
-            resp.sendError(HttpServletResponse.SC_BAD_REQUEST);
-            return;
-        }
-
-        String origin = req.getHeader("Origin");
-        if (!verifyOrigin(origin)) {
-            resp.sendError(HttpServletResponse.SC_FORBIDDEN);
-            return;
-        }
-
-        List<String> subProtocols = getTokensFromHeader(req,
-                "Sec-WebSocket-Protocol");
-        if (!subProtocols.isEmpty()) {
-            subProtocol = selectSubProtocol(subProtocols);
-
-        }
-
-        // TODO Read client handshake - Sec-WebSocket-Extensions
-
-        // TODO Extensions require the ability to specify something (API TBD)
-        //      that can be passed to the Tomcat internals and process extension
-        //      data present when the frame is fragmented.
-
-        // If we got this far, all is good. Accept the connection.
-        resp.setHeader("Upgrade", "websocket");
-        resp.setHeader("Connection", "upgrade");
-        resp.setHeader("Sec-WebSocket-Accept", getWebSocketAccept(key));
-        if (subProtocol != null) {
-            resp.setHeader("Sec-WebSocket-Protocol", subProtocol);
-        }
-        if (!extensions.isEmpty()) {
-            // TODO
-        }
-
-        WsHttpServletRequestWrapper wrapper = new WsHttpServletRequestWrapper(req);
-        HttpUpgradeHandler wsHandler =
-                createWebSocketHandler(subProtocol, wrapper);
-        wrapper.invalidate();
-
-        req.upgrade(wsHandler);
-    }
-
-
-    /*
-     * This only works for tokens. Quoted strings need more sophisticated
-     * parsing.
-     */
-    private boolean headerContainsToken(HttpServletRequest req,
-            String headerName, String target) {
-        Enumeration<String> headers = req.getHeaders(headerName);
-        while (headers.hasMoreElements()) {
-            String header = headers.nextElement();
-            String[] tokens = header.split(",");
-            for (String token : tokens) {
-                if (target.equalsIgnoreCase(token.trim())) {
-                    return true;
-                }
-            }
-        }
-        return false;
-    }
-
-
-    /*
-     * This only works for tokens. Quoted strings need more sophisticated
-     * parsing.
-     */
-    private List<String> getTokensFromHeader(HttpServletRequest req,
-            String headerName) {
-        List<String> result = new ArrayList<>();
-
-        Enumeration<String> headers = req.getHeaders(headerName);
-        while (headers.hasMoreElements()) {
-            String header = headers.nextElement();
-            String[] tokens = header.split(",");
-            for (String token : tokens) {
-                result.add(token.trim());
-            }
-        }
-        return result;
-    }
-
-
-    private String getWebSocketAccept(String key) throws ServletException {
-
-        MessageDigest sha1Helper = sha1Helpers.poll();
-        if (sha1Helper == null) {
-            try {
-                sha1Helper = MessageDigest.getInstance("SHA1");
-            } catch (NoSuchAlgorithmException e) {
-                throw new ServletException(e);
-            }
-        }
-
-        sha1Helper.reset();
-        sha1Helper.update(key.getBytes(B2CConverter.ISO_8859_1));
-        String result = Base64.encode(sha1Helper.digest(WS_ACCEPT));
-
-        sha1Helpers.add(sha1Helper);
-
-        return result;
-    }
-
-
-    /**
-     * Intended to be overridden by sub-classes that wish to verify the origin
-     * of a WebSocket request before processing it.
-     *
-     * @param origin    The value of the origin header from the request which
-     *                  may be <code>null</code>
-     *
-     * @return  <code>true</code> to accept the request. <code>false</code> to
-     *          reject it. This default implementation always returns
-     *          <code>true</code>.
-     */
-    protected boolean verifyOrigin(String origin) {
-        return true;
-    }
-
-
-    /**
-     * Intended to be overridden by sub-classes that wish to select a
-     * sub-protocol if the client provides a list of supported protocols.
-     *
-     * @param subProtocols  The list of sub-protocols supported by the client
-     *                      in client preference order. The server is under no
-     *                      obligation to respect the declared preference
-     * @return  <code>null</code> if no sub-protocol is selected or the name of
-     *          the protocol which <b>must</b> be one of the protocols listed by
-     *          the client. This default implementation always returns
-     *          <code>null</code>.
-     */
-    protected String selectSubProtocol(List<String> subProtocols) {
-        return null;
-    }
-
-
-    /**
-     * Create the instance that will process this inbound connection.
-     * Applications must provide a new instance for each connection.
-     *
-     * @param subProtocol   The sub-protocol agreed between the client and
-     *                      server or <code>null</code> if none was agreed
-     * @param request       The HTTP request that initiated this WebSocket
-     *                      connection. Note that this object is <b>only</b>
-     *                      valid inside this method. You must not retain a
-     *                      reference to it outside the execution of this
-     *                      method. If Tomcat detects such access, it will throw
-     *                      an IllegalStateException
-     */
-    protected abstract HttpUpgradeHandler createWebSocketHandler(
-            String subProtocol, HttpServletRequest request);
-}

==================================================
WsHttpServletRequestWrapper.java
deleted file mode 100644
index 43e80bb771..0000000000
--- a/java/org/apache/catalina/websocket/WsFrame.java
+++ /dev/null
@@ -1,228 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.websocket;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.nio.ByteBuffer;
-import java.nio.CharBuffer;
-import java.nio.charset.CoderResult;
-
-import org.apache.catalina.util.Conversions;
-import org.apache.tomcat.util.buf.Utf8Decoder;
-import org.apache.tomcat.util.res.StringManager;
-
-/**
- * Represents a complete WebSocket frame with the exception of the payload for
- * non-control frames.
- */
-public class WsFrame {
-
-    private static final StringManager sm =
-            StringManager.getManager(Constants.Package);
-
-
-    private final boolean fin;
-    private final int rsv;
-    private final byte opCode;
-    private final byte[] mask = new byte[4];
-    private long payloadLength;
-    private final ByteBuffer payload;
-
-    /**
-     * Create the new WebSocket frame, reading data from the processor as
-     * necessary.
-     *
-     * @param first     First byte of data for this frame
-     * @param processor Processor associated with the WebSocket connection on
-     *                  which the frame has been sent
-     *
-     * @throws IOException  If a problem occurs processing the frame. Any
-     *                      exception will trigger the closing of the WebSocket
-     *                      connection.
-     */
-    private WsFrame(byte first,
-            InputStream is) throws IOException {
-
-        int b = first & 0xFF;
-        fin = (b & 0x80) > 0;
-        rsv = (b & 0x70) >>> 4;
-        opCode = (byte) (b & 0x0F);
-
-        b = blockingRead(is);
-        // Client data must be masked
-        if ((b & 0x80) == 0) {
-            throw new IOException(sm.getString("frame.notMasked"));
-        }
-
-        payloadLength = b & 0x7F;
-        if (payloadLength == 126) {
-            byte[] extended = new byte[2];
-            blockingRead(is, extended);
-            payloadLength = Conversions.byteArrayToLong(extended);
-        } else if (payloadLength == 127) {
-            byte[] extended = new byte[8];
-            blockingRead(is, extended);
-            payloadLength = Conversions.byteArrayToLong(extended);
-        }
-
-        if (isControl()) {
-            if (payloadLength > 125) {
-                throw new IOException();
-            }
-            if (!fin) {
-                throw new IOException();
-            }
-        }
-
-        blockingRead(is, mask);
-
-        if (isControl()) {
-            // Note: Payload limited to <= 125 bytes by test above
-            payload = ByteBuffer.allocate((int) payloadLength);
-            blockingRead(is, payload);
-
-            if (opCode == Constants.OPCODE_CLOSE && payloadLength > 2) {
-                // Check close payload - if present - is valid UTF-8
-                CharBuffer cb = CharBuffer.allocate((int) payloadLength);
-                Utf8Decoder decoder = new Utf8Decoder();
-                payload.position(2);
-                CoderResult cr = decoder.decode(payload, cb, true);
-                payload.position(0);
-                if (cr.isError()) {
-                    throw new IOException(sm.getString("frame.invalidUtf8"));
-                }
-            }
-        } else {
-            payload = null;
-        }
-    }
-
-    public boolean getFin() {
-        return fin;
-    }
-
-    public int getRsv() {
-        return rsv;
-    }
-
-    public byte getOpCode() {
-        return opCode;
-    }
-
-    public boolean isControl() {
-        return (opCode & 0x08) > 0;
-    }
-
-    public byte[] getMask() {
-        return mask;
-    }
-
-    public long getPayLoadLength() {
-        return payloadLength;
-    }
-
-    public ByteBuffer getPayLoad() {
-        return payload;
-    }
-
-
-    /*
-     * Blocks until a aingle byte has been read
-     */
-    private int blockingRead(InputStream is)
-            throws IOException {
-        int result = is.read();
-        if (result == -1) {
-            throw new IOException(sm.getString("frame.eos"));
-        }
-        return result;
-    }
-
-
-    /*
-     * Blocks until the byte array has been filled.
-     */
-    private void blockingRead(InputStream is, byte[] bytes)
-            throws IOException {
-        int read = 0;
-        int last = 0;
-        while (read < bytes.length) {
-            // TODO Must block ????
-            last = is.read(bytes, read, bytes.length - read);
-            if (last == -1) {
-                throw new IOException(sm.getString("frame.eos"));
-            }
-            read += last;
-        }
-    }
-
-
-    /*
-     * Intended to read whole payload and blocks until it has. Therefore able to
-     * unmask the payload data.
-     */
-    private void blockingRead(InputStream is, ByteBuffer bb)
-            throws IOException {
-        int last = 0;
-        while (bb.hasRemaining()) {
-            last = is.read();
-            if (last == -1) {
-                throw new IOException(sm.getString("frame.eos"));
-            }
-            bb.put((byte) (last ^ mask[bb.position() % 4]));
-        }
-        bb.flip();
-    }
-
-
-    /**
-     * Read the next WebSocket frame, reading data from the processor as
-     * necessary.
-     *
-     * @param is    InputStream associated with the WebSocket connection on
-     *                  which the frame has been sent
-     *
-     * @param block Should this method block until a frame is presented if no
-     *              data is currently available to process. Note that is a
-     *              single byte is available, this method will block until the
-     *              complete frame (excluding payload for non-control frames) is
-     *              available.
-     *
-     * @throws IOException  If a problem occurs processing the frame. Any
-     *                      exception will trigger the closing of the WebSocket
-     *                      connection.
-     */
-    public static WsFrame nextFrame(InputStream is,
-            boolean block) throws IOException {
-
-        byte[] first = new byte[1];
-        // TODO Must block ?????
-        int read = is.read(first, 0, 1);
-        if (read == 1) {
-            return new WsFrame(first[0], is);
-        } else if (read == 0) {
-            return null;
-        } else if (read == -1) {
-            throw new EOFException(sm.getString("frame.readEos"));
-        } else {
-            throw new IOException(
-                    sm.getString("frame.readFailed", Integer.valueOf(read)));
-        }
-    }
-}

==================================================
WsInputStream.java
deleted file mode 100644
index debc6c45cb..0000000000
--- a/java/org/apache/catalina/websocket/WsHttpServletRequestWrapper.java
+++ /dev/null
@@ -1,420 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.websocket;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.UnsupportedEncodingException;
-import java.security.Principal;
-import java.util.Collection;
-import java.util.Enumeration;
-import java.util.Locale;
-import java.util.Map;
-
-import javax.servlet.AsyncContext;
-import javax.servlet.DispatcherType;
-import javax.servlet.RequestDispatcher;
-import javax.servlet.ServletContext;
-import javax.servlet.ServletException;
-import javax.servlet.ServletInputStream;
-import javax.servlet.ServletRequest;
-import javax.servlet.ServletResponse;
-import javax.servlet.http.Cookie;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import javax.servlet.http.HttpSession;
-import javax.servlet.http.HttpUpgradeHandler;
-import javax.servlet.http.Part;
-
-import org.apache.tomcat.util.res.StringManager;
-
-/**
- * Wrapper for the HttpServletRequest object that allows the underlying request
- * object to be invalidated.
- */
-public class WsHttpServletRequestWrapper implements HttpServletRequest {
-
-    private static final StringManager sm =
-            StringManager.getManager(Constants.Package);
-
-    private HttpServletRequest request;
-
-    public WsHttpServletRequestWrapper(HttpServletRequest request) {
-        this.request = request;
-    }
-
-    private HttpServletRequest getRequest() {
-        if (request == null) {
-            throw new IllegalStateException(sm.getString("wrapper.invalid"));
-        }
-        return request;
-    }
-
-    protected void invalidate() {
-        request = null;
-    }
-
-    @Override
-    public Object getAttribute(String name) {
-        return getRequest().getAttribute(name);
-    }
-
-    @Override
-    public Enumeration<String> getAttributeNames() {
-        return getRequest().getAttributeNames();
-    }
-
-    @Override
-    public String getCharacterEncoding() {
-        return getRequest().getCharacterEncoding();
-    }
-
-    @Override
-    public void setCharacterEncoding(String env)
-            throws UnsupportedEncodingException {
-        getRequest().setCharacterEncoding(env);
-    }
-
-    @Override
-    public int getContentLength() {
-        return getRequest().getContentLength();
-    }
-
-    @Override
-    public long getContentLengthLong() {
-        return getRequest().getContentLengthLong();
-    }
-
-    @Override
-    public String getContentType() {
-        return getRequest().getContentType();
-    }
-
-    @Override
-    public ServletInputStream getInputStream() throws IOException {
-        return getRequest().getInputStream();
-    }
-
-    @Override
-    public String getParameter(String name) {
-        return getRequest().getParameter(name);
-    }
-
-    @Override
-    public Enumeration<String> getParameterNames() {
-        return getRequest().getParameterNames();
-    }
-
-    @Override
-    public String[] getParameterValues(String name) {
-        return getRequest().getParameterValues(name);
-    }
-
-    @Override
-    public Map<String, String[]> getParameterMap() {
-        return getRequest().getParameterMap();
-    }
-
-    @Override
-    public String getProtocol() {
-        return getRequest().getProtocol();
-    }
-
-    @Override
-    public String getScheme() {
-        return getRequest().getScheme();
-    }
-
-    @Override
-    public String getServerName() {
-        return getRequest().getServerName();
-    }
-
-    @Override
-    public int getServerPort() {
-        return getRequest().getServerPort();
-    }
-
-    @Override
-    public BufferedReader getReader() throws IOException {
-        return getRequest().getReader();
-    }
-
-    @Override
-    public String getRemoteAddr() {
-        return getRequest().getRemoteAddr();
-    }
-
-    @Override
-    public String getRemoteHost() {
-        return getRequest().getRemoteHost();
-    }
-
-    @Override
-    public void setAttribute(String name, Object o) {
-        getRequest().setAttribute(name, o);
-    }
-
-    @Override
-    public void removeAttribute(String name) {
-        getRequest().removeAttribute(name);
-    }
-
-    @Override
-    public Locale getLocale() {
-        return getRequest().getLocale();
-    }
-
-    @Override
-    public Enumeration<Locale> getLocales() {
-        return getRequest().getLocales();
-    }
-
-    @Override
-    public boolean isSecure() {
-        return getRequest().isSecure();
-    }
-
-    @Override
-    public RequestDispatcher getRequestDispatcher(String path) {
-        return getRequest().getRequestDispatcher(path);
-    }
-
-    @Override
-    @Deprecated
-    public String getRealPath(String path) {
-        return getRequest().getRealPath(path);
-    }
-
-    @Override
-    public int getRemotePort() {
-        return getRequest().getRemotePort();
-    }
-
-    @Override
-    public String getLocalName() {
-        return getRequest().getLocalName();
-    }
-
-    @Override
-    public String getLocalAddr() {
-        return getRequest().getLocalAddr();
-    }
-
-    @Override
-    public int getLocalPort() {
-        return getRequest().getLocalPort();
-    }
-
-    @Override
-    public ServletContext getServletContext() {
-        return getRequest().getServletContext();
-    }
-
-    @Override
-    public AsyncContext startAsync() throws IllegalStateException {
-        return getRequest().startAsync();
-    }
-
-    @Override
-    public AsyncContext startAsync(ServletRequest servletRequest,
-            ServletResponse servletResponse) throws IllegalStateException {
-        return getRequest().startAsync(servletRequest, servletResponse);
-    }
-
-    @Override
-    public boolean isAsyncStarted() {
-        return getRequest().isAsyncStarted();
-    }
-
-    @Override
-    public boolean isAsyncSupported() {
-        return getRequest().isAsyncSupported();
-    }
-
-    @Override
-    public AsyncContext getAsyncContext() {
-        return getRequest().getAsyncContext();
-    }
-
-    @Override
-    public DispatcherType getDispatcherType() {
-        return getRequest().getDispatcherType();
-    }
-
-    @Override
-    public String getAuthType() {
-        return getRequest().getAuthType();
-    }
-
-    @Override
-    public Cookie[] getCookies() {
-        return getRequest().getCookies();
-    }
-
-    @Override
-    public long getDateHeader(String name) {
-        return getRequest().getDateHeader(name);
-    }
-
-    @Override
-    public String getHeader(String name) {
-        return getRequest().getHeader(name);
-    }
-
-    @Override
-    public Enumeration<String> getHeaders(String name) {
-        return getRequest().getHeaders(name);
-    }
-
-    @Override
-    public Enumeration<String> getHeaderNames() {
-        return getRequest().getHeaderNames();
-    }
-
-    @Override
-    public int getIntHeader(String name) {
-        return getRequest().getIntHeader(name);
-    }
-
-    @Override
-    public String getMethod() {
-        return getRequest().getMethod();
-    }
-
-    @Override
-    public String getPathInfo() {
-        return getRequest().getPathInfo();
-    }
-
-    @Override
-    public String getPathTranslated() {
-        return getRequest().getPathTranslated();
-    }
-
-    @Override
-    public String getContextPath() {
-        return getRequest().getContextPath();
-    }
-
-    @Override
-    public String getQueryString() {
-        return getRequest().getQueryString();
-    }
-
-    @Override
-    public String getRemoteUser() {
-        return getRequest().getRemoteUser();
-    }
-
-    @Override
-    public boolean isUserInRole(String role) {
-        return getRequest().isUserInRole(role);
-    }
-
-    @Override
-    public Principal getUserPrincipal() {
-        return getRequest().getUserPrincipal();
-    }
-
-    @Override
-    public String getRequestedSessionId() {
-        return getRequest().getRequestedSessionId();
-    }
-
-    @Override
-    public String getRequestURI() {
-        return getRequest().getRequestURI();
-    }
-
-    @Override
-    public StringBuffer getRequestURL() {
-        return getRequest().getRequestURL();
-    }
-
-    @Override
-    public String getServletPath() {
-        return getRequest().getServletPath();
-    }
-
-    @Override
-    public HttpSession getSession(boolean create) {
-        return getRequest().getSession(create);
-    }
-
-    @Override
-    public HttpSession getSession() {
-        return getRequest().getSession();
-    }
-
-    @Override
-    public String changeSessionId() {
-        return getRequest().changeSessionId();
-    }
-
-    @Override
-    public boolean isRequestedSessionIdValid() {
-        return getRequest().isRequestedSessionIdValid();
-    }
-
-    @Override
-    public boolean isRequestedSessionIdFromCookie() {
-        return getRequest().isRequestedSessionIdFromCookie();
-    }
-
-    @Override
-    public boolean isRequestedSessionIdFromURL() {
-        return getRequest().isRequestedSessionIdFromURL();
-    }
-
-    @Override
-    @Deprecated
-    public boolean isRequestedSessionIdFromUrl() {
-        return getRequest().isRequestedSessionIdFromUrl();
-    }
-
-    @Override
-    public boolean authenticate(HttpServletResponse response)
-            throws IOException, ServletException {
-        return getRequest().authenticate(response);
-    }
-
-    @Override
-    public void login(String username, String password) throws ServletException {
-        getRequest().login(username, password);
-    }
-
-    @Override
-    public void logout() throws ServletException {
-        getRequest().logout();
-    }
-
-    @Override
-    public Collection<Part> getParts() throws IOException, ServletException {
-        return getRequest().getParts();
-    }
-
-    @Override
-    public Part getPart(String name) throws IOException, ServletException {
-        return getRequest().getPart(name);
-    }
-
-    @Override
-    public void upgrade(HttpUpgradeHandler handler) throws IOException {
-        getRequest().upgrade(handler);
-    }
-}

==================================================
WsOutbound.java
deleted file mode 100644
index 3511cece07..0000000000
--- a/java/org/apache/catalina/websocket/WsInputStream.java
+++ /dev/null
@@ -1,157 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.websocket;
-
-import java.io.IOException;
-import java.io.InputStream;
-
-import org.apache.tomcat.util.res.StringManager;
-
-/**
- * This class is used to read WebSocket frames from the underlying socket and
- * makes the payload available for reading as an {@link InputStream}. It only
- * makes the number of bytes declared in the payload length available for
- * reading even if more bytes are available from the socket.
- */
-public class WsInputStream extends InputStream {
-
-    private static final StringManager sm =
-            StringManager.getManager(Constants.Package);
-
-
-    private final InputStream is;
-    private final WsOutbound outbound;
-
-    private WsFrame frame;
-    private long remaining;
-    private long readThisFragment;
-
-    private String error = null;
-
-
-    public WsInputStream(InputStream is, WsOutbound outbound) {
-        this.is = is;
-        this.outbound = outbound;
-    }
-
-
-    /**
-     * Process the next WebSocket frame.
-     *
-     * @param block Should this method block until a frame is presented if no
-     *              data is currently available to process. Note that if a
-     *              single byte is available, this method will block until the
-     *              complete frame (excluding payload for non-control frames) is
-     *              available.
-     *
-     * @return  The next frame to be processed or <code>null</code> if block is
-     *          <code>false</code> and there is no data to be processed.
-     *
-     * @throws IOException  If a problem occurs reading the data for the frame.
-     */
-    public WsFrame nextFrame(boolean block) throws IOException {
-        frame = WsFrame.nextFrame(is, block);
-        if (frame != null) {
-            readThisFragment = 0;
-            remaining = frame.getPayLoadLength();
-        }
-        return frame;
-    }
-
-
-    // ----------------------------------------------------- InputStream methods
-
-    @Override
-    public int read() throws IOException {
-
-        makePayloadDataAvailable();
-
-        if (remaining == 0) {
-            return -1;
-        }
-
-        remaining--;
-        readThisFragment++;
-
-        int masked = is.read();
-        if(masked == -1) {
-            return -1;
-        }
-        return masked ^
-                (frame.getMask()[(int) ((readThisFragment - 1) % 4)] & 0xFF);
-    }
-
-
-    @Override
-    public int read(byte b[], int off, int len) throws IOException {
-
-        makePayloadDataAvailable();
-
-        if (remaining == 0) {
-            return -1;
-        }
-
-        if (len > remaining) {
-            len = (int) remaining;
-        }
-        // TODO Must block????
-        int result = is.read(b, off, len);
-        if(result == -1) {
-            return -1;
-        }
-
-        for (int i = off; i < off + result; i++) {
-            b[i] = (byte) (b[i] ^
-                    frame.getMask()[(int) ((readThisFragment + i - off) % 4)]);
-        }
-        remaining -= result;
-        readThisFragment += result;
-        return result;
-    }
-
-
-    /*
-     * Ensures that there is payload data ready to read.
-     */
-    private void makePayloadDataAvailable() throws IOException {
-        if (error != null) {
-            throw new IOException(error);
-        }
-        while (remaining == 0 && !frame.getFin()) {
-            // Need more data - process next frame
-            nextFrame(true);
-            while (frame.isControl()) {
-                if (frame.getOpCode() == Constants.OPCODE_PING) {
-                    outbound.pong(frame.getPayLoad());
-                } else if (frame.getOpCode() == Constants.OPCODE_PONG) {
-                    // NO-OP. Swallow it.
-                } else if (frame.getOpCode() == Constants.OPCODE_CLOSE) {
-                    outbound.close(frame);
-                } else{
-                    throw new IOException(sm.getString("is.unknownOpCode",
-                            Byte.valueOf(frame.getOpCode())));
-                }
-                nextFrame(true);
-            }
-            if (frame.getOpCode() != Constants.OPCODE_CONTINUATION) {
-                error = sm.getString("is.notContinuation",
-                        Byte.valueOf(frame.getOpCode()));
-                throw new IOException(error);
-            }
-        }
-    }
-}

==================================================
