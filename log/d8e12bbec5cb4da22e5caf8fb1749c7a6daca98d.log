d8e12bbec5cb4da22e5caf8fb1749c7a6daca98d
==================================================
Get rid of ArrayList arithmetics in JavaClass.getAnnotationEntries()
==================================================
Konstantin Kolinko
==================================================
Fri Sep 12 18:57:28 2014 +0000
==================================================
ContextConfig.java
Get rid of ArrayList arithmetics in JavaClass.getAnnotationEntries()
Note that this changes return value of getAnnotationEntries() to be null instead of zero-length array by default.

This is based on the following:
- All annotation entries come from a "RuntimeVisibleAnnotations" attribute on a class file
- According to JVM specification, ch.4.7.16
"Each ClassFile, field_info, and method_info structure may contain at most one RuntimeVisibleAnnotations attribute"

Thus there is no need to create an array of attributes and enumerate all those, as there is either zero or one such attribute.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1624614 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Annotations.java
index d2de36b94b..0645cb8fa2 100644
--- a/java/org/apache/catalina/startup/ContextConfig.java
+++ b/java/org/apache/catalina/startup/ContextConfig.java
@@ -1993,17 +1993,18 @@ public class ContextConfig implements LifecycleListener {
         String className = clazz.getClassName();
 
         AnnotationEntry[] annotationsEntries = clazz.getAnnotationEntries();
-
-        for (AnnotationEntry ae : annotationsEntries) {
-            String type = ae.getAnnotationType();
-            if ("Ljavax/servlet/annotation/WebServlet;".equals(type)) {
-                processAnnotationWebServlet(className, ae, fragment);
-            }else if ("Ljavax/servlet/annotation/WebFilter;".equals(type)) {
-                processAnnotationWebFilter(className, ae, fragment);
-            }else if ("Ljavax/servlet/annotation/WebListener;".equals(type)) {
-                fragment.addListener(className);
-            } else {
-                // Unknown annotation - ignore
+        if (annotationsEntries != null) {
+            for (AnnotationEntry ae : annotationsEntries) {
+                String type = ae.getAnnotationType();
+                if ("Ljavax/servlet/annotation/WebServlet;".equals(type)) {
+                    processAnnotationWebServlet(className, ae, fragment);
+                }else if ("Ljavax/servlet/annotation/WebFilter;".equals(type)) {
+                    processAnnotationWebFilter(className, ae, fragment);
+                }else if ("Ljavax/servlet/annotation/WebListener;".equals(type)) {
+                    fragment.addListener(className);
+                } else {
+                    // Unknown annotation - ignore
+                }
             }
         }
     }
@@ -2068,24 +2069,25 @@ public class ContextConfig implements LifecycleListener {
             for (Map.Entry<Class<?>, Set<ServletContainerInitializer>> entry :
                     typeInitializerMap.entrySet()) {
                 if (entry.getKey().isAnnotation()) {
-                    AnnotationEntry[] annotationEntries =
-                            javaClass.getAnnotationEntries();
-                    for (AnnotationEntry annotationEntry : annotationEntries) {
-                        if (entry.getKey().getName().equals(
-                                getClassName(annotationEntry.getAnnotationType()))) {
-                            if (clazz == null) {
-                                clazz = Introspection.loadClass(
-                                        context, className);
+                    AnnotationEntry[] annotationEntries = javaClass.getAnnotationEntries();
+                    if (annotationEntries != null) {
+                        for (AnnotationEntry annotationEntry : annotationEntries) {
+                            if (entry.getKey().getName().equals(
+                                    getClassName(annotationEntry.getAnnotationType()))) {
                                 if (clazz == null) {
-                                    // Can't load the class so no point
-                                    // continuing
-                                    return;
+                                    clazz = Introspection.loadClass(
+                                            context, className);
+                                    if (clazz == null) {
+                                        // Can't load the class so no point
+                                        // continuing
+                                        return;
+                                    }
                                 }
+                                for (ServletContainerInitializer sci : entry.getValue()) {
+                                    initializerClassMap.get(sci).add(clazz);
+                                }
+                                break;
                             }
-                            for (ServletContainerInitializer sci : entry.getValue()) {
-                                initializerClassMap.get(sci).add(clazz);
-                            }
-                            break;
                         }
                     }
                 }

==================================================
Attribute.java
index b401c8fbed..dbefe420c2 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/Annotations.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/Annotations.java
@@ -26,7 +26,7 @@ import java.io.IOException;
  * @author  <A HREF="mailto:dbrosius@qis.net">D. Brosius</A>
  * @since 6.0
  */
-public class Annotations extends Attribute {
+public class Annotations {
 
     private final AnnotationEntry[] annotation_table;
 

==================================================
ClassParser.java
deleted file mode 100644
index 1db974037b..0000000000
--- a/java/org/apache/tomcat/util/bcel/classfile/Attribute.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- */
-package org.apache.tomcat.util.bcel.classfile;
-
-import java.io.DataInputStream;
-import java.io.IOException;
-
-import org.apache.tomcat.util.bcel.Constants;
-
-/**
- * Abstract super class for <em>Attribute</em> objects. Currently the
- * <em>ConstantValue</em>, <em>SourceFile</em>, <em>Code</em>,
- * <em>ExceptionTable</em>, <em>LineNumberTable</em>,
- * <em>LocalVariableTable</em>, <em>InnerClasses</em> and
- * <em>Synthetic</em> attributes are supported. The <em>Unknown</em>
- * attribute stands for non-standard-attributes.
- *
- * @author <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public abstract class Attribute {
-
-    Attribute() {
-    }
-
-    /*
-     * Class method reads one attribute from the input data stream. This method
-     * must not be accessible from the outside. It is called by the Field and
-     * Method constructor methods.
-     *
-     * @see Field
-     * @see Method @param file Input stream @param constant_pool Array of
-     *      constants @return Attribute @throws IOException @throws
-     *      ClassFormatException
-     */
-    public static final Attribute readAttribute(DataInputStream file,
-            ConstantPool constant_pool) throws IOException,
-            ClassFormatException
-    {
-        ConstantUtf8 c;
-        String name;
-        int name_index;
-        int length;
-        // Get class name from constant pool via `name_index' indirection
-        name_index = file.readUnsignedShort();
-        c = (ConstantUtf8) constant_pool.getConstant(name_index,
-                Constants.CONSTANT_Utf8);
-        name = c.getBytes();
-        // Length of data in bytes
-        length = file.readInt();
-
-        // Call proper constructor, depending on `name'
-        if (name.equals("RuntimeVisibleAnnotations")) {
-            return new Annotations(file, constant_pool);
-        } else {
-            // All other attributes are skipped
-            Utility.skipFully(file, length);
-            return null;
-        }
-    }
-}

==================================================
JavaClass.java
index c2107faa00..a095beb07c 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ClassParser.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ClassParser.java
@@ -48,7 +48,7 @@ public final class ClassParser {
     private int access_flags; // Access rights of parsed class
     private int[] interfaces; // Names of implemented interfaces
     private ConstantPool constant_pool; // collection of constants
-    private Attribute[] attributes; // attributes defined in the class
+    private Annotations runtimeVisibleAnnotations; // "RuntimeVisibleAnnotations" attribute defined in the class
     private static final int BUFSIZE = 8192;
 
 
@@ -99,24 +99,11 @@ public final class ClassParser {
         readMethods();
         // Read class attributes
         readAttributes();
-        // Check for unknown variables
-        //Unknown[] u = Unknown.getUnknownAttributes();
-        //for(int i=0; i < u.length; i++)
-        //  System.err.println("WARNING: " + u[i]);
-        // Everything should have been read now
-        //      if(file.available() > 0) {
-        //        int bytes = file.available();
-        //        byte[] buf = new byte[bytes];
-        //        file.read(buf);
-        //        if(!(is_zip && (buf.length == 1))) {
-        //          System.err.println("WARNING: Trailing garbage at end of " + file_name);
-        //          System.err.println(bytes + " extra bytes: " + Utility.toHexString(buf));
-        //        }
-        //      }
 
         // Return the information we have gathered in a new object
         return new JavaClass(class_name_index, superclass_name_index,
-                access_flags, constant_pool, interfaces, attributes);
+                access_flags, constant_pool, interfaces,
+                runtimeVisibleAnnotations);
     }
 
 
@@ -128,9 +115,29 @@ public final class ClassParser {
     private void readAttributes() throws IOException, ClassFormatException {
         int attributes_count;
         attributes_count = file.readUnsignedShort();
-        attributes = new Attribute[attributes_count];
         for (int i = 0; i < attributes_count; i++) {
-            attributes[i] = Attribute.readAttribute(file, constant_pool);
+            ConstantUtf8 c;
+            String name;
+            int name_index;
+            int length;
+            // Get class name from constant pool via `name_index' indirection
+            name_index = file.readUnsignedShort();
+            c = (ConstantUtf8) constant_pool.getConstant(name_index,
+                    Constants.CONSTANT_Utf8);
+            name = c.getBytes();
+            // Length of data in bytes
+            length = file.readInt();
+
+            if (name.equals("RuntimeVisibleAnnotations")) {
+                if (runtimeVisibleAnnotations != null) {
+                    throw new ClassFormatException(
+                            "RuntimeVisibleAnnotations attribute is not allowed more than once in a class file");
+                }
+                runtimeVisibleAnnotations = new Annotations(file, constant_pool);
+            } else {
+                // All other attributes are skipped
+                Utility.skipFully(file, length);
+            }
         }
     }
 

==================================================
