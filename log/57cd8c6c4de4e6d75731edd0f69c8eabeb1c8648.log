57cd8c6c4de4e6d75731edd0f69c8eabeb1c8648
==================================================
Update to Java 20 API
==================================================
remm remm@apache.org
==================================================
Wed Sep 21 11:27:27 2022 +0200
==================================================
OpenSSLContext.java
index 600cb8d575..dc3617b8b3 100644
--- a/modules/openssl-foreign/README.md
+++ b/modules/openssl-foreign/README.md
@@ -7,8 +7,8 @@ at `https://openjdk.java.net/jeps/XXX`.
 
 ## Building the JDK with the JEP XXX API
 
-Clone `https://github.com/openjdk/jdk/` in some location and
-checkout the mais branch. This is a Java 20 development JVM
+Clone `https://github.com/openjdk/panama-foreign/` in some location and
+checkout the main branch. This is a Java 20 development JVM
 with the JEP XXX API. It may fail to build. When this happens, step back
 one commit at a time until it does.
 
@@ -68,10 +68,9 @@ export JAVA_OPTS="--enable-preview --enable-native-access=ALL-UNNAMED"
 ## Generating the OpenSSL API code using jextract (optional)
 
 jextract is now available in its own standalone repository. Clone
-`https://github.com/openjdk/jextract` in some location. Please refer to the
+`https://github.com/openjdk/jextract` in some location and
+checkout the `panama` branch. Please refer to the
 instructions from the repository for building.
-However, jextract has not been adapted yet to the JEP 424 API and the generated
-code will need to be modified manually.
 
 This step is only useful to be able to use additional native APIs from OpenSSL
 or stdlib.

==================================================
OpenSSLEngine.java
index 37fe09a49d..a27da76d31 100644
--- a/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/net/openssl/panama/OpenSSLContext.java
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/net/openssl/panama/OpenSSLContext.java
@@ -20,10 +20,8 @@ import static org.apache.tomcat.util.openssl.openssl_h.*;
 import static org.apache.tomcat.util.openssl.openssl_compat_h.*;
 
 import java.io.File;
-import java.lang.foreign.Addressable;
 import java.lang.foreign.FunctionDescriptor;
 import java.lang.foreign.Linker;
-import java.lang.foreign.MemoryAddress;
 import java.lang.foreign.MemorySegment;
 import java.lang.foreign.MemorySession;
 import java.lang.foreign.SegmentAllocator;
@@ -137,16 +135,16 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
         MethodHandles.Lookup lookup = MethodHandles.lookup();
         try {
             openSSLCallbackVerifyHandle = lookup.findStatic(OpenSSLContext.class, "openSSLCallbackVerify",
-                    MethodType.methodType(int.class, int.class, MemoryAddress.class));
+                    MethodType.methodType(int.class, int.class, MemorySegment.class));
             openSSLCallbackPasswordHandle = lookup.findStatic(OpenSSLContext.class, "openSSLCallbackPassword",
-                    MethodType.methodType(int.class, MemoryAddress.class, int.class, int.class, MemoryAddress.class));
+                    MethodType.methodType(int.class, MemorySegment.class, int.class, int.class, MemorySegment.class));
             openSSLCallbackCertVerifyHandle = lookup.findStatic(OpenSSLContext.class, "openSSLCallbackCertVerify",
-                    MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class));
+                    MethodType.methodType(int.class, MemorySegment.class, MemorySegment.class));
             openSSLCallbackAlpnSelectProtoHandle = lookup.findStatic(OpenSSLContext.class, "openSSLCallbackAlpnSelectProto",
-                    MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class,
-                            MemoryAddress.class, MemoryAddress.class, int.class, MemoryAddress.class));
+                    MethodType.methodType(int.class, MemorySegment.class, MemorySegment.class,
+                            MemorySegment.class, MemorySegment.class, int.class, MemorySegment.class));
             openSSLCallbackTmpDHHandle = lookup.findStatic(OpenSSLContext.class, "openSSLCallbackTmpDH",
-                    MethodType.methodType(Addressable.class, MemoryAddress.class, int.class, int.class));
+                    MethodType.methodType(MemorySegment.class, MemorySegment.class, int.class, int.class));
         } catch (Exception e) {
             throw new IllegalStateException(e);
         }
@@ -171,23 +169,23 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
 
     private static final ConcurrentHashMap<Long, ContextState> states = new ConcurrentHashMap<>();
 
-    static ContextState getState(MemoryAddress ctx) {
-        return states.get(Long.valueOf(ctx.toRawLongValue()));
+    static ContextState getState(MemorySegment ctx) {
+        return states.get(Long.valueOf(Long.valueOf(ctx.address())));
     }
 
     private final ContextState state;
     private final Cleanable cleanable;
 
-    private static String[] getCiphers(MemoryAddress sslCtx) {
-        MemoryAddress sk = SSL_CTX_get_ciphers(sslCtx);
+    private static String[] getCiphers(MemorySegment sslCtx) {
+        MemorySegment sk = SSL_CTX_get_ciphers(sslCtx);
         int len = OPENSSL_sk_num(sk);
         if (len <= 0) {
             return null;
         }
         ArrayList<String> ciphers = new ArrayList<>(len);
         for (int i = 0; i < len; i++) {
-            MemoryAddress cipher = OPENSSL_sk_value(sk, i);
-            MemoryAddress cipherName = SSL_CIPHER_get_name(cipher);
+            MemorySegment cipher = OPENSSL_sk_value(sk, i);
+            MemorySegment cipherName = SSL_CIPHER_get_name(cipher);
             ciphers.add(cipherName.getUtf8String(0));
         }
         return ciphers.toArray(new String[0]);
@@ -209,8 +207,8 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
         this.certificate = certificate;
         MemorySession contextMemorySession = MemorySession.openShared();
 
-        MemoryAddress sslCtx = MemoryAddress.NULL;
-        MemoryAddress confCtx = MemoryAddress.NULL;
+        MemorySegment sslCtx = MemorySegment.NULL;
+        MemorySegment confCtx = MemorySegment.NULL;
         List<byte[]> negotiableProtocolsBytes = null;
         boolean success = false;
         try {
@@ -283,7 +281,7 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
             maxTlsVersion = prot;
             // # define SSL_CTX_set_max_proto_version(sslCtx, version) \
             //          SSL_CTX_ctrl(sslCtx, SSL_CTRL_SET_MAX_PROTO_VERSION, version, NULL)
-            SSL_CTX_ctrl(sslCtx, SSL_CTRL_SET_MAX_PROTO_VERSION(), prot, MemoryAddress.NULL);
+            SSL_CTX_ctrl(sslCtx, SSL_CTRL_SET_MAX_PROTO_VERSION(), prot, MemorySegment.NULL);
             if (prot == TLS1_3_VERSION() && (protocol & SSL_PROTOCOL_TLSV1_2) > 0) {
                 prot = TLS1_2_VERSION();
             }
@@ -299,7 +297,7 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
             minTlsVersion = prot;
             //# define SSL_CTX_set_min_proto_version(sslCtx, version) \
             //         SSL_CTX_ctrl(sslCtx, SSL_CTRL_SET_MIN_PROTO_VERSION, version, NULL)
-            SSL_CTX_ctrl(sslCtx, SSL_CTRL_SET_MIN_PROTO_VERSION(), prot, MemoryAddress.NULL);
+            SSL_CTX_ctrl(sslCtx, SSL_CTRL_SET_MIN_PROTO_VERSION(), prot, MemorySegment.NULL);
 
             // Disable compression, usually unsafe
             SSL_CTX_set_options(sslCtx, SSL_OP_NO_COMPRESSION());
@@ -314,12 +312,12 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
             // Default session context id and cache size
             // # define SSL_CTX_sess_set_cache_size(sslCtx,t) \
             //          SSL_CTX_ctrl(sslCtx,SSL_CTRL_SET_SESS_CACHE_SIZE,t,NULL)
-            SSL_CTX_ctrl(sslCtx, SSL_CTRL_SET_SESS_CACHE_SIZE(), 256, MemoryAddress.NULL);
+            SSL_CTX_ctrl(sslCtx, SSL_CTRL_SET_SESS_CACHE_SIZE(), 256, MemorySegment.NULL);
 
             // Session cache is disabled by default
             // # define SSL_CTX_set_session_cache_mode(sslCtx,m) \
             //          SSL_CTX_ctrl(sslCtx,SSL_CTRL_SET_SESS_CACHE_MODE,m,NULL)
-            SSL_CTX_ctrl(sslCtx, SSL_CTRL_SET_SESS_CACHE_MODE(), SSL_SESS_CACHE_OFF(), MemoryAddress.NULL);
+            SSL_CTX_ctrl(sslCtx, SSL_CTRL_SET_SESS_CACHE_MODE(), SSL_SESS_CACHE_OFF(), MemorySegment.NULL);
 
             // Longer session timeout
             SSL_CTX_set_timeout(sslCtx, 14400);
@@ -631,8 +629,8 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
                     //SSLContext.addClientCACertificateRaw(state.ctx, caCert.getEncoded());
                     var rawCACertificate = memorySession.allocateArray(ValueLayout.JAVA_BYTE, caCert.getEncoded());
                     var rawCACertificatePointer = memorySession.allocate(ValueLayout.ADDRESS, rawCACertificate);
-                    var x509CACert = d2i_X509(MemoryAddress.NULL, rawCACertificatePointer, rawCACertificate.byteSize());
-                    if (MemoryAddress.NULL.equals(x509CACert)) {
+                    var x509CACert = d2i_X509(MemorySegment.NULL, rawCACertificatePointer, rawCACertificate.byteSize());
+                    if (MemorySegment.NULL.equals(x509CACert)) {
                         logLastError(memorySession, "openssl.errorLoadingCertificate");
                     } else if (SSL_CTX_add_client_CA(state.sslCtx, x509CACert) <= 0) {
                         logLastError(memorySession, "openssl.errorAddingCertificate");
@@ -651,23 +649,23 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
                         ? memorySession.allocateUtf8String(SSLHostConfig.adjustRelativePath(sslHostConfig.getCaCertificatePath())) : null;
                 if ((sslHostConfig.getCaCertificateFile() != null || sslHostConfig.getCaCertificatePath() != null) 
                         && SSL_CTX_load_verify_locations(state.sslCtx,
-                                caCertificateFileNative == null ? MemoryAddress.NULL : caCertificateFileNative,
-                                        caCertificatePathNative == null ? MemoryAddress.NULL : caCertificatePathNative) <= 0) {
+                                caCertificateFileNative == null ? MemorySegment.NULL : caCertificateFileNative,
+                                        caCertificatePathNative == null ? MemorySegment.NULL : caCertificatePathNative) <= 0) {
                     logLastError(memorySession, "openssl.errorConfiguringLocations");
                 } else {
                     var caCerts = SSL_CTX_get_client_CA_list(state.sslCtx);
-                    if (MemoryAddress.NULL.equals(caCerts)) {
-                        caCerts = SSL_load_client_CA_file(caCertificateFileNative == null ? MemoryAddress.NULL : caCertificateFileNative);
-                        if (!MemoryAddress.NULL.equals(caCerts)) {
+                    if (MemorySegment.NULL.equals(caCerts)) {
+                        caCerts = SSL_load_client_CA_file(caCertificateFileNative == null ? MemorySegment.NULL : caCertificateFileNative);
+                        if (!MemorySegment.NULL.equals(caCerts)) {
                             SSL_CTX_set_client_CA_list(state.sslCtx, caCerts);
                         }
                     } else {
                         if (SSL_add_file_cert_subjects_to_stack(caCerts,
-                                caCertificateFileNative == null ? MemoryAddress.NULL : caCertificateFileNative) <= 0) {
-                            caCerts = MemoryAddress.NULL;
+                                caCertificateFileNative == null ? MemorySegment.NULL : caCertificateFileNative) <= 0) {
+                            caCerts = MemorySegment.NULL;
                         }
                     }
-                    if (MemoryAddress.NULL.equals(caCerts)) {
+                    if (MemorySegment.NULL.equals(caCerts)) {
                         log.warn(sm.getString("openssl.noCACerts"));
                     }
                 }
@@ -684,7 +682,7 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
 
             // Apply OpenSSLConfCmd if used
             OpenSSLConf openSslConf = sslHostConfig.getOpenSslConf();
-            if (openSslConf != null && !MemoryAddress.NULL.equals(state.confCtx)) {
+            if (openSslConf != null && !MemorySegment.NULL.equals(state.confCtx)) {
                 // Check OpenSSLConfCmd if used
                 if (log.isDebugEnabled()) {
                     log.debug(sm.getString("openssl.checkConf"));
@@ -735,7 +733,7 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
                 sslHostConfig.setEnabledProtocols(
                         enabled.toArray(new String[0]));
                 // Reconfigure the enabled ciphers
-                sslHostConfig.setEnabledCiphers(getCiphers(state.sslCtx.address()));
+                sslHostConfig.setEnabledCiphers(getCiphers(state.sslCtx));
             }
 
             sessionContext = new OpenSSLSessionContext(this);
@@ -743,7 +741,7 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
             // this is set so always set it in case an app is configured to
             // require it
             sessionContext.setSessionIdContext(DEFAULT_SESSION_ID_CONTEXT);
-            sslHostConfig.setOpenSslContext(state.sslCtx.address().toRawLongValue());
+            sslHostConfig.setOpenSslContext(state.sslCtx.address());
             initialized = true;
         } catch (Exception e) {
             log.warn(sm.getString("openssl.errorSSLCtxInit"), e);
@@ -752,14 +750,14 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
     }
 
 
-    public MemoryAddress getSSLContext() {
-        return state.sslCtx.address();
+    public MemorySegment getSSLContext() {
+        return state.sslCtx;
     }
 
     // DH *(*tmp_dh_callback)(SSL *ssl, int is_export, int keylength)
-    public static Addressable openSSLCallbackTmpDH(MemoryAddress ssl, int isExport, int keylength) {
+    public static MemorySegment openSSLCallbackTmpDH(MemorySegment ssl, int isExport, int keylength) {
         var pkey = SSL_get_privatekey(ssl);
-        int type = (MemoryAddress.NULL.equals(pkey)) ? EVP_PKEY_NONE()
+        int type = (MemorySegment.NULL.equals(pkey)) ? EVP_PKEY_NONE()
                 : (OPENSSL_3 ? EVP_PKEY_get_base_id(pkey) : EVP_PKEY_base_id(pkey));
         /*
          * OpenSSL will call us with either keylen == 512 or keylen == 1024
@@ -782,36 +780,38 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
                 return OpenSSLLifecycleListener.dhParameters[i].dh;
             }
         }
-        return MemoryAddress.NULL;
+        return MemorySegment.NULL;
     }
 
     // int SSL_callback_alpn_select_proto(SSL* ssl, const unsigned char **out, unsigned char *outlen,
     //        const unsigned char *in, unsigned int inlen, void *arg)
-    public static int openSSLCallbackAlpnSelectProto(MemoryAddress ssl, MemoryAddress out, MemoryAddress outlen,
-            MemoryAddress in, int inlen, MemoryAddress arg) {
+    public static int openSSLCallbackAlpnSelectProto(MemorySegment ssl, MemorySegment out, MemorySegment outlen,
+            MemorySegment in, int inlen, MemorySegment arg) {
         ContextState state = getState(arg);
         if (state == null) {
-            log.warn(sm.getString("context.noSSL", Long.valueOf(arg.toRawLongValue())));
+            log.warn(sm.getString("context.noSSL", Long.valueOf(arg.address())));
             return SSL_TLSEXT_ERR_NOACK();
         }
         // Byte by byte read, the ALPN data is small
-        byte[] advertisedBytes = new byte[inlen];
-        for (int i = 0; i < inlen; i++) {
-            advertisedBytes[i] = in.get(ValueLayout.JAVA_BYTE, i);
-        }
-        for (byte[] negotiableProtocolBytes : state.negotiableProtocols) {
-            for (int i = 0; i <= advertisedBytes.length - negotiableProtocolBytes.length; i++) {
-                if (advertisedBytes[i] == negotiableProtocolBytes[0]) {
-                    for (int j = 0; j < negotiableProtocolBytes.length; j++) {
-                        if (advertisedBytes[i + j] == negotiableProtocolBytes[j]) {
-                            if (j == negotiableProtocolBytes.length - 1) {
-                                // Match
-                                out.set(ValueLayout.ADDRESS, 0, in.addOffset(i));
-                                outlen.set(ValueLayout.JAVA_BYTE, 0, (byte) negotiableProtocolBytes.length);
-                                return SSL_TLSEXT_ERR_OK();
+        try (var memorySession = MemorySession.openConfined()) {
+            MemorySegment inSeg = MemorySegment.ofAddress(in.address(), inlen, memorySession);
+            byte[] advertisedBytes = inSeg.toArray(ValueLayout.JAVA_BYTE);
+            for (byte[] negotiableProtocolBytes : state.negotiableProtocols) {
+                for (int i = 0; i <= advertisedBytes.length - negotiableProtocolBytes.length; i++) {
+                    if (advertisedBytes[i] == negotiableProtocolBytes[0]) {
+                        for (int j = 0; j < negotiableProtocolBytes.length; j++) {
+                            if (advertisedBytes[i + j] == negotiableProtocolBytes[j]) {
+                                if (j == negotiableProtocolBytes.length - 1) {
+                                    // Match
+                                    MemorySegment outSeg = MemorySegment.ofAddress(out.address(), ValueLayout.ADDRESS.byteSize(), memorySession);
+                                    outSeg.set(ValueLayout.ADDRESS, 0, inSeg.asSlice(i));
+                                    MemorySegment outlenSeg = MemorySegment.ofAddress(outlen.address(), ValueLayout.JAVA_BYTE.byteSize(), memorySession);
+                                    outlenSeg.set(ValueLayout.JAVA_BYTE, 0, (byte) negotiableProtocolBytes.length);
+                                    return SSL_TLSEXT_ERR_OK();
+                                }
+                            } else {
+                                break;
                             }
-                        } else {
-                            break;
                         }
                     }
                 }
@@ -820,42 +820,42 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
         return SSL_TLSEXT_ERR_NOACK();
     }
 
-    public static int openSSLCallbackVerify(int preverify_ok, MemoryAddress /*X509_STORE_CTX*/ x509ctx) {
+    public static int openSSLCallbackVerify(int preverify_ok, MemorySegment /*X509_STORE_CTX*/ x509ctx) {
         return OpenSSLEngine.openSSLCallbackVerify(preverify_ok, x509ctx);
     }
 
 
-    public static int openSSLCallbackCertVerify(MemoryAddress /*X509_STORE_CTX*/ x509_ctx, MemoryAddress param) {
+    public static int openSSLCallbackCertVerify(MemorySegment /*X509_STORE_CTX*/ x509_ctx, MemorySegment param) {
         if (log.isDebugEnabled()) {
             log.debug("Certificate verification");
         }
-        if (MemoryAddress.NULL.equals(param)) {
+        if (MemorySegment.NULL.equals(param)) {
             return 0;
         }
         ContextState state = getState(param);
         if (state == null) {
-            log.warn(sm.getString("context.noSSL", Long.valueOf(param.toRawLongValue())));
+            log.warn(sm.getString("context.noSSL", Long.valueOf(param.address())));
             return 0;
         }
-        MemoryAddress ssl = X509_STORE_CTX_get_ex_data(x509_ctx, SSL_get_ex_data_X509_STORE_CTX_idx());
-        MemoryAddress /*STACK_OF(X509)*/ sk = X509_STORE_CTX_get0_untrusted(x509_ctx);
+        MemorySegment ssl = X509_STORE_CTX_get_ex_data(x509_ctx, SSL_get_ex_data_X509_STORE_CTX_idx());
+        MemorySegment /*STACK_OF(X509)*/ sk = X509_STORE_CTX_get0_untrusted(x509_ctx);
         int len = OPENSSL_sk_num(sk);
         byte[][] certificateChain = new byte[len][];
         try (var memorySession = MemorySession.openConfined()) {
             for (int i = 0; i < len; i++) {
-                MemoryAddress/*(X509*)*/ x509 = OPENSSL_sk_value(sk, i);
-                MemorySegment bufPointer = memorySession.allocate(ValueLayout.ADDRESS, MemoryAddress.NULL);
+                MemorySegment/*(X509*)*/ x509 = OPENSSL_sk_value(sk, i);
+                MemorySegment bufPointer = memorySession.allocate(ValueLayout.ADDRESS, MemorySegment.NULL);
                 int length = i2d_X509(x509, bufPointer);
                 if (length < 0) {
                     certificateChain[i] = new byte[0];
                     continue;
                 }
-                MemoryAddress buf = bufPointer.get(ValueLayout.ADDRESS, 0);
-                certificateChain[i] = MemorySegment.ofAddress(buf, length, memorySession).toArray(ValueLayout.JAVA_BYTE);
-                CRYPTO_free(buf, MemoryAddress.NULL, 0); // OPENSSL_free macro
+                MemorySegment buf = bufPointer.get(ValueLayout.ADDRESS, 0);
+                certificateChain[i] = MemorySegment.ofAddress(buf.address(), length, memorySession).toArray(ValueLayout.JAVA_BYTE);
+                CRYPTO_free(buf, MemorySegment.NULL, 0); // OPENSSL_free macro
             }
-            MemoryAddress cipher = SSL_get_current_cipher(ssl);
-            String authMethod = (MemoryAddress.NULL.equals(cipher)) ? "UNKNOWN"
+            MemorySegment cipher = SSL_get_current_cipher(ssl);
+            String authMethod = (MemorySegment.NULL.equals(cipher)) ? "UNKNOWN"
                     : getCipherAuthenticationMethod(SSL_CIPHER_get_auth_nid(cipher), SSL_CIPHER_get_kx_nid(cipher));
             X509Certificate[] peerCerts = certificates(certificateChain);
             try {
@@ -953,7 +953,7 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
 
     private static ThreadLocal<String> callbackPasswordTheadLocal = new ThreadLocal<>();
 
-    public static int openSSLCallbackPassword(MemoryAddress /*char **/ buf, int bufsiz, int verify, MemoryAddress /*void **/ cb) {
+    public static int openSSLCallbackPassword(MemorySegment /*char **/ buf, int bufsiz, int verify, MemorySegment /*void **/ cb) {
         if (log.isDebugEnabled()) {
             log.debug("Return password for certificate");
         }
@@ -965,7 +965,7 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
                     // The password is too long
                     log.error(sm.getString("openssl.passwordTooLong"));
                 } else {
-                    MemorySegment bufSegment = MemorySegment.ofAddress(buf, bufsiz, memorySession);
+                    MemorySegment bufSegment = MemorySegment.ofAddress(buf.address(), bufsiz, memorySession);
                     bufSegment.copyFrom(callbackPasswordNative);
                     return (int) callbackPasswordNative.byteSize();
                 }
@@ -987,9 +987,9 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
             var certificateFileNative = memorySession.allocateUtf8String(SSLHostConfig.adjustRelativePath(certificate.getCertificateFile()));
             var certificateKeyFileNative = (certificate.getCertificateKeyFile() == null) ? certificateFileNative
                     : memorySession.allocateUtf8String(SSLHostConfig.adjustRelativePath(certificate.getCertificateKeyFile()));
-            MemoryAddress bio;
-            MemoryAddress cert = MemoryAddress.NULL;
-            MemoryAddress key = MemoryAddress.NULL;
+            MemorySegment bio;
+            MemorySegment cert = MemorySegment.NULL;
+            MemorySegment key = MemorySegment.NULL;
             if (certificate.getCertificateFile().endsWith(".pkcs12")) {
                 // Load pkcs12
                 bio = BIO_new(BIO_s_file());
@@ -1000,19 +1000,18 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
                     log.error(sm.getString("openssl.errorLoadingCertificate", "[0]:" + certificate.getCertificateFile()));
                     return;
                 }
-                MemoryAddress p12 = d2i_PKCS12_bio(bio, MemoryAddress.NULL);
+                MemorySegment p12 = d2i_PKCS12_bio(bio, MemorySegment.NULL);
                 BIO_free(bio);
-                if (MemoryAddress.NULL.equals(p12)) {
+                if (MemorySegment.NULL.equals(p12)) {
                     log.error(sm.getString("openssl.errorLoadingCertificate", "[1]:" + certificate.getCertificateFile()));
                     return;
                 }
-                MemoryAddress passwordAddress = MemoryAddress.NULL;
+                MemorySegment passwordAddress = MemorySegment.NULL;
                 int passwordLength = 0;
                 String callbackPassword = certificate.getCertificateKeyPassword();
                 if (callbackPassword != null && callbackPassword.length() > 0) {
-                    MemorySegment password = memorySession.allocateUtf8String(callbackPassword);
-                    passwordAddress = password.address();
-                    passwordLength = (int) (password.byteSize() - 1);
+                    passwordAddress = memorySession.allocateUtf8String(callbackPassword);
+                    passwordLength = (int) (passwordAddress.byteSize() - 1);
                 }
                 if (PKCS12_verify_mac(p12, passwordAddress, passwordLength) <= 0) {
                     // Bad password
@@ -1022,7 +1021,7 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
                 }
                 MemorySegment certPointer = memorySession.allocate(ValueLayout.ADDRESS);
                 MemorySegment keyPointer = memorySession.allocate(ValueLayout.ADDRESS);
-                if (PKCS12_parse(p12, passwordAddress, keyPointer, certPointer, MemoryAddress.NULL) <= 0) {
+                if (PKCS12_parse(p12, passwordAddress, keyPointer, certPointer, MemorySegment.NULL) <= 0) {
                     log.error(sm.getString("openssl.errorLoadingCertificate", "[3]:" + certificate.getCertificateFile()));
                     PKCS12_free(p12);
                     return;
@@ -1040,27 +1039,27 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
                     log.error(sm.getString("openssl.errorLoadingCertificate", certificate.getCertificateKeyFile()));
                     return;
                 }
-                key = MemoryAddress.NULL;
+                key = MemorySegment.NULL;
                 for (int i = 0; i < 3; i++) {
                     try {
                         callbackPasswordTheadLocal.set(certificate.getCertificateKeyPassword());
-                        key = PEM_read_bio_PrivateKey(bio, MemoryAddress.NULL, openSSLCallbackPassword, MemoryAddress.NULL);
+                        key = PEM_read_bio_PrivateKey(bio, MemorySegment.NULL, openSSLCallbackPassword, MemorySegment.NULL);
                     } finally {
                         callbackPasswordTheadLocal.set(null);
                     }
-                    if (!MemoryAddress.NULL.equals(key)) {
+                    if (!MemorySegment.NULL.equals(key)) {
                         break;
                     }
-                    BIO_ctrl(bio, BIO_CTRL_RESET(), 0, MemoryAddress.NULL);
+                    BIO_ctrl(bio, BIO_CTRL_RESET(), 0, MemorySegment.NULL);
                 }
                 BIO_free(bio);
-                if (MemoryAddress.NULL.equals(key)) {
-                    if (!MemoryAddress.NULL.equals(OpenSSLLifecycleListener.enginePointer)) {
+                if (MemorySegment.NULL.equals(key)) {
+                    if (!MemorySegment.NULL.equals(OpenSSLLifecycleListener.enginePointer)) {
                         key = ENGINE_load_private_key(OpenSSLLifecycleListener.enginePointer, certificateKeyFileNative,
-                                MemoryAddress.NULL, MemoryAddress.NULL);
+                                MemorySegment.NULL, MemorySegment.NULL);
                     }
                 }
-                if (MemoryAddress.NULL.equals(key)) {
+                if (MemorySegment.NULL.equals(key)) {
                     log.error(sm.getString("openssl.errorLoadingCertificate", certificate.getCertificateKeyFile()));
                     return;
                 }
@@ -1073,11 +1072,11 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
                 }
                 try {
                     callbackPasswordTheadLocal.set(certificate.getCertificateKeyPassword());
-                    cert = PEM_read_bio_X509_AUX(bio, MemoryAddress.NULL, openSSLCallbackPassword, MemoryAddress.NULL);
+                    cert = PEM_read_bio_X509_AUX(bio, MemorySegment.NULL, openSSLCallbackPassword, MemorySegment.NULL);
                 } finally {
                     callbackPasswordTheadLocal.set(null);
                 }
-                if (MemoryAddress.NULL.equals(cert) &&
+                if (MemorySegment.NULL.equals(cert) &&
                         // Missing ERR_GET_REASON(ERR_peek_last_error())
                         /*int ERR_GET_REASON(unsigned long errcode) {
                          *    if (ERR_SYSTEM_ERROR(errcode))
@@ -1091,11 +1090,11 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
                          */
                         ((ERR_peek_last_error() & 0X7FFFFF) == PEM_R_NO_START_LINE())) {
                     ERR_clear_error();
-                    BIO_ctrl(bio, BIO_CTRL_RESET(), 0, MemoryAddress.NULL);
-                    cert = d2i_X509_bio(bio, MemoryAddress.NULL);
+                    BIO_ctrl(bio, BIO_CTRL_RESET(), 0, MemorySegment.NULL);
+                    cert = d2i_X509_bio(bio, MemorySegment.NULL);
                 }
                 BIO_free(bio);
-                if (MemoryAddress.NULL.equals(cert)) {
+                if (MemorySegment.NULL.equals(cert)) {
                     log.error(sm.getString("openssl.errorLoadingCertificate", certificate.getCertificateFile()));
                     return;
                 }
@@ -1115,20 +1114,20 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
             // Try to read DH parameters from the (first) SSLCertificateFile
             if (index == SSL_AIDX_RSA) {
                 bio = BIO_new_file(certificateFileNative, memorySession.allocateUtf8String("r"));
-                var dh = PEM_read_bio_DHparams(bio, MemoryAddress.NULL, MemoryAddress.NULL, MemoryAddress.NULL);
+                var dh = PEM_read_bio_DHparams(bio, MemorySegment.NULL, MemorySegment.NULL, MemorySegment.NULL);
                 BIO_free(bio);
                 // #  define SSL_CTX_set_tmp_dh(sslCtx,dh) \
                 //           SSL_CTX_ctrl(sslCtx,SSL_CTRL_SET_TMP_DH,0,(char *)(dh))
-                if (!MemoryAddress.NULL.equals(dh)) {
+                if (!MemorySegment.NULL.equals(dh)) {
                     SSL_CTX_ctrl(state.sslCtx, SSL_CTRL_SET_TMP_DH(), 0, dh);
                     DH_free(dh);
                 }
             }
             // Similarly, try to read the ECDH curve name from SSLCertificateFile...
             bio = BIO_new_file(certificateFileNative, memorySession.allocateUtf8String("r"));
-            var ecparams = PEM_read_bio_ECPKParameters(bio, MemoryAddress.NULL, MemoryAddress.NULL, MemoryAddress.NULL);
+            var ecparams = PEM_read_bio_ECPKParameters(bio, MemorySegment.NULL, MemorySegment.NULL, MemorySegment.NULL);
             BIO_free(bio);
-            if (!MemoryAddress.NULL.equals(ecparams)) {
+            if (!MemorySegment.NULL.equals(ecparams)) {
                 int nid = EC_GROUP_get_curve_name(ecparams);
                 var eckey = EC_KEY_new_by_curve_name(nid);
                 // #  define SSL_CTX_set_tmp_ecdh(sslCtx,ecdh) \
@@ -1157,24 +1156,24 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
             //                sslHostConfig.getCertificateRevocationListFile()),
             //        SSLHostConfig.adjustRelativePath(
             //                sslHostConfig.getCertificateRevocationListPath()));
-            MemoryAddress certificateStore = SSL_CTX_get_cert_store(state.sslCtx);
+            MemorySegment certificateStore = SSL_CTX_get_cert_store(state.sslCtx);
             if (sslHostConfig.getCertificateRevocationListFile() != null) {
-                MemoryAddress x509Lookup = X509_STORE_add_lookup(certificateStore, X509_LOOKUP_file());
+                MemorySegment x509Lookup = X509_STORE_add_lookup(certificateStore, X509_LOOKUP_file());
                 var certificateRevocationListFileNative =
                         memorySession.allocateUtf8String(SSLHostConfig.adjustRelativePath(sslHostConfig.getCertificateRevocationListFile()));
                 //X509_LOOKUP_ctrl(lookup,X509_L_FILE_LOAD,file,type,NULL)
                 if (X509_LOOKUP_ctrl(x509Lookup, X509_L_FILE_LOAD(), certificateRevocationListFileNative,
-                        X509_FILETYPE_PEM(), MemoryAddress.NULL) <= 0) {
+                        X509_FILETYPE_PEM(), MemorySegment.NULL) <= 0) {
                     log.error(sm.getString("openssl.errorLoadingCertificateRevocationList", sslHostConfig.getCertificateRevocationListFile()));
                 }
             }
             if (sslHostConfig.getCertificateRevocationListPath() != null) {
-                MemoryAddress x509Lookup = X509_STORE_add_lookup(certificateStore, X509_LOOKUP_hash_dir());
+                MemorySegment x509Lookup = X509_STORE_add_lookup(certificateStore, X509_LOOKUP_hash_dir());
                 var certificateRevocationListPathNative =
                         memorySession.allocateUtf8String(SSLHostConfig.adjustRelativePath(sslHostConfig.getCertificateRevocationListPath()));
                 //X509_LOOKUP_ctrl(lookup,X509_L_ADD_DIR,path,type,NULL)
                 if (X509_LOOKUP_ctrl(x509Lookup, X509_L_ADD_DIR(), certificateRevocationListPathNative,
-                        X509_FILETYPE_PEM(), MemoryAddress.NULL) <= 0) {
+                        X509_FILETYPE_PEM(), MemorySegment.NULL) <= 0) {
                     log.error(sm.getString("openssl.errorLoadingCertificateRevocationList", sslHostConfig.getCertificateRevocationListPath()));
                 }
             }
@@ -1200,16 +1199,16 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
             var rawCertificate = memorySession.allocateArray(ValueLayout.JAVA_BYTE, chain[0].getEncoded());
             var rawCertificatePointer = memorySession.allocate(ValueLayout.ADDRESS, rawCertificate);
             var rawKey = memorySession.allocateArray(ValueLayout.JAVA_BYTE, sb.toString().getBytes(StandardCharsets.US_ASCII));
-            var x509cert = d2i_X509(MemoryAddress.NULL, rawCertificatePointer, rawCertificate.byteSize());
-            if (MemoryAddress.NULL.equals(x509cert)) {
+            var x509cert = d2i_X509(MemorySegment.NULL, rawCertificatePointer, rawCertificate.byteSize());
+            if (MemorySegment.NULL.equals(x509cert)) {
                 logLastError(memorySession, "openssl.errorLoadingCertificate");
                 return;
             }
             var bio = BIO_new(BIO_s_mem());
-            BIO_write(bio, rawKey.address(), (int) rawKey.byteSize());
-            MemoryAddress privateKeyAddress = PEM_read_bio_PrivateKey(bio, MemoryAddress.NULL, MemoryAddress.NULL, MemoryAddress.NULL);
+            BIO_write(bio, rawKey, (int) rawKey.byteSize());
+            MemorySegment privateKeyAddress = PEM_read_bio_PrivateKey(bio, MemorySegment.NULL, MemorySegment.NULL, MemorySegment.NULL);
             BIO_free(bio);
-            if (MemoryAddress.NULL.equals(privateKeyAddress)) {
+            if (MemorySegment.NULL.equals(privateKeyAddress)) {
                 logLastError(memorySession, "openssl.errorLoadingPrivateKey");
                 return;
             }
@@ -1233,8 +1232,8 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
                 //SSLContext.addChainCertificateRaw(state.ctx, chain[i].getEncoded());
                 var rawCertificateChain = memorySession.allocateArray(ValueLayout.JAVA_BYTE, chain[i].getEncoded());
                 var rawCertificateChainPointer = memorySession.allocate(ValueLayout.ADDRESS, rawCertificateChain);
-                var x509certChain = d2i_X509(MemoryAddress.NULL, rawCertificateChainPointer, rawCertificateChain.byteSize());
-                if (MemoryAddress.NULL.equals(x509certChain)) {
+                var x509certChain = d2i_X509(MemorySegment.NULL, rawCertificateChainPointer, rawCertificateChain.byteSize());
+                if (MemorySegment.NULL.equals(x509certChain)) {
                     logLastError(memorySession, "openssl.errorLoadingCertificate");
                     return;
                 }
@@ -1380,14 +1379,14 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
 
         private X509TrustManager x509TrustManager = null;
 
-        private ContextState(MemorySession contextMemorySession, MemoryAddress sslCtx,
-                MemoryAddress confCtx, List<byte[]> negotiableProtocols) {
-            states.put(Long.valueOf(sslCtx.toRawLongValue()), this);
+        private ContextState(MemorySession contextMemorySession, MemorySegment sslCtx,
+                MemorySegment confCtx, List<byte[]> negotiableProtocols) {
+            states.put(Long.valueOf(sslCtx.address()), this);
             this.contextMemorySession = contextMemorySession;
             // Allocate another session to avoid keeping a reference through segments
-            this.sslCtx = MemorySegment.ofAddress(sslCtx, ValueLayout.ADDRESS.byteSize(), stateSession);
-            if (!MemoryAddress.NULL.equals(confCtx)) {
-                this.confCtx = MemorySegment.ofAddress(confCtx, ValueLayout.ADDRESS.byteSize(), stateSession);
+            this.sslCtx = MemorySegment.ofAddress(sslCtx.address(), ValueLayout.ADDRESS.byteSize(), stateSession);
+            if (!MemorySegment.NULL.equals(confCtx)) {
+                this.confCtx = MemorySegment.ofAddress(confCtx.address(), ValueLayout.ADDRESS.byteSize(), stateSession);
             } else {
                 this.confCtx = null;
             }
@@ -1397,7 +1396,7 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
         @Override
         public void run() {
             try {
-                states.remove(Long.valueOf(sslCtx.address().toRawLongValue()));
+                states.remove(Long.valueOf(sslCtx.address()));
                 SSL_CTX_free(sslCtx);
                 if (confCtx != null) {
                     SSL_CONF_CTX_free(confCtx);

==================================================
OpenSSLLifecycleListener.java
index c0cf0d6b8e..f389d74a00 100644
--- a/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/net/openssl/panama/OpenSSLEngine.java
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/net/openssl/panama/OpenSSLEngine.java
@@ -20,7 +20,6 @@ import java.io.ByteArrayOutputStream;
 import java.io.InputStream;
 import java.lang.foreign.FunctionDescriptor;
 import java.lang.foreign.Linker;
-import java.lang.foreign.MemoryAddress;
 import java.lang.foreign.MemorySegment;
 import java.lang.foreign.MemorySession;
 import java.lang.foreign.ValueLayout;
@@ -93,9 +92,9 @@ public final class OpenSSLEngine extends SSLEngine implements SSLUtil.ProtocolIn
         MethodHandles.Lookup lookup = MethodHandles.lookup();
         try {
             openSSLCallbackInfoHandle = lookup.findStatic(OpenSSLEngine.class, "openSSLCallbackInfo",
-                    MethodType.methodType(void.class, MemoryAddress.class, int.class, int.class));
+                    MethodType.methodType(void.class, MemorySegment.class, int.class, int.class));
             openSSLCallbackVerifyHandle = lookup.findStatic(OpenSSLEngine.class, "openSSLCallbackVerify",
-                    MethodType.methodType(int.class, int.class, MemoryAddress.class));
+                    MethodType.methodType(int.class, int.class, MemorySegment.class));
         } catch (Exception e) {
             throw new IllegalStateException(e);
         }
@@ -140,16 +139,16 @@ public final class OpenSSLEngine extends SSLEngine implements SSLUtil.ProtocolIn
         IMPLEMENTED_PROTOCOLS_SET = Collections.unmodifiableSet(protocols);
     }
 
-    private static String[] getCiphers(MemoryAddress ssl) {
-        MemoryAddress sk = SSL_get_ciphers(ssl);
+    private static String[] getCiphers(MemorySegment ssl) {
+        MemorySegment sk = SSL_get_ciphers(ssl);
         int len = OPENSSL_sk_num(sk);
         if (len <= 0) {
             return null;
         }
         ArrayList<String> ciphers = new ArrayList<>(len);
         for (int i = 0; i < len; i++) {
-            MemoryAddress cipher = OPENSSL_sk_value(sk, i);
-            MemoryAddress cipherName = SSL_CIPHER_get_name(cipher);
+            MemorySegment cipher = OPENSSL_sk_value(sk, i);
+            MemorySegment cipherName = SSL_CIPHER_get_name(cipher);
             ciphers.add(cipherName.getUtf8String(0));
         }
         return ciphers.toArray(new String[0]);
@@ -176,8 +175,8 @@ public final class OpenSSLEngine extends SSLEngine implements SSLUtil.ProtocolIn
     private static final String INVALID_CIPHER = "SSL_NULL_WITH_NULL_NULL";
 
     private static final ConcurrentHashMap<Long, EngineState> states = new ConcurrentHashMap<>();
-    private static EngineState getState(MemoryAddress ssl) {
-        return states.get(Long.valueOf(ssl.toRawLongValue()));
+    private static EngineState getState(MemorySegment ssl) {
+        return states.get(Long.valueOf(ssl.address()));
     }
 
     private final EngineState state;
@@ -631,7 +630,7 @@ public final class OpenSSLEngine extends SSLEngine implements SSLUtil.ProtocolIn
         // SSL_pending will return 0 if OpenSSL has not started the current TLS record
         // See https://www.openssl.org/docs/manmaster/man3/SSL_pending.html
         clearLastError();
-        int lastPrimingReadResult = SSL_read(state.ssl, MemoryAddress.NULL, 0); // priming read
+        int lastPrimingReadResult = SSL_read(state.ssl, MemorySegment.NULL, 0); // priming read
         // check if SSL_read returned <= 0. In this case we need to check the error and see if it was something
         // fatal.
         if (lastPrimingReadResult <= 0) {
@@ -643,7 +642,7 @@ public final class OpenSSLEngine extends SSLEngine implements SSLUtil.ProtocolIn
         if (Constants.SSL_PROTO_TLSv1.equals(version) && lastPrimingReadResult == 0 &&
                 pendingReadableBytesInSSL == 0) {
             // Perform another priming read
-            lastPrimingReadResult = SSL_read(state.ssl, MemoryAddress.NULL, 0);
+            lastPrimingReadResult = SSL_read(state.ssl, MemorySegment.NULL, 0);
             if (lastPrimingReadResult <= 0) {
                 checkLastError();
             }
@@ -716,7 +715,7 @@ public final class OpenSSLEngine extends SSLEngine implements SSLUtil.ProtocolIn
         if (destroyed) {
             return new String[0];
         }
-        String[] enabled = getCiphers(state.ssl.address());
+        String[] enabled = getCiphers(state.ssl);
         if (enabled == null) {
             return new String[0];
         } else {
@@ -902,22 +901,22 @@ public final class OpenSSLEngine extends SSLEngine implements SSLUtil.ProtocolIn
 
     private byte[] getPeerCertificate() {
         try (var memorySession = MemorySession.openConfined()) {
-            MemoryAddress/*(X509*)*/ x509 = (OpenSSLContext.OPENSSL_3 ? SSL_get1_peer_certificate(state.ssl) : SSL_get_peer_certificate(state.ssl));
-            MemorySegment bufPointer = memorySession.allocate(ValueLayout.ADDRESS, MemoryAddress.NULL);
+            MemorySegment/*(X509*)*/ x509 = (OpenSSLContext.OPENSSL_3 ? SSL_get1_peer_certificate(state.ssl) : SSL_get_peer_certificate(state.ssl));
+            MemorySegment bufPointer = memorySession.allocate(ValueLayout.ADDRESS, MemorySegment.NULL);
             int length = i2d_X509(x509, bufPointer);
             if (length <= 0) {
                 return null;
             }
-            MemoryAddress buf = bufPointer.get(ValueLayout.ADDRESS, 0);
-            byte[] certificate = MemorySegment.ofAddress(buf, length, memorySession).toArray(ValueLayout.JAVA_BYTE);
+            MemorySegment buf = bufPointer.get(ValueLayout.ADDRESS, 0);
+            byte[] certificate = MemorySegment.ofAddress(buf.address(), length, memorySession).toArray(ValueLayout.JAVA_BYTE);
             X509_free(x509);
-            CRYPTO_free(buf, MemoryAddress.NULL, 0); // OPENSSL_free macro
+            CRYPTO_free(buf, MemorySegment.NULL, 0); // OPENSSL_free macro
             return certificate;
         }
     }
 
     private byte[][] getPeerCertChain() {
-        MemoryAddress/*STACK_OF(X509)*/ sk = SSL_get_peer_cert_chain(state.ssl);
+        MemorySegment/*STACK_OF(X509)*/ sk = SSL_get_peer_cert_chain(state.ssl);
         int len = OPENSSL_sk_num(sk);
         if (len <= 0) {
             return null;
@@ -925,17 +924,17 @@ public final class OpenSSLEngine extends SSLEngine implements SSLUtil.ProtocolIn
         byte[][] certificateChain = new byte[len][];
         try (var memorySession = MemorySession.openConfined()) {
             for (int i = 0; i < len; i++) {
-                MemoryAddress/*(X509*)*/ x509 = OPENSSL_sk_value(sk, i);
-                MemorySegment bufPointer = memorySession.allocate(ValueLayout.ADDRESS, MemoryAddress.NULL);
+                MemorySegment/*(X509*)*/ x509 = OPENSSL_sk_value(sk, i);
+                MemorySegment bufPointer = memorySession.allocate(ValueLayout.ADDRESS, MemorySegment.NULL);
                 int length = i2d_X509(x509, bufPointer);
                 if (length < 0) {
                     certificateChain[i] = new byte[0];
                     continue;
                 }
-                MemoryAddress buf = bufPointer.get(ValueLayout.ADDRESS, 0);
-                byte[] certificate = MemorySegment.ofAddress(buf, length, memorySession).toArray(ValueLayout.JAVA_BYTE);
+                MemorySegment buf = bufPointer.get(ValueLayout.ADDRESS, 0);
+                byte[] certificate = MemorySegment.ofAddress(buf.address(), length, memorySession).toArray(ValueLayout.JAVA_BYTE);
                 certificateChain[i] = certificate;
-                CRYPTO_free(buf, MemoryAddress.NULL, 0); // OPENSSL_free macro
+                CRYPTO_free(buf, MemorySegment.NULL, 0); // OPENSSL_free macro
             }
             return certificateChain;
         }
@@ -944,17 +943,17 @@ public final class OpenSSLEngine extends SSLEngine implements SSLUtil.ProtocolIn
     private String getProtocolNegotiated() {
         try (var memorySession = MemorySession.openConfined()) {
             MemorySegment lenAddress = memorySession.allocate(ValueLayout.JAVA_INT, 0);
-            MemorySegment protocolPointer = memorySession.allocate(ValueLayout.ADDRESS, MemoryAddress.NULL);
+            MemorySegment protocolPointer = memorySession.allocate(ValueLayout.ADDRESS, MemorySegment.NULL);
             SSL_get0_alpn_selected(state.ssl, protocolPointer, lenAddress);
-            if (MemoryAddress.NULL.equals(protocolPointer.address())) {
+            if (MemorySegment.NULL.equals(protocolPointer.address())) {
                 return null;
             }
             int length = lenAddress.get(ValueLayout.JAVA_INT, 0);
             if (length == 0) {
                 return null;
             }
-            MemoryAddress protocolAddress = protocolPointer.get(ValueLayout.ADDRESS, 0);
-            byte[] name = MemorySegment.ofAddress(protocolAddress, length, memorySession).toArray(ValueLayout.JAVA_BYTE);
+            MemorySegment protocolAddress = protocolPointer.get(ValueLayout.ADDRESS, 0);
+            byte[] name = MemorySegment.ofAddress(protocolAddress.address(), length, memorySession).toArray(ValueLayout.JAVA_BYTE);
             if (log.isDebugEnabled()) {
                 log.debug("Protocol negotiated [" + new String(name) + "]");
             }
@@ -1209,10 +1208,10 @@ public final class OpenSSLEngine extends SSLEngine implements SSLUtil.ProtocolIn
         }
     }
 
-    public static void openSSLCallbackInfo(MemoryAddress ssl, int where, int ret) {
+    public static void openSSLCallbackInfo(MemorySegment ssl, int where, int ret) {
         EngineState state = getState(ssl);
         if (state == null) {
-            log.warn(sm.getString("engine.noSSL", Long.valueOf(ssl.toRawLongValue())));
+            log.warn(sm.getString("engine.noSSL", Long.valueOf(ssl.address())));
             return;
         }
         if (0 != (where & SSL_CB_HANDSHAKE_DONE())) {
@@ -1220,11 +1219,11 @@ public final class OpenSSLEngine extends SSLEngine implements SSLUtil.ProtocolIn
         }
     }
 
-    public static int openSSLCallbackVerify(int preverify_ok, MemoryAddress /*X509_STORE_CTX*/ x509ctx) {
-        MemoryAddress ssl = X509_STORE_CTX_get_ex_data(x509ctx, SSL_get_ex_data_X509_STORE_CTX_idx());
+    public static int openSSLCallbackVerify(int preverify_ok, MemorySegment /*X509_STORE_CTX*/ x509ctx) {
+        MemorySegment ssl = X509_STORE_CTX_get_ex_data(x509ctx, SSL_get_ex_data_X509_STORE_CTX_idx());
         EngineState state = getState(ssl);
         if (state == null) {
-            log.warn(sm.getString("engine.noSSL", Long.valueOf(ssl.toRawLongValue())));
+            log.warn(sm.getString("engine.noSSL", Long.valueOf(ssl.address())));
             return 0;
         }
         if (log.isDebugEnabled()) {
@@ -1300,11 +1299,11 @@ public final class OpenSSLEngine extends SSLEngine implements SSLUtil.ProtocolIn
         return ok;
     }
 
-    static int processOCSP(MemoryAddress /*X509_STORE_CTX*/ x509ctx) {
+    static int processOCSP(MemorySegment /*X509_STORE_CTX*/ x509ctx) {
         int ocspResponse = V_OCSP_CERTSTATUS_UNKNOWN();
         // ocspResponse = ssl_verify_OCSP(x509_ctx);
-        MemoryAddress x509 = X509_STORE_CTX_get_current_cert(x509ctx);
-        if (!MemoryAddress.NULL.equals(x509)) {
+        MemorySegment x509 = X509_STORE_CTX_get_current_cert(x509ctx);
+        if (!MemorySegment.NULL.equals(x509)) {
             // No need to check cert->valid, because ssl_verify_OCSP() only
             // is called if OpenSSL already successfully verified the certificate
             // (parameter "ok" in SSL_callback_SSL_verify() must be true).
@@ -1313,18 +1312,18 @@ public final class OpenSSLEngine extends SSLEngine implements SSLUtil.ProtocolIn
                 X509_STORE_CTX_set_error(x509ctx, X509_V_OK());
             } else {
                 // If we can't get the issuer, we cannot perform OCSP verification
-                MemoryAddress issuer = X509_STORE_CTX_get0_current_issuer(x509ctx);
-                if (!MemoryAddress.NULL.equals(issuer)) {
+                MemorySegment issuer = X509_STORE_CTX_get0_current_issuer(x509ctx);
+                if (!MemorySegment.NULL.equals(issuer)) {
                     // sslutils.c ssl_ocsp_request(x509, issuer, x509ctx);
                     int nid = X509_get_ext_by_NID(x509, NID_info_access(), -1);
                     if (nid >= 0) {
                         try (var memorySession = MemorySession.openConfined()) {
-                            MemoryAddress ext = X509_get_ext(x509, nid);
-                            MemoryAddress os = X509_EXTENSION_get_data(ext);
+                            MemorySegment ext = X509_get_ext(x509, nid);
+                            MemorySegment os = X509_EXTENSION_get_data(ext);
                             int length = ASN1_STRING_length(os);
-                            MemoryAddress data = ASN1_STRING_get0_data(os);
+                            MemorySegment data = ASN1_STRING_get0_data(os);
                             // ocsp_urls = decode_OCSP_url(os);
-                            byte[] asn1String = MemorySegment.ofAddress(data, length, memorySession).toArray(ValueLayout.JAVA_BYTE);
+                            byte[] asn1String = MemorySegment.ofAddress(data.address(), length, memorySession).toArray(ValueLayout.JAVA_BYTE);
                             Asn1Parser parser = new Asn1Parser(asn1String);
                             // Parse the byte sequence
                             ArrayList<String> urls = new ArrayList<>();
@@ -1387,40 +1386,40 @@ public final class OpenSSLEngine extends SSLEngine implements SSLUtil.ProtocolIn
         }
     }
 
-    private static int processOCSPRequest(URL url, MemoryAddress issuer, MemoryAddress x509,
-            MemoryAddress /*X509_STORE_CTX*/ x509ctx, MemorySession memorySession) {
-        MemoryAddress ocspRequest = MemoryAddress.NULL;
-        MemoryAddress ocspResponse = MemoryAddress.NULL;
-        MemoryAddress id = MemoryAddress.NULL;
-        MemoryAddress ocspOneReq = MemoryAddress.NULL;
+    private static int processOCSPRequest(URL url, MemorySegment issuer, MemorySegment x509,
+            MemorySegment /*X509_STORE_CTX*/ x509ctx, MemorySession memorySession) {
+        MemorySegment ocspRequest = MemorySegment.NULL;
+        MemorySegment ocspResponse = MemorySegment.NULL;
+        MemorySegment id = MemorySegment.NULL;
+        MemorySegment ocspOneReq = MemorySegment.NULL;
         HttpURLConnection connection = null;
-        MemoryAddress basicResponse = MemoryAddress.NULL;
-        MemoryAddress certId = MemoryAddress.NULL;
+        MemorySegment basicResponse = MemorySegment.NULL;
+        MemorySegment certId = MemorySegment.NULL;
         try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
             ocspRequest = OCSP_REQUEST_new();
-            if (MemoryAddress.NULL.equals(ocspRequest)) {
+            if (MemorySegment.NULL.equals(ocspRequest)) {
                 return V_OCSP_CERTSTATUS_UNKNOWN();
             }
-            id = OCSP_cert_to_id(MemoryAddress.NULL, x509, issuer);
-            if (MemoryAddress.NULL.equals(id)) {
+            id = OCSP_cert_to_id(MemorySegment.NULL, x509, issuer);
+            if (MemorySegment.NULL.equals(id)) {
                 return V_OCSP_CERTSTATUS_UNKNOWN();
             }
             ocspOneReq = OCSP_request_add0_id(ocspRequest, id);
-            if (MemoryAddress.NULL.equals(ocspOneReq)) {
+            if (MemorySegment.NULL.equals(ocspOneReq)) {
                 return V_OCSP_CERTSTATUS_UNKNOWN();
             }
-            MemorySegment bufPointer = memorySession.allocate(ValueLayout.ADDRESS, MemoryAddress.NULL);
+            MemorySegment bufPointer = memorySession.allocate(ValueLayout.ADDRESS, MemorySegment.NULL);
             int requestLength = i2d_OCSP_REQUEST(ocspRequest, bufPointer);
             if (requestLength <= 0) {
                 return V_OCSP_CERTSTATUS_UNKNOWN();
             }
-            MemoryAddress buf = bufPointer.get(ValueLayout.ADDRESS, 0);
+            MemorySegment buf = bufPointer.get(ValueLayout.ADDRESS, 0);
             // HTTP request with the following header
             // POST urlPath HTTP/1.1
             // Host: urlHost:urlPort
             // Content-Type: application/ocsp-request
             // Content-Length: ocspRequestData.length
-            byte[] ocspRequestData = MemorySegment.ofAddress(buf, requestLength, memorySession).toArray(ValueLayout.JAVA_BYTE);
+            byte[] ocspRequestData = MemorySegment.ofAddress(buf.address(), requestLength, memorySession).toArray(ValueLayout.JAVA_BYTE);
             connection = (HttpURLConnection) url.openConnection();
             connection.setRequestMethod("POST");
             connection.setDoInput(true);
@@ -1442,24 +1441,24 @@ public final class OpenSSLEngine extends SSLEngine implements SSLUtil.ProtocolIn
             byte[] responseData = baos.toByteArray();
             var nativeResponseData = memorySession.allocateArray(ValueLayout.JAVA_BYTE, responseData);
             var nativeResponseDataPointer = memorySession.allocate(ValueLayout.ADDRESS, nativeResponseData);
-            ocspResponse = d2i_OCSP_RESPONSE(MemoryAddress.NULL, nativeResponseDataPointer, responseData.length);
-            if (!MemoryAddress.NULL.equals(ocspResponse)) {
+            ocspResponse = d2i_OCSP_RESPONSE(MemorySegment.NULL, nativeResponseDataPointer, responseData.length);
+            if (!MemorySegment.NULL.equals(ocspResponse)) {
                 if (OCSP_response_status(ocspResponse) == OCSP_RESPONSE_STATUS_SUCCESSFUL()) {
                     basicResponse = OCSP_response_get1_basic(ocspResponse);
-                    certId = OCSP_cert_to_id(MemoryAddress.NULL, x509, issuer);
-                    if (MemoryAddress.NULL.equals(certId)) {
+                    certId = OCSP_cert_to_id(MemorySegment.NULL, x509, issuer);
+                    if (MemorySegment.NULL.equals(certId)) {
                         return V_OCSP_CERTSTATUS_UNKNOWN();
                     }
                     // Find by serial number and get the matching response
-                    MemoryAddress singleResponse = OCSP_resp_get0(basicResponse, OCSP_resp_find(basicResponse, certId, -1));
-                    return OCSP_single_get0_status(singleResponse, MemoryAddress.NULL,
-                            MemoryAddress.NULL, MemoryAddress.NULL, MemoryAddress.NULL);
+                    MemorySegment singleResponse = OCSP_resp_get0(basicResponse, OCSP_resp_find(basicResponse, certId, -1));
+                    return OCSP_single_get0_status(singleResponse, MemorySegment.NULL,
+                            MemorySegment.NULL, MemorySegment.NULL, MemorySegment.NULL);
                 }
             }
         } catch (Exception e) {
             log.warn(sm.getString("engine.ocspRequestError", url.toString()), e);
         } finally {
-            if (MemoryAddress.NULL.equals(ocspResponse)) {
+            if (MemorySegment.NULL.equals(ocspResponse)) {
                 // Failed to get a valid response
                 X509_STORE_CTX_set_error(x509ctx, X509_V_ERR_APPLICATION_VERIFICATION());
             }
@@ -1504,13 +1503,13 @@ public final class OpenSSLEngine extends SSLEngine implements SSLUtil.ProtocolIn
                     try (var memorySession = MemorySession.openConfined()) {
                         MemorySegment lenPointer = memorySession.allocate(ValueLayout.ADDRESS);
                         var session = SSL_get_session(state.ssl);
-                        if (MemoryAddress.NULL.equals(session)) {
+                        if (MemorySegment.NULL.equals(session)) {
                             return new byte[0];
                         }
-                        MemoryAddress sessionId = SSL_SESSION_get_id(session, lenPointer);
+                        MemorySegment sessionId = SSL_SESSION_get_id(session, lenPointer);
                         int len = lenPointer.get(ValueLayout.JAVA_INT, 0);
                         id = (len == 0) ? new byte[0]
-                                : MemorySegment.ofAddress(sessionId, len, memorySession).toArray(ValueLayout.JAVA_BYTE);
+                                : MemorySegment.ofAddress(sessionId.address(), len, memorySession).toArray(ValueLayout.JAVA_BYTE);
                     }
                 }
             }
@@ -1530,7 +1529,7 @@ public final class OpenSSLEngine extends SSLEngine implements SSLUtil.ProtocolIn
             synchronized (OpenSSLEngine.this) {
                 if (!destroyed) {
                     var session = SSL_get_session(state.ssl);
-                    if (!MemoryAddress.NULL.equals(session)) {
+                    if (!MemorySegment.NULL.equals(session)) {
                         creationTime = SSL_SESSION_get_time(session);
                     }
                 }
@@ -1802,12 +1801,12 @@ public final class OpenSSLEngine extends SSLEngine implements SSLUtil.ProtocolIn
         private int certificateVerifyMode = 0;
         private int handshakeCount = 0;
 
-        private EngineState(MemoryAddress ssl, MemoryAddress networkBIO,
+        private EngineState(MemorySegment ssl, MemorySegment networkBIO,
                 int certificateVerificationDepth, boolean noOcspCheck) {
-            states.put(Long.valueOf(ssl.toRawLongValue()), this);
+            states.put(Long.valueOf(ssl.address()), this);
             // Allocate another session to avoid keeping a reference through segments
-            this.ssl = MemorySegment.ofAddress(ssl, ValueLayout.ADDRESS.byteSize(), stateSession);
-            this.networkBIO = MemorySegment.ofAddress(networkBIO, ValueLayout.ADDRESS.byteSize(), stateSession);
+            this.ssl = MemorySegment.ofAddress(ssl.address(), ValueLayout.ADDRESS.byteSize(), stateSession);
+            this.networkBIO = MemorySegment.ofAddress(networkBIO.address(), ValueLayout.ADDRESS.byteSize(), stateSession);
             this.certificateVerificationDepth = certificateVerificationDepth;
             this.noOcspCheck = noOcspCheck;
         }
@@ -1815,7 +1814,7 @@ public final class OpenSSLEngine extends SSLEngine implements SSLUtil.ProtocolIn
         @Override
         public void run() {
             try {
-                states.remove(Long.valueOf(ssl.address().toRawLongValue()));
+                states.remove(Long.valueOf(ssl.address()));
                 BIO_free(networkBIO);
                 SSL_free(ssl);
             } finally {

==================================================
OpenSSLSessionStats.java
index f65c459d71..98d6c527c4 100644
--- a/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/net/openssl/panama/OpenSSLLifecycleListener.java
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/net/openssl/panama/OpenSSLLifecycleListener.java
@@ -21,8 +21,8 @@ import static org.apache.tomcat.util.openssl.openssl_compat_h.FIPS_mode;
 import static org.apache.tomcat.util.openssl.openssl_compat_h.FIPS_mode_set;
 import static org.apache.tomcat.util.openssl.openssl_h.*;
 
-import java.lang.foreign.MemoryAddress;
 import java.lang.foreign.MemorySession;
+import java.lang.foreign.MemorySegment;
 import java.lang.foreign.ValueLayout;
 import java.security.SecureRandom;
 
@@ -136,14 +136,14 @@ public class OpenSSLLifecycleListener implements LifecycleListener {
 
     }
 
-    static MemoryAddress enginePointer = MemoryAddress.NULL;
+    static MemorySegment enginePointer = MemorySegment.NULL;
 
     static void initLibrary() {
         synchronized (lock) {
             if (OpenSSLStatus.isLibraryInitialized()) {
                 return;
             }
-            OPENSSL_init_ssl(OPENSSL_INIT_ENGINE_ALL_BUILTIN(), MemoryAddress.NULL);
+            OPENSSL_init_ssl(OPENSSL_INIT_ENGINE_ALL_BUILTIN(), MemorySegment.NULL);
             OpenSSLStatus.setLibraryInitialized(true);
         }
     }
@@ -157,9 +157,9 @@ public class OpenSSLLifecycleListener implements LifecycleListener {
     { BN_get_rfc2409_prime_1024, NULL, 0 }
      */
     static final class DHParam {
-        final MemoryAddress dh;
+        final MemorySegment dh;
         final int min;
-        private DHParam(MemoryAddress dh, int min) {
+        private DHParam(MemorySegment dh, int min) {
             this.dh = dh;
             this.min = min;
         }
@@ -168,48 +168,48 @@ public class OpenSSLLifecycleListener implements LifecycleListener {
 
     private static void initDHParameters() {
         var dh = DH_new();
-        var p = BN_get_rfc3526_prime_8192(MemoryAddress.NULL);
+        var p = BN_get_rfc3526_prime_8192(MemorySegment.NULL);
         var g = BN_new();
         BN_set_word(g, 2);
-        DH_set0_pqg(dh, p, MemoryAddress.NULL, g);
+        DH_set0_pqg(dh, p, MemorySegment.NULL, g);
         dhParameters[0] = new DHParam(dh, 6145);
         dh = DH_new();
-        p = BN_get_rfc3526_prime_6144(MemoryAddress.NULL);
+        p = BN_get_rfc3526_prime_6144(MemorySegment.NULL);
         g = BN_new();
         BN_set_word(g, 2);
-        DH_set0_pqg(dh, p, MemoryAddress.NULL, g);
+        DH_set0_pqg(dh, p, MemorySegment.NULL, g);
         dhParameters[1] = new DHParam(dh, 4097);
         dh = DH_new();
-        p = BN_get_rfc3526_prime_4096(MemoryAddress.NULL);
+        p = BN_get_rfc3526_prime_4096(MemorySegment.NULL);
         g = BN_new();
         BN_set_word(g, 2);
-        DH_set0_pqg(dh, p, MemoryAddress.NULL, g);
+        DH_set0_pqg(dh, p, MemorySegment.NULL, g);
         dhParameters[2] = new DHParam(dh, 3073);
         dh = DH_new();
-        p = BN_get_rfc3526_prime_3072(MemoryAddress.NULL);
+        p = BN_get_rfc3526_prime_3072(MemorySegment.NULL);
         g = BN_new();
         BN_set_word(g, 2);
-        DH_set0_pqg(dh, p, MemoryAddress.NULL, g);
+        DH_set0_pqg(dh, p, MemorySegment.NULL, g);
         dhParameters[3] = new DHParam(dh, 2049);
         dh = DH_new();
-        p = BN_get_rfc3526_prime_2048(MemoryAddress.NULL);
+        p = BN_get_rfc3526_prime_2048(MemorySegment.NULL);
         g = BN_new();
         BN_set_word(g, 2);
-        DH_set0_pqg(dh, p, MemoryAddress.NULL, g);
+        DH_set0_pqg(dh, p, MemorySegment.NULL, g);
         dhParameters[4] = new DHParam(dh, 1025);
         dh = DH_new();
-        p = BN_get_rfc2409_prime_1024(MemoryAddress.NULL);
+        p = BN_get_rfc2409_prime_1024(MemorySegment.NULL);
         g = BN_new();
         BN_set_word(g, 2);
-        DH_set0_pqg(dh, p, MemoryAddress.NULL, g);
+        DH_set0_pqg(dh, p, MemorySegment.NULL, g);
         dhParameters[5] = new DHParam(dh, 0);
     }
 
     private static void freeDHParameters() {
         for (int i = 0; i < dhParameters.length; i++) {
             if (dhParameters[i] != null) {
-                MemoryAddress dh = dhParameters[i].dh;
-                if (dh != null && !MemoryAddress.NULL.equals(dh)) {
+                MemorySegment dh = dhParameters[i].dh;
+                if (dh != null && !MemorySegment.NULL.equals(dh)) {
                     DH_free(dh);
                     dhParameters[i] = null;
                 }
@@ -242,26 +242,26 @@ public class OpenSSLLifecycleListener implements LifecycleListener {
                     } else {
                         var engine = memorySession.allocateUtf8String(engineName);
                         enginePointer = ENGINE_by_id(engine);
-                        if (MemoryAddress.NULL.equals(enginePointer)) {
+                        if (MemorySegment.NULL.equals(enginePointer)) {
                             enginePointer = ENGINE_by_id(memorySession.allocateUtf8String("dynamic"));
                             if (enginePointer != null) {
                                 if (ENGINE_ctrl_cmd_string(enginePointer, memorySession.allocateUtf8String("SO_PATH"), engine, 0) == 0
                                         || ENGINE_ctrl_cmd_string(enginePointer, memorySession.allocateUtf8String("LOAD"),
-                                                MemoryAddress.NULL, 0) == 0) {
+                                                MemorySegment.NULL, 0) == 0) {
                                     // Engine load error
                                     ENGINE_free(enginePointer);
-                                    enginePointer = MemoryAddress.NULL;
+                                    enginePointer = MemorySegment.NULL;
                                 }
                             }
                         }
-                        if (!MemoryAddress.NULL.equals(enginePointer)) {
+                        if (!MemorySegment.NULL.equals(enginePointer)) {
                             if (ENGINE_set_default(enginePointer, ENGINE_METHOD_ALL()) == 0) {
                                 // Engine load error
                                 ENGINE_free(enginePointer);
-                                enginePointer = MemoryAddress.NULL;
+                                enginePointer = MemorySegment.NULL;
                             }
                         }
-                        if (MemoryAddress.NULL.equals(enginePointer)) {
+                        if (MemorySegment.NULL.equals(enginePointer)) {
                             throw new IllegalStateException(sm.getString("listener.engineError"));
                         }
                     }
@@ -290,7 +290,7 @@ public class OpenSSLLifecycleListener implements LifecycleListener {
                     final boolean enterFipsMode;
                     int fipsModeState = FIPS_OFF;
                     if (usingProviders) {
-                        var md = EVP_MD_fetch(MemoryAddress.NULL, memorySession.allocateUtf8String("SHA-512"), MemoryAddress.NULL);
+                        var md = EVP_MD_fetch(MemorySegment.NULL, memorySession.allocateUtf8String("SHA-512"), MemorySegment.NULL);
                         var provider = EVP_MD_get0_provider(md);
                         String name = OSSL_PROVIDER_get0_name(provider).getUtf8String(0);
                         EVP_MD_free(md);
@@ -392,7 +392,7 @@ public class OpenSSLLifecycleListener implements LifecycleListener {
 
             try {
                 freeDHParameters();
-                if (!MemoryAddress.NULL.equals(enginePointer)) {
+                if (!MemorySegment.NULL.equals(enginePointer)) {
                     ENGINE_free(enginePointer);
                 }
                 FIPS_mode_set(0);

==================================================
Constants$root.java
index 4ef51983b0..cfc18ce802 100644
--- a/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/net/openssl/panama/OpenSSLSessionStats.java
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/net/openssl/panama/OpenSSLSessionStats.java
@@ -18,7 +18,7 @@ package org.apache.tomcat.util.net.openssl.panama;
 
 import static org.apache.tomcat.util.openssl.openssl_h.*;
 
-import java.lang.foreign.MemoryAddress;
+import java.lang.foreign.MemorySegment;
 
 /**
  * Stats exposed by an OpenSSL session context.
@@ -27,9 +27,9 @@ import java.lang.foreign.MemoryAddress;
  */
 public final class OpenSSLSessionStats {
 
-    private final MemoryAddress ctx;
+    private final MemorySegment ctx;
 
-    OpenSSLSessionStats(MemoryAddress ctx) {
+    OpenSSLSessionStats(MemorySegment ctx) {
         this.ctx = ctx;
     }
 

==================================================
RuntimeHelper.java
index 54a6564276..801356956d 100644
--- a/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/Constants$root.java
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/Constants$root.java
@@ -34,7 +34,7 @@ public class Constants$root {
     static final  OfLong C_LONG_LONG$LAYOUT = JAVA_LONG.withBitAlignment(64);
     static final  OfFloat C_FLOAT$LAYOUT = JAVA_FLOAT.withBitAlignment(32);
     static final  OfDouble C_DOUBLE$LAYOUT = JAVA_DOUBLE.withBitAlignment(64);
-    static final  OfAddress C_POINTER$LAYOUT = ADDRESS.withBitAlignment(64);
+    static final  OfAddress C_POINTER$LAYOUT = ADDRESS.withBitAlignment(64).asUnbounded();
 }
 
 

==================================================
SSL_CTX_set_cert_verify_callback$cb.java
index 1e251b1129..e6af7c8fb3 100644
--- a/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/RuntimeHelper.java
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/RuntimeHelper.java
@@ -18,12 +18,10 @@
 package org.apache.tomcat.util.openssl;
 // Generated by jextract
 
-import java.lang.foreign.Addressable;
 import java.lang.foreign.Linker;
 import java.lang.foreign.FunctionDescriptor;
 import java.lang.foreign.GroupLayout;
 import java.lang.foreign.SymbolLookup;
-import java.lang.foreign.MemoryAddress;
 import java.lang.foreign.MemoryLayout;
 import java.lang.foreign.MemorySegment;
 import java.lang.foreign.MemorySession;
@@ -51,12 +49,12 @@ final class RuntimeHelper {
     private final static SymbolLookup SYMBOL_LOOKUP;
 
     final static SegmentAllocator CONSTANT_ALLOCATOR =
-            (size, align) -> MemorySegment.allocateNative(size, align, MemorySession.openImplicit());
+            (size, align) -> MemorySegment.allocateNative(size, align);
 
     static {
         System.loadLibrary("ssl");
         SymbolLookup loaderLookup = SymbolLookup.loaderLookup();
-        SYMBOL_LOOKUP = name -> loaderLookup.lookup(name).or(() -> LINKER.defaultLookup().lookup(name));
+        SYMBOL_LOOKUP = name -> loaderLookup.find(name).or(() -> LINKER.defaultLookup().find(name));
     }
 
     static <T> T requireNonNull(T obj, String symbolName) {
@@ -69,11 +67,11 @@ final class RuntimeHelper {
     private final static SegmentAllocator THROWING_ALLOCATOR = (x, y) -> { throw new AssertionError("should not reach here"); };
 
     static final MemorySegment lookupGlobalVariable(String name, MemoryLayout layout) {
-        return SYMBOL_LOOKUP.lookup(name).map(symbol -> MemorySegment.ofAddress(symbol.address(), layout.byteSize(), MemorySession.openShared())).orElse(null);
+        return SYMBOL_LOOKUP.find(name).map(symbol -> MemorySegment.ofAddress(symbol.address(), layout.byteSize(), symbol.session())).orElse(null);
     }
 
     static final MethodHandle downcallHandle(String name, FunctionDescriptor fdesc) {
-        return SYMBOL_LOOKUP.lookup(name).
+        return SYMBOL_LOOKUP.find(name).
                 map(addr -> LINKER.downcallHandle(addr, fdesc)).
                 orElse(null);
     }
@@ -83,14 +81,14 @@ final class RuntimeHelper {
     }
 
     static final MethodHandle downcallHandleVariadic(String name, FunctionDescriptor fdesc) {
-        return SYMBOL_LOOKUP.lookup(name).
+        return SYMBOL_LOOKUP.find(name).
                 map(addr -> VarargsInvoker.make(addr, fdesc)).
                 orElse(null);
     }
 
     static final <Z> MemorySegment upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, MemorySession session) {
         try {
-            MethodHandle handle = MH_LOOKUP.findVirtual(fi, "apply", Linker.upcallType(fdesc));
+            MethodHandle handle = MH_LOOKUP.findVirtual(fi, "apply", fdesc.toMethodType());
             handle = handle.bindTo(z);
             return LINKER.upcallStub(handle, fdesc, session);
         } catch (Throwable ex) {
@@ -98,8 +96,8 @@ final class RuntimeHelper {
         }
     }
 
-    static MemorySegment asArray(MemoryAddress addr, MemoryLayout layout, int numElements, MemorySession session) {
-         return MemorySegment.ofAddress(addr, numElements * layout.byteSize(), session);
+    static MemorySegment asArray(MemorySegment addr, MemoryLayout layout, int numElements, MemorySession session) {
+         return MemorySegment.ofAddress(addr.address(), numElements * layout.byteSize(), session);
     }
 
     // Internals only below this point
@@ -130,7 +128,9 @@ final class RuntimeHelper {
                 mtype = mtype.appendParameterTypes(carrier(layout, false));
             }
             mtype = mtype.appendParameterTypes(Object[].class);
-            if (mtype.returnType().equals(MemorySegment.class)) {
+            boolean needsAllocator = function.returnLayout().isPresent() &&
+                                function.returnLayout().get() instanceof GroupLayout;
+            if (needsAllocator) {
                 mtype = mtype.insertParameterTypes(0, SegmentAllocator.class);
             } else {
                 handle = MethodHandles.insertArguments(handle, 0, THROWING_ALLOCATOR);
@@ -140,8 +140,7 @@ final class RuntimeHelper {
 
         static Class<?> carrier(MemoryLayout layout, boolean ret) {
             if (layout instanceof ValueLayout valueLayout) {
-                return (ret || valueLayout.carrier() != MemoryAddress.class) ?
-                        valueLayout.carrier() : Addressable.class;
+                return valueLayout.carrier();
             } else if (layout instanceof GroupLayout) {
                 return MemorySegment.class;
             } else {
@@ -176,7 +175,9 @@ final class RuntimeHelper {
                     FunctionDescriptor.ofVoid(argLayouts) :
                     FunctionDescriptor.of(function.returnLayout().get(), argLayouts);
             MethodHandle mh = LINKER.downcallHandle(symbol, f);
-            if (mh.type().returnType() == MemorySegment.class) {
+            boolean needsAllocator = function.returnLayout().isPresent() &&
+                                            function.returnLayout().get() instanceof GroupLayout;
+            if (needsAllocator) {
                 mh = mh.bindTo(allocator);
             }
             // flatten argument list so that it can be passed to an asSpreader MH
@@ -226,10 +227,7 @@ final class RuntimeHelper {
             if (c.isPrimitive()) {
                 return promote(c);
             }
-            if (MemoryAddress.class.isAssignableFrom(c)) {
-                return MemoryAddress.class;
-            }
-            if (MemorySegment.class.isAssignableFrom(c)) {
+            if (c == MemorySegment.class) {
                 return MemorySegment.class;
             }
             throw new IllegalArgumentException("Invalid type for ABI: " + c.getTypeName());
@@ -240,7 +238,7 @@ final class RuntimeHelper {
                 return JAVA_LONG;
             } else if (c == double.class) {
                 return JAVA_DOUBLE;
-            } else if (MemoryAddress.class.isAssignableFrom(c)) {
+            } else if (c == MemorySegment.class) {
                 return ADDRESS;
             } else {
                 throw new IllegalArgumentException("Unhandled variadic argument class: " + c);

==================================================
SSL_CTX_set_tmp_dh_callback$dh.java
index 43210cfc8b..c45dc449a7 100644
--- a/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/SSL_CTX_set_cert_verify_callback$cb.java
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/SSL_CTX_set_cert_verify_callback$cb.java
@@ -26,15 +26,15 @@ import java.lang.foreign.*;
 import static java.lang.foreign.ValueLayout.*;
 public interface SSL_CTX_set_cert_verify_callback$cb {
 
-    int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
+    int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
     static MemorySegment allocate(SSL_CTX_set_cert_verify_callback$cb fi, MemorySession session) {
         return RuntimeHelper.upcallStub(SSL_CTX_set_cert_verify_callback$cb.class, fi, constants$15.SSL_CTX_set_cert_verify_callback$cb$FUNC, session);
     }
-    static SSL_CTX_set_cert_verify_callback$cb ofAddress(MemoryAddress addr, MemorySession session) {
-        MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
-        return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
+    static SSL_CTX_set_cert_verify_callback$cb ofAddress(MemorySegment addr, MemorySession session) {
+        MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, session);
+        return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
             try {
-                return (int)constants$15.SSL_CTX_set_cert_verify_callback$cb$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
+                return (int)constants$15.SSL_CTX_set_cert_verify_callback$cb$MH.invokeExact((MemorySegment)symbol, __x0, __x1);
             } catch (Throwable ex$) {
                 throw new AssertionError("should not reach here", ex$);
             }

==================================================
SSL_set_info_callback$cb.java
index cb91c18667..431dfe320a 100644
--- a/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/SSL_CTX_set_tmp_dh_callback$dh.java
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/SSL_CTX_set_tmp_dh_callback$dh.java
@@ -26,15 +26,15 @@ import java.lang.foreign.*;
 import static java.lang.foreign.ValueLayout.*;
 public interface SSL_CTX_set_tmp_dh_callback$dh {
 
-    java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, int _x1, int _x2);
+    java.lang.foreign.MemorySegment apply(java.lang.foreign.MemorySegment _x0, int _x1, int _x2);
     static MemorySegment allocate(SSL_CTX_set_tmp_dh_callback$dh fi, MemorySession session) {
         return RuntimeHelper.upcallStub(SSL_CTX_set_tmp_dh_callback$dh.class, fi, constants$21.SSL_CTX_set_tmp_dh_callback$dh$FUNC, session);
     }
-    static SSL_CTX_set_tmp_dh_callback$dh ofAddress(MemoryAddress addr, MemorySession session) {
-        MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
-        return (java.lang.foreign.MemoryAddress __x0, int __x1, int __x2) -> {
+    static SSL_CTX_set_tmp_dh_callback$dh ofAddress(MemorySegment addr, MemorySession session) {
+        MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, session);
+        return (java.lang.foreign.MemorySegment __x0, int __x1, int __x2) -> {
             try {
-                return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)constants$22.SSL_CTX_set_tmp_dh_callback$dh$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, __x2);
+                return (java.lang.foreign.MemorySegment)constants$22.SSL_CTX_set_tmp_dh_callback$dh$MH.invokeExact((MemorySegment)symbol, __x0, __x1, __x2);
             } catch (Throwable ex$) {
                 throw new AssertionError("should not reach here", ex$);
             }

==================================================
constants$29.java
index 7e472ef297..d1a2fdb57f 100644
--- a/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/SSL_set_info_callback$cb.java
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/SSL_set_info_callback$cb.java
@@ -26,15 +26,15 @@ import java.lang.foreign.*;
 import static java.lang.foreign.ValueLayout.*;
 public interface SSL_set_info_callback$cb {
 
-    void apply(java.lang.foreign.MemoryAddress _x0, int _x1, int _x2);
+    void apply(java.lang.foreign.MemorySegment _x0, int _x1, int _x2);
     static MemorySegment allocate(SSL_set_info_callback$cb fi, MemorySession session) {
         return RuntimeHelper.upcallStub(SSL_set_info_callback$cb.class, fi, constants$21.SSL_set_info_callback$cb$FUNC, session);
     }
-    static SSL_set_info_callback$cb ofAddress(MemoryAddress addr, MemorySession session) {
-        MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
-        return (java.lang.foreign.MemoryAddress __x0, int __x1, int __x2) -> {
+    static SSL_set_info_callback$cb ofAddress(MemorySegment addr, MemorySession session) {
+        MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, session);
+        return (java.lang.foreign.MemorySegment __x0, int __x1, int __x2) -> {
             try {
-                constants$21.SSL_set_info_callback$cb$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, __x2);
+                constants$21.SSL_set_info_callback$cb$MH.invokeExact((MemorySegment)symbol, __x0, __x1, __x2);
             } catch (Throwable ex$) {
                 throw new AssertionError("should not reach here", ex$);
             }

==================================================
openssl_compat_h.java
index 0484c297ec..175593e7f6 100644
--- a/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$29.java
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$29.java
@@ -26,7 +26,7 @@ import java.lang.foreign.*;
 import static java.lang.foreign.ValueLayout.*;
 class constants$29 {
 
-    static final MemorySegment OPENSSL_FILE$SEGMENT = RuntimeHelper.CONSTANT_ALLOCATOR.allocateUtf8String("/tmp/jextract$17092896582695808251.h");
+    static final MemorySegment OPENSSL_FILE$SEGMENT = RuntimeHelper.CONSTANT_ALLOCATOR.allocateUtf8String("/tmp/jextract$7309346795930420663.h");
 }
 
 

==================================================
openssl_h.java
index 563820cd4e..499a15c77e 100644
--- a/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/openssl_compat_h.java
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/openssl_compat_h.java
@@ -70,7 +70,7 @@ public class openssl_compat_h  {
         return RuntimeHelper.requireNonNull(EVP_PKEY_base_id$MH,
                 "EVP_PKEY_base_id");
     }
-    public static int EVP_PKEY_base_id(Addressable pkey) {
+    public static int EVP_PKEY_base_id(MemorySegment pkey) {
         var mh$ = EVP_PKEY_base_id$MH();
         try {
             return (int) mh$.invokeExact(pkey);
@@ -87,7 +87,7 @@ public class openssl_compat_h  {
     public static MethodHandle EVP_PKEY_bits$MH() {
         return RuntimeHelper.requireNonNull(EVP_PKEY_bits$MH, "EVP_PKEY_bits");
     }
-    public static int EVP_PKEY_bits(Addressable pkey) {
+    public static int EVP_PKEY_bits(MemorySegment pkey) {
         var mh$ = EVP_PKEY_bits$MH();
         try {
             return (int) mh$.invokeExact(pkey);
@@ -107,10 +107,10 @@ public class openssl_compat_h  {
         return RuntimeHelper.requireNonNull(SSL_get_peer_certificate$MH,
                 "SSL_get_peer_certificate");
     }
-    public static MemoryAddress SSL_get_peer_certificate(Addressable s) {
+    public static MemorySegment SSL_get_peer_certificate(MemorySegment s) {
         var mh$ = SSL_get_peer_certificate$MH();
         try {
-            return (java.lang.foreign.MemoryAddress) mh$.invokeExact(s);
+            return (java.lang.foreign.MemorySegment) mh$.invokeExact(s);
         } catch (Throwable ex$) {
             throw new AssertionError("should not reach here", ex$);
         }

==================================================
