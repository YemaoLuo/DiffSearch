f9884366b9ed9273c8faf74502c1ef2d64c19b47
==================================================
More code cleanups
==================================================
remm remm@apache.org
==================================================
Fri Apr 19 17:59:12 2019 +0200
==================================================
NioBlockingSelector.java
More code cleanups

No real change. Add an attribute to eventually replace a system property
(the system property still sets the default value). Remove unused block
parameter. Fix a lot of legacy code formatting.


==================================================
NioEndpoint.java
index 252bf0ec18..d723c7abe8 100644
--- a/java/org/apache/tomcat/util/net/NioBlockingSelector.java
+++ b/java/org/apache/tomcat/util/net/NioBlockingSelector.java
@@ -49,9 +49,6 @@ public class NioBlockingSelector {
     protected Selector sharedSelector;
 
     protected BlockPoller poller;
-    public NioBlockingSelector() {
-
-    }
 
     public void open(String name, Selector selector) {
         sharedSelector = selector;
@@ -63,7 +60,7 @@ public class NioBlockingSelector {
     }
 
     public void close() {
-        if (poller!=null) {
+        if (poller != null) {
             poller.disable();
             poller.interrupt();
             poller = null;
@@ -71,13 +68,14 @@ public class NioBlockingSelector {
     }
 
     /**
-     * Performs a blocking write using the bytebuffer for data to be written
+     * Performs a blocking write using the byte buffer for data to be written
      * If the <code>selector</code> parameter is null, then it will perform a busy write that could
      * take up a lot of CPU cycles.
+     *
      * @param buf ByteBuffer - the buffer containing the data, we will write as long as <code>(buf.hasRemaining()==true)</code>
      * @param socket SocketChannel - the socket to write data to
      * @param writeTimeout long - the timeout for this write operation in milliseconds, -1 means no timeout
-     * @return int - returns the number of bytes written
+     * @return the number of bytes written
      * @throws EOFException if write returns -1
      * @throws SocketTimeoutException if the write times out
      * @throws IOException if an IO Exception occurs in the underlying socket logic
@@ -98,11 +96,12 @@ public class NioBlockingSelector {
         int keycount = 1; //assume we can write
         long time = System.currentTimeMillis(); //start the timeout timer
         try {
-            while ( (!timedout) && buf.hasRemaining()) {
+            while (!timedout && buf.hasRemaining()) {
                 if (keycount > 0) { //only write if we were registered for a write
                     int cnt = socket.write(buf); //write the data
-                    if (cnt == -1)
+                    if (cnt == -1) {
                         throw new EOFException();
+                    }
                     written += cnt;
                     if (cnt > 0) {
                         time = System.currentTimeMillis(); //reset our timeout timer
@@ -110,29 +109,33 @@ public class NioBlockingSelector {
                     }
                 }
                 try {
-                    if ( att.getWriteLatch()==null || att.getWriteLatch().getCount()==0) att.startWriteLatch(1);
-                    poller.add(att,SelectionKey.OP_WRITE,reference);
-                    att.awaitWriteLatch(AbstractEndpoint.toTimeout(writeTimeout),TimeUnit.MILLISECONDS);
+                    if (att.getWriteLatch() == null || att.getWriteLatch().getCount() == 0) {
+                        att.startWriteLatch(1);
+                    }
+                    poller.add(att, SelectionKey.OP_WRITE, reference);
+                    att.awaitWriteLatch(AbstractEndpoint.toTimeout(writeTimeout), TimeUnit.MILLISECONDS);
                 } catch (InterruptedException ignore) {
                     // Ignore
                 }
-                if ( att.getWriteLatch()!=null && att.getWriteLatch().getCount()> 0) {
+                if (att.getWriteLatch() != null && att.getWriteLatch().getCount() > 0) {
                     //we got interrupted, but we haven't received notification from the poller.
                     keycount = 0;
-                }else {
+                } else {
                     //latch countdown has happened
                     keycount = 1;
                     att.resetWriteLatch();
                 }
 
-                if (writeTimeout > 0 && (keycount == 0))
+                if (writeTimeout > 0 && (keycount == 0)) {
                     timedout = (System.currentTimeMillis() - time) >= writeTimeout;
-            } //while
-            if (timedout)
+                }
+            }
+            if (timedout) {
                 throw new SocketTimeoutException();
+            }
         } finally {
-            poller.remove(att,SelectionKey.OP_WRITE);
-            if (timedout && reference.key!=null) {
+            poller.remove(att, SelectionKey.OP_WRITE);
+            if (timedout && reference.key != null) {
                 poller.cancelKey(reference.key);
             }
             reference.key = null;
@@ -145,10 +148,11 @@ public class NioBlockingSelector {
      * Performs a blocking read using the bytebuffer for data to be read
      * If the <code>selector</code> parameter is null, then it will perform a busy read that could
      * take up a lot of CPU cycles.
+     *
      * @param buf ByteBuffer - the buffer containing the data, we will read as until we have read at least one byte or we timed out
      * @param socket SocketChannel - the socket to write data to
      * @param readTimeout long - the timeout for this read operation in milliseconds, -1 means no timeout
-     * @return int - returns the number of bytes read
+     * @return the number of bytes read
      * @throws EOFException if read returns -1
      * @throws SocketTimeoutException if the read times out
      * @throws IOException if an IO Exception occurs in the underlying socket logic
@@ -168,7 +172,7 @@ public class NioBlockingSelector {
         int keycount = 1; //assume we can read
         long time = System.currentTimeMillis(); //start the timeout timer
         try {
-            while(!timedout) {
+            while (!timedout) {
                 if (keycount > 0) { //only read if we were registered for a read
                     read = socket.read(buf);
                     if (read != 0) {
@@ -176,7 +180,9 @@ public class NioBlockingSelector {
                     }
                 }
                 try {
-                    if ( att.getReadLatch()==null || att.getReadLatch().getCount()==0) att.startReadLatch(1);
+                    if (att.getReadLatch()==null || att.getReadLatch().getCount()==0) {
+                        att.startReadLatch(1);
+                    }
                     poller.add(att,SelectionKey.OP_READ, reference);
                     att.awaitReadLatch(AbstractEndpoint.toTimeout(readTimeout), TimeUnit.MILLISECONDS);
                 } catch (InterruptedException ignore) {
@@ -190,14 +196,16 @@ public class NioBlockingSelector {
                     keycount = 1;
                     att.resetReadLatch();
                 }
-                if (readTimeout >= 0 && (keycount == 0))
+                if (readTimeout >= 0 && (keycount == 0)) {
                     timedout = (System.currentTimeMillis() - time) >= readTimeout;
-            } //while
-            if (timedout)
+                }
+            }
+            if (timedout) {
                 throw new SocketTimeoutException();
+            }
         } finally {
             poller.remove(att,SelectionKey.OP_READ);
-            if (timedout && reference.key!=null) {
+            if (timedout && reference.key != null) {
                 poller.cancelKey(reference.key);
             }
             reference.key = null;
@@ -211,7 +219,10 @@ public class NioBlockingSelector {
         protected volatile boolean run = true;
         protected Selector selector = null;
         protected final SynchronizedQueue<Runnable> events = new SynchronizedQueue<>();
-        public void disable() { run = false; selector.wakeup();}
+        public void disable() {
+            run = false;
+            selector.wakeup();
+        }
         protected final AtomicInteger wakeupCounter = new AtomicInteger(0);
 
         public void cancelKey(final SelectionKey key) {
@@ -225,31 +236,41 @@ public class NioBlockingSelector {
         }
 
         public void cancel(SelectionKey sk, NioSocketWrapper key, int ops){
-            if (sk!=null) {
+            if (sk != null) {
                 sk.cancel();
                 sk.attach(null);
-                if (SelectionKey.OP_WRITE==(ops&SelectionKey.OP_WRITE)) countDown(key.getWriteLatch());
-                if (SelectionKey.OP_READ==(ops&SelectionKey.OP_READ))countDown(key.getReadLatch());
+                if (SelectionKey.OP_WRITE == (ops & SelectionKey.OP_WRITE)) {
+                    countDown(key.getWriteLatch());
+                }
+                if (SelectionKey.OP_READ == (ops & SelectionKey.OP_READ)) {
+                    countDown(key.getReadLatch());
+                }
             }
         }
 
         public void add(final NioSocketWrapper key, final int ops, final KeyReference ref) {
-            if ( key == null ) return;
+            if (key == null) {
+                return;
+            }
             NioChannel nch = key.getSocket();
             final SocketChannel ch = nch.getIOChannel();
-            if ( ch == null ) return;
-
+            if (ch == null) {
+                return;
+            }
             Runnable r = new RunnableAdd(ch, key, ops, ref);
             events.offer(r);
             wakeup();
         }
 
         public void remove(final NioSocketWrapper key, final int ops) {
-            if ( key == null ) return;
+            if (key == null) {
+                return;
+            }
             NioChannel nch = key.getSocket();
             final SocketChannel ch = nch.getIOChannel();
-            if ( ch == null ) return;
-
+            if (ch == null) {
+                return;
+            }
             Runnable r = new RunnableRemove(ch, key, ops);
             events.offer(r);
             wakeup();
@@ -257,7 +278,6 @@ public class NioBlockingSelector {
 
         public boolean events() {
             Runnable r = null;
-
             /* We only poll and run the runnable events when we start this
              * method. Further events added to the queue later will be delayed
              * to the next execution of this method.
@@ -275,7 +295,6 @@ public class NioBlockingSelector {
             for (int i = 0; i < size && (r = events.poll()) != null; i++) {
                 r.run();
             }
-
             return (size > 0);
         }
 
@@ -287,22 +306,30 @@ public class NioBlockingSelector {
                     int keyCount = 0;
                     try {
                         int i = wakeupCounter.get();
-                        if (i>0)
+                        if (i > 0) {
                             keyCount = selector.selectNow();
-                        else {
+                        } else {
                             wakeupCounter.set(-1);
                             keyCount = selector.select(1000);
                         }
                         wakeupCounter.set(0);
-                        if (!run) break;
-                    }catch ( NullPointerException x ) {
-                        //sun bug 5076772 on windows JDK 1.5
-                        if (selector==null) throw x;
-                        if ( log.isDebugEnabled() ) log.debug("Possibly encountered sun bug 5076772 on windows JDK 1.5",x);
+                        if (!run) {
+                            break;
+                        }
+                    } catch (NullPointerException x) {
+                        // sun bug 5076772 on windows JDK 1.5
+                        if (selector == null) {
+                            throw x;
+                        }
+                        if (log.isDebugEnabled()) {
+                            log.debug("Possibly encountered sun bug 5076772 on windows JDK 1.5", x);
+                        }
                         continue;
-                    } catch ( CancelledKeyException x ) {
-                        //sun bug 5076772 on windows JDK 1.5
-                        if ( log.isDebugEnabled() ) log.debug("Possibly encountered sun bug 5076772 on windows JDK 1.5",x);
+                    } catch (CancelledKeyException x) {
+                        // sun bug 5076772 on windows JDK 1.5
+                        if (log.isDebugEnabled()) {
+                            log.debug("Possibly encountered sun bug 5076772 on windows JDK 1.5", x);
+                        }
                         continue;
                     } catch (Throwable x) {
                         ExceptionUtils.handleThrowable(x);
@@ -310,29 +337,31 @@ public class NioBlockingSelector {
                         continue;
                     }
 
-                    Iterator<SelectionKey> iterator = keyCount > 0 ? selector.selectedKeys().iterator() : null;
+                    Iterator<SelectionKey> iterator = keyCount > 0
+                            ? selector.selectedKeys().iterator()
+                            : null;
 
                     // Walk through the collection of ready keys and dispatch
                     // any active event.
                     while (run && iterator != null && iterator.hasNext()) {
                         SelectionKey sk = iterator.next();
-                        NioSocketWrapper attachment = (NioSocketWrapper)sk.attachment();
+                        NioSocketWrapper socketWrapper = (NioSocketWrapper) sk.attachment();
                         try {
                             iterator.remove();
                             sk.interestOps(sk.interestOps() & (~sk.readyOps()));
-                            if ( sk.isReadable() ) {
-                                countDown(attachment.getReadLatch());
+                            if (sk.isReadable()) {
+                                countDown(socketWrapper.getReadLatch());
                             }
                             if (sk.isWritable()) {
-                                countDown(attachment.getWriteLatch());
+                                countDown(socketWrapper.getWriteLatch());
                             }
-                        }catch (CancelledKeyException ckx) {
+                        } catch (CancelledKeyException ckx) {
                             sk.cancel();
-                            countDown(attachment.getReadLatch());
-                            countDown(attachment.getWriteLatch());
+                            countDown(socketWrapper.getReadLatch());
+                            countDown(socketWrapper.getWriteLatch());
                         }
-                    }//while
-                }catch ( Throwable t ) {
+                    }
+                } catch (Throwable t) {
                     log.error(sm.getString("nioBlockingSelector.processingError"), t);
                 }
             }
@@ -345,19 +374,23 @@ public class NioBlockingSelector {
                 try {
                     // Cancels all remaining keys
                     selector.selectNow();
-                }catch( Exception ignore ) {
-                    if (log.isDebugEnabled())log.debug("",ignore);
+                } catch (Exception ignore) {
+                    if (log.isDebugEnabled())
+                        log.debug("", ignore);
                 }
             }
             try {
                 selector.close();
-            }catch( Exception ignore ) {
-                if (log.isDebugEnabled())log.debug("",ignore);
+            } catch (Exception ignore) {
+                if (log.isDebugEnabled())
+                    log.debug("", ignore);
             }
         }
 
         public void countDown(CountDownLatch latch) {
-            if ( latch == null ) return;
+            if (latch == null) {
+                return;
+            }
             latch.countDown();
         }
 
@@ -414,24 +447,32 @@ public class NioBlockingSelector {
                 SelectionKey sk = ch.keyFor(selector);
                 try {
                     if (sk == null) {
-                        if (SelectionKey.OP_WRITE==(ops&SelectionKey.OP_WRITE)) countDown(key.getWriteLatch());
-                        if (SelectionKey.OP_READ==(ops&SelectionKey.OP_READ))countDown(key.getReadLatch());
+                        if (SelectionKey.OP_WRITE == (ops & SelectionKey.OP_WRITE)) {
+                            countDown(key.getWriteLatch());
+                        }
+                        if (SelectionKey.OP_READ == (ops & SelectionKey.OP_READ)) {
+                            countDown(key.getReadLatch());
+                        }
                     } else {
                         if (sk.isValid()) {
                             sk.interestOps(sk.interestOps() & (~ops));
-                            if (SelectionKey.OP_WRITE==(ops&SelectionKey.OP_WRITE)) countDown(key.getWriteLatch());
-                            if (SelectionKey.OP_READ==(ops&SelectionKey.OP_READ))countDown(key.getReadLatch());
-                            if (sk.interestOps()==0) {
+                            if (SelectionKey.OP_WRITE == (ops & SelectionKey.OP_WRITE)) {
+                                countDown(key.getWriteLatch());
+                            }
+                            if (SelectionKey.OP_READ == (ops & SelectionKey.OP_READ)) {
+                                countDown(key.getReadLatch());
+                            }
+                            if (sk.interestOps() == 0) {
                                 sk.cancel();
                                 sk.attach(null);
                             }
-                        }else {
+                        } else {
                             sk.cancel();
                             sk.attach(null);
                         }
                     }
-                }catch (CancelledKeyException cx) {
-                    if (sk!=null) {
+                } catch (CancelledKeyException cx) {
+                    if (sk != null) {
                         sk.cancel();
                         sk.attach(null);
                     }
@@ -462,9 +503,12 @@ public class NioBlockingSelector {
 
         @Override
         protected void finalize() {
-            if (key!=null && key.isValid()) {
+            if (key != null && key.isValid()) {
                 log.warn(sm.getString("nioBlockingSelector.possibleLeak"));
-                try {key.cancel();}catch (Exception ignore){}
+                try {
+                    key.cancel();
+                } catch (Exception ignore) {
+                }
             }
         }
     }

==================================================
NioSelectorPool.java
index bfa53bbfcc..eb9b87a628 100644
--- a/java/org/apache/tomcat/util/net/NioEndpoint.java
+++ b/java/org/apache/tomcat/util/net/NioEndpoint.java
@@ -1319,7 +1319,7 @@ public class NioEndpoint extends AbstractJsseEndpoint<NioChannel,SocketChannel>
                     // Ignore
                 }
                 try {
-                    pool.write(from, getSocket(), selector, writeTimeout, block);
+                    pool.write(from, getSocket(), selector, writeTimeout);
                     if (block) {
                         // Make sure we are flushed
                         do {

==================================================
SecureNioChannel.java
index 0bcdf8d713..e6b3a17376 100644
--- a/java/org/apache/tomcat/util/net/NioSelectorPool.java
+++ b/java/org/apache/tomcat/util/net/NioSelectorPool.java
@@ -31,56 +31,58 @@ import java.util.concurrent.atomic.AtomicInteger;
  */
 public class NioSelectorPool {
 
-    protected static final boolean SHARED =
-        Boolean.parseBoolean(System.getProperty("org.apache.tomcat.util.net.NioSelectorShared", "true"));
-
     protected NioBlockingSelector blockingSelector;
 
-    protected volatile Selector SHARED_SELECTOR;
+    protected volatile Selector sharedSelector;
 
+    protected boolean shared = Boolean.parseBoolean(System.getProperty("org.apache.tomcat.util.net.NioSelectorShared", "true"));
     protected int maxSelectors = 200;
     protected long sharedSelectorTimeout = 30000;
     protected int maxSpareSelectors = -1;
     protected boolean enabled = true;
+
     protected AtomicInteger active = new AtomicInteger(0);
     protected AtomicInteger spare = new AtomicInteger(0);
-    protected ConcurrentLinkedQueue<Selector> selectors =
-            new ConcurrentLinkedQueue<>();
+    protected ConcurrentLinkedQueue<Selector> selectors = new ConcurrentLinkedQueue<>();
 
     protected Selector getSharedSelector() throws IOException {
-        if (SHARED && SHARED_SELECTOR == null) {
-            synchronized ( NioSelectorPool.class ) {
-                if ( SHARED_SELECTOR == null )  {
-                    SHARED_SELECTOR = Selector.open();
+        if (shared && sharedSelector == null) {
+            synchronized (NioSelectorPool.class) {
+                if (sharedSelector == null) {
+                    sharedSelector = Selector.open();
                 }
             }
         }
-        return  SHARED_SELECTOR;
+        return  sharedSelector;
     }
 
     public Selector get() throws IOException{
-        if ( SHARED ) {
+        if (shared) {
             return getSharedSelector();
         }
-        if ( (!enabled) || active.incrementAndGet() >= maxSelectors ) {
-            if ( enabled ) active.decrementAndGet();
+        if ((!enabled) || active.incrementAndGet() >= maxSelectors) {
+            if (enabled) {
+                active.decrementAndGet();
+            }
             return null;
         }
         Selector s = null;
         try {
-            s = selectors.size()>0?selectors.poll():null;
+            s = selectors.size() > 0 ? selectors.poll() : null;
             if (s == null) {
                 s = Selector.open();
+            } else {
+                spare.decrementAndGet();
             }
-            else spare.decrementAndGet();
-
-        }catch (NoSuchElementException x ) {
+        } catch (NoSuchElementException x) {
             try {
                 s = Selector.open();
             } catch (IOException iox) {
             }
         } finally {
-            if ( s == null ) active.decrementAndGet();//we were unable to find a selector
+            if (s == null) {
+                active.decrementAndGet();// we were unable to find a selector
+            }
         }
         return s;
     }
@@ -88,34 +90,42 @@ public class NioSelectorPool {
 
 
     public void put(Selector s) throws IOException {
-        if ( SHARED ) return;
-        if ( enabled ) active.decrementAndGet();
-        if ( enabled && (maxSpareSelectors==-1 || spare.get() < Math.min(maxSpareSelectors,maxSelectors)) ) {
+        if (shared) {
+            return;
+        }
+        if (enabled) {
+            active.decrementAndGet();
+        }
+        if (enabled && (maxSpareSelectors == -1
+                || spare.get() < Math.min(maxSpareSelectors, maxSelectors))) {
             spare.incrementAndGet();
             selectors.offer(s);
+        } else {
+            s.close();
         }
-        else s.close();
     }
 
     public void close() throws IOException {
         enabled = false;
         Selector s;
-        while ( (s = selectors.poll()) != null ) s.close();
+        while ((s = selectors.poll()) != null) {
+            s.close();
+        }
         spare.set(0);
         active.set(0);
-        if (blockingSelector!=null) {
+        if (blockingSelector != null) {
             blockingSelector.close();
         }
-        if ( SHARED && getSharedSelector()!=null ) {
+        if (shared && getSharedSelector() != null) {
             getSharedSelector().close();
-            SHARED_SELECTOR = null;
+            sharedSelector = null;
         }
     }
 
     public void open(String name) throws IOException {
         enabled = true;
         getSharedSelector();
-        if (SHARED) {
+        if (shared) {
             blockingSelector = new NioBlockingSelector();
             blockingSelector.open(name, getSharedSelector());
         }
@@ -138,10 +148,10 @@ public class NioSelectorPool {
      * @throws SocketTimeoutException if the write times out
      * @throws IOException if an IO Exception occurs in the underlying socket logic
      */
-    public int write(ByteBuffer buf, NioChannel socket, Selector selector,
-                     long writeTimeout, boolean block) throws IOException {
-        if ( SHARED && block ) {
-            return blockingSelector.write(buf,socket,writeTimeout);
+    public int write(ByteBuffer buf, NioChannel socket, Selector selector, long writeTimeout)
+            throws IOException {
+        if (shared) {
+            return blockingSelector.write(buf, socket, writeTimeout);
         }
         SelectionKey key = null;
         int written = 0;
@@ -149,34 +159,42 @@ public class NioSelectorPool {
         int keycount = 1; //assume we can write
         long time = System.currentTimeMillis(); //start the timeout timer
         try {
-            while ( (!timedout) && buf.hasRemaining() ) {
+            while ((!timedout) && buf.hasRemaining()) {
                 int cnt = 0;
                 if ( keycount > 0 ) { //only write if we were registered for a write
                     cnt = socket.write(buf); //write the data
-                    if (cnt == -1) throw new EOFException();
+                    if (cnt == -1) {
+                        throw new EOFException();
+                    }
 
                     written += cnt;
                     if (cnt > 0) {
                         time = System.currentTimeMillis(); //reset our timeout timer
                         continue; //we successfully wrote, try again without a selector
                     }
-                    if (cnt==0 && (!block)) break; //don't block
                 }
-                if ( selector != null ) {
+                if (selector != null) {
                     //register OP_WRITE to the selector
-                    if (key==null) key = socket.getIOChannel().register(selector, SelectionKey.OP_WRITE);
-                    else key.interestOps(SelectionKey.OP_WRITE);
-                    if (writeTimeout==0) {
+                    if (key == null) {
+                        key = socket.getIOChannel().register(selector, SelectionKey.OP_WRITE);
+                    } else {
+                        key.interestOps(SelectionKey.OP_WRITE);
+                    }
+                    if (writeTimeout == 0) {
                         timedout = buf.hasRemaining();
-                    } else if (writeTimeout<0) {
+                    } else if (writeTimeout < 0) {
                         keycount = selector.select();
                     } else {
                         keycount = selector.select(writeTimeout);
                     }
                 }
-                if (writeTimeout > 0 && (selector == null || keycount == 0) ) timedout = (System.currentTimeMillis()-time)>=writeTimeout;
-            }//while
-            if ( timedout ) throw new SocketTimeoutException();
+                if (writeTimeout > 0 && (selector == null || keycount == 0)) {
+                    timedout = (System.currentTimeMillis() - time) >= writeTimeout;
+                }
+            }
+            if (timedout) {
+                throw new SocketTimeoutException();
+            }
         } finally {
             if (key != null) {
                 key.cancel();
@@ -199,27 +217,10 @@ public class NioSelectorPool {
      * @throws SocketTimeoutException if the read times out
      * @throws IOException if an IO Exception occurs in the underlying socket logic
      */
-    public int read(ByteBuffer buf, NioChannel socket, Selector selector, long readTimeout) throws IOException {
-        return read(buf,socket,selector,readTimeout,true);
-    }
-    /**
-     * Performs a read using the bytebuffer for data to be read and a selector to register for events should
-     * you have the block=true.
-     * If the <code>selector</code> parameter is null, then it will perform a busy read that could
-     * take up a lot of CPU cycles.
-     * @param buf ByteBuffer - the buffer containing the data, we will read as until we have read at least one byte or we timed out
-     * @param socket SocketChannel - the socket to write data to
-     * @param selector Selector - the selector to use for blocking, if null then a busy read will be initiated
-     * @param readTimeout long - the timeout for this read operation in milliseconds, -1 means no timeout
-     * @param block - true if you want to block until data becomes available or timeout time has been reached
-     * @return int - returns the number of bytes read
-     * @throws EOFException if read returns -1
-     * @throws SocketTimeoutException if the read times out
-     * @throws IOException if an IO Exception occurs in the underlying socket logic
-     */
-    public int read(ByteBuffer buf, NioChannel socket, Selector selector, long readTimeout, boolean block) throws IOException {
-        if ( SHARED && block ) {
-            return blockingSelector.read(buf,socket,readTimeout);
+    public int read(ByteBuffer buf, NioChannel socket, Selector selector, long readTimeout)
+            throws IOException {
+        if (shared) {
+            return blockingSelector.read(buf, socket, readTimeout);
         }
         SelectionKey key = null;
         int read = 0;
@@ -227,9 +228,9 @@ public class NioSelectorPool {
         int keycount = 1; //assume we can write
         long time = System.currentTimeMillis(); //start the timeout timer
         try {
-            while ( (!timedout) ) {
+            while (!timedout) {
                 int cnt = 0;
-                if ( keycount > 0 ) { //only read if we were registered for a read
+                if (keycount > 0) { //only read if we were registered for a read
                     cnt = socket.read(buf);
                     if (cnt == -1) {
                         if (read == 0) {
@@ -239,27 +240,37 @@ public class NioSelectorPool {
                     }
                     read += cnt;
                     if (cnt > 0) continue; //read some more
-                    if (cnt==0 && (read>0 || (!block) ) ) break; //we are done reading
+                    if (cnt == 0 && read > 0) {
+                        break; //we are done reading
+                    }
                 }
-                if ( selector != null ) {//perform a blocking read
+                if (selector != null) {//perform a blocking read
                     //register OP_WRITE to the selector
-                    if (key==null) key = socket.getIOChannel().register(selector, SelectionKey.OP_READ);
+                    if (key == null) {
+                        key = socket.getIOChannel().register(selector, SelectionKey.OP_READ);
+                    }
                     else key.interestOps(SelectionKey.OP_READ);
-                    if (readTimeout==0) {
-                        timedout = (read==0);
-                    } else if (readTimeout<0) {
+                    if (readTimeout == 0) {
+                        timedout = (read == 0);
+                    } else if (readTimeout < 0) {
                         keycount = selector.select();
                     } else {
                         keycount = selector.select(readTimeout);
                     }
                 }
-                if (readTimeout > 0 && (selector == null || keycount == 0) ) timedout = (System.currentTimeMillis()-time)>=readTimeout;
-            }//while
-            if ( timedout ) throw new SocketTimeoutException();
+                if (readTimeout > 0 && (selector == null || keycount == 0) ) {
+                    timedout = (System.currentTimeMillis() - time) >= readTimeout;
+                }
+            }
+            if (timedout) {
+                throw new SocketTimeoutException();
+            }
         } finally {
             if (key != null) {
                 key.cancel();
-                if (selector != null) selector.selectNow();//removes the key from this selector
+                if (selector != null) {
+                    selector.selectNow();//removes the key from this selector
+                }
             }
         }
         return read;
@@ -304,4 +315,12 @@ public class NioSelectorPool {
     public AtomicInteger getSpare() {
         return spare;
     }
+
+    public boolean isShared() {
+        return shared;
+    }
+
+    public void setShared(boolean shared) {
+        this.shared = shared;
+    }
 }
\ No newline at end of file

==================================================
