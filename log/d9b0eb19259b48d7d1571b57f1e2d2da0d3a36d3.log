d9b0eb19259b48d7d1571b57f1e2d2da0d3a36d3
==================================================
Align ActionCode.DISPATCH_EXECUTE
==================================================
Mark Thomas
==================================================
Fri Aug 12 07:47:20 2016 +0000
==================================================
AjpProcessor.java
Align ActionCode.DISPATCH_EXECUTE

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1756103 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Http11Processor.java
index cdd5660701..96aa1d5842 100644
--- a/java/org/apache/coyote/ajp/AjpProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpProcessor.java
@@ -565,7 +565,10 @@ public class AjpProcessor extends AbstractProcessor {
             break;
         }
         case DISPATCH_EXECUTE: {
-            socketWrapper.executeNonBlockingDispatches(getIteratorAndClearDispatches());
+            SocketWrapperBase<?> wrapper = socketWrapper;
+            if (wrapper != null) {
+                executeDispatches(wrapper);
+            }
             break;
         }
 
@@ -1421,13 +1424,13 @@ public class AjpProcessor extends AbstractProcessor {
         replay = true;
         endOfStream = false;
     }
-    
-    
+
+
     private void setSwallowResponse() {
         swallowResponse = true;
     }
-    
-    
+
+
     private void disableSwallowRequest() {
         /* NO-OP
          * With AJP, Tomcat controls when the client sends request body data. At
@@ -1435,15 +1438,15 @@ public class AjpProcessor extends AbstractProcessor {
          * in finishResponse().
          */
     }
-    
-    
+
+
     private boolean getPopulateRequestAttributesFromSocket() {
         // NO-OPs the attribute requests since they are pre-populated when
         // parsing the first AJP message.
         return false;
     }
 
-    
+
     private void populateRequestAttributeRemoteHost() {
         // Get remote host name using a DNS resolution
         if (request.remoteHost().isNull()) {
@@ -1455,8 +1458,8 @@ public class AjpProcessor extends AbstractProcessor {
             }
         }
     }
-    
-    
+
+
     private void populateSslRequestAttributes() {
         if (!certificates.isNull()) {
             ByteChunk certData = certificates.getByteChunk();
@@ -1498,29 +1501,34 @@ public class AjpProcessor extends AbstractProcessor {
             request.setAttribute(SSLSupport.CERTIFICATE_KEY, jsseCerts);
         }
     }
-    
-    
+
+
     private void sslReHandShake() {
         // NO-OP. Can't force a new SSL handshake with the client when using
         // AJP as the reverse proxy controls that connection.
     }
 
-    
+
     private boolean isRequestBodyFullyRead() {
         return endOfStream;
     }
-    
-    
+
+
     private void registerReadInterest() {
         socketWrapper.registerReadInterest();
     }
-    
-    
+
+
     private boolean isReady() {
         return responseMsgPos == -1 && socketWrapper.isReadyForWrite();
     }
-    
-    
+
+
+    private void executeDispatches(SocketWrapperBase<?> wrapper) {
+        wrapper.executeNonBlockingDispatches(getIteratorAndClearDispatches());
+    }
+
+
     /**
      * Read at least the specified amount of bytes, and place them
      * in the input buffer. Note that if any data is available to read then this

==================================================
StreamProcessor.java
index b44e5c587f..ef46d64b0c 100644
--- a/java/org/apache/coyote/http11/Http11Processor.java
+++ b/java/org/apache/coyote/http11/Http11Processor.java
@@ -860,7 +860,7 @@ public class Http11Processor extends AbstractProcessor {
         case DISPATCH_EXECUTE: {
             SocketWrapperBase<?> wrapper = socketWrapper;
             if (wrapper != null) {
-                wrapper.executeNonBlockingDispatches(getIteratorAndClearDispatches());
+                executeDispatches(wrapper);
             }
             break;
         }
@@ -1746,39 +1746,39 @@ public class Http11Processor extends AbstractProcessor {
     private int available(boolean doRead) {
         return inputBuffer.available(doRead);
     }
-    
-    
+
+
     private void setRequestBody(ByteChunk body) {
         InputFilter savedBody = new SavedRequestInputFilter(body);
         savedBody.setRequest(request);
-    
+
         Http11InputBuffer internalBuffer = (Http11InputBuffer) request.getInputBuffer();
         internalBuffer.addActiveFilter(savedBody);
     }
-    
-    
+
+
     private void setSwallowResponse() {
         outputBuffer.responseFinished = true;
     }
-    
-    
+
+
     private void disableSwallowRequest() {
         inputBuffer.setSwallowInput(false);
     }
-    
-    
+
+
     private boolean getPopulateRequestAttributesFromSocket() {
         return true;
     }
-    
-    
+
+
     private void populateRequestAttributeRemoteHost() {
         if (getPopulateRequestAttributesFromSocket() && socketWrapper != null) {
             request.remoteHost().setString(socketWrapper.getRemoteHost());
         }
     }
-    
-    
+
+
     private void populateSslRequestAttributes() {
         try {
             if (sslSupport != null) {
@@ -1830,23 +1830,28 @@ public class Http11Processor extends AbstractProcessor {
             }
         }
     }
-    
-    
+
+
     private boolean isRequestBodyFullyRead() {
         return inputBuffer.isFinished();
     }
-    
-    
+
+
     private void registerReadInterest() {
         socketWrapper.registerReadInterest();
     }
-    
-    
+
+
     private boolean isReady() {
         return outputBuffer.isReady();
     }
-    
-    
+
+
+    private void executeDispatches(SocketWrapperBase<?> wrapper) {
+        wrapper.executeNonBlockingDispatches(getIteratorAndClearDispatches());
+    }
+
+
     /**
      * Checks to see if the keep-alive loop should be broken, performing any
      * processing (e.g. sendfile handling) that may have an impact on whether

==================================================
