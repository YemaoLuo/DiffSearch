a66c615a0770137b36b986bdb7265eb433f64fa2
==================================================
Refactor to reduce code duplication.
==================================================
Mark Emlyn
==================================================
Mon Sep 16 13:13:18 2013 +0000
==================================================
AbstractArchiveResourceSet.java
Refactor to reduce code duplication.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1523631 13f79535-47bb-0310-9956-ffa450edef68



==================================================
JarResourceSet.java
new file mode 100644
index 0000000000..3416002b85
--- /dev/null
+++ b/java/org/apache/catalina/webresources/AbstractArchiveResourceSet.java
@@ -0,0 +1,152 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.webresources;
+
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Set;
+import java.util.jar.JarEntry;
+
+import org.apache.catalina.util.ResourceSet;
+
+public abstract class AbstractArchiveResourceSet extends AbstractResourceSet {
+
+    protected HashMap<String,JarEntry> jarFileEntries = new HashMap<>();
+    protected String baseUrl;
+
+    @Override
+    public final String[] list(String path) {
+        checkPath(path);
+        String webAppMount = getWebAppMount();
+
+        ArrayList<String> result = new ArrayList<>();
+        if (path.startsWith(webAppMount)) {
+            String pathInJar =
+                    getInternalPath() + path.substring(webAppMount.length());
+            // Always strip off the leading '/' to get the JAR path
+            if (pathInJar.charAt(0) == '/') {
+                pathInJar = pathInJar.substring(1);
+            }
+            Iterator<String> entries = jarFileEntries.keySet().iterator();
+            while (entries.hasNext()) {
+                String name = entries.next();
+                if (name.length() > pathInJar.length() &&
+                        name.startsWith(pathInJar)) {
+                    if (name.charAt(name.length() - 1) == '/') {
+                        name = name.substring(
+                                pathInJar.length(), name.length() - 1);
+                    } else {
+                        name = name.substring(pathInJar.length());
+                    }
+                    if (name.length() == 0) {
+                        continue;
+                    }
+                    if (name.charAt(0) == '/') {
+                        name = name.substring(1);
+                    }
+                    if (name.length() > 0 && name.lastIndexOf('/') == -1) {
+                        result.add(name);
+                    }
+                }
+            }
+        } else {
+            if (!path.endsWith("/")) {
+                path = path + "/";
+            }
+            if (webAppMount.startsWith(path)) {
+                int i = webAppMount.indexOf('/', path.length());
+                if (i == -1) {
+                    return new String[] {webAppMount.substring(path.length())};
+                } else {
+                    return new String[] {
+                            webAppMount.substring(path.length(), i)};
+                }
+            }
+        }
+        return result.toArray(new String[result.size()]);
+    }
+
+    @Override
+    public final Set<String> listWebAppPaths(String path) {
+        checkPath(path);
+        String webAppMount = getWebAppMount();
+
+        ResourceSet<String> result = new ResourceSet<>();
+        if (path.startsWith(webAppMount)) {
+            String pathInJar =
+                    getInternalPath() + path.substring(webAppMount.length());
+            // Always strip off the leading '/' to get the JAR path and make
+            // sure it ends in '/'
+            if (pathInJar.charAt(pathInJar.length() - 1) != '/') {
+                pathInJar = pathInJar.substring(1) + '/';
+            }
+            if (pathInJar.charAt(0) == '/') {
+                pathInJar = pathInJar.substring(1);
+            }
+
+            Iterator<String> entries = jarFileEntries.keySet().iterator();
+            while (entries.hasNext()) {
+                String name = entries.next();
+                if (name.length() > pathInJar.length() &&
+                        name.startsWith(pathInJar)) {
+                    int nextSlash = name.indexOf('/', pathInJar.length());
+                    if (nextSlash == -1 || nextSlash == name.length() - 1) {
+                        if (name.startsWith(pathInJar)) {
+                            result.add(webAppMount + '/' +
+                                    name.substring(getInternalPath().length()));
+                        }
+                    }
+                }
+            }
+        } else {
+            if (!path.endsWith("/")) {
+                path = path + "/";
+            }
+            if (webAppMount.startsWith(path)) {
+                int i = webAppMount.indexOf('/', path.length());
+                if (i == -1) {
+                    result.add(webAppMount + "/");
+                } else {
+                    result.add(webAppMount.substring(0, i + 1));
+                }
+            }
+        }
+        result.setLocked(true);
+        return result;
+    }
+
+    @Override
+    public final boolean mkdir(String path) {
+        checkPath(path);
+
+        return false;
+    }
+
+    @Override
+    public final boolean write(String path, InputStream is, boolean overwrite) {
+        checkPath(path);
+
+        if (is == null) {
+            throw new NullPointerException(
+                    sm.getString("dirResourceSet.writeNpe"));
+        }
+
+        return false;
+    }
+}

==================================================
JarWarResourceSet.java
index e47a3e60c1..0038e5ae1d 100644
--- a/java/org/apache/catalina/webresources/JarResourceSet.java
+++ b/java/org/apache/catalina/webresources/JarResourceSet.java
@@ -18,25 +18,20 @@ package org.apache.catalina.webresources;
 
 import java.io.File;
 import java.io.IOException;
-import java.io.InputStream;
 import java.net.MalformedURLException;
-import java.util.ArrayList;
 import java.util.Enumeration;
 import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Set;
 import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
 
 import org.apache.catalina.LifecycleException;
 import org.apache.catalina.WebResource;
 import org.apache.catalina.WebResourceRoot;
-import org.apache.catalina.util.ResourceSet;
 
 /**
  * Represents a {@link org.apache.catalina.WebResourceSet} based on a JAR file.
  */
-public class JarResourceSet extends AbstractResourceSet {
+public class JarResourceSet extends AbstractArchiveResourceSet {
 
     protected HashMap<String,JarEntry> jarFileEntries = new HashMap<>();
     protected String baseUrl;
@@ -138,126 +133,6 @@ public class JarResourceSet extends AbstractResourceSet {
         }
     }
 
-    @Override
-    public String[] list(String path) {
-        checkPath(path);
-        String webAppMount = getWebAppMount();
-
-        ArrayList<String> result = new ArrayList<>();
-        if (path.startsWith(webAppMount)) {
-            String pathInJar =
-                    getInternalPath() + path.substring(webAppMount.length());
-            // Always strip off the leading '/' to get the JAR path
-            if (pathInJar.charAt(0) == '/') {
-                pathInJar = pathInJar.substring(1);
-            }
-            Iterator<String> entries = jarFileEntries.keySet().iterator();
-            while (entries.hasNext()) {
-                String name = entries.next();
-                if (name.length() > pathInJar.length() &&
-                        name.startsWith(pathInJar)) {
-                    if (name.charAt(name.length() - 1) == '/') {
-                        name = name.substring(
-                                pathInJar.length(), name.length() - 1);
-                    } else {
-                        name = name.substring(pathInJar.length());
-                    }
-                    if (name.length() == 0) {
-                        continue;
-                    }
-                    if (name.charAt(0) == '/') {
-                        name = name.substring(1);
-                    }
-                    if (name.length() > 0 && name.lastIndexOf('/') == -1) {
-                        result.add(name);
-                    }
-                }
-            }
-        } else {
-            if (!path.endsWith("/")) {
-                path = path + "/";
-            }
-            if (webAppMount.startsWith(path)) {
-                int i = webAppMount.indexOf('/', path.length());
-                if (i == -1) {
-                    return new String[] {webAppMount.substring(path.length())};
-                } else {
-                    return new String[] {
-                            webAppMount.substring(path.length(), i)};
-                }
-            }
-        }
-        return result.toArray(new String[result.size()]);
-    }
-
-    @Override
-    public Set<String> listWebAppPaths(String path) {
-        checkPath(path);
-        String webAppMount = getWebAppMount();
-
-        ResourceSet<String> result = new ResourceSet<>();
-        if (path.startsWith(webAppMount)) {
-            String pathInJar =
-                    getInternalPath() + path.substring(webAppMount.length());
-            // Always strip off the leading '/' to get the JAR path and make
-            // sure it ends in '/'
-            if (pathInJar.charAt(pathInJar.length() - 1) != '/') {
-                pathInJar = pathInJar.substring(1) + '/';
-            }
-            if (pathInJar.charAt(0) == '/') {
-                pathInJar = pathInJar.substring(1);
-            }
-
-            Iterator<String> entries = jarFileEntries.keySet().iterator();
-            while (entries.hasNext()) {
-                String name = entries.next();
-                if (name.length() > pathInJar.length() &&
-                        name.startsWith(pathInJar)) {
-                    int nextSlash = name.indexOf('/', pathInJar.length());
-                    if (nextSlash == -1 || nextSlash == name.length() - 1) {
-                        if (name.startsWith(pathInJar)) {
-                            result.add(webAppMount + '/' +
-                                    name.substring(getInternalPath().length()));
-                        }
-                    }
-                }
-            }
-        } else {
-            if (!path.endsWith("/")) {
-                path = path + "/";
-            }
-            if (webAppMount.startsWith(path)) {
-                int i = webAppMount.indexOf('/', path.length());
-                if (i == -1) {
-                    result.add(webAppMount + "/");
-                } else {
-                    result.add(webAppMount.substring(0, i + 1));
-                }
-            }
-        }
-        result.setLocked(true);
-        return result;
-    }
-
-    @Override
-    public boolean mkdir(String path) {
-        checkPath(path);
-
-        return false;
-    }
-
-    @Override
-    public boolean write(String path, InputStream is, boolean overwrite) {
-        checkPath(path);
-
-        if (is == null) {
-            throw new NullPointerException(
-                    sm.getString("dirResourceSet.writeNpe"));
-        }
-
-        return false;
-    }
-
     //-------------------------------------------------------- Lifecycle methods
     @Override
     protected void initInternal() throws LifecycleException {

==================================================
