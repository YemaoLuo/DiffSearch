4a8d92fc282cadf117e4830d3a411580a48d1158
==================================================
HTTP/2 debug logging improvements for Server push
==================================================
Mark Thomas
==================================================
Mon Nov 23 12:28:59 2015 +0000
==================================================
HpackEncoder.java
HTTP/2 debug logging improvements for Server push

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1715783 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Http2UpgradeHandler.java
index 4df3b2de85..9ffca4ff93 100644
--- a/java/org/apache/coyote/http2/HpackEncoder.java
+++ b/java/org/apache/coyote/http2/HpackEncoder.java
@@ -26,13 +26,19 @@ import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.http.MimeHeaders;
+import org.apache.tomcat.util.res.StringManager;
 
 /**
  * Encoder for HPACK frames.
  */
 public class HpackEncoder {
 
+    private static final Log log = LogFactory.getLog(HpackEncoder.class);
+    private static final StringManager sm = StringManager.getManager(HpackEncoder.class);
+
     public static final HpackHeaderFunction DEFAULT_HEADER_FUNCTION = new HpackHeaderFunction() {
         @Override
         public boolean shouldUseIndexing(String headerName, String value) {
@@ -141,19 +147,24 @@ public class HpackEncoder {
                 }
             }
             if (!skip) {
-
-                    int required = 11 + headerName.length(); //we use 11 to make sure we have enough room for the variable length integers
-
                     String val = headers.getValue(it).toString();
+
+                    if (log.isDebugEnabled()) {
+                        log.debug(sm.getString("hpackEncoder.encodeHeader", headerName, val));
+                    }
                     TableEntry tableEntry = findInTable(headerName, val);
 
-                    required += (1 + val.length());
+                    // We use 11 to make sure we have enough room for the
+                    // variable length integers
+                    int required = 11 + headerName.length() + 1 + val.length();
 
                     if (target.remaining() < required) {
                         this.headersIterator = it;
                         return State.UNDERFLOW;
                     }
-                    boolean canIndex = hpackHeaderFunction.shouldUseIndexing(headerName, val) && (headerName.length() + val.length() + 32) < maxTableSize; //only index if it will fit
+                    // Only index if it will fit
+                    boolean canIndex = hpackHeaderFunction.shouldUseIndexing(headerName, val) &&
+                            (headerName.length() + val.length() + 32) < maxTableSize;
                     if (tableEntry == null && canIndex) {
                         //add the entry to the dynamic table
                         target.put((byte) (1 << 6));

==================================================
Stream.java
index 8f86974a4d..c748808076 100644
--- a/java/org/apache/coyote/http2/LocalStrings.properties
+++ b/java/org/apache/coyote/http2/LocalStrings.properties
@@ -35,6 +35,8 @@ hpack.integerEncodedOverTooManyOctets=HPACK variable length integer encoded over
 
 hpackdecoder.zeroNotValidHeaderTableIndex=Zero is not a valid header table index
 
+hpackEncoder.encodeHeader=Encoding header [{0}] with value [{1}]
+
 hpackhuffman.huffmanEncodedHpackValueDidNotEndWithEOS=Huffman encoded value in HPACK headers did not end with EOS padding
 
 http2Parser.headers.wrongFrameType=Connection [{0}], headers in progress for stream [{1}] but a frame of type [{2}] was received
@@ -125,7 +127,7 @@ upgradeHandler.windowSizeTooBig=Connection [{0}], Stream [{1}], Window size too
 upgradeHandler.windowSizeReservationInterrupted=Connection [{0}], Stream [{1}], reservation for [{2}] bytes
 upgradeHandler.writeBody=Connection [{0}], Stream [{1}], Data length [{2}]
 upgradeHandler.writeHeaders=Connection [{0}], Stream [{1}]
-upgradeHandler.writePushHeaders=Connection [{0}], Stream [{1}]
+upgradeHandler.writePushHeaders=Connection [{0}], Stream [{1}], Pushed stream [{2}]
 
 writeStateMachine.endWrite.ise=It is illegal to specify [{0}] for the new state once a write has completed
 writeStateMachine.ise=It is illegal to call [{0}()] in state [{1}]
\ No newline at end of file

==================================================
