1c7a9d068b8978fb56efab5e53dabb9c8393fe34
==================================================
Add code targeting Panama preview API
==================================================
remm remm@apache.org
==================================================
Wed May 18 11:22:30 2022 +0200
==================================================
OpenSSLContext.java
new file mode 100644
index 0000000000..de83ee511e
--- /dev/null
+++ b/modules/openssl-foreign/pom.xml
@@ -0,0 +1,98 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Licensed to the Apache Software Foundation (ASF) under one or more
+  contributor license agreements.  See the NOTICE file distributed with
+  this work for additional information regarding copyright ownership.
+  The ASF licenses this file to You under the Apache License, Version 2.0
+  (the "License"); you may not use this file except in compliance with
+  the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache</groupId>
+        <artifactId>apache</artifactId>
+        <version>26</version>
+    </parent>
+
+    <groupId>org.apache.tomcat</groupId>
+    <artifactId>tomcat-coyote-openssl</artifactId>
+    <name>Apache Tomcat OpenSSL support for Java 21</name>
+    <description>OpenSSL support using new APIs included in Java 21</description>
+    <version>0.1-SNAPSHOT</version>
+
+    <properties>
+        <tomcat.version>10.0.20</tomcat.version>
+        <project.build.outputTimestamp>2021-12-02T12:00:00Z</project.build.outputTimestamp>
+    </properties>
+
+    <scm>
+        <connection>scm:git:https://gitbox.apache.org/repos/asf/tomcat.git</connection>
+        <developerConnection>scm:git:https://gitbox.apache.org/repos/asf/tomcat.git</developerConnection>
+        <url>https://gitbox.apache.org/repos/asf?p=tomcat.git</url>
+        <tag>HEAD</tag>
+    </scm>
+
+    <mailingLists>
+        <mailingList>
+            <name>Development List</name>
+            <subscribe>dev-subscribe@tomcat.apache.org</subscribe>
+            <unsubscribe>dev-unsubscribe@tomcat.apache.org</unsubscribe>
+            <post>dev@tomcat.apache.org</post>
+        </mailingList>
+        <mailingList>
+            <name>Users List</name>
+            <subscribe>users-subscribe@tomcat.apache.org</subscribe>
+            <unsubscribe>users-unsubscribe@tomcat.apache.org</unsubscribe>
+            <post>users@tomcat.apache.org</post>
+        </mailingList>
+    </mailingLists>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.apache.tomcat</groupId>
+            <artifactId>tomcat-catalina</artifactId>
+            <version>${tomcat.version}</version>
+            <scope>provided</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.tomcat</groupId>
+            <artifactId>tomcat-coyote</artifactId>
+            <version>${tomcat.version}</version>
+            <scope>provided</scope>
+        </dependency>
+    </dependencies>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <configuration>
+                    <source>19</source>
+                    <target>19</target>
+                    <compilerArgs>
+                        <arg>--enable-preview</arg>
+                    </compilerArgs>
+                </configuration>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-javadoc-plugin</artifactId>
+                <configuration>
+                    <source>19</source> 
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+
+</project>

==================================================
OpenSSLEngine.java
new file mode 100644
index 0000000000..8f8e857d59
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/net/openssl/panama/OpenSSLContext.java
@@ -0,0 +1,1409 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.util.net.openssl.panama;
+
+import static org.apache.tomcat.util.openssl.openssl_h.*;
+
+import java.io.File;
+import java.lang.foreign.Addressable;
+import java.lang.foreign.FunctionDescriptor;
+import java.lang.foreign.Linker;
+import java.lang.foreign.MemoryAddress;
+import java.lang.foreign.MemorySegment;
+import java.lang.foreign.MemorySession;
+import java.lang.foreign.SegmentAllocator;
+import java.lang.foreign.ValueLayout;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+import java.lang.ref.Cleaner;
+import java.lang.ref.Cleaner.Cleanable;
+import java.nio.charset.StandardCharsets;
+import java.security.PrivateKey;
+import java.security.SecureRandom;
+import java.security.cert.CertificateException;
+import java.security.cert.CertificateFactory;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Base64;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.ConcurrentHashMap;
+
+import javax.net.ssl.KeyManager;
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLException;
+import javax.net.ssl.SSLParameters;
+import javax.net.ssl.SSLServerSocketFactory;
+import javax.net.ssl.SSLSessionContext;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509KeyManager;
+import javax.net.ssl.X509TrustManager;
+
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+import org.apache.tomcat.util.net.AbstractEndpoint;
+import org.apache.tomcat.util.net.Constants;
+import org.apache.tomcat.util.net.SSLHostConfig;
+import org.apache.tomcat.util.net.SSLHostConfig.CertificateVerification;
+import org.apache.tomcat.util.net.SSLHostConfigCertificate;
+import org.apache.tomcat.util.net.SSLHostConfigCertificate.Type;
+import org.apache.tomcat.util.net.openssl.OpenSSLConf;
+import org.apache.tomcat.util.net.openssl.OpenSSLConfCmd;
+import org.apache.tomcat.util.res.StringManager;
+
+public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
+
+    private static final Log log = LogFactory.getLog(OpenSSLContext.class);
+
+    private static final StringManager netSm = StringManager.getManager(AbstractEndpoint.class);
+    private static final StringManager sm = StringManager.getManager(OpenSSLContext.class);
+
+    private static final Cleaner cleaner = Cleaner.create();
+
+    private static final String defaultProtocol = "TLS";
+
+    private static final int SSL_AIDX_RSA     = 0;
+    private static final int SSL_AIDX_DSA     = 1;
+    private static final int SSL_AIDX_ECC     = 3;
+    private static final int SSL_AIDX_MAX     = 4;
+
+    public static final int SSL_PROTOCOL_NONE  = 0;
+    public static final int SSL_PROTOCOL_SSLV2 = (1<<0);
+    public static final int SSL_PROTOCOL_SSLV3 = (1<<1);
+    public static final int SSL_PROTOCOL_TLSV1 = (1<<2);
+    public static final int SSL_PROTOCOL_TLSV1_1 = (1<<3);
+    public static final int SSL_PROTOCOL_TLSV1_2 = (1<<4);
+    public static final int SSL_PROTOCOL_TLSV1_3 = (1<<5);
+    public static final int SSL_PROTOCOL_ALL = (SSL_PROTOCOL_TLSV1 | SSL_PROTOCOL_TLSV1_1 | SSL_PROTOCOL_TLSV1_2 |
+            SSL_PROTOCOL_TLSV1_3);
+
+    private static final String BEGIN_KEY = "-----BEGIN PRIVATE KEY-----\n";
+    private static final Object END_KEY = "\n-----END PRIVATE KEY-----";
+
+    private static final byte[] HTTP_11_PROTOCOL =
+            new byte[] { 'h', 't', 't', 'p', '/', '1', '.', '1' };
+
+    private static final byte[] DEFAULT_SESSION_ID_CONTEXT =
+            new byte[] { 'd', 'e', 'f', 'a', 'u', 'l', 't' };
+
+    static final CertificateFactory X509_CERT_FACTORY;
+    static {
+        try {
+            X509_CERT_FACTORY = CertificateFactory.getInstance("X.509");
+        } catch (CertificateException e) {
+            throw new IllegalStateException(sm.getString("openssl.X509FactoryError"), e);
+        }
+    }
+
+    private static final MethodHandle openSSLCallbackVerifyHandle;
+    private static final MethodHandle openSSLCallbackPasswordHandle;
+    private static final MethodHandle openSSLCallbackCertVerifyHandle;
+    private static final MethodHandle openSSLCallbackAlpnSelectProtoHandle;
+    private static final MethodHandle openSSLCallbackTmpDHHandle;
+
+    private static final FunctionDescriptor openSSLCallbackVerifyFunctionDescriptor =
+            FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.JAVA_INT, ValueLayout.ADDRESS);
+    private static final FunctionDescriptor openSSLCallbackPasswordFunctionDescriptor =
+            FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.ADDRESS, ValueLayout.JAVA_INT,
+            ValueLayout.JAVA_INT, ValueLayout.ADDRESS);
+    private static final FunctionDescriptor openSSLCallbackCertVerifyFunctionDescriptor =
+            FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.ADDRESS, ValueLayout.ADDRESS);
+    private static final FunctionDescriptor openSSLCallbackAlpnSelectProtoFunctionDescriptor =
+            FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.ADDRESS,
+            ValueLayout.ADDRESS, ValueLayout.ADDRESS, ValueLayout.ADDRESS,
+            ValueLayout.JAVA_INT, ValueLayout.ADDRESS);
+    private static final FunctionDescriptor openSSLCallbackTmpDHFunctionDescriptor =
+            FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.ADDRESS,
+            ValueLayout.JAVA_INT, ValueLayout.JAVA_INT);
+
+    static {
+        MethodHandles.Lookup lookup = MethodHandles.lookup();
+        try {
+            openSSLCallbackVerifyHandle = lookup.findStatic(OpenSSLContext.class, "openSSLCallbackVerify",
+                    MethodType.methodType(int.class, int.class, MemoryAddress.class));
+            openSSLCallbackPasswordHandle = lookup.findStatic(OpenSSLContext.class, "openSSLCallbackPassword",
+                    MethodType.methodType(int.class, MemoryAddress.class, int.class, int.class, MemoryAddress.class));
+            openSSLCallbackCertVerifyHandle = lookup.findStatic(OpenSSLContext.class, "openSSLCallbackCertVerify",
+                    MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class));
+            openSSLCallbackAlpnSelectProtoHandle = lookup.findStatic(OpenSSLContext.class, "openSSLCallbackAlpnSelectProto",
+                    MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class,
+                            MemoryAddress.class, MemoryAddress.class, int.class, MemoryAddress.class));
+            openSSLCallbackTmpDHHandle = lookup.findStatic(OpenSSLContext.class, "openSSLCallbackTmpDH",
+                    MethodType.methodType(Addressable.class, MemoryAddress.class, int.class, int.class));
+        } catch (Exception e) {
+            throw new IllegalStateException(e);
+        }
+    }
+
+    private final SSLHostConfig sslHostConfig;
+    private final SSLHostConfigCertificate certificate;
+    private final boolean alpn;
+    private final int minTlsVersion;
+    private final int maxTlsVersion;
+
+    private OpenSSLSessionContext sessionContext;
+    private String enabledProtocol;
+    private boolean initialized = false;
+
+    private boolean noOcspCheck = false;
+
+    // Password callback
+    private final MemorySegment openSSLCallbackPassword;
+
+    private static final ConcurrentHashMap<Long, ContextState> states = new ConcurrentHashMap<>();
+
+    static ContextState getState(MemoryAddress ctx) {
+        return states.get(Long.valueOf(ctx.toRawLongValue()));
+    }
+
+    private final ContextState state;
+    private final Cleanable cleanable;
+
+    private static String[] getCiphers(MemoryAddress sslCtx) {
+        MemoryAddress sk = SSL_CTX_get_ciphers(sslCtx);
+        int len = OPENSSL_sk_num(sk);
+        if (len <= 0) {
+            return null;
+        }
+        ArrayList<String> ciphers = new ArrayList<>(len);
+        for (int i = 0; i < len; i++) {
+            MemoryAddress cipher = OPENSSL_sk_value(sk, i);
+            MemoryAddress cipherName = SSL_CIPHER_get_name(cipher);
+            ciphers.add(cipherName.getUtf8String(0));
+        }
+        return ciphers.toArray(new String[0]);
+    }
+
+    public OpenSSLContext(SSLHostConfigCertificate certificate, List<String> negotiableProtocols)
+            throws SSLException {
+
+        // Check that OpenSSL was initialized
+        if (!OpenSSLStatus.isInitialized()) {
+            try {
+                OpenSSLLifecycleListener.init();
+            } catch (Exception e) {
+                throw new SSLException(e);
+            }
+        }
+
+        this.sslHostConfig = certificate.getSSLHostConfig();
+        this.certificate = certificate;
+        MemorySession contextMemorySession = MemorySession.openShared();
+
+        MemoryAddress sslCtx = MemoryAddress.NULL;
+        MemoryAddress confCtx = MemoryAddress.NULL;
+        List<byte[]> negotiableProtocolsBytes = null;
+        boolean success = false;
+        try {
+            // Create OpenSSLConfCmd context if used
+            OpenSSLConf openSslConf = sslHostConfig.getOpenSslConf();
+            if (openSslConf != null) {
+                var allocator = SegmentAllocator.newNativeArena(contextMemorySession);
+                try {
+                    if (log.isDebugEnabled()) {
+                        log.debug(sm.getString("openssl.makeConf"));
+                    }
+                    confCtx = SSL_CONF_CTX_new();
+                    long errCode = ERR_get_error();
+                    if (errCode != 0) {
+                        var buf = allocator.allocateArray(ValueLayout.JAVA_BYTE, new byte[128]);
+                        ERR_error_string(errCode, buf);
+                        log.error(sm.getString("openssl.errorLoadingCertificate", buf.getUtf8String(0)));
+                    }
+                    SSL_CONF_CTX_set_flags(confCtx, SSL_CONF_FLAG_FILE() |
+                            SSL_CONF_FLAG_SERVER() |
+                            SSL_CONF_FLAG_CERTIFICATE() |
+                            SSL_CONF_FLAG_SHOW_ERRORS());
+                } catch (Exception e) {
+                    throw new SSLException(sm.getString("openssl.errMakeConf"), e);
+                }
+            }
+
+            // SSL protocol
+            sslCtx = SSL_CTX_new(TLS_server_method());
+
+            int protocol = SSL_PROTOCOL_NONE;
+            for (String enabledProtocol : sslHostConfig.getEnabledProtocols()) {
+                if (Constants.SSL_PROTO_SSLv2Hello.equalsIgnoreCase(enabledProtocol)) {
+                    // NO-OP. OpenSSL always supports SSLv2Hello
+                } else if (Constants.SSL_PROTO_SSLv2.equalsIgnoreCase(enabledProtocol)) {
+                    protocol |= SSL_PROTOCOL_SSLV2;
+                } else if (Constants.SSL_PROTO_SSLv3.equalsIgnoreCase(enabledProtocol)) {
+                    protocol |= SSL_PROTOCOL_SSLV3;
+                } else if (Constants.SSL_PROTO_TLSv1.equalsIgnoreCase(enabledProtocol)) {
+                    protocol |= SSL_PROTOCOL_TLSV1;
+                } else if (Constants.SSL_PROTO_TLSv1_1.equalsIgnoreCase(enabledProtocol)) {
+                    protocol |= SSL_PROTOCOL_TLSV1_1;
+                } else if (Constants.SSL_PROTO_TLSv1_2.equalsIgnoreCase(enabledProtocol)) {
+                    protocol |= SSL_PROTOCOL_TLSV1_2;
+                } else if (Constants.SSL_PROTO_TLSv1_3.equalsIgnoreCase(enabledProtocol)) {
+                    protocol |= SSL_PROTOCOL_TLSV1_3;
+                } else if (Constants.SSL_PROTO_ALL.equalsIgnoreCase(enabledProtocol)) {
+                    protocol |= SSL_PROTOCOL_ALL;
+                } else {
+                    // Should not happen since filtering to build
+                    // enabled protocols removes invalid values.
+                    throw new Exception(netSm.getString(
+                            "endpoint.apr.invalidSslProtocol", enabledProtocol));
+                }
+            }
+            // Set maximum and minimum protocol versions
+            int prot = SSL2_VERSION();
+            if ((protocol & SSL_PROTOCOL_TLSV1_3) > 0) {
+                prot = TLS1_3_VERSION();
+            } else if ((protocol & SSL_PROTOCOL_TLSV1_2) > 0) {
+                prot = TLS1_2_VERSION();
+            } else if ((protocol & SSL_PROTOCOL_TLSV1_1) > 0) {
+                prot = TLS1_1_VERSION();
+            } else if ((protocol & SSL_PROTOCOL_TLSV1) > 0) {
+                prot = TLS1_VERSION();
+            } else if ((protocol & SSL_PROTOCOL_SSLV3) > 0) {
+                prot = SSL3_VERSION();
+            }
+            maxTlsVersion = prot;
+            // # define SSL_CTX_set_max_proto_version(sslCtx, version) \
+            //          SSL_CTX_ctrl(sslCtx, SSL_CTRL_SET_MAX_PROTO_VERSION, version, NULL)
+            SSL_CTX_ctrl(sslCtx, SSL_CTRL_SET_MAX_PROTO_VERSION(), prot, MemoryAddress.NULL);
+            if (prot == TLS1_3_VERSION() && (protocol & SSL_PROTOCOL_TLSV1_2) > 0) {
+                prot = TLS1_2_VERSION();
+            }
+            if (prot == TLS1_2_VERSION() && (protocol & SSL_PROTOCOL_TLSV1_1) > 0) {
+                prot = TLS1_1_VERSION();
+            }
+            if (prot == TLS1_1_VERSION() && (protocol & SSL_PROTOCOL_TLSV1) > 0) {
+                prot = TLS1_VERSION();
+            }
+            if (prot == TLS1_VERSION() && (protocol & SSL_PROTOCOL_SSLV3) > 0) {
+                prot = SSL3_VERSION();
+            }
+            minTlsVersion = prot;
+            //# define SSL_CTX_set_min_proto_version(sslCtx, version) \
+            //         SSL_CTX_ctrl(sslCtx, SSL_CTRL_SET_MIN_PROTO_VERSION, version, NULL)
+            SSL_CTX_ctrl(sslCtx, SSL_CTRL_SET_MIN_PROTO_VERSION(), prot, MemoryAddress.NULL);
+
+            // Disable compression, usually unsafe
+            SSL_CTX_set_options(sslCtx, SSL_OP_NO_COMPRESSION());
+
+            // Disallow a session from being resumed during a renegotiation,
+            // so that an acceptable cipher suite can be negotiated.
+            SSL_CTX_set_options(sslCtx, SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION());
+
+            SSL_CTX_set_options(sslCtx, SSL_OP_SINGLE_DH_USE());
+            SSL_CTX_set_options(sslCtx, SSL_OP_SINGLE_ECDH_USE());
+
+            // Default session context id and cache size
+            // # define SSL_CTX_sess_set_cache_size(sslCtx,t) \
+            //          SSL_CTX_ctrl(sslCtx,SSL_CTRL_SET_SESS_CACHE_SIZE,t,NULL)
+            SSL_CTX_ctrl(sslCtx, SSL_CTRL_SET_SESS_CACHE_SIZE(), 256, MemoryAddress.NULL);
+
+            // Session cache is disabled by default
+            // # define SSL_CTX_set_session_cache_mode(sslCtx,m) \
+            //          SSL_CTX_ctrl(sslCtx,SSL_CTRL_SET_SESS_CACHE_MODE,m,NULL)
+            SSL_CTX_ctrl(sslCtx, SSL_CTRL_SET_SESS_CACHE_MODE(), SSL_SESS_CACHE_OFF(), MemoryAddress.NULL);
+
+            // Longer session timeout
+            SSL_CTX_set_timeout(sslCtx, 14400);
+
+            // From SSLContext.make, possibly set ssl_callback_ServerNameIndication
+            // From SSLContext.make, possibly set ssl_callback_ClientHello
+            // Probably not needed
+
+            // Set int pem_password_cb(char *buf, int size, int rwflag, void *u) callback
+            openSSLCallbackPassword =
+                    Linker.nativeLinker().upcallStub(openSSLCallbackPasswordHandle,
+                    openSSLCallbackPasswordFunctionDescriptor, contextMemorySession);
+            SSL_CTX_set_default_passwd_cb(sslCtx, openSSLCallbackPassword);
+
+            alpn = (negotiableProtocols != null && negotiableProtocols.size() > 0);
+            if (alpn) {
+                negotiableProtocolsBytes = new ArrayList<>(negotiableProtocols.size() + 1);
+                for (String negotiableProtocol : negotiableProtocols) {
+                    negotiableProtocolsBytes.add(negotiableProtocol.getBytes(StandardCharsets.ISO_8859_1));
+                }
+                negotiableProtocolsBytes.add(HTTP_11_PROTOCOL);
+            }
+
+            success = true;
+        } catch(Exception e) {
+            throw new SSLException(sm.getString("openssl.errorSSLCtxInit"), e);
+        } finally {
+            state = new ContextState(contextMemorySession, sslCtx, confCtx, negotiableProtocolsBytes);
+            /*
+             * When an SSLHostConfig is replaced at runtime, it is not possible to
+             * call destroy() on the associated OpenSSLContext since it is likely
+             * that there will be in-progress connections using the OpenSSLContext.
+             * A reference chain has been deliberately established (see
+             * OpenSSLSessionContext) to ensure that the OpenSSLContext remains
+             * ineligible for GC while those connections are alive. Once those
+             * connections complete, the OpenSSLContext will become eligible for GC
+             * and the implicit scope will ensure that the associated native
+             * resources are cleaned up.
+             */
+            cleanable = cleaner.register(this, state);
+
+            if (!success) {
+                destroy();
+            }
+        }
+    }
+
+
+    public String getEnabledProtocol() {
+        return enabledProtocol;
+    }
+
+
+    public void setEnabledProtocol(String protocol) {
+        enabledProtocol = (protocol == null) ? defaultProtocol : protocol;
+    }
+
+
+    @Override
+    public void destroy() {
+        cleanable.clean();
+    }
+
+
+    private boolean checkConf(OpenSSLConf conf) throws Exception {
+        boolean result = true;
+        OpenSSLConfCmd cmd;
+        String name;
+        String value;
+        int rc;
+        for (OpenSSLConfCmd command : conf.getCommands()) {
+            cmd = command;
+            name = cmd.getName();
+            value = cmd.getValue();
+            if (name == null) {
+                log.error(sm.getString("opensslconf.noCommandName", value));
+                result = false;
+                continue;
+            }
+            if (log.isDebugEnabled()) {
+                log.debug(sm.getString("opensslconf.checkCommand", name, value));
+            }
+            try (var memorySession = MemorySession.openConfined()) {
+                // rc = SSLConf.check(confCtx, name, value);
+                if (name.equals("NO_OCSP_CHECK")) {
+                    rc = 1;
+                } else {
+                    var allocator = SegmentAllocator.newNativeArena(memorySession);
+                    int code = SSL_CONF_cmd_value_type(state.confCtx, allocator.allocateUtf8String(name));
+                    rc = 1;
+                    long errCode = ERR_get_error();
+                    if (errCode != 0) {
+                        var buf = allocator.allocateArray(ValueLayout.JAVA_BYTE, new byte[128]);
+                        ERR_error_string(errCode, buf);
+                        log.error(sm.getString("opensslconf.checkFailed", buf.getUtf8String(0)));
+                        rc = 0;
+                    }
+                    if (code == SSL_CONF_TYPE_UNKNOWN()) {
+                        log.error(sm.getString("opensslconf.typeUnknown", name));
+                        rc = 0;
+                    }
+                    if (code == SSL_CONF_TYPE_FILE()) {
+                        // Check file
+                        File file = new File(value);
+                        if (!file.isFile() && !file.canRead()) {
+                            log.error(sm.getString("opensslconf.badFile", name, value));
+                            rc = 0;
+                        }
+                    }
+                    if (code == SSL_CONF_TYPE_DIR()) {
+                        // Check dir
+                        File file = new File(value);
+                        if (!file.isDirectory()) {
+                            log.error(sm.getString("opensslconf.badDirectory", name, value));
+                            rc = 0;
+                        }
+                    }
+                }
+            } catch (Exception e) {
+                log.error(sm.getString("opensslconf.checkFailed", e.getLocalizedMessage()));
+                return false;
+            }
+            if (rc <= 0) {
+                log.error(sm.getString("opensslconf.failedCommand", name, value,
+                        Integer.toString(rc)));
+                result = false;
+            } else if (log.isDebugEnabled()) {
+                log.debug(sm.getString("opensslconf.resultCommand", name, value,
+                        Integer.toString(rc)));
+            }
+        }
+        if (!result) {
+            log.error(sm.getString("opensslconf.checkFailed"));
+        }
+        return result;
+    }
+
+
+    private boolean applyConf(OpenSSLConf conf) throws Exception {
+        boolean result = true;
+        // SSLConf.assign(confCtx, sslCtx);
+        SSL_CONF_CTX_set_ssl_ctx(state.confCtx, state.sslCtx);
+        OpenSSLConfCmd cmd;
+        String name;
+        String value;
+        int rc;
+        for (OpenSSLConfCmd command : conf.getCommands()) {
+            cmd = command;
+            name = cmd.getName();
+            value = cmd.getValue();
+            if (name == null) {
+                log.error(sm.getString("opensslconf.noCommandName", value));
+                result = false;
+                continue;
+            }
+            if (log.isDebugEnabled()) {
+                log.debug(sm.getString("opensslconf.applyCommand", name, value));
+            }
+            try (var memorySession = MemorySession.openConfined()) {
+                // rc = SSLConf.apply(confCtx, name, value);
+                if (name.equals("NO_OCSP_CHECK")) {
+                    noOcspCheck = Boolean.valueOf(value);
+                    rc = 1;
+                } else {
+                    var allocator = SegmentAllocator.newNativeArena(memorySession);
+                    rc = SSL_CONF_cmd(state.confCtx, allocator.allocateUtf8String(name),
+                            allocator.allocateUtf8String(value));
+                    long errCode = ERR_get_error();
+                    if (rc <= 0 || errCode != 0) {
+                        var buf = allocator.allocateArray(ValueLayout.JAVA_BYTE, new byte[128]);
+                        ERR_error_string(errCode, buf);
+                        log.error(sm.getString("opensslconf.commandError", name, value, buf.getUtf8String(0)));
+                        rc = 0;
+                    }
+                }
+            } catch (Exception e) {
+                log.error(sm.getString("opensslconf.applyFailed"));
+                return false;
+            }
+            if (rc <= 0) {
+                log.error(sm.getString("opensslconf.failedCommand", name, value,
+                        Integer.toString(rc)));
+                result = false;
+            } else if (log.isDebugEnabled()) {
+                log.debug(sm.getString("opensslconf.resultCommand", name, value,
+                        Integer.toString(rc)));
+            }
+        }
+        // rc = SSLConf.finish(confCtx);
+        rc = SSL_CONF_CTX_finish(state.confCtx);
+        if (rc <= 0) {
+            log.error(sm.getString("opensslconf.finishFailed", Integer.toString(rc)));
+            result = false;
+        }
+        if (!result) {
+            log.error(sm.getString("opensslconf.applyFailed"));
+        }
+        return result;
+    }
+
+    private static final int OPTIONAL_NO_CA = 3;
+
+    /**
+     * Setup the SSL_CTX.
+     *
+     * @param kms Must contain a KeyManager of the type
+     *            {@code OpenSSLKeyManager}
+     * @param tms Must contain a TrustManager of the type
+     *            {@code X509TrustManager}
+     * @param sr Is not used for this implementation.
+     */
+    @Override
+    public synchronized void init(KeyManager[] kms, TrustManager[] tms, SecureRandom sr) {
+        if (initialized) {
+            log.warn(sm.getString("openssl.doubleInit"));
+            return;
+        }
+        try {
+            if (sslHostConfig.getInsecureRenegotiation()) {
+                SSL_CTX_set_options(state.sslCtx, SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION());
+            } else {
+                SSL_CTX_clear_options(state.sslCtx, SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION());
+            }
+
+            // Use server's preference order for ciphers (rather than
+            // client's)
+            if (sslHostConfig.getHonorCipherOrder()) {
+                SSL_CTX_set_options(state.sslCtx, SSL_OP_CIPHER_SERVER_PREFERENCE());
+            } else {
+                SSL_CTX_clear_options(state.sslCtx, SSL_OP_CIPHER_SERVER_PREFERENCE());
+            }
+
+            // Disable compression if requested
+            if (sslHostConfig.getDisableCompression()) {
+                SSL_CTX_set_options(state.sslCtx, SSL_OP_NO_COMPRESSION());
+            } else {
+                SSL_CTX_clear_options(state.sslCtx, SSL_OP_NO_COMPRESSION());
+            }
+
+            // Disable TLS Session Tickets (RFC4507) to protect perfect forward secrecy
+            if (sslHostConfig.getDisableSessionTickets()) {
+                SSL_CTX_set_options(state.sslCtx, SSL_OP_NO_TICKET());
+            } else {
+                SSL_CTX_clear_options(state.sslCtx, SSL_OP_NO_TICKET());
+            }
+
+            // List the ciphers that the client is permitted to negotiate
+            if (minTlsVersion <= TLS1_2_VERSION()) {
+                if (SSL_CTX_set_cipher_list(state.sslCtx,
+                        SegmentAllocator.newNativeArena(state.contextMemorySession).allocateUtf8String(sslHostConfig.getCiphers())) <= 0) {
+                    log.warn(sm.getString("engine.failedCipherList", sslHostConfig.getCiphers()));
+                }
+            }
+            if (maxTlsVersion >= TLS1_3_VERSION() && (sslHostConfig.getCiphers() != SSLHostConfig.DEFAULT_TLS_CIPHERS)) {
+                if (SSL_CTX_set_ciphersuites(state.sslCtx,
+                        SegmentAllocator.newNativeArena(state.contextMemorySession).allocateUtf8String(sslHostConfig.getCiphers())) <= 0) {
+                    log.warn(sm.getString("engine.failedCipherSuite", sslHostConfig.getCiphers()));
+                }
+            }
+
+            if (certificate.getCertificateFile() == null) {
+                certificate.setCertificateKeyManager(OpenSSLUtil.chooseKeyManager(kms));
+            }
+
+            addCertificate(certificate);
+
+            // Client certificate verification
+            int value = 0;
+            switch (sslHostConfig.getCertificateVerification()) {
+            case NONE:
+                value = SSL_VERIFY_NONE();
+                break;
+            case OPTIONAL:
+                value = SSL_VERIFY_PEER();
+                break;
+            case OPTIONAL_NO_CA:
+                value = OPTIONAL_NO_CA;
+                break;
+            case REQUIRED:
+                value = SSL_VERIFY_FAIL_IF_NO_PEER_CERT();
+                break;
+            }
+
+            // SSLContext.setVerify(state.ctx, value, sslHostConfig.getCertificateVerificationDepth());
+            if (SSL_CTX_set_default_verify_paths(state.sslCtx) > 0) {
+                var store = SSL_CTX_get_cert_store(state.sslCtx);
+                X509_STORE_set_flags(store, 0);
+            }
+
+            // Set int verify_callback(int preverify_ok, X509_STORE_CTX *x509_ctx) callback
+            var openSSLCallbackVerify =
+                    Linker.nativeLinker().upcallStub(openSSLCallbackVerifyHandle,
+                    openSSLCallbackVerifyFunctionDescriptor, state.contextMemorySession);
+            // Leave this just in case but in Tomcat this is always set again by the engine
+            SSL_CTX_set_verify(state.sslCtx, value, openSSLCallbackVerify);
+
+            // Trust and certificate verification
+            try (var scope = MemorySession.openConfined()) {
+                var allocator = SegmentAllocator.newNativeArena(scope);
+                if (tms != null) {
+                    // Client certificate verification based on custom trust managers
+                    state.x509TrustManager = chooseTrustManager(tms);
+                    var openSSLCallbackCertVerify =
+                            Linker.nativeLinker().upcallStub(openSSLCallbackCertVerifyHandle,
+                            openSSLCallbackCertVerifyFunctionDescriptor, state.contextMemorySession);
+                    SSL_CTX_set_cert_verify_callback(state.sslCtx, openSSLCallbackCertVerify, state.sslCtx);
+
+                    // Pass along the DER encoded certificates of the accepted client
+                    // certificate issuers, so that their subjects can be presented
+                    // by the server during the handshake to allow the client choosing
+                    // an acceptable certificate
+                    for (X509Certificate caCert : state.x509TrustManager.getAcceptedIssuers()) {
+                        //SSLContext.addClientCACertificateRaw(state.ctx, caCert.getEncoded());
+                        var rawCACertificate = allocator.allocateArray(ValueLayout.JAVA_BYTE, caCert.getEncoded());
+                        var rawCACertificatePointer = allocator.allocate(ValueLayout.ADDRESS, rawCACertificate);
+                        var x509CACert = d2i_X509(MemoryAddress.NULL, rawCACertificatePointer, rawCACertificate.byteSize());
+                        if (MemoryAddress.NULL.equals(x509CACert)) {
+                            logLastError(allocator, "openssl.errorLoadingCertificate");
+                        } else if (SSL_CTX_add_client_CA(state.sslCtx, x509CACert) <= 0) {
+                            logLastError(allocator, "openssl.errorAddingCertificate");
+                        } else if (log.isDebugEnabled()) {
+                            log.debug(sm.getString("openssl.addedClientCaCert", caCert.toString()));
+                        }
+                    }
+                } else {
+                    // Client certificate verification based on trusted CA files and dirs
+                    //SSLContext.setCACertificate(state.ctx,
+                    //        SSLHostConfig.adjustRelativePath(sslHostConfig.getCaCertificateFile()),
+                    //        SSLHostConfig.adjustRelativePath(sslHostConfig.getCaCertificatePath()));
+                    MemorySegment caCertificateFileNative = sslHostConfig.getCaCertificateFile() != null
+                            ? allocator.allocateUtf8String(SSLHostConfig.adjustRelativePath(sslHostConfig.getCaCertificateFile())) : null;
+                    MemorySegment caCertificatePathNative = sslHostConfig.getCaCertificatePath() != null
+                            ? allocator.allocateUtf8String(SSLHostConfig.adjustRelativePath(sslHostConfig.getCaCertificatePath())) : null;
+                    if ((sslHostConfig.getCaCertificateFile() != null || sslHostConfig.getCaCertificatePath() != null) 
+                            && SSL_CTX_load_verify_locations(state.sslCtx,
+                                    caCertificateFileNative == null ? MemoryAddress.NULL : caCertificateFileNative,
+                                    caCertificatePathNative == null ? MemoryAddress.NULL : caCertificatePathNative) <= 0) {
+                        logLastError(allocator, "openssl.errorConfiguringLocations");
+                    } else {
+                        var caCerts = SSL_CTX_get_client_CA_list(state.sslCtx);
+                        if (MemoryAddress.NULL.equals(caCerts)) {
+                            caCerts = SSL_load_client_CA_file(caCertificateFileNative == null ? MemoryAddress.NULL : caCertificateFileNative);
+                            if (!MemoryAddress.NULL.equals(caCerts)) {
+                                SSL_CTX_set_client_CA_list(state.sslCtx, caCerts);
+                            }
+                        } else {
+                            if (SSL_add_file_cert_subjects_to_stack(caCerts,
+                                    caCertificateFileNative == null ? MemoryAddress.NULL : caCertificateFileNative) <= 0) {
+                                caCerts = MemoryAddress.NULL;
+                            }
+                        }
+                        if (MemoryAddress.NULL.equals(caCerts)) {
+                            log.warn(sm.getString("openssl.noCACerts"));
+                        }
+                    }
+                }
+            }
+
+            if (state.negotiableProtocols != null && state.negotiableProtocols.size() > 0) {
+                // int openSSLCallbackAlpnSelectProto(MemoryAddress ssl, MemoryAddress out, MemoryAddress outlen,
+                //        MemoryAddress in, int inlen, MemoryAddress arg
+                var openSSLCallbackAlpnSelectProto =
+                        Linker.nativeLinker().upcallStub(openSSLCallbackAlpnSelectProtoHandle,
+                        openSSLCallbackAlpnSelectProtoFunctionDescriptor, state.contextMemorySession);
+                SSL_CTX_set_alpn_select_cb(state.sslCtx, openSSLCallbackAlpnSelectProto, state.sslCtx);
+                // Skip NPN (annoying and likely not useful anymore)
+                //SSLContext.setNpnProtos(state.ctx, protocolsArray, SSL.SSL_SELECTOR_FAILURE_NO_ADVERTISE);
+            }
+
+            // Apply OpenSSLConfCmd if used
+            OpenSSLConf openSslConf = sslHostConfig.getOpenSslConf();
+            if (openSslConf != null && !MemoryAddress.NULL.equals(state.confCtx)) {
+                // Check OpenSSLConfCmd if used
+                if (log.isDebugEnabled()) {
+                    log.debug(sm.getString("openssl.checkConf"));
+                }
+                try {
+                    if (!checkConf(openSslConf)) {
+                        log.error(sm.getString("openssl.errCheckConf"));
+                        throw new Exception(sm.getString("openssl.errCheckConf"));
+                    }
+                } catch (Exception e) {
+                    throw new Exception(sm.getString("openssl.errCheckConf"), e);
+                }
+                if (log.isDebugEnabled()) {
+                    log.debug(sm.getString("openssl.applyConf"));
+                }
+                try {
+                    if (!applyConf(openSslConf)) {
+                        log.error(sm.getString("openssl.errApplyConf"));
+                        throw new SSLException(sm.getString("openssl.errApplyConf"));
+                    }
+                } catch (Exception e) {
+                    throw new SSLException(sm.getString("openssl.errApplyConf"), e);
+                }
+                // Reconfigure the enabled protocols
+                long opts = SSL_CTX_get_options(state.sslCtx);
+                List<String> enabled = new ArrayList<>();
+                // Seems like there is no way to explicitly disable SSLv2Hello
+                // in OpenSSL so it is always enabled
+                enabled.add(Constants.SSL_PROTO_SSLv2Hello);
+                if ((opts & SSL_OP_NO_TLSv1()) == 0) {
+                    enabled.add(Constants.SSL_PROTO_TLSv1);
+                }
+                if ((opts & SSL_OP_NO_TLSv1_1()) == 0) {
+                    enabled.add(Constants.SSL_PROTO_TLSv1_1);
+                }
+                if ((opts & SSL_OP_NO_TLSv1_2()) == 0) {
+                    enabled.add(Constants.SSL_PROTO_TLSv1_2);
+                }
+                if ((opts & SSL_OP_NO_TLSv1_3()) == 0) {
+                    enabled.add(Constants.SSL_PROTO_TLSv1_3);
+                }
+                if ((opts & SSL_OP_NO_SSLv2()) == 0) {
+                    enabled.add(Constants.SSL_PROTO_SSLv2);
+                }
+                if ((opts & SSL_OP_NO_SSLv3()) == 0) {
+                    enabled.add(Constants.SSL_PROTO_SSLv3);
+                }
+                sslHostConfig.setEnabledProtocols(
+                        enabled.toArray(new String[0]));
+                // Reconfigure the enabled ciphers
+                sslHostConfig.setEnabledCiphers(getCiphers(state.sslCtx));
+            }
+
+            sessionContext = new OpenSSLSessionContext(this);
+            // If client authentication is being used, OpenSSL requires that
+            // this is set so always set it in case an app is configured to
+            // require it
+            sessionContext.setSessionIdContext(DEFAULT_SESSION_ID_CONTEXT);
+            sslHostConfig.setOpenSslContext(state.sslCtx.toRawLongValue());
+            initialized = true;
+        } catch (Exception e) {
+            log.warn(sm.getString("openssl.errorSSLCtxInit"), e);
+            destroy();
+        }
+    }
+
+
+    public MemoryAddress getSSLContext() {
+        return state.sslCtx;
+    }
+
+    // DH *(*tmp_dh_callback)(SSL *ssl, int is_export, int keylength)
+    public static Addressable openSSLCallbackTmpDH(MemoryAddress ssl, int isExport, int keylength) {
+        var pkey = SSL_get_privatekey(ssl);
+        int type = (MemoryAddress.NULL.equals(pkey)) ? EVP_PKEY_NONE() : EVP_PKEY_base_id(pkey);
+        /*
+         * OpenSSL will call us with either keylen == 512 or keylen == 1024
+         * (see the definition of SSL_EXPORT_PKEYLENGTH in ssl_locl.h).
+         * Adjust the DH parameter length according to the size of the
+         * RSA/DSA private key used for the current connection, and always
+         * use at least 1024-bit parameters.
+         * Note: This may cause interoperability issues with implementations
+         * which limit their DH support to 1024 bit - e.g. Java 7 and earlier.
+         * In this case, SSLCertificateFile can be used to specify fixed
+         * 1024-bit DH parameters (with the effect that OpenSSL skips this
+         * callback).
+         */
+        int keylen = 0;
+        if ((type == EVP_PKEY_RSA()) || (type == EVP_PKEY_DSA())) {
+            keylen = EVP_PKEY_bits(pkey);
+        }
+        for (int i = 0; i < OpenSSLLifecycleListener.dhParameters.length; i++) {
+            if (keylen >= OpenSSLLifecycleListener.dhParameters[i].min) {
+                return OpenSSLLifecycleListener.dhParameters[i].dh;
+            }
+        }
+        return MemoryAddress.NULL;
+    }
+
+    // int SSL_callback_alpn_select_proto(SSL* ssl, const unsigned char **out, unsigned char *outlen,
+    //        const unsigned char *in, unsigned int inlen, void *arg)
+    public static int openSSLCallbackAlpnSelectProto(MemoryAddress ssl, MemoryAddress out, MemoryAddress outlen,
+            MemoryAddress in, int inlen, MemoryAddress arg) {
+        ContextState state = getState(arg);
+        if (state == null) {
+            log.warn(sm.getString("context.noSSL", Long.valueOf(arg.toRawLongValue())));
+            return SSL_TLSEXT_ERR_NOACK();
+        }
+        // No scope, so byte by byte read, the ALPN data is small
+        byte[] advertisedBytes = new byte[inlen];
+        for (int i = 0; i < inlen; i++) {
+            advertisedBytes[i] = in.get(ValueLayout.JAVA_BYTE, i);
+        }
+        for (byte[] negotiableProtocolBytes : state.negotiableProtocols) {
+            for (int i = 0; i <= advertisedBytes.length - negotiableProtocolBytes.length; i++) {
+                if (advertisedBytes[i] == negotiableProtocolBytes[0]) {
+                    for (int j = 0; j < negotiableProtocolBytes.length; j++) {
+                        if (advertisedBytes[i + j] == negotiableProtocolBytes[j]) {
+                            if (j == negotiableProtocolBytes.length - 1) {
+                                // Match
+                                out.set(ValueLayout.ADDRESS, 0, in.addOffset(i));
+                                outlen.set(ValueLayout.JAVA_BYTE, 0, (byte) negotiableProtocolBytes.length);
+                                return SSL_TLSEXT_ERR_OK();
+                            }
+                        } else {
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+        return SSL_TLSEXT_ERR_NOACK();
+    }
+
+    public static int openSSLCallbackVerify(int preverify_ok, MemoryAddress /*X509_STORE_CTX*/ x509ctx) {
+        return OpenSSLEngine.openSSLCallbackVerify(preverify_ok, x509ctx);
+    }
+
+
+    public static int openSSLCallbackCertVerify(MemoryAddress /*X509_STORE_CTX*/ x509_ctx, MemoryAddress param) {
+        if (log.isDebugEnabled()) {
+            log.debug("Certificate verification");
+        }
+        if (MemoryAddress.NULL.equals(param)) {
+            return 0;
+        }
+        ContextState state = getState(param);
+        if (state == null) {
+            log.warn(sm.getString("context.noSSL", Long.valueOf(param.toRawLongValue())));
+            return 0;
+        }
+        MemoryAddress ssl = X509_STORE_CTX_get_ex_data(x509_ctx, SSL_get_ex_data_X509_STORE_CTX_idx());
+        MemoryAddress /*STACK_OF(X509)*/ sk = X509_STORE_CTX_get0_untrusted(x509_ctx);
+        int len = OPENSSL_sk_num(sk);
+        byte[][] certificateChain = new byte[len][];
+        try (var memorySession = MemorySession.openConfined()) {
+            var allocator = SegmentAllocator.newNativeArena(memorySession);
+            for (int i = 0; i < len; i++) {
+                MemoryAddress/*(X509*)*/ x509 = OPENSSL_sk_value(sk, i);
+                MemorySegment bufPointer = allocator.allocate(ValueLayout.ADDRESS, MemoryAddress.NULL);
+                int length = i2d_X509(x509, bufPointer);
+                if (length < 0) {
+                    certificateChain[i] = new byte[0];
+                    continue;
+                }
+                MemoryAddress buf = bufPointer.get(ValueLayout.ADDRESS, 0);
+                certificateChain[i] = MemorySegment.ofAddress(buf, length, memorySession).toArray(ValueLayout.JAVA_BYTE);
+                CRYPTO_free(buf, MemoryAddress.NULL, 0); // OPENSSL_free macro
+            }
+            MemoryAddress cipher = SSL_get_current_cipher(ssl);
+            String authMethod = (MemoryAddress.NULL.equals(cipher)) ? "UNKNOWN"
+                    : getCipherAuthenticationMethod(SSL_CIPHER_get_auth_nid(cipher), SSL_CIPHER_get_kx_nid(cipher));
+            X509Certificate[] peerCerts = certificates(certificateChain);
+            try {
+                state.x509TrustManager.checkClientTrusted(peerCerts, authMethod);
+                return 1;
+            } catch (Exception e) {
+                log.debug(sm.getString("openssl.certificateVerificationFailed"), e);
+            }
+        }
+        return 0;
+    }
+
+    private static final int NID_kx_rsa = 1037/*NID_kx_rsa()*/;
+    //private static final int NID_kx_dhe = NID_kx_dhe();
+    //private static final int NID_kx_ecdhe = NID_kx_ecdhe();
+
+    //private static final int NID_auth_rsa = NID_auth_rsa();
+    //private static final int NID_auth_dss = NID_auth_dss();
+    //private static final int NID_auth_null = NID_auth_null();
+    //private static final int NID_auth_ecdsa = NID_auth_ecdsa();
+
+    //private static final int SSL_kRSA = 1;
+    private static final int SSL_kDHr = 2;
+    private static final int SSL_kDHd = 4;
+    private static final int SSL_kEDH = 8;
+    private static final int SSL_kDHE = SSL_kEDH;
+    private static final int SSL_kKRB5 = 10;
+    private static final int SSL_kECDHr = 20;
+    private static final int SSL_kECDHe = 40;
+    private static final int SSL_kEECDH = 80;
+    private static final int SSL_kECDHE = SSL_kEECDH;
+    //private static final int SSL_kPSK = 100;
+    //private static final int SSL_kGOST = 200;
+    //private static final int SSL_kSRP = 400;
+
+    private static final int SSL_aRSA = 1;
+    private static final int SSL_aDSS = 2;
+    private static final int SSL_aNULL = 4;
+    //private static final int SSL_aDH = 8;
+    //private static final int SSL_aECDH = 10;
+    //private static final int SSL_aKRB5 = 20;
+    private static final int SSL_aECDSA = 40;
+    //private static final int SSL_aPSK = 80;
+    //private static final int SSL_aGOST94 = 100;
+    //private static final int SSL_aGOST01 = 200;
+    //private static final int SSL_aSRP = 400;
+
+    private static final String SSL_TXT_RSA = "RSA";
+    private static final String SSL_TXT_DH = "DH";
+    private static final String SSL_TXT_DSS = "DSS";
+    private static final String SSL_TXT_KRB5 = "KRB5";
+    private static final String SSL_TXT_ECDH = "ECDH";
+    private static final String SSL_TXT_ECDSA = "ECDSA";
+
+    private static String getCipherAuthenticationMethod(int auth, int kx) {
+        switch (kx) {
+        case NID_kx_rsa:
+            return SSL_TXT_RSA;
+        case SSL_kDHr:
+            return SSL_TXT_DH + "_" + SSL_TXT_RSA;
+        case SSL_kDHd:
+            return SSL_TXT_DH + "_" + SSL_TXT_DSS;
+        case SSL_kDHE:
+            switch (auth) {
+            case SSL_aDSS:
+                return "DHE_" + SSL_TXT_DSS;
+            case SSL_aRSA:
+                return "DHE_" + SSL_TXT_RSA;
+            case SSL_aNULL:
+                return SSL_TXT_DH + "_anon";
+            default:
+                return "UNKNOWN";
+            }
+        case SSL_kKRB5:
+            return SSL_TXT_KRB5;
+        case SSL_kECDHr:
+            return SSL_TXT_ECDH + "_" + SSL_TXT_RSA;
+        case SSL_kECDHe:
+            return SSL_TXT_ECDH + "_" + SSL_TXT_ECDSA;
+        case SSL_kECDHE:
+            switch (auth) {
+            case SSL_aECDSA:
+                return "ECDHE_" + SSL_TXT_ECDSA;
+            case SSL_aRSA:
+                return "ECDHE_" + SSL_TXT_RSA;
+            case SSL_aNULL:
+                return SSL_TXT_ECDH + "_anon";
+            default:
+                return "UNKNOWN";
+            }
+        default:
+            return "UNKNOWN";
+        }
+    }
+
+    private static ThreadLocal<String> callbackPasswordTheadLocal = new ThreadLocal<>();
+
+    public static int openSSLCallbackPassword(MemoryAddress /*char **/ buf, int bufsiz, int verify, MemoryAddress /*void **/ cb) {
+        if (log.isDebugEnabled()) {
+            log.debug("Return password for certificate");
+        }
+        String callbackPassword = callbackPasswordTheadLocal.get();
+        if (callbackPassword != null && callbackPassword.length() > 0) {
+            try (var memorySession = MemorySession.openConfined()) {
+                var allocator = SegmentAllocator.newNativeArena(memorySession);
+                MemorySegment callbackPasswordNative = allocator.allocateUtf8String(callbackPassword);
+                if (callbackPasswordNative.byteSize() > bufsiz) {
+                    // The password is too long
+                    log.error(sm.getString("openssl.passwordTooLong"));
+                } else {
+                    MemorySegment bufSegment = MemorySegment.ofAddress(buf, bufsiz, memorySession);
+                    bufSegment.copyFrom(callbackPasswordNative);
+                    return (int) callbackPasswordNative.byteSize();
+                }
+            }
+        }
+        return 0;
+    }
+
+
+    private void addCertificate(SSLHostConfigCertificate certificate) throws Exception {
+        var allocator = SegmentAllocator.newNativeArena(state.contextMemorySession);
+        int index = getCertificateIndex(certificate);
+        // Load Server key and certificate
+        if (certificate.getCertificateFile() != null) {
+            // Set certificate
+            //SSLContext.setCertificate(state.ctx,
+            //        SSLHostConfig.adjustRelativePath(certificate.getCertificateFile()),
+            //        SSLHostConfig.adjustRelativePath(certificate.getCertificateKeyFile()),
+            //        certificate.getCertificateKeyPassword(), getCertificateIndex(certificate));
+            var certificateFileNative = allocator.allocateUtf8String(SSLHostConfig.adjustRelativePath(certificate.getCertificateFile()));
+            var certificateKeyFileNative = (certificate.getCertificateKeyFile() == null) ? certificateFileNative
+                    : allocator.allocateUtf8String(SSLHostConfig.adjustRelativePath(certificate.getCertificateKeyFile()));
+            MemoryAddress bio;
+            MemoryAddress cert = MemoryAddress.NULL;
+            MemoryAddress key = MemoryAddress.NULL;
+            if (certificate.getCertificateFile().endsWith(".pkcs12")) {
+                // Load pkcs12
+                bio = BIO_new(BIO_s_file());
+                //#  define BIO_read_filename(b,name)
+                //        (int)BIO_ctrl(b,BIO_C_SET_FILENAME, BIO_CLOSE|BIO_FP_READ,(char *)(name))
+                if (BIO_ctrl(bio, BIO_C_SET_FILENAME(), BIO_CLOSE() | BIO_FP_READ(), certificateFileNative) <= 0) {
+                    BIO_free(bio);
+                    log.error(sm.getString("openssl.errorLoadingCertificate", "[0]:" + certificate.getCertificateFile()));
+                    return;
+                }
+                MemoryAddress p12 = d2i_PKCS12_bio(bio, MemoryAddress.NULL);
+                BIO_free(bio);
+                if (MemoryAddress.NULL.equals(p12)) {
+                    log.error(sm.getString("openssl.errorLoadingCertificate", "[1]:" + certificate.getCertificateFile()));
+                    return;
+                }
+                MemoryAddress passwordAddress = MemoryAddress.NULL;
+                int passwordLength = 0;
+                String callbackPassword = certificate.getCertificateKeyPassword();
+                if (callbackPassword != null && callbackPassword.length() > 0) {
+                    MemorySegment password = allocator.allocateUtf8String(callbackPassword);
+                    passwordAddress = password.address();
+                    passwordLength = (int) (password.byteSize() - 1);
+                }
+                if (PKCS12_verify_mac(p12, passwordAddress, passwordLength) <= 0) {
+                    // Bad password
+                    log.error(sm.getString("openssl.errorLoadingCertificate", "[2]:" + certificate.getCertificateFile()));
+                    PKCS12_free(p12);
+                    return;
+                }
+                MemorySegment certPointer = allocator.allocate(ValueLayout.ADDRESS);
+                MemorySegment keyPointer = allocator.allocate(ValueLayout.ADDRESS);
+                if (PKCS12_parse(p12, passwordAddress, keyPointer, certPointer, MemoryAddress.NULL) <= 0) {
+                    log.error(sm.getString("openssl.errorLoadingCertificate", "[3]:" + certificate.getCertificateFile()));
+                    PKCS12_free(p12);
+                    return;
+                }
+                PKCS12_free(p12);
+                cert = certPointer.get(ValueLayout.ADDRESS, 0);
+                key = keyPointer.get(ValueLayout.ADDRESS, 0);
+            } else {
+                // Load key
+                bio = BIO_new(BIO_s_file());
+                //#  define BIO_read_filename(b,name)
+                //        (int)BIO_ctrl(b,BIO_C_SET_FILENAME, BIO_CLOSE|BIO_FP_READ,(char *)(name))
+                if (BIO_ctrl(bio, BIO_C_SET_FILENAME(), BIO_CLOSE() | BIO_FP_READ(), certificateKeyFileNative) <= 0) {
+                    BIO_free(bio);
+                    log.error(sm.getString("openssl.errorLoadingCertificate", certificate.getCertificateKeyFile()));
+                    return;
+                }
+                key = MemoryAddress.NULL;
+                for (int i = 0; i < 3; i++) {
+                    try {
+                        callbackPasswordTheadLocal.set(certificate.getCertificateKeyPassword());
+                        key = PEM_read_bio_PrivateKey(bio, MemoryAddress.NULL, openSSLCallbackPassword, MemoryAddress.NULL);
+                    } finally {
+                        callbackPasswordTheadLocal.set(null);
+                    }
+                    if (!MemoryAddress.NULL.equals(key)) {
+                        break;
+                    }
+                    BIO_ctrl(bio, BIO_CTRL_RESET(), 0, MemoryAddress.NULL);
+                }
+                BIO_free(bio);
+                if (MemoryAddress.NULL.equals(key)) {
+                    if (!MemoryAddress.NULL.equals(OpenSSLLifecycleListener.enginePointer)) {
+                        key = ENGINE_load_private_key(OpenSSLLifecycleListener.enginePointer, certificateKeyFileNative,
+                                MemoryAddress.NULL, MemoryAddress.NULL);
+                    }
+                }
+                if (MemoryAddress.NULL.equals(key)) {
+                    log.error(sm.getString("openssl.errorLoadingCertificate", certificate.getCertificateKeyFile()));
+                    return;
+                }
+                // Load certificate
+                bio = BIO_new(BIO_s_file());
+                if (BIO_ctrl(bio, BIO_C_SET_FILENAME(), BIO_CLOSE() | BIO_FP_READ(), certificateFileNative) <= 0) {
+                    BIO_free(bio);
+                    log.error(sm.getString("openssl.errorLoadingCertificate", certificate.getCertificateFile()));
+                    return;
+                }
+                try {
+                    callbackPasswordTheadLocal.set(certificate.getCertificateKeyPassword());
+                    cert = PEM_read_bio_X509_AUX(bio, MemoryAddress.NULL, openSSLCallbackPassword, MemoryAddress.NULL);
+                } finally {
+                    callbackPasswordTheadLocal.set(null);
+                }
+                if (MemoryAddress.NULL.equals(cert) &&
+                        // Missing ERR_GET_REASON(ERR_peek_last_error())
+                        /*int ERR_GET_REASON(unsigned long errcode) {
+                         *    if (ERR_SYSTEM_ERROR(errcode))
+                         *        return errcode & ERR_SYSTEM_MASK;
+                         *    return errcode & ERR_REASON_MASK;
+                         *}
+                         *# define ERR_SYSTEM_ERROR(errcode)      (((errcode) & ERR_SYSTEM_FLAG) != 0)
+                         *# define ERR_SYSTEM_FLAG                ((unsigned int)INT_MAX + 1)
+                         *# define ERR_SYSTEM_MASK                ((unsigned int)INT_MAX)
+                         *# define ERR_REASON_MASK                0X7FFFFF
+                         */
+                        ((ERR_peek_last_error() & 0X7FFFFF) == PEM_R_NO_START_LINE())) {
+                    ERR_clear_error();
+                    BIO_ctrl(bio, BIO_CTRL_RESET(), 0, MemoryAddress.NULL);
+                    cert = d2i_X509_bio(bio, MemoryAddress.NULL);
+                }
+                BIO_free(bio);
+                if (MemoryAddress.NULL.equals(cert)) {
+                    log.error(sm.getString("openssl.errorLoadingCertificate", certificate.getCertificateFile()));
+                    return;
+                }
+            }
+            if (SSL_CTX_use_certificate(state.sslCtx, cert) <= 0) {
+                logLastError(allocator, "openssl.errorLoadingCertificate");
+                return;
+            }
+            if (SSL_CTX_use_PrivateKey(state.sslCtx, key) <= 0) {
+                logLastError(allocator, "openssl.errorLoadingPrivateKey");
+                return;
+            }
+            if (SSL_CTX_check_private_key(state.sslCtx) <= 0) {
+                logLastError(allocator, "openssl.errorPrivateKeyCheck");
+                return;
+            }
+            // Try to read DH parameters from the (first) SSLCertificateFile
+            if (index == SSL_AIDX_RSA) {
+                bio = BIO_new_file(certificateFileNative, allocator.allocateUtf8String("r"));
+                var dh = PEM_read_bio_DHparams(bio, MemoryAddress.NULL, MemoryAddress.NULL, MemoryAddress.NULL);
+                BIO_free(bio);
+                // #  define SSL_CTX_set_tmp_dh(sslCtx,dh) \
+                //           SSL_CTX_ctrl(sslCtx,SSL_CTRL_SET_TMP_DH,0,(char *)(dh))
+                if (!MemoryAddress.NULL.equals(dh)) {
+                    SSL_CTX_ctrl(state.sslCtx, SSL_CTRL_SET_TMP_DH(), 0, dh);
+                    DH_free(dh);
+                }
+            }
+            // Similarly, try to read the ECDH curve name from SSLCertificateFile...
+            bio = BIO_new_file(certificateFileNative, allocator.allocateUtf8String("r"));
+            var ecparams = PEM_read_bio_ECPKParameters(bio, MemoryAddress.NULL, MemoryAddress.NULL, MemoryAddress.NULL);
+            BIO_free(bio);
+            if (!MemoryAddress.NULL.equals(ecparams)) {
+                int nid = EC_GROUP_get_curve_name(ecparams);
+                var eckey = EC_KEY_new_by_curve_name(nid);
+                // #  define SSL_CTX_set_tmp_ecdh(sslCtx,ecdh) \
+                //           SSL_CTX_ctrl(sslCtx,SSL_CTRL_SET_TMP_ECDH,0,(char *)(ecdh))
+                SSL_CTX_ctrl(state.sslCtx, SSL_CTRL_SET_TMP_ECDH(), 0, eckey);
+                EC_KEY_free(eckey);
+                EC_GROUP_free(ecparams);
+            }
+            // Set callback for DH parameters
+            var openSSLCallbackTmpDH = Linker.nativeLinker().upcallStub(openSSLCallbackTmpDHHandle,
+                    openSSLCallbackTmpDHFunctionDescriptor, state.contextMemorySession);
+            SSL_CTX_set_tmp_dh_callback(state.sslCtx, openSSLCallbackTmpDH);
+            // Set certificate chain file
+            if (certificate.getCertificateChainFile() != null) {
+                var certificateChainFileNative =
+                        allocator.allocateUtf8String(SSLHostConfig.adjustRelativePath(certificate.getCertificateChainFile()));
+                // SSLContext.setCertificateChainFile(state.ctx,
+                //        SSLHostConfig.adjustRelativePath(certificate.getCertificateChainFile()), false);
+                if (SSL_CTX_use_certificate_chain_file(state.sslCtx, certificateChainFileNative) <= 0) {
+                    log.error(sm.getString("openssl.errorLoadingCertificate", certificate.getCertificateChainFile()));
+                }
+            }
+            // Set revocation
+            //SSLContext.setCARevocation(state.ctx,
+            //        SSLHostConfig.adjustRelativePath(
+            //                sslHostConfig.getCertificateRevocationListFile()),
+            //        SSLHostConfig.adjustRelativePath(
+            //                sslHostConfig.getCertificateRevocationListPath()));
+            MemoryAddress certificateStore = SSL_CTX_get_cert_store(state.sslCtx);
+            if (sslHostConfig.getCertificateRevocationListFile() != null) {
+                MemoryAddress x509Lookup = X509_STORE_add_lookup(certificateStore, X509_LOOKUP_file());
+                var certificateRevocationListFileNative =
+                        allocator.allocateUtf8String(SSLHostConfig.adjustRelativePath(sslHostConfig.getCertificateRevocationListFile()));
+                //X509_LOOKUP_ctrl(lookup,X509_L_FILE_LOAD,file,type,NULL)
+                if (X509_LOOKUP_ctrl(x509Lookup, X509_L_FILE_LOAD(), certificateRevocationListFileNative,
+                        X509_FILETYPE_PEM(), MemoryAddress.NULL) <= 0) {
+                    log.error(sm.getString("openssl.errorLoadingCertificateRevocationList", sslHostConfig.getCertificateRevocationListFile()));
+                }
+            }
+            if (sslHostConfig.getCertificateRevocationListPath() != null) {
+                MemoryAddress x509Lookup = X509_STORE_add_lookup(certificateStore, X509_LOOKUP_hash_dir());
+                var certificateRevocationListPathNative =
+                        allocator.allocateUtf8String(SSLHostConfig.adjustRelativePath(sslHostConfig.getCertificateRevocationListPath()));
+                //X509_LOOKUP_ctrl(lookup,X509_L_ADD_DIR,path,type,NULL)
+                if (X509_LOOKUP_ctrl(x509Lookup, X509_L_ADD_DIR(), certificateRevocationListPathNative,
+                        X509_FILETYPE_PEM(), MemoryAddress.NULL) <= 0) {
+                    log.error(sm.getString("openssl.errorLoadingCertificateRevocationList", sslHostConfig.getCertificateRevocationListPath()));
+                }
+            }
+            X509_STORE_set_flags(certificateStore, X509_V_FLAG_CRL_CHECK() | X509_V_FLAG_CRL_CHECK_ALL());
+        } else {
+            String alias = certificate.getCertificateKeyAlias();
+            X509KeyManager x509KeyManager = certificate.getCertificateKeyManager();
+            if (alias == null) {
+                alias = "tomcat";
+            }
+            X509Certificate[] chain = x509KeyManager.getCertificateChain(alias);
+            if (chain == null) {
+                alias = findAlias(x509KeyManager, certificate);
+                chain = x509KeyManager.getCertificateChain(alias);
+            }
+            PrivateKey key = x509KeyManager.getPrivateKey(alias);
+            StringBuilder sb = new StringBuilder(BEGIN_KEY);
+            sb.append(Base64.getMimeEncoder(64, new byte[] {'\n'}).encodeToString(key.getEncoded()));
+            sb.append(END_KEY);
+            //SSLContext.setCertificateRaw(state.ctx, chain[0].getEncoded(),
+            //        sb.toString().getBytes(StandardCharsets.US_ASCII),
+            //        getCertificateIndex(certificate));
+            var rawCertificate = allocator.allocateArray(ValueLayout.JAVA_BYTE, chain[0].getEncoded());
+            var rawCertificatePointer = allocator.allocate(ValueLayout.ADDRESS, rawCertificate);
+            var rawKey = allocator.allocateArray(ValueLayout.JAVA_BYTE, sb.toString().getBytes(StandardCharsets.US_ASCII));
+            var x509cert = d2i_X509(MemoryAddress.NULL, rawCertificatePointer, rawCertificate.byteSize());
+            if (MemoryAddress.NULL.equals(x509cert)) {
+                logLastError(allocator, "openssl.errorLoadingCertificate");
+                return;
+            }
+            var bio = BIO_new(BIO_s_mem());
+            BIO_write(bio, rawKey.address(), (int) rawKey.byteSize());
+            MemoryAddress privateKeyAddress = PEM_read_bio_PrivateKey(bio, MemoryAddress.NULL, MemoryAddress.NULL, MemoryAddress.NULL);
+            BIO_free(bio);
+            if (MemoryAddress.NULL.equals(privateKeyAddress)) {
+                logLastError(allocator, "openssl.errorLoadingPrivateKey");
+                return;
+            }
+            if (SSL_CTX_use_certificate(state.sslCtx, x509cert) <= 0) {
+                logLastError(allocator, "openssl.errorLoadingCertificate");
+                return;
+            }
+            if (SSL_CTX_use_PrivateKey(state.sslCtx, privateKeyAddress) <= 0) {
+                logLastError(allocator, "openssl.errorLoadingPrivateKey");
+                return;
+            }
+            if (SSL_CTX_check_private_key(state.sslCtx) <= 0) {
+                logLastError(allocator, "openssl.errorPrivateKeyCheck");
+                return;
+            }
+            // Set callback for DH parameters
+            var openSSLCallbackTmpDH = Linker.nativeLinker().upcallStub(openSSLCallbackTmpDHHandle,
+                    openSSLCallbackTmpDHFunctionDescriptor, state.contextMemorySession);
+            SSL_CTX_set_tmp_dh_callback(state.sslCtx, openSSLCallbackTmpDH);
+            for (int i = 1; i < chain.length; i++) {
+                //SSLContext.addChainCertificateRaw(state.ctx, chain[i].getEncoded());
+                var rawCertificateChain = allocator.allocateArray(ValueLayout.JAVA_BYTE, chain[i].getEncoded());
+                var rawCertificateChainPointer = allocator.allocate(ValueLayout.ADDRESS, rawCertificateChain);
+                var x509certChain = d2i_X509(MemoryAddress.NULL, rawCertificateChainPointer, rawCertificateChain.byteSize());
+                if (MemoryAddress.NULL.equals(x509certChain)) {
+                    logLastError(allocator, "openssl.errorLoadingCertificate");
+                    return;
+                }
+                // # define SSL_CTX_add0_chain_cert(sslCtx,x509) SSL_CTX_ctrl(sslCtx,SSL_CTRL_CHAIN_CERT,0,(char *)(x509))
+                if (SSL_CTX_ctrl(state.sslCtx, SSL_CTRL_CHAIN_CERT(), 0, x509certChain) <= 0) {
+                    logLastError(allocator, "openssl.errorAddingCertificate");
+                    return;
+                }
+            }
+        }
+    }
+
+
+    private static int getCertificateIndex(SSLHostConfigCertificate certificate) {
+        int result = -1;
+        // If the type is undefined there will only be one certificate (enforced
+        // in SSLHostConfig) so use the RSA slot.
+        if (certificate.getType() == Type.RSA || certificate.getType() == Type.UNDEFINED) {
+            result = SSL_AIDX_RSA;
+        } else if (certificate.getType() == Type.EC) {
+            result = SSL_AIDX_ECC;
+        } else if (certificate.getType() == Type.DSA) {
+            result = SSL_AIDX_DSA;
+        } else {
+            result = SSL_AIDX_MAX;
+        }
+        return result;
+    }
+
+
+    /*
+     * Find a valid alias when none was specified in the config.
+     */
+    private static String findAlias(X509KeyManager keyManager,
+            SSLHostConfigCertificate certificate) {
+
+        Type type = certificate.getType();
+        String result = null;
+
+        List<Type> candidateTypes = new ArrayList<>();
+        if (Type.UNDEFINED.equals(type)) {
+            // Try all types to find an suitable alias
+            candidateTypes.addAll(Arrays.asList(Type.values()));
+            candidateTypes.remove(Type.UNDEFINED);
+        } else {
+            // Look for the specific type to find a suitable alias
+            candidateTypes.add(type);
+        }
+
+        Iterator<Type> iter = candidateTypes.iterator();
+        while (result == null && iter.hasNext()) {
+            result = keyManager.chooseServerAlias(iter.next().toString(),  null,  null);
+        }
+
+        return result;
+    }
+
+    private static X509TrustManager chooseTrustManager(TrustManager[] managers) {
+        for (TrustManager m : managers) {
+            if (m instanceof X509TrustManager) {
+                return (X509TrustManager) m;
+            }
+        }
+        throw new IllegalStateException(sm.getString("openssl.trustManagerMissing"));
+    }
+
+    private static X509Certificate[] certificates(byte[][] chain) {
+        X509Certificate[] peerCerts = new X509Certificate[chain.length];
+        for (int i = 0; i < peerCerts.length; i++) {
+            peerCerts[i] = new OpenSSLX509Certificate(chain[i]);
+        }
+        return peerCerts;
+    }
+
+
+    private static void logLastError(SegmentAllocator allocator, String string) {
+        var buf = allocator.allocateArray(ValueLayout.JAVA_BYTE, new byte[128]);
+        ERR_error_string(ERR_get_error(), buf);
+        String err = buf.getUtf8String(0);
+        log.error(sm.getString(string, err));
+    }
+
+
+    @Override
+    public SSLSessionContext getServerSessionContext() {
+        return sessionContext;
+    }
+
+    @Override
+    public synchronized SSLEngine createSSLEngine() {
+        return new OpenSSLEngine(state.sslCtx, defaultProtocol, false, sessionContext,
+                alpn, initialized,
+                sslHostConfig.getCertificateVerificationDepth(),
+                sslHostConfig.getCertificateVerification() == CertificateVerification.OPTIONAL_NO_CA,
+                noOcspCheck);
+    }
+
+    @Override
+    public SSLServerSocketFactory getServerSocketFactory() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public SSLParameters getSupportedSSLParameters() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public X509Certificate[] getCertificateChain(String alias) {
+        X509Certificate[] chain = null;
+        X509KeyManager x509KeyManager = certificate.getCertificateKeyManager();
+        if (x509KeyManager != null) {
+            if (alias == null) {
+                alias = "tomcat";
+            }
+            chain = x509KeyManager.getCertificateChain(alias);
+            if (chain == null) {
+                alias = findAlias(x509KeyManager, certificate);
+                chain = x509KeyManager.getCertificateChain(alias);
+            }
+        }
+
+        return chain;
+    }
+
+    @Override
+    public X509Certificate[] getAcceptedIssuers() {
+        X509Certificate[] acceptedCerts = null;
+        if (state.x509TrustManager != null) {
+            acceptedCerts = state.x509TrustManager.getAcceptedIssuers();
+        }
+        return acceptedCerts;
+    }
+
+
+    private static class ContextState implements Runnable {
+
+        private final MemorySession contextMemorySession;
+        private final MemoryAddress sslCtx;
+        private final MemoryAddress confCtx;
+        private final List<byte[]> negotiableProtocols;
+
+        private X509TrustManager x509TrustManager = null;
+
+        private ContextState(MemorySession contextMemorySession, MemoryAddress sslCtx,
+                MemoryAddress confCtx, List<byte[]> negotiableProtocols) {
+            states.put(Long.valueOf(sslCtx.toRawLongValue()), this);
+            this.contextMemorySession = contextMemorySession;
+            this.sslCtx = sslCtx;
+            this.confCtx = confCtx;
+            this.negotiableProtocols = negotiableProtocols;
+        }
+
+        @Override
+        public void run() {
+            try {
+                states.remove(Long.valueOf(sslCtx.toRawLongValue()));
+                SSL_CTX_free(sslCtx);
+                if (!MemoryAddress.NULL.equals(confCtx)) {
+                    SSL_CONF_CTX_free(confCtx);
+                }
+            } finally {
+                contextMemorySession.close();
+            }
+        }
+    }
+}

==================================================
OpenSSLImplementation.java
new file mode 100644
index 0000000000..b9c7ed64b0
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/net/openssl/panama/OpenSSLEngine.java
@@ -0,0 +1,1890 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.util.net.openssl.panama;
+
+import java.io.ByteArrayOutputStream;
+import java.io.InputStream;
+import java.lang.foreign.FunctionDescriptor;
+import java.lang.foreign.Linker;
+import java.lang.foreign.MemoryAddress;
+import java.lang.foreign.MemorySegment;
+import java.lang.foreign.MemorySession;
+import java.lang.foreign.SegmentAllocator;
+import java.lang.foreign.ValueLayout;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.nio.ByteBuffer;
+import java.nio.ReadOnlyBufferException;
+import java.security.Principal;
+import java.security.cert.Certificate;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLEngineResult;
+import javax.net.ssl.SSLException;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSessionBindingEvent;
+import javax.net.ssl.SSLSessionBindingListener;
+import javax.net.ssl.SSLSessionContext;
+
+import static org.apache.tomcat.util.openssl.openssl_h.*;
+
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+import org.apache.tomcat.util.buf.Asn1Parser;
+import org.apache.tomcat.util.buf.ByteBufferUtils;
+import org.apache.tomcat.util.net.Constants;
+import org.apache.tomcat.util.net.SSLUtil;
+import org.apache.tomcat.util.net.openssl.ciphers.OpenSSLCipherConfigurationParser;
+import org.apache.tomcat.util.res.StringManager;
+
+/**
+ * Implements a {@link SSLEngine} using
+ * <a href="https://www.openssl.org/docs/crypto/BIO_s_bio.html#EXAMPLE">OpenSSL
+ * BIO abstractions</a>.
+ */
+public final class OpenSSLEngine extends SSLEngine implements SSLUtil.ProtocolInfo {
+
+    private static final Log log = LogFactory.getLog(OpenSSLEngine.class);
+    private static final StringManager sm = StringManager.getManager(OpenSSLEngine.class);
+
+    private static final Certificate[] EMPTY_CERTIFICATES = new Certificate[0];
+
+    public static final Set<String> AVAILABLE_CIPHER_SUITES;
+
+    public static final Set<String> IMPLEMENTED_PROTOCOLS_SET;
+
+    private static final MethodHandle openSSLCallbackInfoHandle;
+    private static final MethodHandle openSSLCallbackVerifyHandle;
+
+    private static final FunctionDescriptor openSSLCallbackInfoFunctionDescriptor =
+            FunctionDescriptor.ofVoid(ValueLayout.ADDRESS, ValueLayout.JAVA_INT, ValueLayout.JAVA_INT);
+    private static final FunctionDescriptor openSSLCallbackVerifyFunctionDescriptor =
+            FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.JAVA_INT, ValueLayout.ADDRESS);
+
+    static {
+        MethodHandles.Lookup lookup = MethodHandles.lookup();
+        try {
+            openSSLCallbackInfoHandle = lookup.findStatic(OpenSSLEngine.class, "openSSLCallbackInfo",
+                    MethodType.methodType(void.class, MemoryAddress.class, int.class, int.class));
+            openSSLCallbackVerifyHandle = lookup.findStatic(OpenSSLEngine.class, "openSSLCallbackVerify",
+                    MethodType.methodType(int.class, int.class, MemoryAddress.class));
+        } catch (Exception e) {
+            throw new IllegalStateException(e);
+        }
+
+        OpenSSLLifecycleListener.initLibrary();
+
+        final Set<String> availableCipherSuites = new LinkedHashSet<>(128);
+        try (var memorySession = MemorySession.openConfined()) {
+            var allocator = SegmentAllocator.newNativeArena(memorySession);
+            var sslCtx = SSL_CTX_new(TLS_server_method());
+            try {
+                SSL_CTX_set_options(sslCtx, SSL_OP_ALL());
+                SSL_CTX_set_cipher_list(sslCtx, allocator.allocateUtf8String("ALL"));
+                var ssl = SSL_new(sslCtx);
+                SSL_set_accept_state(ssl);
+                try {
+                    for (String c : getCiphers(ssl)) {
+                        // Filter out bad input.
+                        if (c == null || c.length() == 0 || availableCipherSuites.contains(c)) {
+                            continue;
+                        }
+                        availableCipherSuites.add(OpenSSLCipherConfigurationParser.openSSLToJsse(c));
+                    }
+                } finally {
+                    SSL_free(ssl);
+                }
+            } finally {
+                SSL_CTX_free(sslCtx);
+            }
+        } catch (Exception e) {
+            log.warn(sm.getString("engine.ciphersFailure"), e);
+        }
+        AVAILABLE_CIPHER_SUITES = Collections.unmodifiableSet(availableCipherSuites);
+
+        HashSet<String> protocols = new HashSet<>();
+        protocols.add(Constants.SSL_PROTO_SSLv2Hello);
+        protocols.add(Constants.SSL_PROTO_SSLv2);
+        protocols.add(Constants.SSL_PROTO_SSLv3);
+        protocols.add(Constants.SSL_PROTO_TLSv1);
+        protocols.add(Constants.SSL_PROTO_TLSv1_1);
+        protocols.add(Constants.SSL_PROTO_TLSv1_2);
+        protocols.add(Constants.SSL_PROTO_TLSv1_3);
+        IMPLEMENTED_PROTOCOLS_SET = Collections.unmodifiableSet(protocols);
+    }
+
+    private static String[] getCiphers(MemoryAddress ssl) {
+        MemoryAddress sk = SSL_get_ciphers(ssl);
+        int len = OPENSSL_sk_num(sk);
+        if (len <= 0) {
+            return null;
+        }
+        ArrayList<String> ciphers = new ArrayList<>(len);
+        for (int i = 0; i < len; i++) {
+            MemoryAddress cipher = OPENSSL_sk_value(sk, i);
+            MemoryAddress cipherName = SSL_CIPHER_get_name(cipher);
+            ciphers.add(cipherName.getUtf8String(0));
+        }
+        return ciphers.toArray(new String[0]);
+    }
+
+    private static final int MAX_PLAINTEXT_LENGTH = 16 * 1024; // 2^14
+    private static final int MAX_COMPRESSED_LENGTH = MAX_PLAINTEXT_LENGTH + 1024;
+    private static final int MAX_CIPHERTEXT_LENGTH = MAX_COMPRESSED_LENGTH + 1024;
+
+    // Protocols
+    static final int VERIFY_DEPTH = 10;
+
+    // Header (5) + Data (2^14) + Compression (1024) + Encryption (1024) + MAC (20) + Padding (256)
+    static final int MAX_ENCRYPTED_PACKET_LENGTH = MAX_CIPHERTEXT_LENGTH + 5 + 20 + 256;
+
+    static final int MAX_ENCRYPTION_OVERHEAD_LENGTH = MAX_ENCRYPTED_PACKET_LENGTH - MAX_PLAINTEXT_LENGTH;
+
+    enum ClientAuthMode {
+        NONE,
+        OPTIONAL,
+        REQUIRE,
+    }
+
+    private static final String INVALID_CIPHER = "SSL_NULL_WITH_NULL_NULL";
+
+    private static final ConcurrentHashMap<Long, EngineState> states = new ConcurrentHashMap<>();
+    private static EngineState getState(MemoryAddress ssl) {
+        return states.get(Long.valueOf(ssl.toRawLongValue()));
+    }
+
+    private final EngineState state;
+    private final MemorySession engineMemorySession;
+
+    private enum Accepted { NOT, IMPLICIT, EXPLICIT }
+    private Accepted accepted = Accepted.NOT;
+    private enum PHAState { NONE, START, COMPLETE }
+    private boolean handshakeFinished;
+    private int currentHandshake;
+    private boolean receivedShutdown;
+    private volatile boolean destroyed;
+
+    // Use an invalid cipherSuite until the handshake is completed
+    // See http://docs.oracle.com/javase/7/docs/api/javax/net/ssl/SSLEngine.html#getSession()
+    private volatile String version;
+    private volatile String cipher;
+    private volatile String applicationProtocol;
+
+    private volatile Certificate[] peerCerts;
+    @Deprecated
+    private volatile javax.security.cert.X509Certificate[] x509PeerCerts;
+    private volatile ClientAuthMode clientAuth = ClientAuthMode.NONE;
+
+    // SSL Engine status variables
+    private boolean isInboundDone;
+    private boolean isOutboundDone;
+    private boolean engineClosed;
+    private boolean sendHandshakeError = false;
+
+    private final boolean clientMode;
+    private final String fallbackApplicationProtocol;
+    private final OpenSSLSessionContext sessionContext;
+    private final boolean alpn;
+    private final boolean initialized;
+    private final boolean certificateVerificationOptionalNoCA;
+
+    private String selectedProtocol = null;
+
+    private final OpenSSLSession session;
+
+    /**
+     * Creates a new instance
+     *
+     * @param sslCtx an OpenSSL {@code SSL_CTX} object
+     * @param fallbackApplicationProtocol the fallback application protocol
+     * @param clientMode {@code true} if this is used for clients, {@code false}
+     * otherwise
+     * @param sessionContext the {@link OpenSSLSessionContext} this
+     * {@link SSLEngine} belongs to.
+     * @param alpn {@code true} if alpn should be used, {@code false}
+     * otherwise
+     * @param initialized {@code true} if this instance gets its protocol,
+     * cipher and client verification from the {@code SSL_CTX} {@code sslCtx}
+     * @param certificateVerificationDepth Certificate verification depth
+     * @param certificateVerificationOptionalNoCA Skip CA verification in
+     *   optional mode
+     */
+    OpenSSLEngine(MemoryAddress sslCtx, String fallbackApplicationProtocol,
+            boolean clientMode, OpenSSLSessionContext sessionContext, boolean alpn,
+            boolean initialized, int certificateVerificationDepth,
+            boolean certificateVerificationOptionalNoCA, boolean noOcspCheck) {
+        if (sslCtx == null) {
+            throw new IllegalArgumentException(sm.getString("engine.noSSLContext"));
+        }
+        engineMemorySession = MemorySession.openImplicit();
+        var allocator = SegmentAllocator.newNativeArena(engineMemorySession);
+        session = new OpenSSLSession();
+        var ssl = SSL_new(sslCtx);
+        // Set ssl_info_callback
+        var openSSLCallbackInfo = Linker.nativeLinker().upcallStub(openSSLCallbackInfoHandle,
+                openSSLCallbackInfoFunctionDescriptor, engineMemorySession);
+        SSL_set_info_callback(ssl, openSSLCallbackInfo);
+        if (clientMode) {
+            SSL_set_connect_state(ssl);
+        } else {
+            SSL_set_accept_state(ssl);
+        }
+        SSL_set_verify_result(ssl, X509_V_OK());
+        var internalBIOPointer = allocator.allocate(ValueLayout.ADDRESS);
+        var networkBIOPointer = allocator.allocate(ValueLayout.ADDRESS);
+        BIO_new_bio_pair(internalBIOPointer, 0, networkBIOPointer, 0);
+        var internalBIO = internalBIOPointer.get(ValueLayout.ADDRESS, 0);
+        var networkBIO = networkBIOPointer.get(ValueLayout.ADDRESS, 0);
+        SSL_set_bio(ssl, internalBIO, internalBIO);
+        state = new EngineState(ssl, networkBIO, certificateVerificationDepth, noOcspCheck);
+        engineMemorySession.addCloseAction(state);
+        this.fallbackApplicationProtocol = fallbackApplicationProtocol;
+        this.clientMode = clientMode;
+        this.sessionContext = sessionContext;
+        this.alpn = alpn;
+        this.initialized = initialized;
+        this.certificateVerificationOptionalNoCA = certificateVerificationOptionalNoCA;
+    }
+
+    @Override
+    public String getNegotiatedProtocol() {
+        return selectedProtocol;
+    }
+
+    /**
+     * Destroys this engine.
+     */
+    public synchronized void shutdown() {
+        if (!destroyed) {
+            destroyed = true;
+            // internal errors can cause shutdown without marking the engine closed
+            isInboundDone = isOutboundDone = engineClosed = true;
+        }
+    }
+
+    /**
+     * Write plain text data to the OpenSSL internal BIO
+     *
+     * Calling this function with src.remaining == 0 is undefined.
+     * @throws SSLException if the OpenSSL error check fails
+     */
+    private int writePlaintextData(final MemoryAddress ssl, final ByteBuffer src) throws SSLException {
+        clearLastError();
+        final int pos = src.position();
+        final int limit = src.limit();
+        final int len = Math.min(limit - pos, MAX_PLAINTEXT_LENGTH);
+        final int sslWrote;
+
+        if (src.isDirect()) {
+            sslWrote = SSL_write(ssl, MemorySegment.ofByteBuffer(src), len);
+            if (sslWrote > 0) {
+                src.position(pos + sslWrote);
+                return sslWrote;
+            } else {
+                checkLastError();
+            }
+        } else {
+            try (var memorySession = MemorySession.openConfined()) {
+                var allocator = SegmentAllocator.newNativeArena(memorySession);
+                MemorySegment bufSegment = allocator.allocateArray(ValueLayout.JAVA_BYTE, len);
+                MemorySegment.copy(src.array(), pos, bufSegment, ValueLayout.JAVA_BYTE, 0, len);
+                sslWrote = SSL_write(ssl, bufSegment, len);
+                if (sslWrote > 0) {
+                    src.position(pos + sslWrote);
+                    return sslWrote;
+                } else {
+                    checkLastError();
+                }
+            }
+        }
+
+        return 0;
+    }
+
+    /**
+     * Write encrypted data to the OpenSSL network BIO.
+     * @throws SSLException if the OpenSSL error check fails
+     */
+    private int writeEncryptedData(final MemoryAddress networkBIO, final ByteBuffer src) throws SSLException {
+        clearLastError();
+        final int pos = src.position();
+        final int len = src.remaining();
+        if (src.isDirect()) {
+            final int netWrote = BIO_write(networkBIO, MemorySegment.ofByteBuffer(src), len);
+            if (netWrote > 0) {
+                src.position(pos + netWrote);
+                return netWrote;
+            } else {
+                checkLastError();
+            }
+        } else {
+            // This uses unsafe and does not need to be used: the connector should be configured with direct buffers
+            ByteBuffer buf = ByteBuffer.allocateDirect(len);
+            try {
+                buf.put(src);
+                buf.flip();
+                final int netWrote = BIO_write(networkBIO, MemorySegment.ofByteBuffer(buf), len);
+                if (netWrote > 0) {
+                    src.position(pos + netWrote);
+                    return netWrote;
+                } else {
+                    src.position(pos);
+                    checkLastError();
+                }
+            } finally {
+                buf.clear();
+                ByteBufferUtils.cleanDirectBuffer(buf);
+            }
+        }
+
+        return 0;
+    }
+
+    /**
+     * Read plain text data from the OpenSSL internal BIO
+     * @throws SSLException if the OpenSSL error check fails
+     */
+    private int readPlaintextData(final MemoryAddress ssl, final ByteBuffer dst) throws SSLException {
+        clearLastError();
+        final int pos = dst.position();
+
+        if (dst.isDirect()) {
+            final int len = dst.remaining();
+            final int sslRead = SSL_read(ssl, MemorySegment.ofByteBuffer(dst), len);
+            if (sslRead > 0) {
+                dst.position(dst.position() + sslRead);
+                return sslRead;
+            } else {
+                checkLastError();
+            }
+        } else {
+            final int limit = dst.limit();
+            final int len = Math.min(MAX_ENCRYPTED_PACKET_LENGTH, limit - pos);
+            try (var memorySession = MemorySession.openConfined()) {
+                var allocator = SegmentAllocator.newNativeArena(memorySession);
+                MemorySegment bufSegment = allocator.allocateArray(ValueLayout.JAVA_BYTE, len);
+                final int sslRead = SSL_read(ssl, bufSegment, len);
+                if (sslRead > 0) {
+                    MemorySegment.copy(bufSegment, ValueLayout.JAVA_BYTE, 0, dst.array(), pos, sslRead);
+                    dst.position(dst.position() + sslRead);
+                    return sslRead;
+                } else {
+                    checkLastError();
+                }
+            }
+        }
+
+        return 0;
+    }
+
+    /**
+     * Read encrypted data from the OpenSSL network BIO
+     * @throws SSLException if the OpenSSL error check fails
+     */
+    private int readEncryptedData(final MemoryAddress networkBIO, final ByteBuffer dst, final int pending) throws SSLException {
+        clearLastError();
+        final int pos = dst.position();
+        if (dst.isDirect()) {
+            final int bioRead = BIO_read(networkBIO, MemorySegment.ofByteBuffer(dst), pending);
+            if (bioRead > 0) {
+                dst.position(pos + bioRead);
+                return bioRead;
+            } else {
+                checkLastError();
+            }
+        } else {
+            // This uses unsafe and does not need to be used: the connector should be configured with direct buffers
+            final ByteBuffer buf = ByteBuffer.allocateDirect(pending);
+            try {
+                final int bioRead = BIO_read(networkBIO, MemorySegment.ofByteBuffer(buf), pending);
+                if (bioRead > 0) {
+                    buf.limit(bioRead);
+                    int oldLimit = dst.limit();
+                    dst.limit(pos + bioRead);
+                    dst.put(buf);
+                    dst.limit(oldLimit);
+                    return bioRead;
+                } else {
+                    checkLastError();
+                }
+            } finally {
+                buf.clear();
+                ByteBufferUtils.cleanDirectBuffer(buf);
+            }
+        }
+
+        return 0;
+    }
+
+    @Override
+    public synchronized SSLEngineResult wrap(final ByteBuffer[] srcs, final int offset, final int length, final ByteBuffer dst) throws SSLException {
+        // Check to make sure the engine has not been closed
+        if (destroyed) {
+            return new SSLEngineResult(SSLEngineResult.Status.CLOSED, SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING, 0, 0);
+        }
+
+        // Throw required runtime exceptions
+        if (srcs == null || dst == null) {
+            throw new IllegalArgumentException(sm.getString("engine.nullBuffer"));
+        }
+        if (offset >= srcs.length || offset + length > srcs.length) {
+            throw new IndexOutOfBoundsException(sm.getString("engine.invalidBufferArray",
+                    Integer.toString(offset), Integer.toString(length),
+                    Integer.toString(srcs.length)));
+        }
+        if (dst.isReadOnly()) {
+            throw new ReadOnlyBufferException();
+        }
+        // Prepare OpenSSL to work in server mode and receive handshake
+        if (accepted == Accepted.NOT) {
+            beginHandshakeImplicitly();
+        }
+
+        // In handshake or close_notify stages, check if call to wrap was made
+        // without regard to the handshake status.
+        SSLEngineResult.HandshakeStatus handshakeStatus = getHandshakeStatus();
+
+        if ((!handshakeFinished || engineClosed) && handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {
+            return new SSLEngineResult(getEngineStatus(), SSLEngineResult.HandshakeStatus.NEED_UNWRAP, 0, 0);
+        }
+
+        int bytesProduced = 0;
+        int pendingNet;
+
+        // Check for pending data in the network BIO
+        pendingNet = (int) BIO_ctrl_pending(state.networkBIO);
+        if (pendingNet > 0) {
+            // Do we have enough room in destination to write encrypted data?
+            int capacity = dst.remaining();
+            if (capacity < pendingNet) {
+                return new SSLEngineResult(SSLEngineResult.Status.BUFFER_OVERFLOW, handshakeStatus, 0, 0);
+            }
+
+            // Write the pending data from the network BIO into the dst buffer
+            try {
+                bytesProduced = readEncryptedData(state.networkBIO, dst, pendingNet);
+            } catch (Exception e) {
+                throw new SSLException(e);
+            }
+
+            // If isOutboundDone is set, then the data from the network BIO
+            // was the close_notify message -- we are not required to wait
+            // for the receipt the peer's close_notify message -- shutdown.
+            if (isOutboundDone) {
+                shutdown();
+            }
+
+            return new SSLEngineResult(getEngineStatus(), getHandshakeStatus(), 0, bytesProduced);
+        }
+
+        // There was no pending data in the network BIO -- encrypt any application data
+        int bytesConsumed = 0;
+        int endOffset = offset + length;
+        for (int i = offset; i < endOffset; ++i) {
+            final ByteBuffer src = srcs[i];
+            if (src == null) {
+                throw new IllegalArgumentException(sm.getString("engine.nullBufferInArray"));
+            }
+            while (src.hasRemaining()) {
+
+                int bytesWritten = 0;
+                // Write plain text application data to the SSL engine
+                try {
+                    bytesWritten = writePlaintextData(state.ssl, src);
+                    bytesConsumed += bytesWritten;
+                } catch (Exception e) {
+                    throw new SSLException(e);
+                }
+
+                if (bytesWritten == 0) {
+                    throw new IllegalStateException(sm.getString("engine.failedToWriteBytes"));
+                }
+
+                // Check to see if the engine wrote data into the network BIO
+                pendingNet = (int) BIO_ctrl_pending(state.networkBIO);
+                if (pendingNet > 0) {
+                    // Do we have enough room in dst to write encrypted data?
+                    int capacity = dst.remaining();
+                    if (capacity < pendingNet) {
+                        return new SSLEngineResult(
+                                SSLEngineResult.Status.BUFFER_OVERFLOW, getHandshakeStatus(), bytesConsumed, bytesProduced);
+                    }
+
+                    // Write the pending data from the network BIO into the dst buffer
+                    try {
+                        bytesProduced += readEncryptedData(state.networkBIO, dst, pendingNet);
+                    } catch (Exception e) {
+                        throw new SSLException(e);
+                    }
+
+                    return new SSLEngineResult(getEngineStatus(), getHandshakeStatus(), bytesConsumed, bytesProduced);
+                }
+            }
+        }
+
+        return new SSLEngineResult(getEngineStatus(), getHandshakeStatus(), bytesConsumed, bytesProduced);
+    }
+
+    @Override
+    public synchronized SSLEngineResult unwrap(final ByteBuffer src, final ByteBuffer[] dsts, final int offset, final int length) throws SSLException {
+        // Check to make sure the engine has not been closed
+        if (destroyed) {
+            return new SSLEngineResult(SSLEngineResult.Status.CLOSED, SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING, 0, 0);
+        }
+
+        // Throw required runtime exceptions
+        if (src == null || dsts == null) {
+            throw new IllegalArgumentException(sm.getString("engine.nullBuffer"));
+        }
+        if (offset >= dsts.length || offset + length > dsts.length) {
+            throw new IndexOutOfBoundsException(sm.getString("engine.invalidBufferArray",
+                    Integer.toString(offset), Integer.toString(length),
+                    Integer.toString(dsts.length)));
+        }
+        int capacity = 0;
+        final int endOffset = offset + length;
+        for (int i = offset; i < endOffset; i++) {
+            ByteBuffer dst = dsts[i];
+            if (dst == null) {
+                throw new IllegalArgumentException(sm.getString("engine.nullBufferInArray"));
+            }
+            if (dst.isReadOnly()) {
+                throw new ReadOnlyBufferException();
+            }
+            capacity += dst.remaining();
+        }
+
+        // Prepare OpenSSL to work in server mode and receive handshake
+        if (accepted == Accepted.NOT) {
+            beginHandshakeImplicitly();
+        }
+
+        // In handshake or close_notify stages, check if call to unwrap was made
+        // without regard to the handshake status.
+        SSLEngineResult.HandshakeStatus handshakeStatus = getHandshakeStatus();
+        if ((!handshakeFinished || engineClosed) && handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_WRAP) {
+            return new SSLEngineResult(getEngineStatus(), SSLEngineResult.HandshakeStatus.NEED_WRAP, 0, 0);
+        }
+
+        int len = src.remaining();
+
+        // protect against protocol overflow attack vector
+        if (len > MAX_ENCRYPTED_PACKET_LENGTH) {
+            isInboundDone = true;
+            isOutboundDone = true;
+            engineClosed = true;
+            shutdown();
+            throw new SSLException(sm.getString("engine.oversizedPacket"));
+        }
+
+        // Write encrypted data to network BIO
+        int written = 0;
+        try {
+            written = writeEncryptedData(state.networkBIO, src);
+        } catch (Exception e) {
+            throw new SSLException(e);
+        }
+
+        // There won't be any application data until we're done handshaking
+        //
+        // We first check handshakeFinished to eliminate the overhead of extra JNI call if possible.
+        int pendingApp = pendingReadableBytesInSSL();
+        if (!handshakeFinished) {
+            pendingApp = 0;
+        }
+        int bytesProduced = 0;
+        int idx = offset;
+        // Do we have enough room in dsts to write decrypted data?
+        if (capacity == 0) {
+            return new SSLEngineResult(SSLEngineResult.Status.BUFFER_OVERFLOW, getHandshakeStatus(), written, 0);
+        }
+
+        while (pendingApp > 0) {
+            if (idx == endOffset) {
+                // Destination buffer state changed (no remaining space although
+                // capacity is still available), so break loop with an error
+                throw new IllegalStateException(sm.getString("engine.invalidDestinationBuffersState"));
+            }
+            // Write decrypted data to dsts buffers
+            while (idx < endOffset) {
+                ByteBuffer dst = dsts[idx];
+                if (!dst.hasRemaining()) {
+                    idx++;
+                    continue;
+                }
+
+                if (pendingApp <= 0) {
+                    break;
+                }
+
+                int bytesRead;
+                try {
+                    bytesRead = readPlaintextData(state.ssl, dst);
+                } catch (Exception e) {
+                    throw new SSLException(e);
+                }
+
+                if (bytesRead == 0) {
+                    // This should not be possible. pendingApp is positive
+                    // therefore the read should have read at least one byte.
+                    throw new IllegalStateException(sm.getString("engine.failedToReadAvailableBytes"));
+                }
+
+                bytesProduced += bytesRead;
+                pendingApp -= bytesRead;
+                capacity -= bytesRead;
+
+                if (!dst.hasRemaining()) {
+                    idx++;
+                }
+            }
+            if (capacity == 0) {
+                break;
+            } else if (pendingApp == 0) {
+                pendingApp = pendingReadableBytesInSSL();
+            }
+        }
+
+        // Check to see if we received a close_notify message from the peer
+        if (!receivedShutdown && (SSL_get_shutdown(state.ssl) & SSL_RECEIVED_SHUTDOWN()) == SSL_RECEIVED_SHUTDOWN()) {
+            receivedShutdown = true;
+            closeOutbound();
+            closeInbound();
+        }
+
+        if (bytesProduced == 0 && (written == 0 || (written > 0 && !src.hasRemaining() && handshakeFinished))) {
+            return new SSLEngineResult(SSLEngineResult.Status.BUFFER_UNDERFLOW, getHandshakeStatus(), written, 0);
+        } else {
+            return new SSLEngineResult(getEngineStatus(), getHandshakeStatus(), written, bytesProduced);
+        }
+    }
+
+    private int pendingReadableBytesInSSL()
+            throws SSLException {
+        // NOTE: Calling a fake read is necessary before calling pendingReadableBytesInSSL because
+        // SSL_pending will return 0 if OpenSSL has not started the current TLS record
+        // See https://www.openssl.org/docs/manmaster/man3/SSL_pending.html
+        clearLastError();
+        int lastPrimingReadResult = SSL_read(state.ssl, MemoryAddress.NULL, 0); // priming read
+        // check if SSL_read returned <= 0. In this case we need to check the error and see if it was something
+        // fatal.
+        if (lastPrimingReadResult <= 0) {
+            checkLastError();
+        }
+        int pendingReadableBytesInSSL = SSL_pending(state.ssl);
+
+        // TLS 1.0 needs additional handling
+        if (Constants.SSL_PROTO_TLSv1.equals(version) && lastPrimingReadResult == 0 &&
+                pendingReadableBytesInSSL == 0) {
+            // Perform another priming read
+            lastPrimingReadResult = SSL_read(state.ssl, MemoryAddress.NULL, 0);
+            if (lastPrimingReadResult <= 0) {
+                checkLastError();
+            }
+            pendingReadableBytesInSSL = SSL_pending(state.ssl);
+        }
+
+        return pendingReadableBytesInSSL;
+    }
+
+    @Override
+    public Runnable getDelegatedTask() {
+        // Currently, we do not delegate SSL computation tasks
+        return null;
+    }
+
+    @Override
+    public synchronized void closeInbound() throws SSLException {
+        if (isInboundDone) {
+            return;
+        }
+
+        isInboundDone = true;
+        engineClosed = true;
+
+        shutdown();
+
+        if (accepted != Accepted.NOT && !receivedShutdown) {
+            throw new SSLException(sm.getString("engine.inboundClose"));
+        }
+    }
+
+    @Override
+    public synchronized boolean isInboundDone() {
+        return isInboundDone || engineClosed;
+    }
+
+    @Override
+    public synchronized void closeOutbound() {
+        if (isOutboundDone) {
+            return;
+        }
+
+        isOutboundDone = true;
+        engineClosed = true;
+
+        if (accepted != Accepted.NOT && !destroyed) {
+            int mode = SSL_get_shutdown(state.ssl);
+            if ((mode & SSL_SENT_SHUTDOWN()) != SSL_SENT_SHUTDOWN()) {
+                SSL_shutdown(state.ssl);
+            }
+        } else {
+            // engine closing before initial handshake
+            shutdown();
+        }
+    }
+
+    @Override
+    public synchronized boolean isOutboundDone() {
+        return isOutboundDone;
+    }
+
+    @Override
+    public String[] getSupportedCipherSuites() {
+        Set<String> availableCipherSuites = AVAILABLE_CIPHER_SUITES;
+        return availableCipherSuites.toArray(new String[0]);
+    }
+
+    @Override
+    public synchronized String[] getEnabledCipherSuites() {
+        if (destroyed) {
+            return new String[0];
+        }
+        String[] enabled = getCiphers(state.ssl);
+        if (enabled == null) {
+            return new String[0];
+        } else {
+            for (int i = 0; i < enabled.length; i++) {
+                String mapped = OpenSSLCipherConfigurationParser.openSSLToJsse(enabled[i]);
+                if (mapped != null) {
+                    enabled[i] = mapped;
+                }
+            }
+            return enabled;
+        }
+    }
+
+    @Override
+    public synchronized void setEnabledCipherSuites(String[] cipherSuites) {
+        if (initialized) {
+            return;
+        }
+        if (cipherSuites == null) {
+            throw new IllegalArgumentException(sm.getString("engine.nullCipherSuite"));
+        }
+        if (destroyed) {
+            return;
+        }
+        final StringBuilder buf = new StringBuilder();
+        for (String cipherSuite : cipherSuites) {
+            if (cipherSuite == null) {
+                break;
+            }
+            String converted = OpenSSLCipherConfigurationParser.jsseToOpenSSL(cipherSuite);
+            if (!AVAILABLE_CIPHER_SUITES.contains(cipherSuite)) {
+                log.debug(sm.getString("engine.unsupportedCipher", cipherSuite, converted));
+            }
+            if (converted != null) {
+                cipherSuite = converted;
+            }
+
+            buf.append(cipherSuite);
+            buf.append(':');
+        }
+
+        if (buf.length() == 0) {
+            throw new IllegalArgumentException(sm.getString("engine.emptyCipherSuite"));
+        }
+        buf.setLength(buf.length() - 1);
+
+        final String cipherSuiteSpec = buf.toString();
+        try {
+            SSL_set_cipher_list(state.ssl, SegmentAllocator.newNativeArena(engineMemorySession)
+                    .allocateUtf8String(cipherSuiteSpec));
+        } catch (Exception e) {
+            throw new IllegalStateException(sm.getString("engine.failedCipherSuite", cipherSuiteSpec), e);
+        }
+    }
+
+    @Override
+    public String[] getSupportedProtocols() {
+        return IMPLEMENTED_PROTOCOLS_SET.toArray(new String[0]);
+    }
+
+    @Override
+    public synchronized String[] getEnabledProtocols() {
+        if (destroyed) {
+            return new String[0];
+        }
+        List<String> enabled = new ArrayList<>();
+        // Seems like there is no way to explicitly disable SSLv2Hello in OpenSSL so it is always enabled
+        enabled.add(Constants.SSL_PROTO_SSLv2Hello);
+        long opts = SSL_get_options(state.ssl);
+        if ((opts & SSL_OP_NO_TLSv1()) == 0) {
+            enabled.add(Constants.SSL_PROTO_TLSv1);
+        }
+        if ((opts & SSL_OP_NO_TLSv1_1()) == 0) {
+            enabled.add(Constants.SSL_PROTO_TLSv1_1);
+        }
+        if ((opts & SSL_OP_NO_TLSv1_2()) == 0) {
+            enabled.add(Constants.SSL_PROTO_TLSv1_2);
+        }
+        if ((opts & SSL_OP_NO_TLSv1_3()) == 0) {
+            enabled.add(Constants.SSL_PROTO_TLSv1_3);
+        }
+        if ((opts & SSL_OP_NO_SSLv2()) == 0) {
+            enabled.add(Constants.SSL_PROTO_SSLv2);
+        }
+        if ((opts & SSL_OP_NO_SSLv3()) == 0) {
+            enabled.add(Constants.SSL_PROTO_SSLv3);
+        }
+        int size = enabled.size();
+        if (size == 0) {
+            return new String[0];
+        } else {
+            return enabled.toArray(new String[size]);
+        }
+    }
+
+    @Override
+    public synchronized void setEnabledProtocols(String[] protocols) {
+        if (initialized) {
+            return;
+        }
+        if (protocols == null) {
+            // This is correct from the API docs
+            throw new IllegalArgumentException();
+        }
+        if (destroyed) {
+            return;
+        }
+        boolean sslv2 = false;
+        boolean sslv3 = false;
+        boolean tlsv1 = false;
+        boolean tlsv1_1 = false;
+        boolean tlsv1_2 = false;
+        boolean tlsv1_3 = false;
+        for (String p : protocols) {
+            if (!IMPLEMENTED_PROTOCOLS_SET.contains(p)) {
+                throw new IllegalArgumentException(sm.getString("engine.unsupportedProtocol", p));
+            }
+            if (p.equals(Constants.SSL_PROTO_SSLv2)) {
+                sslv2 = true;
+            } else if (p.equals(Constants.SSL_PROTO_SSLv3)) {
+                sslv3 = true;
+            } else if (p.equals(Constants.SSL_PROTO_TLSv1)) {
+                tlsv1 = true;
+            } else if (p.equals(Constants.SSL_PROTO_TLSv1_1)) {
+                tlsv1_1 = true;
+            } else if (p.equals(Constants.SSL_PROTO_TLSv1_2)) {
+                tlsv1_2 = true;
+            } else if (p.equals(Constants.SSL_PROTO_TLSv1_3)) {
+                tlsv1_3 = true;
+            }
+        }
+        // Enable all and then disable what we not want
+        SSL_set_options(state.ssl, SSL_OP_ALL());
+
+        if (!sslv2) {
+            SSL_set_options(state.ssl, SSL_OP_NO_SSLv2());
+        }
+        if (!sslv3) {
+            SSL_set_options(state.ssl, SSL_OP_NO_SSLv3());
+        }
+        if (!tlsv1) {
+            SSL_set_options(state.ssl, SSL_OP_NO_TLSv1());
+        }
+        if (!tlsv1_1) {
+            SSL_set_options(state.ssl, SSL_OP_NO_TLSv1_1());
+        }
+        if (!tlsv1_2) {
+            SSL_set_options(state.ssl, SSL_OP_NO_TLSv1_2());
+        }
+        if (!tlsv1_3) {
+            SSL_set_options(state.ssl, SSL_OP_NO_TLSv1_3());
+        }
+    }
+
+    @Override
+    public SSLSession getSession() {
+        return session;
+    }
+
+    @Override
+    public synchronized void beginHandshake() throws SSLException {
+        if (engineClosed || destroyed) {
+            throw new SSLException(sm.getString("engine.engineClosed"));
+        }
+        switch (accepted) {
+        case NOT:
+            handshake();
+            accepted = Accepted.EXPLICIT;
+            break;
+        case IMPLICIT:
+            // A user did not start handshake by calling this method by themselves,
+            // but handshake has been started already by wrap() or unwrap() implicitly.
+            // Because it's the user's first time to call this method, it is unfair to
+            // raise an exception.  From the user's standpoint, they never asked for
+            // renegotiation.
+
+            accepted = Accepted.EXPLICIT; // Next time this method is invoked by the user, we should raise an exception.
+            break;
+        case EXPLICIT:
+            renegotiate();
+            break;
+        }
+    }
+
+    private byte[] getPeerCertificate() {
+        var allocator = SegmentAllocator.newNativeArena(engineMemorySession);
+        MemoryAddress/*(X509*)*/ x509 = SSL_get_peer_certificate(state.ssl);
+        MemorySegment bufPointer = allocator.allocate(ValueLayout.ADDRESS, MemoryAddress.NULL);
+        int length = i2d_X509(x509, bufPointer);
+        if (length <= 0) {
+            return null;
+        }
+        MemoryAddress buf = bufPointer.get(ValueLayout.ADDRESS, 0);
+        byte[] certificate = MemorySegment.ofAddress(buf, length, engineMemorySession).toArray(ValueLayout.JAVA_BYTE);
+        X509_free(x509);
+        CRYPTO_free(buf, MemoryAddress.NULL, 0); // OPENSSL_free macro
+        return certificate;
+    }
+
+    private byte[][] getPeerCertChain() {
+        MemoryAddress/*STACK_OF(X509)*/ sk = SSL_get_peer_cert_chain(state.ssl);
+        int len = OPENSSL_sk_num(sk);
+        if (len <= 0) {
+            return null;
+        }
+        byte[][] certificateChain = new byte[len][];
+        var allocator = SegmentAllocator.newNativeArena(engineMemorySession);
+        for (int i = 0; i < len; i++) {
+            MemoryAddress/*(X509*)*/ x509 = OPENSSL_sk_value(sk, i);
+            MemorySegment bufPointer = allocator.allocate(ValueLayout.ADDRESS, MemoryAddress.NULL);
+            int length = i2d_X509(x509, bufPointer);
+            if (length < 0) {
+                certificateChain[i] = new byte[0];
+                continue;
+            }
+            MemoryAddress buf = bufPointer.get(ValueLayout.ADDRESS, 0);
+            byte[] certificate = MemorySegment.ofAddress(buf, length, engineMemorySession).toArray(ValueLayout.JAVA_BYTE);
+            certificateChain[i] = certificate;
+            CRYPTO_free(buf, MemoryAddress.NULL, 0); // OPENSSL_free macro
+        }
+        return certificateChain;
+    }
+
+    private String getProtocolNegotiated() {
+        var allocator = SegmentAllocator.newNativeArena(engineMemorySession);
+        MemorySegment lenAddress = allocator.allocate(ValueLayout.JAVA_INT, 0);
+        MemorySegment protocolPointer = allocator.allocate(ValueLayout.ADDRESS, MemoryAddress.NULL);
+        SSL_get0_alpn_selected(state.ssl, protocolPointer, lenAddress);
+        if (MemoryAddress.NULL.equals(protocolPointer.address())) {
+            SSL_get0_next_proto_negotiated(state.ssl, protocolPointer, lenAddress);
+        }
+        if (MemoryAddress.NULL.equals(protocolPointer.address())) {
+            return null;
+        }
+        int length = lenAddress.get(ValueLayout.JAVA_INT, 0);
+        if (length == 0) {
+            return null;
+        }
+        MemoryAddress protocolAddress = protocolPointer.get(ValueLayout.ADDRESS, 0);
+        byte[] name = MemorySegment.ofAddress(protocolAddress, length, engineMemorySession).toArray(ValueLayout.JAVA_BYTE);
+        if (log.isDebugEnabled()) {
+            log.debug("Protocol negotiated [" + new String(name) + "]");
+        }
+        return new String(name);
+    }
+
+    private void beginHandshakeImplicitly() throws SSLException {
+        handshake();
+        accepted = Accepted.IMPLICIT;
+    }
+
+    private void handshake() throws SSLException {
+        currentHandshake = state.handshakeCount;
+        clearLastError();
+        int code = SSL_do_handshake(state.ssl);
+        if (code <= 0) {
+            checkLastError();
+        } else {
+            if (alpn) {
+                selectedProtocol = getProtocolNegotiated();
+            }
+            session.lastAccessedTime = System.currentTimeMillis();
+            // if SSL_do_handshake returns > 0 it means the handshake was finished. This means we can update
+            // handshakeFinished directly and so eliminate unnecessary calls to SSL.isInInit(...)
+            handshakeFinished = true;
+        }
+    }
+
+    private synchronized void renegotiate() throws SSLException {
+        if (log.isDebugEnabled()) {
+            log.debug("Start renegotiate");
+        }
+        clearLastError();
+        int code;
+        if (SSL_get_version(state.ssl).getUtf8String(0).equals(Constants.SSL_PROTO_TLSv1_3)) {
+            state.phaState = PHAState.START;
+            code = SSL_verify_client_post_handshake(state.ssl);
+        } else {
+            code = SSL_renegotiate(state.ssl);
+        }
+        if (code <= 0) {
+            checkLastError();
+        }
+        handshakeFinished = false;
+        peerCerts = null;
+        x509PeerCerts = null;
+        currentHandshake = state.handshakeCount;
+        int code2 = SSL_do_handshake(state.ssl);
+        if (code2 <= 0) {
+            checkLastError();
+        }
+    }
+
+    private void checkLastError() throws SSLException {
+        String sslError = getLastError();
+        if (sslError != null) {
+            // Many errors can occur during handshake and need to be reported
+            if (!handshakeFinished) {
+                sendHandshakeError = true;
+            } else {
+                throw new SSLException(sslError);
+            }
+        }
+    }
+
+
+    /**
+     * Clear out any errors, but log a warning.
+     */
+    private void clearLastError() {
+        getLastError();
+    }
+
+    /**
+     * Many calls to SSL methods do not check the last error. Those that do
+     * check the last error need to ensure that any previously ignored error is
+     * cleared prior to the method call else errors may be falsely reported.
+     * Ideally, before any SSL_read, SSL_write, clearLastError should always
+     * be called, and getLastError should be called after on any negative or
+     * zero result.
+     * @return the first error in the stack
+     */
+    private String getLastError() {
+        String sslError = null;
+        long error = ERR_get_error();
+        if (error != SSL_ERROR_NONE()) {
+            var allocator = SegmentAllocator.newNativeArena(engineMemorySession);
+            do {
+                // Loop until getLastErrorNumber() returns SSL_ERROR_NONE
+                var buf = allocator.allocateArray(ValueLayout.JAVA_BYTE, new byte[128]);
+                ERR_error_string(error, buf);
+                String err = buf.getUtf8String(0);
+                if (sslError == null) {
+                    sslError = err;
+                }
+                if (log.isDebugEnabled()) {
+                    log.debug(sm.getString("engine.openSSLError", Long.toString(error), err));
+                }
+            } while ((error = ERR_get_error()) != SSL_ERROR_NONE());
+        }
+        return sslError;
+    }
+
+    private SSLEngineResult.Status getEngineStatus() {
+        return engineClosed ? SSLEngineResult.Status.CLOSED : SSLEngineResult.Status.OK;
+    }
+
+    @Override
+    public synchronized SSLEngineResult.HandshakeStatus getHandshakeStatus() {
+        if (accepted == Accepted.NOT || destroyed) {
+            return SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING;
+        }
+
+        // Check if we are in the initial handshake phase
+        if (!handshakeFinished) {
+
+            // There is pending data in the network BIO -- call wrap
+            if (sendHandshakeError || BIO_ctrl_pending(state.networkBIO) != 0) {
+                if (sendHandshakeError) {
+                    // After a last wrap, consider it is going to be done
+                    sendHandshakeError = false;
+                    currentHandshake++;
+                }
+                return SSLEngineResult.HandshakeStatus.NEED_WRAP;
+            }
+
+            /*
+             * Tomcat Native stores a count of the completed handshakes in the
+             * SSL instance and increments it every time a handshake is
+             * completed. Comparing the handshake count when the handshake
+             * started to the current handshake count enables this code to
+             * detect when the handshake has completed.
+             *
+             * Obtaining client certificates after the connection has been
+             * established requires additional checks. We need to trigger
+             * additional reads until the certificates have been read but we
+             * don't know how many reads we will need as it depends on both
+             * client and network behaviour.
+             *
+             * The additional reads are triggered by returning NEED_UNWRAP
+             * rather than FINISHED. This allows the standard I/O code to be
+             * used.
+             *
+             * For TLSv1.2 and below, the handshake completes before the
+             * renegotiation. We therefore use SSL.renegotiatePending() to
+             * check on the current status of the renegotiation and return
+             * NEED_UNWRAP until it completes which means the client
+             * certificates will have been read from the client.
+             *
+             * For TLSv1.3, Tomcat Native sets a flag when post handshake
+             * authentication is started and updates it once the client
+             * certificate has been received. We therefore use
+             * SSL.getPostHandshakeAuthInProgress() to check the current status
+             * and return NEED_UNWRAP until that methods indicates that PHA is
+             * no longer in progress.
+             */
+
+            // No pending data to be sent to the peer
+            // Check to see if we have finished handshaking
+            if (state.handshakeCount != currentHandshake && SSL_renegotiate_pending(state.ssl) == 0 &&
+                    (state.phaState != PHAState.START)) {
+                if (alpn) {
+                    selectedProtocol = getProtocolNegotiated();
+                }
+                session.lastAccessedTime = System.currentTimeMillis();
+                version = SSL_get_version(state.ssl).getUtf8String(0);
+                handshakeFinished = true;
+                return SSLEngineResult.HandshakeStatus.FINISHED;
+            }
+
+            // No pending data
+            // Still handshaking / renegotiation / post-handshake auth pending
+            // Must be waiting on the peer to send more data
+            return SSLEngineResult.HandshakeStatus.NEED_UNWRAP;
+        }
+
+        // Check if we are in the shutdown phase
+        if (engineClosed) {
+            // Waiting to send the close_notify message
+            if (BIO_ctrl_pending(state.networkBIO) != 0) {
+                return SSLEngineResult.HandshakeStatus.NEED_WRAP;
+            }
+
+            // Must be waiting to receive the close_notify message
+            return SSLEngineResult.HandshakeStatus.NEED_UNWRAP;
+        }
+
+        return SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING;
+    }
+
+    @Override
+    public void setUseClientMode(boolean clientMode) {
+        if (clientMode != this.clientMode) {
+            throw new UnsupportedOperationException();
+        }
+    }
+
+    @Override
+    public boolean getUseClientMode() {
+        return clientMode;
+    }
+
+    @Override
+    public void setNeedClientAuth(boolean b) {
+        setClientAuth(b ? ClientAuthMode.REQUIRE : ClientAuthMode.NONE);
+    }
+
+    @Override
+    public boolean getNeedClientAuth() {
+        return clientAuth == ClientAuthMode.REQUIRE;
+    }
+
+    @Override
+    public void setWantClientAuth(boolean b) {
+        setClientAuth(b ? ClientAuthMode.OPTIONAL : ClientAuthMode.NONE);
+    }
+
+    @Override
+    public boolean getWantClientAuth() {
+        return clientAuth == ClientAuthMode.OPTIONAL;
+    }
+
+    private static final int OPTIONAL_NO_CA = 3;
+
+    private void setClientAuth(ClientAuthMode mode) {
+        if (clientMode) {
+            return;
+        }
+        synchronized (this) {
+            if (clientAuth == mode) {
+                return;
+            }
+            state.certificateVerifyMode = switch (mode) {
+                case NONE -> SSL_VERIFY_NONE();
+                case REQUIRE -> SSL_VERIFY_FAIL_IF_NO_PEER_CERT();
+                case OPTIONAL -> certificateVerificationOptionalNoCA ? OPTIONAL_NO_CA : SSL_VERIFY_PEER();
+            };
+            // SSL.setVerify(state.ssl, value, certificateVerificationDepth);
+            // Set int verify_callback(int preverify_ok, X509_STORE_CTX *x509_ctx) callback
+            var openSSLCallbackVerify =
+                    Linker.nativeLinker().upcallStub(openSSLCallbackVerifyHandle,
+                    openSSLCallbackVerifyFunctionDescriptor, engineMemorySession);
+            int value = switch (mode) {
+                case NONE -> SSL_VERIFY_NONE();
+                case REQUIRE -> SSL_VERIFY_PEER() | SSL_VERIFY_FAIL_IF_NO_PEER_CERT();
+                case OPTIONAL -> SSL_VERIFY_PEER();
+            };
+            SSL_set_verify(state.ssl, value, openSSLCallbackVerify);
+            clientAuth = mode;
+        }
+    }
+
+    public static void openSSLCallbackInfo(MemoryAddress ssl, int where, int ret) {
+        EngineState state = getState(ssl);
+        if (state == null) {
+            log.warn(sm.getString("engine.noSSL", Long.valueOf(ssl.toRawLongValue())));
+            return;
+        }
+        if (0 != (where & SSL_CB_HANDSHAKE_DONE())) {
+            state.handshakeCount++;
+        }
+    }
+
+    public static int openSSLCallbackVerify(int preverify_ok, MemoryAddress /*X509_STORE_CTX*/ x509ctx) {
+        MemoryAddress ssl = X509_STORE_CTX_get_ex_data(x509ctx, SSL_get_ex_data_X509_STORE_CTX_idx());
+        EngineState state = getState(ssl);
+        if (state == null) {
+            log.warn(sm.getString("engine.noSSL", Long.valueOf(ssl.toRawLongValue())));
+            return 0;
+        }
+        if (log.isDebugEnabled()) {
+            log.debug("Verification in engine with mode [" + state.certificateVerifyMode + "] for " + state.ssl);
+        }
+        int ok = preverify_ok;
+        int errnum = X509_STORE_CTX_get_error(x509ctx);
+        int errdepth = X509_STORE_CTX_get_error_depth(x509ctx);
+        state.phaState = PHAState.COMPLETE;
+        if (state.certificateVerifyMode == -1 /*SSL_CVERIFY_UNSET*/ || state.certificateVerifyMode == SSL_VERIFY_NONE()) {
+            return 1;
+        }
+        /*SSL_VERIFY_ERROR_IS_OPTIONAL(errnum) -> ((errnum == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT)
+                || (errnum == X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN)
+                || (errnum == X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)
+                || (errnum == X509_V_ERR_CERT_UNTRUSTED)
+                || (errnum == X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE))*/
+        boolean verifyErrorIsOptional = (errnum == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT())
+                || (errnum == X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN())
+                || (errnum == X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY())
+                || (errnum == X509_V_ERR_CERT_UNTRUSTED())
+                || (errnum == X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE());
+        if (verifyErrorIsOptional && (state.certificateVerifyMode == OPTIONAL_NO_CA)) {
+            ok = 1;
+            SSL_set_verify_result(state.ssl, X509_V_OK());
+        }
+        /*
+         * Expired certificates vs. "expired" CRLs: by default, OpenSSL
+         * turns X509_V_ERR_CRL_HAS_EXPIRED into a "certificate_expired(45)"
+         * SSL alert, but that's not really the message we should convey to the
+         * peer (at the very least, it's confusing, and in many cases, it's also
+         * inaccurate, as the certificate itself may very well not have expired
+         * yet). We set the X509_STORE_CTX error to something which OpenSSL's
+         * s3_both.c:ssl_verify_alarm_type() maps to SSL_AD_CERTIFICATE_UNKNOWN,
+         * i.e. the peer will receive a "certificate_unknown(46)" alert.
+         * We do not touch errnum, though, so that later on we will still log
+         * the "real" error, as returned by OpenSSL.
+         */
+        if (ok == 0 && errnum == X509_V_ERR_CRL_HAS_EXPIRED()) {
+            X509_STORE_CTX_set_error(x509ctx, -1);
+        }
+
+        // OCSP
+        if (!state.noOcspCheck && (ok > 0)) {
+            /* If there was an optional verification error, it's not
+             * possible to perform OCSP validation since the issuer may be
+             * missing/untrusted.  Fail in that case.
+             */
+            if (verifyErrorIsOptional) {
+                if (state.certificateVerifyMode != OPTIONAL_NO_CA) {
+                    X509_STORE_CTX_set_error(x509ctx, X509_V_ERR_APPLICATION_VERIFICATION());
+                    errnum = X509_V_ERR_APPLICATION_VERIFICATION();
+                    ok = 0;
+                }
+            } else {
+                int ocspResponse = processOCSP(x509ctx);
+                if (ocspResponse == V_OCSP_CERTSTATUS_REVOKED()) {
+                    ok = 0;
+                    errnum = X509_STORE_CTX_get_error(x509ctx);
+                } else if (ocspResponse == V_OCSP_CERTSTATUS_UNKNOWN()) {
+                    errnum = X509_STORE_CTX_get_error(x509ctx);
+                    if (errnum <= 0) {
+                        ok = 0;
+                    }
+                }
+            }
+        }
+
+        if (errdepth > state.certificateVerificationDepth) {
+            // Certificate Verification: Certificate Chain too long
+            ok = 0;
+        }
+        return ok;
+    }
+
+    static int processOCSP(MemoryAddress /*X509_STORE_CTX*/ x509ctx) {
+        int ocspResponse = V_OCSP_CERTSTATUS_UNKNOWN();
+        // ocspResponse = ssl_verify_OCSP(x509_ctx);
+        MemoryAddress x509 = X509_STORE_CTX_get_current_cert(x509ctx);
+        if (!MemoryAddress.NULL.equals(x509)) {
+            // No need to check cert->valid, because ssl_verify_OCSP() only
+            // is called if OpenSSL already successfully verified the certificate
+            // (parameter "ok" in SSL_callback_SSL_verify() must be true).
+            if (X509_check_issued(x509, x509) == X509_V_OK()) {
+                // don't do OCSP checking for valid self-issued certs
+                X509_STORE_CTX_set_error(x509ctx, X509_V_OK());
+            } else {
+                // If we can't get the issuer, we cannot perform OCSP verification
+                MemoryAddress issuer = X509_STORE_CTX_get0_current_issuer(x509ctx);
+                if (!MemoryAddress.NULL.equals(issuer)) {
+                    // sslutils.c ssl_ocsp_request(x509, issuer, x509ctx);
+                    int nid = X509_get_ext_by_NID(x509, NID_info_access(), -1);
+                    if (nid >= 0) {
+                        try (var memorySession = MemorySession.openConfined()) {
+                            MemoryAddress ext = X509_get_ext(x509, nid);
+                            MemoryAddress os = X509_EXTENSION_get_data(ext);
+                            int length = ASN1_STRING_length(os);
+                            MemoryAddress data = ASN1_STRING_get0_data(os);
+                            // ocsp_urls = decode_OCSP_url(os);
+                            byte[] asn1String = MemorySegment.ofAddress(data, length, memorySession).toArray(ValueLayout.JAVA_BYTE);
+                            Asn1Parser parser = new Asn1Parser(asn1String);
+                            // Parse the byte sequence
+                            ArrayList<String> urls = new ArrayList<>();
+                            try {
+                                parseOCSPURLs(parser, urls);
+                            } catch (Exception e) {
+                                log.error(sm.getString("engine.ocspParseError"), e);
+                            }
+                            if (!urls.isEmpty()) {
+                                // Use OpenSSL to build OCSP request
+                                for (String urlString : urls) {
+                                    try {
+                                        URL url = new URL(urlString);
+                                        ocspResponse = processOCSPRequest(url, issuer, x509, x509ctx, memorySession);
+                                        if (log.isDebugEnabled()) {
+                                            log.debug("OCSP response for URL: " + urlString + " was " + ocspResponse);
+                                        }
+                                    } catch (MalformedURLException e) {
+                                        log.warn(sm.getString("engine.invalidOCSPURL", urlString));
+                                    }
+                                    if (ocspResponse != V_OCSP_CERTSTATUS_UNKNOWN()) {
+                                        break;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        return ocspResponse;
+    }
+
+    private static final int ASN1_SEQUENCE = 0x30;
+    private static final int ASN1_OID      = 0x06;
+    private static final int ASN1_STRING   = 0x86;
+    private static final byte[] OCSP_OID = {0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01};
+
+    private static void parseOCSPURLs(Asn1Parser parser, ArrayList<String> urls) {
+        while (!parser.eof()) {
+            int tag = parser.peekTag();
+            if (tag == ASN1_SEQUENCE) {
+                parser.parseTag(ASN1_SEQUENCE);
+                parser.parseFullLength();
+            } else if (tag == ASN1_OID) {
+                parser.parseTag(ASN1_OID);
+                int oidLen = parser.parseLength();
+                byte[] oid = new byte[oidLen];
+                parser.parseBytes(oid);
+                if (Arrays.compareUnsigned(oid, 0, OCSP_OID.length, OCSP_OID, 0, OCSP_OID.length) == 0) {
+                    parser.parseTag(ASN1_STRING);
+                    int urlLen = parser.parseLength();
+                    byte[] url = new byte[urlLen];
+                    parser.parseBytes(url);
+                    urls.add(new String(url));
+                }
+            } else {
+                return;
+            }
+        }
+    }
+
+    private static int processOCSPRequest(URL url, MemoryAddress issuer, MemoryAddress x509,
+            MemoryAddress /*X509_STORE_CTX*/ x509ctx, MemorySession memorySession) {
+        MemoryAddress ocspRequest = MemoryAddress.NULL;
+        MemoryAddress ocspResponse = MemoryAddress.NULL;
+        MemoryAddress id = MemoryAddress.NULL;
+        MemoryAddress ocspOneReq = MemoryAddress.NULL;
+        HttpURLConnection connection = null;
+        MemoryAddress basicResponse = MemoryAddress.NULL;
+        MemoryAddress certId = MemoryAddress.NULL;
+        try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
+            var allocator = SegmentAllocator.newNativeArena(memorySession);
+            ocspRequest = OCSP_REQUEST_new();
+            if (MemoryAddress.NULL.equals(ocspRequest)) {
+                return V_OCSP_CERTSTATUS_UNKNOWN();
+            }
+            id = OCSP_cert_to_id(MemoryAddress.NULL, x509, issuer);
+            if (MemoryAddress.NULL.equals(id)) {
+                return V_OCSP_CERTSTATUS_UNKNOWN();
+            }
+            ocspOneReq = OCSP_request_add0_id(ocspRequest, id);
+            if (MemoryAddress.NULL.equals(ocspOneReq)) {
+                return V_OCSP_CERTSTATUS_UNKNOWN();
+            }
+            MemorySegment bufPointer = allocator.allocate(ValueLayout.ADDRESS, MemoryAddress.NULL);
+            int requestLength = i2d_OCSP_REQUEST(ocspRequest, bufPointer);
+            if (requestLength <= 0) {
+                return V_OCSP_CERTSTATUS_UNKNOWN();
+            }
+            MemoryAddress buf = bufPointer.get(ValueLayout.ADDRESS, 0);
+            // HTTP request with the following header
+            // POST urlPath HTTP/1.1
+            // Host: urlHost:urlPort
+            // Content-Type: application/ocsp-request
+            // Content-Length: ocspRequestData.length
+            byte[] ocspRequestData = MemorySegment.ofAddress(buf, requestLength, memorySession).toArray(ValueLayout.JAVA_BYTE);
+            connection = (HttpURLConnection) url.openConnection();
+            connection.setRequestMethod("POST");
+            connection.setDoInput(true);
+            connection.setDoOutput(true);
+            connection.setFixedLengthStreamingMode(requestLength);
+            connection.setRequestProperty("Content-Type", "application/ocsp-request");
+            connection.connect();
+            connection.getOutputStream().write(ocspRequestData);
+            int responseCode = connection.getResponseCode();
+            if (responseCode != HttpURLConnection.HTTP_OK) {
+                return V_OCSP_CERTSTATUS_UNKNOWN();
+            }
+            InputStream is = connection.getInputStream();
+            int read = 0;
+            byte[] responseBuf = new byte[1024];
+            while ((read = is.read(responseBuf)) > 0) {
+                baos.write(responseBuf, 0, read);
+            }
+            byte[] responseData = baos.toByteArray();
+            var nativeResponseData = allocator.allocateArray(ValueLayout.JAVA_BYTE, responseData);
+            var nativeResponseDataPointer = allocator.allocate(ValueLayout.ADDRESS, nativeResponseData);
+            ocspResponse = d2i_OCSP_RESPONSE(MemoryAddress.NULL, nativeResponseDataPointer, responseData.length);
+            if (!MemoryAddress.NULL.equals(ocspResponse)) {
+                if (OCSP_response_status(ocspResponse) == OCSP_RESPONSE_STATUS_SUCCESSFUL()) {
+                    basicResponse = OCSP_response_get1_basic(ocspResponse);
+                    certId = OCSP_cert_to_id(MemoryAddress.NULL, x509, issuer);
+                    if (MemoryAddress.NULL.equals(certId)) {
+                        return V_OCSP_CERTSTATUS_UNKNOWN();
+                    }
+                    // Find by serial number and get the matching response
+                    MemoryAddress singleResponse = OCSP_resp_get0(basicResponse, OCSP_resp_find(basicResponse, certId, -1));
+                    return OCSP_single_get0_status(singleResponse, MemoryAddress.NULL,
+                            MemoryAddress.NULL, MemoryAddress.NULL, MemoryAddress.NULL);
+                }
+            }
+        } catch (Exception e) {
+            log.warn(sm.getString("engine.ocspRequestError", url.toString()), e);
+        } finally {
+            if (MemoryAddress.NULL.equals(ocspResponse)) {
+                // Failed to get a valid response
+                X509_STORE_CTX_set_error(x509ctx, X509_V_ERR_APPLICATION_VERIFICATION());
+            }
+            OCSP_CERTID_free(certId);
+            OCSP_BASICRESP_free(basicResponse);
+            OCSP_RESPONSE_free(ocspResponse);
+            OCSP_REQUEST_free(ocspRequest);
+            if (connection != null) {
+                connection.disconnect();
+            }
+        }
+        return V_OCSP_CERTSTATUS_UNKNOWN();
+    }
+
+    @Override
+    public void setEnableSessionCreation(boolean b) {
+        if (!b) {
+            String msg = sm.getString("engine.noRestrictSessionCreation");
+            throw new UnsupportedOperationException(msg);
+        }
+    }
+
+    @Override
+    public boolean getEnableSessionCreation() {
+        return true;
+    }
+
+
+    private class OpenSSLSession implements SSLSession {
+
+        // lazy init for memory reasons
+        private Map<String, Object> values;
+
+        // Last accessed time
+        private long lastAccessedTime = -1;
+
+        @Override
+        public byte[] getId() {
+            byte[] id = null;
+            synchronized (OpenSSLEngine.this) {
+                if (!destroyed) {
+                    var allocator = SegmentAllocator.newNativeArena(engineMemorySession);
+                    MemorySegment lenPointer = allocator.allocate(ValueLayout.ADDRESS);
+                    var session = SSL_get_session(state.ssl);
+                    if (MemoryAddress.NULL.equals(session)) {
+                        return new byte[0];
+                    }
+                    MemoryAddress sessionId = SSL_SESSION_get_id(session, lenPointer);
+                    int len = lenPointer.get(ValueLayout.JAVA_INT, 0);
+                    id = (len == 0) ? new byte[0]
+                            : MemorySegment.ofAddress(sessionId, len, engineMemorySession).toArray(ValueLayout.JAVA_BYTE);
+                }
+            }
+
+            return id;
+        }
+
+        @Override
+        public SSLSessionContext getSessionContext() {
+            return sessionContext;
+        }
+
+        @Override
+        public long getCreationTime() {
+            // We need to multiply by 1000 as OpenSSL uses seconds and we need milliseconds.
+            long creationTime = 0;
+            synchronized (OpenSSLEngine.this) {
+                if (!destroyed) {
+                    var session = SSL_get_session(state.ssl);
+                    if (!MemoryAddress.NULL.equals(session)) {
+                        creationTime = SSL_SESSION_get_time(session);
+                    }
+                }
+            }
+            return creationTime * 1000L;
+        }
+
+        @Override
+        public long getLastAccessedTime() {
+            return (lastAccessedTime > 0) ? lastAccessedTime : getCreationTime();
+        }
+
+        @Override
+        public void invalidate() {
+            // NOOP
+        }
+
+        @Override
+        public boolean isValid() {
+            return false;
+        }
+
+        @Override
+        public void putValue(String name, Object value) {
+            if (name == null) {
+                throw new IllegalArgumentException(sm.getString("engine.nullName"));
+            }
+            if (value == null) {
+                throw new IllegalArgumentException(sm.getString("engine.nullValue"));
+            }
+            Map<String, Object> values = this.values;
+            if (values == null) {
+                // Use size of 2 to keep the memory overhead small
+                values = this.values = new HashMap<>(2);
+            }
+            Object old = values.put(name, value);
+            if (value instanceof SSLSessionBindingListener) {
+                ((SSLSessionBindingListener) value).valueBound(new SSLSessionBindingEvent(this, name));
+            }
+            notifyUnbound(old, name);
+        }
+
+        @Override
+        public Object getValue(String name) {
+            if (name == null) {
+                throw new IllegalArgumentException(sm.getString("engine.nullName"));
+            }
+            if (values == null) {
+                return null;
+            }
+            return values.get(name);
+        }
+
+        @Override
+        public void removeValue(String name) {
+            if (name == null) {
+                throw new IllegalArgumentException(sm.getString("engine.nullName"));
+            }
+            Map<String, Object> values = this.values;
+            if (values == null) {
+                return;
+            }
+            Object old = values.remove(name);
+            notifyUnbound(old, name);
+        }
+
+        @Override
+        public String[] getValueNames() {
+            Map<String, Object> values = this.values;
+            if (values == null || values.isEmpty()) {
+                return new String[0];
+            }
+            return values.keySet().toArray(new String[0]);
+        }
+
+        private void notifyUnbound(Object value, String name) {
+            if (value instanceof SSLSessionBindingListener) {
+                ((SSLSessionBindingListener) value).valueUnbound(new SSLSessionBindingEvent(this, name));
+            }
+        }
+
+        @Override
+        public Certificate[] getPeerCertificates() throws SSLPeerUnverifiedException {
+            // these are lazy created to reduce memory overhead
+            Certificate[] c = peerCerts;
+            if (c == null) {
+                byte[] clientCert;
+                byte[][] chain;
+                synchronized (OpenSSLEngine.this) {
+                    if (destroyed || SSL_in_init(state.ssl) != 0) {
+                        throw new SSLPeerUnverifiedException(sm.getString("engine.unverifiedPeer"));
+                    }
+                    chain = getPeerCertChain();
+                    if (!clientMode) {
+                        // if used on the server side SSL_get_peer_cert_chain(...) will not include the remote peer certificate.
+                        // We use SSL_get_peer_certificate to get it in this case and add it to our array later.
+                        //
+                        // See https://www.openssl.org/docs/ssl/SSL_get_peer_cert_chain.html
+                        clientCert = getPeerCertificate();
+                    } else {
+                        clientCert = null;
+                    }
+                }
+                if (chain == null && clientCert == null) {
+                    return null;
+                }
+                int len = 0;
+                if (chain != null) {
+                    len += chain.length;
+                }
+
+                int i = 0;
+                Certificate[] certificates;
+                if (clientCert != null) {
+                    len++;
+                    certificates = new Certificate[len];
+                    certificates[i++] = new OpenSSLX509Certificate(clientCert);
+                } else {
+                    certificates = new Certificate[len];
+                }
+                if (chain != null) {
+                    int a = 0;
+                    for (; i < certificates.length; i++) {
+                        certificates[i] = new OpenSSLX509Certificate(chain[a++]);
+                    }
+                }
+                c = peerCerts = certificates;
+            }
+            return c;
+        }
+
+        @Override
+        public Certificate[] getLocalCertificates() {
+            // FIXME (if possible): Not available in the OpenSSL API
+            return EMPTY_CERTIFICATES;
+        }
+
+        @Deprecated
+        @Override
+        public javax.security.cert.X509Certificate[] getPeerCertificateChain()
+                throws SSLPeerUnverifiedException {
+            // these are lazy created to reduce memory overhead
+            javax.security.cert.X509Certificate[] c = x509PeerCerts;
+            if (c == null) {
+                byte[][] chain;
+                synchronized (OpenSSLEngine.this) {
+                    if (destroyed || SSL_in_init(state.ssl) != 0) {
+                        throw new SSLPeerUnverifiedException(sm.getString("engine.unverifiedPeer"));
+                    }
+                    chain = getPeerCertChain();
+                }
+                if (chain == null) {
+                    throw new SSLPeerUnverifiedException(sm.getString("engine.unverifiedPeer"));
+                }
+                javax.security.cert.X509Certificate[] peerCerts =
+                        new javax.security.cert.X509Certificate[chain.length];
+                for (int i = 0; i < peerCerts.length; i++) {
+                    try {
+                        peerCerts[i] = javax.security.cert.X509Certificate.getInstance(chain[i]);
+                    } catch (javax.security.cert.CertificateException e) {
+                        throw new IllegalStateException(e);
+                    }
+                }
+                c = x509PeerCerts = peerCerts;
+            }
+            return c;
+        }
+
+        @Override
+        public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
+            Certificate[] peer = getPeerCertificates();
+            if (peer == null || peer.length == 0) {
+                return null;
+            }
+            return principal(peer);
+        }
+
+        @Override
+        public Principal getLocalPrincipal() {
+            Certificate[] local = getLocalCertificates();
+            if (local == null || local.length == 0) {
+                return null;
+            }
+            return principal(local);
+        }
+
+        private Principal principal(Certificate[] certs) {
+            return ((java.security.cert.X509Certificate) certs[0]).getIssuerX500Principal();
+        }
+
+        @Override
+        public String getCipherSuite() {
+            if (cipher == null) {
+                String ciphers;
+                synchronized (OpenSSLEngine.this) {
+                    if (!handshakeFinished) {
+                        return INVALID_CIPHER;
+                    }
+                    if (destroyed) {
+                        return INVALID_CIPHER;
+                    }
+                    ciphers = SSL_CIPHER_get_name(SSL_get_current_cipher(state.ssl)).getUtf8String(0);
+                }
+                String c = OpenSSLCipherConfigurationParser.openSSLToJsse(ciphers);
+                if (c != null) {
+                    cipher = c;
+                }
+            }
+            return cipher;
+        }
+
+        @Override
+        public String getProtocol() {
+            String applicationProtocol = OpenSSLEngine.this.applicationProtocol;
+            if (applicationProtocol == null) {
+                synchronized (OpenSSLEngine.this) {
+                    if (!destroyed) {
+                        applicationProtocol = getProtocolNegotiated();
+                    }
+                }
+                if (applicationProtocol == null) {
+                    applicationProtocol = fallbackApplicationProtocol;
+                }
+                if (applicationProtocol != null) {
+                    OpenSSLEngine.this.applicationProtocol = applicationProtocol.replace(':', '_');
+                } else {
+                    OpenSSLEngine.this.applicationProtocol = applicationProtocol = "";
+                }
+            }
+            String version = null;
+            synchronized (OpenSSLEngine.this) {
+                if (!destroyed) {
+                    version = SSL_get_version(state.ssl).getUtf8String(0);
+                }
+            }
+            if (applicationProtocol.isEmpty()) {
+                return version;
+            } else {
+                return version + ':' + applicationProtocol;
+            }
+        }
+
+        @Override
+        public String getPeerHost() {
+            // Not available for now in Tomcat (needs to be passed during engine creation)
+            return null;
+        }
+
+        @Override
+        public int getPeerPort() {
+            // Not available for now in Tomcat (needs to be passed during engine creation)
+            return 0;
+        }
+
+        @Override
+        public int getPacketBufferSize() {
+            return MAX_ENCRYPTED_PACKET_LENGTH;
+        }
+
+        @Override
+        public int getApplicationBufferSize() {
+            return MAX_PLAINTEXT_LENGTH;
+        }
+
+    }
+
+    private static class EngineState implements Runnable {
+
+        private final MemoryAddress ssl;
+        private final MemoryAddress networkBIO;
+        private final int certificateVerificationDepth;
+        private final boolean noOcspCheck;
+
+        private PHAState phaState = PHAState.NONE;
+        private int certificateVerifyMode = 0;
+        private int handshakeCount = 0;
+
+        private EngineState(MemoryAddress ssl, MemoryAddress networkBIO,
+                int certificateVerificationDepth, boolean noOcspCheck) {
+            states.put(Long.valueOf(ssl.toRawLongValue()), this);
+            this.ssl = ssl;
+            this.networkBIO = networkBIO;
+            this.certificateVerificationDepth = certificateVerificationDepth;
+            this.noOcspCheck = noOcspCheck;
+        }
+
+        @Override
+        public void run() {
+            states.remove(Long.valueOf(ssl.toRawLongValue()));
+            BIO_free(networkBIO);
+            SSL_free(ssl);
+        }
+    }
+}

==================================================
OpenSSLLifecycleListener.java
new file mode 100644
index 0000000000..28d7ae2b8f
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/net/openssl/panama/OpenSSLImplementation.java
@@ -0,0 +1,51 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.util.net.openssl.panama;
+
+import java.util.List;
+import java.util.Map;
+
+import javax.net.ssl.SSLSession;
+
+import org.apache.tomcat.util.net.SSLHostConfigCertificate;
+import org.apache.tomcat.util.net.SSLImplementation;
+import org.apache.tomcat.util.net.SSLSupport;
+import org.apache.tomcat.util.net.SSLUtil;
+import org.apache.tomcat.util.net.jsse.JSSESupport;
+
+public class OpenSSLImplementation extends SSLImplementation {
+
+    @Deprecated
+    public SSLSupport getSSLSupport(SSLSession session) {
+        return new JSSESupport(session, null);
+    }
+
+    @Override
+    public SSLSupport getSSLSupport(SSLSession session, Map<String, List<String>> additionalAttributes) {
+        return new JSSESupport(session, additionalAttributes);
+    }
+
+    @Override
+    public SSLUtil getSSLUtil(SSLHostConfigCertificate certificate) {
+        return new OpenSSLUtil(certificate);
+    }
+
+    public boolean isAlpnSupported() {
+        // OpenSSL supported ALPN
+        return true;
+    }
+}

==================================================
OpenSSLSessionContext.java
new file mode 100644
index 0000000000..426c9a5873
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/net/openssl/panama/OpenSSLLifecycleListener.java
@@ -0,0 +1,424 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.util.net.openssl.panama;
+
+
+import static org.apache.tomcat.util.openssl.openssl_h.*;
+
+import java.lang.foreign.MemoryAddress;
+import java.lang.foreign.MemorySession;
+import java.lang.foreign.SegmentAllocator;
+import java.lang.foreign.ValueLayout;
+import java.security.SecureRandom;
+
+import org.apache.catalina.Lifecycle;
+import org.apache.catalina.LifecycleEvent;
+import org.apache.catalina.LifecycleListener;
+import org.apache.catalina.Server;
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+import org.apache.tomcat.util.ExceptionUtils;
+import org.apache.tomcat.util.res.StringManager;
+
+
+
+/**
+ * Implementation of <code>LifecycleListener</code> that will do the global
+ * initialization of OpenSSL according to specified configuration parameters.
+ * Using the listener is completely optional, but is needed for configuration
+ * and full cleanup of a few native memory allocations.
+ */
+public class OpenSSLLifecycleListener implements LifecycleListener {
+
+    private static final Log log = LogFactory.getLog(OpenSSLLifecycleListener.class);
+
+    /**
+     * The string manager for this package.
+     */
+    protected static final StringManager sm = StringManager.getManager(OpenSSLLifecycleListener.class);
+
+
+    // ---------------------------------------------- Properties
+    protected static String SSLEngine = "on"; //default on
+    protected static String FIPSMode = "off"; // default off, valid only when SSLEngine="on"
+    protected static String SSLRandomSeed = "builtin";
+    protected static boolean fipsModeActive = false;
+
+    /**
+     * The "FIPS mode" level that we use as the argument to OpenSSL method
+     * <code>FIPS_mode_set()</code> to enable FIPS mode and that we expect as
+     * the return value of <code>FIPS_mode()</code> when FIPS mode is enabled.
+     * <p>
+     * In the future the OpenSSL library might grow support for different
+     * non-zero "FIPS" modes that specify different allowed subsets of ciphers
+     * or whatever, but nowadays only "1" is the supported value.
+     * </p>
+     * @see <a href="http://wiki.openssl.org/index.php/FIPS_mode_set%28%29">OpenSSL method FIPS_mode_set()</a>
+     * @see <a href="http://wiki.openssl.org/index.php/FIPS_mode%28%29">OpenSSL method FIPS_mode()</a>
+     */
+    private static final int FIPS_ON = 1;
+
+    private static final int FIPS_OFF = 0;
+
+    protected static final Object lock = new Object();
+
+    public static boolean isAvailable() {
+        if (OpenSSLStatus.isInstanceCreated()) {
+            synchronized (lock) {
+                init();
+            }
+        }
+        return OpenSSLStatus.isAvailable();
+    }
+
+    public OpenSSLLifecycleListener() {
+        OpenSSLStatus.setInstanceCreated(true);
+    }
+
+    // ---------------------------------------------- LifecycleListener Methods
+
+    /**
+     * Primary entry point for startup and shutdown events.
+     *
+     * @param event The event that has occurred
+     */
+    @Override
+    public void lifecycleEvent(LifecycleEvent event) {
+
+        boolean initError = false;
+        if (Lifecycle.BEFORE_INIT_EVENT.equals(event.getType())) {
+            if (!(event.getLifecycle() instanceof Server)) {
+                log.warn(sm.getString("listener.notServer",
+                        event.getLifecycle().getClass().getSimpleName()));
+            }
+            try {
+                init();
+            } catch (Throwable t) {
+                t = ExceptionUtils.unwrapInvocationTargetException(t);
+                ExceptionUtils.handleThrowable(t);
+                log.error(sm.getString("listener.sslInit"), t);
+                initError = true;
+            }
+            // Failure to initialize FIPS mode is fatal
+            if (!(null == FIPSMode || "off".equalsIgnoreCase(FIPSMode)) && !isFIPSModeActive()) {
+                String errorMessage = sm.getString("listener.initializeFIPSFailed");
+                Error e = new Error(errorMessage);
+                // Log here, because thrown error might be not logged
+                log.fatal(errorMessage, e);
+                initError = true;
+            }
+        }
+        if (initError || Lifecycle.AFTER_DESTROY_EVENT.equals(event.getType())) {
+            // Note: Without the listener, destroy will never be called (which is not a significant problem)
+            try {
+                destroy();
+            } catch (Throwable t) {
+                t = ExceptionUtils.unwrapInvocationTargetException(t);
+                ExceptionUtils.handleThrowable(t);
+                log.info(sm.getString("listener.destroy"));
+            }
+        }
+
+    }
+
+    static MemoryAddress enginePointer = MemoryAddress.NULL;
+
+    static void initLibrary() {
+        synchronized (lock) {
+            if (OpenSSLStatus.isLibraryInitialized()) {
+                return;
+            }
+            OPENSSL_init_ssl(OPENSSL_INIT_ENGINE_ALL_BUILTIN(), MemoryAddress.NULL);
+            OpenSSLStatus.setLibraryInitialized(true);
+        }
+    }
+
+    /*
+    { BN_get_rfc3526_prime_8192, NULL, 6145 },
+    { BN_get_rfc3526_prime_6144, NULL, 4097 },
+    { BN_get_rfc3526_prime_4096, NULL, 3073 },
+    { BN_get_rfc3526_prime_3072, NULL, 2049 },
+    { BN_get_rfc3526_prime_2048, NULL, 1025 },
+    { BN_get_rfc2409_prime_1024, NULL, 0 }
+     */
+    static final class DHParam {
+        final MemoryAddress dh;
+        final int min;
+        private DHParam(MemoryAddress dh, int min) {
+            this.dh = dh;
+            this.min = min;
+        }
+    }
+    static final DHParam[] dhParameters = new DHParam[6];
+
+    private static void initDHParameters() {
+        var dh = DH_new();
+        var p = BN_get_rfc3526_prime_8192(MemoryAddress.NULL);
+        var g = BN_new();
+        BN_set_word(g, 2);
+        DH_set0_pqg(dh, p, MemoryAddress.NULL, g);
+        dhParameters[0] = new DHParam(dh, 6145);
+        dh = DH_new();
+        p = BN_get_rfc3526_prime_6144(MemoryAddress.NULL);
+        g = BN_new();
+        BN_set_word(g, 2);
+        DH_set0_pqg(dh, p, MemoryAddress.NULL, g);
+        dhParameters[1] = new DHParam(dh, 4097);
+        dh = DH_new();
+        p = BN_get_rfc3526_prime_4096(MemoryAddress.NULL);
+        g = BN_new();
+        BN_set_word(g, 2);
+        DH_set0_pqg(dh, p, MemoryAddress.NULL, g);
+        dhParameters[2] = new DHParam(dh, 3073);
+        dh = DH_new();
+        p = BN_get_rfc3526_prime_3072(MemoryAddress.NULL);
+        g = BN_new();
+        BN_set_word(g, 2);
+        DH_set0_pqg(dh, p, MemoryAddress.NULL, g);
+        dhParameters[3] = new DHParam(dh, 2049);
+        dh = DH_new();
+        p = BN_get_rfc3526_prime_2048(MemoryAddress.NULL);
+        g = BN_new();
+        BN_set_word(g, 2);
+        DH_set0_pqg(dh, p, MemoryAddress.NULL, g);
+        dhParameters[4] = new DHParam(dh, 1025);
+        dh = DH_new();
+        p = BN_get_rfc2409_prime_1024(MemoryAddress.NULL);
+        g = BN_new();
+        BN_set_word(g, 2);
+        DH_set0_pqg(dh, p, MemoryAddress.NULL, g);
+        dhParameters[5] = new DHParam(dh, 0);
+    }
+
+    private static void freeDHParameters() {
+        for (int i = 0; i < dhParameters.length; i++) {
+            if (dhParameters[i] != null) {
+                MemoryAddress dh = dhParameters[i].dh;
+                if (dh != null && !MemoryAddress.NULL.equals(dh)) {
+                    DH_free(dh);
+                    dhParameters[i] = null;
+                }
+            }
+        }
+    }
+
+    static void init() {
+        synchronized (lock) {
+
+            if (OpenSSLStatus.isInitialized()) {
+                return;
+            }
+            OpenSSLStatus.setInitialized(true);
+
+            if ("off".equalsIgnoreCase(SSLEngine)) {
+                return;
+            }
+
+            var memorySession = MemorySession.global();
+            var allocator = SegmentAllocator.newNativeArena(memorySession);
+
+            // Main library init
+            initLibrary();
+
+            // Setup engine
+            String engineName = "on".equalsIgnoreCase(SSLEngine) ? null : SSLEngine;
+            if (engineName != null) {
+                if ("auto".equals(engineName)) {
+                    ENGINE_register_all_complete();
+                } else {
+                    var engine = allocator.allocateUtf8String(engineName);
+                    enginePointer = ENGINE_by_id(engine);
+                    if (MemoryAddress.NULL.equals(enginePointer)) {
+                        enginePointer = ENGINE_by_id(allocator.allocateUtf8String("dynamic"));
+                        if (enginePointer != null) {
+                            if (ENGINE_ctrl_cmd_string(enginePointer, allocator.allocateUtf8String("SO_PATH"), engine, 0) == 0
+                                    || ENGINE_ctrl_cmd_string(enginePointer, allocator.allocateUtf8String("LOAD"),
+                                            MemoryAddress.NULL, 0) == 0) {
+                                // Engine load error
+                                ENGINE_free(enginePointer);
+                                enginePointer = MemoryAddress.NULL;
+                            }
+                        }
+                    }
+                    if (!MemoryAddress.NULL.equals(enginePointer)) {
+                        if (ENGINE_set_default(enginePointer, ENGINE_METHOD_ALL()) == 0) {
+                            // Engine load error
+                            ENGINE_free(enginePointer);
+                            enginePointer = MemoryAddress.NULL;
+                        }
+                    }
+                    if (MemoryAddress.NULL.equals(enginePointer)) {
+                        throw new IllegalStateException(sm.getString("listener.engineError"));
+                    }
+                }
+            }
+
+            // Set the random seed, translated to the Java way
+            boolean seedDone = false;
+            if (SSLRandomSeed != null || SSLRandomSeed.length() != 0 || !"builtin".equals(SSLRandomSeed)) {
+                var randomSeed = allocator.allocateUtf8String(SSLRandomSeed);
+                seedDone = RAND_load_file(randomSeed, 128) > 0;
+            }
+            if (!seedDone) {
+                // Use a regular random to get some bytes
+                SecureRandom random = new SecureRandom();
+                byte[] randomBytes = random.generateSeed(128);
+                RAND_seed(allocator.allocateArray(ValueLayout.JAVA_BYTE, randomBytes), 128);
+            }
+
+            initDHParameters();
+
+            if (!(null == FIPSMode || "off".equalsIgnoreCase(FIPSMode))) {
+
+                fipsModeActive = false;
+
+                final boolean enterFipsMode;
+                int fipsModeState = FIPS_mode();
+
+                if(log.isDebugEnabled()) {
+                    log.debug(sm.getString("listener.currentFIPSMode",
+                            Integer.valueOf(fipsModeState)));
+                }
+
+                if ("on".equalsIgnoreCase(FIPSMode)) {
+                    if (fipsModeState == FIPS_ON) {
+                        log.info(sm.getString("listener.skipFIPSInitialization"));
+                        fipsModeActive = true;
+                        enterFipsMode = false;
+                    } else {
+                        enterFipsMode = true;
+                    }
+                } else if ("require".equalsIgnoreCase(FIPSMode)) {
+                    if (fipsModeState == FIPS_ON) {
+                        fipsModeActive = true;
+                        enterFipsMode = false;
+                    } else {
+                        throw new IllegalStateException(
+                                sm.getString("listener.requireNotInFIPSMode"));
+                    }
+                } else if ("enter".equalsIgnoreCase(FIPSMode)) {
+                    if (fipsModeState == FIPS_OFF) {
+                        enterFipsMode = true;
+                    } else {
+                        throw new IllegalStateException(sm.getString(
+                                "listener.enterAlreadyInFIPSMode",
+                                Integer.valueOf(fipsModeState)));
+                    }
+                } else {
+                    throw new IllegalArgumentException(sm.getString(
+                            "listener.wrongFIPSMode", FIPSMode));
+                }
+
+                if (enterFipsMode) {
+                    log.info(sm.getString("listener.initializingFIPS"));
+
+                    fipsModeState = FIPS_mode_set(FIPS_ON);
+                    if (fipsModeState != FIPS_ON) {
+                        // This case should be handled by the native method,
+                        // but we'll make absolutely sure, here.
+                        String message = sm.getString("listener.initializeFIPSFailed");
+                        log.error(message);
+                        throw new IllegalStateException(message);
+                    }
+
+                    fipsModeActive = true;
+                    log.info(sm.getString("listener.initializeFIPSSuccess"));
+                }
+            }
+
+            log.info(sm.getString("listener.initializedOpenSSL", OpenSSL_version(0).getUtf8String(0)));
+            OpenSSLStatus.setAvailable(true);
+        }
+    }
+
+    static void destroy() {
+        synchronized (lock) {
+            if (!OpenSSLStatus.isInitialized()) {
+                return;
+            }
+            OpenSSLStatus.setAvailable(false);
+
+            try {
+                freeDHParameters();
+                if (!MemoryAddress.NULL.equals(enginePointer)) {
+                    ENGINE_free(enginePointer);
+                }
+                FIPS_mode_set(0);
+            } finally {
+                OpenSSLStatus.setInitialized(false);
+                fipsModeActive = false;
+            }
+        }
+    }
+
+    public String getSSLEngine() {
+        return SSLEngine;
+    }
+
+    public void setSSLEngine(String SSLEngine) {
+        if (!SSLEngine.equals(OpenSSLLifecycleListener.SSLEngine)) {
+            // Ensure that the SSLEngine is consistent with that used for SSL init
+            if (OpenSSLStatus.isInitialized()) {
+                throw new IllegalStateException(
+                        sm.getString("listener.tooLateForSSLEngine"));
+            }
+
+            OpenSSLLifecycleListener.SSLEngine = SSLEngine;
+        }
+    }
+
+    public String getSSLRandomSeed() {
+        return SSLRandomSeed;
+    }
+
+    public void setSSLRandomSeed(String SSLRandomSeed) {
+        if (!SSLRandomSeed.equals(OpenSSLLifecycleListener.SSLRandomSeed)) {
+            // Ensure that the random seed is consistent with that used for SSL init
+            if (OpenSSLStatus.isInitialized()) {
+                throw new IllegalStateException(
+                        sm.getString("listener.tooLateForSSLRandomSeed"));
+            }
+
+            OpenSSLLifecycleListener.SSLRandomSeed = SSLRandomSeed;
+        }
+    }
+
+    public String getFIPSMode() {
+        return FIPSMode;
+    }
+
+    public void setFIPSMode(String FIPSMode) {
+        if (!FIPSMode.equals(OpenSSLLifecycleListener.FIPSMode)) {
+            // Ensure that the FIPS mode is consistent with that used for SSL init
+            if (OpenSSLStatus.isInitialized()) {
+                throw new IllegalStateException(
+                        sm.getString("listener.tooLateForFIPSMode"));
+            }
+
+            OpenSSLLifecycleListener.FIPSMode = FIPSMode;
+        }
+    }
+
+    public boolean isFIPSModeActive() {
+        return fipsModeActive;
+    }
+
+    public static boolean isInstanceCreated() {
+        return OpenSSLStatus.isInstanceCreated();
+    }
+
+}

==================================================
OpenSSLSessionStats.java
new file mode 100644
index 0000000000..d358b27277
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/net/openssl/panama/OpenSSLSessionContext.java
@@ -0,0 +1,165 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.util.net.openssl.panama;
+
+import java.lang.foreign.MemorySession;
+import java.lang.foreign.SegmentAllocator;
+import java.lang.foreign.ValueLayout;
+import java.util.Enumeration;
+import java.util.NoSuchElementException;
+
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSessionContext;
+
+import static org.apache.tomcat.util.openssl.openssl_h.*;
+
+import org.apache.tomcat.util.res.StringManager;
+
+/**
+ * OpenSSL specific {@link SSLSessionContext} implementation.
+ */
+public class OpenSSLSessionContext implements SSLSessionContext {
+    private static final StringManager sm = StringManager.getManager(OpenSSLSessionContext.class);
+    private static final Enumeration<byte[]> EMPTY = new EmptyEnumeration();
+
+    private static final int TICKET_KEYS_SIZE = 48;
+
+    private final OpenSSLSessionStats stats;
+    private final OpenSSLContext context;
+
+    OpenSSLSessionContext(OpenSSLContext context) {
+        this.context = context;
+        stats = new OpenSSLSessionStats(context.getSSLContext());
+    }
+
+    @Override
+    public SSLSession getSession(byte[] bytes) {
+        return null;
+    }
+
+    @Override
+    public Enumeration<byte[]> getIds() {
+        return EMPTY;
+    }
+
+    /**
+     * Sets the SSL session ticket keys of this context.
+     *
+     * @param keys The session ticket keys
+     */
+    public void setTicketKeys(byte[] keys) {
+        if (keys == null) {
+            throw new IllegalArgumentException(sm.getString("sessionContext.nullTicketKeys"));
+        }
+        if (keys.length != TICKET_KEYS_SIZE) {
+            throw new IllegalArgumentException(sm.getString("sessionContext.invalidTicketKeysLength", keys.length));
+        }
+        try (var memorySession = MemorySession.openConfined()) {
+            var array = SegmentAllocator.newNativeArena(memorySession).allocateArray(ValueLayout.JAVA_BYTE, keys);
+            // #define SSL_CTX_set_tlsext_ticket_keys(ctx, keys, keylen)
+            //     SSL_CTX_ctrl((ctx),SSL_CTRL_SET_TLSEXT_TICKET_KEYS, (keylen), (keys))
+            SSL_CTX_ctrl(context.getSSLContext(), SSL_CTRL_SET_TLSEXT_TICKET_KEYS(), TICKET_KEYS_SIZE, array);
+        }
+    }
+
+    /**
+     * Enable or disable caching of SSL sessions.
+     *
+     * @param enabled {@code true} to enable caching, {@code false} to disable
+     */
+    public void setSessionCacheEnabled(boolean enabled) {
+        long mode = enabled ? SSL_SESS_CACHE_SERVER() : SSL_SESS_CACHE_OFF();
+        // # define SSL_CTX_set_session_cache_mode(ctx,m) \
+        //     SSL_CTX_ctrl(ctx,SSL_CTRL_SET_SESS_CACHE_MODE,m,NULL)
+        SSL_CTX_ctrl(context.getSSLContext(), SSL_CTRL_SET_SESS_CACHE_MODE(), mode, null);
+    }
+
+    /**
+     * @return {@code true} if caching of SSL sessions is enabled, {@code false}
+     *         otherwise.
+     */
+    public boolean isSessionCacheEnabled() {
+        // # define SSL_CTX_get_session_cache_mode(ctx) \
+        //    SSL_CTX_ctrl(ctx,SSL_CTRL_GET_SESS_CACHE_MODE,0,NULL)
+        return SSL_CTX_ctrl(context.getSSLContext(), SSL_CTRL_GET_SESS_CACHE_MODE(), 0, null) == SSL_SESS_CACHE_SERVER();
+    }
+
+    /**
+     * @return The statistics for this context.
+     */
+    public OpenSSLSessionStats stats() {
+        return stats;
+    }
+
+    @Override
+    public void setSessionTimeout(int seconds) {
+        if (seconds < 0) {
+            throw new IllegalArgumentException();
+        }
+        SSL_CTX_set_timeout(context.getSSLContext(), seconds);
+    }
+
+    @Override
+    public int getSessionTimeout() {
+        return (int) SSL_CTX_get_timeout(context.getSSLContext());
+    }
+
+    @Override
+    public void setSessionCacheSize(int size) {
+        if (size < 0) {
+            throw new IllegalArgumentException();
+        }
+        // # define SSL_CTX_sess_set_cache_size(ctx,t) \
+        //     SSL_CTX_ctrl(ctx,SSL_CTRL_SET_SESS_CACHE_SIZE,t,NULL)
+        SSL_CTX_ctrl(context.getSSLContext(), SSL_CTRL_SET_SESS_CACHE_SIZE(), size, null);
+    }
+
+    @Override
+    public int getSessionCacheSize() {
+        // # define SSL_CTX_sess_get_cache_size(ctx) \
+        //     SSL_CTX_ctrl(ctx,SSL_CTRL_GET_SESS_CACHE_SIZE,0,NULL)
+        return (int) SSL_CTX_ctrl(context.getSSLContext(), SSL_CTRL_GET_SESS_CACHE_SIZE(), 0, null);
+    }
+
+    /**
+     * Set the context within which session be reused (server side only)
+     * See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_session_id_context.html">
+     *     man SSL_CTX_set_session_id_context</a>
+     *
+     * @param sidCtx can be any kind of binary data, it is therefore possible to use e.g. the name
+     *               of the application and/or the hostname and/or service name
+     * @return {@code true} if success, {@code false} otherwise.
+     */
+    public boolean setSessionIdContext(byte[] sidCtx) {
+        try (var memorySession = MemorySession.openConfined()) {
+            var array = SegmentAllocator.newNativeArena(memorySession).allocateArray(ValueLayout.JAVA_BYTE, sidCtx);
+            return (SSL_CTX_set_session_id_context(context.getSSLContext(), array, sidCtx.length) == 1);
+        }
+    }
+
+    private static final class EmptyEnumeration implements Enumeration<byte[]> {
+        @Override
+        public boolean hasMoreElements() {
+            return false;
+        }
+
+        @Override
+        public byte[] nextElement() {
+            throw new NoSuchElementException();
+        }
+    }
+}

==================================================
OpenSSLStatus.java
new file mode 100644
index 0000000000..4ef51983b0
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/net/openssl/panama/OpenSSLSessionStats.java
@@ -0,0 +1,128 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.util.net.openssl.panama;
+
+import static org.apache.tomcat.util.openssl.openssl_h.*;
+
+import java.lang.foreign.MemoryAddress;
+
+/**
+ * Stats exposed by an OpenSSL session context.
+ *
+ * @see <a href="https://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html"><code>SSL_CTX_sess_number</code></a>
+ */
+public final class OpenSSLSessionStats {
+
+    private final MemoryAddress ctx;
+
+    OpenSSLSessionStats(MemoryAddress ctx) {
+        this.ctx = ctx;
+    }
+
+    /**
+     * @return The current number of sessions in the internal session cache.
+     */
+    public long number() {
+        return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_NUMBER(), 0, null);
+    }
+
+    /**
+     * @return The number of started SSL/TLS handshakes in client mode.
+     */
+    public long connect() {
+        return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_CONNECT() ,0, null);
+    }
+
+    /**
+     * @return The number of successfully established SSL/TLS sessions in client mode.
+     */
+    public long connectGood() {
+        return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_CONNECT_GOOD() , 0, null);
+    }
+
+    /**
+     * @return The number of start renegotiations in client mode.
+     */
+    public long connectRenegotiate() {
+        return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_CONNECT_RENEGOTIATE() , 0, null);
+    }
+
+    /**
+     * @return The number of started SSL/TLS handshakes in server mode.
+     */
+    public long accept() {
+        return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_ACCEPT(), 0, null);
+    }
+
+    /**
+     * @return The number of successfully established SSL/TLS sessions in server mode.
+     */
+    public long acceptGood() {
+        return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_ACCEPT_GOOD(), 0, null);
+    }
+
+    /**
+     * @return The number of start renegotiations in server mode.
+     */
+    public long acceptRenegotiate() {
+        return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_ACCEPT_RENEGOTIATE(), 0, null);
+    }
+
+    /**
+     * @return The number of successfully reused sessions. In client mode, a
+     *         session set with {@code SSL_set_session} successfully reused is
+     *         counted as a hit. In server mode, a session successfully
+     *         retrieved from internal or external cache is counted as a hit.
+     */
+    public long hits() {
+        return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_HIT(), 0, null);
+    }
+
+    /**
+     * @return The number of successfully retrieved sessions from the external
+     *         session cache in server mode.
+     */
+    public long cbHits() {
+        return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_CB_HIT(), 0, null);
+    }
+
+    /**
+     * @return The number of sessions proposed by clients that were not found in
+     *         the internal session cache in server mode.
+     */
+    public long misses() {
+        return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_MISSES(), 0, null);
+    }
+
+    /**
+     * @return The number of sessions proposed by clients and either found in
+     *         the internal or external session cache in server mode, but that
+     *         were invalid due to timeout. These sessions are not included in
+     *         the {@link #hits()} count.
+     */
+    public long timeouts() {
+        return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_TIMEOUTS(), 0, null);
+    }
+
+    /**
+     * @return The number of sessions that were removed because the maximum
+     *         session cache size was exceeded.
+     */
+    public long cacheFull() {
+        return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_CACHE_FULL(), 0, null);
+    }
+}

==================================================
OpenSSLUtil.java
new file mode 100644
index 0000000000..a45f442708
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/net/openssl/panama/OpenSSLStatus.java
@@ -0,0 +1,60 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.util.net.openssl.panama;
+
+/**
+ * Holds OpenSSL status without the need to load other classes.
+ */
+public class OpenSSLStatus {
+    private static volatile boolean libraryInitialized = false;
+    private static volatile boolean initialized = false;
+    private static volatile boolean available = false;
+    private static volatile boolean instanceCreated = false;
+
+
+    public static boolean isLibraryInitialized() {
+        return libraryInitialized;
+    }
+
+    public static boolean isInitialized() {
+        return initialized;
+    }
+
+    public static boolean isAvailable() {
+        return available;
+    }
+
+    public static boolean isInstanceCreated() {
+        return instanceCreated;
+    }
+
+    public static void setLibraryInitialized(boolean libraryInitialized) {
+        OpenSSLStatus.libraryInitialized = libraryInitialized;
+    }
+
+    public static void setInitialized(boolean initialized) {
+        OpenSSLStatus.initialized = initialized;
+    }
+
+    public static void setAvailable(boolean available) {
+        OpenSSLStatus.available = available;
+    }
+
+    public static void setInstanceCreated(boolean instanceCreated) {
+        OpenSSLStatus.instanceCreated = instanceCreated;
+    }
+}

==================================================
OpenSSLX509Certificate.java
new file mode 100644
index 0000000000..781dd4889a
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/net/openssl/panama/OpenSSLUtil.java
@@ -0,0 +1,128 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.util.net.openssl.panama;
+
+import java.io.IOException;
+import java.security.KeyStoreException;
+import java.util.List;
+import java.util.Set;
+
+import javax.net.ssl.KeyManager;
+import javax.net.ssl.X509KeyManager;
+
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+import org.apache.tomcat.util.net.SSLContext;
+import org.apache.tomcat.util.net.SSLHostConfigCertificate;
+import org.apache.tomcat.util.net.SSLUtilBase;
+import org.apache.tomcat.util.net.jsse.JSSEKeyManager;
+import org.apache.tomcat.util.res.StringManager;
+
+public class OpenSSLUtil extends SSLUtilBase {
+
+    private static final Log log = LogFactory.getLog(OpenSSLUtil.class);
+    private static final StringManager sm = StringManager.getManager(OpenSSLUtil.class);
+
+
+    public OpenSSLUtil(SSLHostConfigCertificate certificate) {
+        super(certificate);
+    }
+
+
+    @Override
+    protected Log getLog() {
+        return log;
+    }
+
+
+    @Override
+    protected Set<String> getImplementedProtocols() {
+        return OpenSSLEngine.IMPLEMENTED_PROTOCOLS_SET;
+    }
+
+
+    @Override
+    protected Set<String> getImplementedCiphers() {
+        return OpenSSLEngine.AVAILABLE_CIPHER_SUITES;
+    }
+
+
+    @Override
+    protected boolean isTls13RenegAuthAvailable() {
+        // OpenSSL does support authentication after the initial handshake
+        return true;
+    }
+
+
+    @Override
+    public SSLContext createSSLContextInternal(List<String> negotiableProtocols) throws Exception {
+        return new OpenSSLContext(certificate, negotiableProtocols);
+    }
+
+
+    public static X509KeyManager chooseKeyManager(KeyManager[] managers) throws Exception {
+        if (managers == null) {
+            return null;
+        }
+        for (KeyManager manager : managers) {
+            if (manager instanceof JSSEKeyManager) {
+                return (JSSEKeyManager) manager;
+            }
+        }
+        for (KeyManager manager : managers) {
+            if (manager instanceof X509KeyManager) {
+                return (X509KeyManager) manager;
+            }
+        }
+        throw new IllegalStateException(sm.getString("openssl.keyManagerMissing"));
+    }
+
+
+    @Override
+    public KeyManager[] getKeyManagers() throws Exception {
+        try {
+            return super.getKeyManagers();
+        } catch (IllegalArgumentException e) {
+            // No (or invalid?) certificate chain was provided for the cert
+            String msg = sm.getString("openssl.nonJsseChain", certificate.getCertificateChainFile());
+            if (log.isDebugEnabled()) {
+                log.info(msg, e);
+            } else {
+                log.info(msg);
+            }
+            return null;
+        } catch (KeyStoreException | IOException e) {
+            // Depending on what is presented, JSSE may also throw
+            // KeyStoreException or IOException if it doesn't understand the
+            // provided file.
+            if (certificate.getCertificateFile() != null) {
+                String msg = sm.getString("openssl.nonJsseCertificate",
+                        certificate.getCertificateFile(), certificate.getCertificateKeyFile());
+                if (log.isDebugEnabled()) {
+                    log.info(msg, e);
+                } else {
+                    log.info(msg);
+                }
+                // Assume JSSE processing of the certificate failed, try again with OpenSSL
+                // without a key manager
+                return null;
+            }
+            throw e;
+        }
+    }
+
+}

==================================================
RuntimeHelper.java
new file mode 100644
index 0000000000..b4e6f381bf
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/net/openssl/panama/OpenSSLX509Certificate.java
@@ -0,0 +1,190 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.util.net.openssl.panama;
+
+import java.io.ByteArrayInputStream;
+import java.math.BigInteger;
+import java.security.InvalidKeyException;
+import java.security.NoSuchAlgorithmException;
+import java.security.NoSuchProviderException;
+import java.security.Principal;
+import java.security.PublicKey;
+import java.security.SignatureException;
+import java.security.cert.CertificateEncodingException;
+import java.security.cert.CertificateException;
+import java.security.cert.CertificateExpiredException;
+import java.security.cert.CertificateNotYetValidException;
+import java.security.cert.X509Certificate;
+import java.util.Date;
+import java.util.Set;
+
+final class OpenSSLX509Certificate extends X509Certificate {
+
+    private final byte[] bytes;
+    private X509Certificate wrapped;
+
+    public OpenSSLX509Certificate(byte[] bytes) {
+        this.bytes = bytes;
+    }
+
+    @Override
+    public void checkValidity() throws CertificateExpiredException, CertificateNotYetValidException {
+        unwrap().checkValidity();
+    }
+
+    @Override
+    public void checkValidity(Date date) throws CertificateExpiredException, CertificateNotYetValidException {
+        unwrap().checkValidity(date);
+    }
+
+    @Override
+    public int getVersion() {
+        return unwrap().getVersion();
+    }
+
+    @Override
+    public BigInteger getSerialNumber() {
+        return unwrap().getSerialNumber();
+    }
+
+    @Override
+    public Principal getIssuerDN() {
+        return unwrap().getIssuerDN();
+    }
+
+    @Override
+    public Principal getSubjectDN() {
+        return unwrap().getSubjectDN();
+    }
+
+    @Override
+    public Date getNotBefore() {
+        return unwrap().getNotBefore();
+    }
+
+    @Override
+    public Date getNotAfter() {
+        return unwrap().getNotAfter();
+    }
+
+    @Override
+    public byte[] getTBSCertificate() throws CertificateEncodingException {
+        return unwrap().getTBSCertificate();
+    }
+
+    @Override
+    public byte[] getSignature() {
+        return unwrap().getSignature();
+    }
+
+    @Override
+    public String getSigAlgName() {
+        return unwrap().getSigAlgName();
+    }
+
+    @Override
+    public String getSigAlgOID() {
+        return unwrap().getSigAlgOID();
+    }
+
+    @Override
+    public byte[] getSigAlgParams() {
+        return unwrap().getSigAlgParams();
+    }
+
+    @Override
+    public boolean[] getIssuerUniqueID() {
+        return unwrap().getIssuerUniqueID();
+    }
+
+    @Override
+    public boolean[] getSubjectUniqueID() {
+        return unwrap().getSubjectUniqueID();
+    }
+
+    @Override
+    public boolean[] getKeyUsage() {
+        return unwrap().getKeyUsage();
+    }
+
+    @Override
+    public int getBasicConstraints() {
+        return unwrap().getBasicConstraints();
+    }
+
+    @Override
+    public byte[] getEncoded() {
+        return bytes.clone();
+    }
+
+    @Override
+    public void verify(PublicKey key)
+            throws CertificateException, NoSuchAlgorithmException,
+            InvalidKeyException, NoSuchProviderException, SignatureException {
+        unwrap().verify(key);
+    }
+
+    @Override
+    public void verify(PublicKey key, String sigProvider)
+            throws CertificateException, NoSuchAlgorithmException, InvalidKeyException,
+            NoSuchProviderException, SignatureException {
+        unwrap().verify(key, sigProvider);
+    }
+
+    @Override
+    public String toString() {
+        return unwrap().toString();
+    }
+
+    @Override
+    public PublicKey getPublicKey() {
+        return unwrap().getPublicKey();
+    }
+
+    @Override
+    public boolean hasUnsupportedCriticalExtension() {
+        return unwrap().hasUnsupportedCriticalExtension();
+    }
+
+    @Override
+    public Set<String> getCriticalExtensionOIDs() {
+        return unwrap().getCriticalExtensionOIDs();
+    }
+
+    @Override
+    public Set<String> getNonCriticalExtensionOIDs() {
+        return unwrap().getNonCriticalExtensionOIDs();
+    }
+
+    @Override
+    public byte[] getExtensionValue(String oid) {
+        return unwrap().getExtensionValue(oid);
+    }
+
+    private X509Certificate unwrap() {
+        X509Certificate wrapped = this.wrapped;
+        if (wrapped == null) {
+            try {
+                wrapped = this.wrapped = (X509Certificate) OpenSSLContext.X509_CERT_FACTORY.generateCertificate(
+                        new ByteArrayInputStream(bytes));
+            } catch (CertificateException e) {
+                throw new IllegalStateException(e);
+            }
+        }
+        return wrapped;
+    }
+}

==================================================
constants$0.java
new file mode 100644
index 0000000000..74e85d1820
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/RuntimeHelper.java
@@ -0,0 +1,248 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.util.openssl;
+// Generated by jextract
+
+import java.lang.foreign.Addressable;
+import java.lang.foreign.FunctionDescriptor;
+import java.lang.foreign.GroupLayout;
+import java.lang.foreign.Linker;
+import java.lang.foreign.MemoryAddress;
+import java.lang.foreign.MemoryLayout;
+import java.lang.foreign.MemorySegment;
+import java.lang.foreign.MemorySession;
+import java.lang.foreign.SegmentAllocator;
+import java.lang.foreign.SymbolLookup;
+import java.lang.foreign.ValueLayout;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+import java.io.File;
+import java.nio.file.Path;
+import java.nio.charset.StandardCharsets;
+import java.util.Arrays;
+import java.util.Optional;
+import java.util.stream.Stream;
+
+import static java.lang.foreign.Linker.*;
+import static java.lang.foreign.ValueLayout.*;
+
+final class RuntimeHelper {
+
+    private RuntimeHelper() {}
+    private final static Linker LINKER = Linker.nativeLinker();
+    private final static ClassLoader LOADER = RuntimeHelper.class.getClassLoader();
+    private final static MethodHandles.Lookup MH_LOOKUP = MethodHandles.lookup();
+
+    final static SegmentAllocator CONSTANT_ALLOCATOR =
+            (size, align) -> MemorySegment.allocateNative(size, align, MemorySession.openImplicit());
+
+    static {
+        System.loadLibrary("ssl");
+    }
+
+    static <T> T requireNonNull(T obj, String symbolName) {
+        if (obj == null) {
+            throw new UnsatisfiedLinkError("unresolved symbol: " + symbolName);
+        }
+        return obj;
+    }
+
+    private final static SegmentAllocator THROWING_ALLOCATOR = (x, y) -> { throw new AssertionError("should not reach here"); };
+
+    static final MemorySegment lookupGlobalVariable(String name, MemoryLayout layout) {
+        return SymbolLookup.loaderLookup().lookup(name).map(symbol -> MemorySegment.ofAddress(symbol.address(), layout.byteSize(), MemorySession.openShared())).orElse(null);
+    }
+
+    static final MethodHandle downcallHandle(String name, FunctionDescriptor fdesc, boolean variadic) {
+        return SymbolLookup.loaderLookup().lookup(name).map(
+                addr -> {
+                    return variadic ?
+                        VarargsInvoker.make(addr, fdesc) :
+                        LINKER.downcallHandle(addr, fdesc);
+                }).orElse(null);
+    }
+
+    static final MethodHandle downcallHandle(FunctionDescriptor fdesc, boolean variadic) {
+        if (variadic) {
+            throw new AssertionError("Cannot get here!");
+        }
+        return LINKER.downcallHandle(fdesc);
+    }
+
+    static final <Z> MemorySegment upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, String mtypeDesc, MemorySession scope) {
+        try {
+            MethodHandle handle = MH_LOOKUP.findVirtual(fi, "apply",
+                    MethodType.fromMethodDescriptorString(mtypeDesc, LOADER));
+            handle = handle.bindTo(z);
+            return LINKER.upcallStub(handle, fdesc, scope);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+
+    static MemorySegment asArray(MemoryAddress addr, MemoryLayout layout, int numElements, MemorySession scope) {
+         return MemorySegment.ofAddress(addr, numElements * layout.byteSize(), scope);
+    }
+
+    // Internals only below this point
+
+    private static class VarargsInvoker {
+        private static final MethodHandle INVOKE_MH;
+        private final MemorySegment symbol;
+        private final FunctionDescriptor function;
+
+        private VarargsInvoker(MemorySegment symbol, FunctionDescriptor function) {
+            this.symbol = symbol;
+            this.function = function;
+        }
+
+        static {
+            try {
+                INVOKE_MH = MethodHandles.lookup().findVirtual(VarargsInvoker.class, "invoke", MethodType.methodType(Object.class, SegmentAllocator.class, Object[].class));
+            } catch (ReflectiveOperationException e) {
+                throw new RuntimeException(e);
+            }
+        }
+
+        static MethodHandle make(MemorySegment symbol, FunctionDescriptor function) {
+            VarargsInvoker invoker = new VarargsInvoker(symbol, function);
+            MethodHandle handle = INVOKE_MH.bindTo(invoker).asCollector(Object[].class, function.argumentLayouts().size() + 1);
+            MethodType mtype = MethodType.methodType(function.returnLayout().isPresent() ? carrier(function.returnLayout().get(), true) : void.class);
+            for (MemoryLayout layout : function.argumentLayouts()) {
+                mtype = mtype.appendParameterTypes(carrier(layout, false));
+            }
+            mtype = mtype.appendParameterTypes(Object[].class);
+            if (mtype.returnType().equals(MemorySegment.class)) {
+                mtype = mtype.insertParameterTypes(0, SegmentAllocator.class);
+            } else {
+                handle = MethodHandles.insertArguments(handle, 0, THROWING_ALLOCATOR);
+            }
+            return handle.asType(mtype);
+        }
+
+        static Class<?> carrier(MemoryLayout layout, boolean ret) {
+            if (layout instanceof ValueLayout valueLayout) {
+                return (ret || valueLayout.carrier() != MemoryAddress.class) ?
+                        valueLayout.carrier() : Addressable.class;
+            } else if (layout instanceof GroupLayout) {
+                return MemorySegment.class;
+            } else {
+                throw new AssertionError("Cannot get here!");
+            }
+        }
+
+        private Object invoke(SegmentAllocator allocator, Object[] args) throws Throwable {
+            // one trailing Object[]
+            int nNamedArgs = function.argumentLayouts().size();
+            assert(args.length == nNamedArgs + 1);
+            // The last argument is the array of vararg collector
+            Object[] unnamedArgs = (Object[]) args[args.length - 1];
+
+            int argsCount = nNamedArgs + unnamedArgs.length;
+            Class<?>[] argTypes = new Class<?>[argsCount];
+            MemoryLayout[] argLayouts = new MemoryLayout[nNamedArgs + unnamedArgs.length];
+
+            int pos = 0;
+            for (pos = 0; pos < nNamedArgs; pos++) {
+                argLayouts[pos] = function.argumentLayouts().get(pos);
+            }
+
+            assert pos == nNamedArgs;
+            for (Object o: unnamedArgs) {
+                argLayouts[pos] = variadicLayout(normalize(o.getClass()));
+                pos++;
+            }
+            assert pos == argsCount;
+
+            FunctionDescriptor f = (function.returnLayout().isEmpty()) ?
+                    FunctionDescriptor.ofVoid(argLayouts) :
+                    FunctionDescriptor.of(function.returnLayout().get(), argLayouts);
+            MethodHandle mh = LINKER.downcallHandle(symbol, f);
+            if (mh.type().returnType() == MemorySegment.class) {
+                mh = mh.bindTo(allocator);
+            }
+            // flatten argument list so that it can be passed to an asSpreader MH
+            Object[] allArgs = new Object[nNamedArgs + unnamedArgs.length];
+            System.arraycopy(args, 0, allArgs, 0, nNamedArgs);
+            System.arraycopy(unnamedArgs, 0, allArgs, nNamedArgs, unnamedArgs.length);
+
+            return mh.asSpreader(Object[].class, argsCount).invoke(allArgs);
+        }
+
+        private static Class<?> unboxIfNeeded(Class<?> clazz) {
+            if (clazz == Boolean.class) {
+                return boolean.class;
+            } else if (clazz == Void.class) {
+                return void.class;
+            } else if (clazz == Byte.class) {
+                return byte.class;
+            } else if (clazz == Character.class) {
+                return char.class;
+            } else if (clazz == Short.class) {
+                return short.class;
+            } else if (clazz == Integer.class) {
+                return int.class;
+            } else if (clazz == Long.class) {
+                return long.class;
+            } else if (clazz == Float.class) {
+                return float.class;
+            } else if (clazz == Double.class) {
+                return double.class;
+            } else {
+                return clazz;
+            }
+        }
+
+        private Class<?> promote(Class<?> c) {
+            if (c == byte.class || c == char.class || c == short.class || c == int.class) {
+                return long.class;
+            } else if (c == float.class) {
+                return double.class;
+            } else {
+                return c;
+            }
+        }
+
+        private Class<?> normalize(Class<?> c) {
+            c = unboxIfNeeded(c);
+            if (c.isPrimitive()) {
+                return promote(c);
+            }
+            if (MemoryAddress.class.isAssignableFrom(c)) {
+                return MemoryAddress.class;
+            }
+            if (MemorySegment.class.isAssignableFrom(c)) {
+                return MemorySegment.class;
+            }
+            throw new IllegalArgumentException("Invalid type for ABI: " + c.getTypeName());
+        }
+
+        private MemoryLayout variadicLayout(Class<?> c) {
+            if (c == long.class) {
+                return JAVA_LONG;
+            } else if (c == double.class) {
+                return JAVA_DOUBLE;
+            } else if (MemoryAddress.class.isAssignableFrom(c)) {
+                return ADDRESS;
+            } else {
+                throw new IllegalArgumentException("Unhandled variadic argument class: " + c);
+            }
+        }
+    }
+}

==================================================
constants$1.java
new file mode 100644
index 0000000000..264553e0be
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$0.java
@@ -0,0 +1,66 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Generated by jextract
+
+package org.apache.tomcat.util.openssl;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
+import java.lang.foreign.*;
+import static java.lang.foreign.ValueLayout.*;
+class constants$0 {
+
+    static final FunctionDescriptor OPENSSL_sk_num$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS
+    );
+    static final MethodHandle OPENSSL_sk_num$MH = RuntimeHelper.downcallHandle(
+        "OPENSSL_sk_num",
+        constants$0.OPENSSL_sk_num$FUNC, false
+    );
+    static final FunctionDescriptor OPENSSL_sk_value$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS,
+        JAVA_INT
+    );
+    static final MethodHandle OPENSSL_sk_value$MH = RuntimeHelper.downcallHandle(
+        "OPENSSL_sk_value",
+        constants$0.OPENSSL_sk_value$FUNC, false
+    );
+    static final FunctionDescriptor OpenSSL_version_num$FUNC = FunctionDescriptor.of(JAVA_LONG);
+    static final MethodHandle OpenSSL_version_num$MH = RuntimeHelper.downcallHandle(
+        "OpenSSL_version_num",
+        constants$0.OpenSSL_version_num$FUNC, false
+    );
+    static final FunctionDescriptor OpenSSL_version$FUNC = FunctionDescriptor.of(ADDRESS,
+        JAVA_INT
+    );
+    static final MethodHandle OpenSSL_version$MH = RuntimeHelper.downcallHandle(
+        "OpenSSL_version",
+        constants$0.OpenSSL_version$FUNC, false
+    );
+    static final FunctionDescriptor CRYPTO_set_mem_functions$m$FUNC = FunctionDescriptor.of(ADDRESS,
+        JAVA_LONG,
+        ADDRESS,
+        JAVA_INT
+    );
+    static final MethodHandle CRYPTO_set_mem_functions$m$MH = RuntimeHelper.downcallHandle(
+        constants$0.CRYPTO_set_mem_functions$m$FUNC, false
+    );
+}
+
+

==================================================
constants$10.java
new file mode 100644
index 0000000000..986b10a55f
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$1.java
@@ -0,0 +1,66 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Generated by jextract
+
+package org.apache.tomcat.util.openssl;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
+import java.lang.foreign.*;
+import static java.lang.foreign.ValueLayout.*;
+class constants$1 {
+
+    static final FunctionDescriptor CRYPTO_set_mem_functions$r$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS,
+        JAVA_LONG,
+        ADDRESS,
+        JAVA_INT
+    );
+    static final MethodHandle CRYPTO_set_mem_functions$r$MH = RuntimeHelper.downcallHandle(
+        constants$1.CRYPTO_set_mem_functions$r$FUNC, false
+    );
+    static final FunctionDescriptor CRYPTO_set_mem_functions$f$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS,
+        ADDRESS,
+        JAVA_INT
+    );
+    static final MethodHandle CRYPTO_set_mem_functions$f$MH = RuntimeHelper.downcallHandle(
+        constants$1.CRYPTO_set_mem_functions$f$FUNC, false
+    );
+    static final FunctionDescriptor CRYPTO_set_mem_functions$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle CRYPTO_set_mem_functions$MH = RuntimeHelper.downcallHandle(
+        "CRYPTO_set_mem_functions",
+        constants$1.CRYPTO_set_mem_functions$FUNC, false
+    );
+    static final FunctionDescriptor CRYPTO_free$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS,
+        ADDRESS,
+        JAVA_INT
+    );
+    static final MethodHandle CRYPTO_free$MH = RuntimeHelper.downcallHandle(
+        "CRYPTO_free",
+        constants$1.CRYPTO_free$FUNC, false
+    );
+}
+
+

==================================================
constants$11.java
new file mode 100644
index 0000000000..dc282042f7
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$10.java
@@ -0,0 +1,82 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Generated by jextract
+
+package org.apache.tomcat.util.openssl;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
+import java.lang.foreign.*;
+import static java.lang.foreign.ValueLayout.*;
+class constants$10 {
+
+    static final FunctionDescriptor d2i_X509$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS,
+        ADDRESS,
+        JAVA_LONG
+    );
+    static final MethodHandle d2i_X509$MH = RuntimeHelper.downcallHandle(
+        "d2i_X509",
+        constants$10.d2i_X509$FUNC, false
+    );
+    static final FunctionDescriptor i2d_X509$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle i2d_X509$MH = RuntimeHelper.downcallHandle(
+        "i2d_X509",
+        constants$10.i2d_X509$FUNC, false
+    );
+    static final FunctionDescriptor X509_get_ext_by_NID$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        JAVA_INT,
+        JAVA_INT
+    );
+    static final MethodHandle X509_get_ext_by_NID$MH = RuntimeHelper.downcallHandle(
+        "X509_get_ext_by_NID",
+        constants$10.X509_get_ext_by_NID$FUNC, false
+    );
+    static final FunctionDescriptor X509_get_ext$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS,
+        JAVA_INT
+    );
+    static final MethodHandle X509_get_ext$MH = RuntimeHelper.downcallHandle(
+        "X509_get_ext",
+        constants$10.X509_get_ext$FUNC, false
+    );
+    static final FunctionDescriptor X509_EXTENSION_get_data$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle X509_EXTENSION_get_data$MH = RuntimeHelper.downcallHandle(
+        "X509_EXTENSION_get_data",
+        constants$10.X509_EXTENSION_get_data$FUNC, false
+    );
+    static final FunctionDescriptor PEM_read_bio_X509_AUX$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS,
+        ADDRESS,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle PEM_read_bio_X509_AUX$MH = RuntimeHelper.downcallHandle(
+        "PEM_read_bio_X509_AUX",
+        constants$10.PEM_read_bio_X509_AUX$FUNC, false
+    );
+}
+
+

==================================================
constants$12.java
new file mode 100644
index 0000000000..981de46964
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$11.java
@@ -0,0 +1,83 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Generated by jextract
+
+package org.apache.tomcat.util.openssl;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
+import java.lang.foreign.*;
+import static java.lang.foreign.ValueLayout.*;
+class constants$11 {
+
+    static final FunctionDescriptor PEM_read_bio_ECPKParameters$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS,
+        ADDRESS,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle PEM_read_bio_ECPKParameters$MH = RuntimeHelper.downcallHandle(
+        "PEM_read_bio_ECPKParameters",
+        constants$11.PEM_read_bio_ECPKParameters$FUNC, false
+    );
+    static final FunctionDescriptor PEM_read_bio_DHparams$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS,
+        ADDRESS,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle PEM_read_bio_DHparams$MH = RuntimeHelper.downcallHandle(
+        "PEM_read_bio_DHparams",
+        constants$11.PEM_read_bio_DHparams$FUNC, false
+    );
+    static final FunctionDescriptor PEM_read_bio_PrivateKey$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS,
+        ADDRESS,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle PEM_read_bio_PrivateKey$MH = RuntimeHelper.downcallHandle(
+        "PEM_read_bio_PrivateKey",
+        constants$11.PEM_read_bio_PrivateKey$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CTX_get_options$FUNC = FunctionDescriptor.of(JAVA_LONG,
+        ADDRESS
+    );
+    static final MethodHandle SSL_CTX_get_options$MH = RuntimeHelper.downcallHandle(
+        "SSL_CTX_get_options",
+        constants$11.SSL_CTX_get_options$FUNC, false
+    );
+    static final FunctionDescriptor SSL_get_options$FUNC = FunctionDescriptor.of(JAVA_LONG,
+        ADDRESS
+    );
+    static final MethodHandle SSL_get_options$MH = RuntimeHelper.downcallHandle(
+        "SSL_get_options",
+        constants$11.SSL_get_options$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CTX_clear_options$FUNC = FunctionDescriptor.of(JAVA_LONG,
+        ADDRESS,
+        JAVA_LONG
+    );
+    static final MethodHandle SSL_CTX_clear_options$MH = RuntimeHelper.downcallHandle(
+        "SSL_CTX_clear_options",
+        constants$11.SSL_CTX_clear_options$FUNC, false
+    );
+}
+
+

==================================================
constants$13.java
new file mode 100644
index 0000000000..685268aab8
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$12.java
@@ -0,0 +1,81 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Generated by jextract
+
+package org.apache.tomcat.util.openssl;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
+import java.lang.foreign.*;
+import static java.lang.foreign.ValueLayout.*;
+class constants$12 {
+
+    static final FunctionDescriptor SSL_CTX_set_options$FUNC = FunctionDescriptor.of(JAVA_LONG,
+        ADDRESS,
+        JAVA_LONG
+    );
+    static final MethodHandle SSL_CTX_set_options$MH = RuntimeHelper.downcallHandle(
+        "SSL_CTX_set_options",
+        constants$12.SSL_CTX_set_options$FUNC, false
+    );
+    static final FunctionDescriptor SSL_set_options$FUNC = FunctionDescriptor.of(JAVA_LONG,
+        ADDRESS,
+        JAVA_LONG
+    );
+    static final MethodHandle SSL_set_options$MH = RuntimeHelper.downcallHandle(
+        "SSL_set_options",
+        constants$12.SSL_set_options$FUNC, false
+    );
+    static final FunctionDescriptor SSL_get0_next_proto_negotiated$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_get0_next_proto_negotiated$MH = RuntimeHelper.downcallHandle(
+        "SSL_get0_next_proto_negotiated",
+        constants$12.SSL_get0_next_proto_negotiated$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CTX_set_alpn_select_cb$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_CTX_set_alpn_select_cb$MH = RuntimeHelper.downcallHandle(
+        "SSL_CTX_set_alpn_select_cb",
+        constants$12.SSL_CTX_set_alpn_select_cb$FUNC, false
+    );
+    static final FunctionDescriptor SSL_get0_alpn_selected$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_get0_alpn_selected$MH = RuntimeHelper.downcallHandle(
+        "SSL_get0_alpn_selected",
+        constants$12.SSL_get0_alpn_selected$FUNC, false
+    );
+    static final FunctionDescriptor SSL_in_init$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS
+    );
+    static final MethodHandle SSL_in_init$MH = RuntimeHelper.downcallHandle(
+        "SSL_in_init",
+        constants$12.SSL_in_init$FUNC, false
+    );
+}
+
+

==================================================
constants$14.java
new file mode 100644
index 0000000000..2c35a0861f
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$13.java
@@ -0,0 +1,83 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Generated by jextract
+
+package org.apache.tomcat.util.openssl;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
+import java.lang.foreign.*;
+import static java.lang.foreign.ValueLayout.*;
+class constants$13 {
+
+    static final FunctionDescriptor SSL_CTX_set_cipher_list$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_CTX_set_cipher_list$MH = RuntimeHelper.downcallHandle(
+        "SSL_CTX_set_cipher_list",
+        constants$13.SSL_CTX_set_cipher_list$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CTX_set_ciphersuites$FUNC = FunctionDescriptor.of(JAVA_INT,
+            ADDRESS,
+            ADDRESS
+        );
+    static final MethodHandle SSL_CTX_set_ciphersuites$MH = RuntimeHelper.downcallHandle(
+            "SSL_CTX_set_ciphersuites",
+            constants$13.SSL_CTX_set_ciphersuites$FUNC, false
+        );
+    static final FunctionDescriptor SSL_CTX_new$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_CTX_new$MH = RuntimeHelper.downcallHandle(
+        "SSL_CTX_new",
+        constants$13.SSL_CTX_new$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CTX_free$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS
+    );
+    static final MethodHandle SSL_CTX_free$MH = RuntimeHelper.downcallHandle(
+        "SSL_CTX_free",
+        constants$13.SSL_CTX_free$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CTX_set_timeout$FUNC = FunctionDescriptor.of(JAVA_LONG,
+        ADDRESS,
+        JAVA_LONG
+    );
+    static final MethodHandle SSL_CTX_set_timeout$MH = RuntimeHelper.downcallHandle(
+        "SSL_CTX_set_timeout",
+        constants$13.SSL_CTX_set_timeout$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CTX_get_timeout$FUNC = FunctionDescriptor.of(JAVA_LONG,
+        ADDRESS
+    );
+    static final MethodHandle SSL_CTX_get_timeout$MH = RuntimeHelper.downcallHandle(
+        "SSL_CTX_get_timeout",
+        constants$13.SSL_CTX_get_timeout$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CTX_get_cert_store$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_CTX_get_cert_store$MH = RuntimeHelper.downcallHandle(
+        "SSL_CTX_get_cert_store",
+        constants$13.SSL_CTX_get_cert_store$FUNC, false
+    );
+}
+
+

==================================================
constants$15.java
new file mode 100644
index 0000000000..698c479087
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$14.java
@@ -0,0 +1,75 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Generated by jextract
+
+package org.apache.tomcat.util.openssl;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
+import java.lang.foreign.*;
+import static java.lang.foreign.ValueLayout.*;
+class constants$14 {
+
+    static final FunctionDescriptor SSL_get_current_cipher$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_get_current_cipher$MH = RuntimeHelper.downcallHandle(
+        "SSL_get_current_cipher",
+        constants$14.SSL_get_current_cipher$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CIPHER_get_name$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_CIPHER_get_name$MH = RuntimeHelper.downcallHandle(
+        "SSL_CIPHER_get_name",
+        constants$14.SSL_CIPHER_get_name$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CIPHER_get_kx_nid$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS
+    );
+    static final MethodHandle SSL_CIPHER_get_kx_nid$MH = RuntimeHelper.downcallHandle(
+        "SSL_CIPHER_get_kx_nid",
+        constants$14.SSL_CIPHER_get_kx_nid$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CIPHER_get_auth_nid$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS
+    );
+    static final MethodHandle SSL_CIPHER_get_auth_nid$MH = RuntimeHelper.downcallHandle(
+        "SSL_CIPHER_get_auth_nid",
+        constants$14.SSL_CIPHER_get_auth_nid$FUNC, false
+    );
+    static final FunctionDescriptor SSL_pending$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS
+    );
+    static final MethodHandle SSL_pending$MH = RuntimeHelper.downcallHandle(
+        "SSL_pending",
+        constants$14.SSL_pending$FUNC, false
+    );
+    static final FunctionDescriptor SSL_set_bio$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_set_bio$MH = RuntimeHelper.downcallHandle(
+        "SSL_set_bio",
+        constants$14.SSL_set_bio$FUNC, false
+    );
+}
+
+

==================================================
constants$16.java
new file mode 100644
index 0000000000..31aa20f732
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$15.java
@@ -0,0 +1,78 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Generated by jextract
+
+package org.apache.tomcat.util.openssl;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
+import java.lang.foreign.*;
+import static java.lang.foreign.ValueLayout.*;
+class constants$15 {
+
+    static final FunctionDescriptor SSL_set_cipher_list$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_set_cipher_list$MH = RuntimeHelper.downcallHandle(
+        "SSL_set_cipher_list",
+        constants$15.SSL_set_cipher_list$FUNC, false
+    );
+    static final FunctionDescriptor SSL_set_verify$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS,
+        JAVA_INT,
+        ADDRESS
+    );
+    static final MethodHandle SSL_set_verify$MH = RuntimeHelper.downcallHandle(
+        "SSL_set_verify",
+        constants$15.SSL_set_verify$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CTX_use_certificate_chain_file$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_CTX_use_certificate_chain_file$MH = RuntimeHelper.downcallHandle(
+        "SSL_CTX_use_certificate_chain_file",
+        constants$15.SSL_CTX_use_certificate_chain_file$FUNC, false
+    );
+    static final FunctionDescriptor SSL_load_client_CA_file$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_load_client_CA_file$MH = RuntimeHelper.downcallHandle(
+        "SSL_load_client_CA_file",
+        constants$15.SSL_load_client_CA_file$FUNC, false
+    );
+    static final FunctionDescriptor SSL_add_file_cert_subjects_to_stack$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_add_file_cert_subjects_to_stack$MH = RuntimeHelper.downcallHandle(
+        "SSL_add_file_cert_subjects_to_stack",
+        constants$15.SSL_add_file_cert_subjects_to_stack$FUNC, false
+    );
+    static final FunctionDescriptor SSL_SESSION_get_time$FUNC = FunctionDescriptor.of(JAVA_LONG,
+        ADDRESS
+    );
+    static final MethodHandle SSL_SESSION_get_time$MH = RuntimeHelper.downcallHandle(
+        "SSL_SESSION_get_time",
+        constants$15.SSL_SESSION_get_time$FUNC, false
+    );
+}
+
+

==================================================
constants$17.java
new file mode 100644
index 0000000000..c4529d5247
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$16.java
@@ -0,0 +1,69 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Generated by jextract
+
+package org.apache.tomcat.util.openssl;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
+import java.lang.foreign.*;
+import static java.lang.foreign.ValueLayout.*;
+class constants$16 {
+
+    static final FunctionDescriptor SSL_SESSION_get_id$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_SESSION_get_id$MH = RuntimeHelper.downcallHandle(
+        "SSL_SESSION_get_id",
+        constants$16.SSL_SESSION_get_id$FUNC, false
+    );
+    static final FunctionDescriptor SSL_get_peer_certificate$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_get_peer_certificate$MH = RuntimeHelper.downcallHandle(
+        "SSL_get_peer_certificate",
+        constants$16.SSL_get_peer_certificate$FUNC, false
+    );
+    static final FunctionDescriptor SSL_get_peer_cert_chain$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_get_peer_cert_chain$MH = RuntimeHelper.downcallHandle(
+        "SSL_get_peer_cert_chain",
+        constants$16.SSL_get_peer_cert_chain$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CTX_set_verify$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS,
+        JAVA_INT,
+        ADDRESS
+    );
+    static final MethodHandle SSL_CTX_set_verify$MH = RuntimeHelper.downcallHandle(
+        "SSL_CTX_set_verify",
+        constants$16.SSL_CTX_set_verify$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CTX_set_cert_verify_callback$cb$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_CTX_set_cert_verify_callback$cb$MH = RuntimeHelper.downcallHandle(
+        constants$16.SSL_CTX_set_cert_verify_callback$cb$FUNC, false
+    );
+}
+
+

==================================================
constants$18.java
new file mode 100644
index 0000000000..81d397403a
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$17.java
@@ -0,0 +1,80 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Generated by jextract
+
+package org.apache.tomcat.util.openssl;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
+import java.lang.foreign.*;
+import static java.lang.foreign.ValueLayout.*;
+class constants$17 {
+
+    static final FunctionDescriptor SSL_CTX_set_cert_verify_callback$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_CTX_set_cert_verify_callback$MH = RuntimeHelper.downcallHandle(
+        "SSL_CTX_set_cert_verify_callback",
+        constants$17.SSL_CTX_set_cert_verify_callback$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CTX_use_PrivateKey$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_CTX_use_PrivateKey$MH = RuntimeHelper.downcallHandle(
+        "SSL_CTX_use_PrivateKey",
+        constants$17.SSL_CTX_use_PrivateKey$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CTX_use_certificate$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_CTX_use_certificate$MH = RuntimeHelper.downcallHandle(
+        "SSL_CTX_use_certificate",
+        constants$17.SSL_CTX_use_certificate$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CTX_set_default_passwd_cb$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_CTX_set_default_passwd_cb$MH = RuntimeHelper.downcallHandle(
+        "SSL_CTX_set_default_passwd_cb",
+        constants$17.SSL_CTX_set_default_passwd_cb$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CTX_check_private_key$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS
+    );
+    static final MethodHandle SSL_CTX_check_private_key$MH = RuntimeHelper.downcallHandle(
+        "SSL_CTX_check_private_key",
+        constants$17.SSL_CTX_check_private_key$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CTX_set_session_id_context$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        ADDRESS,
+        JAVA_INT
+    );
+    static final MethodHandle SSL_CTX_set_session_id_context$MH = RuntimeHelper.downcallHandle(
+        "SSL_CTX_set_session_id_context",
+        constants$17.SSL_CTX_set_session_id_context$FUNC, false
+    );
+}
+
+

==================================================
constants$19.java
new file mode 100644
index 0000000000..8c060c0718
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$18.java
@@ -0,0 +1,80 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Generated by jextract
+
+package org.apache.tomcat.util.openssl;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
+import java.lang.foreign.*;
+import static java.lang.foreign.ValueLayout.*;
+class constants$18 {
+
+    static final FunctionDescriptor SSL_new$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_new$MH = RuntimeHelper.downcallHandle(
+        "SSL_new",
+        constants$18.SSL_new$FUNC, false
+    );
+    static final FunctionDescriptor SSL_free$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS
+    );
+    static final MethodHandle SSL_free$MH = RuntimeHelper.downcallHandle(
+        "SSL_free",
+        constants$18.SSL_free$FUNC, false
+    );
+    static final FunctionDescriptor SSL_read$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        ADDRESS,
+        JAVA_INT
+    );
+    static final MethodHandle SSL_read$MH = RuntimeHelper.downcallHandle(
+        "SSL_read",
+        constants$18.SSL_read$FUNC, false
+    );
+    static final FunctionDescriptor SSL_write$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        ADDRESS,
+        JAVA_INT
+    );
+    static final MethodHandle SSL_write$MH = RuntimeHelper.downcallHandle(
+        "SSL_write",
+        constants$18.SSL_write$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CTX_ctrl$FUNC = FunctionDescriptor.of(JAVA_LONG,
+        ADDRESS,
+        JAVA_INT,
+        JAVA_LONG,
+        ADDRESS
+    );
+    static final MethodHandle SSL_CTX_ctrl$MH = RuntimeHelper.downcallHandle(
+        "SSL_CTX_ctrl",
+        constants$18.SSL_CTX_ctrl$FUNC, false
+    );
+    static final FunctionDescriptor SSL_get_version$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_get_version$MH = RuntimeHelper.downcallHandle(
+        "SSL_get_version",
+        constants$18.SSL_get_version$FUNC, false
+    );
+}
+
+

==================================================
constants$2.java
new file mode 100644
index 0000000000..0b4a602bd7
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$19.java
@@ -0,0 +1,71 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Generated by jextract
+
+package org.apache.tomcat.util.openssl;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
+import java.lang.foreign.*;
+import static java.lang.foreign.ValueLayout.*;
+class constants$19 {
+
+    static final FunctionDescriptor TLS_server_method$FUNC = FunctionDescriptor.of(ADDRESS);
+    static final MethodHandle TLS_server_method$MH = RuntimeHelper.downcallHandle(
+        "TLS_server_method",
+        constants$19.TLS_server_method$FUNC, false
+    );
+    static final FunctionDescriptor SSL_get_ciphers$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_get_ciphers$MH = RuntimeHelper.downcallHandle(
+        "SSL_get_ciphers",
+        constants$19.SSL_get_ciphers$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CTX_get_ciphers$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_CTX_get_ciphers$MH = RuntimeHelper.downcallHandle(
+        "SSL_CTX_get_ciphers",
+        constants$19.SSL_CTX_get_ciphers$FUNC, false
+    );
+    static final FunctionDescriptor SSL_do_handshake$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS
+    );
+    static final MethodHandle SSL_do_handshake$MH = RuntimeHelper.downcallHandle(
+        "SSL_do_handshake",
+        constants$19.SSL_do_handshake$FUNC, false
+    );
+    static final FunctionDescriptor SSL_renegotiate$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS
+    );
+    static final MethodHandle SSL_renegotiate$MH = RuntimeHelper.downcallHandle(
+        "SSL_renegotiate",
+        constants$19.SSL_renegotiate$FUNC, false
+    );
+    static final FunctionDescriptor SSL_renegotiate_pending$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS
+    );
+    static final MethodHandle SSL_renegotiate_pending$MH = RuntimeHelper.downcallHandle(
+        "SSL_renegotiate_pending",
+        constants$19.SSL_renegotiate_pending$FUNC, false
+    );
+}
+
+

==================================================
constants$20.java
new file mode 100644
index 0000000000..c7532094ef
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$2.java
@@ -0,0 +1,70 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Generated by jextract
+
+package org.apache.tomcat.util.openssl;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
+import java.lang.foreign.*;
+import static java.lang.foreign.ValueLayout.*;
+class constants$2 {
+
+    static final FunctionDescriptor FIPS_mode$FUNC = FunctionDescriptor.of(JAVA_INT);
+    static final MethodHandle FIPS_mode$MH = RuntimeHelper.downcallHandle(
+        "FIPS_mode",
+        constants$2.FIPS_mode$FUNC, false
+    );
+    static final FunctionDescriptor FIPS_mode_set$FUNC = FunctionDescriptor.of(JAVA_INT,
+        JAVA_INT
+    );
+    static final MethodHandle FIPS_mode_set$MH = RuntimeHelper.downcallHandle(
+        "FIPS_mode_set",
+        constants$2.FIPS_mode_set$FUNC, false
+    );
+    static final FunctionDescriptor BIO_ctrl_pending$FUNC = FunctionDescriptor.of(JAVA_LONG,
+        ADDRESS
+    );
+    static final MethodHandle BIO_ctrl_pending$MH = RuntimeHelper.downcallHandle(
+        "BIO_ctrl_pending",
+        constants$2.BIO_ctrl_pending$FUNC, false
+    );
+    static final FunctionDescriptor BIO_s_file$FUNC = FunctionDescriptor.of(ADDRESS);
+    static final MethodHandle BIO_s_file$MH = RuntimeHelper.downcallHandle(
+        "BIO_s_file",
+        constants$2.BIO_s_file$FUNC, false
+    );
+    static final FunctionDescriptor BIO_new_file$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle BIO_new_file$MH = RuntimeHelper.downcallHandle(
+        "BIO_new_file",
+        constants$2.BIO_new_file$FUNC, false
+    );
+    static final FunctionDescriptor BIO_new$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle BIO_new$MH = RuntimeHelper.downcallHandle(
+        "BIO_new",
+        constants$2.BIO_new$FUNC, false
+    );
+}
+
+

==================================================
constants$21.java
new file mode 100644
index 0000000000..016030bbb2
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$20.java
@@ -0,0 +1,75 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Generated by jextract
+
+package org.apache.tomcat.util.openssl;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
+import java.lang.foreign.*;
+import static java.lang.foreign.ValueLayout.*;
+class constants$20 {
+
+    static final FunctionDescriptor SSL_shutdown$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS
+    );
+    static final MethodHandle SSL_shutdown$MH = RuntimeHelper.downcallHandle(
+        "SSL_shutdown",
+        constants$20.SSL_shutdown$FUNC, false
+    );
+    static final FunctionDescriptor SSL_verify_client_post_handshake$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS
+    );
+    static final MethodHandle SSL_verify_client_post_handshake$MH = RuntimeHelper.downcallHandle(
+        "SSL_verify_client_post_handshake",
+        constants$20.SSL_verify_client_post_handshake$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CTX_set_client_CA_list$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_CTX_set_client_CA_list$MH = RuntimeHelper.downcallHandle(
+        "SSL_CTX_set_client_CA_list",
+        constants$20.SSL_CTX_set_client_CA_list$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CTX_get_client_CA_list$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_CTX_get_client_CA_list$MH = RuntimeHelper.downcallHandle(
+        "SSL_CTX_get_client_CA_list",
+        constants$20.SSL_CTX_get_client_CA_list$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CTX_add_client_CA$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_CTX_add_client_CA$MH = RuntimeHelper.downcallHandle(
+        "SSL_CTX_add_client_CA",
+        constants$20.SSL_CTX_add_client_CA$FUNC, false
+    );
+    static final FunctionDescriptor SSL_set_connect_state$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS
+    );
+    static final MethodHandle SSL_set_connect_state$MH = RuntimeHelper.downcallHandle(
+        "SSL_set_connect_state",
+        constants$20.SSL_set_connect_state$FUNC, false
+    );
+}
+
+

==================================================
constants$22.java
new file mode 100644
index 0000000000..702a53949e
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$21.java
@@ -0,0 +1,75 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Generated by jextract
+
+package org.apache.tomcat.util.openssl;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
+import java.lang.foreign.*;
+import static java.lang.foreign.ValueLayout.*;
+class constants$21 {
+
+    static final FunctionDescriptor SSL_set_accept_state$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS
+    );
+    static final MethodHandle SSL_set_accept_state$MH = RuntimeHelper.downcallHandle(
+        "SSL_set_accept_state",
+        constants$21.SSL_set_accept_state$FUNC, false
+    );
+    static final FunctionDescriptor SSL_get_privatekey$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_get_privatekey$MH = RuntimeHelper.downcallHandle(
+        "SSL_get_privatekey",
+        constants$21.SSL_get_privatekey$FUNC, false
+    );
+    static final FunctionDescriptor SSL_get_shutdown$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS
+    );
+    static final MethodHandle SSL_get_shutdown$MH = RuntimeHelper.downcallHandle(
+        "SSL_get_shutdown",
+        constants$21.SSL_get_shutdown$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CTX_set_default_verify_paths$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS
+    );
+    static final MethodHandle SSL_CTX_set_default_verify_paths$MH = RuntimeHelper.downcallHandle(
+        "SSL_CTX_set_default_verify_paths",
+        constants$21.SSL_CTX_set_default_verify_paths$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CTX_load_verify_locations$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_CTX_load_verify_locations$MH = RuntimeHelper.downcallHandle(
+        "SSL_CTX_load_verify_locations",
+        constants$21.SSL_CTX_load_verify_locations$FUNC, false
+    );
+    static final FunctionDescriptor SSL_get_session$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_get_session$MH = RuntimeHelper.downcallHandle(
+        "SSL_get_session",
+        constants$21.SSL_get_session$FUNC, false
+    );
+}
+
+

==================================================
constants$23.java
new file mode 100644
index 0000000000..8336d37b8c
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$22.java
@@ -0,0 +1,65 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Generated by jextract
+
+package org.apache.tomcat.util.openssl;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
+import java.lang.foreign.*;
+import static java.lang.foreign.ValueLayout.*;
+class constants$22 {
+
+    static final FunctionDescriptor SSL_set_info_callback$cb$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS,
+        JAVA_INT,
+        JAVA_INT
+    );
+    static final MethodHandle SSL_set_info_callback$cb$MH = RuntimeHelper.downcallHandle(
+        constants$22.SSL_set_info_callback$cb$FUNC, false
+    );
+    static final FunctionDescriptor SSL_set_info_callback$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_set_info_callback$MH = RuntimeHelper.downcallHandle(
+        "SSL_set_info_callback",
+        constants$22.SSL_set_info_callback$FUNC, false
+    );
+    static final FunctionDescriptor SSL_set_verify_result$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS,
+        JAVA_LONG
+    );
+    static final MethodHandle SSL_set_verify_result$MH = RuntimeHelper.downcallHandle(
+        "SSL_set_verify_result",
+        constants$22.SSL_set_verify_result$FUNC, false
+    );
+    static final FunctionDescriptor SSL_get_ex_data_X509_STORE_CTX_idx$FUNC = FunctionDescriptor.of(JAVA_INT);
+    static final MethodHandle SSL_get_ex_data_X509_STORE_CTX_idx$MH = RuntimeHelper.downcallHandle(
+        "SSL_get_ex_data_X509_STORE_CTX_idx",
+        constants$22.SSL_get_ex_data_X509_STORE_CTX_idx$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CTX_set_tmp_dh_callback$dh$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS,
+        JAVA_INT,
+        JAVA_INT
+    );
+}
+
+

==================================================
constants$24.java
new file mode 100644
index 0000000000..7a2c21a271
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$23.java
@@ -0,0 +1,74 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Generated by jextract
+
+package org.apache.tomcat.util.openssl;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
+import java.lang.foreign.*;
+import static java.lang.foreign.ValueLayout.*;
+class constants$23 {
+
+    static final FunctionDescriptor SSL_CTX_set_tmp_dh_callback$dh$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS,
+        JAVA_INT,
+        JAVA_INT
+    );
+    static final MethodHandle SSL_CTX_set_tmp_dh_callback$dh$MH = RuntimeHelper.downcallHandle(
+        constants$23.SSL_CTX_set_tmp_dh_callback$dh$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CTX_set_tmp_dh_callback$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_CTX_set_tmp_dh_callback$MH = RuntimeHelper.downcallHandle(
+        "SSL_CTX_set_tmp_dh_callback",
+        constants$23.SSL_CTX_set_tmp_dh_callback$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CONF_CTX_new$FUNC = FunctionDescriptor.of(ADDRESS);
+    static final MethodHandle SSL_CONF_CTX_new$MH = RuntimeHelper.downcallHandle(
+        "SSL_CONF_CTX_new",
+        constants$23.SSL_CONF_CTX_new$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CONF_CTX_finish$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS
+    );
+    static final MethodHandle SSL_CONF_CTX_finish$MH = RuntimeHelper.downcallHandle(
+        "SSL_CONF_CTX_finish",
+        constants$23.SSL_CONF_CTX_finish$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CONF_CTX_free$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS
+    );
+    static final MethodHandle SSL_CONF_CTX_free$MH = RuntimeHelper.downcallHandle(
+        "SSL_CONF_CTX_free",
+        constants$23.SSL_CONF_CTX_free$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CONF_CTX_set_flags$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        JAVA_INT
+    );
+    static final MethodHandle SSL_CONF_CTX_set_flags$MH = RuntimeHelper.downcallHandle(
+        "SSL_CONF_CTX_set_flags",
+        constants$23.SSL_CONF_CTX_set_flags$FUNC, false
+    );
+}
+
+

==================================================
constants$25.java
new file mode 100644
index 0000000000..cc22bf1e2f
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$24.java
@@ -0,0 +1,74 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Generated by jextract
+
+package org.apache.tomcat.util.openssl;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
+import java.lang.foreign.*;
+import static java.lang.foreign.ValueLayout.*;
+class constants$24 {
+
+    static final FunctionDescriptor SSL_CONF_CTX_set_ssl_ctx$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_CONF_CTX_set_ssl_ctx$MH = RuntimeHelper.downcallHandle(
+        "SSL_CONF_CTX_set_ssl_ctx",
+        constants$24.SSL_CONF_CTX_set_ssl_ctx$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CONF_cmd$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_CONF_cmd$MH = RuntimeHelper.downcallHandle(
+        "SSL_CONF_cmd",
+        constants$24.SSL_CONF_cmd$FUNC, false
+    );
+    static final FunctionDescriptor SSL_CONF_cmd_value_type$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle SSL_CONF_cmd_value_type$MH = RuntimeHelper.downcallHandle(
+        "SSL_CONF_cmd_value_type",
+        constants$24.SSL_CONF_cmd_value_type$FUNC, false
+    );
+    static final FunctionDescriptor OPENSSL_init_ssl$FUNC = FunctionDescriptor.of(JAVA_INT,
+        JAVA_LONG,
+        ADDRESS
+    );
+    static final MethodHandle OPENSSL_init_ssl$MH = RuntimeHelper.downcallHandle(
+        "OPENSSL_init_ssl",
+        constants$24.OPENSSL_init_ssl$FUNC, false
+    );
+    static final FunctionDescriptor ERR_get_error$FUNC = FunctionDescriptor.of(JAVA_LONG);
+    static final MethodHandle ERR_get_error$MH = RuntimeHelper.downcallHandle(
+        "ERR_get_error",
+        constants$24.ERR_get_error$FUNC, false
+    );
+    static final FunctionDescriptor ERR_peek_last_error$FUNC = FunctionDescriptor.of(JAVA_LONG);
+    static final MethodHandle ERR_peek_last_error$MH = RuntimeHelper.downcallHandle(
+        "ERR_peek_last_error",
+        constants$24.ERR_peek_last_error$FUNC, false
+    );
+}
+
+

==================================================
constants$26.java
new file mode 100644
index 0000000000..22d9b3dd65
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$25.java
@@ -0,0 +1,79 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Generated by jextract
+
+package org.apache.tomcat.util.openssl;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
+import java.lang.foreign.*;
+import static java.lang.foreign.ValueLayout.*;
+class constants$25 {
+
+    static final FunctionDescriptor ERR_clear_error$FUNC = FunctionDescriptor.ofVoid();
+    static final MethodHandle ERR_clear_error$MH = RuntimeHelper.downcallHandle(
+        "ERR_clear_error",
+        constants$25.ERR_clear_error$FUNC, false
+    );
+    static final FunctionDescriptor ERR_error_string$FUNC = FunctionDescriptor.of(ADDRESS,
+        JAVA_LONG,
+        ADDRESS
+    );
+    static final MethodHandle ERR_error_string$MH = RuntimeHelper.downcallHandle(
+        "ERR_error_string",
+        constants$25.ERR_error_string$FUNC, false
+    );
+    static final FunctionDescriptor PKCS12_verify_mac$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        ADDRESS,
+        JAVA_INT
+    );
+    static final MethodHandle PKCS12_verify_mac$MH = RuntimeHelper.downcallHandle(
+        "PKCS12_verify_mac",
+        constants$25.PKCS12_verify_mac$FUNC, false
+    );
+    static final FunctionDescriptor PKCS12_free$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS
+    );
+    static final MethodHandle PKCS12_free$MH = RuntimeHelper.downcallHandle(
+        "PKCS12_free",
+        constants$25.PKCS12_free$FUNC, false
+    );
+    static final FunctionDescriptor PKCS12_parse$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        ADDRESS,
+        ADDRESS,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle PKCS12_parse$MH = RuntimeHelper.downcallHandle(
+        "PKCS12_parse",
+        constants$25.PKCS12_parse$FUNC, false
+    );
+    static final FunctionDescriptor d2i_PKCS12_bio$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle d2i_PKCS12_bio$MH = RuntimeHelper.downcallHandle(
+        "d2i_PKCS12_bio",
+        constants$25.d2i_PKCS12_bio$FUNC, false
+    );
+}
+
+

==================================================
constants$27.java
new file mode 100644
index 0000000000..6ea09de487
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$26.java
@@ -0,0 +1,77 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Generated by jextract
+
+package org.apache.tomcat.util.openssl;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
+import java.lang.foreign.*;
+import static java.lang.foreign.ValueLayout.*;
+class constants$26 {
+
+    static final FunctionDescriptor RAND_seed$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS,
+        JAVA_INT
+    );
+    static final MethodHandle RAND_seed$MH = RuntimeHelper.downcallHandle(
+        "RAND_seed",
+        constants$26.RAND_seed$FUNC, false
+    );
+    static final FunctionDescriptor RAND_load_file$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        JAVA_LONG
+    );
+    static final MethodHandle RAND_load_file$MH = RuntimeHelper.downcallHandle(
+        "RAND_load_file",
+        constants$26.RAND_load_file$FUNC, false
+    );
+    static final FunctionDescriptor X509_check_issued$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle X509_check_issued$MH = RuntimeHelper.downcallHandle(
+        "X509_check_issued",
+        constants$26.X509_check_issued$FUNC, false
+    );
+    static final FunctionDescriptor ENGINE_by_id$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle ENGINE_by_id$MH = RuntimeHelper.downcallHandle(
+        "ENGINE_by_id",
+        constants$26.ENGINE_by_id$FUNC, false
+    );
+    static final FunctionDescriptor ENGINE_register_all_complete$FUNC = FunctionDescriptor.of(JAVA_INT);
+    static final MethodHandle ENGINE_register_all_complete$MH = RuntimeHelper.downcallHandle(
+        "ENGINE_register_all_complete",
+        constants$26.ENGINE_register_all_complete$FUNC, false
+    );
+    static final FunctionDescriptor ENGINE_ctrl_cmd_string$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        ADDRESS,
+        ADDRESS,
+        JAVA_INT
+    );
+    static final MethodHandle ENGINE_ctrl_cmd_string$MH = RuntimeHelper.downcallHandle(
+        "ENGINE_ctrl_cmd_string",
+        constants$26.ENGINE_ctrl_cmd_string$FUNC, false
+    );
+}
+
+

==================================================
constants$28.java
new file mode 100644
index 0000000000..d9236ba3ff
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$27.java
@@ -0,0 +1,80 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Generated by jextract
+
+package org.apache.tomcat.util.openssl;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
+import java.lang.foreign.*;
+import static java.lang.foreign.ValueLayout.*;
+class constants$27 {
+
+    static final FunctionDescriptor ENGINE_free$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS
+    );
+    static final MethodHandle ENGINE_free$MH = RuntimeHelper.downcallHandle(
+        "ENGINE_free",
+        constants$27.ENGINE_free$FUNC, false
+    );
+    static final FunctionDescriptor ENGINE_load_private_key$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS,
+        ADDRESS,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle ENGINE_load_private_key$MH = RuntimeHelper.downcallHandle(
+        "ENGINE_load_private_key",
+        constants$27.ENGINE_load_private_key$FUNC, false
+    );
+    static final FunctionDescriptor ENGINE_set_default$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        JAVA_INT
+    );
+    static final MethodHandle ENGINE_set_default$MH = RuntimeHelper.downcallHandle(
+        "ENGINE_set_default",
+        constants$27.ENGINE_set_default$FUNC, false
+    );
+    static final FunctionDescriptor OCSP_cert_to_id$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle OCSP_cert_to_id$MH = RuntimeHelper.downcallHandle(
+        "OCSP_cert_to_id",
+        constants$27.OCSP_cert_to_id$FUNC, false
+    );
+    static final FunctionDescriptor OCSP_request_add0_id$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle OCSP_request_add0_id$MH = RuntimeHelper.downcallHandle(
+        "OCSP_request_add0_id",
+        constants$27.OCSP_request_add0_id$FUNC, false
+    );
+    static final FunctionDescriptor OCSP_response_status$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS
+    );
+    static final MethodHandle OCSP_response_status$MH = RuntimeHelper.downcallHandle(
+        "OCSP_response_status",
+        constants$27.OCSP_response_status$FUNC, false
+    );
+}
+
+

==================================================
constants$29.java
new file mode 100644
index 0000000000..729a875ca6
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$28.java
@@ -0,0 +1,80 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Generated by jextract
+
+package org.apache.tomcat.util.openssl;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
+import java.lang.foreign.*;
+import static java.lang.foreign.ValueLayout.*;
+class constants$28 {
+
+    static final FunctionDescriptor OCSP_response_get1_basic$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle OCSP_response_get1_basic$MH = RuntimeHelper.downcallHandle(
+        "OCSP_response_get1_basic",
+        constants$28.OCSP_response_get1_basic$FUNC, false
+    );
+    static final FunctionDescriptor OCSP_resp_get0$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS,
+        JAVA_INT
+    );
+    static final MethodHandle OCSP_resp_get0$MH = RuntimeHelper.downcallHandle(
+        "OCSP_resp_get0",
+        constants$28.OCSP_resp_get0$FUNC, false
+    );
+    static final FunctionDescriptor OCSP_resp_find$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        ADDRESS,
+        JAVA_INT
+    );
+    static final MethodHandle OCSP_resp_find$MH = RuntimeHelper.downcallHandle(
+        "OCSP_resp_find",
+        constants$28.OCSP_resp_find$FUNC, false
+    );
+    static final FunctionDescriptor OCSP_single_get0_status$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        ADDRESS,
+        ADDRESS,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle OCSP_single_get0_status$MH = RuntimeHelper.downcallHandle(
+        "OCSP_single_get0_status",
+        constants$28.OCSP_single_get0_status$FUNC, false
+    );
+    static final FunctionDescriptor OCSP_BASICRESP_free$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS
+    );
+    static final MethodHandle OCSP_BASICRESP_free$MH = RuntimeHelper.downcallHandle(
+        "OCSP_BASICRESP_free",
+        constants$28.OCSP_BASICRESP_free$FUNC, false
+    );
+    static final FunctionDescriptor OCSP_RESPONSE_free$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS
+    );
+    static final MethodHandle OCSP_RESPONSE_free$MH = RuntimeHelper.downcallHandle(
+        "OCSP_RESPONSE_free",
+        constants$28.OCSP_RESPONSE_free$FUNC, false
+    );
+}
+
+

==================================================
constants$3.java
new file mode 100644
index 0000000000..ad2c41d86d
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$29.java
@@ -0,0 +1,68 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Generated by jextract
+
+package org.apache.tomcat.util.openssl;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
+import java.lang.foreign.*;
+import static java.lang.foreign.ValueLayout.*;
+class constants$29 {
+
+    static final FunctionDescriptor d2i_OCSP_RESPONSE$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS,
+        ADDRESS,
+        JAVA_LONG
+    );
+    static final MethodHandle d2i_OCSP_RESPONSE$MH = RuntimeHelper.downcallHandle(
+        "d2i_OCSP_RESPONSE",
+        constants$29.d2i_OCSP_RESPONSE$FUNC, false
+    );
+    static final FunctionDescriptor OCSP_CERTID_free$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS
+    );
+    static final MethodHandle OCSP_CERTID_free$MH = RuntimeHelper.downcallHandle(
+        "OCSP_CERTID_free",
+        constants$29.OCSP_CERTID_free$FUNC, false
+    );
+    static final FunctionDescriptor OCSP_REQUEST_new$FUNC = FunctionDescriptor.of(ADDRESS);
+    static final MethodHandle OCSP_REQUEST_new$MH = RuntimeHelper.downcallHandle(
+        "OCSP_REQUEST_new",
+        constants$29.OCSP_REQUEST_new$FUNC, false
+    );
+    static final FunctionDescriptor OCSP_REQUEST_free$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS
+    );
+    static final MethodHandle OCSP_REQUEST_free$MH = RuntimeHelper.downcallHandle(
+        "OCSP_REQUEST_free",
+        constants$29.OCSP_REQUEST_free$FUNC, false
+    );
+    static final FunctionDescriptor i2d_OCSP_REQUEST$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle i2d_OCSP_REQUEST$MH = RuntimeHelper.downcallHandle(
+        "i2d_OCSP_REQUEST",
+        constants$29.i2d_OCSP_REQUEST$FUNC, false
+    );
+    static final MemorySegment OPENSSL_FILE$SEGMENT = RuntimeHelper.CONSTANT_ALLOCATOR.allocateUtf8String("/tmp/jextract$7507082841068085766.h");
+}
+
+

==================================================
constants$4.java
new file mode 100644
index 0000000000..6061e7aa01
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$3.java
@@ -0,0 +1,76 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Generated by jextract
+
+package org.apache.tomcat.util.openssl;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
+import java.lang.foreign.*;
+import static java.lang.foreign.ValueLayout.*;
+class constants$3 {
+
+    static final FunctionDescriptor BIO_free$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS
+    );
+    static final MethodHandle BIO_free$MH = RuntimeHelper.downcallHandle(
+        "BIO_free",
+        constants$3.BIO_free$FUNC, false
+    );
+    static final FunctionDescriptor BIO_read$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        ADDRESS,
+        JAVA_INT
+    );
+    static final MethodHandle BIO_read$MH = RuntimeHelper.downcallHandle(
+        "BIO_read",
+        constants$3.BIO_read$FUNC, false
+    );
+    static final FunctionDescriptor BIO_write$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        ADDRESS,
+        JAVA_INT
+    );
+    static final MethodHandle BIO_write$MH = RuntimeHelper.downcallHandle(
+        "BIO_write",
+        constants$3.BIO_write$FUNC, false
+    );
+    static final FunctionDescriptor BIO_ctrl$FUNC = FunctionDescriptor.of(JAVA_LONG,
+        ADDRESS,
+        JAVA_INT,
+        JAVA_LONG,
+        ADDRESS
+    );
+    static final MethodHandle BIO_ctrl$MH = RuntimeHelper.downcallHandle(
+        "BIO_ctrl",
+        constants$3.BIO_ctrl$FUNC, false
+    );
+    static final FunctionDescriptor BIO_s_mem$FUNC = FunctionDescriptor.of(ADDRESS);
+    static final MethodHandle BIO_s_mem$MH = RuntimeHelper.downcallHandle(
+        "BIO_s_mem",
+        constants$3.BIO_s_mem$FUNC, false
+    );
+    static final FunctionDescriptor BIO_s_bio$FUNC = FunctionDescriptor.of(ADDRESS);
+    static final MethodHandle BIO_s_bio$MH = RuntimeHelper.downcallHandle(
+        "BIO_s_bio",
+        constants$3.BIO_s_bio$FUNC, false
+    );
+}
+
+

==================================================
constants$5.java
new file mode 100644
index 0000000000..d7b39bd55c
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$4.java
@@ -0,0 +1,75 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Generated by jextract
+
+package org.apache.tomcat.util.openssl;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
+import java.lang.foreign.*;
+import static java.lang.foreign.ValueLayout.*;
+class constants$4 {
+
+    static final FunctionDescriptor BIO_new_bio_pair$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        JAVA_LONG,
+        ADDRESS,
+        JAVA_LONG
+    );
+    static final MethodHandle BIO_new_bio_pair$MH = RuntimeHelper.downcallHandle(
+        "BIO_new_bio_pair",
+        constants$4.BIO_new_bio_pair$FUNC, false
+    );
+    static final FunctionDescriptor BN_new$FUNC = FunctionDescriptor.of(ADDRESS);
+    static final MethodHandle BN_new$MH = RuntimeHelper.downcallHandle(
+        "BN_new",
+        constants$4.BN_new$FUNC, false
+    );
+    static final FunctionDescriptor BN_set_word$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        JAVA_LONG
+    );
+    static final MethodHandle BN_set_word$MH = RuntimeHelper.downcallHandle(
+        "BN_set_word",
+        constants$4.BN_set_word$FUNC, false
+    );
+    static final FunctionDescriptor BN_get_rfc2409_prime_768$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle BN_get_rfc2409_prime_768$MH = RuntimeHelper.downcallHandle(
+        "BN_get_rfc2409_prime_768",
+        constants$4.BN_get_rfc2409_prime_768$FUNC, false
+    );
+    static final FunctionDescriptor BN_get_rfc2409_prime_1024$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle BN_get_rfc2409_prime_1024$MH = RuntimeHelper.downcallHandle(
+        "BN_get_rfc2409_prime_1024",
+        constants$4.BN_get_rfc2409_prime_1024$FUNC, false
+    );
+    static final FunctionDescriptor BN_get_rfc3526_prime_1536$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle BN_get_rfc3526_prime_1536$MH = RuntimeHelper.downcallHandle(
+        "BN_get_rfc3526_prime_1536",
+        constants$4.BN_get_rfc3526_prime_1536$FUNC, false
+    );
+}
+
+

==================================================
constants$6.java
new file mode 100644
index 0000000000..086e5b7db5
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$5.java
@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Generated by jextract
+
+package org.apache.tomcat.util.openssl;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
+import java.lang.foreign.*;
+import static java.lang.foreign.ValueLayout.*;
+class constants$5 {
+
+    static final FunctionDescriptor BN_get_rfc3526_prime_2048$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle BN_get_rfc3526_prime_2048$MH = RuntimeHelper.downcallHandle(
+        "BN_get_rfc3526_prime_2048",
+        constants$5.BN_get_rfc3526_prime_2048$FUNC, false
+    );
+    static final FunctionDescriptor BN_get_rfc3526_prime_3072$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle BN_get_rfc3526_prime_3072$MH = RuntimeHelper.downcallHandle(
+        "BN_get_rfc3526_prime_3072",
+        constants$5.BN_get_rfc3526_prime_3072$FUNC, false
+    );
+    static final FunctionDescriptor BN_get_rfc3526_prime_4096$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle BN_get_rfc3526_prime_4096$MH = RuntimeHelper.downcallHandle(
+        "BN_get_rfc3526_prime_4096",
+        constants$5.BN_get_rfc3526_prime_4096$FUNC, false
+    );
+    static final FunctionDescriptor BN_get_rfc3526_prime_6144$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle BN_get_rfc3526_prime_6144$MH = RuntimeHelper.downcallHandle(
+        "BN_get_rfc3526_prime_6144",
+        constants$5.BN_get_rfc3526_prime_6144$FUNC, false
+    );
+    static final FunctionDescriptor BN_get_rfc3526_prime_8192$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle BN_get_rfc3526_prime_8192$MH = RuntimeHelper.downcallHandle(
+        "BN_get_rfc3526_prime_8192",
+        constants$5.BN_get_rfc3526_prime_8192$FUNC, false
+    );
+    static final FunctionDescriptor ASN1_STRING_length$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS
+    );
+    static final MethodHandle ASN1_STRING_length$MH = RuntimeHelper.downcallHandle(
+        "ASN1_STRING_length",
+        constants$5.ASN1_STRING_length$FUNC, false
+    );
+}
+
+

==================================================
constants$7.java
new file mode 100644
index 0000000000..ed2494b275
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$6.java
@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Generated by jextract
+
+package org.apache.tomcat.util.openssl;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
+import java.lang.foreign.*;
+import static java.lang.foreign.ValueLayout.*;
+class constants$6 {
+
+    static final FunctionDescriptor ASN1_STRING_get0_data$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle ASN1_STRING_get0_data$MH = RuntimeHelper.downcallHandle(
+        "ASN1_STRING_get0_data",
+        constants$6.ASN1_STRING_get0_data$FUNC, false
+    );
+    static final FunctionDescriptor EVP_PKEY_base_id$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS
+    );
+    static final MethodHandle EVP_PKEY_base_id$MH = RuntimeHelper.downcallHandle(
+        "EVP_PKEY_base_id",
+        constants$6.EVP_PKEY_base_id$FUNC, false
+    );
+    static final FunctionDescriptor EVP_PKEY_bits$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS
+    );
+    static final MethodHandle EVP_PKEY_bits$MH = RuntimeHelper.downcallHandle(
+        "EVP_PKEY_bits",
+        constants$6.EVP_PKEY_bits$FUNC, false
+    );
+    static final FunctionDescriptor EC_GROUP_free$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS
+    );
+    static final MethodHandle EC_GROUP_free$MH = RuntimeHelper.downcallHandle(
+        "EC_GROUP_free",
+        constants$6.EC_GROUP_free$FUNC, false
+    );
+    static final FunctionDescriptor EC_GROUP_get_curve_name$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS
+    );
+    static final MethodHandle EC_GROUP_get_curve_name$MH = RuntimeHelper.downcallHandle(
+        "EC_GROUP_get_curve_name",
+        constants$6.EC_GROUP_get_curve_name$FUNC, false
+    );
+    static final FunctionDescriptor EC_KEY_new_by_curve_name$FUNC = FunctionDescriptor.of(ADDRESS,
+        JAVA_INT
+    );
+    static final MethodHandle EC_KEY_new_by_curve_name$MH = RuntimeHelper.downcallHandle(
+        "EC_KEY_new_by_curve_name",
+        constants$6.EC_KEY_new_by_curve_name$FUNC, false
+    );
+}
+
+

==================================================
constants$8.java
new file mode 100644
index 0000000000..343f45915d
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$7.java
@@ -0,0 +1,75 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Generated by jextract
+
+package org.apache.tomcat.util.openssl;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
+import java.lang.foreign.*;
+import static java.lang.foreign.ValueLayout.*;
+class constants$7 {
+
+    static final FunctionDescriptor EC_KEY_free$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS
+    );
+    static final MethodHandle EC_KEY_free$MH = RuntimeHelper.downcallHandle(
+        "EC_KEY_free",
+        constants$7.EC_KEY_free$FUNC, false
+    );
+    static final FunctionDescriptor DH_new$FUNC = FunctionDescriptor.of(ADDRESS);
+    static final MethodHandle DH_new$MH = RuntimeHelper.downcallHandle(
+        "DH_new",
+        constants$7.DH_new$FUNC, false
+    );
+    static final FunctionDescriptor DH_free$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS
+    );
+    static final MethodHandle DH_free$MH = RuntimeHelper.downcallHandle(
+        "DH_free",
+        constants$7.DH_free$FUNC, false
+    );
+    static final FunctionDescriptor DH_set0_pqg$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        ADDRESS,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle DH_set0_pqg$MH = RuntimeHelper.downcallHandle(
+        "DH_set0_pqg",
+        constants$7.DH_set0_pqg$FUNC, false
+    );
+    static final FunctionDescriptor X509_STORE_set_flags$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        JAVA_LONG
+    );
+    static final MethodHandle X509_STORE_set_flags$MH = RuntimeHelper.downcallHandle(
+        "X509_STORE_set_flags",
+        constants$7.X509_STORE_set_flags$FUNC, false
+    );
+    static final FunctionDescriptor X509_STORE_CTX_get0_untrusted$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle X509_STORE_CTX_get0_untrusted$MH = RuntimeHelper.downcallHandle(
+        "X509_STORE_CTX_get0_untrusted",
+        constants$7.X509_STORE_CTX_get0_untrusted$FUNC, false
+    );
+}
+
+

==================================================
constants$9.java
new file mode 100644
index 0000000000..338a89d1b9
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$8.java
@@ -0,0 +1,75 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Generated by jextract
+
+package org.apache.tomcat.util.openssl;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
+import java.lang.foreign.*;
+import static java.lang.foreign.ValueLayout.*;
+class constants$8 {
+
+    static final FunctionDescriptor X509_STORE_add_lookup$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle X509_STORE_add_lookup$MH = RuntimeHelper.downcallHandle(
+        "X509_STORE_add_lookup",
+        constants$8.X509_STORE_add_lookup$FUNC, false
+    );
+    static final FunctionDescriptor X509_LOOKUP_hash_dir$FUNC = FunctionDescriptor.of(ADDRESS);
+    static final MethodHandle X509_LOOKUP_hash_dir$MH = RuntimeHelper.downcallHandle(
+        "X509_LOOKUP_hash_dir",
+        constants$8.X509_LOOKUP_hash_dir$FUNC, false
+    );
+    static final FunctionDescriptor X509_LOOKUP_file$FUNC = FunctionDescriptor.of(ADDRESS);
+    static final MethodHandle X509_LOOKUP_file$MH = RuntimeHelper.downcallHandle(
+        "X509_LOOKUP_file",
+        constants$8.X509_LOOKUP_file$FUNC, false
+    );
+    static final FunctionDescriptor X509_LOOKUP_ctrl$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS,
+        JAVA_INT,
+        ADDRESS,
+        JAVA_LONG,
+        ADDRESS
+    );
+    static final MethodHandle X509_LOOKUP_ctrl$MH = RuntimeHelper.downcallHandle(
+        "X509_LOOKUP_ctrl",
+        constants$8.X509_LOOKUP_ctrl$FUNC, false
+    );
+    static final FunctionDescriptor X509_STORE_CTX_get_ex_data$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS,
+        JAVA_INT
+    );
+    static final MethodHandle X509_STORE_CTX_get_ex_data$MH = RuntimeHelper.downcallHandle(
+        "X509_STORE_CTX_get_ex_data",
+        constants$8.X509_STORE_CTX_get_ex_data$FUNC, false
+    );
+    static final FunctionDescriptor X509_STORE_CTX_get_error$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS
+    );
+    static final MethodHandle X509_STORE_CTX_get_error$MH = RuntimeHelper.downcallHandle(
+        "X509_STORE_CTX_get_error",
+        constants$8.X509_STORE_CTX_get_error$FUNC, false
+    );
+}
+
+

==================================================
openssl_h.java
new file mode 100644
index 0000000000..360216dbcc
--- /dev/null
+++ b/modules/openssl-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$9.java
@@ -0,0 +1,75 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Generated by jextract
+
+package org.apache.tomcat.util.openssl;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
+import java.lang.foreign.*;
+import static java.lang.foreign.ValueLayout.*;
+class constants$9 {
+
+    static final FunctionDescriptor X509_STORE_CTX_set_error$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS,
+        JAVA_INT
+    );
+    static final MethodHandle X509_STORE_CTX_set_error$MH = RuntimeHelper.downcallHandle(
+        "X509_STORE_CTX_set_error",
+        constants$9.X509_STORE_CTX_set_error$FUNC, false
+    );
+    static final FunctionDescriptor X509_STORE_CTX_get_error_depth$FUNC = FunctionDescriptor.of(JAVA_INT,
+        ADDRESS
+    );
+    static final MethodHandle X509_STORE_CTX_get_error_depth$MH = RuntimeHelper.downcallHandle(
+        "X509_STORE_CTX_get_error_depth",
+        constants$9.X509_STORE_CTX_get_error_depth$FUNC, false
+    );
+    static final FunctionDescriptor X509_STORE_CTX_get_current_cert$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle X509_STORE_CTX_get_current_cert$MH = RuntimeHelper.downcallHandle(
+        "X509_STORE_CTX_get_current_cert",
+        constants$9.X509_STORE_CTX_get_current_cert$FUNC, false
+    );
+    static final FunctionDescriptor X509_STORE_CTX_get0_current_issuer$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle X509_STORE_CTX_get0_current_issuer$MH = RuntimeHelper.downcallHandle(
+        "X509_STORE_CTX_get0_current_issuer",
+        constants$9.X509_STORE_CTX_get0_current_issuer$FUNC, false
+    );
+    static final FunctionDescriptor d2i_X509_bio$FUNC = FunctionDescriptor.of(ADDRESS,
+        ADDRESS,
+        ADDRESS
+    );
+    static final MethodHandle d2i_X509_bio$MH = RuntimeHelper.downcallHandle(
+        "d2i_X509_bio",
+        constants$9.d2i_X509_bio$FUNC, false
+    );
+    static final FunctionDescriptor X509_free$FUNC = FunctionDescriptor.ofVoid(
+        ADDRESS
+    );
+    static final MethodHandle X509_free$MH = RuntimeHelper.downcallHandle(
+        "X509_free",
+        constants$9.X509_free$FUNC, false
+    );
+}
+
+

==================================================
