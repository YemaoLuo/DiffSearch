f93376d54df87ca64c1286ac209da107b45ab574
==================================================
Note: This patch is on the critical path.
==================================================
Mark Emlyn
==================================================
Mon May 19 20:07:20 2008 +0000
==================================================
InternalAprInputBuffer.java
Note: This patch is on the critical path.
Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=42750
Making parsing of the request line tolerant of multiple SP and/or HT rather than requiring single SP characters.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@657954 13f79535-47bb-0310-9956-ffa450edef68



==================================================
InternalInputBuffer.java
index 4286458135..f1137cf292 100644
--- a/java/org/apache/coyote/http11/InternalAprInputBuffer.java
+++ b/java/org/apache/coyote/http11/InternalAprInputBuffer.java
@@ -403,7 +403,8 @@ public class InternalAprInputBuffer implements InputBuffer {
                     throw new EOFException(sm.getString("iib.eof.error"));
             }
 
-            if (buf[pos] == Constants.SP) {
+            // Spec says single SP but it also says be tolerant of HT
+            if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
                 space = true;
                 request.method().setBytes(buf, start, pos - start);
             }
@@ -412,6 +413,20 @@ public class InternalAprInputBuffer implements InputBuffer {
 
         }
 
+        // Spec says single SP but also says be tolerant of multiple and/or HT
+        while (space) {
+            // Read new bytes if needed
+            if (pos >= lastValid) {
+                if (!fill())
+                    throw new EOFException(sm.getString("iib.eof.error"));
+            }
+            if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
+                pos++;
+            } else {
+                space = false;
+            }
+        }
+
         // Mark the current buffer position
         start = pos;
         int end = 0;
@@ -421,7 +436,6 @@ public class InternalAprInputBuffer implements InputBuffer {
         // Reading the URI
         //
 
-        space = false;
         boolean eol = false;
 
         while (!space) {
@@ -432,7 +446,8 @@ public class InternalAprInputBuffer implements InputBuffer {
                     throw new EOFException(sm.getString("iib.eof.error"));
             }
 
-            if (buf[pos] == Constants.SP) {
+            // Spec says single SP but it also says be tolerant of HT
+            if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
                 space = true;
                 end = pos;
             } else if ((buf[pos] == Constants.CR) 
@@ -459,6 +474,21 @@ public class InternalAprInputBuffer implements InputBuffer {
             request.requestURI().setBytes(buf, start, end - start);
         }
 
+        // Spec says single SP but also says be tolerant of multiple and/or HT
+        while (space) {
+            // Read new bytes if needed
+            if (pos >= lastValid) {
+                if (!fill())
+                    throw new EOFException(sm.getString("iib.eof.error"));
+            }
+            if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
+                pos++;
+            } else {
+                space = false;
+            }
+        }
+
+
         // Mark the current buffer position
         start = pos;
         end = 0;

==================================================
InternalNioInputBuffer.java
index 6b77f24862..d98a64bd9c 100644
--- a/java/org/apache/coyote/http11/InternalInputBuffer.java
+++ b/java/org/apache/coyote/http11/InternalInputBuffer.java
@@ -391,7 +391,8 @@ public class InternalInputBuffer implements InputBuffer {
                     throw new EOFException(sm.getString("iib.eof.error"));
             }
 
-            if (buf[pos] == Constants.SP) {
+            // Spec says single SP but it also says be tolerant of HT
+            if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
                 space = true;
                 request.method().setBytes(buf, start, pos - start);
             }
@@ -400,6 +401,21 @@ public class InternalInputBuffer implements InputBuffer {
 
         }
 
+        
+        // Spec says single SP but also says be tolerant of multiple and/or HT
+        while (space) {
+            // Read new bytes if needed
+            if (pos >= lastValid) {
+                if (!fill())
+                    throw new EOFException(sm.getString("iib.eof.error"));
+            }
+            if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
+                pos++;
+            } else {
+                space = false;
+            }
+        }
+
         // Mark the current buffer position
         start = pos;
         int end = 0;
@@ -409,7 +425,6 @@ public class InternalInputBuffer implements InputBuffer {
         // Reading the URI
         //
 
-        space = false;
         boolean eol = false;
 
         while (!space) {
@@ -420,7 +435,8 @@ public class InternalInputBuffer implements InputBuffer {
                     throw new EOFException(sm.getString("iib.eof.error"));
             }
 
-            if (buf[pos] == Constants.SP) {
+            // Spec says single SP but it also says be tolerant of HT
+            if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
                 space = true;
                 end = pos;
             } else if ((buf[pos] == Constants.CR) 
@@ -447,6 +463,20 @@ public class InternalInputBuffer implements InputBuffer {
             request.requestURI().setBytes(buf, start, end - start);
         }
 
+        // Spec says single SP but also says be tolerant of multiple and/or HT
+        while (space) {
+            // Read new bytes if needed
+            if (pos >= lastValid) {
+                if (!fill())
+                    throw new EOFException(sm.getString("iib.eof.error"));
+            }
+            if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
+                pos++;
+            } else {
+                space = false;
+            }
+        }
+
         // Mark the current buffer position
         start = pos;
         end = 0;

==================================================
