272cb97d3b4a16a983d52ae9ffc1f3d33cad5f35
==================================================
EL 3.0
==================================================
Mark Emlyn
==================================================
Wed Jul 3 12:45:46 2013 +0000
==================================================
ArrayELResolver.java
EL 3.0
Implement new EvaluationListener class
Create new Util class
Refactor i18n support

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1499371 13f79535-47bb-0310-9956-ffa450edef68



==================================================
BeanELResolver.java
index a96f27acdb..56a7e922e1 100644
--- a/java/javax/el/ArrayELResolver.java
+++ b/java/javax/el/ArrayELResolver.java
@@ -83,7 +83,7 @@ public class ArrayELResolver extends ELResolver {
             context.setPropertyResolved(true);
 
             if (this.readOnly) {
-                throw new PropertyNotWritableException(message(context,
+                throw new PropertyNotWritableException(Util.message(context,
                         "resolverNotWriteable", base.getClass().getName()));
             }
 
@@ -92,7 +92,7 @@ public class ArrayELResolver extends ELResolver {
             if (value != null &&
                     !base.getClass().getComponentType().isAssignableFrom(
                             value.getClass())) {
-                throw new ClassCastException(message(context,
+                throw new ClassCastException(Util.message(context,
                         "objectNotAssignable", value.getClass().getName(),
                         base.getClass().getComponentType().getName()));
             }

==================================================
ELContext.java
index f6c96db189..b2d871711f 100644
--- a/java/javax/el/BeanELResolver.java
+++ b/java/javax/el/BeanELResolver.java
@@ -109,7 +109,7 @@ public class BeanELResolver extends ELResolver {
             if (cause instanceof VirtualMachineError) {
                 throw (VirtualMachineError) cause;
             }
-            throw new ELException(message(context, "propertyReadError",
+            throw new ELException(Util.message(context, "propertyReadError",
                     base.getClass().getName(), property.toString()), cause);
         } catch (Exception e) {
             throw new ELException(e);
@@ -131,7 +131,7 @@ public class BeanELResolver extends ELResolver {
         context.setPropertyResolved(true);
 
         if (this.readOnly) {
-            throw new PropertyNotWritableException(message(context,
+            throw new PropertyNotWritableException(Util.message(context,
                     "resolverNotWriteable", base.getClass().getName()));
         }
 
@@ -148,7 +148,7 @@ public class BeanELResolver extends ELResolver {
             if (cause instanceof VirtualMachineError) {
                 throw (VirtualMachineError) cause;
             }
-            throw new ELException(message(context, "propertyWriteError",
+            throw new ELException(Util.message(context, "propertyWriteError",
                     base.getClass().getName(), property.toString()), cause);
         } catch (Exception e) {
             throw new ELException(e);
@@ -338,7 +338,7 @@ public class BeanELResolver extends ELResolver {
         private BeanProperty get(ELContext ctx, String name) {
             BeanProperty property = this.properties.get(name);
             if (property == null) {
-                throw new PropertyNotFoundException(message(ctx,
+                throw new PropertyNotFoundException(Util.message(ctx,
                         "propertyNotFound", type.getName(), name));
             }
             return property;
@@ -393,7 +393,7 @@ public class BeanELResolver extends ELResolver {
             if (this.write == null) {
                 this.write = getMethod(this.owner, descriptor.getWriteMethod());
                 if (this.write == null) {
-                    throw new PropertyNotFoundException(message(ctx,
+                    throw new PropertyNotFoundException(Util.message(ctx,
                             "propertyNotWritable", new Object[] {
                                     owner.getName(), descriptor.getName() }));
                 }
@@ -405,7 +405,7 @@ public class BeanELResolver extends ELResolver {
             if (this.read == null) {
                 this.read = getMethod(this.owner, descriptor.getReadMethod());
                 if (this.read == null) {
-                    throw new PropertyNotFoundException(message(ctx,
+                    throw new PropertyNotFoundException(Util.message(ctx,
                             "propertyNotReadable", new Object[] {
                                     owner.getName(), descriptor.getName() }));
                 }

==================================================
ELResolver.java
index e8e5b74485..7e16a924ba 100644
--- a/java/javax/el/ELContext.java
+++ b/java/javax/el/ELContext.java
@@ -16,7 +16,9 @@
  */
 package javax.el;
 
+import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 
@@ -28,6 +30,10 @@ public abstract class ELContext {
 
     private boolean resolved;
 
+    private ImportHandler importHandler = null;
+
+    private List<EvaluationListener> listeners = new ArrayList<>();
+
     public ELContext() {
         this.resolved = false;
     }
@@ -36,6 +42,14 @@ public abstract class ELContext {
         this.resolved = resolved;
     }
 
+    /**
+     * @since EL 3.0
+     */
+    public void setPropertyResolved(Object base, Object property) {
+        setPropertyResolved(true);
+        notifyPropertyResolved(base, property);
+    }
+
     public boolean isPropertyResolved() {
         return this.resolved;
     }
@@ -64,6 +78,16 @@ public abstract class ELContext {
 
     public abstract ELResolver getELResolver();
 
+    /**
+     * @since EL 3.0
+     */
+    public ImportHandler getImportHandler() {
+        if (importHandler == null) {
+            importHandler = new ImportHandler();
+        }
+        return importHandler;
+    }
+
     public abstract FunctionMapper getFunctionMapper();
 
     public Locale getLocale() {
@@ -75,4 +99,60 @@ public abstract class ELContext {
     }
 
     public abstract VariableMapper getVariableMapper();
+
+    /**
+     * @since EL 3.0
+     */
+    public void addEvaluationListener(EvaluationListener listener) {
+        listeners.add(listener);
+    }
+
+    /**
+     * @since EL 3.0
+     */
+    public List<EvaluationListener> getEvaluationListeners() {
+        return listeners;
+    }
+
+    /**
+     * @since EL 3.0
+     */
+    public void notifyBeforeEvaluation(String expression) {
+        for (EvaluationListener listener : listeners) {
+            try {
+                listener.beforeEvaluation(this, expression);
+            } catch (Throwable t) {
+                Util.handleThrowable(t);
+                // Ignore - no option to log
+            }
+        }
+    }
+
+    /**
+     * @since EL 3.0
+     */
+    public void notifyAfterEvaluation(String expression) {
+        for (EvaluationListener listener : listeners) {
+            try {
+                listener.afterEvaluation(this, expression);
+            } catch (Throwable t) {
+                Util.handleThrowable(t);
+                // Ignore - no option to log
+            }
+        }
+    }
+
+    /**
+     * @since EL 3.0
+     */
+    public void notifyPropertyResolved(Object base, Object property) {
+        for (EvaluationListener listener : listeners) {
+            try {
+                listener.propertyResolved(this, base, property);
+            } catch (Throwable t) {
+                Util.handleThrowable(t);
+                // Ignore - no option to log
+            }
+        }
+    }
 }

==================================================
EvaluationListener.java
index f51ecee5af..d8e399acc3 100644
--- a/java/javax/el/ELResolver.java
+++ b/java/javax/el/ELResolver.java
@@ -14,14 +14,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package javax.el;
 
-import java.text.MessageFormat;
 import java.util.Iterator;
-import java.util.Locale;
-import java.util.MissingResourceException;
-import java.util.ResourceBundle;
 
 /**
  * @author Jacob Hookom [jacob/hookom.net]
@@ -29,31 +24,6 @@ import java.util.ResourceBundle;
  */
 public abstract class ELResolver {
 
-    static String message(ELContext context, String name, Object... props) {
-        Locale locale = null;
-        if (context != null) {
-            locale = context.getLocale();
-        }
-        if (locale == null) {
-            locale = Locale.getDefault();
-            if (locale == null) {
-                return "";
-            }
-        }
-        ResourceBundle bundle = ResourceBundle.getBundle(
-                "javax.el.LocalStrings", locale);
-        try {
-            String template = bundle.getString(name);
-            if (props != null) {
-                template = MessageFormat.format(template, props);
-            }
-            return template;
-        } catch (MissingResourceException e) {
-            return "Missing Resource: '" + name + "' for Locale "
-                    + locale.getDisplayName();
-        }
-    }
-
     public static final String TYPE = "type";
 
     public static final String RESOLVABLE_AT_DESIGN_TIME = "resolvableAtDesignTime";

==================================================
ImportHandler.java
new file mode 100644
index 0000000000..13aec8dd72
--- /dev/null
+++ b/java/javax/el/EvaluationListener.java
@@ -0,0 +1,54 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package javax.el;
+
+/**
+ * @since EL 3.0
+ */
+public abstract class EvaluationListener {
+
+    /**
+     * Fired before the evaluation of the expression.
+     *
+     * @param context
+     * @param expression
+     */
+    public void beforeEvaluation(ELContext context, String expression) {
+        // NO-OP
+    }
+
+    /**
+     * Fired after the evaluation of the expression.
+     *
+     * @param context
+     * @param expression
+     */
+    public void afterEvaluation(ELContext context, String expression) {
+        // NO-OP
+    }
+
+    /**
+     * Fired after a property has been resolved.
+     *
+     * @param context
+     * @param base
+     * @param property
+     */
+    public void propertyResolved(ELContext context, Object base, Object property) {
+        // NO-OP
+    }
+}

==================================================
ListELResolver.java
index 38f0d17f9f..47034fb812 100644
--- a/java/javax/el/ImportHandler.java
+++ b/java/javax/el/ImportHandler.java
@@ -43,7 +43,7 @@ public class ImportHandler {
         int lastPeriod = name.lastIndexOf('.');
 
         if (lastPeriod < 0) {
-            throw new ELException(ELResolver.message(
+            throw new ELException(Util.message(
                     null, "importHandler.invalidStaticName", name));
         }
 
@@ -53,7 +53,7 @@ public class ImportHandler {
         Class<?> clazz = findClass(className);
 
         if (clazz == null) {
-            throw new ELException(ELResolver.message(
+            throw new ELException(Util.message(
                     null, "importHandler.invalidClassNameForStatic",
                     className, name));
         }
@@ -77,14 +77,14 @@ public class ImportHandler {
         }
 
         if (!found) {
-            throw new ELException(ELResolver.message(null,
+            throw new ELException(Util.message(null,
                     "importHandler.staticNotFound", fieldOrMethodName,
                     className, name));
         }
 
         Class<?> conflict = statics.get(fieldOrMethodName);
         if (conflict != null) {
-            throw new ELException(ELResolver.message(null,
+            throw new ELException(Util.message(null,
                     "importHandler.ambiguousStaticImport", name,
                     conflict.getName() + '.' +  fieldOrMethodName));
         }
@@ -95,14 +95,14 @@ public class ImportHandler {
 
     public void importClass(String name) throws javax.el.ELException {
         if (!name.contains(".")) {
-            throw new ELException(ELResolver.message(
+            throw new ELException(Util.message(
                     null, "importHandler.invalidClassName", name));
         }
 
         Class<?> clazz = findClass(name);
 
         if (clazz == null) {
-            throw new ELException(ELResolver.message(
+            throw new ELException(Util.message(
                     null, "importHandler.classNotFound", name));
         }
     }
@@ -112,7 +112,7 @@ public class ImportHandler {
         // Import ambiguity is handled at resolution, not at import
         Package p = Package.getPackage(name);
         if (p == null) {
-            throw new IllegalArgumentException(ELResolver.message(
+            throw new IllegalArgumentException(Util.message(
                     null, "importHandler.invalidPackage", name));
         }
         packages.add(name);
@@ -154,7 +154,7 @@ public class ImportHandler {
         int modifiers = clazz.getModifiers();
         if (!Modifier.isPublic(modifiers) || Modifier.isAbstract(modifiers) ||
                 Modifier.isInterface(modifiers)) {
-            throw new ELException(ELResolver.message(
+            throw new ELException(Util.message(
                     null, "importHandler.invalidClass", name));
         }
 
@@ -162,7 +162,7 @@ public class ImportHandler {
         Class<?> conflict = clazzes.get(simpleName);
 
         if (conflict != null) {
-            throw new ELException(ELResolver.message(null,
+            throw new ELException(Util.message(null,
                     "importHandler.ambiguousImport", name, conflict.getName()));
         }
 

==================================================
MapELResolver.java
index a65aa33b3b..e4c67c9960 100644
--- a/java/javax/el/ListELResolver.java
+++ b/java/javax/el/ListELResolver.java
@@ -95,7 +95,7 @@ public class ListELResolver extends ELResolver {
             List<Object> list = (List<Object>) base;
 
             if (this.readOnly) {
-                throw new PropertyNotWritableException(message(context,
+                throw new PropertyNotWritableException(Util.message(context,
                         "resolverNotWriteable", base.getClass().getName()));
             }
 

==================================================
ResourceBundleELResolver.java
index 4ebbbfbf7a..88669b0afe 100644
--- a/java/javax/el/MapELResolver.java
+++ b/java/javax/el/MapELResolver.java
@@ -83,7 +83,7 @@ public class MapELResolver extends ELResolver {
             context.setPropertyResolved(true);
 
             if (this.readOnly) {
-                throw new PropertyNotWritableException(message(context,
+                throw new PropertyNotWritableException(Util.message(context,
                         "resolverNotWriteable", base.getClass().getName()));
             }
 

==================================================
Util.java
index 481099e271..56abb89ddd 100644
--- a/java/javax/el/ResourceBundleELResolver.java
+++ b/java/javax/el/ResourceBundleELResolver.java
@@ -81,7 +81,7 @@ public class ResourceBundleELResolver extends ELResolver {
 
         if (base instanceof ResourceBundle) {
             context.setPropertyResolved(true);
-            throw new PropertyNotWritableException(message(context,
+            throw new PropertyNotWritableException(Util.message(context,
                     "resolverNotWriteable", base.getClass().getName()));
         }
     }

==================================================
