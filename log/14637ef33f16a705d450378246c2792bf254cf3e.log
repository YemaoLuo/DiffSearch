14637ef33f16a705d450378246c2792bf254cf3e
==================================================
Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=54123
==================================================
Mark Emlyn
==================================================
Sun Nov 11 23:26:55 2012 +0000
==================================================
AsyncContextImpl.java
Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=54123
There are two things going on here:
1. The reported bug. If there is a async timeout and no async listeners, trigger a 500 response.
2. Implement "error dispatch". This is used a couple of times in the spec without any definition. The implication from the part of the spec quoted in the bug report is:
   - The standard error page mechanism should be used to identify the page
   - An async request that has been started should be left in async mode when forwarding to the error page
   - The error page may call complete() or dispatch()
This commit hooks into the StandardHostValve to access the error page mechanism. I could have copied and pasted but I preferred the dependency on StandardHostValve
Because the error page may do a dispatch(), need to ensure that when running the dispatch(), the error page mechanism is not triggered a second time.
Depending on what emerges running the full unit tests and the TCK, I mat still decide to copy the error page code to AsyncContextImpl

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1408148 13f79535-47bb-0310-9956-ffa450edef68



==================================================
StandardHostValve.java
index 22dd780f15..a4a501a44d 100644
--- a/java/org/apache/catalina/core/AsyncContextImpl.java
+++ b/java/org/apache/catalina/core/AsyncContextImpl.java
@@ -41,6 +41,8 @@ import javax.servlet.http.HttpServletResponse;
 import org.apache.catalina.AsyncDispatcher;
 import org.apache.catalina.Context;
 import org.apache.catalina.Globals;
+import org.apache.catalina.Host;
+import org.apache.catalina.Valve;
 import org.apache.catalina.connector.Request;
 import org.apache.coyote.ActionCode;
 import org.apache.coyote.AsyncContextCallback;
@@ -182,8 +184,8 @@ public class AsyncContextImpl implements AsyncContext, AsyncContextCallback {
                             ActionCode.ASYNC_IS_TIMINGOUT, result);
                     return !result.get();
                 } else {
-                    // No listeners, container calls complete
-                    complete();
+                    // No listeners, trigger error handling
+                    return false;
                 }
 
             } finally {
@@ -423,6 +425,23 @@ public class AsyncContextImpl implements AsyncContext, AsyncContextCallback {
                         listener.getClass().getName() + "]", ioe);
             }
         }
+
+        // SRV.2.3.3.3 (search for "error dispatch")
+        if (servletResponse instanceof HttpServletResponse) {
+            ((HttpServletResponse) servletResponse).setStatus(
+                    HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
+        }
+
+        Host host = (Host) context.getParent();
+        Valve stdHostValve = host.getPipeline().getBasic();
+        if (stdHostValve instanceof StandardHostValve) {
+            ((StandardHostValve) stdHostValve).throwable(request,
+                    request.getResponse(), t);
+        }
+
+        if (isStarted() && !request.isAsyncDispatching()) {
+            complete();
+        }
     }
 
 

==================================================
AsyncStateMachine.java
index 448415131b..ded1463e6c 100644
--- a/java/org/apache/catalina/core/StandardHostValve.java
+++ b/java/org/apache/catalina/core/StandardHostValve.java
@@ -145,6 +145,9 @@ final class StandardHostValve extends ValveBase {
         // If a request init listener throws an exception, the request is
         // aborted
         boolean asyncAtStart = request.isAsync();
+        // An async error page may dispatch to another resource. This flag helps
+        // ensure an infinite error handling loop is not entered
+        boolean errorAtStart = response.isError();
         if (asyncAtStart || context.fireRequestInitEvent(request)) {
 
             // Ask this Context to process this request
@@ -152,29 +155,37 @@ final class StandardHostValve extends ValveBase {
                 context.getPipeline().getFirst().invoke(request, response);
             } catch (Throwable t) {
                 ExceptionUtils.handleThrowable(t);
-                request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t);
-                throwable(request, response, t);
+                if (errorAtStart) {
+                    container.getLogger().error("Exception Processing " +
+                            request.getRequestURI(), t);
+                } else {
+                    request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t);
+                    throwable(request, response, t);
+                }
             }
 
             // If the request was async at the start and an error occurred then
             // the async error handling will kick-in and that will fire the
             // request destroyed event *after* the error handling has taken
             // place
-            if (!(request.isAsync() || (asyncAtStart && request.getAttribute(
-                        RequestDispatcher.ERROR_EXCEPTION) != null))) {
-                // Protect against NPEs if context was destroyed during a long
-                // running request.
+            if (!(request.isAsync() || (asyncAtStart &&
+                    request.getAttribute(
+                            RequestDispatcher.ERROR_EXCEPTION) != null))) {
+                // Protect against NPEs if context was destroyed during a
+                // long running request.
                 if (context.getState().isAvailable()) {
-                    // Error page processing
-                    response.setSuspended(false);
-
-                    Throwable t = (Throwable) request.getAttribute(
-                            RequestDispatcher.ERROR_EXCEPTION);
-
-                    if (t != null) {
-                        throwable(request, response, t);
-                    } else {
-                        status(request, response);
+                    if (!errorAtStart) {
+                        // Error page processing
+                        response.setSuspended(false);
+
+                        Throwable t = (Throwable) request.getAttribute(
+                                RequestDispatcher.ERROR_EXCEPTION);
+
+                        if (t != null) {
+                            throwable(request, response, t);
+                        } else {
+                            status(request, response);
+                        }
                     }
 
                     context.fireRequestDestroyEvent(request);
@@ -334,7 +345,7 @@ final class StandardHostValve extends ValveBase {
      * @param throwable The exception that occurred (which possibly wraps
      *  a root cause exception
      */
-    private void throwable(Request request, Response response,
+    protected void throwable(Request request, Response response,
                              Throwable throwable) {
         Context context = request.getContext();
         if (context == null) {

==================================================
TestAsyncContextImpl.java
index 02d4010ef0..1bfb7941b6 100644
--- a/java/org/apache/coyote/AsyncStateMachine.java
+++ b/java/org/apache/coyote/AsyncStateMachine.java
@@ -271,7 +271,8 @@ public class AsyncStateMachine<S> {
         if (state == AsyncState.STARTING) {
             state = AsyncState.MUST_DISPATCH;
         } else if (state == AsyncState.STARTED ||
-                state == AsyncState.TIMING_OUT) {
+                state == AsyncState.TIMING_OUT ||
+                state == AsyncState.ERROR) {
             state = AsyncState.DISPATCHING;
             doDispatch = true;
         } else {

==================================================
