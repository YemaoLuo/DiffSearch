632e68c830312d12eb5292fe15599f4f21ac70b5
==================================================
Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=48267
==================================================
Mark Emlyn
==================================================
Fri Nov 27 17:14:16 2009 +0000
==================================================
Resource.java
Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=48267
Generics
Patch provided by sebb

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@884913 13f79535-47bb-0310-9956-ffa450edef68



==================================================
EJB.java
index 7510565c5f..bc3bd70c47 100644
--- a/java/javax/annotation/Resource.java
+++ b/java/javax/annotation/Resource.java
@@ -32,6 +32,7 @@ public @interface Resource {
         APPLICATION
     }
     public String name() default "";
+    @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match specification
     public Class type() default Object.class;
     public AuthenticationType authenticationType() default AuthenticationType.CONTAINER;
     public boolean shareable() default true;

==================================================
BeanELResolver.java
index 1ea40a904f..8e31ad8f5f 100644
--- a/java/javax/ejb/EJB.java
+++ b/java/javax/ejb/EJB.java
@@ -29,6 +29,7 @@ import java.lang.annotation.Target;
 public @interface EJB {
    String name() default "";
    String description() default "";
+   @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match specification
    Class beanInterface() default java.lang.Object.class;
    String beanName() default "";
    String mappedName() default "";

==================================================
ELContext.java
index ea21be5579..77c4822743 100644
--- a/java/javax/el/BeanELResolver.java
+++ b/java/javax/el/BeanELResolver.java
@@ -229,7 +229,8 @@ public class BeanELResolver extends ELResolver {
 			this.type = descriptor.getPropertyType();
 		}
 
-		public Class getPropertyType() {
+		@SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match specification
+        public Class getPropertyType() {
 			return this.type;
 		}
 
@@ -285,7 +286,7 @@ public class BeanELResolver extends ELResolver {
 		return props.get(ctx, prop);
 	}
 
-	private final static Method getMethod(Class type, Method m) {
+	private final static Method getMethod(Class<?> type, Method m) {
 		if (m == null || Modifier.isPublic(type.getModifiers())) {
 			return m;
 		}

==================================================
ListELResolver.java
index db59394659..19f2f66541 100644
--- a/java/javax/el/ELContext.java
+++ b/java/javax/el/ELContext.java
@@ -39,6 +39,7 @@ public abstract class ELContext {
         this.resolved = false;
     }
     
+    @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match specification
     public Object getContext(Class key) {
         if (this.map == null) {
             return null;
@@ -46,6 +47,7 @@ public abstract class ELContext {
         return this.map.get(key);
     }
     
+    @SuppressWarnings("unchecked") // Can't use Class<?> because API needs to match specification
     public void putContext(Class key, Object contextObject) throws NullPointerException {
         if (key == null || contextObject == null) {
             throw new NullPointerException();

==================================================
MapELResolver.java
index 712e69de71..b6328dcfac 100644
--- a/java/javax/el/ListELResolver.java
+++ b/java/javax/el/ListELResolver.java
@@ -28,7 +28,7 @@ public class ListELResolver extends ELResolver {
 
 	private final boolean readOnly;
 
-	private final static Class<? extends List> UNMODIFIABLE =
+	private final static Class<?> UNMODIFIABLE =
 	    Collections.unmodifiableList(new ArrayList<Object>()).getClass();
 
 	public ListELResolver() {
@@ -46,9 +46,9 @@ public class ListELResolver extends ELResolver {
 			throw new NullPointerException();
 		}
 
-		if (base instanceof List) {
+		if (base instanceof List<?>) {
 			context.setPropertyResolved(true);
-			List<Object> list = (List<Object>) base;
+			List<?> list = (List<?>) base;
 			int idx = coerce(property);
 			if (idx < 0 || idx >= list.size()) {
 				return null;
@@ -66,9 +66,9 @@ public class ListELResolver extends ELResolver {
 			throw new NullPointerException();
 		}
 
-		if (base instanceof List) {
+		if (base instanceof List<?>) {
 			context.setPropertyResolved(true);
-			List<Object> list = (List<Object>) base;
+			List<?> list = (List<?>) base;
 			int idx = coerce(property);
 			if (idx < 0 || idx >= list.size()) {
 				return null;
@@ -89,8 +89,9 @@ public class ListELResolver extends ELResolver {
 			throw new NullPointerException();
 		}
 
-		if (base instanceof List) {
+		if (base instanceof List<?>) {
 			context.setPropertyResolved(true);
+			@SuppressWarnings("unchecked") // Must be OK to cast to Object
 			List<Object> list = (List<Object>) base;
 
 			if (this.readOnly) {
@@ -117,9 +118,9 @@ public class ListELResolver extends ELResolver {
 			throw new NullPointerException();
 		}
 
-		if (base instanceof List) {
+		if (base instanceof List<?>) {
 			context.setPropertyResolved(true);
-			List<Object> list = (List<Object>) base;
+			List<?> list = (List<?>) base;
 			int idx = coerce(property);
 			if (idx < 0 || idx >= list.size()) {
 				throw new PropertyNotFoundException(
@@ -133,8 +134,8 @@ public class ListELResolver extends ELResolver {
 
 	@Override
     public Iterator<FeatureDescriptor> getFeatureDescriptors(ELContext context, Object base) {
-		if (base instanceof List) {
-			FeatureDescriptor[] descs = new FeatureDescriptor[((List) base).size()];
+		if (base instanceof List<?>) {
+			FeatureDescriptor[] descs = new FeatureDescriptor[((List<?>) base).size()];
 			for (int i = 0; i < descs.length; i++) {
 				descs[i] = new FeatureDescriptor();
 				descs[i].setDisplayName("["+i+"]");
@@ -152,7 +153,7 @@ public class ListELResolver extends ELResolver {
 
 	@Override
     public Class<?> getCommonPropertyType(ELContext context, Object base) {
-		if (base != null && base instanceof List) {
+		if (base instanceof List<?>) { // implies base != null
 			return Integer.class;
 		}
 		return null;

==================================================
ResourceBundleELResolver.java
index 7238fc3b06..a265d09a6e 100644
--- a/java/javax/el/MapELResolver.java
+++ b/java/javax/el/MapELResolver.java
@@ -27,8 +27,8 @@ import java.util.Map;
 
 public class MapELResolver extends ELResolver {
 
-	private final static Class UNMODIFIABLE = Collections.unmodifiableMap(
-			new HashMap()).getClass();
+	private final static Class<?> UNMODIFIABLE = Collections.unmodifiableMap(
+			new HashMap<Object, Object>()).getClass();
 
 	private final boolean readOnly;
 
@@ -47,9 +47,9 @@ public class MapELResolver extends ELResolver {
 			throw new NullPointerException();
 		}
 
-		if (base instanceof Map) {
+		if (base instanceof Map<?,?>) {
 			context.setPropertyResolved(true);
-			return ((Map) base).get(property);
+			return ((Map<?,?>) base).get(property);
 		}
 		
 		return null;
@@ -62,9 +62,9 @@ public class MapELResolver extends ELResolver {
 			throw new NullPointerException();
 		}
 
-		if (base instanceof Map) {
+		if (base instanceof Map<?,?>) {
 			context.setPropertyResolved(true);
-			Object obj = ((Map) base).get(property);
+			Object obj = ((Map<?,?>) base).get(property);
 			return (obj != null) ? obj.getClass() : null;
 		}
 		
@@ -80,7 +80,7 @@ public class MapELResolver extends ELResolver {
 			throw new NullPointerException();
 		}
 
-		if (base instanceof Map) {
+		if (base instanceof Map<?, ?>) {
 			context.setPropertyResolved(true);
 
 			if (this.readOnly) {
@@ -90,7 +90,9 @@ public class MapELResolver extends ELResolver {
 			}
 
 			try {
-				((Map) base).put(property, value);
+			    @SuppressWarnings("unchecked") // Must be OK
+			    Map<Object, Object> map = ((Map<Object, Object>) base);
+			    map.put(property, value);
 			} catch (UnsupportedOperationException e) {
 				throw new PropertyNotWritableException(e);
 			}
@@ -104,7 +106,7 @@ public class MapELResolver extends ELResolver {
 			throw new NullPointerException();
 		}
 
-		if (base instanceof Map) {
+		if (base instanceof Map<?, ?>) {
 			context.setPropertyResolved(true);
 			return this.readOnly || UNMODIFIABLE.equals(base.getClass());
 		}
@@ -114,8 +116,8 @@ public class MapELResolver extends ELResolver {
 
 	@Override
     public Iterator<FeatureDescriptor> getFeatureDescriptors(ELContext context, Object base) {
-		if (base instanceof Map) {
-			Iterator itr = ((Map) base).keySet().iterator();
+		if (base instanceof Map<?, ?>) {
+			Iterator<?> itr = ((Map<?, ?>) base).keySet().iterator();
 			List<FeatureDescriptor> feats = new ArrayList<FeatureDescriptor>();
 			Object key;
 			FeatureDescriptor desc;
@@ -138,7 +140,7 @@ public class MapELResolver extends ELResolver {
 
 	@Override
     public Class<?> getCommonPropertyType(ELContext context, Object base) {
-		if (base instanceof Map) {
+		if (base instanceof Map<?, ?>) {
 			return Object.class;
 		}
 		return null;

==================================================
WebServiceRef.java
index c37c2cae38..2eb3999e50 100644
--- a/java/javax/el/ResourceBundleELResolver.java
+++ b/java/javax/el/ResourceBundleELResolver.java
@@ -100,14 +100,15 @@ public class ResourceBundleELResolver extends ELResolver {
 	}
 
 	@Override
+    @SuppressWarnings("unchecked") // Can't use Iterator<FeatureDescriptor> because API needs to match specification
     public Iterator getFeatureDescriptors(ELContext context, Object base) {
 		if (base instanceof ResourceBundle) {
 			List<FeatureDescriptor> feats = new ArrayList<FeatureDescriptor>();
-			Enumeration e = ((ResourceBundle) base).getKeys();
+			Enumeration<String> e = ((ResourceBundle) base).getKeys();
 			FeatureDescriptor feat;
 			String key;
 			while (e.hasMoreElements()) {
-				key = (String) e.nextElement();
+				key = e.nextElement();
 				feat = new FeatureDescriptor();
 				feat.setDisplayName(key);
 				feat.setExpert(false);

==================================================
