68eaab30dfc7bf539caee22c5c1e709c6bb507a4
==================================================
Whitespace removal from /java/org/apache/coyote
==================================================
Mark Emlyn
==================================================
Sat Oct 22 20:59:39 2011 +0000
==================================================
AbstractProcessor.java
Whitespace removal from /java/org/apache/coyote

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1187780 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AbstractProtocol.java
index c0c168d91b..5717d7170d 100644
--- a/java/org/apache/coyote/AbstractProcessor.java
+++ b/java/org/apache/coyote/AbstractProcessor.java
@@ -36,11 +36,11 @@ public abstract class AbstractProcessor<S> implements ActionHook, Processor {
     protected final Request request;
     protected final Response response;
 
-    
+
     public AbstractProcessor(AbstractEndpoint endpoint) {
         this.endpoint = endpoint;
         asyncStateMachine = new AsyncStateMachine(this);
-        
+
         request = new Request();
 
         response = new Response();
@@ -93,8 +93,8 @@ public abstract class AbstractProcessor<S> implements ActionHook, Processor {
     public Executor getExecutor() {
         return endpoint.getExecutor();
     }
-    
-    
+
+
     public boolean isAsync() {
         return asyncStateMachine.isAsync();
     }

==================================================
ActionCode.java
index a573e88325..532cb08fae 100644
--- a/java/org/apache/coyote/AbstractProtocol.java
+++ b/java/org/apache/coyote/AbstractProtocol.java
@@ -52,13 +52,13 @@ public abstract class AbstractProtocol implements ProtocolHandler,
      */
     protected ObjectName rgOname = null;
 
-    
+
     /**
      * Name of MBean for the ThreadPool.
      */
     protected ObjectName tpOname = null;
 
-    
+
     /**
      * Endpoint that provides low-level network I/O - must be matched to the
      * ProtocolHandler implementation (ProtocolHandler using BIO, requires BIO
@@ -66,7 +66,7 @@ public abstract class AbstractProtocol implements ProtocolHandler,
      */
     protected AbstractEndpoint endpoint = null;
 
-    
+
     // ----------------------------------------------- Generic property handling
 
     /**
@@ -91,7 +91,7 @@ public abstract class AbstractProtocol implements ProtocolHandler,
 
 
     // ------------------------------- Properties managed by the ProtocolHandler
-    
+
     /**
      * The adapter provides the link between the ProtocolHandler and the
      * connector.
@@ -124,7 +124,7 @@ public abstract class AbstractProtocol implements ProtocolHandler,
      * provider is used to perform the conversion. For example it is used with
      * the AJP connectors, the HTTP APR connector and with the
      * {@link org.apache.catalina.valves.SSLValve}. If not specified, the
-     * default provider will be used. 
+     * default provider will be used.
      */
     protected String clientCertProvider = null;
     public String getClientCertProvider() { return clientCertProvider; }
@@ -144,7 +144,7 @@ public abstract class AbstractProtocol implements ProtocolHandler,
     public void setMaxThreads(int maxThreads) {
         endpoint.setMaxThreads(maxThreads);
     }
-    
+
     public int getMaxConnections() { return endpoint.getMaxConnections(); }
     public void setMaxConnections(int maxConnections) {
         endpoint.setMaxConnections(maxConnections);
@@ -236,16 +236,16 @@ public abstract class AbstractProtocol implements ProtocolHandler,
         return ObjectName.quote(name.toString());
     }
 
-    
+
     // -------------------------------------------------------- Abstract methods
-    
+
     /**
      * Concrete implementations need to provide access to their logger to be
      * used by the abstract classes.
      */
     protected abstract Log getLog();
-    
-    
+
+
     /**
      * Obtain the prefix to be used when construction a name for this protocol
      * handler. The name will be prefix-address-port.
@@ -306,7 +306,7 @@ public abstract class AbstractProtocol implements ProtocolHandler,
     private ObjectName createObjectName() throws MalformedObjectNameException {
         // Use the same domain as the connector
         domain = adapter.getDomain();
-        
+
         if (domain == null) {
             return null;
         }
@@ -446,7 +446,7 @@ public abstract class AbstractProtocol implements ProtocolHandler,
             getLog().error(sm.getString("abstractProtocolHandler.destroyError",
                     getName()), e);
         }
-        
+
         if (oname != null) {
             Registry.getRegistry(null, null).unregisterComponent(oname);
         }
@@ -456,10 +456,10 @@ public abstract class AbstractProtocol implements ProtocolHandler,
         if (rgOname != null)
             Registry.getRegistry(null, null).unregisterComponent(rgOname);
     }
-    
-    
+
+
     // ------------------------------------------- Connection handler base class
-    
+
     protected abstract static class AbstractConnectionHandler<S,P extends AbstractProcessor<S>>
             implements AbstractEndpoint.Handler {
 
@@ -473,7 +473,7 @@ public abstract class AbstractProtocol implements ProtocolHandler,
 
         protected RecycledProcessors<P,S> recycledProcessors =
             new RecycledProcessors<P,S>(this);
-        
+
 
         protected abstract AbstractProtocol getProtocol();
 
@@ -487,7 +487,7 @@ public abstract class AbstractProtocol implements ProtocolHandler,
         public void recycle() {
             recycledProcessors.clear();
         }
-        
+
 
         public SocketState process(SocketWrapper<S> socket,
                 SocketStatus status) {
@@ -514,7 +514,7 @@ public abstract class AbstractProtocol implements ProtocolHandler,
                     } else {
                         state = processor.process(socket);
                     }
-    
+
                     if (state != SocketState.CLOSED && processor.isAsync()) {
                         state = processor.asyncPostProcess();
                     }
@@ -561,7 +561,7 @@ public abstract class AbstractProtocol implements ProtocolHandler,
             release(socket, processor, true, false);
             return SocketState.CLOSED;
         }
-        
+
         protected abstract P createProcessor();
         protected abstract void initSsl(SocketWrapper<S> socket, P processor);
         protected abstract void longPoll(SocketWrapper<S> socket, P processor);
@@ -617,7 +617,7 @@ public abstract class AbstractProtocol implements ProtocolHandler,
             }
         }
     }
-    
+
     protected static class RecycledProcessors<P extends AbstractProcessor<S>, S>
             extends ConcurrentLinkedQueue<P> {
 
@@ -644,7 +644,7 @@ public abstract class AbstractProtocol implements ProtocolHandler,
             if (!result) handler.unregister(processor);
             return result;
         }
-    
+
         @Override
         public P poll() {
             P result = super.poll();
@@ -653,7 +653,7 @@ public abstract class AbstractProtocol implements ProtocolHandler,
             }
             return result;
         }
-    
+
         @Override
         public void clear() {
             P next = poll();

==================================================
ActionHook.java
index f857945045..af213ed706 100644
--- a/java/org/apache/coyote/ActionCode.java
+++ b/java/org/apache/coyote/ActionCode.java
@@ -21,7 +21,7 @@ package org.apache.coyote;
  * ActionCodes represent callbacks from the servlet container to the coyote
  * connector. Actions are implemented by ProtocolHandler, using the ActionHook
  * interface.
- * 
+ *
  * @see ProtocolHandler
  * @see ActionHook
  * @author Remy Maucherat
@@ -49,7 +49,7 @@ public enum ActionCode {
     /**
      * Hook called if swallowing request input should be disabled.
      * Example: Cancel a large file upload.
-     * 
+     *
      */
     DISABLE_SWALLOW_INPUT,
 
@@ -153,28 +153,28 @@ public enum ActionCode {
      * {@link javax.servlet.AsyncContext#complete()}
      */
     ASYNC_COMPLETE,
-    
+
     /**
      * Callback to trigger the processing of an async timeout
      */
     ASYNC_TIMEOUT,
-    
+
     /**
      * Callback to trigger the error processing
      */
     ASYNC_ERROR,
-    
+
     /**
      * Callback for an async call to
      * {@link javax.servlet.AsyncContext#setTimeout(long)}
      */
     ASYNC_SETTIMEOUT,
-    
+
     /**
-     * Callback to determine if async processing is in progress 
+     * Callback to determine if async processing is in progress
      */
     ASYNC_IS_ASYNC,
-    
+
     /**
      * Callback to determine if async dispatch is in progress
      */

==================================================
Adapter.java
index 72154947af..0fac047670 100644
--- a/java/org/apache/coyote/ActionHook.java
+++ b/java/org/apache/coyote/ActionHook.java
@@ -26,7 +26,7 @@ package org.apache.coyote;
  *
  * The param object can be used to pass and return informations related with the
  * action.
- * 
+ *
  *
  * This interface is typically implemented by ProtocolHandlers, and the param
  * is usually a Request or Response object.
@@ -38,7 +38,7 @@ public interface ActionHook {
 
     /**
      * Send an action to the connector.
-     * 
+     *
      * @param actionCode Type of the action
      * @param param Action parameter
      */

==================================================
AsyncContextCallback.java
index e9496e7f70..8992816a58 100644
--- a/java/org/apache/coyote/Adapter.java
+++ b/java/org/apache/coyote/Adapter.java
@@ -29,7 +29,7 @@ import org.apache.tomcat.util.net.SocketStatus;
  */
 public interface Adapter {
 
-    /** 
+    /**
      * Call the service method, and notify all listeners
      *
      * @exception Exception if an error happens during handling of
@@ -49,7 +49,7 @@ public interface Adapter {
 
     public boolean event(Request req, Response res, SocketStatus status)
             throws Exception;
-    
+
     public boolean asyncDispatch(Request req,Response res, SocketStatus status)
             throws Exception;
 
@@ -58,7 +58,7 @@ public interface Adapter {
     /**
      * Provide the name of the domain to use to register MBeans for conponents
      * associated with the connector.
-     * 
+     *
      * @return  The MBean domain name
      */
     public String getDomain();

==================================================
AsyncStateMachine.java
index cf20be826d..2278414a52 100644
--- a/java/org/apache/coyote/AsyncContextCallback.java
+++ b/java/org/apache/coyote/AsyncContextCallback.java
@@ -21,7 +21,7 @@ package org.apache.coyote;
  * {@link javax.servlet.AsyncContext} implementation that an action, such as
  * firing event listeners needs to be taken. It is implemented in this manner
  * so that the org.apache.coyote package does not have a dependency on the
- * org.apache.coyote package.  
+ * org.apache.coyote package.
  */
 public interface AsyncContextCallback {
     public void fireOnComplete();

==================================================
Constants.java
index 00af3a3cf6..93e58598d1 100644
--- a/java/org/apache/coyote/AsyncStateMachine.java
+++ b/java/org/apache/coyote/AsyncStateMachine.java
@@ -24,7 +24,7 @@ import org.apache.tomcat.util.res.StringManager;
 
 /**
  * Manages the state transitions for async requests.
- * 
+ *
  * <pre>
  * The internal states that are used are:
  * DISPATCHED    - Standard request. Not in Async mode.
@@ -49,40 +49,40 @@ import org.apache.tomcat.util.res.StringManager;
  * DISPATCHING   - The dispatch is being processed.
  * ERROR         - Something went wrong.
  *
- * |----------------->--------------|                                         
- * |                               \|/                                        
- * |   |----------<---------------ERROR                                    
+ * |----------------->--------------|
+ * |                               \|/
+ * |   |----------<---------------ERROR
  * |   |    complete()           /|\ |postProcess()
  * |   |                   error()|  |
  * |   |                          |  |  |--|timeout()
  * |   |           postProcess()  | \|/ | \|/            auto
  * |   |         |--------------->DISPATCHED<------------------COMPLETING<----|
- * |   |         |               /|\  |                          | /|\        | 
- * |   |         |    |--->-------|   |                          |--|         | 
+ * |   |         |               /|\  |                          | /|\        |
+ * |   |         |    |--->-------|   |                          |--|         |
  * |   |         ^    |               |startAsync()            timeout()      |
- * |   |         |    |               |                                       | 
- * |  \|/        |    |  complete()  \|/        postProcess()                 | 
- * | MUST_COMPLETE-<- | ----<------STARTING-->----------------|               ^     
- * |      /|\         |               |                       |               |         
- * |       |          |               |                       |               |         
- * |       |          ^               |dispatch()             |               |         
- * |       |          |               |                       |               |         
- * |       |          |              \|/                     \|/   complete() |         
- * |       |          |         MUST_DISPATCH              STARTED---->-------|   
- * |       |          |           |                         |   |                        
- * |       |          |           |postProcess()            |   |                        
- * ^       ^          |           |              dispatch() |   |auto                        
- * |       |          |           |    |--------------------|   |                        
- * |       |          | auto     \|/  \|/                      \|/                         
- * |       |          |---<----DISPATCHING<-----------------TIMING_OUT                              
- * |       |                                  dispatch()      |   |             
- * |       |                                                  |   |            
- * |       |-------<-------------------------------------<----|   |            
- * |                              complete()                      |            
- * |                                                              |            
- * |----<------------------------<-----------------------------<--|            
+ * |   |         |    |               |                                       |
+ * |  \|/        |    |  complete()  \|/        postProcess()                 |
+ * | MUST_COMPLETE-<- | ----<------STARTING-->----------------|               ^
+ * |      /|\         |               |                       |               |
+ * |       |          |               |                       |               |
+ * |       |          ^               |dispatch()             |               |
+ * |       |          |               |                       |               |
+ * |       |          |              \|/                     \|/   complete() |
+ * |       |          |         MUST_DISPATCH              STARTED---->-------|
+ * |       |          |           |                         |   |
+ * |       |          |           |postProcess()            |   |
+ * ^       ^          |           |              dispatch() |   |auto
+ * |       |          |           |    |--------------------|   |
+ * |       |          | auto     \|/  \|/                      \|/
+ * |       |          |---<----DISPATCHING<-----------------TIMING_OUT
+ * |       |                                  dispatch()      |   |
+ * |       |                                                  |   |
+ * |       |-------<-------------------------------------<----|   |
+ * |                              complete()                      |
+ * |                                                              |
+ * |----<------------------------<-----------------------------<--|
  *                                 error()
- * </pre>                               
+ * </pre>
  */
 public class AsyncStateMachine {
 
@@ -102,38 +102,38 @@ public class AsyncStateMachine {
         MUST_DISPATCH(true, false, true),
         DISPATCHING(true, false, true),
         ERROR(true,false,false);
-    
+
         private boolean isAsync;
         private boolean isStarted;
         private boolean isDispatching;
-        
+
         private AsyncState(boolean isAsync, boolean isStarted,
                 boolean isDispatching) {
             this.isAsync = isAsync;
             this.isStarted = isStarted;
             this.isDispatching = isDispatching;
         }
-        
+
         public boolean isAsync() {
             return this.isAsync;
         }
-        
+
         public boolean isStarted() {
             return this.isStarted;
         }
-        
+
         public boolean isDispatching() {
             return this.isDispatching;
         }
     }
-    
+
 
     private volatile AsyncState state = AsyncState.DISPATCHED;
     // Need this to fire listener on complete
     private AsyncContextCallback asyncCtxt = null;
     private Processor processor;
-    
-    
+
+
     public AsyncStateMachine(Processor processor) {
         this.processor = processor;
     }
@@ -166,14 +166,14 @@ public class AsyncStateMachine {
                             "asyncStart()", state));
         }
     }
-    
+
     /*
      * Async has been processed. Whether or not to enter a long poll depends on
      * current state. For example, as per SRV.2.3.3.3 can now process calls to
      * complete() or dispatch().
      */
     public synchronized SocketState asyncPostProcess() {
-        
+
         if (state == AsyncState.STARTING) {
             state = AsyncState.STARTED;
             return SocketState.LONG;
@@ -204,11 +204,11 @@ public class AsyncStateMachine {
                             "asyncPostProcess()", state));
         }
     }
-    
+
 
     public synchronized boolean asyncComplete() {
         boolean doComplete = false;
-        
+
         if (state == AsyncState.STARTING) {
             state = AsyncState.MUST_COMPLETE;
         } else if (state == AsyncState.STARTED) {
@@ -221,12 +221,12 @@ public class AsyncStateMachine {
             throw new IllegalStateException(
                     sm.getString("asyncStateMachine.invalidAsyncState",
                             "asyncComplete()", state));
-            
+
         }
         return doComplete;
     }
-    
-    
+
+
     public synchronized boolean asyncTimeout() {
         if (state == AsyncState.STARTED) {
             state = AsyncState.TIMING_OUT;
@@ -242,8 +242,8 @@ public class AsyncStateMachine {
                             "asyncTimeout()", state));
         }
     }
-    
-    
+
+
     public synchronized boolean asyncDispatch() {
         boolean doDispatch = false;
         if (state == AsyncState.STARTING) {
@@ -259,8 +259,8 @@ public class AsyncStateMachine {
         }
         return doDispatch;
     }
-    
-    
+
+
     public synchronized void asyncDispatched() {
         if (state == AsyncState.DISPATCHING) {
             state = AsyncState.DISPATCHED;
@@ -270,8 +270,8 @@ public class AsyncStateMachine {
                             "asyncDispatched()", state));
         }
     }
-    
-    
+
+
     public synchronized boolean asyncError() {
         boolean doDispatch = false;
         if (state == AsyncState.DISPATCHED ||
@@ -284,7 +284,7 @@ public class AsyncStateMachine {
         }
         return doDispatch;
     }
-    
+
     public synchronized void asyncRun(Runnable runnable) {
         if (state == AsyncState.STARTING || state ==  AsyncState.STARTED) {
             // Execute the runnable using a container thread from the
@@ -305,7 +305,7 @@ public class AsyncStateMachine {
                     Thread.currentThread().setContextClassLoader(
                             this.getClass().getClassLoader());
                 }
-                
+
                 processor.getExecutor().execute(runnable);
             } finally {
                 if (Constants.IS_SECURITY_ENABLED) {
@@ -323,14 +323,14 @@ public class AsyncStateMachine {
         }
 
     }
-    
-    
+
+
     public synchronized void recycle() {
         asyncCtxt = null;
         state = AsyncState.DISPATCHED;
     }
-    
-    
+
+
     private static class PrivilegedSetTccl implements PrivilegedAction<Void> {
 
         private ClassLoader cl;

==================================================
InputBuffer.java
index 0b4bcc023c..fda206c9fe 100644
--- a/java/org/apache/coyote/Constants.java
+++ b/java/org/apache/coyote/Constants.java
@@ -28,7 +28,7 @@ public final class Constants {
     // -------------------------------------------------------------- Constants
 
     public static final String Package = "org.apache.coyote";
-    
+
     public static final String DEFAULT_CHARACTER_ENCODING="ISO-8859-1";
 
     public static final int MAX_NOTES = 32;

==================================================
OutputBuffer.java
index d3bd3bfb2b..f84982e5eb 100644
--- a/java/org/apache/coyote/InputBuffer.java
+++ b/java/org/apache/coyote/InputBuffer.java
@@ -28,7 +28,7 @@ import org.apache.tomcat.util.buf.ByteChunk;
  * This class is used only in the protocol implementation. All reading from
  * Tomcat ( or adapter ) should be done using Request.doRead().
  *
- * 
+ *
  * @author Remy Maucherat
  */
 public interface InputBuffer {
@@ -39,7 +39,7 @@ public interface InputBuffer {
         buffer and return a pointer to it in ByteChunk ( i.e. the param will
         have chunk.getBytes()==null before call, and the result after the call ).
     */
-    public int doRead(ByteChunk chunk, Request request) 
+    public int doRead(ByteChunk chunk, Request request)
         throws IOException;
 
 

==================================================
RequestInfo.java
index 2dfb588056..74c6776a5c 100644
--- a/java/org/apache/coyote/OutputBuffer.java
+++ b/java/org/apache/coyote/OutputBuffer.java
@@ -27,7 +27,7 @@ import org.apache.tomcat.util.buf.ByteChunk;
  *
  * This class is used internally by the protocol implementation. All writes from
  * higher level code should happen via Resonse.doWrite().
- * 
+ *
  * @author Remy Maucherat
  */
 public interface OutputBuffer {
@@ -47,7 +47,7 @@ public interface OutputBuffer {
     /**
      * Bytes written to the underlying socket. This includes the effects of
      * chunking, compression, etc.
-     * 
+     *
      * @return  Bytes written for the current request
      */
     public long getBytesWritten();

==================================================
Response.java
index c142cf65ae..4f6b7628fc 100644
--- a/java/org/apache/coyote/RequestInfo.java
+++ b/java/org/apache/coyote/RequestInfo.java
@@ -46,14 +46,14 @@ public class RequestInfo  {
     public RequestGroupInfo getGlobalProcessor() {
         return global;
     }
-    
+
     public void setGlobalProcessor(RequestGroupInfo global) {
         if( global != null) {
             this.global=global;
             global.addRequestProcessor( this );
         } else {
             if (this.global != null) {
-                this.global.removeRequestProcessor( this ); 
+                this.global.removeRequestProcessor( this );
                 this.global = null;
             }
         }
@@ -130,7 +130,7 @@ public class RequestInfo  {
     private int requestCount;
     // number of response codes >= 400
     private int errorCount;
-    
+
     //the time of the last request
     private long lastRequestProcessingTime = 0;
 

==================================================
AbstractAjpProcessor.java
index 88f1bbd03f..fe560c4993 100644
--- a/java/org/apache/coyote/Response.java
+++ b/java/org/apache/coyote/Response.java
@@ -25,7 +25,7 @@ import org.apache.tomcat.util.http.MimeHeaders;
 
 /**
  * Response object.
- * 
+ *
  * @author James Duncan Davidson [duncan@eng.sun.com]
  * @author Jason Hunter [jch@eng.sun.com]
  * @author James Todd [gonzo@eng.sun.com]
@@ -164,7 +164,7 @@ public final class Response {
 
     public void action(ActionCode actionCode, Object param) {
         if (hook != null) {
-            if( param==null ) 
+            if( param==null )
                 hook.action(actionCode, this);
             else
                 hook.action(actionCode, param);
@@ -179,10 +179,10 @@ public final class Response {
         return status;
     }
 
-    
-    /** 
-     * Set the response status 
-     */ 
+
+    /**
+     * Set the response status
+     */
     public void setStatus( int status ) {
         this.status = status;
     }
@@ -217,7 +217,7 @@ public final class Response {
     // -----------------Error State --------------------
 
 
-    /** 
+    /**
      * Set the error Exception that occurred during
      * request processing.
      */
@@ -226,7 +226,7 @@ public final class Response {
     }
 
 
-    /** 
+    /**
      * Get the Exception that occurred during request
      * processing.
      */
@@ -241,11 +241,11 @@ public final class Response {
 
 
     // -------------------- Methods --------------------
-    
-    
-    public void reset() 
+
+
+    public void reset()
         throws IllegalStateException {
-        
+
         // Reset the headers only if this is the main request,
         // not for included
         contentType = null;
@@ -258,16 +258,16 @@ public final class Response {
         status = 200;
         message = null;
         headers.clear();
-        
+
         // Force the PrintWriter to flush its data to the output
         // stream before resetting the output stream
         //
         // Reset the stream
         if (commited) {
-            //String msg = sm.getString("servletOutputStreamImpl.reset.ise"); 
+            //String msg = sm.getString("servletOutputStreamImpl.reset.ise");
             throw new IllegalStateException();
         }
-        
+
         action(ActionCode.RESET, this);
     }
 
@@ -311,9 +311,9 @@ public final class Response {
         headers.addValue(name).setString( value );
     }
 
-    
-    /** 
-     * Set internal fields for special header names. 
+
+    /**
+     * Set internal fields for special header names.
      * Called from set/addHeader.
      * Return true if the header is special, no need to set the header.
      */
@@ -330,7 +330,7 @@ public final class Response {
                 setContentLength( cL );
                 return true;
             } catch( NumberFormatException ex ) {
-                // Do nothing - the spec doesn't have any "throws" 
+                // Do nothing - the spec doesn't have any "throws"
                 // and the user might know what he's doing
                 return false;
             }
@@ -418,7 +418,7 @@ public final class Response {
     /**
      * Sets the content type.
      *
-     * This method must preserve any response charset that may already have 
+     * This method must preserve any response charset that may already have
      * been set via a call to response.setContentType(), response.setLocale(),
      * or response.setCharacterEncoding().
      *
@@ -493,7 +493,7 @@ public final class Response {
 
         String ret = contentType;
 
-        if (ret != null 
+        if (ret != null
             && characterEncoding != null
             && charsetSet) {
             ret = ret + ";charset=" + characterEncoding;
@@ -501,7 +501,7 @@ public final class Response {
 
         return ret;
     }
-    
+
     public void setContentLength(int contentLength) {
         this.contentLength = contentLength;
     }
@@ -512,19 +512,19 @@ public final class Response {
 
     public int getContentLength() {
         long length = getContentLengthLong();
-        
+
         if (length < Integer.MAX_VALUE) {
             return (int) length;
         }
         return -1;
     }
-    
+
     public long getContentLengthLong() {
         return contentLength;
     }
 
 
-    /** 
+    /**
      * Write a chunk of bytes.
      */
     public void doWrite(ByteChunk chunk/*byte buffer[], int pos, int count*/)
@@ -535,9 +535,9 @@ public final class Response {
     }
 
     // --------------------
-    
+
     public void recycle() {
-        
+
         contentType = null;
         contentLanguage = null;
         locale = DEFAULT_LOCALE;
@@ -560,7 +560,7 @@ public final class Response {
     public long getContentWritten() {
         return contentWritten;
     }
-    
+
     /**
      * Bytes written to socket - i.e. after compression, chunking, etc.
      */

==================================================
AbstractAjpProtocol.java
index 056c6caa5e..b9f9122d89 100644
--- a/java/org/apache/coyote/ajp/AbstractAjpProcessor.java
+++ b/java/org/apache/coyote/ajp/AbstractAjpProcessor.java
@@ -118,7 +118,7 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
         pongMessage.appendByte(Constants.JK_AJP13_CPONG_REPLY);
         pongMessage.end();
         pongMessageArray = new byte[pongMessage.getLen()];
-        System.arraycopy(pongMessage.getBuffer(), 0, pongMessageArray, 
+        System.arraycopy(pongMessage.getBuffer(), 0, pongMessageArray,
                 0, pongMessage.getLen());
     }
 
@@ -248,7 +248,7 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
                 Constants.MAX_PACKET_SIZE);
         getBodyMessage.end();
         getBodyMessageArray = new byte[getBodyMessage.getLen()];
-        System.arraycopy(getBodyMessage.getBuffer(), 0, getBodyMessageArray, 
+        System.arraycopy(getBodyMessage.getBuffer(), 0, getBodyMessageArray,
                 0, getBodyMessage.getLen());
     }
 
@@ -292,7 +292,7 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
      * provider is used to perform the conversion. For example it is used with
      * the AJP connectors, the HTTP APR connector and with the
      * {@link org.apache.catalina.valves.SSLValve}. If not specified, the
-     * default provider will be used. 
+     * default provider will be used.
      */
     protected String clientCertProvider = null;
     public String getClientCertProvider() { return clientCertProvider; }
@@ -512,7 +512,7 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
     /**
      * Recycle the processor, ready for the next request which may be on the
      * same connection or a different connection.
-     * 
+     *
      * @param socketClosing Indicates if the socket is about to be closed
      *                      allowing the processor to perform any additional
      *                      clean-up that may be required
@@ -963,7 +963,7 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
         }
     }
 
-    
+
     /**
      * Finish AJP response.
      */

==================================================
AjpAprProcessor.java
index d479b3b2d9..d1515f64e0 100644
--- a/java/org/apache/coyote/ajp/AbstractAjpProtocol.java
+++ b/java/org/apache/coyote/ajp/AbstractAjpProtocol.java
@@ -21,7 +21,7 @@ import org.apache.tomcat.util.net.SocketWrapper;
 import org.apache.tomcat.util.res.StringManager;
 
 public abstract class AbstractAjpProtocol extends AbstractProtocol {
-    
+
     /**
      * The string manager for this package.
      */
@@ -38,9 +38,9 @@ public abstract class AbstractAjpProtocol extends AbstractProtocol {
 
     // ------------------------------------------------- AJP specific properties
     // ------------------------------------------ managed in the ProtocolHandler
-    
+
     /**
-     * Should authentication be done in the native webserver layer, 
+     * Should authentication be done in the native webserver layer,
      * or in the Servlet container ?
      */
     protected boolean tomcatAuthentication = true;
@@ -71,7 +71,7 @@ public abstract class AbstractAjpProtocol extends AbstractProtocol {
             this.packetSize = packetSize;
         }
     }
-    
+
     protected abstract static class AbstractAjpConnectionHandler<S,P extends AbstractAjpProcessor<S>>
             extends AbstractConnectionHandler<S, P> {
 

==================================================
AjpAprProtocol.java
index eca67e10ac..2ef6da724d 100644
--- a/java/org/apache/coyote/ajp/AjpAprProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpAprProcessor.java
@@ -283,9 +283,9 @@ public class AjpAprProcessor extends AbstractAjpProcessor<Long> {
     protected void output(byte[] src, int offset, int length)
             throws IOException {
         outputBuffer.put(src, offset, length);
-        
+
         long socketRef = socket.getSocket().longValue();
-        
+
         if (outputBuffer.position() > 0) {
             if ((socketRef != 0) && Socket.sendbb(socketRef, 0, outputBuffer.position()) < 0) {
                 throw new IOException(sm.getString("ajpprocessor.failedsend"));

==================================================
AjpMessage.java
index aa873d8f06..96f066b786 100644
--- a/java/org/apache/coyote/ajp/AjpAprProtocol.java
+++ b/java/org/apache/coyote/ajp/AjpAprProtocol.java
@@ -34,8 +34,8 @@ import org.apache.tomcat.util.net.SocketWrapper;
  * @author Costin Manolache
  */
 public class AjpAprProtocol extends AbstractAjpProtocol {
-    
-    
+
+
     private static final Log log = LogFactory.getLog(AjpAprProtocol.class);
 
     @Override
@@ -62,7 +62,7 @@ public class AjpAprProtocol extends AbstractAjpProtocol {
         ((AprEndpoint) endpoint).setUseSendfile(false);
     }
 
-    
+
     // ----------------------------------------------------- Instance Variables
 
 

==================================================
AjpNioProcessor.java
index 8986955a05..f67bf5da4d 100644
--- a/java/org/apache/coyote/ajp/AjpMessage.java
+++ b/java/org/apache/coyote/ajp/AjpMessage.java
@@ -30,7 +30,7 @@ import org.apache.tomcat.util.res.StringManager;
  * container.  Designed to be reused many times with no creation of
  * garbage.  Understands the format of data types for these packets.
  * Can be used (somewhat confusingly) for both incoming and outgoing
- * packets.  
+ * packets.
  *
  * @author Henri Gomez
  * @author Dan Milstein
@@ -52,11 +52,11 @@ public class AjpMessage {
 
     // ------------------------------------------------------------ Constructor
 
-    
+
     public AjpMessage(int packetSize) {
         buf = new byte[packetSize];
     }
-    
+
 
     // ----------------------------------------------------- Instance Variables
 
@@ -79,9 +79,9 @@ public class AjpMessage {
      * payload (excluding the header).  For write, it's the length of
      * the packet as a whole (counting the header).  Oh, well.
      */
-    protected int len; 
+    protected int len;
+
 
-    
     // --------------------------------------------------------- Public Methods
 
 
@@ -99,7 +99,7 @@ public class AjpMessage {
     /**
      * For a packet to be sent to the web server, finish the process of
      * accumulating data and write the length of the data payload into
-     * the header.  
+     * the header.
      */
     public void end() {
         len = pos;
@@ -128,7 +128,7 @@ public class AjpMessage {
     public int getLen() {
         return len;
     }
-    
+
 
     /**
      * Add a short integer (2 bytes) to the message.
@@ -146,14 +146,14 @@ public class AjpMessage {
         buf[pos++] = (byte) val;
     }
 
-    
+
     /**
      * Write a MessageBytes out at the current write position.
-     * A null MessageBytes is encoded as a string with length 0.  
+     * A null MessageBytes is encoded as a string with length 0.
      */
     public void appendBytes(MessageBytes mb) {
         if (mb == null) {
-            log.error(sm.getString("ajpmessage.null"), 
+            log.error(sm.getString("ajpmessage.null"),
                     new NullPointerException());
             appendInt(0);
             appendByte(0);
@@ -170,14 +170,14 @@ public class AjpMessage {
         }
     }
 
-    
+
     /**
      * Write a ByteChunk out at the current write position.
-     * A null ByteChunk is encoded as a string with length 0.  
+     * A null ByteChunk is encoded as a string with length 0.
      */
     public void appendByteChunk(ByteChunk bc) {
         if (bc == null) {
-            log.error(sm.getString("ajpmessage.null"), 
+            log.error(sm.getString("ajpmessage.null"),
                     new NullPointerException());
             appendInt(0);
             appendByte(0);
@@ -186,14 +186,14 @@ public class AjpMessage {
         appendBytes(bc.getBytes(), bc.getStart(), bc.getLength());
     }
 
-    
+
     /**
      * Write a CharChunk out at the current write position.
-     * A null CharChunk is encoded as a string with length 0.  
+     * A null CharChunk is encoded as a string with length 0.
      */
     public void appendCharChunk(CharChunk cc) {
         if (cc == null) {
-            log.error(sm.getString("ajpmessage.null"), 
+            log.error(sm.getString("ajpmessage.null"),
                     new NullPointerException());
             appendInt(0);
             appendByte(0);
@@ -219,18 +219,18 @@ public class AjpMessage {
         appendByte(0);
     }
 
-    
+
     /**
      * Write a String out at the current write position.  Strings are
      * encoded with the length in two bytes first, then the string, and
      * then a terminating \0 (which is <B>not</B> included in the
      * encoded length).  The terminator is for the convenience of the C
      * code, where it saves a round of copying.  A null string is
-     * encoded as a string with length 0.  
+     * encoded as a string with length 0.
      */
     public void appendString(String str) {
         if (str == null) {
-            log.error(sm.getString("ajpmessage.null"), 
+            log.error(sm.getString("ajpmessage.null"),
                     new NullPointerException());
             appendInt(0);
             appendByte(0);
@@ -254,8 +254,8 @@ public class AjpMessage {
         appendByte(0);
     }
 
-    
-    /** 
+
+    /**
      * Copy a chunk of bytes into the packet, starting at the current
      * write position.  The chunk of bytes is encoded with the length
      * in two bytes first, then the data itself, and finally a
@@ -264,7 +264,7 @@ public class AjpMessage {
      *
      * @param b The array from which to copy bytes.
      * @param off The offset into the array at which to start copying
-     * @param numBytes The number of bytes to copy.  
+     * @param numBytes The number of bytes to copy.
      */
     public void appendBytes(byte[] b, int off, int numBytes) {
         if (pos + numBytes + 3 > buf.length) {
@@ -281,12 +281,12 @@ public class AjpMessage {
         appendByte(0);
     }
 
-    
+
     /**
      * Read an integer from packet, and advance the read position past
      * it.  Integers are encoded as two unsigned bytes with the
      * high-order byte first, and, as far as I can tell, in
-     * little-endian order within each byte.  
+     * little-endian order within each byte.
      */
     public int getInt() {
         int b1 = buf[pos++] & 0xFF;
@@ -303,22 +303,22 @@ public class AjpMessage {
         return (b1<<8) + b2;
     }
 
-    
+
     public byte getByte() {
         byte res = buf[pos++];
         validatePos(pos);
         return res;
     }
 
-    
+
     public void getBytes(MessageBytes mb) {
         doGetBytes(mb, true);
     }
-    
+
     public void getBodyBytes(MessageBytes mb) {
         doGetBytes(mb, false);
     }
-    
+
     private void doGetBytes(MessageBytes mb, boolean terminated) {
         int length = getInt();
         if ((length == 0xFFFF) || (length == -1)) {
@@ -337,8 +337,8 @@ public class AjpMessage {
             pos++; // Skip the terminating \0
         }
     }
-    
-    
+
+
     /**
      * Read a 32 bits integer from packet, and advance the read position past
      * it.  Integers are encoded as four unsigned bytes with the
@@ -362,12 +362,12 @@ public class AjpMessage {
         return 4;
     }
 
-    
+
     public int getPacketSize() {
         return buf.length;
     }
-    
-    
+
+
     public int processHeader(boolean toContainer) {
         pos = 0;
         int mark = getInt();
@@ -386,7 +386,7 @@ public class AjpMessage {
         }
         return len;
     }
-    
+
 
     /**
      * Dump the contents of the message, prefixed with the given String.
@@ -401,7 +401,7 @@ public class AjpMessage {
         if (max > 1000)
             max = 1000;
         if (log.isDebugEnabled()) {
-            for (int j = 0; j < max; j += 16) { 
+            for (int j = 0; j < max; j += 16) {
                 log.debug(hexLine(buf, j, len));
             }
         }
@@ -410,7 +410,7 @@ public class AjpMessage {
 
     private void validatePos(int posToTest) {
         if (posToTest > len + 4) {
-            // Trying to read data beyond the end of the AJP message 
+            // Trying to read data beyond the end of the AJP message
             throw new ArrayIndexOutOfBoundsException(sm.getString(
                     "ajpMessage.invalidPos", Integer.valueOf(posToTest)));
         }
@@ -423,7 +423,7 @@ public class AjpMessage {
         for (int i = start; i < start + 16 ; i++) {
             if (i < len + 4) {
                 sb.append(hex(buf[i]) + " ");
-            } else { 
+            } else {
                 sb.append("   ");
             }
         }

==================================================
AjpNioProtocol.java
index 29f5135138..ff537dddae 100644
--- a/java/org/apache/coyote/ajp/AjpNioProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpNioProcessor.java
@@ -72,7 +72,7 @@ public class AjpNioProcessor extends AbstractAjpProcessor<NioChannel> {
      */
     protected NioChannel socket;
 
-    
+
     /**
      * Selector pool for the associated endpoint.
      */
@@ -96,7 +96,7 @@ public class AjpNioProcessor extends AbstractAjpProcessor<NioChannel> {
 
         // Setting up the socket
         this.socket = socket.getSocket();
-        
+
         long soTimeout = endpoint.getSoTimeout();
         boolean cping = false;
 
@@ -279,9 +279,9 @@ public class AjpNioProcessor extends AbstractAjpProcessor<NioChannel> {
         ByteBuffer writeBuffer = socket.getBufHandler() .getWriteBuffer();
 
         writeBuffer.put(src, offset, length);
-        
+
         writeBuffer.flip();
-        
+
         NioEndpoint.KeyAttachment att = (NioEndpoint.KeyAttachment)socket.getAttachment(false);
         if ( att == null ) throw new IOException("Key must be cancelled");
         long writeTimeout = att.getTimeout();
@@ -294,7 +294,7 @@ public class AjpNioProcessor extends AbstractAjpProcessor<NioChannel> {
         try {
             pool.write(writeBuffer, socket, selector, writeTimeout, true,
                     null);
-        }finally { 
+        }finally {
             if ( selector != null ) pool.put(selector);
         }
         writeBuffer.clear();
@@ -310,7 +310,7 @@ public class AjpNioProcessor extends AbstractAjpProcessor<NioChannel> {
         int read = 0;
         int res = 0;
         boolean block = blockFirstRead;
-        
+
         while (read < n) {
             res = readSocket(buf, read + pos, n, block);
             if (res > 0) {
@@ -343,7 +343,7 @@ public class AjpNioProcessor extends AbstractAjpProcessor<NioChannel> {
                 nRead = pool.read(socket.getBufHandler().getReadBuffer(),socket,selector,att.getTimeout());
             } catch ( EOFException eof ) {
                 nRead = -1;
-            } finally { 
+            } finally {
                 if ( selector != null ) pool.put(selector);
             }
         } else {
@@ -372,7 +372,7 @@ public class AjpNioProcessor extends AbstractAjpProcessor<NioChannel> {
 
         first = false;
         bodyMessage.reset();
-        
+
         readMessage(bodyMessage, true);
 
         // No data received.
@@ -409,7 +409,7 @@ public class AjpNioProcessor extends AbstractAjpProcessor<NioChannel> {
         if (bytesRead == 0) {
             return 0;
         }
-        
+
         int messageLength = message.processHeader(true);
         if (messageLength < 0) {
             // Invalid AJP header signature

==================================================
AjpProcessor.java
index 0e217af85b..f17a77eef5 100644
--- a/java/org/apache/coyote/ajp/AjpNioProtocol.java
+++ b/java/org/apache/coyote/ajp/AjpNioProtocol.java
@@ -36,8 +36,8 @@ import org.apache.tomcat.util.net.SocketWrapper;
  * will not fit Jk protocols like JNI.
  */
 public class AjpNioProtocol extends AbstractAjpProtocol {
-    
-    
+
+
     private static final Log log = LogFactory.getLog(AjpNioProtocol.class);
 
     @Override
@@ -64,7 +64,7 @@ public class AjpNioProtocol extends AbstractAjpProtocol {
         ((NioEndpoint) endpoint).setUseSendfile(false);
     }
 
-    
+
     // ----------------------------------------------------- Instance Variables
 
 
@@ -117,7 +117,7 @@ public class AjpNioProtocol extends AbstractAjpProtocol {
          */
         @Override
         public void release(SocketChannel socket) {
-            if (log.isDebugEnabled()) 
+            if (log.isDebugEnabled())
                 log.debug("Iterating through our connections to release a socket channel:"+socket);
             boolean released = false;
             Iterator<java.util.Map.Entry<NioChannel, AjpNioProcessor>> it = connections.entrySet().iterator();
@@ -132,10 +132,10 @@ public class AjpNioProtocol extends AbstractAjpProtocol {
                     break;
                 }
             }
-            if (log.isDebugEnabled()) 
+            if (log.isDebugEnabled())
                 log.debug("Done iterating through our connections to release a socket channel:"+socket +" released:"+released);
         }
-        
+
         /**
          * Expected to be used by the Poller to release resources on socket
          * close, errors etc.

==================================================
AjpProtocol.java
index 5998989d21..ca8016d92e 100644
--- a/java/org/apache/coyote/ajp/AjpProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpProcessor.java
@@ -75,18 +75,18 @@ public class AjpProcessor extends AbstractAjpProcessor<Socket> {
      */
     protected SocketWrapper<Socket> socket;
 
-    
+
     /**
      * Input stream.
      */
     protected InputStream input;
-    
-    
+
+
     /**
      * Output stream.
      */
     protected OutputStream output;
-    
+
 
     // --------------------------------------------------------- Public Methods
 
@@ -209,7 +209,7 @@ public class AjpProcessor extends AbstractAjpProcessor<Socket> {
                     error = true;
                 }
             }
-            
+
             if (isAsync() && !error) {
                 break;
             }
@@ -234,7 +234,7 @@ public class AjpProcessor extends AbstractAjpProcessor<Socket> {
             rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);
             recycle(false);
         }
-        
+
         rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
 
         if (isAsync() && !error && !endpoint.isPaused()) {
@@ -244,7 +244,7 @@ public class AjpProcessor extends AbstractAjpProcessor<Socket> {
             output = null;
             return SocketState.CLOSED;
         }
-        
+
     }
 
     @Override
@@ -313,7 +313,7 @@ public class AjpProcessor extends AbstractAjpProcessor<Socket> {
                 throw new IOException(sm.getString("ajpprotocol.failedread"));
             }
         }
-        
+
         return true;
 
     }

==================================================
Constants.java
index 0e55782635..9f302a954f 100644
--- a/java/org/apache/coyote/ajp/AjpProtocol.java
+++ b/java/org/apache/coyote/ajp/AjpProtocol.java
@@ -37,8 +37,8 @@ import org.apache.tomcat.util.net.SocketWrapper;
  * @author Costin Manolache
  */
 public class AjpProtocol extends AbstractAjpProtocol {
-    
-    
+
+
     private static final Log log = LogFactory.getLog(AjpProtocol.class);
 
     @Override
@@ -63,10 +63,10 @@ public class AjpProtocol extends AbstractAjpProtocol {
         setTcpNoDelay(Constants.DEFAULT_TCP_NO_DELAY);
     }
 
-    
+
     // ----------------------------------------------------- Instance Variables
 
-    
+
     /**
      * Connection handler for AJP.
      */
@@ -93,7 +93,7 @@ public class AjpProtocol extends AbstractAjpProtocol {
         public AjpConnectionHandler(AjpProtocol proto) {
             this.proto = proto;
         }
-        
+
         @Override
         protected AbstractProtocol getProtocol() {
             return proto;
@@ -113,7 +113,7 @@ public class AjpProtocol extends AbstractAjpProtocol {
         /**
          * Expected to be used by the handler once the processor is no longer
          * required.
-         * 
+         *
          * @param socket            Ignored for BIO
          * @param processor
          * @param isSocketClosing

==================================================
AbstractHttp11JsseProtocol.java
index c00a79d06f..d40a7e5543 100644
--- a/java/org/apache/coyote/ajp/LocalStrings.properties
+++ b/java/org/apache/coyote/ajp/LocalStrings.properties
@@ -15,7 +15,7 @@
 
 # $Id$
 
-# language 
+# language
 
 # package org.apache.coyote.ajp
 

==================================================
AbstractHttp11Protocol.java
index 8cf49f65cd..47d1baeaba 100644
--- a/java/org/apache/coyote/http11/AbstractHttp11JsseProtocol.java
+++ b/java/org/apache/coyote/http11/AbstractHttp11JsseProtocol.java
@@ -25,7 +25,7 @@ public abstract class AbstractHttp11JsseProtocol
 
     public String getAlgorithm() { return endpoint.getAlgorithm();}
     public void setAlgorithm(String s ) { endpoint.setAlgorithm(s);}
-    
+
     public String getClientAuth() { return endpoint.getClientAuth();}
     public void setClientAuth(String s ) { endpoint.setClientAuth(s);}
 
@@ -34,7 +34,7 @@ public abstract class AbstractHttp11JsseProtocol
 
     public String getKeystorePass() { return endpoint.getKeystorePass();}
     public void setKeystorePass(String s ) { endpoint.setKeystorePass(s);}
-    
+
     public String getKeystoreType() { return endpoint.getKeystoreType();}
     public void setKeystoreType(String s ) { endpoint.setKeystoreType(s);}
 
@@ -47,7 +47,7 @@ public abstract class AbstractHttp11JsseProtocol
 
     public String getSslProtocol() { return endpoint.getSslProtocol();}
     public void setSslProtocol(String s) { endpoint.setSslProtocol(s);}
-    
+
     public String getCiphers() { return endpoint.getCiphers();}
     public void setCiphers(String s) { endpoint.setCiphers(s);}
 
@@ -56,7 +56,7 @@ public abstract class AbstractHttp11JsseProtocol
 
     public String getKeyPass() { return endpoint.getKeyPass();}
     public void setKeyPass(String s ) { endpoint.setKeyPass(s);}
-    
+
     public void setTruststoreFile(String f){ endpoint.setTruststoreFile(f);}
     public String getTruststoreFile(){ return endpoint.getTruststoreFile();}
 
@@ -79,23 +79,23 @@ public abstract class AbstractHttp11JsseProtocol
     public String getTruststoreAlgorithm(){
         return endpoint.getTruststoreAlgorithm();
     }
-    
+
     public void setTrustMaxCertLength(String s){
         endpoint.setTrustMaxCertLength(s);
     }
     public String getTrustMaxCertLength(){
         return endpoint.getTrustMaxCertLength();
     }
-    
+
     public void setCrlFile(String s){endpoint.setCrlFile(s);}
     public String getCrlFile(){ return endpoint.getCrlFile();}
-    
+
     public void setSessionCacheSize(String s){endpoint.setSessionCacheSize(s);}
     public String getSessionCacheSize(){ return endpoint.getSessionCacheSize();}
 
     public void setSessionTimeout(String s){endpoint.setSessionTimeout(s);}
     public String getSessionTimeout(){ return endpoint.getSessionTimeout();}
-    
+
     public void setAllowUnsafeLegacyRenegotiation(String s) {
         endpoint.setAllowUnsafeLegacyRenegotiation(s);
     }

==================================================
AbstractInputBuffer.java
index 85b8371d03..797ab08e22 100644
--- a/java/org/apache/coyote/http11/AbstractHttp11Protocol.java
+++ b/java/org/apache/coyote/http11/AbstractHttp11Protocol.java
@@ -44,7 +44,7 @@ public abstract class AbstractHttp11Protocol extends AbstractProtocol {
         this.socketBuffer = socketBuffer;
     }
 
-    
+
     /**
      * Maximum size of the post which will be saved when processing certain
      * requests, such as a POST.
@@ -52,7 +52,7 @@ public abstract class AbstractHttp11Protocol extends AbstractProtocol {
     private int maxSavePostSize = 4 * 1024;
     public int getMaxSavePostSize() { return maxSavePostSize; }
     public void setMaxSavePostSize(int valueI) { maxSavePostSize = valueI; }
-    
+
 
     /**
      * Maximum size of the HTTP message header.
@@ -61,10 +61,10 @@ public abstract class AbstractHttp11Protocol extends AbstractProtocol {
     public int getMaxHttpHeaderSize() { return maxHttpHeaderSize; }
     public void setMaxHttpHeaderSize(int valueI) { maxHttpHeaderSize = valueI; }
 
-    
+
     /**
      * Specifies a different (usually  longer) connection timeout during data
-     * upload. 
+     * upload.
      */
     private int connectionUploadTimeout = 300000;
     public int getConnectionUploadTimeout() { return connectionUploadTimeout; }
@@ -159,25 +159,25 @@ public abstract class AbstractHttp11Protocol extends AbstractProtocol {
      */
     private boolean secure;
     public boolean getSecure() { return secure; }
-    public void setSecure(boolean b) { 
-        secure = b;         
+    public void setSecure(boolean b) {
+        secure = b;
     }
-    
+
 
     // ------------------------------------------------ HTTP specific properties
     // ------------------------------------------ passed through to the EndPoint
-    
+
     public boolean isSSLEnabled() { return endpoint.isSSLEnabled();}
     public void setSSLEnabled(boolean SSLEnabled) {
         endpoint.setSSLEnabled(SSLEnabled);
-    }    
+    }
 
 
     /**
-     * Maximum number of requests which can be performed over a keepalive 
+     * Maximum number of requests which can be performed over a keepalive
      * connection. The default is the same as for Apache HTTP Server.
      */
-    public int getMaxKeepAliveRequests() { 
+    public int getMaxKeepAliveRequests() {
         return endpoint.getMaxKeepAliveRequests();
     }
     public void setMaxKeepAliveRequests(int mkar) {

==================================================
AbstractOutputBuffer.java
index dfa747bf12..88fcd4972b 100644
--- a/java/org/apache/coyote/http11/AbstractInputBuffer.java
+++ b/java/org/apache/coyote/http11/AbstractInputBuffer.java
@@ -172,7 +172,7 @@ public abstract class AbstractInputBuffer<S> implements InputBuffer{
 
         // FIXME: Check for null ?
 
-        InputFilter[] newFilterLibrary = 
+        InputFilter[] newFilterLibrary =
             new InputFilter[filterLibrary.length + 1];
         for (int i = 0; i < filterLibrary.length; i++) {
             newFilterLibrary[i] = filterLibrary[i];
@@ -227,10 +227,10 @@ public abstract class AbstractInputBuffer<S> implements InputBuffer{
 
     public abstract boolean parseRequestLine(boolean useAvailableDataOnly)
         throws IOException;
-    
+
     public abstract boolean parseHeaders() throws IOException;
-    
-    protected abstract boolean fill(boolean block) throws IOException; 
+
+    protected abstract boolean fill(boolean block) throws IOException;
 
     protected abstract void init(SocketWrapper<S> socketWrapper,
             AbstractEndpoint endpoint) throws IOException;
@@ -240,7 +240,7 @@ public abstract class AbstractInputBuffer<S> implements InputBuffer{
 
 
     /**
-     * Recycle the input buffer. This should be called when closing the 
+     * Recycle the input buffer. This should be called when closing the
      * connection.
      */
     public void recycle() {
@@ -259,7 +259,7 @@ public abstract class AbstractInputBuffer<S> implements InputBuffer{
 
     /**
      * End processing of current HTTP request.
-     * Note: All bytes of the current request should have been already 
+     * Note: All bytes of the current request should have been already
      * consumed. This method only resets all the pointers so that we are ready
      * to parse the next HTTP request.
      */
@@ -297,7 +297,7 @@ public abstract class AbstractInputBuffer<S> implements InputBuffer{
 
     /**
      * End request (consumes leftover bytes).
-     * 
+     *
      * @throws IOException an underlying I/O error occurred
      */
     public void endRequest()
@@ -309,7 +309,7 @@ public abstract class AbstractInputBuffer<S> implements InputBuffer{
         }
 
     }
-    
+
     // ---------------------------------------------------- InputBuffer Methods
 
 
@@ -317,7 +317,7 @@ public abstract class AbstractInputBuffer<S> implements InputBuffer{
      * Read some bytes.
      */
     @Override
-    public int doRead(ByteChunk chunk, Request req) 
+    public int doRead(ByteChunk chunk, Request req)
         throws IOException {
 
         if (lastActiveFilter == -1)

==================================================
Constants.java
index a709720a46..d17889bac4 100644
--- a/java/org/apache/coyote/http11/AbstractOutputBuffer.java
+++ b/java/org/apache/coyote/http11/AbstractOutputBuffer.java
@@ -103,7 +103,7 @@ public abstract class AbstractOutputBuffer<S> implements OutputBuffer{
      */
     protected static final StringManager sm =
         StringManager.getManager(Constants.Package);
-    
+
     /**
      * Logger.
      */
@@ -118,7 +118,7 @@ public abstract class AbstractOutputBuffer<S> implements OutputBuffer{
      */
     public void addFilter(OutputFilter filter) {
 
-        OutputFilter[] newFilterLibrary = 
+        OutputFilter[] newFilterLibrary =
             new OutputFilter[filterLibrary.length + 1];
         for (int i = 0; i < filterLibrary.length; i++) {
             newFilterLibrary[i] = filterLibrary[i];
@@ -168,19 +168,19 @@ public abstract class AbstractOutputBuffer<S> implements OutputBuffer{
 
     /**
      * Write the contents of a byte chunk.
-     * 
+     *
      * @param chunk byte chunk
      * @return number of bytes written
      * @throws IOException an underlying I/O error occurred
      */
     @Override
-    public int doWrite(ByteChunk chunk, Response res) 
+    public int doWrite(ByteChunk chunk, Response res)
         throws IOException {
 
         if (!committed) {
 
             // Send the connector a request for commit. The connector should
-            // then validate the headers, send them (using sendHeaders) and 
+            // then validate the headers, send them (using sendHeaders) and
             // set the filters accordingly.
             response.action(ActionCode.COMMIT, null);
 
@@ -209,7 +209,7 @@ public abstract class AbstractOutputBuffer<S> implements OutputBuffer{
 
     /**
      * Flush the response.
-     * 
+     *
      * @throws IOException an underlying I/O error occurred
      */
     public void flush()
@@ -218,12 +218,12 @@ public abstract class AbstractOutputBuffer<S> implements OutputBuffer{
         if (!committed) {
 
             // Send the connector a request for commit. The connector should
-            // then validate the headers, send them (using sendHeader) and 
+            // then validate the headers, send them (using sendHeader) and
             // set the filters accordingly.
             response.action(ActionCode.COMMIT, null);
 
         }
-        
+
         // go through the filters and if there is gzip filter
         // invoke it to flush
         for (int i = 0; i <= lastActiveFilter; i++) {
@@ -237,10 +237,10 @@ public abstract class AbstractOutputBuffer<S> implements OutputBuffer{
             }
         }
     }
-    
+
     /**
      * Reset current response.
-     * 
+     *
      * @throws IllegalStateException if the response has already been committed
      */
     public void reset() {
@@ -252,9 +252,9 @@ public abstract class AbstractOutputBuffer<S> implements OutputBuffer{
         response.recycle();
 
     }
-    
+
     /**
-     * Recycle the output buffer. This should be called when closing the 
+     * Recycle the output buffer. This should be called when closing the
      * connection.
      */
     public void recycle() {
@@ -270,10 +270,10 @@ public abstract class AbstractOutputBuffer<S> implements OutputBuffer{
         finished = false;
 
     }
-    
+
     /**
      * End processing of current HTTP request.
-     * Note: All bytes of the current request should have been already 
+     * Note: All bytes of the current request should have been already
      * consumed. This method only resets all the pointers so that we are ready
      * to parse the next HTTP request.
      */
@@ -293,10 +293,10 @@ public abstract class AbstractOutputBuffer<S> implements OutputBuffer{
         finished = false;
         byteCount = 0;
     }
-    
+
     /**
      * End request.
-     * 
+     *
      * @throws IOException an underlying I/O error occurred
      */
     public void endRequest()
@@ -305,7 +305,7 @@ public abstract class AbstractOutputBuffer<S> implements OutputBuffer{
         if (!committed) {
 
             // Send the connector a request for commit. The connector should
-            // then validate the headers, send them (using sendHeader) and 
+            // then validate the headers, send them (using sendHeader) and
             // set the filters accordingly.
             response.action(ActionCode.COMMIT, null);
 
@@ -319,12 +319,12 @@ public abstract class AbstractOutputBuffer<S> implements OutputBuffer{
         finished = true;
     }
 
-    
+
     public abstract void init(SocketWrapper<S> socketWrapper,
             AbstractEndpoint endpoint) throws IOException;
 
     public abstract void sendAck() throws IOException;
-    
+
     protected abstract void commit() throws IOException;
 
 
@@ -362,7 +362,7 @@ public abstract class AbstractOutputBuffer<S> implements OutputBuffer{
             message = response.getMessage();
         }
         if (message == null) {
-            write(HttpMessages.getMessage(status)); 
+            write(HttpMessages.getMessage(status));
         } else {
             write(message);
         }
@@ -384,12 +384,12 @@ public abstract class AbstractOutputBuffer<S> implements OutputBuffer{
             buf[pos++] = Constants.LF;
         }
 
-    } 
+    }
 
 
     /**
      * Send a header.
-     * 
+     *
      * @param name Header name
      * @param value Header value
      */
@@ -414,13 +414,13 @@ public abstract class AbstractOutputBuffer<S> implements OutputBuffer{
         buf[pos++] = Constants.LF;
 
     }
-    
-    
+
+
     /**
-     * This method will write the contents of the specified message bytes 
+     * This method will write the contents of the specified message bytes
      * buffer to the output stream, without filtering. This method is meant to
      * be used to write the response header.
-     * 
+     *
      * @param mb data to be written
      */
     protected void write(MessageBytes mb) {
@@ -439,10 +439,10 @@ public abstract class AbstractOutputBuffer<S> implements OutputBuffer{
 
 
     /**
-     * This method will write the contents of the specified message bytes 
+     * This method will write the contents of the specified message bytes
      * buffer to the output stream, without filtering. This method is meant to
      * be used to write the response header.
-     * 
+     *
      * @param bc data to be written
      */
     protected void write(ByteChunk bc) {
@@ -456,10 +456,10 @@ public abstract class AbstractOutputBuffer<S> implements OutputBuffer{
 
 
     /**
-     * This method will write the contents of the specified char 
+     * This method will write the contents of the specified char
      * buffer to the output stream, without filtering. This method is meant to
      * be used to write the response header.
-     * 
+     *
      * @param cc data to be written
      */
     protected void write(CharChunk cc) {
@@ -485,10 +485,10 @@ public abstract class AbstractOutputBuffer<S> implements OutputBuffer{
 
 
     /**
-     * This method will write the contents of the specified byte 
+     * This method will write the contents of the specified byte
      * buffer to the output stream, without filtering. This method is meant to
      * be used to write the response header.
-     * 
+     *
      * @param b data to be written
      */
     public void write(byte[] b) {
@@ -501,10 +501,10 @@ public abstract class AbstractOutputBuffer<S> implements OutputBuffer{
 
 
     /**
-     * This method will write the contents of the specified String to the 
-     * output stream, without filtering. This method is meant to be used to 
+     * This method will write the contents of the specified String to the
+     * output stream, without filtering. This method is meant to be used to
      * write the response header.
-     * 
+     *
      * @param s data to be written
      */
     protected void write(String s) {
@@ -532,10 +532,10 @@ public abstract class AbstractOutputBuffer<S> implements OutputBuffer{
 
 
     /**
-     * This method will print the specified integer to the output stream, 
-     * without filtering. This method is meant to be used to write the 
+     * This method will print the specified integer to the output stream,
+     * without filtering. This method is meant to be used to write the
      * response header.
-     * 
+     *
      * @param i data to be written
      */
     protected void write(int i) {

==================================================
Http11AprProtocol.java
index 20edc935a0..2e28ea6acd 100644
--- a/java/org/apache/coyote/http11/Constants.java
+++ b/java/org/apache/coyote/http11/Constants.java
@@ -39,21 +39,21 @@ public final class Constants {
     public static final int DEFAULT_CONNECTION_LINGER = -1;
     public static final int DEFAULT_CONNECTION_TIMEOUT = 60000;
     public static final boolean DEFAULT_TCP_NO_DELAY = true;
-    
-    
+
+
     /**
      * CRLF.
      */
     public static final String CRLF = "\r\n";
 
-    
+
     /**
      * Server string.
      */
-    public static final byte[] SERVER_BYTES = 
+    public static final byte[] SERVER_BYTES =
         ByteChunk.convertToBytes("Server: Apache-Coyote/1.1" + CRLF);
 
-    
+
     /**
      * CR.
      */
@@ -82,7 +82,7 @@ public final class Constants {
      * COLON.
      */
     public static final byte COLON = (byte) ':';
-    
+
     /**
      * SEMI_COLON.
      */
@@ -123,22 +123,22 @@ public final class Constants {
     /* Various constant "strings" */
     public static final String CONNECTION = "Connection";
     public static final String CLOSE = "close";
-    public static final byte[] CLOSE_BYTES = 
+    public static final byte[] CLOSE_BYTES =
         ByteChunk.convertToBytes(CLOSE);
     public static final String KEEPALIVE = "keep-alive";
-    public static final byte[] KEEPALIVE_BYTES = 
+    public static final byte[] KEEPALIVE_BYTES =
         ByteChunk.convertToBytes(KEEPALIVE);
     public static final String CHUNKED = "chunked";
-    public static final byte[] ACK_BYTES = 
+    public static final byte[] ACK_BYTES =
         ByteChunk.convertToBytes("HTTP/1.1 100 Continue" + CRLF + CRLF);
     public static final String TRANSFERENCODING = "Transfer-Encoding";
-    public static final byte[] _200_BYTES = 
+    public static final byte[] _200_BYTES =
         ByteChunk.convertToBytes("200");
-    public static final byte[] _400_BYTES = 
+    public static final byte[] _400_BYTES =
         ByteChunk.convertToBytes("400");
-    public static final byte[] _404_BYTES = 
+    public static final byte[] _404_BYTES =
         ByteChunk.convertToBytes("404");
-    
+
 
     /**
      * Identity filters (input and output).
@@ -180,7 +180,7 @@ public final class Constants {
      * HTTP/1.1.
      */
     public static final String HTTP_11 = "HTTP/1.1";
-    public static final byte[] HTTP_11_BYTES = 
+    public static final byte[] HTTP_11_BYTES =
         ByteChunk.convertToBytes(HTTP_11);
 
 

==================================================
Http11NioProtocol.java
index 163c4a489b..5f708ca02e 100644
--- a/java/org/apache/coyote/http11/Http11AprProtocol.java
+++ b/java/org/apache/coyote/http11/Http11AprProtocol.java
@@ -70,10 +70,10 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
 
     public void setPollerThreadCount(int pollerThreadCount) { ((AprEndpoint)endpoint).setPollerThreadCount(pollerThreadCount); }
     public int getPollerThreadCount() { return ((AprEndpoint)endpoint).getPollerThreadCount(); }
-    
+
     public int getSendfileSize() { return ((AprEndpoint)endpoint).getSendfileSize(); }
     public void setSendfileSize(int sendfileSize) { ((AprEndpoint)endpoint).setSendfileSize(sendfileSize); }
-    
+
     public void setSendfileThreadCount(int sendfileThreadCount) { ((AprEndpoint)endpoint).setSendfileThreadCount(sendfileThreadCount); }
     public int getSendfileThreadCount() { return ((AprEndpoint)endpoint).getSendfileThreadCount(); }
 
@@ -165,7 +165,7 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
      */
     public int getSSLVerifyDepth() { return ((AprEndpoint)endpoint).getSSLVerifyDepth(); }
     public void setSSLVerifyDepth(int SSLVerifyDepth) { ((AprEndpoint)endpoint).setSSLVerifyDepth(SSLVerifyDepth); }
-    
+
     // ----------------------------------------------------- JMX related methods
 
     @Override
@@ -178,9 +178,9 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
 
     protected static class Http11ConnectionHandler
             extends AbstractConnectionHandler<Long,Http11AprProcessor> implements Handler {
-        
+
         protected Http11AprProtocol proto;
-        
+
         Http11ConnectionHandler(Http11AprProtocol proto) {
             this.proto = proto;
         }
@@ -194,7 +194,7 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
         protected Log getLog() {
             return log;
         }
-        
+
         @Override
         public void recycle() {
             recycledProcessors.clear();
@@ -203,7 +203,7 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
         /**
          * Expected to be used by the handler once the processor is no longer
          * required.
-         * 
+         *
          * @param socket
          * @param processor
          * @param isSocketClosing   Not used in HTTP

==================================================
Http11Processor.java
index a0f2498f5c..5ea84757d0 100644
--- a/java/org/apache/coyote/http11/Http11NioProtocol.java
+++ b/java/org/apache/coyote/http11/Http11NioProtocol.java
@@ -43,13 +43,13 @@ import org.apache.tomcat.util.net.SocketWrapper;
  * @author Filip Hanik
  */
 public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
-    
+
     private static final Log log = LogFactory.getLog(Http11NioProtocol.class);
 
 
     @Override
     protected Log getLog() { return log; }
-    
+
 
     @Override
     protected AbstractEndpoint.Handler getHandler() {
@@ -73,7 +73,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
 
 
     // -------------------- Properties--------------------
-    
+
     private Http11ConnectionHandler cHandler;
 
     // -------------------- Pool setup --------------------
@@ -81,19 +81,19 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
     public void setPollerThreadCount(int count) {
         ((NioEndpoint)endpoint).setPollerThreadCount(count);
     }
-    
+
     public int getPollerThreadCount() {
         return ((NioEndpoint)endpoint).getPollerThreadCount();
     }
-    
+
     public void setSelectorTimeout(long timeout) {
         ((NioEndpoint)endpoint).setSelectorTimeout(timeout);
     }
-    
+
     public long getSelectorTimeout() {
         return ((NioEndpoint)endpoint).getSelectorTimeout();
     }
-    
+
     public void setAcceptorThreadPriority(int threadPriority) {
         ((NioEndpoint)endpoint).setAcceptorThreadPriority(threadPriority);
     }
@@ -105,12 +105,12 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
     public int getAcceptorThreadPriority() {
       return ((NioEndpoint)endpoint).getAcceptorThreadPriority();
     }
-    
+
     public int getPollerThreadPriority() {
       return ((NioEndpoint)endpoint).getThreadPriority();
     }
-    
-    
+
+
     public boolean getUseSendfile() {
         return ((NioEndpoint)endpoint).getUseSendfile();
     }
@@ -118,7 +118,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
     public void setUseSendfile(boolean useSendfile) {
         ((NioEndpoint)endpoint).setUseSendfile(useSendfile);
     }
-    
+
     // -------------------- Tcp setup --------------------
     public void setOomParachute(int oomParachute) {
         ((NioEndpoint)endpoint).setOomParachute(oomParachute);
@@ -143,7 +143,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
         Http11ConnectionHandler(Http11NioProtocol proto) {
             this.proto = proto;
         }
-        
+
         @Override
         protected AbstractProtocol getProtocol() {
             return proto;
@@ -153,8 +153,8 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
         protected Log getLog() {
             return log;
         }
-        
-        
+
+
         @Override
         public SSLImplementation getSslImplementation() {
             return proto.sslImplementation;
@@ -166,7 +166,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
          */
         @Override
         public void release(SocketChannel socket) {
-            if (log.isDebugEnabled()) 
+            if (log.isDebugEnabled())
                 log.debug("Iterating through our connections to release a socket channel:"+socket);
             boolean released = false;
             Iterator<java.util.Map.Entry<NioChannel, Http11NioProcessor>> it = connections.entrySet().iterator();
@@ -181,10 +181,10 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
                     break;
                 }
             }
-            if (log.isDebugEnabled()) 
+            if (log.isDebugEnabled())
                 log.debug("Done iterating through our connections to release a socket channel:"+socket +" released:"+released);
         }
-        
+
         /**
          * Expected to be used by the Poller to release resources on socket
          * close, errors etc.
@@ -203,7 +203,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
         /**
          * Expected to be used by the handler once the processor is no longer
          * required.
-         * 
+         *
          * @param socket
          * @param processor
          * @param isSocketClosing   Not used in HTTP
@@ -241,7 +241,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
         protected void longPoll(SocketWrapper<NioChannel> socket,
                 Http11NioProcessor processor) {
             connections.put(socket.getSocket(), processor);
-            
+
             if (processor.isAsync()) {
                 socket.setAsync(true);
             } else {

==================================================
Http11Protocol.java
index dfbbac2d37..7aaedcdb98 100644
--- a/java/org/apache/coyote/http11/Http11Processor.java
+++ b/java/org/apache/coyote/http11/Http11Processor.java
@@ -53,7 +53,7 @@ public class Http11Processor extends AbstractHttp11Processor<Socket> {
             int maxTrailerSize) {
 
         super(endpoint);
-        
+
         inputBuffer = new InternalInputBuffer(request, headerBufferSize);
         request.setInputBuffer(inputBuffer);
 
@@ -84,7 +84,7 @@ public class Http11Processor extends AbstractHttp11Processor<Socket> {
      */
     protected SSLSupport sslSupport;
 
-    
+
     /**
      * Socket associated with the current connection.
      */
@@ -120,7 +120,7 @@ public class Http11Processor extends AbstractHttp11Processor<Socket> {
 
     @Override
     protected boolean disableKeepAlive() {
-        int threadRatio = -1;   
+        int threadRatio = -1;
         // These may return zero or negative values
         // Only calculate a thread ratio when both are >0 to ensure we get a
         // sensible result
@@ -129,24 +129,24 @@ public class Http11Processor extends AbstractHttp11Processor<Socket> {
                 && (threadsBusy = endpoint.getCurrentThreadsBusy()) > 0) {
             threadRatio = (threadsBusy * 100) / maxThreads;
         }
-        // Disable keep-alive if we are running low on threads      
-        if (threadRatio > getDisableKeepAlivePercentage()) {     
+        // Disable keep-alive if we are running low on threads
+        if (threadRatio > getDisableKeepAlivePercentage()) {
             return true;
         }
-        
+
         return false;
     }
 
 
     @Override
     protected void setRequestLineReadTimeout() throws IOException {
-        
+
         /*
          * When there is no data in the buffer and this is not the first
          * request on this connection and timeouts are being used the
          * first read for this request may need a different timeout to
          * take account of time spent waiting for a processing thread.
-         * 
+         *
          * This is a little hacky but better than exposing the socket
          * and the timeout info to the InputBuffer
          */
@@ -190,8 +190,8 @@ public class Http11Processor extends AbstractHttp11Processor<Socket> {
     protected void setSocketTimeout(int timeout) throws IOException {
         socket.getSocket().setSoTimeout(timeout);
     }
-    
-    
+
+
     @Override
     protected void setCometTimeouts(SocketWrapper<Socket> socketWrapper) {
         // NO-OP for BIO
@@ -209,7 +209,7 @@ public class Http11Processor extends AbstractHttp11Processor<Socket> {
         return false;
     }
 
-    
+
     @Override
     protected void resetTimeouts() {
         // NOOP for BIO

==================================================
InputFilter.java
index 79e65b930d..6c83102bc2 100644
--- a/java/org/apache/coyote/http11/Http11Protocol.java
+++ b/java/org/apache/coyote/http11/Http11Protocol.java
@@ -40,7 +40,7 @@ public class Http11Protocol extends AbstractHttp11JsseProtocol {
 
     private static final org.apache.juli.logging.Log log
         = org.apache.juli.logging.LogFactory.getLog(Http11Protocol.class);
-    
+
     @Override
     protected Log getLog() { return log; }
 
@@ -63,7 +63,7 @@ public class Http11Protocol extends AbstractHttp11JsseProtocol {
         setTcpNoDelay(Constants.DEFAULT_TCP_NO_DELAY);
     }
 
-    
+
     // ----------------------------------------------------------------- Fields
 
     protected Http11ConnectionHandler cHandler;
@@ -85,7 +85,7 @@ public class Http11Protocol extends AbstractHttp11JsseProtocol {
             this.disableKeepAlivePercentage = disableKeepAlivePercentage;
         }
     }
-    
+
     // ----------------------------------------------------- JMX related methods
 
     @Override
@@ -100,7 +100,7 @@ public class Http11Protocol extends AbstractHttp11JsseProtocol {
             extends AbstractConnectionHandler<Socket, Http11Processor> implements Handler {
 
         protected Http11Protocol proto;
-            
+
         Http11ConnectionHandler(Http11Protocol proto) {
             this.proto = proto;
         }
@@ -114,7 +114,7 @@ public class Http11Protocol extends AbstractHttp11JsseProtocol {
         protected Log getLog() {
             return log;
         }
-        
+
         @Override
         public SSLImplementation getSslImplementation() {
             return proto.sslImplementation;
@@ -123,7 +123,7 @@ public class Http11Protocol extends AbstractHttp11JsseProtocol {
         /**
          * Expected to be used by the handler once the processor is no longer
          * required.
-         * 
+         *
          * @param socket            Not used in BIO
          * @param processor
          * @param isSocketClosing   Not used in HTTP

==================================================
InternalAprInputBuffer.java
index 94b7db1540..a90c88bf80 100644
--- a/java/org/apache/coyote/http11/InputFilter.java
+++ b/java/org/apache/coyote/http11/InputFilter.java
@@ -25,7 +25,7 @@ import org.apache.tomcat.util.buf.ByteChunk;
 
 /**
  * Input filter interface.
- * 
+ *
  * @author Remy Maucherat
  */
 public interface InputFilter extends InputBuffer {
@@ -33,7 +33,7 @@ public interface InputFilter extends InputBuffer {
 
     /**
      * Read bytes.
-     * 
+     *
      * @return Number of bytes read.
      */
     @Override
@@ -42,7 +42,7 @@ public interface InputFilter extends InputBuffer {
 
 
     /**
-     * Some filters need additional parameters from the request. All the 
+     * Some filters need additional parameters from the request. All the
      * necessary reading can occur in that method, as this method is called
      * after the request header processing is complete.
      */
@@ -69,7 +69,7 @@ public interface InputFilter extends InputBuffer {
 
     /**
      * End the current request.
-     * 
+     *
      * @return 0 is the expected return value. A positive value indicates that
      * too many bytes were read. This method is allowed to use buffer.doRead
      * to consume extra bytes. The result of this method can't be negative (if

==================================================
InternalAprOutputBuffer.java
index 74706fdc17..3abde0fee0 100644
--- a/java/org/apache/coyote/http11/InternalAprInputBuffer.java
+++ b/java/org/apache/coyote/http11/InternalAprInputBuffer.java
@@ -70,7 +70,7 @@ public class InternalAprInputBuffer extends AbstractInputBuffer<Long> {
 
         parsingHeader = true;
         swallowInput = true;
-        
+
     }
 
 
@@ -92,7 +92,7 @@ public class InternalAprInputBuffer extends AbstractInputBuffer<Long> {
     // --------------------------------------------------------- Public Methods
 
     /**
-     * Recycle the input buffer. This should be called when closing the 
+     * Recycle the input buffer. This should be called when closing the
      * connection.
      */
     @Override
@@ -103,14 +103,14 @@ public class InternalAprInputBuffer extends AbstractInputBuffer<Long> {
 
 
     /**
-     * Read the request line. This function is meant to be used during the 
-     * HTTP request header parsing. Do NOT attempt to read the request body 
+     * Read the request line. This function is meant to be used during the
+     * HTTP request header parsing. Do NOT attempt to read the request body
      * using it.
      *
      * @throws IOException If an exception occurs during the underlying socket
      * read operations, or if the given buffer is not big enough to accommodate
      * the whole line.
-     * @return true if data is properly fed; false if no data is available 
+     * @return true if data is properly fed; false if no data is available
      * immediately and thread should be freed
      */
     @Override
@@ -219,13 +219,13 @@ public class InternalAprInputBuffer extends AbstractInputBuffer<Long> {
             if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
                 space = true;
                 end = pos;
-            } else if ((buf[pos] == Constants.CR) 
+            } else if ((buf[pos] == Constants.CR)
                        || (buf[pos] == Constants.LF)) {
                 // HTTP/0.9 style request
                 eol = true;
                 space = true;
                 end = pos;
-            } else if ((buf[pos] == Constants.QUESTION) 
+            } else if ((buf[pos] == Constants.QUESTION)
                        && (questionPos == -1)) {
                 questionPos = pos;
             }
@@ -236,7 +236,7 @@ public class InternalAprInputBuffer extends AbstractInputBuffer<Long> {
 
         request.unparsedURI().setBytes(buf, start, end - start);
         if (questionPos >= 0) {
-            request.queryString().setBytes(buf, questionPos + 1, 
+            request.queryString().setBytes(buf, questionPos + 1,
                                            end - questionPos - 1);
             request.requestURI().setBytes(buf, start, questionPos - start);
         } else {
@@ -292,7 +292,7 @@ public class InternalAprInputBuffer extends AbstractInputBuffer<Long> {
         } else {
             request.protocol().setString("");
         }
-        
+
         return true;
 
     }
@@ -317,7 +317,7 @@ public class InternalAprInputBuffer extends AbstractInputBuffer<Long> {
 
     /**
      * Parse an HTTP header.
-     * 
+     *
      * @return false after reading a blank line (which indicates that the
      * HTTP header parsing is done
      */
@@ -481,14 +481,14 @@ public class InternalAprInputBuffer extends AbstractInputBuffer<Long> {
 
     }
 
-    
+
     private void skipLine(int start) throws IOException {
         boolean eol = false;
         int lastRealByte = start;
         if (pos - 1 > start) {
             lastRealByte = pos - 1;
         }
-        
+
         while (!eol) {
 
             // Read new bytes if needed
@@ -512,8 +512,8 @@ public class InternalAprInputBuffer extends AbstractInputBuffer<Long> {
                     lastRealByte - start + 1, Charset.forName("ISO-8859-1"))));
         }
     }
-    
-    
+
+
     /**
      * Available bytes (note that due to encoding, this may not correspond )
      */
@@ -535,7 +535,7 @@ public class InternalAprInputBuffer extends AbstractInputBuffer<Long> {
      * Read some bytes.
      */
     @Override
-    public int doRead(ByteChunk chunk, Request req) 
+    public int doRead(ByteChunk chunk, Request req)
         throws IOException {
 
         if (lastActiveFilter == -1)
@@ -562,11 +562,11 @@ public class InternalAprInputBuffer extends AbstractInputBuffer<Long> {
         // Ignore the block parameter and just call fill
         return fill();
     }
-    
-    
+
+
     /**
      * Fill the internal buffer using data from the underlying input stream.
-     * 
+     *
      * @return false if at end of stream
      */
     protected boolean fill()
@@ -598,7 +598,7 @@ public class InternalAprInputBuffer extends AbstractInputBuffer<Long> {
         } else {
 
             if (buf.length - end < 4500) {
-                // In this case, the request header was really large, so we allocate a 
+                // In this case, the request header was really large, so we allocate a
                 // brand new one; the old one will get GCed when subsequent requests
                 // clear all references
                 buf = new byte[buf.length];
@@ -637,7 +637,7 @@ public class InternalAprInputBuffer extends AbstractInputBuffer<Long> {
      * This class is an input buffer which will read its data from an input
      * stream.
      */
-    protected class SocketInputBuffer 
+    protected class SocketInputBuffer
         implements InputBuffer {
 
 
@@ -645,7 +645,7 @@ public class InternalAprInputBuffer extends AbstractInputBuffer<Long> {
          * Read bytes into the specified chunk.
          */
         @Override
-        public int doRead(ByteChunk chunk, Request req ) 
+        public int doRead(ByteChunk chunk, Request req )
             throws IOException {
 
             if (pos >= lastValid) {

==================================================
InternalInputBuffer.java
index 94b8a8943f..6fbdd83f0b 100644
--- a/java/org/apache/coyote/http11/InternalAprOutputBuffer.java
+++ b/java/org/apache/coyote/http11/InternalAprOutputBuffer.java
@@ -31,7 +31,7 @@ import org.apache.tomcat.util.net.SocketWrapper;
 
 /**
  * Output buffer.
- * 
+ *
  * @author <a href="mailto:remm@apache.org">Remy Maucherat</a>
  */
 public class InternalAprOutputBuffer extends AbstractOutputBuffer<Long> {
@@ -82,7 +82,7 @@ public class InternalAprOutputBuffer extends AbstractOutputBuffer<Long> {
      */
     private ByteBuffer bbuf = null;
 
-    
+
     // --------------------------------------------------------- Public Methods
 
     @Override
@@ -96,7 +96,7 @@ public class InternalAprOutputBuffer extends AbstractOutputBuffer<Long> {
 
     /**
      * Flush the response.
-     * 
+     *
      * @throws IOException an underlying I/O error occurred
      */
     @Override
@@ -111,21 +111,21 @@ public class InternalAprOutputBuffer extends AbstractOutputBuffer<Long> {
 
 
     /**
-     * Recycle the output buffer. This should be called when closing the 
+     * Recycle the output buffer. This should be called when closing the
      * connection.
      */
     @Override
     public void recycle() {
 
         super.recycle();
-        
+
         bbuf.clear();
     }
 
 
     /**
      * End request.
-     * 
+     *
      * @throws IOException an underlying I/O error occurred
      */
     @Override
@@ -135,7 +135,7 @@ public class InternalAprOutputBuffer extends AbstractOutputBuffer<Long> {
         if (!committed) {
 
             // Send the connector a request for commit. The connector should
-            // then validate the headers, send them (using sendHeader) and 
+            // then validate the headers, send them (using sendHeader) and
             // set the filters accordingly.
             response.action(ActionCode.COMMIT, null);
 
@@ -177,7 +177,7 @@ public class InternalAprOutputBuffer extends AbstractOutputBuffer<Long> {
 
     /**
      * Commit the response.
-     * 
+     *
      * @throws IOException an underlying I/O error occurred
      */
     @Override
@@ -223,7 +223,7 @@ public class InternalAprOutputBuffer extends AbstractOutputBuffer<Long> {
          * Write chunk.
          */
         @Override
-        public int doWrite(ByteChunk chunk, Response res) 
+        public int doWrite(ByteChunk chunk, Response res)
             throws IOException {
 
             int len = chunk.getLength();

==================================================
InternalNioInputBuffer.java
index b4d2d5be13..5a7f16d240 100644
--- a/java/org/apache/coyote/http11/InternalInputBuffer.java
+++ b/java/org/apache/coyote/http11/InternalInputBuffer.java
@@ -69,10 +69,10 @@ public class InternalInputBuffer extends AbstractInputBuffer<Socket> {
 
     }
 
-    
+
     /**
-     * Read the request line. This function is meant to be used during the 
-     * HTTP request header parsing. Do NOT attempt to read the request body 
+     * Read the request line. This function is meant to be used during the
+     * HTTP request header parsing. Do NOT attempt to read the request body
      * using it.
      *
      * @throws IOException If an exception occurs during the underlying socket
@@ -81,7 +81,7 @@ public class InternalInputBuffer extends AbstractInputBuffer<Socket> {
      */
     @Override
     public boolean parseRequestLine(boolean useAvailableDataOnly)
-    
+
         throws IOException {
 
         int start = 0;
@@ -138,7 +138,7 @@ public class InternalInputBuffer extends AbstractInputBuffer<Socket> {
 
         }
 
-        
+
         // Spec says single SP but also says be tolerant of multiple and/or HT
         while (space) {
             // Read new bytes if needed
@@ -176,13 +176,13 @@ public class InternalInputBuffer extends AbstractInputBuffer<Socket> {
             if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
                 space = true;
                 end = pos;
-            } else if ((buf[pos] == Constants.CR) 
+            } else if ((buf[pos] == Constants.CR)
                        || (buf[pos] == Constants.LF)) {
                 // HTTP/0.9 style request
                 eol = true;
                 space = true;
                 end = pos;
-            } else if ((buf[pos] == Constants.QUESTION) 
+            } else if ((buf[pos] == Constants.QUESTION)
                        && (questionPos == -1)) {
                 questionPos = pos;
             }
@@ -193,7 +193,7 @@ public class InternalInputBuffer extends AbstractInputBuffer<Socket> {
 
         request.unparsedURI().setBytes(buf, start, end - start);
         if (questionPos >= 0) {
-            request.queryString().setBytes(buf, questionPos + 1, 
+            request.queryString().setBytes(buf, questionPos + 1,
                                            end - questionPos - 1);
             request.requestURI().setBytes(buf, start, questionPos - start);
         } else {
@@ -248,7 +248,7 @@ public class InternalInputBuffer extends AbstractInputBuffer<Socket> {
         } else {
             request.protocol().setString("");
         }
-        
+
         return true;
 
     }
@@ -273,7 +273,7 @@ public class InternalInputBuffer extends AbstractInputBuffer<Socket> {
 
     /**
      * Parse an HTTP header.
-     * 
+     *
      * @return false after reading a blank line (which indicates that the
      * HTTP header parsing is done
      */
@@ -463,7 +463,7 @@ public class InternalInputBuffer extends AbstractInputBuffer<Socket> {
         if (pos - 1 > start) {
             lastRealByte = pos - 1;
         }
-        
+
         while (!eol) {
 
             // Read new bytes if needed
@@ -490,7 +490,7 @@ public class InternalInputBuffer extends AbstractInputBuffer<Socket> {
 
     /**
      * Fill the internal buffer using data from the underlying input stream.
-     * 
+     *
      * @return false if at end of stream
      */
     protected boolean fill() throws IOException {
@@ -517,7 +517,7 @@ public class InternalInputBuffer extends AbstractInputBuffer<Socket> {
         } else {
 
             if (buf.length - end < 4500) {
-                // In this case, the request header was really large, so we allocate a 
+                // In this case, the request header was really large, so we allocate a
                 // brand new one; the old one will get GCed when subsequent requests
                 // clear all references
                 buf = new byte[buf.length];
@@ -544,7 +544,7 @@ public class InternalInputBuffer extends AbstractInputBuffer<Socket> {
      * This class is an input buffer which will read its data from an input
      * stream.
      */
-    protected class InputStreamInputBuffer 
+    protected class InputStreamInputBuffer
         implements InputBuffer {
 
 
@@ -552,7 +552,7 @@ public class InternalInputBuffer extends AbstractInputBuffer<Socket> {
          * Read bytes into the specified chunk.
          */
         @Override
-        public int doRead(ByteChunk chunk, Request req ) 
+        public int doRead(ByteChunk chunk, Request req )
             throws IOException {
 
             if (pos >= lastValid) {

==================================================
InternalNioOutputBuffer.java
index 79f99a84cc..da0bb615be 100644
--- a/java/org/apache/coyote/http11/InternalNioInputBuffer.java
+++ b/java/org/apache/coyote/http11/InternalNioInputBuffer.java
@@ -92,7 +92,7 @@ public class InternalNioInputBuffer extends AbstractInputBuffer<NioChannel> {
     }
 
     // ----------------------------------------------------------- Constructors
-    
+
 
     /**
      * Alternate constructor.
@@ -137,7 +137,7 @@ public class InternalNioInputBuffer extends AbstractInputBuffer<NioChannel> {
      * Underlying socket.
      */
     private NioChannel socket;
-    
+
     /**
      * Selector pool, for blocking reads and blocking writes
      */
@@ -170,7 +170,7 @@ public class InternalNioInputBuffer extends AbstractInputBuffer<NioChannel> {
     // --------------------------------------------------------- Public Methods
 
     /**
-     * Recycle the input buffer. This should be called when closing the 
+     * Recycle the input buffer. This should be called when closing the
      * connection.
      */
     @Override
@@ -194,7 +194,7 @@ public class InternalNioInputBuffer extends AbstractInputBuffer<NioChannel> {
 
     /**
      * End processing of current HTTP request.
-     * Note: All bytes of the current request should have been already 
+     * Note: All bytes of the current request should have been already
      * consumed. This method only resets all the pointers so that we are ready
      * to parse the next HTTP request.
      */
@@ -211,14 +211,14 @@ public class InternalNioInputBuffer extends AbstractInputBuffer<NioChannel> {
     }
 
     /**
-     * Read the request line. This function is meant to be used during the 
-     * HTTP request header parsing. Do NOT attempt to read the request body 
+     * Read the request line. This function is meant to be used during the
+     * HTTP request header parsing. Do NOT attempt to read the request body
      * using it.
      *
      * @throws IOException If an exception occurs during the underlying socket
      * read operations, or if the given buffer is not big enough to accommodate
      * the whole line.
-     * @return true if data is properly fed; false if no data is available 
+     * @return true if data is properly fed; false if no data is available
      * immediately and thread should be freed
      */
     @Override
@@ -233,7 +233,7 @@ public class InternalNioInputBuffer extends AbstractInputBuffer<NioChannel> {
         if ( parsingRequestLinePhase == 0 ) {
             byte chr = 0;
             do {
-                
+
                 // Read new bytes if needed
                 if (pos >= lastValid) {
                     if (useAvailableDataOnly) {
@@ -308,7 +308,7 @@ public class InternalNioInputBuffer extends AbstractInputBuffer<NioChannel> {
         }
         if (parsingRequestLinePhase == 4) {
             // Mark the current buffer position
-            
+
             int end = 0;
             //
             // Reading the URI
@@ -323,13 +323,13 @@ public class InternalNioInputBuffer extends AbstractInputBuffer<NioChannel> {
                 if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
                     space = true;
                     end = pos;
-                } else if ((buf[pos] == Constants.CR) 
+                } else if ((buf[pos] == Constants.CR)
                            || (buf[pos] == Constants.LF)) {
                     // HTTP/0.9 style request
                     parsingRequestLineEol = true;
                     space = true;
                     end = pos;
-                } else if ((buf[pos] == Constants.QUESTION) 
+                } else if ((buf[pos] == Constants.QUESTION)
                            && (parsingRequestLineQPos == -1)) {
                     parsingRequestLineQPos = pos;
                 }
@@ -337,7 +337,7 @@ public class InternalNioInputBuffer extends AbstractInputBuffer<NioChannel> {
             }
             request.unparsedURI().setBytes(buf, parsingRequestLineStart, end - parsingRequestLineStart);
             if (parsingRequestLineQPos >= 0) {
-                request.queryString().setBytes(buf, parsingRequestLineQPos + 1, 
+                request.queryString().setBytes(buf, parsingRequestLineQPos + 1,
                                                end - parsingRequestLineQPos - 1);
                 request.requestURI().setBytes(buf, parsingRequestLineStart, parsingRequestLineQPos - parsingRequestLineStart);
             } else {
@@ -363,9 +363,9 @@ public class InternalNioInputBuffer extends AbstractInputBuffer<NioChannel> {
             parsingRequestLineStart = pos;
             parsingRequestLinePhase = 6;
         }
-        if (parsingRequestLinePhase == 6) { 
+        if (parsingRequestLinePhase == 6) {
             // Mark the current buffer position
-            
+
             end = 0;
             //
             // Reading the protocol
@@ -377,7 +377,7 @@ public class InternalNioInputBuffer extends AbstractInputBuffer<NioChannel> {
                     if (!fill(true, false)) //request line parsing
                         return false;
                 }
-        
+
                 if (buf[pos] == Constants.CR) {
                     end = pos;
                 } else if (buf[pos] == Constants.LF) {
@@ -387,7 +387,7 @@ public class InternalNioInputBuffer extends AbstractInputBuffer<NioChannel> {
                 }
                 pos++;
             }
-        
+
             if ( (end - parsingRequestLineStart) > 0) {
                 request.protocol().setBytes(buf, parsingRequestLineStart, end - parsingRequestLineStart);
             } else {
@@ -401,7 +401,7 @@ public class InternalNioInputBuffer extends AbstractInputBuffer<NioChannel> {
         }
         throw new IllegalStateException("Invalid request line parse phase:"+parsingRequestLinePhase);
     }
-    
+
     private void expand(int newsize) {
         if ( newsize > buf.length ) {
             if (parsingHeader) {
@@ -416,7 +416,7 @@ public class InternalNioInputBuffer extends AbstractInputBuffer<NioChannel> {
             buf = tmp;
         }
     }
-    
+
     /**
      * Perform blocking read with a timeout if desired
      * @param timeout boolean - if we want to use the timeout data
@@ -425,7 +425,7 @@ public class InternalNioInputBuffer extends AbstractInputBuffer<NioChannel> {
      * @throws IOException if a socket exception occurs
      * @throws EOFException if end of stream is reached
      */
-    
+
     private int readSocket(boolean timeout, boolean block) throws IOException {
         int nRead = 0;
         socket.getBufHandler().getReadBuffer().clear();
@@ -442,7 +442,7 @@ public class InternalNioInputBuffer extends AbstractInputBuffer<NioChannel> {
                 nRead = pool.read(socket.getBufHandler().getReadBuffer(),socket,selector,att.getTimeout());
             } catch ( EOFException eof ) {
                 nRead = -1;
-            } finally { 
+            } finally {
                 if ( selector != null ) pool.put(selector);
             }
         } else {
@@ -470,7 +470,7 @@ public class InternalNioInputBuffer extends AbstractInputBuffer<NioChannel> {
     public boolean parseHeaders()
         throws IOException {
         HeaderParseStatus status = HeaderParseStatus.HAVE_MORE_HEADERS;
-        
+
         do {
             status = parseHeader();
         } while ( status == HeaderParseStatus.HAVE_MORE_HEADERS );
@@ -499,7 +499,7 @@ public class InternalNioInputBuffer extends AbstractInputBuffer<NioChannel> {
 
     /**
      * Parse an HTTP header.
-     * 
+     *
      * @return false after reading a blank line (which indicates that the
      * HTTP header parsing is done
      */
@@ -515,7 +515,7 @@ public class InternalNioInputBuffer extends AbstractInputBuffer<NioChannel> {
 
             // Read new bytes if needed
             if (pos >= lastValid) {
-                if (!fill(true,false)) {//parse header 
+                if (!fill(true,false)) {//parse header
                     headerParsePos = HeaderParsePosition.HEADER_START;
                     return HeaderParseStatus.NEED_MORE_DATA;
                 }
@@ -551,7 +551,7 @@ public class InternalNioInputBuffer extends AbstractInputBuffer<NioChannel> {
 
             // Read new bytes if needed
             if (pos >= lastValid) {
-                if (!fill(true,false)) { //parse header 
+                if (!fill(true,false)) { //parse header
                     return HeaderParseStatus.NEED_MORE_DATA;
                 }
             }
@@ -598,7 +598,7 @@ public class InternalNioInputBuffer extends AbstractInputBuffer<NioChannel> {
                 while (true) {
                     // Read new bytes if needed
                     if (pos >= lastValid) {
-                        if (!fill(true,false)) {//parse header 
+                        if (!fill(true,false)) {//parse header
                             //HEADER_VALUE_START
                             return HeaderParseStatus.NEED_MORE_DATA;
                         }
@@ -621,7 +621,7 @@ public class InternalNioInputBuffer extends AbstractInputBuffer<NioChannel> {
 
                     // Read new bytes if needed
                     if (pos >= lastValid) {
-                        if (!fill(true,false)) {//parse header 
+                        if (!fill(true,false)) {//parse header
                             //HEADER_VALUE
                             return HeaderParseStatus.NEED_MORE_DATA;
                         }
@@ -654,7 +654,7 @@ public class InternalNioInputBuffer extends AbstractInputBuffer<NioChannel> {
             // Read new bytes if needed
             if (pos >= lastValid) {
                 if (!fill(true,false)) {//parse header
-                    
+
                     //HEADER_MULTI_LINE
                     return HeaderParseStatus.NEED_MORE_DATA;
                 }
@@ -680,7 +680,7 @@ public class InternalNioInputBuffer extends AbstractInputBuffer<NioChannel> {
         headerData.recycle();
         return HeaderParseStatus.HAVE_MORE_HEADERS;
     }
-    
+
     public int getParsingRequestLinePhase() {
         return parsingRequestLinePhase;
     }
@@ -794,7 +794,7 @@ public class InternalNioInputBuffer extends AbstractInputBuffer<NioChannel> {
 
     /**
      * Fill the internal buffer using data from the underlying input stream.
-     * 
+     *
      * @return false if at end of stream
      */
     @Override
@@ -803,7 +803,7 @@ public class InternalNioInputBuffer extends AbstractInputBuffer<NioChannel> {
     }
 
     protected boolean fill(boolean timeout, boolean block) throws IOException, EOFException {
-        
+
 
         boolean read = false;
 
@@ -832,7 +832,7 @@ public class InternalNioInputBuffer extends AbstractInputBuffer<NioChannel> {
      * This class is an input buffer which will read its data from an input
      * stream.
      */
-    protected class SocketInputBuffer 
+    protected class SocketInputBuffer
         implements InputBuffer {
 
 
@@ -840,7 +840,7 @@ public class InternalNioInputBuffer extends AbstractInputBuffer<NioChannel> {
          * Read bytes into the specified chunk.
          */
         @Override
-        public int doRead(ByteChunk chunk, Request req ) 
+        public int doRead(ByteChunk chunk, Request req )
             throws IOException {
 
             if (pos >= lastValid) {

==================================================
InternalOutputBuffer.java
index dca3fae5c9..1571db79f3 100644
--- a/java/org/apache/coyote/http11/InternalNioOutputBuffer.java
+++ b/java/org/apache/coyote/http11/InternalNioOutputBuffer.java
@@ -35,7 +35,7 @@ import org.apache.tomcat.util.net.SocketWrapper;
 
 /**
  * Output buffer.
- * 
+ *
  * @author <a href="mailto:remm@apache.org">Remy Maucherat</a>
  * @author Filip Hanik
  */
@@ -51,7 +51,7 @@ public class InternalNioOutputBuffer extends AbstractOutputBuffer<NioChannel> {
         this.response = response;
 
         buf = new byte[headerBufferSize];
-        
+
         outputStreamOutputBuffer = new SocketOutputBuffer();
 
         filterLibrary = new OutputFilter[0];
@@ -60,7 +60,7 @@ public class InternalNioOutputBuffer extends AbstractOutputBuffer<NioChannel> {
 
         committed = false;
         finished = false;
-        
+
         // Cause loading of HttpMessages
         HttpMessages.getMessage(200);
 
@@ -76,7 +76,7 @@ public class InternalNioOutputBuffer extends AbstractOutputBuffer<NioChannel> {
      * Underlying socket.
      */
     private NioChannel socket;
-    
+
     /**
      * Selector pool, for blocking reads and blocking writes
      */
@@ -88,9 +88,9 @@ public class InternalNioOutputBuffer extends AbstractOutputBuffer<NioChannel> {
 
     /**
      * Flush the response.
-     * 
+     *
      * @throws IOException an underlying I/O error occurred
-     * 
+     *
      */
     @Override
     public void flush() throws IOException {
@@ -103,7 +103,7 @@ public class InternalNioOutputBuffer extends AbstractOutputBuffer<NioChannel> {
 
 
     /**
-     * Recycle the output buffer. This should be called when closing the 
+     * Recycle the output buffer. This should be called when closing the
      * connection.
      */
     @Override
@@ -119,7 +119,7 @@ public class InternalNioOutputBuffer extends AbstractOutputBuffer<NioChannel> {
 
     /**
      * End request.
-     * 
+     *
      * @throws IOException an underlying I/O error occurred
      */
     @Override
@@ -131,7 +131,7 @@ public class InternalNioOutputBuffer extends AbstractOutputBuffer<NioChannel> {
     // ------------------------------------------------ HTTP/1.1 Output Methods
 
 
-    /** 
+    /**
      * Send an acknowledgment.
      */
     @Override
@@ -139,14 +139,14 @@ public class InternalNioOutputBuffer extends AbstractOutputBuffer<NioChannel> {
 
         if (!committed) {
             //Socket.send(socket, Constants.ACK_BYTES, 0, Constants.ACK_BYTES.length) < 0
-            socket.getBufHandler() .getWriteBuffer().put(Constants.ACK_BYTES,0,Constants.ACK_BYTES.length);    
+            socket.getBufHandler() .getWriteBuffer().put(Constants.ACK_BYTES,0,Constants.ACK_BYTES.length);
             writeToSocket(socket.getBufHandler() .getWriteBuffer(),true,true);
         }
 
     }
 
     /**
-     * 
+     *
      * @param bytebuffer ByteBuffer
      * @param flip boolean
      * @return int
@@ -168,16 +168,16 @@ public class InternalNioOutputBuffer extends AbstractOutputBuffer<NioChannel> {
         }
         try {
             written = pool.write(bytebuffer, socket, selector, writeTimeout, block,lastWrite);
-            //make sure we are flushed 
+            //make sure we are flushed
             do {
                 if (socket.flush(true,selector,writeTimeout,lastWrite)) break;
             }while ( true );
-        }finally { 
+        }finally {
             if ( selector != null ) pool.put(selector);
         }
         if ( block ) bytebuffer.clear(); //only clear
         return written;
-    } 
+    }
 
 
     // ------------------------------------------------------ Protected Methods
@@ -193,7 +193,7 @@ public class InternalNioOutputBuffer extends AbstractOutputBuffer<NioChannel> {
 
     /**
      * Commit the response.
-     * 
+     *
      * @throws IOException an underlying I/O error occurred
      */
     @Override
@@ -258,7 +258,7 @@ public class InternalNioOutputBuffer extends AbstractOutputBuffer<NioChannel> {
      * This class is an output buffer which will write data to an output
      * stream.
      */
-    protected class SocketOutputBuffer 
+    protected class SocketOutputBuffer
         implements OutputBuffer {
 
 
@@ -266,7 +266,7 @@ public class InternalNioOutputBuffer extends AbstractOutputBuffer<NioChannel> {
          * Write chunk.
          */
         @Override
-        public int doWrite(ByteChunk chunk, Response res) 
+        public int doWrite(ByteChunk chunk, Response res)
             throws IOException {
 
             int len = chunk.getLength();

==================================================
OutputFilter.java
index d79a78ccee..6fa403242c 100644
--- a/java/org/apache/coyote/http11/LocalStrings_ja.properties
+++ b/java/org/apache/coyote/http11/LocalStrings_ja.properties
@@ -20,6 +20,6 @@ http11protocol.proto.ioexception.info=\u30ea\u30af\u30a8\u30b9\u30c8\u3092\u8aad
 http11protocol.proto.socketexception.debug=\u30ea\u30af\u30a8\u30b9\u30c8\u3092\u8aad\u307f\u8fbc\u307f\u4e2d\u306eSocketException\u3067\u3059
 http11protocol.proto.socketexception.info=\u30ea\u30af\u30a8\u30b9\u30c8\u3092\u8aad\u307f\u8fbc\u307f\u4e2d\u306eSocketException\u3067\u3059\u304c\u3001\u7121\u8996\u3055\u308c\u307e\u3057\u305f
 http11protocol.start=Coyote HTTP/1.1\u3092 {0} \u3067\u8d77\u52d5\u3057\u307e\u3059
- 
+
 iib.eof.error=\u30bd\u30b1\u30c3\u30c8\u304b\u3089\u4e88\u671f\u3057\u306a\u3044EOF\u3092\u8aad\u307f\u8fbc\u307f\u307e\u3057\u305f
 iib.requestheadertoolarge.error=\u30ea\u30af\u30a8\u30b9\u30c8\u30d8\u30c3\u30c0\u304c\u9577\u3059\u304e\u307e\u3059

==================================================
BufferedInputFilter.java
index 7585859cd5..044c2e0fb9 100644
--- a/java/org/apache/coyote/http11/OutputFilter.java
+++ b/java/org/apache/coyote/http11/OutputFilter.java
@@ -25,7 +25,7 @@ import org.apache.tomcat.util.buf.ByteChunk;
 
 /**
  * Output filter.
- * 
+ *
  * @author Remy Maucherat
  */
 public interface OutputFilter extends OutputBuffer {
@@ -33,7 +33,7 @@ public interface OutputFilter extends OutputBuffer {
 
     /**
      * Write some bytes.
-     * 
+     *
      * @return number of bytes written by the filter
      */
     @Override
@@ -42,7 +42,7 @@ public interface OutputFilter extends OutputBuffer {
 
 
     /**
-     * Some filters need additional parameters from the response. All the 
+     * Some filters need additional parameters from the response. All the
      * necessary reading can occur in that method, as this method is called
      * after the response header processing is complete.
      */
@@ -64,10 +64,10 @@ public interface OutputFilter extends OutputBuffer {
     /**
      * End the current request. It is acceptable to write extra bytes using
      * buffer.doWrite during the execution of this method.
-     * 
-     * @return Should return 0 unless the filter does some content length 
+     *
+     * @return Should return 0 unless the filter does some content length
      * delimitation, in which case the number is the amount of extra bytes or
-     * missing bytes, which would indicate an error. 
+     * missing bytes, which would indicate an error.
      * Note: It is recommended that extra bytes be swallowed by the filter.
      */
     public long end()

==================================================
ChunkedInputFilter.java
index 55186d008f..077787be07 100644
--- a/java/org/apache/coyote/http11/filters/BufferedInputFilter.java
+++ b/java/org/apache/coyote/http11/filters/BufferedInputFilter.java
@@ -137,5 +137,5 @@ public class BufferedInputFilter implements InputFilter {
     public int available() {
         return buffered.getLength();
     }
-    
+
 }

==================================================
ChunkedOutputFilter.java
index 180924e0c7..caf0e69a18 100644
--- a/java/org/apache/coyote/http11/filters/ChunkedInputFilter.java
+++ b/java/org/apache/coyote/http11/filters/ChunkedInputFilter.java
@@ -33,7 +33,7 @@ import org.apache.tomcat.util.http.MimeHeaders;
 /**
  * Chunked input filter. Parses chunked data according to
  * <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.6.1">http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.6.1</a><br>
- * 
+ *
  * @author Remy Maucherat
  * @author Filip Hanik
  */
@@ -117,7 +117,7 @@ public class ChunkedInputFilter implements InputFilter {
      * Request being parsed.
      */
     private Request request;
-    
+
     // ----------------------------------------------------------- Constructors
     public ChunkedInputFilter(int maxTrailerSize) {
         this.trailingHeaders.setLimit(maxTrailerSize);
@@ -128,10 +128,10 @@ public class ChunkedInputFilter implements InputFilter {
 
     /**
      * Read bytes.
-     * 
+     *
      * @return If the filter does request length control, this value is
      * significant; it should be the number of bytes consumed from the buffer,
-     * up until the end of the current request body, or the buffer length, 
+     * up until the end of the current request body, or the buffer length,
      * whichever is greater. If the filter does not do request body length
      * control, the returned value should be -1.
      */
@@ -174,7 +174,7 @@ public class ChunkedInputFilter implements InputFilter {
             pos = pos + remaining;
             remaining = 0;
             //we need a CRLF
-            if ((pos+1) >= lastValid) {   
+            if ((pos+1) >= lastValid) {
                 //if we call parseCRLF we overrun the buffer here
                 //so we defer it to the next call BZ 11117
                 needCRLFParse = true;
@@ -225,7 +225,7 @@ public class ChunkedInputFilter implements InputFilter {
     public int available() {
         return (lastValid - pos);
     }
-    
+
 
     /**
      * Set the next buffer in the filter pipeline.
@@ -250,7 +250,7 @@ public class ChunkedInputFilter implements InputFilter {
 
 
     /**
-     * Return the name of the associated encoding; Here, the value is 
+     * Return the name of the associated encoding; Here, the value is
      * "identity".
      */
     @Override
@@ -280,10 +280,10 @@ public class ChunkedInputFilter implements InputFilter {
 
     /**
      * Parse the header of a chunk.
-     * A chunk header can look like 
+     * A chunk header can look like
      * A10CRLF
      * F23;chunk-extension to be ignoredCRLF
-     * The letters before CRLF but after the trailer mark, must be valid hex digits, 
+     * The letters before CRLF but after the trailer mark, must be valid hex digits,
      * we should not parse F23IAMGONNAMESSTHISUP34CRLF as a valid header
      * according to spec
      */
@@ -303,12 +303,12 @@ public class ChunkedInputFilter implements InputFilter {
             }
 
             if (buf[pos] == Constants.CR) {
-                // FIXME: Improve parsing to check for CRLF 
+                // FIXME: Improve parsing to check for CRLF
             } else if (buf[pos] == Constants.LF) {
                 eol = true;
             } else if (buf[pos] == Constants.SEMI_COLON) {
                 trailer = true;
-            } else if (!trailer) { 
+            } else if (!trailer) {
                 //don't read data after the trailer
                 if (HexUtils.getDec(buf[pos]) != -1) {
                     readDigit = true;
@@ -386,7 +386,7 @@ public class ChunkedInputFilter implements InputFilter {
         }
     }
 
-    
+
     private boolean parseHeader() throws IOException {
 
         MimeHeaders headers = request.getMimeHeaders();
@@ -400,7 +400,7 @@ public class ChunkedInputFilter implements InputFilter {
             }
 
             chr = buf[pos];
-    
+
             if ((chr == Constants.CR) || (chr == Constants.LF)) {
                 if (chr == Constants.LF) {
                     pos++;
@@ -409,28 +409,28 @@ public class ChunkedInputFilter implements InputFilter {
             } else {
                 break;
             }
-    
+
             pos++;
-    
+
         }
-    
+
         // Mark the current buffer position
         int start = trailingHeaders.getEnd();
-    
+
         //
         // Reading the header name
         // Header name is always US-ASCII
         //
-    
+
         boolean colon = false;
         while (!colon) {
-    
+
             // Read new bytes if needed
             if (pos >= lastValid) {
                 if (readBytes() <0)
                     throw new EOFException("Unexpected end of stream whilst reading trailer headers for chunked request");
             }
-    
+
             chr = buf[pos];
             if ((chr >= Constants.A) && (chr <= Constants.Z)) {
                 chr = (byte) (chr - Constants.LC_OFFSET);
@@ -441,55 +441,55 @@ public class ChunkedInputFilter implements InputFilter {
             } else {
                 trailingHeaders.append(chr);
             }
-    
+
             pos++;
-    
+
         }
         MessageBytes headerValue = headers.addValue(trailingHeaders.getBytes(),
                 start, trailingHeaders.getEnd() - start);
-    
+
         // Mark the current buffer position
         start = trailingHeaders.getEnd();
 
         //
         // Reading the header value (which can be spanned over multiple lines)
         //
-    
+
         boolean eol = false;
         boolean validLine = true;
         int lastSignificantChar = 0;
-    
+
         while (validLine) {
-    
+
             boolean space = true;
-    
+
             // Skipping spaces
             while (space) {
-    
+
                 // Read new bytes if needed
                 if (pos >= lastValid) {
                     if (readBytes() <0)
                         throw new EOFException("Unexpected end of stream whilst reading trailer headers for chunked request");
                 }
-    
+
                 chr = buf[pos];
                 if ((chr == Constants.SP) || (chr == Constants.HT)) {
                     pos++;
                 } else {
                     space = false;
                 }
-    
+
             }
-    
+
             // Reading bytes until the end of the line
             while (!eol) {
-    
+
                 // Read new bytes if needed
                 if (pos >= lastValid) {
                     if (readBytes() <0)
                         throw new EOFException("Unexpected end of stream whilst reading trailer headers for chunked request");
                 }
-    
+
                 chr = buf[pos];
                 if (chr == Constants.CR) {
                     // Skip
@@ -501,20 +501,20 @@ public class ChunkedInputFilter implements InputFilter {
                     trailingHeaders.append(chr);
                     lastSignificantChar = trailingHeaders.getEnd();
                 }
-    
+
                 pos++;
-    
+
             }
-    
+
             // Checking the first character of the new line. If the character
             // is a LWS, then it's a multiline header
-    
+
             // Read new bytes if needed
             if (pos >= lastValid) {
                 if (readBytes() <0)
                     throw new EOFException("Unexpected end of stream whilst reading trailer headers for chunked request");
             }
-    
+
             chr = buf[pos];
             if ((chr != Constants.SP) && (chr != Constants.HT)) {
                 validLine = false;
@@ -524,13 +524,13 @@ public class ChunkedInputFilter implements InputFilter {
                 // be at least one space inserted between the lines)
                 trailingHeaders.append(chr);
             }
-    
+
         }
-    
+
         // Set the header value
         headerValue.setBytes(trailingHeaders.getBytes(), start,
                 lastSignificantChar - start);
-    
+
         return true;
     }
 }

==================================================
FlushableGZIPOutputStream.java
index 797f3e830e..6e2c7f983c 100644
--- a/java/org/apache/coyote/http11/filters/ChunkedOutputFilter.java
+++ b/java/org/apache/coyote/http11/filters/ChunkedOutputFilter.java
@@ -27,7 +27,7 @@ import org.apache.tomcat.util.buf.HexUtils;
 
 /**
  * Chunked output filter.
- * 
+ *
  * @author Remy Maucherat
  */
 public class ChunkedOutputFilter implements OutputFilter {
@@ -44,7 +44,7 @@ public class ChunkedOutputFilter implements OutputFilter {
 
 
     static {
-        byte[] END_CHUNK_BYTES = {(byte) '0', (byte) '\r', (byte) '\n', 
+        byte[] END_CHUNK_BYTES = {(byte) '0', (byte) '\r', (byte) '\n',
                                   (byte) '\r', (byte) '\n'};
         END_CHUNK.setBytes(END_CHUNK_BYTES, 0, END_CHUNK_BYTES.length);
     }
@@ -92,7 +92,7 @@ public class ChunkedOutputFilter implements OutputFilter {
 
     /**
      * Write some bytes.
-     * 
+     *
      * @return number of bytes written by the filter
      */
     @Override
@@ -136,7 +136,7 @@ public class ChunkedOutputFilter implements OutputFilter {
 
 
     /**
-     * Some filters need additional parameters from the response. All the 
+     * Some filters need additional parameters from the response. All the
      * necessary reading can occur in that method, as this method is called
      * after the response header processing is complete.
      */
@@ -165,7 +165,7 @@ public class ChunkedOutputFilter implements OutputFilter {
 
         // Write end chunk
         buffer.doWrite(END_CHUNK, null);
-        
+
         return 0;
 
     }

==================================================
GzipOutputFilter.java
index 1656a9c281..3056d69a6a 100644
--- a/java/org/apache/coyote/http11/filters/FlushableGZIPOutputStream.java
+++ b/java/org/apache/coyote/http11/filters/FlushableGZIPOutputStream.java
@@ -28,7 +28,7 @@ import java.util.zip.GZIPOutputStream;
  * (<a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4255743">Bug
  * 4255743</a> and
  * <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4813885">Bug
- * 4813885</a>) so the GZIP'd output can be flushed. 
+ * 4813885</a>) so the GZIP'd output can be flushed.
  */
 public class FlushableGZIPOutputStream extends GZIPOutputStream {
     public FlushableGZIPOutputStream(OutputStream os) throws IOException {

==================================================
IdentityInputFilter.java
index a7071f88ee..20ba495b7d 100644
--- a/java/org/apache/coyote/http11/filters/GzipOutputFilter.java
+++ b/java/org/apache/coyote/http11/filters/GzipOutputFilter.java
@@ -28,7 +28,7 @@ import org.apache.tomcat.util.buf.ByteChunk;
 
 /**
  * Gzip output filter.
- * 
+ *
  * @author Remy Maucherat
  */
 public class GzipOutputFilter implements OutputFilter {
@@ -67,7 +67,7 @@ public class GzipOutputFilter implements OutputFilter {
 
     /**
      * Write some bytes.
-     * 
+     *
      * @return number of bytes written by the filter
      */
     @Override
@@ -76,7 +76,7 @@ public class GzipOutputFilter implements OutputFilter {
         if (compressionStream == null) {
             compressionStream = new FlushableGZIPOutputStream(fakeOutputStream);
         }
-        compressionStream.write(chunk.getBytes(), chunk.getStart(), 
+        compressionStream.write(chunk.getBytes(), chunk.getStart(),
                                 chunk.getLength());
         return chunk.getLength();
     }
@@ -109,7 +109,7 @@ public class GzipOutputFilter implements OutputFilter {
     }
 
     /**
-     * Some filters need additional parameters from the response. All the 
+     * Some filters need additional parameters from the response. All the
      * necessary reading can occur in that method, as this method is called
      * after the response header processing is complete.
      */
@@ -164,7 +164,7 @@ public class GzipOutputFilter implements OutputFilter {
         @Override
         public void write(int b)
             throws IOException {
-            // Shouldn't get used for good performance, but is needed for 
+            // Shouldn't get used for good performance, but is needed for
             // compatibility with Sun JDK 1.4.0
             singleByteBuffer[0] = (byte) (b & 0xff);
             outputChunk.setBytes(singleByteBuffer, 0, 1);

==================================================
IdentityOutputFilter.java
index 666afa251a..e8fd8f5fd3 100644
--- a/java/org/apache/coyote/http11/filters/IdentityInputFilter.java
+++ b/java/org/apache/coyote/http11/filters/IdentityInputFilter.java
@@ -27,7 +27,7 @@ import org.apache.tomcat.util.buf.ByteChunk;
 
 /**
  * Identity input filter.
- * 
+ *
  * @author Remy Maucherat
  */
 public class IdentityInputFilter implements InputFilter {
@@ -100,10 +100,10 @@ public class IdentityInputFilter implements InputFilter {
 
     /**
      * Read bytes.
-     * 
+     *
      * @return If the filter does request length control, this value is
      * significant; it should be the number of bytes consumed from the buffer,
-     * up until the end of the current request body, or the buffer length, 
+     * up until the end of the current request body, or the buffer length,
      * whichever is greater. If the filter does not do request body length
      * control, the returned value should be -1.
      */
@@ -120,7 +120,7 @@ public class IdentityInputFilter implements InputFilter {
                     // The chunk is longer than the number of bytes remaining
                     // in the body; changing the chunk length to the number
                     // of bytes remaining
-                    chunk.setBytes(chunk.getBytes(), chunk.getStart(), 
+                    chunk.setBytes(chunk.getBytes(), chunk.getStart(),
                                    (int) remaining);
                     result = (int) remaining;
                 } else {
@@ -128,7 +128,7 @@ public class IdentityInputFilter implements InputFilter {
                 }
                 remaining = remaining - nRead;
             } else {
-                // No more bytes left to be read : return -1 and clear the 
+                // No more bytes left to be read : return -1 and clear the
                 // buffer
                 chunk.recycle();
                 result = -1;
@@ -183,7 +183,7 @@ public class IdentityInputFilter implements InputFilter {
     public int available() {
         return 0;
     }
-    
+
 
     /**
      * Set the next buffer in the filter pipeline.
@@ -206,7 +206,7 @@ public class IdentityInputFilter implements InputFilter {
 
 
     /**
-     * Return the name of the associated encoding; Here, the value is 
+     * Return the name of the associated encoding; Here, the value is
      * "identity".
      */
     @Override

==================================================
SavedRequestInputFilter.java
index 83912a44b8..0f782316d9 100644
--- a/java/org/apache/coyote/http11/filters/IdentityOutputFilter.java
+++ b/java/org/apache/coyote/http11/filters/IdentityOutputFilter.java
@@ -26,7 +26,7 @@ import org.apache.tomcat.util.buf.ByteChunk;
 
 /**
  * Identity output filter.
- * 
+ *
  * @author Remy Maucherat
  */
 public class IdentityOutputFilter implements OutputFilter {
@@ -58,7 +58,7 @@ public class IdentityOutputFilter implements OutputFilter {
 
     /**
      * Write some bytes.
-     * 
+     *
      * @return number of bytes written by the filter
      */
     @Override
@@ -74,7 +74,7 @@ public class IdentityOutputFilter implements OutputFilter {
                     // The chunk is longer than the number of bytes remaining
                     // in the body; changing the chunk length to the number
                     // of bytes remaining
-                    chunk.setBytes(chunk.getBytes(), chunk.getStart(), 
+                    chunk.setBytes(chunk.getBytes(), chunk.getStart(),
                                    (int) remaining);
                     result = (int) remaining;
                     remaining = 0;
@@ -83,7 +83,7 @@ public class IdentityOutputFilter implements OutputFilter {
                 }
                 buffer.doWrite(chunk, res);
             } else {
-                // No more bytes left to be written : return -1 and clear the 
+                // No more bytes left to be written : return -1 and clear the
                 // buffer
                 chunk.recycle();
                 result = -1;
@@ -109,7 +109,7 @@ public class IdentityOutputFilter implements OutputFilter {
 
 
     /**
-     * Some filters need additional parameters from the response. All the 
+     * Some filters need additional parameters from the response. All the
      * necessary reading can occur in that method, as this method is called
      * after the response header processing is complete.
      */

==================================================
VoidInputFilter.java
index 33289ba498..97c818918a 100644
--- a/java/org/apache/coyote/http11/filters/SavedRequestInputFilter.java
+++ b/java/org/apache/coyote/http11/filters/SavedRequestInputFilter.java
@@ -36,7 +36,7 @@ public class SavedRequestInputFilter implements InputFilter {
 
     /**
      * Create a new SavedRequestInputFilter.
-     * 
+     *
      * @param input The saved request body to be replayed.
      */
     public SavedRequestInputFilter(ByteChunk input) {
@@ -50,20 +50,20 @@ public class SavedRequestInputFilter implements InputFilter {
     public int doRead(ByteChunk chunk, org.apache.coyote.Request request)
             throws IOException {
         int writeLength = 0;
-        
+
         if (chunk.getLimit() > 0 && chunk.getLimit() < input.getLength()) {
             writeLength = chunk.getLimit();
         } else {
             writeLength = input.getLength();
         }
-        
+
         if(input.getOffset()>= input.getEnd())
             return -1;
-        
+
         input.substract(chunk.getBuffer(), 0, writeLength);
         chunk.setOffset(0);
         chunk.setEnd(writeLength);
-        
+
         return writeLength;
     }
 
@@ -106,7 +106,7 @@ public class SavedRequestInputFilter implements InputFilter {
     public int available() {
         return input.getLength();
     }
-    
+
     /**
      * End the current request (has no effect).
      */

==================================================
VoidOutputFilter.java
index aea2bdbcab..25f21f8ac4 100644
--- a/java/org/apache/coyote/http11/filters/VoidInputFilter.java
+++ b/java/org/apache/coyote/http11/filters/VoidInputFilter.java
@@ -28,7 +28,7 @@ import org.apache.tomcat.util.buf.ByteChunk;
 /**
  * Void input filter, which returns -1 when attempting a read. Used with a GET,
  * HEAD, or a similar request.
- * 
+ *
  * @author Remy Maucherat
  */
 public class VoidInputFilter implements InputFilter {
@@ -58,7 +58,7 @@ public class VoidInputFilter implements InputFilter {
 
     /**
      * Write some bytes.
-     * 
+     *
      * @return number of bytes written by the filter
      */
     @Override
@@ -101,7 +101,7 @@ public class VoidInputFilter implements InputFilter {
 
 
     /**
-     * Return the name of the associated encoding; Here, the value is 
+     * Return the name of the associated encoding; Here, the value is
      * "void".
      */
     @Override
@@ -113,10 +113,10 @@ public class VoidInputFilter implements InputFilter {
     /**
      * End the current request. It is acceptable to write extra bytes using
      * buffer.doWrite during the execution of this method.
-     * 
-     * @return Should return 0 unless the filter does some content length 
+     *
+     * @return Should return 0 unless the filter does some content length
      * delimitation, in which case the number is the amount of extra bytes or
-     * missing bytes, which would indicate an error. 
+     * missing bytes, which would indicate an error.
      * Note: It is recommended that extra bytes be swallowed by the filter.
      */
     @Override
@@ -133,5 +133,5 @@ public class VoidInputFilter implements InputFilter {
     public int available() {
         return 0;
     }
-    
+
 }

==================================================
