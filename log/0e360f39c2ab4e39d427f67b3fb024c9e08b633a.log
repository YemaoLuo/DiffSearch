0e360f39c2ab4e39d427f67b3fb024c9e08b633a
==================================================
Update license header in TC6 trunk to comply with:
==================================================
Mark Emlyn
==================================================
Sat Oct 21 23:30:39 2006 +0000
==================================================
Generated.java
Update license header in TC6 trunk to comply with:
http://www.apache.org/legal/src-headers.html#headers

It does compile but I need to check the commit message carefully to ensure the script hasn't changed anything it shouldn't have done.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/tc6.0.x/trunk@466609 13f79535-47bb-0310-9956-ffa450edef68



==================================================
PostConstruct.java
index 409435ddd8..d4721db26a 100644
--- a/java/javax/annotation/Generated.java
+++ b/java/javax/annotation/Generated.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
PreDestroy.java
index 11ce7878a9..94a7aa758b 100644
--- a/java/javax/annotation/PostConstruct.java
+++ b/java/javax/annotation/PostConstruct.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Resource.java
index 2020298c51..c453edd535 100644
--- a/java/javax/annotation/PreDestroy.java
+++ b/java/javax/annotation/PreDestroy.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Resources.java
index f58b8cfd03..7510565c5f 100644
--- a/java/javax/annotation/Resource.java
+++ b/java/javax/annotation/Resource.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
DeclareRoles.java
index 96b8d3e0b4..4b398f2aff 100644
--- a/java/javax/annotation/Resources.java
+++ b/java/javax/annotation/Resources.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
DenyAll.java
index 95f8aa1944..d5d214aee5 100644
--- a/java/javax/annotation/security/DeclareRoles.java
+++ b/java/javax/annotation/security/DeclareRoles.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
PermitAll.java
index dfc2051d46..c16550a9d3 100644
--- a/java/javax/annotation/security/DenyAll.java
+++ b/java/javax/annotation/security/DenyAll.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
RolesAllowed.java
index c34a34e4db..f666c84643 100644
--- a/java/javax/annotation/security/PermitAll.java
+++ b/java/javax/annotation/security/PermitAll.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
RunAs.java
index a8d7a50a25..fced7619a3 100644
--- a/java/javax/annotation/security/RolesAllowed.java
+++ b/java/javax/annotation/security/RolesAllowed.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
EJB.java
index e59bb1cc39..3920d7c601 100644
--- a/java/javax/annotation/security/RunAs.java
+++ b/java/javax/annotation/security/RunAs.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
EJBs.java
index 0a4e445566..ccbc04327b 100644
--- a/java/javax/ejb/EJB.java
+++ b/java/javax/ejb/EJB.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ArrayELResolver.java
index 50ed5d9298..3f752f9f57 100644
--- a/java/javax/ejb/EJBs.java
+++ b/java/javax/ejb/EJBs.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
BeanELResolver.java
index 6569f435c9..b5b633a794 100644
--- a/java/javax/el/ArrayELResolver.java
+++ b/java/javax/el/ArrayELResolver.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
CompositeELResolver.java
index ea2ae8b993..109f6cea21 100644
--- a/java/javax/el/BeanELResolver.java
+++ b/java/javax/el/BeanELResolver.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ELContext.java
index 6d64eb2c4a..aba91dd884 100644
--- a/java/javax/el/CompositeELResolver.java
+++ b/java/javax/el/CompositeELResolver.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ELContextEvent.java
index 6d6890d479..db59394659 100644
--- a/java/javax/el/ELContext.java
+++ b/java/javax/el/ELContext.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ELContextListener.java
index 8f8607265d..6c5c17e688 100644
--- a/java/javax/el/ELContextEvent.java
+++ b/java/javax/el/ELContextEvent.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ELException.java
index 25a128a023..a21038b81c 100644
--- a/java/javax/el/ELContextListener.java
+++ b/java/javax/el/ELContextListener.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ELResolver.java
index d1e1952112..935a8a207f 100644
--- a/java/javax/el/ELException.java
+++ b/java/javax/el/ELException.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Expression.java
index de01d8cbba..0b3b90afdd 100644
--- a/java/javax/el/ELResolver.java
+++ b/java/javax/el/ELResolver.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ExpressionFactory.java
index ed1a2e5feb..8d9d7ec83c 100644
--- a/java/javax/el/Expression.java
+++ b/java/javax/el/Expression.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
FunctionMapper.java
index 53e340b575..16d51ed19c 100644
--- a/java/javax/el/ExpressionFactory.java
+++ b/java/javax/el/ExpressionFactory.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ListELResolver.java
index 09f55b94e5..666a76cc42 100644
--- a/java/javax/el/FunctionMapper.java
+++ b/java/javax/el/FunctionMapper.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
MapELResolver.java
index 23726c0014..22bc1e4fe9 100644
--- a/java/javax/el/LocalStrings.properties
+++ b/java/javax/el/LocalStrings.properties
@@ -1,8 +1,9 @@
-# Copyright 2004 The Apache Software Foundation
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
 #
 #     http://www.apache.org/licenses/LICENSE-2.0
 #

==================================================
MethodExpression.java
index fb8622c6c3..5f83474283 100644
--- a/java/javax/el/MapELResolver.java
+++ b/java/javax/el/MapELResolver.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
MethodInfo.java
index 90b0d60a83..0b566fcfa2 100644
--- a/java/javax/el/MethodExpression.java
+++ b/java/javax/el/MethodExpression.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
MethodNotFoundException.java
index 3aa3fa2c46..8047e259cb 100644
--- a/java/javax/el/MethodInfo.java
+++ b/java/javax/el/MethodInfo.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
PropertyNotFoundException.java
index f4389de1aa..cd69ce1f6a 100644
--- a/java/javax/el/MethodNotFoundException.java
+++ b/java/javax/el/MethodNotFoundException.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
PropertyNotWritableException.java
index 3ded8904b7..2480999d8c 100644
--- a/java/javax/el/PropertyNotFoundException.java
+++ b/java/javax/el/PropertyNotFoundException.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ResourceBundleELResolver.java
index ee4a0e32cf..912ab9b0ba 100644
--- a/java/javax/el/PropertyNotWritableException.java
+++ b/java/javax/el/PropertyNotWritableException.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ValueExpression.java
index 0affb5c69c..0f1a6bb10e 100644
--- a/java/javax/el/ResourceBundleELResolver.java
+++ b/java/javax/el/ResourceBundleELResolver.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
VariableMapper.java
index b4fc413d66..e501a9ed33 100644
--- a/java/javax/el/ValueExpression.java
+++ b/java/javax/el/ValueExpression.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
PersistenceContext.java
index 3ee6ca2829..84c3682230 100644
--- a/java/javax/el/VariableMapper.java
+++ b/java/javax/el/VariableMapper.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
PersistenceContexts.java
index 80d58f306f..aaa697bc1b 100644
--- a/java/javax/persistence/PersistenceContext.java
+++ b/java/javax/persistence/PersistenceContext.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
PersistenceUnit.java
index dcbd68bdb6..d451f24899 100644
--- a/java/javax/persistence/PersistenceContexts.java
+++ b/java/javax/persistence/PersistenceContexts.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
PersistenceUnits.java
index 1b150ecb9a..e42a3b2600 100644
--- a/java/javax/persistence/PersistenceUnit.java
+++ b/java/javax/persistence/PersistenceUnit.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Filter.java
index 8a00831a55..0d3cf24170 100644
--- a/java/javax/persistence/PersistenceUnits.java
+++ b/java/javax/persistence/PersistenceUnits.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
FilterChain.java
index db6d6b7e7c..99eae03bae 100644
--- a/java/javax/servlet/Filter.java
+++ b/java/javax/servlet/Filter.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
FilterConfig.java
index d6210d5e5d..03ba454490 100644
--- a/java/javax/servlet/FilterChain.java
+++ b/java/javax/servlet/FilterChain.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
GenericServlet.java
index 05c609d3b5..e1ef616c78 100644
--- a/java/javax/servlet/FilterConfig.java
+++ b/java/javax/servlet/FilterConfig.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
RequestDispatcher.java
index 4ed3709f91..2a87482d72 100644
--- a/java/javax/servlet/LocalStrings_ja.properties
+++ b/java/javax/servlet/LocalStrings_ja.properties
@@ -1,8 +1,9 @@
-# Copyright 2004 The Apache Software Foundation
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
 #
 #     http://www.apache.org/licenses/LICENSE-2.0
 #

==================================================
Servlet.java
index 1993728e7e..a9e79b270c 100644
--- a/java/javax/servlet/RequestDispatcher.java
+++ b/java/javax/servlet/RequestDispatcher.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
ServletConfig.java
index 3d568deb59..6dae418a15 100644
--- a/java/javax/servlet/Servlet.java
+++ b/java/javax/servlet/Servlet.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
ServletContext.java
index e5f9b1b6ec..dea6bbd5ec 100644
--- a/java/javax/servlet/ServletConfig.java
+++ b/java/javax/servlet/ServletConfig.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
ServletContextAttributeEvent.java
index 855d62c1f6..cb32eb8574 100644
--- a/java/javax/servlet/ServletContext.java
+++ b/java/javax/servlet/ServletContext.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
ServletContextAttributeListener.java
index e7af9a9da2..2ae4936740 100644
--- a/java/javax/servlet/ServletContextAttributeEvent.java
+++ b/java/javax/servlet/ServletContextAttributeEvent.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
ServletContextEvent.java
index 3d8b938fa3..fcb5575f03 100644
--- a/java/javax/servlet/ServletContextAttributeListener.java
+++ b/java/javax/servlet/ServletContextAttributeListener.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
ServletContextListener.java
index cb7b8878c1..7137596567 100644
--- a/java/javax/servlet/ServletContextEvent.java
+++ b/java/javax/servlet/ServletContextEvent.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
ServletException.java
index 693d2c16eb..e4b01641c3 100644
--- a/java/javax/servlet/ServletContextListener.java
+++ b/java/javax/servlet/ServletContextListener.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
ServletInputStream.java
index 29533cb0fd..59b4044c02 100644
--- a/java/javax/servlet/ServletException.java
+++ b/java/javax/servlet/ServletException.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
ServletOutputStream.java
index bcc3a45d6c..a29c8082ef 100644
--- a/java/javax/servlet/ServletInputStream.java
+++ b/java/javax/servlet/ServletInputStream.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
ServletRequest.java
index 865b1d192d..c1b7281fe5 100644
--- a/java/javax/servlet/ServletOutputStream.java
+++ b/java/javax/servlet/ServletOutputStream.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
ServletRequestAttributeEvent.java
index a2cf60de67..39b359ff78 100644
--- a/java/javax/servlet/ServletRequest.java
+++ b/java/javax/servlet/ServletRequest.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
ServletRequestAttributeListener.java
index 8ca9eb457d..98a5861ff6 100644
--- a/java/javax/servlet/ServletRequestAttributeEvent.java
+++ b/java/javax/servlet/ServletRequestAttributeEvent.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
ServletRequestEvent.java
index b68bbc5cfd..8d65fa12ff 100644
--- a/java/javax/servlet/ServletRequestAttributeListener.java
+++ b/java/javax/servlet/ServletRequestAttributeListener.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
ServletRequestListener.java
index a75b213627..d395029070 100644
--- a/java/javax/servlet/ServletRequestEvent.java
+++ b/java/javax/servlet/ServletRequestEvent.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
ServletRequestWrapper.java
index 3518b19ba2..4ac7055da0 100644
--- a/java/javax/servlet/ServletRequestListener.java
+++ b/java/javax/servlet/ServletRequestListener.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
ServletResponse.java
index d5f232e9b4..aa80a8f50d 100644
--- a/java/javax/servlet/ServletRequestWrapper.java
+++ b/java/javax/servlet/ServletRequestWrapper.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
ServletResponseWrapper.java
index 770d9a090f..b9427d7a32 100644
--- a/java/javax/servlet/ServletResponse.java
+++ b/java/javax/servlet/ServletResponse.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
SingleThreadModel.java
index 7a95e28c64..9358ca71d8 100644
--- a/java/javax/servlet/ServletResponseWrapper.java
+++ b/java/javax/servlet/ServletResponseWrapper.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
UnavailableException.java
index 646ff0270c..ea2e92c906 100644
--- a/java/javax/servlet/SingleThreadModel.java
+++ b/java/javax/servlet/SingleThreadModel.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
Cookie.java
index cc0d7e55d3..dde2dea8a4 100644
--- a/java/javax/servlet/UnavailableException.java
+++ b/java/javax/servlet/UnavailableException.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
HttpServlet.java
index 7cbc6b46c9..7c62f606e8 100644
--- a/java/javax/servlet/http/Cookie.java
+++ b/java/javax/servlet/http/Cookie.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
HttpServletRequest.java
index 08479b9f6b..43b4c690c3 100644
--- a/java/javax/servlet/http/HttpServlet.java
+++ b/java/javax/servlet/http/HttpServlet.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
HttpServletRequestWrapper.java
index c0a5d36ee4..50b5d4f921 100644
--- a/java/javax/servlet/http/HttpServletRequest.java
+++ b/java/javax/servlet/http/HttpServletRequest.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
HttpServletResponse.java
index 361e38f46c..28cc3a98c8 100644
--- a/java/javax/servlet/http/HttpServletRequestWrapper.java
+++ b/java/javax/servlet/http/HttpServletRequestWrapper.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
HttpServletResponseWrapper.java
index 617905020f..33502643d1 100644
--- a/java/javax/servlet/http/HttpServletResponse.java
+++ b/java/javax/servlet/http/HttpServletResponse.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
HttpSession.java
index 751e4bcf34..6563b7b399 100644
--- a/java/javax/servlet/http/HttpServletResponseWrapper.java
+++ b/java/javax/servlet/http/HttpServletResponseWrapper.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
HttpSessionActivationListener.java
index 2957975955..0aa4e5ffad 100644
--- a/java/javax/servlet/http/HttpSession.java
+++ b/java/javax/servlet/http/HttpSession.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
HttpSessionAttributeListener.java
index 95963ae297..99a9f03db1 100644
--- a/java/javax/servlet/http/HttpSessionActivationListener.java
+++ b/java/javax/servlet/http/HttpSessionActivationListener.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
HttpSessionBindingEvent.java
index b70e9f58c1..95257a777d 100644
--- a/java/javax/servlet/http/HttpSessionAttributeListener.java
+++ b/java/javax/servlet/http/HttpSessionAttributeListener.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
HttpSessionBindingListener.java
index 5e84f32cf3..36c2fd2dce 100644
--- a/java/javax/servlet/http/HttpSessionBindingEvent.java
+++ b/java/javax/servlet/http/HttpSessionBindingEvent.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
HttpSessionContext.java
index a07674409f..852b2fa017 100644
--- a/java/javax/servlet/http/HttpSessionBindingListener.java
+++ b/java/javax/servlet/http/HttpSessionBindingListener.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
HttpSessionEvent.java
index dd7bfe6e4a..3810aba53e 100644
--- a/java/javax/servlet/http/HttpSessionContext.java
+++ b/java/javax/servlet/http/HttpSessionContext.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
HttpSessionListener.java
index 8aa85f9a50..c64359bbff 100644
--- a/java/javax/servlet/http/HttpSessionEvent.java
+++ b/java/javax/servlet/http/HttpSessionEvent.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
HttpUtils.java
index b1a9224811..0b2fa78bb8 100644
--- a/java/javax/servlet/http/HttpSessionListener.java
+++ b/java/javax/servlet/http/HttpSessionListener.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
ErrorData.java
index edfbdd51da..70983d785a 100644
--- a/java/javax/servlet/http/LocalStrings_ja.properties
+++ b/java/javax/servlet/http/LocalStrings_ja.properties
@@ -1,8 +1,9 @@
-# Copyright 2004 The Apache Software Foundation
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
 #
 #     http://www.apache.org/licenses/LICENSE-2.0
 #

==================================================
HttpJspPage.java
index e36c073017..78f41d1d08 100644
--- a/java/javax/servlet/jsp/ErrorData.java
+++ b/java/javax/servlet/jsp/ErrorData.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
JspApplicationContext.java
index 50cd1475dd..685caf8339 100644
--- a/java/javax/servlet/jsp/HttpJspPage.java
+++ b/java/javax/servlet/jsp/HttpJspPage.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
JspContext.java
index 252ac23a02..5533f32f92 100644
--- a/java/javax/servlet/jsp/JspApplicationContext.java
+++ b/java/javax/servlet/jsp/JspApplicationContext.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
JspEngineInfo.java
index 0d2e394d69..8b19b4fd3f 100644
--- a/java/javax/servlet/jsp/JspContext.java
+++ b/java/javax/servlet/jsp/JspContext.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
JspException.java
index 736f00eff3..0c6ca67b0b 100644
--- a/java/javax/servlet/jsp/JspEngineInfo.java
+++ b/java/javax/servlet/jsp/JspEngineInfo.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
JspFactory.java
index e2eb9443e7..6d0f172547 100644
--- a/java/javax/servlet/jsp/JspException.java
+++ b/java/javax/servlet/jsp/JspException.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
JspPage.java
index 5d3003fc36..2fe511f4cb 100644
--- a/java/javax/servlet/jsp/JspFactory.java
+++ b/java/javax/servlet/jsp/JspFactory.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
JspTagException.java
index e93074d7e4..75cfcce896 100644
--- a/java/javax/servlet/jsp/JspPage.java
+++ b/java/javax/servlet/jsp/JspPage.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
JspWriter.java
index 35d8769401..5f37b3f656 100644
--- a/java/javax/servlet/jsp/JspTagException.java
+++ b/java/javax/servlet/jsp/JspTagException.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
PageContext.java
index b11050d30a..b001c4e2b8 100644
--- a/java/javax/servlet/jsp/JspWriter.java
+++ b/java/javax/servlet/jsp/JspWriter.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
SkipPageException.java
index b1906192d1..d83f463c2b 100644
--- a/java/javax/servlet/jsp/PageContext.java
+++ b/java/javax/servlet/jsp/PageContext.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
ELException.java
index b0ea0cd42e..a8001f8ade 100644
--- a/java/javax/servlet/jsp/SkipPageException.java
+++ b/java/javax/servlet/jsp/SkipPageException.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
ELParseException.java
index 3d3b796b0d..bc6e8eebc2 100644
--- a/java/javax/servlet/jsp/el/ELException.java
+++ b/java/javax/servlet/jsp/el/ELException.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
Expression.java
index 901f2720da..e2c4ac04f8 100644
--- a/java/javax/servlet/jsp/el/ELParseException.java
+++ b/java/javax/servlet/jsp/el/ELParseException.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
ExpressionEvaluator.java
index 78e3603ee8..bd2ba574fe 100644
--- a/java/javax/servlet/jsp/el/Expression.java
+++ b/java/javax/servlet/jsp/el/Expression.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
FunctionMapper.java
index 48c61634c2..72c26a0e2d 100644
--- a/java/javax/servlet/jsp/el/ExpressionEvaluator.java
+++ b/java/javax/servlet/jsp/el/ExpressionEvaluator.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
ImplicitObjectELResolver.java
index f518eaf952..a8568c3149 100644
--- a/java/javax/servlet/jsp/el/FunctionMapper.java
+++ b/java/javax/servlet/jsp/el/FunctionMapper.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
ScopedAttributeELResolver.java
index 5534267981..86b85a0d54 100644
--- a/java/javax/servlet/jsp/el/ImplicitObjectELResolver.java
+++ b/java/javax/servlet/jsp/el/ImplicitObjectELResolver.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2006 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
VariableResolver.java
index a9f23ffa5f..4568014046 100644
--- a/java/javax/servlet/jsp/el/ScopedAttributeELResolver.java
+++ b/java/javax/servlet/jsp/el/ScopedAttributeELResolver.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2006 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
BodyContent.java
index 8113b0906e..c99b3489cb 100755
--- a/java/javax/servlet/jsp/resources/web-jsptaglibrary_2_0.xsd
+++ b/java/javax/servlet/jsp/resources/web-jsptaglibrary_2_0.xsd
@@ -1,10 +1,11 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
-  Copyright 2004 The Apache Software Foundation
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
+ Licensed to the Apache Software Foundation (ASF) under one or more
+  contributor license agreements.  See the NOTICE file distributed with
+  this work for additional information regarding copyright ownership.
+  The ASF licenses this file to You under the Apache License, Version 2.0
+  (the "License"); you may not use this file except in compliance with
+  the License.  You may obtain a copy of the License at
 
       http://www.apache.org/licenses/LICENSE-2.0
 

==================================================
BodyTag.java
index ca09e2f1d1..a8375b8b40 100644
--- a/java/javax/servlet/jsp/tagext/BodyContent.java
+++ b/java/javax/servlet/jsp/tagext/BodyContent.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
BodyTagSupport.java
index fa2d4f4e3f..7253d20af6 100644
--- a/java/javax/servlet/jsp/tagext/BodyTag.java
+++ b/java/javax/servlet/jsp/tagext/BodyTag.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
DynamicAttributes.java
index d6bdc6b1cc..31022e88aa 100644
--- a/java/javax/servlet/jsp/tagext/BodyTagSupport.java
+++ b/java/javax/servlet/jsp/tagext/BodyTagSupport.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
FunctionInfo.java
index 6fbbc11994..be77f64436 100644
--- a/java/javax/servlet/jsp/tagext/DynamicAttributes.java
+++ b/java/javax/servlet/jsp/tagext/DynamicAttributes.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
IterationTag.java
index 1c984a3bd3..886c166ff4 100644
--- a/java/javax/servlet/jsp/tagext/FunctionInfo.java
+++ b/java/javax/servlet/jsp/tagext/FunctionInfo.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
JspFragment.java
index da643bc79a..6f4a3622e5 100644
--- a/java/javax/servlet/jsp/tagext/IterationTag.java
+++ b/java/javax/servlet/jsp/tagext/IterationTag.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
JspTag.java
index 00f52bc24c..7e46e98863 100644
--- a/java/javax/servlet/jsp/tagext/JspFragment.java
+++ b/java/javax/servlet/jsp/tagext/JspFragment.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
PageData.java
index 3e1d482451..81cdd69475 100644
--- a/java/javax/servlet/jsp/tagext/JspTag.java
+++ b/java/javax/servlet/jsp/tagext/JspTag.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
SimpleTag.java
index 50e62d6fe7..77c6f63548 100644
--- a/java/javax/servlet/jsp/tagext/PageData.java
+++ b/java/javax/servlet/jsp/tagext/PageData.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
SimpleTagSupport.java
index a9a414f7a1..25569a77e4 100644
--- a/java/javax/servlet/jsp/tagext/SimpleTag.java
+++ b/java/javax/servlet/jsp/tagext/SimpleTag.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
Tag.java
index aa730293e8..6f5559926c 100644
--- a/java/javax/servlet/jsp/tagext/SimpleTagSupport.java
+++ b/java/javax/servlet/jsp/tagext/SimpleTagSupport.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
TagAdapter.java
index 28cbcf708c..0dd3d57ff9 100644
--- a/java/javax/servlet/jsp/tagext/Tag.java
+++ b/java/javax/servlet/jsp/tagext/Tag.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
TagAttributeInfo.java
index d325f93e4d..1b309a8a93 100644
--- a/java/javax/servlet/jsp/tagext/TagAdapter.java
+++ b/java/javax/servlet/jsp/tagext/TagAdapter.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
TagData.java
index 0cabe8b8fd..20733421a4 100644
--- a/java/javax/servlet/jsp/tagext/TagAttributeInfo.java
+++ b/java/javax/servlet/jsp/tagext/TagAttributeInfo.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2004 The Apache Software Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
TagExtraInfo.java
index dbf5eea6c4..f9f4e3f411 100644
--- a/java/javax/servlet/jsp/tagext/TagData.java
+++ b/java/javax/servlet/jsp/tagext/TagData.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
TagFileInfo.java
index 78858f175a..6a50f5dd7b 100644
--- a/java/javax/servlet/jsp/tagext/TagExtraInfo.java
+++ b/java/javax/servlet/jsp/tagext/TagExtraInfo.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
TagInfo.java
index 4a93d02481..605bcca890 100644
--- a/java/javax/servlet/jsp/tagext/TagFileInfo.java
+++ b/java/javax/servlet/jsp/tagext/TagFileInfo.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
TagLibraryInfo.java
index e4d341f954..33b597feec 100644
--- a/java/javax/servlet/jsp/tagext/TagInfo.java
+++ b/java/javax/servlet/jsp/tagext/TagInfo.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
TagLibraryValidator.java
index 4667ca77f6..0c0b9e0c55 100644
--- a/java/javax/servlet/jsp/tagext/TagLibraryInfo.java
+++ b/java/javax/servlet/jsp/tagext/TagLibraryInfo.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
TagSupport.java
index a59a5f13d4..a11b125c6f 100644
--- a/java/javax/servlet/jsp/tagext/TagLibraryValidator.java
+++ b/java/javax/servlet/jsp/tagext/TagLibraryValidator.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
TagVariableInfo.java
index f1a81c3dea..20e0cfdbf5 100644
--- a/java/javax/servlet/jsp/tagext/TagSupport.java
+++ b/java/javax/servlet/jsp/tagext/TagSupport.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
TryCatchFinally.java
index ba1759fbca..145a50db78 100644
--- a/java/javax/servlet/jsp/tagext/TagVariableInfo.java
+++ b/java/javax/servlet/jsp/tagext/TagVariableInfo.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
ValidationMessage.java
index cd849eb4c6..64621f07a6 100644
--- a/java/javax/servlet/jsp/tagext/TryCatchFinally.java
+++ b/java/javax/servlet/jsp/tagext/TryCatchFinally.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
VariableInfo.java
index c544553836..90dd43a1b1 100644
--- a/java/javax/servlet/jsp/tagext/ValidationMessage.java
+++ b/java/javax/servlet/jsp/tagext/ValidationMessage.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
WebServiceRef.java
index 0bea0fda53..fb866b60fe 100644
--- a/java/javax/servlet/resources/xml.xsd
+++ b/java/javax/servlet/resources/xml.xsd
@@ -1,10 +1,11 @@
 <?xml version='1.0'?>
 <!--
-  Copyright 2004 The Apache Software Foundation
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
+ Licensed to the Apache Software Foundation (ASF) under one or more
+  contributor license agreements.  See the NOTICE file distributed with
+  this work for additional information regarding copyright ownership.
+  The ASF licenses this file to You under the Apache License, Version 2.0
+  (the "License"); you may not use this file except in compliance with
+  the License.  You may obtain a copy of the License at
 
       http://www.apache.org/licenses/LICENSE-2.0
 

==================================================
WebServiceRefs.java
index 5c60078e7c..44e5046c66 100644
--- a/java/javax/xml/ws/WebServiceRef.java
+++ b/java/javax/xml/ws/WebServiceRef.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
AnnotationProcessor.java
index c34d61383f..851b48811f 100644
--- a/java/javax/xml/ws/WebServiceRefs.java
+++ b/java/javax/xml/ws/WebServiceRefs.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
PeriodicEventListener.java
index 3912d3555a..d7af22aeca 100644
--- a/java/org/apache/AnnotationProcessor.java
+++ b/java/org/apache/AnnotationProcessor.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Authenticator.java
index 08d6c3fadd..1923085552 100644
--- a/java/org/apache/PeriodicEventListener.java
+++ b/java/org/apache/PeriodicEventListener.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Cluster.java
index b3bdbcbb81..5877a997bd 100644
--- a/java/org/apache/catalina/Authenticator.java
+++ b/java/org/apache/catalina/Authenticator.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
CometEvent.java
index ef93c24752..7755415eaf 100644
--- a/java/org/apache/catalina/Cluster.java
+++ b/java/org/apache/catalina/Cluster.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
CometFilter.java
index c38baade60..0057727c54 100644
--- a/java/org/apache/catalina/CometEvent.java
+++ b/java/org/apache/catalina/CometEvent.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
CometFilterChain.java
index 5a4d21d1bc..55cd327c4a 100644
--- a/java/org/apache/catalina/CometFilter.java
+++ b/java/org/apache/catalina/CometFilter.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
CometProcessor.java
index 5af80047eb..f0632fcd71 100644
--- a/java/org/apache/catalina/CometFilterChain.java
+++ b/java/org/apache/catalina/CometFilterChain.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Contained.java
index e9d02709ba..8645f0041f 100644
--- a/java/org/apache/catalina/CometProcessor.java
+++ b/java/org/apache/catalina/CometProcessor.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Container.java
index aa6fd52987..697f5ff6b8 100644
--- a/java/org/apache/catalina/Contained.java
+++ b/java/org/apache/catalina/Contained.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ContainerEvent.java
index f2e334bf64..05cf61a1cd 100644
--- a/java/org/apache/catalina/Container.java
+++ b/java/org/apache/catalina/Container.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ContainerListener.java
index 3fc0bc62a3..5533a06bdb 100644
--- a/java/org/apache/catalina/ContainerEvent.java
+++ b/java/org/apache/catalina/ContainerEvent.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ContainerServlet.java
index fc7384a487..e83dba4837 100644
--- a/java/org/apache/catalina/ContainerListener.java
+++ b/java/org/apache/catalina/ContainerListener.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Context.java
index 5efd7b2f35..9419365fd6 100644
--- a/java/org/apache/catalina/ContainerServlet.java
+++ b/java/org/apache/catalina/ContainerServlet.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Engine.java
index fc07113100..d64b7893df 100644
--- a/java/org/apache/catalina/Context.java
+++ b/java/org/apache/catalina/Context.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Globals.java
index 991c034290..393bb5543b 100644
--- a/java/org/apache/catalina/Engine.java
+++ b/java/org/apache/catalina/Engine.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Group.java
index 9caf191f10..d3fe5754ea 100644
--- a/java/org/apache/catalina/Globals.java
+++ b/java/org/apache/catalina/Globals.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Host.java
index c22e3125e6..a50b4d84cf 100644
--- a/java/org/apache/catalina/Group.java
+++ b/java/org/apache/catalina/Group.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
InstanceEvent.java
index fe78e45694..e183453144 100644
--- a/java/org/apache/catalina/Host.java
+++ b/java/org/apache/catalina/Host.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
InstanceListener.java
index 541ec7cbc7..3c814455ac 100644
--- a/java/org/apache/catalina/InstanceEvent.java
+++ b/java/org/apache/catalina/InstanceEvent.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Lifecycle.java
index 1b15507501..a545bd5f57 100644
--- a/java/org/apache/catalina/InstanceListener.java
+++ b/java/org/apache/catalina/InstanceListener.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
LifecycleEvent.java
index 19750bf758..73f07b2d3b 100644
--- a/java/org/apache/catalina/Lifecycle.java
+++ b/java/org/apache/catalina/Lifecycle.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
LifecycleException.java
index 4b921ea0bc..bd73ffc7c0 100644
--- a/java/org/apache/catalina/LifecycleEvent.java
+++ b/java/org/apache/catalina/LifecycleEvent.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
LifecycleListener.java
index e03d5602f7..7801b66b3a 100644
--- a/java/org/apache/catalina/LifecycleException.java
+++ b/java/org/apache/catalina/LifecycleException.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Loader.java
index 5fd32380b3..a61372c152 100644
--- a/java/org/apache/catalina/LifecycleListener.java
+++ b/java/org/apache/catalina/LifecycleListener.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Manager.java
index b075e0a0d3..28b30d93e8 100644
--- a/java/org/apache/catalina/Loader.java
+++ b/java/org/apache/catalina/Loader.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Pipeline.java
index 017b99a012..52a3901436 100644
--- a/java/org/apache/catalina/Manager.java
+++ b/java/org/apache/catalina/Manager.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Realm.java
index 0e6137ad29..f7f8e6ca48 100644
--- a/java/org/apache/catalina/Pipeline.java
+++ b/java/org/apache/catalina/Pipeline.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Role.java
index 698056327d..37ec06832b 100644
--- a/java/org/apache/catalina/Realm.java
+++ b/java/org/apache/catalina/Realm.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Server.java
index a45c296887..08cc6ce762 100644
--- a/java/org/apache/catalina/Role.java
+++ b/java/org/apache/catalina/Role.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ServerFactory.java
index e08b9f5976..547a7b2ae6 100644
--- a/java/org/apache/catalina/Server.java
+++ b/java/org/apache/catalina/Server.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Service.java
index aead339154..f2fb382800 100644
--- a/java/org/apache/catalina/ServerFactory.java
+++ b/java/org/apache/catalina/ServerFactory.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Session.java
index 3086ea80a1..bcb9639e8d 100644
--- a/java/org/apache/catalina/Service.java
+++ b/java/org/apache/catalina/Service.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SessionEvent.java
index 3f531f6a5a..c55e9338fb 100644
--- a/java/org/apache/catalina/Session.java
+++ b/java/org/apache/catalina/Session.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SessionListener.java
index eacd06c96f..e65c585ec3 100644
--- a/java/org/apache/catalina/SessionEvent.java
+++ b/java/org/apache/catalina/SessionEvent.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Store.java
index 61215b343c..dd7d07c75a 100644
--- a/java/org/apache/catalina/SessionListener.java
+++ b/java/org/apache/catalina/SessionListener.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
User.java
index 92e773d6bd..25334257bb 100644
--- a/java/org/apache/catalina/Store.java
+++ b/java/org/apache/catalina/Store.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
UserDatabase.java
index 8ae33ee548..86b703d324 100644
--- a/java/org/apache/catalina/User.java
+++ b/java/org/apache/catalina/User.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Valve.java
index 7f96f80ae8..e377a6d451 100644
--- a/java/org/apache/catalina/UserDatabase.java
+++ b/java/org/apache/catalina/UserDatabase.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Wrapper.java
index bb0f25f235..72f9656e9d 100644
--- a/java/org/apache/catalina/Valve.java
+++ b/java/org/apache/catalina/Valve.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
AbstractCatalinaTask.java
index 357cf51760..e6505052d2 100644
--- a/java/org/apache/catalina/Wrapper.java
+++ b/java/org/apache/catalina/Wrapper.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
BaseRedirectorHelperTask.java
index 5e1150bc40..332f514474 100644
--- a/java/org/apache/catalina/ant/AbstractCatalinaTask.java
+++ b/java/org/apache/catalina/ant/AbstractCatalinaTask.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
DeployTask.java
index 5c8a5b4e09..11fb0a1cbc 100644
--- a/java/org/apache/catalina/ant/BaseRedirectorHelperTask.java
+++ b/java/org/apache/catalina/ant/BaseRedirectorHelperTask.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
InstallTask.java
index 62b32ed272..4c9beac89b 100644
--- a/java/org/apache/catalina/ant/DeployTask.java
+++ b/java/org/apache/catalina/ant/DeployTask.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JKStatusUpdateTask.java
index 2dffe2ed7a..8e9d705bd6 100644
--- a/java/org/apache/catalina/ant/InstallTask.java
+++ b/java/org/apache/catalina/ant/InstallTask.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JMXGetTask.java
index ff4ea312e2..55e2b92a3a 100644
--- a/java/org/apache/catalina/ant/JKStatusUpdateTask.java
+++ b/java/org/apache/catalina/ant/JKStatusUpdateTask.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JMXQueryTask.java
index 33a810fdd9..23cbd91e48 100644
--- a/java/org/apache/catalina/ant/JMXGetTask.java
+++ b/java/org/apache/catalina/ant/JMXGetTask.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JMXSetTask.java
index 61b82a3af3..fdb6e9ac29 100644
--- a/java/org/apache/catalina/ant/JMXQueryTask.java
+++ b/java/org/apache/catalina/ant/JMXQueryTask.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ListTask.java
index 7c12cc0bd8..c286f85f45 100644
--- a/java/org/apache/catalina/ant/JMXSetTask.java
+++ b/java/org/apache/catalina/ant/JMXSetTask.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ReloadTask.java
index e67e539405..778fcebbce 100644
--- a/java/org/apache/catalina/ant/ListTask.java
+++ b/java/org/apache/catalina/ant/ListTask.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
RemoveTask.java
index 84d81a8710..2543e8d131 100644
--- a/java/org/apache/catalina/ant/ReloadTask.java
+++ b/java/org/apache/catalina/ant/ReloadTask.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ResourcesTask.java
index c3c5ad8abd..ed8416c507 100644
--- a/java/org/apache/catalina/ant/RemoveTask.java
+++ b/java/org/apache/catalina/ant/RemoveTask.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
RolesTask.java
index ea8a427334..cd1ce568ad 100644
--- a/java/org/apache/catalina/ant/ResourcesTask.java
+++ b/java/org/apache/catalina/ant/ResourcesTask.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ServerinfoTask.java
index 1b0496aef7..c96fa8da5c 100644
--- a/java/org/apache/catalina/ant/RolesTask.java
+++ b/java/org/apache/catalina/ant/RolesTask.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SessionsTask.java
index 1757a4c9c0..3381789955 100644
--- a/java/org/apache/catalina/ant/ServerinfoTask.java
+++ b/java/org/apache/catalina/ant/ServerinfoTask.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
StartTask.java
index 9e1af74ceb..bdd438a128 100644
--- a/java/org/apache/catalina/ant/SessionsTask.java
+++ b/java/org/apache/catalina/ant/SessionsTask.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
StopTask.java
index c2f4a5b38d..271e5a9cc1 100644
--- a/java/org/apache/catalina/ant/StartTask.java
+++ b/java/org/apache/catalina/ant/StartTask.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
UndeployTask.java
index 6101f1d427..f1421d9d5a 100644
--- a/java/org/apache/catalina/ant/StopTask.java
+++ b/java/org/apache/catalina/ant/StopTask.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ValidatorTask.java
index 6f42e46893..a09c5e191b 100644
--- a/java/org/apache/catalina/ant/UndeployTask.java
+++ b/java/org/apache/catalina/ant/UndeployTask.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Arg.java
index a9fd0a3826..d8f96ced9f 100644
--- a/java/org/apache/catalina/ant/ValidatorTask.java
+++ b/java/org/apache/catalina/ant/ValidatorTask.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JMXAccessorCondition.java
index 7bf5c63f78..57003da2c3 100644
--- a/java/org/apache/catalina/ant/jmx/Arg.java
+++ b/java/org/apache/catalina/ant/jmx/Arg.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JMXAccessorCreateTask.java
index a2e794eaca..8ccb921c41 100644
--- a/java/org/apache/catalina/ant/jmx/JMXAccessorCondition.java
+++ b/java/org/apache/catalina/ant/jmx/JMXAccessorCondition.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JMXAccessorEqualsCondition.java
index bde89241de..5c26230340 100644
--- a/java/org/apache/catalina/ant/jmx/JMXAccessorCreateTask.java
+++ b/java/org/apache/catalina/ant/jmx/JMXAccessorCreateTask.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JMXAccessorGetTask.java
index c3bfb2872d..fe39bab84e 100644
--- a/java/org/apache/catalina/ant/jmx/JMXAccessorEqualsCondition.java
+++ b/java/org/apache/catalina/ant/jmx/JMXAccessorEqualsCondition.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JMXAccessorInvokeTask.java
index f134f8ca17..cfa7863ecd 100644
--- a/java/org/apache/catalina/ant/jmx/JMXAccessorGetTask.java
+++ b/java/org/apache/catalina/ant/jmx/JMXAccessorGetTask.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JMXAccessorQueryTask.java
index cc5c5c1e52..982c6a0b51 100644
--- a/java/org/apache/catalina/ant/jmx/JMXAccessorInvokeTask.java
+++ b/java/org/apache/catalina/ant/jmx/JMXAccessorInvokeTask.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JMXAccessorSetTask.java
index 30e57e6dfa..9ac9bcfebb 100644
--- a/java/org/apache/catalina/ant/jmx/JMXAccessorQueryTask.java
+++ b/java/org/apache/catalina/ant/jmx/JMXAccessorQueryTask.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JMXAccessorTask.java
index 6daa8b257f..2e888e7bc0 100644
--- a/java/org/apache/catalina/ant/jmx/JMXAccessorSetTask.java
+++ b/java/org/apache/catalina/ant/jmx/JMXAccessorSetTask.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JMXAccessorUnregisterTask.java
index 6a32661306..b701f49cc6 100644
--- a/java/org/apache/catalina/ant/jmx/JMXAccessorTask.java
+++ b/java/org/apache/catalina/ant/jmx/JMXAccessorTask.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
AuthenticatorBase.java
index daa5530f90..b1a6179066 100644
--- a/java/org/apache/catalina/ant/jmx/JMXAccessorUnregisterTask.java
+++ b/java/org/apache/catalina/ant/jmx/JMXAccessorUnregisterTask.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
BasicAuthenticator.java
index a8a71c6e9b..a17672248e 100644
--- a/java/org/apache/catalina/authenticator/AuthenticatorBase.java
+++ b/java/org/apache/catalina/authenticator/AuthenticatorBase.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Constants.java
index a8ce22447f..5b08802dc5 100644
--- a/java/org/apache/catalina/authenticator/BasicAuthenticator.java
+++ b/java/org/apache/catalina/authenticator/BasicAuthenticator.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
DigestAuthenticator.java
index 77259978b9..0ffcd8820c 100644
--- a/java/org/apache/catalina/authenticator/Constants.java
+++ b/java/org/apache/catalina/authenticator/Constants.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
FormAuthenticator.java
index c834e8c3fe..5004043194 100644
--- a/java/org/apache/catalina/authenticator/DigestAuthenticator.java
+++ b/java/org/apache/catalina/authenticator/DigestAuthenticator.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
NonLoginAuthenticator.java
index e7ed472dd4..fb9c5d5774 100644
--- a/java/org/apache/catalina/authenticator/FormAuthenticator.java
+++ b/java/org/apache/catalina/authenticator/FormAuthenticator.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SSLAuthenticator.java
index 878ccd3e0a..042f2ac55a 100644
--- a/java/org/apache/catalina/authenticator/NonLoginAuthenticator.java
+++ b/java/org/apache/catalina/authenticator/NonLoginAuthenticator.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SavedRequest.java
index fc1ca36829..466f3ef11a 100644
--- a/java/org/apache/catalina/authenticator/SSLAuthenticator.java
+++ b/java/org/apache/catalina/authenticator/SSLAuthenticator.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SingleSignOn.java
index 13cb8ed942..be32a26ede 100644
--- a/java/org/apache/catalina/authenticator/SavedRequest.java
+++ b/java/org/apache/catalina/authenticator/SavedRequest.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SingleSignOnEntry.java
index 0263db44e1..4136e6a738 100644
--- a/java/org/apache/catalina/authenticator/SingleSignOn.java
+++ b/java/org/apache/catalina/authenticator/SingleSignOn.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ClientAbortException.java
index bd1d2bb5e7..924d29d895 100644
--- a/java/org/apache/catalina/authenticator/SingleSignOnEntry.java
+++ b/java/org/apache/catalina/authenticator/SingleSignOnEntry.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
CometEventImpl.java
index 4bfaf6c046..4786855fe2 100644
--- a/java/org/apache/catalina/connector/ClientAbortException.java
+++ b/java/org/apache/catalina/connector/ClientAbortException.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Connector.java
index 12e19b70f3..708f4f4c5b 100644
--- a/java/org/apache/catalina/connector/CometEventImpl.java
+++ b/java/org/apache/catalina/connector/CometEventImpl.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Constants.java
index b9ad616eb4..fc9886b3ab 100644
--- a/java/org/apache/catalina/connector/Connector.java
+++ b/java/org/apache/catalina/connector/Connector.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
CoyoteAdapter.java
index 7f49bb9d0c..1884a9cd1e 100644
--- a/java/org/apache/catalina/connector/Constants.java
+++ b/java/org/apache/catalina/connector/Constants.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
CoyoteInputStream.java
index eb89e1e041..29844667ba 100644
--- a/java/org/apache/catalina/connector/CoyoteAdapter.java
+++ b/java/org/apache/catalina/connector/CoyoteAdapter.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
CoyoteOutputStream.java
index 6d8ad7c683..c41c86680a 100644
--- a/java/org/apache/catalina/connector/CoyoteInputStream.java
+++ b/java/org/apache/catalina/connector/CoyoteInputStream.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
CoyotePrincipal.java
index 0dc4c3185a..cc4bed3ce2 100644
--- a/java/org/apache/catalina/connector/CoyoteOutputStream.java
+++ b/java/org/apache/catalina/connector/CoyoteOutputStream.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
CoyoteReader.java
index aca49dc3fb..08a3a98bdc 100644
--- a/java/org/apache/catalina/connector/CoyotePrincipal.java
+++ b/java/org/apache/catalina/connector/CoyotePrincipal.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
CoyoteWriter.java
index 120ddce152..d3584e911d 100644
--- a/java/org/apache/catalina/connector/CoyoteReader.java
+++ b/java/org/apache/catalina/connector/CoyoteReader.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
InputBuffer.java
index edd6603e67..513f2fb211 100644
--- a/java/org/apache/catalina/connector/CoyoteWriter.java
+++ b/java/org/apache/catalina/connector/CoyoteWriter.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
MapperListener.java
index ef0941a8c5..c380d33ce2 100644
--- a/java/org/apache/catalina/connector/InputBuffer.java
+++ b/java/org/apache/catalina/connector/InputBuffer.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
OutputBuffer.java
index 730e345f4d..545ee1e29b 100644
--- a/java/org/apache/catalina/connector/MapperListener.java
+++ b/java/org/apache/catalina/connector/MapperListener.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Request.java
index 9ea4b1cbcb..c86bbca63f 100644
--- a/java/org/apache/catalina/connector/OutputBuffer.java
+++ b/java/org/apache/catalina/connector/OutputBuffer.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
RequestFacade.java
index a7349c8a23..71018209ca 100644
--- a/java/org/apache/catalina/connector/Request.java
+++ b/java/org/apache/catalina/connector/Request.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Response.java
index db5b0f3744..ec89e5fd58 100644
--- a/java/org/apache/catalina/connector/RequestFacade.java
+++ b/java/org/apache/catalina/connector/RequestFacade.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ResponseFacade.java
index 0a82a71a97..c305a0b6fb 100644
--- a/java/org/apache/catalina/connector/Response.java
+++ b/java/org/apache/catalina/connector/Response.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ApplicationContext.java
index 71bf2fc1e7..22d29d9171 100644
--- a/java/org/apache/catalina/connector/ResponseFacade.java
+++ b/java/org/apache/catalina/connector/ResponseFacade.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ApplicationContextFacade.java
index fba8cd25ab..21bc0dd354 100644
--- a/java/org/apache/catalina/core/ApplicationContext.java
+++ b/java/org/apache/catalina/core/ApplicationContext.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ApplicationDispatcher.java
index 5e5599582c..a32855dcbe 100644
--- a/java/org/apache/catalina/core/ApplicationContextFacade.java
+++ b/java/org/apache/catalina/core/ApplicationContextFacade.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ApplicationFilterChain.java
index c8fee93d95..dddb2e7a17 100644
--- a/java/org/apache/catalina/core/ApplicationDispatcher.java
+++ b/java/org/apache/catalina/core/ApplicationDispatcher.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ApplicationFilterConfig.java
index 33e9a89a6c..0bb916515d 100644
--- a/java/org/apache/catalina/core/ApplicationFilterChain.java
+++ b/java/org/apache/catalina/core/ApplicationFilterChain.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ApplicationFilterFactory.java
index 631190b4c2..4446ffb1b8 100644
--- a/java/org/apache/catalina/core/ApplicationFilterConfig.java
+++ b/java/org/apache/catalina/core/ApplicationFilterConfig.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ApplicationHttpRequest.java
index 89b588dfa0..d64688e3cd 100644
--- a/java/org/apache/catalina/core/ApplicationFilterFactory.java
+++ b/java/org/apache/catalina/core/ApplicationFilterFactory.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ApplicationHttpResponse.java
index 3ef5e59534..721602ba96 100644
--- a/java/org/apache/catalina/core/ApplicationHttpRequest.java
+++ b/java/org/apache/catalina/core/ApplicationHttpRequest.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ApplicationRequest.java
index 28c6934d81..a86ac23685 100644
--- a/java/org/apache/catalina/core/ApplicationHttpResponse.java
+++ b/java/org/apache/catalina/core/ApplicationHttpResponse.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ApplicationResponse.java
index bed95a3aaa..5637424eac 100644
--- a/java/org/apache/catalina/core/ApplicationRequest.java
+++ b/java/org/apache/catalina/core/ApplicationRequest.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
AprLifecycleListener.java
index becb25d2d5..ea12b909d3 100644
--- a/java/org/apache/catalina/core/ApplicationResponse.java
+++ b/java/org/apache/catalina/core/ApplicationResponse.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Constants.java
index 8cb8d650d0..c2a93ecea5 100644
--- a/java/org/apache/catalina/core/AprLifecycleListener.java
+++ b/java/org/apache/catalina/core/AprLifecycleListener.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ContainerBase.java
index eb8c49994a..59256eb79d 100644
--- a/java/org/apache/catalina/core/Constants.java
+++ b/java/org/apache/catalina/core/Constants.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
DummyRequest.java
index 6a67bb2d12..d8401d4c38 100644
--- a/java/org/apache/catalina/core/ContainerBase.java
+++ b/java/org/apache/catalina/core/ContainerBase.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
DummyResponse.java
index 68e87e3edd..183e026bdd 100644
--- a/java/org/apache/catalina/core/DummyRequest.java
+++ b/java/org/apache/catalina/core/DummyRequest.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JasperListener.java
index f3b27e0e85..3e4aa96559 100644
--- a/java/org/apache/catalina/core/DummyResponse.java
+++ b/java/org/apache/catalina/core/DummyResponse.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
NamingContextListener.java
index 3756c13733..924da16ec6 100644
--- a/java/org/apache/catalina/core/JasperListener.java
+++ b/java/org/apache/catalina/core/JasperListener.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
StandardContext.java
index 60abf52b34..fe4f77a215 100644
--- a/java/org/apache/catalina/core/NamingContextListener.java
+++ b/java/org/apache/catalina/core/NamingContextListener.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
StandardContextValve.java
index 5031d851fc..05e91a860f 100644
--- a/java/org/apache/catalina/core/StandardContext.java
+++ b/java/org/apache/catalina/core/StandardContext.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
StandardEngine.java
index 825d4939c3..c1be326670 100644
--- a/java/org/apache/catalina/core/StandardContextValve.java
+++ b/java/org/apache/catalina/core/StandardContextValve.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
StandardEngineValve.java
index 4c000a9408..fd889f306a 100644
--- a/java/org/apache/catalina/core/StandardEngine.java
+++ b/java/org/apache/catalina/core/StandardEngine.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
StandardHost.java
index 9c4259a23d..7520f36c11 100644
--- a/java/org/apache/catalina/core/StandardEngineValve.java
+++ b/java/org/apache/catalina/core/StandardEngineValve.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
StandardHostValve.java
index 71f0539850..3bf330f387 100644
--- a/java/org/apache/catalina/core/StandardHost.java
+++ b/java/org/apache/catalina/core/StandardHost.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
StandardPipeline.java
index e367512fc1..6846680873 100644
--- a/java/org/apache/catalina/core/StandardHostValve.java
+++ b/java/org/apache/catalina/core/StandardHostValve.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
StandardServer.java
index 388cbdb4c6..f67b523c31 100644
--- a/java/org/apache/catalina/core/StandardPipeline.java
+++ b/java/org/apache/catalina/core/StandardPipeline.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
StandardService.java
index 1232600bed..9052c69dae 100644
--- a/java/org/apache/catalina/core/StandardServer.java
+++ b/java/org/apache/catalina/core/StandardServer.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
StandardWrapper.java
index 1c46a2a110..b41c0007af 100644
--- a/java/org/apache/catalina/core/StandardService.java
+++ b/java/org/apache/catalina/core/StandardService.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
StandardWrapperFacade.java
index 12c0c258ee..37e0805e1d 100644
--- a/java/org/apache/catalina/core/StandardWrapper.java
+++ b/java/org/apache/catalina/core/StandardWrapper.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
StandardWrapperValve.java
index 9711353b21..a4c074989c 100644
--- a/java/org/apache/catalina/core/StandardWrapperFacade.java
+++ b/java/org/apache/catalina/core/StandardWrapperFacade.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ApplicationParameter.java
index 25a335a6d7..b520c3a8ba 100644
--- a/java/org/apache/catalina/core/StandardWrapperValve.java
+++ b/java/org/apache/catalina/core/StandardWrapperValve.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ContextEjb.java
index 768e4332ba..9aca3c2a23 100644
--- a/java/org/apache/catalina/deploy/ApplicationParameter.java
+++ b/java/org/apache/catalina/deploy/ApplicationParameter.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ContextEnvironment.java
index 7cbea6fac7..69ee22a952 100644
--- a/java/org/apache/catalina/deploy/ContextEjb.java
+++ b/java/org/apache/catalina/deploy/ContextEjb.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ContextLocalEjb.java
index 3dcdc7f4ab..363d59d805 100644
--- a/java/org/apache/catalina/deploy/ContextEnvironment.java
+++ b/java/org/apache/catalina/deploy/ContextEnvironment.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ContextResource.java
index afc4190f94..f2b25e8a20 100644
--- a/java/org/apache/catalina/deploy/ContextLocalEjb.java
+++ b/java/org/apache/catalina/deploy/ContextLocalEjb.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ContextResourceEnvRef.java
index 8bb52d3103..5d8e9dd43e 100644
--- a/java/org/apache/catalina/deploy/ContextResource.java
+++ b/java/org/apache/catalina/deploy/ContextResource.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ContextResourceLink.java
index a554e99497..a00058fc47 100644
--- a/java/org/apache/catalina/deploy/ContextResourceEnvRef.java
+++ b/java/org/apache/catalina/deploy/ContextResourceEnvRef.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ContextService.java
index 0a4f9762fd..ca4bf293a5 100644
--- a/java/org/apache/catalina/deploy/ContextResourceLink.java
+++ b/java/org/apache/catalina/deploy/ContextResourceLink.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ContextTransaction.java
index b16e54166a..d8796b46c9 100644
--- a/java/org/apache/catalina/deploy/ContextService.java
+++ b/java/org/apache/catalina/deploy/ContextService.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ErrorPage.java
index a198667d1f..2e8374a51a 100644
--- a/java/org/apache/catalina/deploy/ContextTransaction.java
+++ b/java/org/apache/catalina/deploy/ContextTransaction.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
FilterDef.java
index 6fb5d5dc79..6f10df45e2 100644
--- a/java/org/apache/catalina/deploy/ErrorPage.java
+++ b/java/org/apache/catalina/deploy/ErrorPage.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
FilterMap.java
index 7b98888536..b94b8fa650 100644
--- a/java/org/apache/catalina/deploy/FilterDef.java
+++ b/java/org/apache/catalina/deploy/FilterDef.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
LoginConfig.java
index c05df9ed60..ef255bf85a 100644
--- a/java/org/apache/catalina/deploy/FilterMap.java
+++ b/java/org/apache/catalina/deploy/FilterMap.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
MessageDestination.java
index cc8aa47afd..a377a4b487 100644
--- a/java/org/apache/catalina/deploy/LoginConfig.java
+++ b/java/org/apache/catalina/deploy/LoginConfig.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
MessageDestinationRef.java
index d7078d4530..a764e7ec65 100644
--- a/java/org/apache/catalina/deploy/MessageDestination.java
+++ b/java/org/apache/catalina/deploy/MessageDestination.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
NamingResources.java
index 9668fca53d..d5ebcaaaf0 100644
--- a/java/org/apache/catalina/deploy/MessageDestinationRef.java
+++ b/java/org/apache/catalina/deploy/MessageDestinationRef.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ResourceBase.java
index c3917f39d2..8ba59d35e3 100644
--- a/java/org/apache/catalina/deploy/NamingResources.java
+++ b/java/org/apache/catalina/deploy/NamingResources.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SecurityCollection.java
index 5356421fe4..d83bd6e8b8 100644
--- a/java/org/apache/catalina/deploy/ResourceBase.java
+++ b/java/org/apache/catalina/deploy/ResourceBase.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SecurityConstraint.java
index 482793d4b9..2ff3035946 100644
--- a/java/org/apache/catalina/deploy/SecurityCollection.java
+++ b/java/org/apache/catalina/deploy/SecurityCollection.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
CatalinaCluster.java
index e9cff33e56..4060580c75 100644
--- a/java/org/apache/catalina/deploy/SecurityConstraint.java
+++ b/java/org/apache/catalina/deploy/SecurityConstraint.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ClusterDeployer.java
index c4dd07a096..de60e2c554 100644
--- a/java/org/apache/catalina/ha/CatalinaCluster.java
+++ b/java/org/apache/catalina/ha/CatalinaCluster.java
@@ -1,129 +1,130 @@
-/*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha;
-
-import java.util.Map;
-
-import org.apache.catalina.Cluster;
-import org.apache.catalina.LifecycleException;
-import org.apache.catalina.Manager;
-import org.apache.catalina.Valve;
-import org.apache.catalina.tribes.Channel;
-import org.apache.catalina.tribes.Member;
-import org.apache.juli.logging.Log;
-
-
-
-/**
- * A <b>CatalinaCluster</b> interface allows to plug in and out the 
- * different cluster implementations
- *
- * @author Filip Hanik
- * @version $Revision: 379550 $, $Date: 2006-02-21 12:06:35 -0600 (Tue, 21 Feb 2006) $
- */
-
-public interface CatalinaCluster extends Cluster {
-    // ----------------------------------------------------- Instance Variables
-
-    /**
-     * Descriptive information about this component implementation.
-     */
-    public String info = "CatalinaCluster/2.0";
-    
-    /**
-     * Start the cluster, the owning container will invoke this
-     * @throws Exception - if failure to start cluster
-     */
-    public void start() throws Exception;
-    
-    /**
-     * Stops the cluster, the owning container will invoke this
-     * @throws LifecycleException
-     */
-    public void stop() throws LifecycleException;
-    
-    /**
-     * Returns the associates logger with this cluster.
-     *
-     * @return Log
-     */
-    public Log getLogger();
-    
-    /**
-     * Sends a message to all the members in the cluster
-     * @param msg ClusterMessage
-     */
-    public void send(ClusterMessage msg);
-    
-    /**
-     * Sends a message to a specific member in the cluster.
-     *
-     * @param msg ClusterMessage
-     * @param dest Member
-     */
-    public void send(ClusterMessage msg, Member dest);
-    
-    /**
-     * Sends a message to a all members at local cluster domain
-     *
-     * @param msg ClusterMessage
-     */
-    public void sendClusterDomain(ClusterMessage msg);
-
-    /**
-     * Returns that cluster has members.
-     */
-    public boolean hasMembers();
-
-    /**
-     * Returns all the members currently participating in the cluster.
-     *
-     * @return Member[]
-     */
-    public Member[] getMembers();
-    
-    /**
-     * Return the member that represents this node.
-     *
-     * @return Member
-     */
-    public Member getLocalMember();
-    
-    public void addValve(Valve valve);
-    
-    public void addClusterListener(ClusterListener listener);
-    
-    public void removeClusterListener(ClusterListener listener);
-    
-    public void setClusterDeployer(ClusterDeployer deployer);
-    
-    public ClusterDeployer getClusterDeployer();
-    
-    /**
-     * @return The map of managers
-     */
-    public Map getManagers();
-
-    public Manager getManager(String name);
-    public String getManagerName(String name, Manager manager);
-    public Valve[] getValves();
-    
-    public void setChannel(Channel channel);
-    public Channel getChannel();
-    
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha;
+
+import java.util.Map;
+
+import org.apache.catalina.Cluster;
+import org.apache.catalina.LifecycleException;
+import org.apache.catalina.Manager;
+import org.apache.catalina.Valve;
+import org.apache.catalina.tribes.Channel;
+import org.apache.catalina.tribes.Member;
+import org.apache.juli.logging.Log;
+
+
+
+/**
+ * A <b>CatalinaCluster</b> interface allows to plug in and out the 
+ * different cluster implementations
+ *
+ * @author Filip Hanik
+ * @version $Revision: 379550 $, $Date: 2006-02-21 12:06:35 -0600 (Tue, 21 Feb 2006) $
+ */
+
+public interface CatalinaCluster extends Cluster {
+    // ----------------------------------------------------- Instance Variables
+
+    /**
+     * Descriptive information about this component implementation.
+     */
+    public String info = "CatalinaCluster/2.0";
+    
+    /**
+     * Start the cluster, the owning container will invoke this
+     * @throws Exception - if failure to start cluster
+     */
+    public void start() throws Exception;
+    
+    /**
+     * Stops the cluster, the owning container will invoke this
+     * @throws LifecycleException
+     */
+    public void stop() throws LifecycleException;
+    
+    /**
+     * Returns the associates logger with this cluster.
+     *
+     * @return Log
+     */
+    public Log getLogger();
+    
+    /**
+     * Sends a message to all the members in the cluster
+     * @param msg ClusterMessage
+     */
+    public void send(ClusterMessage msg);
+    
+    /**
+     * Sends a message to a specific member in the cluster.
+     *
+     * @param msg ClusterMessage
+     * @param dest Member
+     */
+    public void send(ClusterMessage msg, Member dest);
+    
+    /**
+     * Sends a message to a all members at local cluster domain
+     *
+     * @param msg ClusterMessage
+     */
+    public void sendClusterDomain(ClusterMessage msg);
+
+    /**
+     * Returns that cluster has members.
+     */
+    public boolean hasMembers();
+
+    /**
+     * Returns all the members currently participating in the cluster.
+     *
+     * @return Member[]
+     */
+    public Member[] getMembers();
+    
+    /**
+     * Return the member that represents this node.
+     *
+     * @return Member
+     */
+    public Member getLocalMember();
+    
+    public void addValve(Valve valve);
+    
+    public void addClusterListener(ClusterListener listener);
+    
+    public void removeClusterListener(ClusterListener listener);
+    
+    public void setClusterDeployer(ClusterDeployer deployer);
+    
+    public ClusterDeployer getClusterDeployer();
+    
+    /**
+     * @return The map of managers
+     */
+    public Map getManagers();
+
+    public Manager getManager(String name);
+    public String getManagerName(String name, Manager manager);
+    public Valve[] getValves();
+    
+    public void setChannel(Channel channel);
+    public Channel getChannel();
+    
+
+}

==================================================
ClusterListener.java
index 39c9322ab6..4823abce58 100644
--- a/java/org/apache/catalina/ha/ClusterDeployer.java
+++ b/java/org/apache/catalina/ha/ClusterDeployer.java
@@ -1,120 +1,121 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha;
-
-/**
- * A <b>ClusterDeployer</b> interface allows to plug in and out the
- * different deployment implementations
- *
- * @author Filip Hanik
- * @version $Revision: 378050 $, $Date: 2006-02-15 12:30:02 -0600 (Wed, 15 Feb 2006) $
- */
-import org.apache.catalina.LifecycleException;
-import java.io.IOException;
-import java.net.URL;
-import org.apache.catalina.tribes.ChannelListener;
-
-public interface ClusterDeployer extends ChannelListener {
-    /**
-     * Descriptive information about this component implementation.
-     */
-    public String info = "ClusterDeployer/1.0";
-    /**
-     * Start the cluster deployer, the owning container will invoke this
-     * @throws Exception - if failure to start cluster
-     */
-    public void start() throws Exception;
-
-    /**
-     * Stops the cluster deployer, the owning container will invoke this
-     * @throws LifecycleException
-     */
-    public void stop() throws LifecycleException;
-
-    /**
-     * Sets the deployer for this cluster deployer to use.
-     * @param deployer Deployer
-     */
-    // FIXME
-    //public void setDeployer(Deployer deployer);
-
-    /**
-     * Install a new web application, whose web application archive is at the
-     * specified URL, into this container and all the other
-     * members of the cluster with the specified context path.
-     * A context path of "" (the empty string) should be used for the root
-     * application for this container.  Otherwise, the context path must
-     * start with a slash.
-     * <p>
-     * If this application is successfully installed locally, 
-     * a ContainerEvent of type
-     * <code>INSTALL_EVENT</code> will be sent to all registered listeners,
-     * with the newly created <code>Context</code> as an argument.
-     *
-     * @param contextPath The context path to which this application should
-     *  be installed (must be unique)
-     * @param war A URL of type "jar:" that points to a WAR file, or type
-     *  "file:" that points to an unpacked directory structure containing
-     *  the web application to be installed
-     *
-     * @exception IllegalArgumentException if the specified context path
-     *  is malformed (it must be "" or start with a slash)
-     * @exception IllegalStateException if the specified context path
-     *  is already attached to an existing web application
-     * @exception IOException if an input/output error was encountered
-     *  during installation
-     */
-    public void install(String contextPath, URL war) throws IOException;
-
-    /**
-     * Remove an existing web application, attached to the specified context
-     * path.  If this application is successfully removed, a
-     * ContainerEvent of type <code>REMOVE_EVENT</code> will be sent to all
-     * registered listeners, with the removed <code>Context</code> as
-     * an argument. Deletes the web application war file and/or directory
-     * if they exist in the Host's appBase.
-     *
-     * @param contextPath The context path of the application to be removed
-     * @param undeploy boolean flag to remove web application from server
-     *
-     * @exception IllegalArgumentException if the specified context path
-     *  is malformed (it must be "" or start with a slash)
-     * @exception IllegalArgumentException if the specified context path does
-     *  not identify a currently installed web application
-     * @exception IOException if an input/output error occurs during
-     *  removal
-     */
-    public void remove(String contextPath, boolean undeploy) throws IOException;
-
-    /**
-     * call from container Background Process
-     */
-    public void backgroundProcess();
-    
-    /**
-     * Returns the cluster the cluster deployer is associated with
-     * @return CatalinaCluster
-     */
-    public CatalinaCluster getCluster();
-
-    /**
-     * Associates the cluster deployer with a cluster
-     * @param cluster CatalinaCluster
-     */
-    public void setCluster(CatalinaCluster cluster);
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha;
+
+/**
+ * A <b>ClusterDeployer</b> interface allows to plug in and out the
+ * different deployment implementations
+ *
+ * @author Filip Hanik
+ * @version $Revision: 378050 $, $Date: 2006-02-15 12:30:02 -0600 (Wed, 15 Feb 2006) $
+ */
+import org.apache.catalina.LifecycleException;
+import java.io.IOException;
+import java.net.URL;
+import org.apache.catalina.tribes.ChannelListener;
+
+public interface ClusterDeployer extends ChannelListener {
+    /**
+     * Descriptive information about this component implementation.
+     */
+    public String info = "ClusterDeployer/1.0";
+    /**
+     * Start the cluster deployer, the owning container will invoke this
+     * @throws Exception - if failure to start cluster
+     */
+    public void start() throws Exception;
+
+    /**
+     * Stops the cluster deployer, the owning container will invoke this
+     * @throws LifecycleException
+     */
+    public void stop() throws LifecycleException;
+
+    /**
+     * Sets the deployer for this cluster deployer to use.
+     * @param deployer Deployer
+     */
+    // FIXME
+    //public void setDeployer(Deployer deployer);
+
+    /**
+     * Install a new web application, whose web application archive is at the
+     * specified URL, into this container and all the other
+     * members of the cluster with the specified context path.
+     * A context path of "" (the empty string) should be used for the root
+     * application for this container.  Otherwise, the context path must
+     * start with a slash.
+     * <p>
+     * If this application is successfully installed locally, 
+     * a ContainerEvent of type
+     * <code>INSTALL_EVENT</code> will be sent to all registered listeners,
+     * with the newly created <code>Context</code> as an argument.
+     *
+     * @param contextPath The context path to which this application should
+     *  be installed (must be unique)
+     * @param war A URL of type "jar:" that points to a WAR file, or type
+     *  "file:" that points to an unpacked directory structure containing
+     *  the web application to be installed
+     *
+     * @exception IllegalArgumentException if the specified context path
+     *  is malformed (it must be "" or start with a slash)
+     * @exception IllegalStateException if the specified context path
+     *  is already attached to an existing web application
+     * @exception IOException if an input/output error was encountered
+     *  during installation
+     */
+    public void install(String contextPath, URL war) throws IOException;
+
+    /**
+     * Remove an existing web application, attached to the specified context
+     * path.  If this application is successfully removed, a
+     * ContainerEvent of type <code>REMOVE_EVENT</code> will be sent to all
+     * registered listeners, with the removed <code>Context</code> as
+     * an argument. Deletes the web application war file and/or directory
+     * if they exist in the Host's appBase.
+     *
+     * @param contextPath The context path of the application to be removed
+     * @param undeploy boolean flag to remove web application from server
+     *
+     * @exception IllegalArgumentException if the specified context path
+     *  is malformed (it must be "" or start with a slash)
+     * @exception IllegalArgumentException if the specified context path does
+     *  not identify a currently installed web application
+     * @exception IOException if an input/output error occurs during
+     *  removal
+     */
+    public void remove(String contextPath, boolean undeploy) throws IOException;
+
+    /**
+     * call from container Background Process
+     */
+    public void backgroundProcess();
+    
+    /**
+     * Returns the cluster the cluster deployer is associated with
+     * @return CatalinaCluster
+     */
+    public CatalinaCluster getCluster();
+
+    /**
+     * Associates the cluster deployer with a cluster
+     * @param cluster CatalinaCluster
+     */
+    public void setCluster(CatalinaCluster cluster);
+
+}

==================================================
ClusterManager.java
index 9dcc75761e..a99bba4eb4 100644
--- a/java/org/apache/catalina/ha/ClusterListener.java
+++ b/java/org/apache/catalina/ha/ClusterListener.java
@@ -1,113 +1,114 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha;
-
-
-
-
-import java.io.Serializable;
-
-import org.apache.catalina.tribes.ChannelListener;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.util.StringManager;
-
-
-/**
- * Receive SessionID cluster change from other backup node after primary session
- * node is failed.
- * 
- * @author Peter Rossbach
- * @author Filip Hanik
- * @version $Revision: 378258 $ $Date: 2006-02-16 08:42:35 -0600 (Thu, 16 Feb 2006) $
- */
-public abstract class ClusterListener implements ChannelListener {
-
-    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(ClusterListener.class);
-
-
-    //--Instance Variables--------------------------------------
-
-    /**
-     * The string manager for this package.
-     */
-    protected StringManager sm = StringManager.getManager(Constants.Package);
-
-    protected CatalinaCluster cluster = null;
-
-    //--Constructor---------------------------------------------
-
-    public ClusterListener() {
-    }
-    
-    //--Instance Getters/Setters--------------------------------
-    
-    public CatalinaCluster getCluster() {
-        return cluster;
-    }
-
-    public void setCluster(CatalinaCluster cluster) {
-        if (log.isDebugEnabled()) {
-            if (cluster != null)
-                log.debug("add ClusterListener " + this.toString() + " to cluster" + cluster);
-            else
-                log.debug("remove ClusterListener " + this.toString() + " from cluster");
-        }
-        this.cluster = cluster;
-    }
-
-    public boolean equals(Object listener) {
-        return super.equals(listener);
-    }
-
-    public int hashCode() {
-        return super.hashCode();
-    }
-
-    //--Logic---------------------------------------------------
-
-    public final void messageReceived(Serializable msg, Member member) {
-        if ( msg instanceof ClusterMessage ) messageReceived((ClusterMessage)msg);
-    }
-    public final boolean accept(Serializable msg, Member member) {
-        if ( msg instanceof ClusterMessage ) return true;
-        return false;
-    }
-
-
-
-    /**
-     * Callback from the cluster, when a message is received, The cluster will
-     * broadcast it invoking the messageReceived on the receiver.
-     * 
-     * @param msg
-     *            ClusterMessage - the message received from the cluster
-     */
-    public abstract void messageReceived(ClusterMessage msg) ;
-    
-
-    /**
-     * Accept only SessionIDMessages
-     * 
-     * @param msg
-     *            ClusterMessage
-     * @return boolean - returns true to indicate that messageReceived should be
-     *         invoked. If false is returned, the messageReceived method will
-     *         not be invoked.
-     */
-    public abstract boolean accept(ClusterMessage msg) ;
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha;
+
+
+
+
+import java.io.Serializable;
+
+import org.apache.catalina.tribes.ChannelListener;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.util.StringManager;
+
+
+/**
+ * Receive SessionID cluster change from other backup node after primary session
+ * node is failed.
+ * 
+ * @author Peter Rossbach
+ * @author Filip Hanik
+ * @version $Revision: 378258 $ $Date: 2006-02-16 08:42:35 -0600 (Thu, 16 Feb 2006) $
+ */
+public abstract class ClusterListener implements ChannelListener {
+
+    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(ClusterListener.class);
+
+
+    //--Instance Variables--------------------------------------
+
+    /**
+     * The string manager for this package.
+     */
+    protected StringManager sm = StringManager.getManager(Constants.Package);
+
+    protected CatalinaCluster cluster = null;
+
+    //--Constructor---------------------------------------------
+
+    public ClusterListener() {
+    }
+    
+    //--Instance Getters/Setters--------------------------------
+    
+    public CatalinaCluster getCluster() {
+        return cluster;
+    }
+
+    public void setCluster(CatalinaCluster cluster) {
+        if (log.isDebugEnabled()) {
+            if (cluster != null)
+                log.debug("add ClusterListener " + this.toString() + " to cluster" + cluster);
+            else
+                log.debug("remove ClusterListener " + this.toString() + " from cluster");
+        }
+        this.cluster = cluster;
+    }
+
+    public boolean equals(Object listener) {
+        return super.equals(listener);
+    }
+
+    public int hashCode() {
+        return super.hashCode();
+    }
+
+    //--Logic---------------------------------------------------
+
+    public final void messageReceived(Serializable msg, Member member) {
+        if ( msg instanceof ClusterMessage ) messageReceived((ClusterMessage)msg);
+    }
+    public final boolean accept(Serializable msg, Member member) {
+        if ( msg instanceof ClusterMessage ) return true;
+        return false;
+    }
+
+
+
+    /**
+     * Callback from the cluster, when a message is received, The cluster will
+     * broadcast it invoking the messageReceived on the receiver.
+     * 
+     * @param msg
+     *            ClusterMessage - the message received from the cluster
+     */
+    public abstract void messageReceived(ClusterMessage msg) ;
+    
+
+    /**
+     * Accept only SessionIDMessages
+     * 
+     * @param msg
+     *            ClusterMessage
+     * @return boolean - returns true to indicate that messageReceived should be
+     *         invoked. If false is returned, the messageReceived method will
+     *         not be invoked.
+     */
+    public abstract boolean accept(ClusterMessage msg) ;
+
+}

==================================================
ClusterMessage.java
index 9a05faf25c..0a5da49216 100644
--- a/java/org/apache/catalina/ha/ClusterManager.java
+++ b/java/org/apache/catalina/ha/ClusterManager.java
@@ -1,111 +1,112 @@
-/*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha;
-
-
-import org.apache.catalina.Manager;
-import java.io.IOException;
-import org.apache.catalina.tribes.io.ReplicationStream;
-
-
-/**
- * The common interface used by all cluster manager.
- * This is so that we can have a more pluggable way
- * of swapping session managers for different algorithms.
- *
- * @author Filip Hanik
- * @author Peter Rossbach
- */
-public interface ClusterManager extends Manager {
-
-   /**
-    * A message was received from another node, this
-    * is the callback method to implement if you are interested in
-    * receiving replication messages.
-    * @param msg - the message received.
-    */
-   public void messageDataReceived(ClusterMessage msg);
-
-   /**
-    * When the request has been completed, the replication valve
-    * will notify the manager, and the manager will decide whether
-    * any replication is needed or not.
-    * If there is a need for replication, the manager will
-    * create a session message and that will be replicated.
-    * The cluster determines where it gets sent.
-    * @param sessionId - the sessionId that just completed.
-    * @return a SessionMessage to be sent.
-    */
-   public ClusterMessage requestCompleted(String sessionId);
-
-   /**
-    * When the manager expires session not tied to a request.
-    * The cluster will periodically ask for a list of sessions
-    * that should expire and that should be sent across the wire.
-    * @return String[] The invalidated sessions
-    */
-   public String[] getInvalidatedSessions();
-   
-   /**
-    * Return the name of the manager, at host /context name and at engine hostname+/context.
-    * @return String
-    * @since 5.5.10
-    */
-   public String getName();
-   
-   /**
-    * Set the name of the manager, at host /context name and at engine hostname+/context
-    * @param name
-    * @since 5.5.10
-    */
-   public void setName(String name);
-         
-   public CatalinaCluster getCluster();
-
-   public void setCluster(CatalinaCluster cluster);
-   
-   /**
-    * @return Manager send only to same cluster domain.
-    * @since 5.5.10
-    */
-   public boolean doDomainReplication();
-
-   /**
-    * @param sendClusterDomainOnly Flag value.
-    * @since 5.5.10
-    */
-   public void setDomainReplication(boolean domainReplication);
-
-   /**
-    * @param mode The mode
-    * @since 5.5.10
-    */
-   public void setDefaultMode(boolean mode);
-
-   /**
-    * @since 5.5.10
-    */
-   public boolean isDefaultMode();
-   
-   public ReplicationStream getReplicationStream(byte[] data) throws IOException;
-
-   public ReplicationStream getReplicationStream(byte[] data, int offset, int length) throws IOException;
-   
-   public boolean isNotifyListenersOnReplication();
-
-   public ClusterManager cloneFromTemplate();
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha;
+
+
+import org.apache.catalina.Manager;
+import java.io.IOException;
+import org.apache.catalina.tribes.io.ReplicationStream;
+
+
+/**
+ * The common interface used by all cluster manager.
+ * This is so that we can have a more pluggable way
+ * of swapping session managers for different algorithms.
+ *
+ * @author Filip Hanik
+ * @author Peter Rossbach
+ */
+public interface ClusterManager extends Manager {
+
+   /**
+    * A message was received from another node, this
+    * is the callback method to implement if you are interested in
+    * receiving replication messages.
+    * @param msg - the message received.
+    */
+   public void messageDataReceived(ClusterMessage msg);
+
+   /**
+    * When the request has been completed, the replication valve
+    * will notify the manager, and the manager will decide whether
+    * any replication is needed or not.
+    * If there is a need for replication, the manager will
+    * create a session message and that will be replicated.
+    * The cluster determines where it gets sent.
+    * @param sessionId - the sessionId that just completed.
+    * @return a SessionMessage to be sent.
+    */
+   public ClusterMessage requestCompleted(String sessionId);
+
+   /**
+    * When the manager expires session not tied to a request.
+    * The cluster will periodically ask for a list of sessions
+    * that should expire and that should be sent across the wire.
+    * @return String[] The invalidated sessions
+    */
+   public String[] getInvalidatedSessions();
+   
+   /**
+    * Return the name of the manager, at host /context name and at engine hostname+/context.
+    * @return String
+    * @since 5.5.10
+    */
+   public String getName();
+   
+   /**
+    * Set the name of the manager, at host /context name and at engine hostname+/context
+    * @param name
+    * @since 5.5.10
+    */
+   public void setName(String name);
+         
+   public CatalinaCluster getCluster();
+
+   public void setCluster(CatalinaCluster cluster);
+   
+   /**
+    * @return Manager send only to same cluster domain.
+    * @since 5.5.10
+    */
+   public boolean doDomainReplication();
+
+   /**
+    * @param sendClusterDomainOnly Flag value.
+    * @since 5.5.10
+    */
+   public void setDomainReplication(boolean domainReplication);
+
+   /**
+    * @param mode The mode
+    * @since 5.5.10
+    */
+   public void setDefaultMode(boolean mode);
+
+   /**
+    * @since 5.5.10
+    */
+   public boolean isDefaultMode();
+   
+   public ReplicationStream getReplicationStream(byte[] data) throws IOException;
+
+   public ReplicationStream getReplicationStream(byte[] data, int offset, int length) throws IOException;
+   
+   public boolean isNotifyListenersOnReplication();
+
+   public ClusterManager cloneFromTemplate();
+}

==================================================
ClusterRuleSet.java
index d33f9e84cb..579a85a9d0 100644
--- a/java/org/apache/catalina/ha/ClusterMessage.java
+++ b/java/org/apache/catalina/ha/ClusterMessage.java
@@ -1,33 +1,34 @@
-/*
- * Copyright 1999,2005 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.ha;
-
-import java.io.Serializable;
-import org.apache.catalina.tribes.Member;
-
-
-/**
- * @author Filip Hanik
- * 
- */
-public interface ClusterMessage extends Serializable {
-    public Member getAddress();
-    public void setAddress(Member member);
-    public String getUniqueId();
-    public void setUniqueId(String id);
-    public long getTimestamp();
-    public void setTimestamp(long timestamp);
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.ha;
+
+import java.io.Serializable;
+import org.apache.catalina.tribes.Member;
+
+
+/**
+ * @author Filip Hanik
+ * 
+ */
+public interface ClusterMessage extends Serializable {
+    public Member getAddress();
+    public void setAddress(Member member);
+    public String getUniqueId();
+    public void setUniqueId(String id);
+    public long getTimestamp();
+    public void setTimestamp(long timestamp);
+}

==================================================
ClusterSession.java
index c6d7c7bfb3..118a0e8880 100644
--- a/java/org/apache/catalina/ha/ClusterRuleSet.java
+++ b/java/org/apache/catalina/ha/ClusterRuleSet.java
@@ -1,194 +1,195 @@
-/*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina.ha;
-
-
-import org.apache.tomcat.util.digester.Digester;
-import org.apache.tomcat.util.digester.RuleSetBase;
-
-
-/**
- * <p><strong>RuleSet</strong> for processing the contents of a
- * Cluster definition element.  </p>
- *
- * @author Filip Hanik
- * @author Peter Rossbach
- * @version $Revision: 387285 $ $Date: 2006-03-20 13:30:50 -0600 (Mon, 20 Mar 2006) $
- */
-
-public class ClusterRuleSet extends RuleSetBase {
-
-
-    // ----------------------------------------------------- Instance Variables
-
-
-    /**
-     * The matching pattern prefix to use for recognizing our elements.
-     */
-    protected String prefix = null;
-
-
-    // ------------------------------------------------------------ Constructor
-
-
-    /**
-     * Construct an instance of this <code>RuleSet</code> with the default
-     * matching pattern prefix.
-     */
-    public ClusterRuleSet() {
-
-        this("");
-
-    }
-
-
-    /**
-     * Construct an instance of this <code>RuleSet</code> with the specified
-     * matching pattern prefix.
-     *
-     * @param prefix Prefix for matching pattern rules (including the
-     *  trailing slash character)
-     */
-    public ClusterRuleSet(String prefix) {
-        super();
-        this.namespaceURI = null;
-        this.prefix = prefix;
-    }
-
-
-    // --------------------------------------------------------- Public Methods
-
-
-    /**
-     * <p>Add the set of Rule instances defined in this RuleSet to the
-     * specified <code>Digester</code> instance, associating them with
-     * our namespace URI (if any).  This method should only be called
-     * by a Digester instance.</p>
-     *
-     * @param digester Digester instance to which the new Rule instances
-     *  should be added.
-     */
-    public void addRuleInstances(Digester digester) {
-        //Cluster configuration start
-        digester.addObjectCreate(prefix + "Manager",
-                                 null, // MUST be specified in the element
-                                 "className");
-        digester.addSetProperties(prefix + "Manager");
-        digester.addSetNext(prefix + "Manager",
-                            "setManagerTemplate",
-                            "org.apache.catalina.ha.ClusterManager");
-        
-
-
-        digester.addObjectCreate(prefix + "Channel",
-                                 null, // MUST be specified in the element
-                                 "className");
-        digester.addSetProperties(prefix + "Channel");
-        digester.addSetNext(prefix + "Channel",
-                            "setChannel",
-                            "org.apache.catalina.tribes.Channel");
-
-
-        String channelPrefix = prefix + "Channel/";
-        { //channel properties
-            digester.addObjectCreate(channelPrefix + "Membership",
-                                     null, // MUST be specified in the element
-                                     "className");
-            digester.addSetProperties(channelPrefix + "Membership");
-            digester.addSetNext(channelPrefix + "Membership",
-                                "setMembershipService",
-                                "org.apache.catalina.tribes.MembershipService");
-
-            digester.addObjectCreate(channelPrefix + "Sender",
-                                     null, // MUST be specified in the element
-                                     "className");
-            digester.addSetProperties(channelPrefix + "Sender");
-            digester.addSetNext(channelPrefix + "Sender",
-                                "setChannelSender",
-                                "org.apache.catalina.tribes.ChannelSender");
-
-            digester.addObjectCreate(channelPrefix + "Sender/Transport",
-                                     null, // MUST be specified in the element
-                                     "className");
-            digester.addSetProperties(channelPrefix + "Sender/Transport");
-            digester.addSetNext(channelPrefix + "Sender/Transport",
-                                "setTransport",
-                                "org.apache.catalina.tribes.transport.MultiPointSender");
-
-
-            digester.addObjectCreate(channelPrefix + "Receiver",
-                                     null, // MUST be specified in the element
-                                     "className");
-            digester.addSetProperties(channelPrefix + "Receiver");
-            digester.addSetNext(channelPrefix + "Receiver",
-                                "setChannelReceiver",
-                                "org.apache.catalina.tribes.ChannelReceiver");
-
-            digester.addObjectCreate(channelPrefix + "Interceptor",
-                                     null, // MUST be specified in the element
-                                     "className");
-            digester.addSetProperties(channelPrefix + "Interceptor");
-            digester.addSetNext(channelPrefix + "Interceptor",
-                                "addInterceptor",
-                                "org.apache.catalina.tribes.ChannelInterceptor");
-
-            
-            digester.addObjectCreate(channelPrefix + "Interceptor/Member",
-                                     null, // MUST be specified in the element
-                                     "className");
-            digester.addSetProperties(channelPrefix + "Interceptor/Member");
-            digester.addSetNext(channelPrefix + "Interceptor/Member",
-                                "addStaticMember",
-                                "org.apache.catalina.tribes.Member");
-        }
-
-        digester.addObjectCreate(prefix + "Valve",
-                                 null, // MUST be specified in the element
-                                 "className");
-        digester.addSetProperties(prefix + "Valve");
-        digester.addSetNext(prefix + "Valve",
-                            "addValve",
-                            "org.apache.catalina.Valve");
-        
-        digester.addObjectCreate(prefix + "Deployer",
-                                 null, // MUST be specified in the element
-                                 "className");
-        digester.addSetProperties(prefix + "Deployer");
-        digester.addSetNext(prefix + "Deployer",
-                            "setClusterDeployer",
-                            "org.apache.catalina.ha.ClusterDeployer");
-        
-        digester.addObjectCreate(prefix + "Listener",
-                null, // MUST be specified in the element
-                "className");
-        digester.addSetProperties(prefix + "Listener");
-        digester.addSetNext(prefix + "Listener",
-                            "addLifecycleListener",
-                            "org.apache.catalina.LifecycleListener");
-        
-        digester.addObjectCreate(prefix + "ClusterListener",
-                null, // MUST be specified in the element
-                "className");
-        digester.addSetProperties(prefix + "ClusterListener");
-        digester.addSetNext(prefix + "ClusterListener",
-                            "addClusterListener",
-                            "org.apache.catalina.ha.ClusterListener");
-        //Cluster configuration end
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.catalina.ha;
+
+
+import org.apache.tomcat.util.digester.Digester;
+import org.apache.tomcat.util.digester.RuleSetBase;
+
+
+/**
+ * <p><strong>RuleSet</strong> for processing the contents of a
+ * Cluster definition element.  </p>
+ *
+ * @author Filip Hanik
+ * @author Peter Rossbach
+ * @version $Revision: 387285 $ $Date: 2006-03-20 13:30:50 -0600 (Mon, 20 Mar 2006) $
+ */
+
+public class ClusterRuleSet extends RuleSetBase {
+
+
+    // ----------------------------------------------------- Instance Variables
+
+
+    /**
+     * The matching pattern prefix to use for recognizing our elements.
+     */
+    protected String prefix = null;
+
+
+    // ------------------------------------------------------------ Constructor
+
+
+    /**
+     * Construct an instance of this <code>RuleSet</code> with the default
+     * matching pattern prefix.
+     */
+    public ClusterRuleSet() {
+
+        this("");
+
+    }
+
+
+    /**
+     * Construct an instance of this <code>RuleSet</code> with the specified
+     * matching pattern prefix.
+     *
+     * @param prefix Prefix for matching pattern rules (including the
+     *  trailing slash character)
+     */
+    public ClusterRuleSet(String prefix) {
+        super();
+        this.namespaceURI = null;
+        this.prefix = prefix;
+    }
+
+
+    // --------------------------------------------------------- Public Methods
+
+
+    /**
+     * <p>Add the set of Rule instances defined in this RuleSet to the
+     * specified <code>Digester</code> instance, associating them with
+     * our namespace URI (if any).  This method should only be called
+     * by a Digester instance.</p>
+     *
+     * @param digester Digester instance to which the new Rule instances
+     *  should be added.
+     */
+    public void addRuleInstances(Digester digester) {
+        //Cluster configuration start
+        digester.addObjectCreate(prefix + "Manager",
+                                 null, // MUST be specified in the element
+                                 "className");
+        digester.addSetProperties(prefix + "Manager");
+        digester.addSetNext(prefix + "Manager",
+                            "setManagerTemplate",
+                            "org.apache.catalina.ha.ClusterManager");
+        
+
+
+        digester.addObjectCreate(prefix + "Channel",
+                                 null, // MUST be specified in the element
+                                 "className");
+        digester.addSetProperties(prefix + "Channel");
+        digester.addSetNext(prefix + "Channel",
+                            "setChannel",
+                            "org.apache.catalina.tribes.Channel");
+
+
+        String channelPrefix = prefix + "Channel/";
+        { //channel properties
+            digester.addObjectCreate(channelPrefix + "Membership",
+                                     null, // MUST be specified in the element
+                                     "className");
+            digester.addSetProperties(channelPrefix + "Membership");
+            digester.addSetNext(channelPrefix + "Membership",
+                                "setMembershipService",
+                                "org.apache.catalina.tribes.MembershipService");
+
+            digester.addObjectCreate(channelPrefix + "Sender",
+                                     null, // MUST be specified in the element
+                                     "className");
+            digester.addSetProperties(channelPrefix + "Sender");
+            digester.addSetNext(channelPrefix + "Sender",
+                                "setChannelSender",
+                                "org.apache.catalina.tribes.ChannelSender");
+
+            digester.addObjectCreate(channelPrefix + "Sender/Transport",
+                                     null, // MUST be specified in the element
+                                     "className");
+            digester.addSetProperties(channelPrefix + "Sender/Transport");
+            digester.addSetNext(channelPrefix + "Sender/Transport",
+                                "setTransport",
+                                "org.apache.catalina.tribes.transport.MultiPointSender");
+
+
+            digester.addObjectCreate(channelPrefix + "Receiver",
+                                     null, // MUST be specified in the element
+                                     "className");
+            digester.addSetProperties(channelPrefix + "Receiver");
+            digester.addSetNext(channelPrefix + "Receiver",
+                                "setChannelReceiver",
+                                "org.apache.catalina.tribes.ChannelReceiver");
+
+            digester.addObjectCreate(channelPrefix + "Interceptor",
+                                     null, // MUST be specified in the element
+                                     "className");
+            digester.addSetProperties(channelPrefix + "Interceptor");
+            digester.addSetNext(channelPrefix + "Interceptor",
+                                "addInterceptor",
+                                "org.apache.catalina.tribes.ChannelInterceptor");
+
+            
+            digester.addObjectCreate(channelPrefix + "Interceptor/Member",
+                                     null, // MUST be specified in the element
+                                     "className");
+            digester.addSetProperties(channelPrefix + "Interceptor/Member");
+            digester.addSetNext(channelPrefix + "Interceptor/Member",
+                                "addStaticMember",
+                                "org.apache.catalina.tribes.Member");
+        }
+
+        digester.addObjectCreate(prefix + "Valve",
+                                 null, // MUST be specified in the element
+                                 "className");
+        digester.addSetProperties(prefix + "Valve");
+        digester.addSetNext(prefix + "Valve",
+                            "addValve",
+                            "org.apache.catalina.Valve");
+        
+        digester.addObjectCreate(prefix + "Deployer",
+                                 null, // MUST be specified in the element
+                                 "className");
+        digester.addSetProperties(prefix + "Deployer");
+        digester.addSetNext(prefix + "Deployer",
+                            "setClusterDeployer",
+                            "org.apache.catalina.ha.ClusterDeployer");
+        
+        digester.addObjectCreate(prefix + "Listener",
+                null, // MUST be specified in the element
+                "className");
+        digester.addSetProperties(prefix + "Listener");
+        digester.addSetNext(prefix + "Listener",
+                            "addLifecycleListener",
+                            "org.apache.catalina.LifecycleListener");
+        
+        digester.addObjectCreate(prefix + "ClusterListener",
+                null, // MUST be specified in the element
+                "className");
+        digester.addSetProperties(prefix + "ClusterListener");
+        digester.addSetNext(prefix + "ClusterListener",
+                            "addClusterListener",
+                            "org.apache.catalina.ha.ClusterListener");
+        //Cluster configuration end
+    }
+
+}

==================================================
ClusterValve.java
index 8eb8978221..6266c27957 100644
--- a/java/org/apache/catalina/ha/ClusterSession.java
+++ b/java/org/apache/catalina/ha/ClusterSession.java
@@ -1,39 +1,40 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina.ha;
-
-import org.apache.catalina.Session;
-import javax.servlet.http.HttpSession;
-
-public interface ClusterSession extends Session, HttpSession {
-   /**
-    * returns true if this session is the primary session, if that is the
-    * case, the manager can expire it upon timeout.
-    * @return True if this session is primary
-    */
-   public boolean isPrimarySession();
-
-   /**
-    * Sets whether this is the primary session or not.
-    * @param primarySession Flag value
-    */
-   public void setPrimarySession(boolean primarySession);
-   
-   
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.catalina.ha;
+
+import org.apache.catalina.Session;
+import javax.servlet.http.HttpSession;
+
+public interface ClusterSession extends Session, HttpSession {
+   /**
+    * returns true if this session is the primary session, if that is the
+    * case, the manager can expire it upon timeout.
+    * @return True if this session is primary
+    */
+   public boolean isPrimarySession();
+
+   /**
+    * Sets whether this is the primary session or not.
+    * @param primarySession Flag value
+    */
+   public void setPrimarySession(boolean primarySession);
+   
+   
+
+}

==================================================
Constants.java
index 42c93b7cae..1add40ef3a 100644
--- a/java/org/apache/catalina/ha/ClusterValve.java
+++ b/java/org/apache/catalina/ha/ClusterValve.java
@@ -1,39 +1,40 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.ha;
-
-import org.apache.catalina.Valve;
-
-/**
- * Cluster valves are a simple extension to the Tomcat valve architecture
- * with a small addition of being able to reference the cluster component in the container it sits in.
- * @author Filip Hanik
- * @author Peter Rossbach
- * @version $Revision: 303842 $, $Date: 2005-04-10 11:20:46 -0500 (Sun, 10 Apr 2005) $
- */
-public interface ClusterValve extends Valve{
-    /**
-     * Returns the cluster the cluster deployer is associated with
-     * @return CatalinaCluster
-     */
-    public CatalinaCluster getCluster();
-
-    /**
-     * Associates the cluster deployer with a cluster
-     * @param cluster CatalinaCluster
-     */
-    public void setCluster(CatalinaCluster cluster);
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.ha;
+
+import org.apache.catalina.Valve;
+
+/**
+ * Cluster valves are a simple extension to the Tomcat valve architecture
+ * with a small addition of being able to reference the cluster component in the container it sits in.
+ * @author Filip Hanik
+ * @author Peter Rossbach
+ * @version $Revision: 303842 $, $Date: 2005-04-10 11:20:46 -0500 (Sun, 10 Apr 2005) $
+ */
+public interface ClusterValve extends Valve{
+    /**
+     * Returns the cluster the cluster deployer is associated with
+     * @return CatalinaCluster
+     */
+    public CatalinaCluster getCluster();
+
+    /**
+     * Associates the cluster deployer with a cluster
+     * @param cluster CatalinaCluster
+     */
+    public void setCluster(CatalinaCluster cluster);
+}

==================================================
ReplicatedContext.java
index 7b7f041483..c2221e5a9f 100644
--- a/java/org/apache/catalina/ha/Constants.java
+++ b/java/org/apache/catalina/ha/Constants.java
@@ -1,30 +1,31 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina.ha;
-
-/**
- * Manifest constants for the <code>org.apache.catalina.ha</code>
- * package.
- *
- * @author Bip Thelin
- * @version $Revision: 302726 $, $Date: 2004-02-27 08:59:07 -0600 (Fri, 27 Feb 2004) $
- */
-
-public final class Constants {
-    public static final String Package = "org.apache.catalina.ha";
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.catalina.ha;
+
+/**
+ * Manifest constants for the <code>org.apache.catalina.ha</code>
+ * package.
+ *
+ * @author Bip Thelin
+ * @version $Revision: 302726 $, $Date: 2004-02-27 08:59:07 -0600 (Fri, 27 Feb 2004) $
+ */
+
+public final class Constants {
+    public static final String Package = "org.apache.catalina.ha";
+}

==================================================
FarmWarDeployer.java
index eb9c1ec836..35602a15f0 100644
--- a/java/org/apache/catalina/ha/context/ReplicatedContext.java
+++ b/java/org/apache/catalina/ha/context/ReplicatedContext.java
@@ -1,125 +1,126 @@
-/*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.ha.context;
-
-import org.apache.catalina.core.StandardContext;
-import org.apache.catalina.LifecycleException;
-import org.apache.catalina.ha.CatalinaCluster;
-import org.apache.catalina.tribes.tipis.ReplicatedMap;
-import org.apache.catalina.tribes.Channel;
-import org.apache.catalina.Loader;
-import org.apache.catalina.core.ApplicationContext;
-import org.apache.catalina.Globals;
-import javax.servlet.ServletContext;
-import java.util.HashMap;
-import org.apache.catalina.tribes.tipis.LazyReplicatedMap;
-
-/**
- * @author Filip Hanik
- * @version 1.0
- */
-public class ReplicatedContext extends StandardContext {
-    private int mapSendOptions = Channel.SEND_OPTIONS_DEFAULT;
-    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( ReplicatedContext.class );
-
-    protected static long DEFAULT_REPL_TIMEOUT = 15000;//15 seconds
-    
-
-
-    public synchronized void start() throws LifecycleException {
-        if ( this.started ) return;
-        try {
-            CatalinaCluster catclust = (CatalinaCluster)this.getCluster();
-            if (this.context == null) this.context = new ReplApplContext(this.getBasePath(), this);
-            if ( catclust != null ) {
-                ReplicatedMap map = new ReplicatedMap(this,catclust.getChannel(),DEFAULT_REPL_TIMEOUT,
-                                                      getName(),getClassLoaders());
-                map.setChannelSendOptions(mapSendOptions);
-                ((ReplApplContext)this.context).setAttributeMap(map);
-                if (getAltDDName() != null) context.setAttribute(Globals.ALT_DD_ATTR, getAltDDName());
-            }
-            super.start();
-        }  catch ( Exception x ) {
-            log.error("Unable to start ReplicatedContext",x);
-            throw new LifecycleException("Failed to start ReplicatedContext",x);
-        }
-    }
-    
-    public synchronized void stop() throws LifecycleException
-    {
-        ReplicatedMap map = (ReplicatedMap)((ReplApplContext)this.context).getAttributeMap();
-        if ( map!=null ) {
-            map.breakdown();
-        }
-        if ( !this.started ) return;
-        try {
-        } catch ( Exception x ){
-            log.error("Unable to stop ReplicatedContext",x);
-            throw new LifecycleException("Failed to stop ReplicatedContext",x);
-        } finally {
-            super.stop();
-        }
-
-    }
-
-
-    public void setMapSendOptions(int mapSendOptions) {
-        this.mapSendOptions = mapSendOptions;
-    }
-
-    public int getMapSendOptions() {
-        return mapSendOptions;
-    }
-    
-    public ClassLoader[] getClassLoaders() {
-        Loader loader = null;
-        ClassLoader classLoader = null;
-        loader = this.getLoader();
-        if (loader != null) classLoader = loader.getClassLoader();
-        if ( classLoader == null ) classLoader = Thread.currentThread().getContextClassLoader();
-        if ( classLoader == Thread.currentThread().getContextClassLoader() ) {
-            return new ClassLoader[] {classLoader};
-        } else {
-            return new ClassLoader[] {classLoader,Thread.currentThread().getContextClassLoader()};
-        }
-    }
-    
-    public ServletContext getServletContext() {
-        return ((ReplApplContext)context).getFacade();
-
-    }
-
-    
-    protected static class ReplApplContext extends ApplicationContext {
-        public ReplApplContext(String basePath, StandardContext context) {
-            super(basePath,context);
-        }
-        
-         protected ServletContext getFacade() {
-             return super.getFacade();
-        }
-        
-        public HashMap getAttributeMap() {
-            return (HashMap)this.attributes;
-        }
-        public void setAttributeMap(HashMap map) {
-            this.attributes = map;
-        }
-
-    }
-
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.ha.context;
+
+import org.apache.catalina.core.StandardContext;
+import org.apache.catalina.LifecycleException;
+import org.apache.catalina.ha.CatalinaCluster;
+import org.apache.catalina.tribes.tipis.ReplicatedMap;
+import org.apache.catalina.tribes.Channel;
+import org.apache.catalina.Loader;
+import org.apache.catalina.core.ApplicationContext;
+import org.apache.catalina.Globals;
+import javax.servlet.ServletContext;
+import java.util.HashMap;
+import org.apache.catalina.tribes.tipis.LazyReplicatedMap;
+
+/**
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class ReplicatedContext extends StandardContext {
+    private int mapSendOptions = Channel.SEND_OPTIONS_DEFAULT;
+    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( ReplicatedContext.class );
+
+    protected static long DEFAULT_REPL_TIMEOUT = 15000;//15 seconds
+    
+
+
+    public synchronized void start() throws LifecycleException {
+        if ( this.started ) return;
+        try {
+            CatalinaCluster catclust = (CatalinaCluster)this.getCluster();
+            if (this.context == null) this.context = new ReplApplContext(this.getBasePath(), this);
+            if ( catclust != null ) {
+                ReplicatedMap map = new ReplicatedMap(this,catclust.getChannel(),DEFAULT_REPL_TIMEOUT,
+                                                      getName(),getClassLoaders());
+                map.setChannelSendOptions(mapSendOptions);
+                ((ReplApplContext)this.context).setAttributeMap(map);
+                if (getAltDDName() != null) context.setAttribute(Globals.ALT_DD_ATTR, getAltDDName());
+            }
+            super.start();
+        }  catch ( Exception x ) {
+            log.error("Unable to start ReplicatedContext",x);
+            throw new LifecycleException("Failed to start ReplicatedContext",x);
+        }
+    }
+    
+    public synchronized void stop() throws LifecycleException
+    {
+        ReplicatedMap map = (ReplicatedMap)((ReplApplContext)this.context).getAttributeMap();
+        if ( map!=null ) {
+            map.breakdown();
+        }
+        if ( !this.started ) return;
+        try {
+        } catch ( Exception x ){
+            log.error("Unable to stop ReplicatedContext",x);
+            throw new LifecycleException("Failed to stop ReplicatedContext",x);
+        } finally {
+            super.stop();
+        }
+
+    }
+
+
+    public void setMapSendOptions(int mapSendOptions) {
+        this.mapSendOptions = mapSendOptions;
+    }
+
+    public int getMapSendOptions() {
+        return mapSendOptions;
+    }
+    
+    public ClassLoader[] getClassLoaders() {
+        Loader loader = null;
+        ClassLoader classLoader = null;
+        loader = this.getLoader();
+        if (loader != null) classLoader = loader.getClassLoader();
+        if ( classLoader == null ) classLoader = Thread.currentThread().getContextClassLoader();
+        if ( classLoader == Thread.currentThread().getContextClassLoader() ) {
+            return new ClassLoader[] {classLoader};
+        } else {
+            return new ClassLoader[] {classLoader,Thread.currentThread().getContextClassLoader()};
+        }
+    }
+    
+    public ServletContext getServletContext() {
+        return ((ReplApplContext)context).getFacade();
+
+    }
+
+    
+    protected static class ReplApplContext extends ApplicationContext {
+        public ReplApplContext(String basePath, StandardContext context) {
+            super(basePath,context);
+        }
+        
+         protected ServletContext getFacade() {
+             return super.getFacade();
+        }
+        
+        public HashMap getAttributeMap() {
+            return (HashMap)this.attributes;
+        }
+        public void setAttributeMap(HashMap map) {
+            this.attributes = map;
+        }
+
+    }
+
+
 }
\ No newline at end of file

==================================================
FileChangeListener.java
index fffbdc43cd..dc17bb77f0 100644
--- a/java/org/apache/catalina/ha/deploy/FarmWarDeployer.java
+++ b/java/org/apache/catalina/ha/deploy/FarmWarDeployer.java
@@ -1,746 +1,747 @@
-/*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha.deploy;
-
-import java.io.File;
-import java.io.IOException;
-import java.net.URL;
-import java.util.HashMap;
-import javax.management.MBeanServer;
-import javax.management.ObjectName;
-
-import org.apache.catalina.Context;
-import org.apache.catalina.Engine;
-import org.apache.catalina.Host;
-import org.apache.catalina.Lifecycle;
-import org.apache.catalina.LifecycleException;
-import org.apache.catalina.ha.CatalinaCluster;
-import org.apache.catalina.ha.ClusterDeployer;
-import org.apache.catalina.ha.ClusterListener;
-import org.apache.catalina.ha.ClusterMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.tomcat.util.modeler.Registry;
-
-
-/**
- * <p>
- * A farm war deployer is a class that is able to deploy/undeploy web
- * applications in WAR form within the cluster.
- * </p>
- * Any host can act as the admin, and will have three directories
- * <ul>
- * <li>deployDir - the directory where we watch for changes</li>
- * <li>applicationDir - the directory where we install applications</li>
- * <li>tempDir - a temporaryDirectory to store binary data when downloading a
- * war from the cluster</li>
- * </ul>
- * Currently we only support deployment of WAR files since they are easier to
- * send across the wire.
- * 
- * @author Filip Hanik
- * @author Peter Rossbach
- * @version $Revision: 390639 $
- */
-public class FarmWarDeployer extends ClusterListener implements ClusterDeployer, FileChangeListener {
-    /*--Static Variables----------------------------------------*/
-    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory
-            .getLog(FarmWarDeployer.class);
-    /**
-     * The descriptive information about this implementation.
-     */
-    private static final String info = "FarmWarDeployer/1.2";
-
-    /*--Instance Variables--------------------------------------*/
-    protected CatalinaCluster cluster = null;
-
-    protected boolean started = false; //default 5 seconds
-
-    protected HashMap fileFactories = new HashMap();
-
-    protected String deployDir;
-
-    protected String tempDir;
-
-    protected String watchDir;
-
-    protected boolean watchEnabled = false;
-
-    protected WarWatcher watcher = null;
-
-    /**
-     * Iteration count for background processing.
-     */
-    private int count = 0;
-
-    /**
-     * Frequency of the Farm watchDir check. Cluster wide deployment will be
-     * done once for the specified amount of backgrondProcess calls (ie, the
-     * lower the amount, the most often the checks will occur).
-     */
-    protected int processDeployFrequency = 2;
-
-    /**
-     * Path where context descriptors should be deployed.
-     */
-    protected File configBase = null;
-
-    /**
-     * The associated host.
-     */
-    protected Host host = null;
-
-    /**
-     * The host appBase.
-     */
-    protected File appBase = null;
-
-    /**
-     * MBean server.
-     */
-    protected MBeanServer mBeanServer = null;
-
-    /**
-     * The associated deployer ObjectName.
-     */
-    protected ObjectName oname = null;
-
-    /*--Constructor---------------------------------------------*/
-    public FarmWarDeployer() {
-    }
-
-    /**
-     * Return descriptive information about this deployer implementation and the
-     * corresponding version number, in the format
-     * <code>&lt;description&gt;/&lt;version&gt;</code>.
-     */
-    public String getInfo() {
-
-        return (info);
-
-    }
-
-    /*--Logic---------------------------------------------------*/
-    public void start() throws Exception {
-        if (started)
-            return;
-        getCluster().addClusterListener(this);
-        if (watchEnabled) {
-            watcher = new WarWatcher(this, new File(getWatchDir()));
-            if (log.isInfoEnabled())
-                log.info("Cluster deployment is watching " + getWatchDir()
-                         + " for changes.");
-        }
-    
-        // Check to correct engine and host setup
-        Object parent = getCluster().getContainer();
-        Engine engine = null;
-        if ( parent instanceof Host ) {
-            host = (Host) parent;
-            engine = (Engine) host.getParent();
-        }else {
-            engine = (Engine)parent;
-        }
-        try {
-            oname = new ObjectName(engine.getName() + ":type=Deployer,host="
-                    + host.getName());
-        } catch (Exception e) {
-            log.error("Can't construct MBean object name" + e);
-        }
-        configBase = new File(System.getProperty("catalina.base"), "conf");
-        if (engine != null) {
-            configBase = new File(configBase, engine.getName());
-        } else if (host != null) {
-            configBase = new File(configBase, host.getName());
-        }
-
-        // Retrieve the MBean server
-        mBeanServer = Registry.getRegistry(null, null).getMBeanServer();
-
-        started = true;
-        count = 0;
-        if (log.isInfoEnabled())
-            log.info("Cluster FarmWarDeployer started.");
-    }
-
-    /*
-     * stop cluster wide deployments
-     * 
-     * @see org.apache.catalina.ha.ClusterDeployer#stop()
-     */
-    public void stop() throws LifecycleException {
-        started = false;
-        getCluster().removeClusterListener(this);
-        count = 0;
-        if (watcher != null) {
-            watcher.clear();
-            watcher = null;
-
-        }
-        if (log.isInfoEnabled())
-            log.info("Cluster FarmWarDeployer stopped.");
-    }
-
-    public void cleanDeployDir() {
-        throw new java.lang.UnsupportedOperationException(
-                "Method cleanDeployDir() not yet implemented.");
-    }
-
-    /**
-     * Callback from the cluster, when a message is received, The cluster will
-     * broadcast it invoking the messageReceived on the receiver.
-     * 
-     * @param msg
-     *            ClusterMessage - the message received from the cluster
-     */
-    public void messageReceived(ClusterMessage msg) {
-        try {
-            if (msg instanceof FileMessage && msg != null) {
-                FileMessage fmsg = (FileMessage) msg;
-                if (log.isDebugEnabled())
-                    log.debug("receive cluster deployment [ path: "
-                            + fmsg.getContextPath() + " war:  "
-                            + fmsg.getFileName() + " ]");
-                FileMessageFactory factory = getFactory(fmsg);
-                // TODO correct second try after app is in service!
-                if (factory.writeMessage(fmsg)) {
-                    //last message received war file is completed
-                    String name = factory.getFile().getName();
-                    if (!name.endsWith(".war"))
-                        name = name + ".war";
-                    File deployable = new File(getDeployDir(), name);
-                    try {
-                        String path = fmsg.getContextPath();
-                        if (!isServiced(path)) {
-                            addServiced(path);
-                            try {
-                                remove(path);
-                                factory.getFile().renameTo(deployable);
-                                check(path);
-                            } finally {
-                                removeServiced(path);
-                            }
-                            if (log.isDebugEnabled())
-                                log.debug("deployment from " + path
-                                        + " finished.");
-                        } else
-                            log.error("Application " + path
-                                    + " in used. touch war file " + name
-                                    + " again!");
-                    } catch (Exception ex) {
-                        log.error(ex);
-                    } finally {
-                        removeFactory(fmsg);
-                    }
-                }
-            } else if (msg instanceof UndeployMessage && msg != null) {
-                try {
-                    UndeployMessage umsg = (UndeployMessage) msg;
-                    String path = umsg.getContextPath();
-                    if (log.isDebugEnabled())
-                        log.debug("receive cluster undeployment from " + path);
-                    if (!isServiced(path)) {
-                        addServiced(path);
-                        try {
-                            remove(path);
-                        } finally {
-                            removeServiced(path);
-                        }
-                        if (log.isDebugEnabled())
-                            log.debug("undeployment from " + path
-                                    + " finished.");
-                    } else
-                        log.error("Application "
-                            + path
-                            + " in used. Sorry not remove from backup cluster nodes!");
-                } catch (Exception ex) {
-                    log.error(ex);
-                }
-            }
-        } catch (java.io.IOException x) {
-            log.error("Unable to read farm deploy file message.", x);
-        }
-    }
-
-    /**
-     * create factory for all transported war files
-     * 
-     * @param msg
-     * @return Factory for all app message (war files)
-     * @throws java.io.FileNotFoundException
-     * @throws java.io.IOException
-     */
-    public synchronized FileMessageFactory getFactory(FileMessage msg)
-            throws java.io.FileNotFoundException, java.io.IOException {
-        File tmpFile = new File(msg.getFileName());
-        File writeToFile = new File(getTempDir(), tmpFile.getName());
-        FileMessageFactory factory = (FileMessageFactory) fileFactories.get(msg
-                .getFileName());
-        if (factory == null) {
-            factory = FileMessageFactory.getInstance(writeToFile, true);
-            fileFactories.put(msg.getFileName(), factory);
-        }
-        return factory;
-    }
-
-    /**
-     * Remove file (war) from messages)
-     * 
-     * @param msg
-     */
-    public void removeFactory(FileMessage msg) {
-        fileFactories.remove(msg.getFileName());
-    }
-
-    /**
-     * Before the cluster invokes messageReceived the cluster will ask the
-     * receiver to accept or decline the message, In the future, when messages
-     * get big, the accept method will only take a message header
-     * 
-     * @param msg
-     *            ClusterMessage
-     * @return boolean - returns true to indicate that messageReceived should be
-     *         invoked. If false is returned, the messageReceived method will
-     *         not be invoked.
-     */
-    public boolean accept(ClusterMessage msg) {
-        return (msg instanceof FileMessage) || (msg instanceof UndeployMessage);
-    }
-
-    /**
-     * Install a new web application, whose web application archive is at the
-     * specified URL, into this container and all the other members of the
-     * cluster with the specified context path. A context path of "" (the empty
-     * string) should be used for the root application for this container.
-     * Otherwise, the context path must start with a slash.
-     * <p>
-     * If this application is successfully installed locally, a ContainerEvent
-     * of type <code>INSTALL_EVENT</code> will be sent to all registered
-     * listeners, with the newly created <code>Context</code> as an argument.
-     * 
-     * @param contextPath
-     *            The context path to which this application should be installed
-     *            (must be unique)
-     * @param war
-     *            A URL of type "jar:" that points to a WAR file, or type
-     *            "file:" that points to an unpacked directory structure
-     *            containing the web application to be installed
-     * 
-     * @exception IllegalArgumentException
-     *                if the specified context path is malformed (it must be ""
-     *                or start with a slash)
-     * @exception IllegalStateException
-     *                if the specified context path is already attached to an
-     *                existing web application
-     * @exception IOException
-     *                if an input/output error was encountered during
-     *                installation
-     */
-    public void install(String contextPath, URL war) throws IOException {
-        Member[] members = getCluster().getMembers();
-        Member localMember = getCluster().getLocalMember();
-        FileMessageFactory factory = FileMessageFactory.getInstance(new File(
-                war.getFile()), false);
-        FileMessage msg = new FileMessage(localMember, war.getFile(),
-                contextPath);
-        if(log.isDebugEnabled())
-            log.debug("Send cluster war deployment [ path:"
-                    + contextPath + " war: " + war + " ] started.");
-        msg = factory.readMessage(msg);
-        while (msg != null) {
-            for (int i = 0; i < members.length; i++) {
-                if (log.isDebugEnabled())
-                    log.debug("Send cluster war fragment [ path: "
-                            + contextPath + " war: " + war + " to: " +  members[i] + " ]");
-                getCluster().send(msg, members[i]);
-            }
-            msg = factory.readMessage(msg);
-        }
-        if(log.isDebugEnabled())
-            log.debug("Send cluster war deployment [ path: "
-                    + contextPath + " war: " + war + " ] finished.");
-    }
-
-    /**
-     * Remove an existing web application, attached to the specified context
-     * path. If this application is successfully removed, a ContainerEvent of
-     * type <code>REMOVE_EVENT</code> will be sent to all registered
-     * listeners, with the removed <code>Context</code> as an argument.
-     * Deletes the web application war file and/or directory if they exist in
-     * the Host's appBase.
-     * 
-     * @param contextPath
-     *            The context path of the application to be removed
-     * @param undeploy
-     *            boolean flag to remove web application from server
-     * 
-     * @exception IllegalArgumentException
-     *                if the specified context path is malformed (it must be ""
-     *                or start with a slash)
-     * @exception IllegalArgumentException
-     *                if the specified context path does not identify a
-     *                currently installed web application
-     * @exception IOException
-     *                if an input/output error occurs during removal
-     */
-    public void remove(String contextPath, boolean undeploy) throws IOException {
-        if (log.isInfoEnabled())
-            log.info("Cluster wide remove of web app " + contextPath);
-        Member localMember = getCluster().getLocalMember();
-        UndeployMessage msg = new UndeployMessage(localMember, System
-                .currentTimeMillis(), "Undeploy:" + contextPath + ":"
-                + System.currentTimeMillis(), contextPath, undeploy);
-        if (log.isDebugEnabled())
-            log.debug("Send cluster wide undeployment from "
-                    + contextPath );
-        cluster.send(msg);
-        // remove locally
-        if (undeploy) {
-            try {
-                if (!isServiced(contextPath)) {
-                    addServiced(contextPath);
-                    try {
-                        remove(contextPath);
-                    } finally {
-                        removeServiced(contextPath);
-                    }
-                } else
-                    log.error("Local remove from " + contextPath
-                            + "failed, other manager has app in service!");
-
-            } catch (Exception ex) {
-                log.error("local remove from " + contextPath + " failed", ex);
-            }
-        }
-
-    }
-
-    /*
-     * Modifcation from watchDir war detected!
-     * 
-     * @see org.apache.catalina.ha.deploy.FileChangeListener#fileModified(java.io.File)
-     */
-    public void fileModified(File newWar) {
-        try {
-            File deployWar = new File(getDeployDir(), newWar.getName());
-            copy(newWar, deployWar);
-            String contextName = getContextName(deployWar);
-            if (log.isInfoEnabled())
-                log.info("Installing webapp[" + contextName + "] from "
-                        + deployWar.getAbsolutePath());
-            try {
-                remove(contextName, false);
-            } catch (Exception x) {
-                log.error("No removal", x);
-            }
-            install(contextName, deployWar.toURL());
-        } catch (Exception x) {
-            log.error("Unable to install WAR file", x);
-        }
-    }
-
-    /*
-     * War remvoe from watchDir
-     * 
-     * @see org.apache.catalina.ha.deploy.FileChangeListener#fileRemoved(java.io.File)
-     */
-    public void fileRemoved(File removeWar) {
-        try {
-            String contextName = getContextName(removeWar);
-            if (log.isInfoEnabled())
-                log.info("Removing webapp[" + contextName + "]");
-            remove(contextName, true);
-        } catch (Exception x) {
-            log.error("Unable to remove WAR file", x);
-        }
-    }
-
-    /**
-     * Create a context path from war
-     * @param war War filename
-     * @return '/filename' or if war name is ROOT.war context name is empty string '' 
-     */
-    protected String getContextName(File war) {
-        String contextName = "/"
-        + war.getName().substring(0,
-                war.getName().lastIndexOf(".war"));
-        if("/ROOT".equals(contextName))
-            contextName= "" ;
-        return contextName ;
-    }
-    
-    /**
-     * Given a context path, get the config file name.
-     */
-    protected String getConfigFile(String path) {
-        String basename = null;
-        if (path.equals("")) {
-            basename = "ROOT";
-        } else {
-            basename = path.substring(1).replace('/', '#');
-        }
-        return (basename);
-    }
-
-    /**
-     * Given a context path, get the config file name.
-     */
-    protected String getDocBase(String path) {
-        String basename = null;
-        if (path.equals("")) {
-            basename = "ROOT";
-        } else {
-            basename = path.substring(1);
-        }
-        return (basename);
-    }
-
-    /**
-     * Return a File object representing the "application root" directory for
-     * our associated Host.
-     */
-    protected File getAppBase() {
-
-        if (appBase != null) {
-            return appBase;
-        }
-
-        File file = new File(host.getAppBase());
-        if (!file.isAbsolute())
-            file = new File(System.getProperty("catalina.base"), host
-                    .getAppBase());
-        try {
-            appBase = file.getCanonicalFile();
-        } catch (IOException e) {
-            appBase = file;
-        }
-        return (appBase);
-
-    }
-
-    /**
-     * Invoke the remove method on the deployer.
-     */
-    protected void remove(String path) throws Exception {
-        // TODO Handle remove also work dir content !
-        // Stop the context first to be nicer
-        Context context = (Context) host.findChild(path);
-        if (context != null) {
-            if(log.isDebugEnabled())
-                log.debug("Undeploy local context " +path );
-            ((Lifecycle) context).stop();
-            File war = new File(getAppBase(), getDocBase(path) + ".war");
-            File dir = new File(getAppBase(), getDocBase(path));
-            File xml = new File(configBase, getConfigFile(path) + ".xml");
-            if (war.exists()) {
-                war.delete();
-            } else if (dir.exists()) {
-                undeployDir(dir);
-            } else {
-                xml.delete();
-            }
-            // Perform new deployment and remove internal HostConfig state
-            check(path);
-        }
-
-    }
-
-    /**
-     * Delete the specified directory, including all of its contents and
-     * subdirectories recursively.
-     * 
-     * @param dir
-     *            File object representing the directory to be deleted
-     */
-    protected void undeployDir(File dir) {
-
-        String files[] = dir.list();
-        if (files == null) {
-            files = new String[0];
-        }
-        for (int i = 0; i < files.length; i++) {
-            File file = new File(dir, files[i]);
-            if (file.isDirectory()) {
-                undeployDir(file);
-            } else {
-                file.delete();
-            }
-        }
-        dir.delete();
-
-    }
-
-    /*
-     * Call watcher to check for deploy changes
-     * 
-     * @see org.apache.catalina.ha.ClusterDeployer#backgroundProcess()
-     */
-    public void backgroundProcess() {
-        if (started) {
-            count = (count + 1) % processDeployFrequency;
-            if (count == 0 && watchEnabled) {
-                watcher.check();
-            }
-        }
-
-    }
-
-    /*--Deployer Operations ------------------------------------*/
-
-    /**
-     * Invoke the check method on the deployer.
-     */
-    protected void check(String name) throws Exception {
-        String[] params = { name };
-        String[] signature = { "java.lang.String" };
-        mBeanServer.invoke(oname, "check", params, signature);
-    }
-
-    /**
-     * Invoke the check method on the deployer.
-     */
-    protected boolean isServiced(String name) throws Exception {
-        String[] params = { name };
-        String[] signature = { "java.lang.String" };
-        Boolean result = (Boolean) mBeanServer.invoke(oname, "isServiced",
-                params, signature);
-        return result.booleanValue();
-    }
-
-    /**
-     * Invoke the check method on the deployer.
-     */
-    protected void addServiced(String name) throws Exception {
-        String[] params = { name };
-        String[] signature = { "java.lang.String" };
-        mBeanServer.invoke(oname, "addServiced", params, signature);
-    }
-
-    /**
-     * Invoke the check method on the deployer.
-     */
-    protected void removeServiced(String name) throws Exception {
-        String[] params = { name };
-        String[] signature = { "java.lang.String" };
-        mBeanServer.invoke(oname, "removeServiced", params, signature);
-    }
-
-    /*--Instance Getters/Setters--------------------------------*/
-    public CatalinaCluster getCluster() {
-        return cluster;
-    }
-
-    public void setCluster(CatalinaCluster cluster) {
-        this.cluster = cluster;
-    }
-
-    public boolean equals(Object listener) {
-        return super.equals(listener);
-    }
-
-    public int hashCode() {
-        return super.hashCode();
-    }
-
-    public String getDeployDir() {
-        return deployDir;
-    }
-
-    public void setDeployDir(String deployDir) {
-        this.deployDir = deployDir;
-    }
-
-    public String getTempDir() {
-        return tempDir;
-    }
-
-    public void setTempDir(String tempDir) {
-        this.tempDir = tempDir;
-    }
-
-    public String getWatchDir() {
-        return watchDir;
-    }
-
-    public void setWatchDir(String watchDir) {
-        this.watchDir = watchDir;
-    }
-
-    public boolean isWatchEnabled() {
-        return watchEnabled;
-    }
-
-    public boolean getWatchEnabled() {
-        return watchEnabled;
-    }
-
-    public void setWatchEnabled(boolean watchEnabled) {
-        this.watchEnabled = watchEnabled;
-    }
-
-    /**
-     * Return the frequency of watcher checks.
-     */
-    public int getProcessDeployFrequency() {
-
-        return (this.processDeployFrequency);
-
-    }
-
-    /**
-     * Set the watcher checks frequency.
-     * 
-     * @param processExpiresFrequency
-     *            the new manager checks frequency
-     */
-    public void setProcessDeployFrequency(int processExpiresFrequency) {
-
-        if (processExpiresFrequency <= 0) {
-            return;
-        }
-        this.processDeployFrequency = processExpiresFrequency;
-    }
-
-    /**
-     * Copy a file to the specified temp directory.
-     * @param from copy from temp
-     * @param to   to host appBase directory
-     * @return true, copy successful
-     */
-    protected boolean copy(File from, File to) {
-        try {
-            if (!to.exists())
-                to.createNewFile();
-            java.io.FileInputStream is = new java.io.FileInputStream(from);
-            java.io.FileOutputStream os = new java.io.FileOutputStream(to,
-                    false);
-            byte[] buf = new byte[4096];
-            while (true) {
-                int len = is.read(buf);
-                if (len < 0)
-                    break;
-                os.write(buf, 0, len);
-            }
-            is.close();
-            os.close();
-        } catch (IOException e) {
-            log.error("Unable to copy file from:" + from + " to:" + to, e);
-            return false;
-        }
-        return true;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha.deploy;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.URL;
+import java.util.HashMap;
+import javax.management.MBeanServer;
+import javax.management.ObjectName;
+
+import org.apache.catalina.Context;
+import org.apache.catalina.Engine;
+import org.apache.catalina.Host;
+import org.apache.catalina.Lifecycle;
+import org.apache.catalina.LifecycleException;
+import org.apache.catalina.ha.CatalinaCluster;
+import org.apache.catalina.ha.ClusterDeployer;
+import org.apache.catalina.ha.ClusterListener;
+import org.apache.catalina.ha.ClusterMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.tomcat.util.modeler.Registry;
+
+
+/**
+ * <p>
+ * A farm war deployer is a class that is able to deploy/undeploy web
+ * applications in WAR form within the cluster.
+ * </p>
+ * Any host can act as the admin, and will have three directories
+ * <ul>
+ * <li>deployDir - the directory where we watch for changes</li>
+ * <li>applicationDir - the directory where we install applications</li>
+ * <li>tempDir - a temporaryDirectory to store binary data when downloading a
+ * war from the cluster</li>
+ * </ul>
+ * Currently we only support deployment of WAR files since they are easier to
+ * send across the wire.
+ * 
+ * @author Filip Hanik
+ * @author Peter Rossbach
+ * @version $Revision: 390639 $
+ */
+public class FarmWarDeployer extends ClusterListener implements ClusterDeployer, FileChangeListener {
+    /*--Static Variables----------------------------------------*/
+    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory
+            .getLog(FarmWarDeployer.class);
+    /**
+     * The descriptive information about this implementation.
+     */
+    private static final String info = "FarmWarDeployer/1.2";
+
+    /*--Instance Variables--------------------------------------*/
+    protected CatalinaCluster cluster = null;
+
+    protected boolean started = false; //default 5 seconds
+
+    protected HashMap fileFactories = new HashMap();
+
+    protected String deployDir;
+
+    protected String tempDir;
+
+    protected String watchDir;
+
+    protected boolean watchEnabled = false;
+
+    protected WarWatcher watcher = null;
+
+    /**
+     * Iteration count for background processing.
+     */
+    private int count = 0;
+
+    /**
+     * Frequency of the Farm watchDir check. Cluster wide deployment will be
+     * done once for the specified amount of backgrondProcess calls (ie, the
+     * lower the amount, the most often the checks will occur).
+     */
+    protected int processDeployFrequency = 2;
+
+    /**
+     * Path where context descriptors should be deployed.
+     */
+    protected File configBase = null;
+
+    /**
+     * The associated host.
+     */
+    protected Host host = null;
+
+    /**
+     * The host appBase.
+     */
+    protected File appBase = null;
+
+    /**
+     * MBean server.
+     */
+    protected MBeanServer mBeanServer = null;
+
+    /**
+     * The associated deployer ObjectName.
+     */
+    protected ObjectName oname = null;
+
+    /*--Constructor---------------------------------------------*/
+    public FarmWarDeployer() {
+    }
+
+    /**
+     * Return descriptive information about this deployer implementation and the
+     * corresponding version number, in the format
+     * <code>&lt;description&gt;/&lt;version&gt;</code>.
+     */
+    public String getInfo() {
+
+        return (info);
+
+    }
+
+    /*--Logic---------------------------------------------------*/
+    public void start() throws Exception {
+        if (started)
+            return;
+        getCluster().addClusterListener(this);
+        if (watchEnabled) {
+            watcher = new WarWatcher(this, new File(getWatchDir()));
+            if (log.isInfoEnabled())
+                log.info("Cluster deployment is watching " + getWatchDir()
+                         + " for changes.");
+        }
+    
+        // Check to correct engine and host setup
+        Object parent = getCluster().getContainer();
+        Engine engine = null;
+        if ( parent instanceof Host ) {
+            host = (Host) parent;
+            engine = (Engine) host.getParent();
+        }else {
+            engine = (Engine)parent;
+        }
+        try {
+            oname = new ObjectName(engine.getName() + ":type=Deployer,host="
+                    + host.getName());
+        } catch (Exception e) {
+            log.error("Can't construct MBean object name" + e);
+        }
+        configBase = new File(System.getProperty("catalina.base"), "conf");
+        if (engine != null) {
+            configBase = new File(configBase, engine.getName());
+        } else if (host != null) {
+            configBase = new File(configBase, host.getName());
+        }
+
+        // Retrieve the MBean server
+        mBeanServer = Registry.getRegistry(null, null).getMBeanServer();
+
+        started = true;
+        count = 0;
+        if (log.isInfoEnabled())
+            log.info("Cluster FarmWarDeployer started.");
+    }
+
+    /*
+     * stop cluster wide deployments
+     * 
+     * @see org.apache.catalina.ha.ClusterDeployer#stop()
+     */
+    public void stop() throws LifecycleException {
+        started = false;
+        getCluster().removeClusterListener(this);
+        count = 0;
+        if (watcher != null) {
+            watcher.clear();
+            watcher = null;
+
+        }
+        if (log.isInfoEnabled())
+            log.info("Cluster FarmWarDeployer stopped.");
+    }
+
+    public void cleanDeployDir() {
+        throw new java.lang.UnsupportedOperationException(
+                "Method cleanDeployDir() not yet implemented.");
+    }
+
+    /**
+     * Callback from the cluster, when a message is received, The cluster will
+     * broadcast it invoking the messageReceived on the receiver.
+     * 
+     * @param msg
+     *            ClusterMessage - the message received from the cluster
+     */
+    public void messageReceived(ClusterMessage msg) {
+        try {
+            if (msg instanceof FileMessage && msg != null) {
+                FileMessage fmsg = (FileMessage) msg;
+                if (log.isDebugEnabled())
+                    log.debug("receive cluster deployment [ path: "
+                            + fmsg.getContextPath() + " war:  "
+                            + fmsg.getFileName() + " ]");
+                FileMessageFactory factory = getFactory(fmsg);
+                // TODO correct second try after app is in service!
+                if (factory.writeMessage(fmsg)) {
+                    //last message received war file is completed
+                    String name = factory.getFile().getName();
+                    if (!name.endsWith(".war"))
+                        name = name + ".war";
+                    File deployable = new File(getDeployDir(), name);
+                    try {
+                        String path = fmsg.getContextPath();
+                        if (!isServiced(path)) {
+                            addServiced(path);
+                            try {
+                                remove(path);
+                                factory.getFile().renameTo(deployable);
+                                check(path);
+                            } finally {
+                                removeServiced(path);
+                            }
+                            if (log.isDebugEnabled())
+                                log.debug("deployment from " + path
+                                        + " finished.");
+                        } else
+                            log.error("Application " + path
+                                    + " in used. touch war file " + name
+                                    + " again!");
+                    } catch (Exception ex) {
+                        log.error(ex);
+                    } finally {
+                        removeFactory(fmsg);
+                    }
+                }
+            } else if (msg instanceof UndeployMessage && msg != null) {
+                try {
+                    UndeployMessage umsg = (UndeployMessage) msg;
+                    String path = umsg.getContextPath();
+                    if (log.isDebugEnabled())
+                        log.debug("receive cluster undeployment from " + path);
+                    if (!isServiced(path)) {
+                        addServiced(path);
+                        try {
+                            remove(path);
+                        } finally {
+                            removeServiced(path);
+                        }
+                        if (log.isDebugEnabled())
+                            log.debug("undeployment from " + path
+                                    + " finished.");
+                    } else
+                        log.error("Application "
+                            + path
+                            + " in used. Sorry not remove from backup cluster nodes!");
+                } catch (Exception ex) {
+                    log.error(ex);
+                }
+            }
+        } catch (java.io.IOException x) {
+            log.error("Unable to read farm deploy file message.", x);
+        }
+    }
+
+    /**
+     * create factory for all transported war files
+     * 
+     * @param msg
+     * @return Factory for all app message (war files)
+     * @throws java.io.FileNotFoundException
+     * @throws java.io.IOException
+     */
+    public synchronized FileMessageFactory getFactory(FileMessage msg)
+            throws java.io.FileNotFoundException, java.io.IOException {
+        File tmpFile = new File(msg.getFileName());
+        File writeToFile = new File(getTempDir(), tmpFile.getName());
+        FileMessageFactory factory = (FileMessageFactory) fileFactories.get(msg
+                .getFileName());
+        if (factory == null) {
+            factory = FileMessageFactory.getInstance(writeToFile, true);
+            fileFactories.put(msg.getFileName(), factory);
+        }
+        return factory;
+    }
+
+    /**
+     * Remove file (war) from messages)
+     * 
+     * @param msg
+     */
+    public void removeFactory(FileMessage msg) {
+        fileFactories.remove(msg.getFileName());
+    }
+
+    /**
+     * Before the cluster invokes messageReceived the cluster will ask the
+     * receiver to accept or decline the message, In the future, when messages
+     * get big, the accept method will only take a message header
+     * 
+     * @param msg
+     *            ClusterMessage
+     * @return boolean - returns true to indicate that messageReceived should be
+     *         invoked. If false is returned, the messageReceived method will
+     *         not be invoked.
+     */
+    public boolean accept(ClusterMessage msg) {
+        return (msg instanceof FileMessage) || (msg instanceof UndeployMessage);
+    }
+
+    /**
+     * Install a new web application, whose web application archive is at the
+     * specified URL, into this container and all the other members of the
+     * cluster with the specified context path. A context path of "" (the empty
+     * string) should be used for the root application for this container.
+     * Otherwise, the context path must start with a slash.
+     * <p>
+     * If this application is successfully installed locally, a ContainerEvent
+     * of type <code>INSTALL_EVENT</code> will be sent to all registered
+     * listeners, with the newly created <code>Context</code> as an argument.
+     * 
+     * @param contextPath
+     *            The context path to which this application should be installed
+     *            (must be unique)
+     * @param war
+     *            A URL of type "jar:" that points to a WAR file, or type
+     *            "file:" that points to an unpacked directory structure
+     *            containing the web application to be installed
+     * 
+     * @exception IllegalArgumentException
+     *                if the specified context path is malformed (it must be ""
+     *                or start with a slash)
+     * @exception IllegalStateException
+     *                if the specified context path is already attached to an
+     *                existing web application
+     * @exception IOException
+     *                if an input/output error was encountered during
+     *                installation
+     */
+    public void install(String contextPath, URL war) throws IOException {
+        Member[] members = getCluster().getMembers();
+        Member localMember = getCluster().getLocalMember();
+        FileMessageFactory factory = FileMessageFactory.getInstance(new File(
+                war.getFile()), false);
+        FileMessage msg = new FileMessage(localMember, war.getFile(),
+                contextPath);
+        if(log.isDebugEnabled())
+            log.debug("Send cluster war deployment [ path:"
+                    + contextPath + " war: " + war + " ] started.");
+        msg = factory.readMessage(msg);
+        while (msg != null) {
+            for (int i = 0; i < members.length; i++) {
+                if (log.isDebugEnabled())
+                    log.debug("Send cluster war fragment [ path: "
+                            + contextPath + " war: " + war + " to: " +  members[i] + " ]");
+                getCluster().send(msg, members[i]);
+            }
+            msg = factory.readMessage(msg);
+        }
+        if(log.isDebugEnabled())
+            log.debug("Send cluster war deployment [ path: "
+                    + contextPath + " war: " + war + " ] finished.");
+    }
+
+    /**
+     * Remove an existing web application, attached to the specified context
+     * path. If this application is successfully removed, a ContainerEvent of
+     * type <code>REMOVE_EVENT</code> will be sent to all registered
+     * listeners, with the removed <code>Context</code> as an argument.
+     * Deletes the web application war file and/or directory if they exist in
+     * the Host's appBase.
+     * 
+     * @param contextPath
+     *            The context path of the application to be removed
+     * @param undeploy
+     *            boolean flag to remove web application from server
+     * 
+     * @exception IllegalArgumentException
+     *                if the specified context path is malformed (it must be ""
+     *                or start with a slash)
+     * @exception IllegalArgumentException
+     *                if the specified context path does not identify a
+     *                currently installed web application
+     * @exception IOException
+     *                if an input/output error occurs during removal
+     */
+    public void remove(String contextPath, boolean undeploy) throws IOException {
+        if (log.isInfoEnabled())
+            log.info("Cluster wide remove of web app " + contextPath);
+        Member localMember = getCluster().getLocalMember();
+        UndeployMessage msg = new UndeployMessage(localMember, System
+                .currentTimeMillis(), "Undeploy:" + contextPath + ":"
+                + System.currentTimeMillis(), contextPath, undeploy);
+        if (log.isDebugEnabled())
+            log.debug("Send cluster wide undeployment from "
+                    + contextPath );
+        cluster.send(msg);
+        // remove locally
+        if (undeploy) {
+            try {
+                if (!isServiced(contextPath)) {
+                    addServiced(contextPath);
+                    try {
+                        remove(contextPath);
+                    } finally {
+                        removeServiced(contextPath);
+                    }
+                } else
+                    log.error("Local remove from " + contextPath
+                            + "failed, other manager has app in service!");
+
+            } catch (Exception ex) {
+                log.error("local remove from " + contextPath + " failed", ex);
+            }
+        }
+
+    }
+
+    /*
+     * Modifcation from watchDir war detected!
+     * 
+     * @see org.apache.catalina.ha.deploy.FileChangeListener#fileModified(java.io.File)
+     */
+    public void fileModified(File newWar) {
+        try {
+            File deployWar = new File(getDeployDir(), newWar.getName());
+            copy(newWar, deployWar);
+            String contextName = getContextName(deployWar);
+            if (log.isInfoEnabled())
+                log.info("Installing webapp[" + contextName + "] from "
+                        + deployWar.getAbsolutePath());
+            try {
+                remove(contextName, false);
+            } catch (Exception x) {
+                log.error("No removal", x);
+            }
+            install(contextName, deployWar.toURL());
+        } catch (Exception x) {
+            log.error("Unable to install WAR file", x);
+        }
+    }
+
+    /*
+     * War remvoe from watchDir
+     * 
+     * @see org.apache.catalina.ha.deploy.FileChangeListener#fileRemoved(java.io.File)
+     */
+    public void fileRemoved(File removeWar) {
+        try {
+            String contextName = getContextName(removeWar);
+            if (log.isInfoEnabled())
+                log.info("Removing webapp[" + contextName + "]");
+            remove(contextName, true);
+        } catch (Exception x) {
+            log.error("Unable to remove WAR file", x);
+        }
+    }
+
+    /**
+     * Create a context path from war
+     * @param war War filename
+     * @return '/filename' or if war name is ROOT.war context name is empty string '' 
+     */
+    protected String getContextName(File war) {
+        String contextName = "/"
+        + war.getName().substring(0,
+                war.getName().lastIndexOf(".war"));
+        if("/ROOT".equals(contextName))
+            contextName= "" ;
+        return contextName ;
+    }
+    
+    /**
+     * Given a context path, get the config file name.
+     */
+    protected String getConfigFile(String path) {
+        String basename = null;
+        if (path.equals("")) {
+            basename = "ROOT";
+        } else {
+            basename = path.substring(1).replace('/', '#');
+        }
+        return (basename);
+    }
+
+    /**
+     * Given a context path, get the config file name.
+     */
+    protected String getDocBase(String path) {
+        String basename = null;
+        if (path.equals("")) {
+            basename = "ROOT";
+        } else {
+            basename = path.substring(1);
+        }
+        return (basename);
+    }
+
+    /**
+     * Return a File object representing the "application root" directory for
+     * our associated Host.
+     */
+    protected File getAppBase() {
+
+        if (appBase != null) {
+            return appBase;
+        }
+
+        File file = new File(host.getAppBase());
+        if (!file.isAbsolute())
+            file = new File(System.getProperty("catalina.base"), host
+                    .getAppBase());
+        try {
+            appBase = file.getCanonicalFile();
+        } catch (IOException e) {
+            appBase = file;
+        }
+        return (appBase);
+
+    }
+
+    /**
+     * Invoke the remove method on the deployer.
+     */
+    protected void remove(String path) throws Exception {
+        // TODO Handle remove also work dir content !
+        // Stop the context first to be nicer
+        Context context = (Context) host.findChild(path);
+        if (context != null) {
+            if(log.isDebugEnabled())
+                log.debug("Undeploy local context " +path );
+            ((Lifecycle) context).stop();
+            File war = new File(getAppBase(), getDocBase(path) + ".war");
+            File dir = new File(getAppBase(), getDocBase(path));
+            File xml = new File(configBase, getConfigFile(path) + ".xml");
+            if (war.exists()) {
+                war.delete();
+            } else if (dir.exists()) {
+                undeployDir(dir);
+            } else {
+                xml.delete();
+            }
+            // Perform new deployment and remove internal HostConfig state
+            check(path);
+        }
+
+    }
+
+    /**
+     * Delete the specified directory, including all of its contents and
+     * subdirectories recursively.
+     * 
+     * @param dir
+     *            File object representing the directory to be deleted
+     */
+    protected void undeployDir(File dir) {
+
+        String files[] = dir.list();
+        if (files == null) {
+            files = new String[0];
+        }
+        for (int i = 0; i < files.length; i++) {
+            File file = new File(dir, files[i]);
+            if (file.isDirectory()) {
+                undeployDir(file);
+            } else {
+                file.delete();
+            }
+        }
+        dir.delete();
+
+    }
+
+    /*
+     * Call watcher to check for deploy changes
+     * 
+     * @see org.apache.catalina.ha.ClusterDeployer#backgroundProcess()
+     */
+    public void backgroundProcess() {
+        if (started) {
+            count = (count + 1) % processDeployFrequency;
+            if (count == 0 && watchEnabled) {
+                watcher.check();
+            }
+        }
+
+    }
+
+    /*--Deployer Operations ------------------------------------*/
+
+    /**
+     * Invoke the check method on the deployer.
+     */
+    protected void check(String name) throws Exception {
+        String[] params = { name };
+        String[] signature = { "java.lang.String" };
+        mBeanServer.invoke(oname, "check", params, signature);
+    }
+
+    /**
+     * Invoke the check method on the deployer.
+     */
+    protected boolean isServiced(String name) throws Exception {
+        String[] params = { name };
+        String[] signature = { "java.lang.String" };
+        Boolean result = (Boolean) mBeanServer.invoke(oname, "isServiced",
+                params, signature);
+        return result.booleanValue();
+    }
+
+    /**
+     * Invoke the check method on the deployer.
+     */
+    protected void addServiced(String name) throws Exception {
+        String[] params = { name };
+        String[] signature = { "java.lang.String" };
+        mBeanServer.invoke(oname, "addServiced", params, signature);
+    }
+
+    /**
+     * Invoke the check method on the deployer.
+     */
+    protected void removeServiced(String name) throws Exception {
+        String[] params = { name };
+        String[] signature = { "java.lang.String" };
+        mBeanServer.invoke(oname, "removeServiced", params, signature);
+    }
+
+    /*--Instance Getters/Setters--------------------------------*/
+    public CatalinaCluster getCluster() {
+        return cluster;
+    }
+
+    public void setCluster(CatalinaCluster cluster) {
+        this.cluster = cluster;
+    }
+
+    public boolean equals(Object listener) {
+        return super.equals(listener);
+    }
+
+    public int hashCode() {
+        return super.hashCode();
+    }
+
+    public String getDeployDir() {
+        return deployDir;
+    }
+
+    public void setDeployDir(String deployDir) {
+        this.deployDir = deployDir;
+    }
+
+    public String getTempDir() {
+        return tempDir;
+    }
+
+    public void setTempDir(String tempDir) {
+        this.tempDir = tempDir;
+    }
+
+    public String getWatchDir() {
+        return watchDir;
+    }
+
+    public void setWatchDir(String watchDir) {
+        this.watchDir = watchDir;
+    }
+
+    public boolean isWatchEnabled() {
+        return watchEnabled;
+    }
+
+    public boolean getWatchEnabled() {
+        return watchEnabled;
+    }
+
+    public void setWatchEnabled(boolean watchEnabled) {
+        this.watchEnabled = watchEnabled;
+    }
+
+    /**
+     * Return the frequency of watcher checks.
+     */
+    public int getProcessDeployFrequency() {
+
+        return (this.processDeployFrequency);
+
+    }
+
+    /**
+     * Set the watcher checks frequency.
+     * 
+     * @param processExpiresFrequency
+     *            the new manager checks frequency
+     */
+    public void setProcessDeployFrequency(int processExpiresFrequency) {
+
+        if (processExpiresFrequency <= 0) {
+            return;
+        }
+        this.processDeployFrequency = processExpiresFrequency;
+    }
+
+    /**
+     * Copy a file to the specified temp directory.
+     * @param from copy from temp
+     * @param to   to host appBase directory
+     * @return true, copy successful
+     */
+    protected boolean copy(File from, File to) {
+        try {
+            if (!to.exists())
+                to.createNewFile();
+            java.io.FileInputStream is = new java.io.FileInputStream(from);
+            java.io.FileOutputStream os = new java.io.FileOutputStream(to,
+                    false);
+            byte[] buf = new byte[4096];
+            while (true) {
+                int len = is.read(buf);
+                if (len < 0)
+                    break;
+                os.write(buf, 0, len);
+            }
+            is.close();
+            os.close();
+        } catch (IOException e) {
+            log.error("Unable to copy file from:" + from + " to:" + to, e);
+            return false;
+        }
+        return true;
+    }
+
+}

==================================================
FileMessage.java
index 3468622c84..51858cc0f4 100644
--- a/java/org/apache/catalina/ha/deploy/FileChangeListener.java
+++ b/java/org/apache/catalina/ha/deploy/FileChangeListener.java
@@ -1,23 +1,24 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha.deploy;
-import java.io.File;
-
-public interface FileChangeListener {
-    public void fileModified(File f);
-    public void fileRemoved(File f);
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha.deploy;
+import java.io.File;
+
+public interface FileChangeListener {
+    public void fileModified(File f);
+    public void fileRemoved(File f);
+}

==================================================
FileMessageFactory.java
index ab2847ec3a..acab7fd4da 100644
--- a/java/org/apache/catalina/ha/deploy/FileMessage.java
+++ b/java/org/apache/catalina/ha/deploy/FileMessage.java
@@ -1,112 +1,113 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha.deploy;
-
-import java.io.Serializable;
-
-import org.apache.catalina.ha.ClusterMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.ha.ClusterMessageBase;
-
-/**
- * Contains the data for a file being transferred over TCP, this is 
- * essentially a fragment of a file, read and written by the FileMessageFactory
- * @author Filip Hanik
- * @version 1.0
- */
-
-public class FileMessage extends ClusterMessageBase implements ClusterMessage, Serializable {
-    private int messageNumber;
-    private byte[] data;
-    private int dataLength;
-    
-    private long totalLength;
-    private long totalNrOfMsgs;
-    private String fileName;
-    private String contextPath;
-    
-    public FileMessage(Member source,
-                       String fileName,
-                       String contextPath) {
-        this.address=source;
-        this.fileName=fileName;
-        this.contextPath=contextPath;
-    }
-    
-    /*
-    public void writeExternal(ObjectOutput out) throws IOException {
-                   
-    }
-    
-    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
-                  
-    }
-    */
-   
-    public int getMessageNumber() {
-        return messageNumber;
-    }
-    public void setMessageNumber(int messageNumber) {
-        this.messageNumber = messageNumber;
-    }
-    public long getTotalNrOfMsgs() {
-        return totalNrOfMsgs;
-    }
-    public void setTotalNrOfMsgs(long totalNrOfMsgs) {
-        this.totalNrOfMsgs = totalNrOfMsgs;
-    }
-    public byte[] getData() {
-        return data;
-    }
-    public void setData(byte[] data, int length) {
-        this.data = data;
-        this.dataLength = length;
-    }
-    public int getDataLength() {
-        return dataLength;
-    }
-    public void setDataLength(int dataLength) {
-        this.dataLength = dataLength;
-    }
-    public long getTotalLength() {
-        return totalLength;
-    }
-    public void setTotalLength(long totalLength) {
-        this.totalLength = totalLength;
-    }
-
-    public String getUniqueId() {
-        StringBuffer result = new StringBuffer(getFileName());
-        result.append("#-#");
-        result.append(getMessageNumber());
-        result.append("#-#");
-        result.append(System.currentTimeMillis());
-        return result.toString();
-    }
-
-    
-    public String getFileName() {
-        return fileName;
-    }
-    public void setFileName(String fileName) {
-        this.fileName = fileName;
-    }
-    public String getContextPath() {
-        return contextPath;
-    }
-    
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha.deploy;
+
+import java.io.Serializable;
+
+import org.apache.catalina.ha.ClusterMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.ha.ClusterMessageBase;
+
+/**
+ * Contains the data for a file being transferred over TCP, this is 
+ * essentially a fragment of a file, read and written by the FileMessageFactory
+ * @author Filip Hanik
+ * @version 1.0
+ */
+
+public class FileMessage extends ClusterMessageBase implements ClusterMessage, Serializable {
+    private int messageNumber;
+    private byte[] data;
+    private int dataLength;
+    
+    private long totalLength;
+    private long totalNrOfMsgs;
+    private String fileName;
+    private String contextPath;
+    
+    public FileMessage(Member source,
+                       String fileName,
+                       String contextPath) {
+        this.address=source;
+        this.fileName=fileName;
+        this.contextPath=contextPath;
+    }
+    
+    /*
+    public void writeExternal(ObjectOutput out) throws IOException {
+                   
+    }
+    
+    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
+                  
+    }
+    */
+   
+    public int getMessageNumber() {
+        return messageNumber;
+    }
+    public void setMessageNumber(int messageNumber) {
+        this.messageNumber = messageNumber;
+    }
+    public long getTotalNrOfMsgs() {
+        return totalNrOfMsgs;
+    }
+    public void setTotalNrOfMsgs(long totalNrOfMsgs) {
+        this.totalNrOfMsgs = totalNrOfMsgs;
+    }
+    public byte[] getData() {
+        return data;
+    }
+    public void setData(byte[] data, int length) {
+        this.data = data;
+        this.dataLength = length;
+    }
+    public int getDataLength() {
+        return dataLength;
+    }
+    public void setDataLength(int dataLength) {
+        this.dataLength = dataLength;
+    }
+    public long getTotalLength() {
+        return totalLength;
+    }
+    public void setTotalLength(long totalLength) {
+        this.totalLength = totalLength;
+    }
+
+    public String getUniqueId() {
+        StringBuffer result = new StringBuffer(getFileName());
+        result.append("#-#");
+        result.append(getMessageNumber());
+        result.append("#-#");
+        result.append(System.currentTimeMillis());
+        return result.toString();
+    }
+
+    
+    public String getFileName() {
+        return fileName;
+    }
+    public void setFileName(String fileName) {
+        this.fileName = fileName;
+    }
+    public String getContextPath() {
+        return contextPath;
+    }
+    
+}

==================================================
UndeployMessage.java
index 21d9643c7d..43866699fc 100644
--- a/java/org/apache/catalina/ha/deploy/FileMessageFactory.java
+++ b/java/org/apache/catalina/ha/deploy/FileMessageFactory.java
@@ -1,311 +1,312 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha.deploy;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.FileNotFoundException;
-
-/**
- * This factory is used to read files and write files by splitting them up into
- * smaller messages. So that entire files don't have to be read into memory.
- * <BR>
- * The factory can be used as a reader or writer but not both at the same time.
- * When done reading or writing the factory will close the input or output
- * streams and mark the factory as closed. It is not possible to use it after
- * that. <BR>
- * To force a cleanup, call cleanup() from the calling object. <BR>
- * This class is not thread safe.
- * 
- * @author Filip Hanik
- * @version 1.0
- */
-public class FileMessageFactory {
-    /*--Static Variables----------------------------------------*/
-    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory
-            .getLog(FileMessageFactory.class);
-
-    /**
-     * The number of bytes that we read from file
-     */
-    public static final int READ_SIZE = 1024 * 10; //10kb
-
-    /**
-     * The file that we are reading/writing
-     */
-    protected File file = null;
-
-    /**
-     * True means that we are writing with this factory. False means that we are
-     * reading with this factory
-     */
-    protected boolean openForWrite;
-
-    /**
-     * Once the factory is used, it can not be reused.
-     */
-    protected boolean closed = false;
-
-    /**
-     * When openForWrite=false, the input stream is held by this variable
-     */
-    protected FileInputStream in;
-
-    /**
-     * When openForWrite=true, the output stream is held by this variable
-     */
-    protected FileOutputStream out;
-
-    /**
-     * The number of messages we have read or written
-     */
-    protected int nrOfMessagesProcessed = 0;
-
-    /**
-     * The total size of the file
-     */
-    protected long size = 0;
-
-    /**
-     * The total number of packets that we split this file into
-     */
-    protected long totalNrOfMessages = 0;
-
-    /**
-     * The bytes that we hold the data in, not thread safe.
-     */
-    protected byte[] data = new byte[READ_SIZE];
-
-    /**
-     * Private constructor, either instantiates a factory to read or write. <BR>
-     * When openForWrite==true, then a the file, f, will be created and an
-     * output stream is opened to write to it. <BR>
-     * When openForWrite==false, an input stream is opened, the file has to
-     * exist.
-     * 
-     * @param f
-     *            File - the file to be read/written
-     * @param openForWrite
-     *            boolean - true means we are writing to the file, false means
-     *            we are reading from the file
-     * @throws FileNotFoundException -
-     *             if the file to be read doesn't exist
-     * @throws IOException -
-     *             if the system fails to open input/output streams to the file
-     *             or if it fails to create the file to be written to.
-     */
-    private FileMessageFactory(File f, boolean openForWrite)
-            throws FileNotFoundException, IOException {
-        this.file = f;
-        this.openForWrite = openForWrite;
-        if (log.isDebugEnabled())
-            log.debug("open file " + f + " write " + openForWrite);
-        if (openForWrite) {
-            if (!file.exists())
-                file.createNewFile();
-            out = new FileOutputStream(f);
-        } else {
-            size = file.length();
-            totalNrOfMessages = (size / READ_SIZE) + 1;
-            in = new FileInputStream(f);
-        }//end if
-
-    }
-
-    /**
-     * Creates a factory to read or write from a file. When opening for read,
-     * the readMessage can be invoked, and when opening for write the
-     * writeMessage can be invoked.
-     * 
-     * @param f
-     *            File - the file to be read or written
-     * @param openForWrite
-     *            boolean - true, means we are writing to the file, false means
-     *            we are reading from it
-     * @throws FileNotFoundException -
-     *             if the file to be read doesn't exist
-     * @throws IOException -
-     *             if it fails to create the file that is to be written
-     * @return FileMessageFactory
-     */
-    public static FileMessageFactory getInstance(File f, boolean openForWrite)
-            throws FileNotFoundException, IOException {
-        return new FileMessageFactory(f, openForWrite);
-    }
-
-    /**
-     * Reads file data into the file message and sets the size, totalLength,
-     * totalNrOfMsgs and the message number <BR>
-     * If EOF is reached, the factory returns null, and closes itself, otherwise
-     * the same message is returned as was passed in. This makes sure that not
-     * more memory is ever used. To remember, neither the file message or the
-     * factory are thread safe. dont hand off the message to one thread and read
-     * the same with another.
-     * 
-     * @param f
-     *            FileMessage - the message to be populated with file data
-     * @throws IllegalArgumentException -
-     *             if the factory is for writing or is closed
-     * @throws IOException -
-     *             if a file read exception occurs
-     * @return FileMessage - returns the same message passed in as a parameter,
-     *         or null if EOF
-     */
-    public FileMessage readMessage(FileMessage f)
-            throws IllegalArgumentException, IOException {
-        checkState(false);
-        int length = in.read(data);
-        if (length == -1) {
-            cleanup();
-            return null;
-        } else {
-            f.setData(data, length);
-            f.setTotalLength(size);
-            f.setTotalNrOfMsgs(totalNrOfMessages);
-            f.setMessageNumber(++nrOfMessagesProcessed);
-            return f;
-        }//end if
-    }
-
-    /**
-     * Writes a message to file. If (msg.getMessageNumber() ==
-     * msg.getTotalNrOfMsgs()) the output stream will be closed after writing.
-     * 
-     * @param msg
-     *            FileMessage - message containing data to be written
-     * @throws IllegalArgumentException -
-     *             if the factory is opened for read or closed
-     * @throws IOException -
-     *             if a file write error occurs
-     * @return returns true if the file is complete and outputstream is closed,
-     *         false otherwise.
-     */
-    public boolean writeMessage(FileMessage msg)
-            throws IllegalArgumentException, IOException {
-        if (!openForWrite)
-            throw new IllegalArgumentException(
-                    "Can't write message, this factory is reading.");
-        if (log.isDebugEnabled())
-            log.debug("Message " + msg + " data " + msg.getData()
-                    + " data length " + msg.getDataLength() + " out " + out);
-        if (out != null) {
-            out.write(msg.getData(), 0, msg.getDataLength());
-            nrOfMessagesProcessed++;
-            out.flush();
-            if (msg.getMessageNumber() == msg.getTotalNrOfMsgs()) {
-                out.close();
-                cleanup();
-                return true;
-            }//end if
-        } else {
-            if (log.isWarnEnabled())
-                log.warn("Receive Message again -- Sender ActTimeout to short [ path: "
-                                + msg.getContextPath()
-                                + " war: "
-                                + msg.getFileName()
-                                + " data: "
-                                + msg.getData()
-                                + " data length: " + msg.getDataLength() + " ]");
-        }
-        return false;
-    }//writeMessage
-
-    /**
-     * Closes the factory, its streams and sets all its references to null
-     */
-    public void cleanup() {
-        if (in != null)
-            try {
-                in.close();
-            } catch (Exception ignore) {
-            }
-        if (out != null)
-            try {
-                out.close();
-            } catch (Exception ignore) {
-            }
-        in = null;
-        out = null;
-        size = 0;
-        closed = true;
-        data = null;
-        nrOfMessagesProcessed = 0;
-        totalNrOfMessages = 0;
-    }
-
-    /**
-     * Check to make sure the factory is able to perform the function it is
-     * asked to do. Invoked by readMessage/writeMessage before those methods
-     * proceed.
-     * 
-     * @param openForWrite
-     *            boolean
-     * @throws IllegalArgumentException
-     */
-    protected void checkState(boolean openForWrite)
-            throws IllegalArgumentException {
-        if (this.openForWrite != openForWrite) {
-            cleanup();
-            if (openForWrite)
-                throw new IllegalArgumentException(
-                        "Can't write message, this factory is reading.");
-            else
-                throw new IllegalArgumentException(
-                        "Can't read message, this factory is writing.");
-        }
-        if (this.closed) {
-            cleanup();
-            throw new IllegalArgumentException("Factory has been closed.");
-        }
-    }
-
-    /**
-     * Example usage.
-     * 
-     * @param args
-     *            String[], args[0] - read from filename, args[1] write to
-     *            filename
-     * @throws Exception
-     */
-    public static void main(String[] args) throws Exception {
-
-        System.out
-                .println("Usage: FileMessageFactory fileToBeRead fileToBeWritten");
-        System.out
-                .println("Usage: This will make a copy of the file on the local file system");
-        FileMessageFactory read = getInstance(new File(args[0]), false);
-        FileMessageFactory write = getInstance(new File(args[1]), true);
-        FileMessage msg = new FileMessage(null, args[0], args[0]);
-        msg = read.readMessage(msg);
-        System.out.println("Expecting to write " + msg.getTotalNrOfMsgs()
-                + " messages.");
-        int cnt = 0;
-        while (msg != null) {
-            write.writeMessage(msg);
-            cnt++;
-            msg = read.readMessage(msg);
-        }//while
-        System.out.println("Actually wrote " + cnt + " messages.");
-    }///main
-
-    public File getFile() {
-        return file;
-    }
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha.deploy;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.FileNotFoundException;
+
+/**
+ * This factory is used to read files and write files by splitting them up into
+ * smaller messages. So that entire files don't have to be read into memory.
+ * <BR>
+ * The factory can be used as a reader or writer but not both at the same time.
+ * When done reading or writing the factory will close the input or output
+ * streams and mark the factory as closed. It is not possible to use it after
+ * that. <BR>
+ * To force a cleanup, call cleanup() from the calling object. <BR>
+ * This class is not thread safe.
+ * 
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class FileMessageFactory {
+    /*--Static Variables----------------------------------------*/
+    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory
+            .getLog(FileMessageFactory.class);
+
+    /**
+     * The number of bytes that we read from file
+     */
+    public static final int READ_SIZE = 1024 * 10; //10kb
+
+    /**
+     * The file that we are reading/writing
+     */
+    protected File file = null;
+
+    /**
+     * True means that we are writing with this factory. False means that we are
+     * reading with this factory
+     */
+    protected boolean openForWrite;
+
+    /**
+     * Once the factory is used, it can not be reused.
+     */
+    protected boolean closed = false;
+
+    /**
+     * When openForWrite=false, the input stream is held by this variable
+     */
+    protected FileInputStream in;
+
+    /**
+     * When openForWrite=true, the output stream is held by this variable
+     */
+    protected FileOutputStream out;
+
+    /**
+     * The number of messages we have read or written
+     */
+    protected int nrOfMessagesProcessed = 0;
+
+    /**
+     * The total size of the file
+     */
+    protected long size = 0;
+
+    /**
+     * The total number of packets that we split this file into
+     */
+    protected long totalNrOfMessages = 0;
+
+    /**
+     * The bytes that we hold the data in, not thread safe.
+     */
+    protected byte[] data = new byte[READ_SIZE];
+
+    /**
+     * Private constructor, either instantiates a factory to read or write. <BR>
+     * When openForWrite==true, then a the file, f, will be created and an
+     * output stream is opened to write to it. <BR>
+     * When openForWrite==false, an input stream is opened, the file has to
+     * exist.
+     * 
+     * @param f
+     *            File - the file to be read/written
+     * @param openForWrite
+     *            boolean - true means we are writing to the file, false means
+     *            we are reading from the file
+     * @throws FileNotFoundException -
+     *             if the file to be read doesn't exist
+     * @throws IOException -
+     *             if the system fails to open input/output streams to the file
+     *             or if it fails to create the file to be written to.
+     */
+    private FileMessageFactory(File f, boolean openForWrite)
+            throws FileNotFoundException, IOException {
+        this.file = f;
+        this.openForWrite = openForWrite;
+        if (log.isDebugEnabled())
+            log.debug("open file " + f + " write " + openForWrite);
+        if (openForWrite) {
+            if (!file.exists())
+                file.createNewFile();
+            out = new FileOutputStream(f);
+        } else {
+            size = file.length();
+            totalNrOfMessages = (size / READ_SIZE) + 1;
+            in = new FileInputStream(f);
+        }//end if
+
+    }
+
+    /**
+     * Creates a factory to read or write from a file. When opening for read,
+     * the readMessage can be invoked, and when opening for write the
+     * writeMessage can be invoked.
+     * 
+     * @param f
+     *            File - the file to be read or written
+     * @param openForWrite
+     *            boolean - true, means we are writing to the file, false means
+     *            we are reading from it
+     * @throws FileNotFoundException -
+     *             if the file to be read doesn't exist
+     * @throws IOException -
+     *             if it fails to create the file that is to be written
+     * @return FileMessageFactory
+     */
+    public static FileMessageFactory getInstance(File f, boolean openForWrite)
+            throws FileNotFoundException, IOException {
+        return new FileMessageFactory(f, openForWrite);
+    }
+
+    /**
+     * Reads file data into the file message and sets the size, totalLength,
+     * totalNrOfMsgs and the message number <BR>
+     * If EOF is reached, the factory returns null, and closes itself, otherwise
+     * the same message is returned as was passed in. This makes sure that not
+     * more memory is ever used. To remember, neither the file message or the
+     * factory are thread safe. dont hand off the message to one thread and read
+     * the same with another.
+     * 
+     * @param f
+     *            FileMessage - the message to be populated with file data
+     * @throws IllegalArgumentException -
+     *             if the factory is for writing or is closed
+     * @throws IOException -
+     *             if a file read exception occurs
+     * @return FileMessage - returns the same message passed in as a parameter,
+     *         or null if EOF
+     */
+    public FileMessage readMessage(FileMessage f)
+            throws IllegalArgumentException, IOException {
+        checkState(false);
+        int length = in.read(data);
+        if (length == -1) {
+            cleanup();
+            return null;
+        } else {
+            f.setData(data, length);
+            f.setTotalLength(size);
+            f.setTotalNrOfMsgs(totalNrOfMessages);
+            f.setMessageNumber(++nrOfMessagesProcessed);
+            return f;
+        }//end if
+    }
+
+    /**
+     * Writes a message to file. If (msg.getMessageNumber() ==
+     * msg.getTotalNrOfMsgs()) the output stream will be closed after writing.
+     * 
+     * @param msg
+     *            FileMessage - message containing data to be written
+     * @throws IllegalArgumentException -
+     *             if the factory is opened for read or closed
+     * @throws IOException -
+     *             if a file write error occurs
+     * @return returns true if the file is complete and outputstream is closed,
+     *         false otherwise.
+     */
+    public boolean writeMessage(FileMessage msg)
+            throws IllegalArgumentException, IOException {
+        if (!openForWrite)
+            throw new IllegalArgumentException(
+                    "Can't write message, this factory is reading.");
+        if (log.isDebugEnabled())
+            log.debug("Message " + msg + " data " + msg.getData()
+                    + " data length " + msg.getDataLength() + " out " + out);
+        if (out != null) {
+            out.write(msg.getData(), 0, msg.getDataLength());
+            nrOfMessagesProcessed++;
+            out.flush();
+            if (msg.getMessageNumber() == msg.getTotalNrOfMsgs()) {
+                out.close();
+                cleanup();
+                return true;
+            }//end if
+        } else {
+            if (log.isWarnEnabled())
+                log.warn("Receive Message again -- Sender ActTimeout to short [ path: "
+                                + msg.getContextPath()
+                                + " war: "
+                                + msg.getFileName()
+                                + " data: "
+                                + msg.getData()
+                                + " data length: " + msg.getDataLength() + " ]");
+        }
+        return false;
+    }//writeMessage
+
+    /**
+     * Closes the factory, its streams and sets all its references to null
+     */
+    public void cleanup() {
+        if (in != null)
+            try {
+                in.close();
+            } catch (Exception ignore) {
+            }
+        if (out != null)
+            try {
+                out.close();
+            } catch (Exception ignore) {
+            }
+        in = null;
+        out = null;
+        size = 0;
+        closed = true;
+        data = null;
+        nrOfMessagesProcessed = 0;
+        totalNrOfMessages = 0;
+    }
+
+    /**
+     * Check to make sure the factory is able to perform the function it is
+     * asked to do. Invoked by readMessage/writeMessage before those methods
+     * proceed.
+     * 
+     * @param openForWrite
+     *            boolean
+     * @throws IllegalArgumentException
+     */
+    protected void checkState(boolean openForWrite)
+            throws IllegalArgumentException {
+        if (this.openForWrite != openForWrite) {
+            cleanup();
+            if (openForWrite)
+                throw new IllegalArgumentException(
+                        "Can't write message, this factory is reading.");
+            else
+                throw new IllegalArgumentException(
+                        "Can't read message, this factory is writing.");
+        }
+        if (this.closed) {
+            cleanup();
+            throw new IllegalArgumentException("Factory has been closed.");
+        }
+    }
+
+    /**
+     * Example usage.
+     * 
+     * @param args
+     *            String[], args[0] - read from filename, args[1] write to
+     *            filename
+     * @throws Exception
+     */
+    public static void main(String[] args) throws Exception {
+
+        System.out
+                .println("Usage: FileMessageFactory fileToBeRead fileToBeWritten");
+        System.out
+                .println("Usage: This will make a copy of the file on the local file system");
+        FileMessageFactory read = getInstance(new File(args[0]), false);
+        FileMessageFactory write = getInstance(new File(args[1]), true);
+        FileMessage msg = new FileMessage(null, args[0], args[0]);
+        msg = read.readMessage(msg);
+        System.out.println("Expecting to write " + msg.getTotalNrOfMsgs()
+                + " messages.");
+        int cnt = 0;
+        while (msg != null) {
+            write.writeMessage(msg);
+            cnt++;
+            msg = read.readMessage(msg);
+        }//while
+        System.out.println("Actually wrote " + cnt + " messages.");
+    }///main
+
+    public File getFile() {
+        return file;
+    }
+
 }
\ No newline at end of file

==================================================
WarWatcher.java
index 1003f3c90f..24f1c4670b 100644
--- a/java/org/apache/catalina/ha/deploy/UndeployMessage.java
+++ b/java/org/apache/catalina/ha/deploy/UndeployMessage.java
@@ -1,113 +1,114 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha.deploy;
-
-import org.apache.catalina.ha.ClusterMessage;
-import org.apache.catalina.tribes.Member;
-import java.io.Serializable;
-public class UndeployMessage implements ClusterMessage,Serializable {
-    private Member address;
-    private long timestamp;
-    private String uniqueId;
-    private String contextPath;
-    private boolean undeploy;
-    private int resend = 0;
-    private int compress = 0;
-
-    public UndeployMessage() {} //for serialization
-    public UndeployMessage(Member address,
-                           long timestamp,
-                           String uniqueId,
-                           String contextPath,
-                           boolean undeploy) {
-        this.address  = address;
-        this.timestamp= timestamp;
-        this.undeploy = undeploy;
-        this.uniqueId = uniqueId;
-        this.undeploy = undeploy;
-        this.contextPath = contextPath;
-    }
-
-    public Member getAddress() {
-        return address;
-    }
-
-    public void setAddress(Member address) {
-        this.address = address;
-    }
-
-    public long getTimestamp() {
-        return timestamp;
-    }
-
-    public void setTimestamp(long timestamp) {
-        this.timestamp = timestamp;
-    }
-
-    public String getUniqueId() {
-        return uniqueId;
-    }
-
-    public void setUniqueId(String uniqueId) {
-        this.uniqueId = uniqueId;
-    }
-
-    public String getContextPath() {
-        return contextPath;
-    }
-
-    public void setContextPath(String contextPath) {
-        this.contextPath = contextPath;
-    }
-
-    public boolean getUndeploy() {
-        return undeploy;
-    }
-
-    public void setUndeploy(boolean undeploy) {
-        this.undeploy = undeploy;
-    }
-    /**
-     * @return Returns the compress.
-     * @since 5.5.10 
-     */
-    public int getCompress() {
-        return compress;
-    }
-    /**
-     * @param compress The compress to set.
-     * @since 5.5.10
-     */
-    public void setCompress(int compress) {
-        this.compress = compress;
-    }
-    /**
-     * @return Returns the resend.
-     * @since 5.5.10
-     */
-    public int getResend() {
-        return resend;
-    }
-    /**
-     * @param resend The resend to set.
-     * @since 5.5.10
-     */
-    public void setResend(int resend) {
-        this.resend = resend;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha.deploy;
+
+import org.apache.catalina.ha.ClusterMessage;
+import org.apache.catalina.tribes.Member;
+import java.io.Serializable;
+public class UndeployMessage implements ClusterMessage,Serializable {
+    private Member address;
+    private long timestamp;
+    private String uniqueId;
+    private String contextPath;
+    private boolean undeploy;
+    private int resend = 0;
+    private int compress = 0;
+
+    public UndeployMessage() {} //for serialization
+    public UndeployMessage(Member address,
+                           long timestamp,
+                           String uniqueId,
+                           String contextPath,
+                           boolean undeploy) {
+        this.address  = address;
+        this.timestamp= timestamp;
+        this.undeploy = undeploy;
+        this.uniqueId = uniqueId;
+        this.undeploy = undeploy;
+        this.contextPath = contextPath;
+    }
+
+    public Member getAddress() {
+        return address;
+    }
+
+    public void setAddress(Member address) {
+        this.address = address;
+    }
+
+    public long getTimestamp() {
+        return timestamp;
+    }
+
+    public void setTimestamp(long timestamp) {
+        this.timestamp = timestamp;
+    }
+
+    public String getUniqueId() {
+        return uniqueId;
+    }
+
+    public void setUniqueId(String uniqueId) {
+        this.uniqueId = uniqueId;
+    }
+
+    public String getContextPath() {
+        return contextPath;
+    }
+
+    public void setContextPath(String contextPath) {
+        this.contextPath = contextPath;
+    }
+
+    public boolean getUndeploy() {
+        return undeploy;
+    }
+
+    public void setUndeploy(boolean undeploy) {
+        this.undeploy = undeploy;
+    }
+    /**
+     * @return Returns the compress.
+     * @since 5.5.10 
+     */
+    public int getCompress() {
+        return compress;
+    }
+    /**
+     * @param compress The compress to set.
+     * @since 5.5.10
+     */
+    public void setCompress(int compress) {
+        this.compress = compress;
+    }
+    /**
+     * @return Returns the resend.
+     * @since 5.5.10
+     */
+    public int getResend() {
+        return resend;
+    }
+    /**
+     * @param resend The resend to set.
+     * @since 5.5.10
+     */
+    public void setResend(int resend) {
+        this.resend = resend;
+    }
+
+}

==================================================
BackupManager.java
index 1249448bd6..925b6c2d29 100644
--- a/java/org/apache/catalina/ha/deploy/WarWatcher.java
+++ b/java/org/apache/catalina/ha/deploy/WarWatcher.java
@@ -1,238 +1,239 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha.deploy;
-
-import java.io.File;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Iterator;
-
-/**
- * <p>
- * The <b>WarWatcher </b> watches the deployDir for changes made to the
- * directory (adding new WAR files->deploy or remove WAR files->undeploy) And
- * notifies a listener of the changes made
- * </p>
- * 
- * @author Filip Hanik
- * @author Peter Rossbach
- * @version 1.1
- */
-
-public class WarWatcher {
-
-    /*--Static Variables----------------------------------------*/
-    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory
-            .getLog(WarWatcher.class);
-
-    /*--Instance Variables--------------------------------------*/
-    /**
-     * Directory to watch for war files
-     */
-    protected File watchDir = null;
-
-    /**
-     * Parent to be notified of changes
-     */
-    protected FileChangeListener listener = null;
-
-    /**
-     * Currently deployed files
-     */
-    protected Map currentStatus = new HashMap();
-
-    /*--Constructor---------------------------------------------*/
-
-    public WarWatcher() {
-    }
-
-    public WarWatcher(FileChangeListener listener, File watchDir) {
-        this.listener = listener;
-        this.watchDir = watchDir;
-    }
-
-    /*--Logic---------------------------------------------------*/
-
-    /**
-     * check for modification and send notifcation to listener
-     */
-    public void check() {
-        if (log.isInfoEnabled())
-            log.info("check cluster wars at " + watchDir);
-        File[] list = watchDir.listFiles(new WarFilter());
-        if (list == null)
-            list = new File[0];
-        //first make sure all the files are listed in our current status
-        for (int i = 0; i < list.length; i++) {
-            addWarInfo(list[i]);
-        }
-
-        //check all the status codes and update the FarmDeployer
-        for (Iterator i = currentStatus.entrySet().iterator(); i.hasNext();) {
-            Map.Entry entry = (Map.Entry) i.next();
-            WarInfo info = (WarInfo) entry.getValue();
-            int check = info.check();
-            if (check == 1) {
-                listener.fileModified(info.getWar());
-            } else if (check == -1) {
-                listener.fileRemoved(info.getWar());
-                //no need to keep in memory
-                currentStatus.remove(info.getWar());
-            }
-        }
-
-    }
-
-    /**
-     * add cluster war to the watcher state
-     * @param warfile
-     */
-    protected void addWarInfo(File warfile) {
-        WarInfo info = (WarInfo) currentStatus.get(warfile.getAbsolutePath());
-        if (info == null) {
-            info = new WarInfo(warfile);
-            info.setLastState(-1); //assume file is non existent
-            currentStatus.put(warfile.getAbsolutePath(), info);
-        }
-    }
-
-    /**
-     * clear watcher state
-     */
-    public void clear() {
-        currentStatus.clear();
-    }
-
-    /**
-     * @return Returns the watchDir.
-     */
-    public File getWatchDir() {
-        return watchDir;
-    }
-
-    /**
-     * @param watchDir
-     *            The watchDir to set.
-     */
-    public void setWatchDir(File watchDir) {
-        this.watchDir = watchDir;
-    }
-
-    /**
-     * @return Returns the listener.
-     */
-    public FileChangeListener getListener() {
-        return listener;
-    }
-
-    /**
-     * @param listener
-     *            The listener to set.
-     */
-    public void setListener(FileChangeListener listener) {
-        this.listener = listener;
-    }
-
-    /*--Inner classes-------------------------------------------*/
-
-    /**
-     * File name filter for war files
-     */
-    protected class WarFilter implements java.io.FilenameFilter {
-        public boolean accept(File path, String name) {
-            if (name == null)
-                return false;
-            return name.endsWith(".war");
-        }
-    }
-
-    /**
-     * File information on existing WAR files
-     */
-    protected class WarInfo {
-        protected File war = null;
-
-        protected long lastChecked = 0;
-
-        protected long lastState = 0;
-
-        public WarInfo(File war) {
-            this.war = war;
-            this.lastChecked = war.lastModified();
-            if (!war.exists())
-                lastState = -1;
-        }
-
-        public boolean modified() {
-            return war.exists() && war.lastModified() > lastChecked;
-        }
-
-        public boolean exists() {
-            return war.exists();
-        }
-
-        /**
-         * Returns 1 if the file has been added/modified, 0 if the file is
-         * unchanged and -1 if the file has been removed
-         * 
-         * @return int 1=file added; 0=unchanged; -1=file removed
-         */
-        public int check() {
-            //file unchanged by default
-            int result = 0;
-
-            if (modified()) {
-                //file has changed - timestamp
-                result = 1;
-                lastState = result;
-            } else if ((!exists()) && (!(lastState == -1))) {
-                //file was removed
-                result = -1;
-                lastState = result;
-            } else if ((lastState == -1) && exists()) {
-                //file was added
-                result = 1;
-                lastState = result;
-            }
-            this.lastChecked = System.currentTimeMillis();
-            return result;
-        }
-
-        public File getWar() {
-            return war;
-        }
-
-        public int hashCode() {
-            return war.getAbsolutePath().hashCode();
-        }
-
-        public boolean equals(Object other) {
-            if (other instanceof WarInfo) {
-                WarInfo wo = (WarInfo) other;
-                return wo.getWar().equals(getWar());
-            } else {
-                return false;
-            }
-        }
-
-        protected void setLastState(int lastState) {
-            this.lastState = lastState;
-        }
-
-    }
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha.deploy;
+
+import java.io.File;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Iterator;
+
+/**
+ * <p>
+ * The <b>WarWatcher </b> watches the deployDir for changes made to the
+ * directory (adding new WAR files->deploy or remove WAR files->undeploy) And
+ * notifies a listener of the changes made
+ * </p>
+ * 
+ * @author Filip Hanik
+ * @author Peter Rossbach
+ * @version 1.1
+ */
+
+public class WarWatcher {
+
+    /*--Static Variables----------------------------------------*/
+    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory
+            .getLog(WarWatcher.class);
+
+    /*--Instance Variables--------------------------------------*/
+    /**
+     * Directory to watch for war files
+     */
+    protected File watchDir = null;
+
+    /**
+     * Parent to be notified of changes
+     */
+    protected FileChangeListener listener = null;
+
+    /**
+     * Currently deployed files
+     */
+    protected Map currentStatus = new HashMap();
+
+    /*--Constructor---------------------------------------------*/
+
+    public WarWatcher() {
+    }
+
+    public WarWatcher(FileChangeListener listener, File watchDir) {
+        this.listener = listener;
+        this.watchDir = watchDir;
+    }
+
+    /*--Logic---------------------------------------------------*/
+
+    /**
+     * check for modification and send notifcation to listener
+     */
+    public void check() {
+        if (log.isInfoEnabled())
+            log.info("check cluster wars at " + watchDir);
+        File[] list = watchDir.listFiles(new WarFilter());
+        if (list == null)
+            list = new File[0];
+        //first make sure all the files are listed in our current status
+        for (int i = 0; i < list.length; i++) {
+            addWarInfo(list[i]);
+        }
+
+        //check all the status codes and update the FarmDeployer
+        for (Iterator i = currentStatus.entrySet().iterator(); i.hasNext();) {
+            Map.Entry entry = (Map.Entry) i.next();
+            WarInfo info = (WarInfo) entry.getValue();
+            int check = info.check();
+            if (check == 1) {
+                listener.fileModified(info.getWar());
+            } else if (check == -1) {
+                listener.fileRemoved(info.getWar());
+                //no need to keep in memory
+                currentStatus.remove(info.getWar());
+            }
+        }
+
+    }
+
+    /**
+     * add cluster war to the watcher state
+     * @param warfile
+     */
+    protected void addWarInfo(File warfile) {
+        WarInfo info = (WarInfo) currentStatus.get(warfile.getAbsolutePath());
+        if (info == null) {
+            info = new WarInfo(warfile);
+            info.setLastState(-1); //assume file is non existent
+            currentStatus.put(warfile.getAbsolutePath(), info);
+        }
+    }
+
+    /**
+     * clear watcher state
+     */
+    public void clear() {
+        currentStatus.clear();
+    }
+
+    /**
+     * @return Returns the watchDir.
+     */
+    public File getWatchDir() {
+        return watchDir;
+    }
+
+    /**
+     * @param watchDir
+     *            The watchDir to set.
+     */
+    public void setWatchDir(File watchDir) {
+        this.watchDir = watchDir;
+    }
+
+    /**
+     * @return Returns the listener.
+     */
+    public FileChangeListener getListener() {
+        return listener;
+    }
+
+    /**
+     * @param listener
+     *            The listener to set.
+     */
+    public void setListener(FileChangeListener listener) {
+        this.listener = listener;
+    }
+
+    /*--Inner classes-------------------------------------------*/
+
+    /**
+     * File name filter for war files
+     */
+    protected class WarFilter implements java.io.FilenameFilter {
+        public boolean accept(File path, String name) {
+            if (name == null)
+                return false;
+            return name.endsWith(".war");
+        }
+    }
+
+    /**
+     * File information on existing WAR files
+     */
+    protected class WarInfo {
+        protected File war = null;
+
+        protected long lastChecked = 0;
+
+        protected long lastState = 0;
+
+        public WarInfo(File war) {
+            this.war = war;
+            this.lastChecked = war.lastModified();
+            if (!war.exists())
+                lastState = -1;
+        }
+
+        public boolean modified() {
+            return war.exists() && war.lastModified() > lastChecked;
+        }
+
+        public boolean exists() {
+            return war.exists();
+        }
+
+        /**
+         * Returns 1 if the file has been added/modified, 0 if the file is
+         * unchanged and -1 if the file has been removed
+         * 
+         * @return int 1=file added; 0=unchanged; -1=file removed
+         */
+        public int check() {
+            //file unchanged by default
+            int result = 0;
+
+            if (modified()) {
+                //file has changed - timestamp
+                result = 1;
+                lastState = result;
+            } else if ((!exists()) && (!(lastState == -1))) {
+                //file was removed
+                result = -1;
+                lastState = result;
+            } else if ((lastState == -1) && exists()) {
+                //file was added
+                result = 1;
+                lastState = result;
+            }
+            this.lastChecked = System.currentTimeMillis();
+            return result;
+        }
+
+        public File getWar() {
+            return war;
+        }
+
+        public int hashCode() {
+            return war.getAbsolutePath().hashCode();
+        }
+
+        public boolean equals(Object other) {
+            if (other instanceof WarInfo) {
+                WarInfo wo = (WarInfo) other;
+                return wo.getWar().equals(getWar());
+            } else {
+                return false;
+            }
+        }
+
+        protected void setLastState(int lastState) {
+            this.lastState = lastState;
+        }
+
+    }
+
 }
\ No newline at end of file

==================================================
ClusterManagerBase.java
index dbc04018d6..1e39e4b65c 100644
--- a/java/org/apache/catalina/ha/session/BackupManager.java
+++ b/java/org/apache/catalina/ha/session/BackupManager.java
@@ -1,281 +1,282 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.ha.session;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-
-import org.apache.catalina.LifecycleException;
-import org.apache.catalina.Session;
-import org.apache.catalina.ha.CatalinaCluster;
-import org.apache.catalina.ha.ClusterManager;
-import org.apache.catalina.ha.ClusterMessage;
-import org.apache.catalina.session.StandardManager;
-import org.apache.catalina.tribes.Channel;
-import org.apache.catalina.tribes.io.ReplicationStream;
-import org.apache.catalina.tribes.tipis.LazyReplicatedMap;
-
-/**
- *@author Filip Hanik
- *@version 1.0
- */
-public class BackupManager extends StandardManager implements ClusterManager
-{
-    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( BackupManager.class );
-
-    protected static long DEFAULT_REPL_TIMEOUT = 15000;//15 seconds
-
-    /** Set to true if we don't want the sessions to expire on shutdown */
-    protected boolean mExpireSessionsOnShutdown = true;
-    
-    /**
-     * The name of this manager
-     */
-    protected String name;
-
-    /**
-     * A reference to the cluster
-     */
-    protected CatalinaCluster cluster;
-    
-    /**
-     * Should listeners be notified?
-     */
-    private boolean notifyListenersOnReplication;
-    /**
-     * 
-     */
-    private int mapSendOptions = Channel.SEND_OPTIONS_SYNCHRONIZED_ACK|Channel.SEND_OPTIONS_USE_ACK;
-
-    /**
-     * Constructor, just calls super()
-     *
-     */
-    public BackupManager() {
-        super();
-    }
-
-
-//******************************************************************************/
-//      ClusterManager Interface     
-//******************************************************************************/
-
-    public void messageDataReceived(ClusterMessage msg) {
-    }
-
-    public boolean doDomainReplication() {
-        return false;
-    }
-
-    /**
-     * @param sendClusterDomainOnly The sendClusterDomainOnly to set.
-     */
-    public void setDomainReplication(boolean sendClusterDomainOnly) {
-    }
-
-    /**
-     * @return Returns the defaultMode.
-     */
-    public boolean isDefaultMode() {
-        return false;
-    }
-    /**
-     * @param defaultMode The defaultMode to set.
-     */
-    public void setDefaultMode(boolean defaultMode) {
-    }
-
-    public void setExpireSessionsOnShutdown(boolean expireSessionsOnShutdown)
-    {
-        mExpireSessionsOnShutdown = expireSessionsOnShutdown;
-    }
-
-    public void setCluster(CatalinaCluster cluster) {
-        if(log.isDebugEnabled())
-            log.debug("Cluster associated with SimpleTcpReplicationManager");
-        this.cluster = cluster;
-    }
-
-    public boolean getExpireSessionsOnShutdown()
-    {
-        return mExpireSessionsOnShutdown;
-    }
-
-
-    /**
-     * Override persistence since they don't go hand in hand with replication for now.
-     */
-    public void unload() throws IOException {
-    }
-    
-    public ClusterMessage requestCompleted(String sessionId) {
-        if ( !this.started ) return null;
-        LazyReplicatedMap map = (LazyReplicatedMap)sessions;
-        map.replicate(sessionId,false);
-        return null;
-    }
-
-
-//=========================================================================
-// OVERRIDE THESE METHODS TO IMPLEMENT THE REPLICATION
-//=========================================================================
-
-    public Session createEmptySession() {
-        return new DeltaSession(this);
-    }
-    
-    public ClassLoader[] getClassLoaders() {
-        return ClusterManagerBase.getClassLoaders(this.container);
-    }
-
-    /**
-     * Open Stream and use correct ClassLoader (Container) Switch
-     * ThreadClassLoader
-     * 
-     * @param data
-     * @return The object input stream
-     * @throws IOException
-     */
-    public ReplicationStream getReplicationStream(byte[] data) throws IOException {
-        return getReplicationStream(data,0,data.length);
-    }
-
-    public ReplicationStream getReplicationStream(byte[] data, int offset, int length) throws IOException {
-        ByteArrayInputStream fis = new ByteArrayInputStream(data, offset, length);
-        return new ReplicationStream(fis, getClassLoaders());
-    }    
-
-
-
-
-    public String getName() {
-        return this.name;
-    }
-    /**
-     * Prepare for the beginning of active use of the public methods of this
-     * component.  This method should be called after <code>configure()</code>,
-     * and before any of the public methods of the component are utilized.<BR>
-     * Starts the cluster communication channel, this will connect with the other nodes
-     * in the cluster, and request the current session state to be transferred to this node.
-     * @exception IllegalStateException if this component has already been
-     *  started
-     * @exception LifecycleException if this component detects a fatal error
-     *  that prevents this component from being used
-     */
-    public void start() throws LifecycleException {
-        if ( this.started ) return;
-        
-        try {
-            cluster.registerManager(this);
-            CatalinaCluster catclust = (CatalinaCluster)cluster;
-            LazyReplicatedMap map = new LazyReplicatedMap(this,
-                                                          catclust.getChannel(),
-                                                          DEFAULT_REPL_TIMEOUT,
-                                                          getMapName(),
-                                                          getClassLoaders());
-            map.setChannelSendOptions(mapSendOptions);
-            this.sessions = map;
-            super.start();
-            this.started = true;
-        }  catch ( Exception x ) {
-            log.error("Unable to start BackupManager",x);
-            throw new LifecycleException("Failed to start BackupManager",x);
-        }
-    }
-    
-    public String getMapName() {
-        CatalinaCluster catclust = (CatalinaCluster)cluster;
-        String name = catclust.getManagerName(getName(),this)+"-"+"map";
-        if ( log.isDebugEnabled() ) log.debug("Backup manager, Setting map name to:"+name);
-        return name;
-    }
-
-    /**
-     * Gracefully terminate the active use of the public methods of this
-     * component.  This method should be the last one called on a given
-     * instance of this component.<BR>
-     * This will disconnect the cluster communication channel and stop the listener thread.
-     * @exception IllegalStateException if this component has not been started
-     * @exception LifecycleException if this component detects a fatal error
-     *  that needs to be reported
-     */
-    public void stop() throws LifecycleException
-    {
-        
-        LazyReplicatedMap map = (LazyReplicatedMap)sessions;
-        if ( map!=null ) {
-            map.breakdown();
-        }
-        if ( !this.started ) return;
-        try {
-        } catch ( Exception x ){
-            log.error("Unable to stop BackupManager",x);
-            throw new LifecycleException("Failed to stop BackupManager",x);
-        } finally {
-            super.stop();
-        }
-        cluster.removeManager(this);
-
-    }
-
-    public void setDistributable(boolean dist) {
-        this.distributable = dist;
-    }
-
-    public boolean getDistributable() {
-        return distributable;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-    public boolean isNotifyListenersOnReplication() {
-        return notifyListenersOnReplication;
-    }
-    public void setNotifyListenersOnReplication(boolean notifyListenersOnReplication) {
-        this.notifyListenersOnReplication = notifyListenersOnReplication;
-    }
-
-    public void setMapSendOptions(int mapSendOptions) {
-        this.mapSendOptions = mapSendOptions;
-    }
-
-    /* 
-     * @see org.apache.catalina.ha.ClusterManager#getCluster()
-     */
-    public CatalinaCluster getCluster() {
-        return cluster;
-    }
-
-    public int getMapSendOptions() {
-        return mapSendOptions;
-    }
-
-    public String[] getInvalidatedSessions() {
-        return new String[0];
-    }
-    
-    public ClusterManager cloneFromTemplate() {
-        BackupManager result = new BackupManager();
-        result.mExpireSessionsOnShutdown = mExpireSessionsOnShutdown;
-        result.name = "Clone-from-"+name;
-        result.cluster = cluster;
-        result.notifyListenersOnReplication = notifyListenersOnReplication;
-        result.mapSendOptions = mapSendOptions;
-        return result;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.ha.session;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+
+import org.apache.catalina.LifecycleException;
+import org.apache.catalina.Session;
+import org.apache.catalina.ha.CatalinaCluster;
+import org.apache.catalina.ha.ClusterManager;
+import org.apache.catalina.ha.ClusterMessage;
+import org.apache.catalina.session.StandardManager;
+import org.apache.catalina.tribes.Channel;
+import org.apache.catalina.tribes.io.ReplicationStream;
+import org.apache.catalina.tribes.tipis.LazyReplicatedMap;
+
+/**
+ *@author Filip Hanik
+ *@version 1.0
+ */
+public class BackupManager extends StandardManager implements ClusterManager
+{
+    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( BackupManager.class );
+
+    protected static long DEFAULT_REPL_TIMEOUT = 15000;//15 seconds
+
+    /** Set to true if we don't want the sessions to expire on shutdown */
+    protected boolean mExpireSessionsOnShutdown = true;
+    
+    /**
+     * The name of this manager
+     */
+    protected String name;
+
+    /**
+     * A reference to the cluster
+     */
+    protected CatalinaCluster cluster;
+    
+    /**
+     * Should listeners be notified?
+     */
+    private boolean notifyListenersOnReplication;
+    /**
+     * 
+     */
+    private int mapSendOptions = Channel.SEND_OPTIONS_SYNCHRONIZED_ACK|Channel.SEND_OPTIONS_USE_ACK;
+
+    /**
+     * Constructor, just calls super()
+     *
+     */
+    public BackupManager() {
+        super();
+    }
+
+
+//******************************************************************************/
+//      ClusterManager Interface     
+//******************************************************************************/
+
+    public void messageDataReceived(ClusterMessage msg) {
+    }
+
+    public boolean doDomainReplication() {
+        return false;
+    }
+
+    /**
+     * @param sendClusterDomainOnly The sendClusterDomainOnly to set.
+     */
+    public void setDomainReplication(boolean sendClusterDomainOnly) {
+    }
+
+    /**
+     * @return Returns the defaultMode.
+     */
+    public boolean isDefaultMode() {
+        return false;
+    }
+    /**
+     * @param defaultMode The defaultMode to set.
+     */
+    public void setDefaultMode(boolean defaultMode) {
+    }
+
+    public void setExpireSessionsOnShutdown(boolean expireSessionsOnShutdown)
+    {
+        mExpireSessionsOnShutdown = expireSessionsOnShutdown;
+    }
+
+    public void setCluster(CatalinaCluster cluster) {
+        if(log.isDebugEnabled())
+            log.debug("Cluster associated with SimpleTcpReplicationManager");
+        this.cluster = cluster;
+    }
+
+    public boolean getExpireSessionsOnShutdown()
+    {
+        return mExpireSessionsOnShutdown;
+    }
+
+
+    /**
+     * Override persistence since they don't go hand in hand with replication for now.
+     */
+    public void unload() throws IOException {
+    }
+    
+    public ClusterMessage requestCompleted(String sessionId) {
+        if ( !this.started ) return null;
+        LazyReplicatedMap map = (LazyReplicatedMap)sessions;
+        map.replicate(sessionId,false);
+        return null;
+    }
+
+
+//=========================================================================
+// OVERRIDE THESE METHODS TO IMPLEMENT THE REPLICATION
+//=========================================================================
+
+    public Session createEmptySession() {
+        return new DeltaSession(this);
+    }
+    
+    public ClassLoader[] getClassLoaders() {
+        return ClusterManagerBase.getClassLoaders(this.container);
+    }
+
+    /**
+     * Open Stream and use correct ClassLoader (Container) Switch
+     * ThreadClassLoader
+     * 
+     * @param data
+     * @return The object input stream
+     * @throws IOException
+     */
+    public ReplicationStream getReplicationStream(byte[] data) throws IOException {
+        return getReplicationStream(data,0,data.length);
+    }
+
+    public ReplicationStream getReplicationStream(byte[] data, int offset, int length) throws IOException {
+        ByteArrayInputStream fis = new ByteArrayInputStream(data, offset, length);
+        return new ReplicationStream(fis, getClassLoaders());
+    }    
+
+
+
+
+    public String getName() {
+        return this.name;
+    }
+    /**
+     * Prepare for the beginning of active use of the public methods of this
+     * component.  This method should be called after <code>configure()</code>,
+     * and before any of the public methods of the component are utilized.<BR>
+     * Starts the cluster communication channel, this will connect with the other nodes
+     * in the cluster, and request the current session state to be transferred to this node.
+     * @exception IllegalStateException if this component has already been
+     *  started
+     * @exception LifecycleException if this component detects a fatal error
+     *  that prevents this component from being used
+     */
+    public void start() throws LifecycleException {
+        if ( this.started ) return;
+        
+        try {
+            cluster.registerManager(this);
+            CatalinaCluster catclust = (CatalinaCluster)cluster;
+            LazyReplicatedMap map = new LazyReplicatedMap(this,
+                                                          catclust.getChannel(),
+                                                          DEFAULT_REPL_TIMEOUT,
+                                                          getMapName(),
+                                                          getClassLoaders());
+            map.setChannelSendOptions(mapSendOptions);
+            this.sessions = map;
+            super.start();
+            this.started = true;
+        }  catch ( Exception x ) {
+            log.error("Unable to start BackupManager",x);
+            throw new LifecycleException("Failed to start BackupManager",x);
+        }
+    }
+    
+    public String getMapName() {
+        CatalinaCluster catclust = (CatalinaCluster)cluster;
+        String name = catclust.getManagerName(getName(),this)+"-"+"map";
+        if ( log.isDebugEnabled() ) log.debug("Backup manager, Setting map name to:"+name);
+        return name;
+    }
+
+    /**
+     * Gracefully terminate the active use of the public methods of this
+     * component.  This method should be the last one called on a given
+     * instance of this component.<BR>
+     * This will disconnect the cluster communication channel and stop the listener thread.
+     * @exception IllegalStateException if this component has not been started
+     * @exception LifecycleException if this component detects a fatal error
+     *  that needs to be reported
+     */
+    public void stop() throws LifecycleException
+    {
+        
+        LazyReplicatedMap map = (LazyReplicatedMap)sessions;
+        if ( map!=null ) {
+            map.breakdown();
+        }
+        if ( !this.started ) return;
+        try {
+        } catch ( Exception x ){
+            log.error("Unable to stop BackupManager",x);
+            throw new LifecycleException("Failed to stop BackupManager",x);
+        } finally {
+            super.stop();
+        }
+        cluster.removeManager(this);
+
+    }
+
+    public void setDistributable(boolean dist) {
+        this.distributable = dist;
+    }
+
+    public boolean getDistributable() {
+        return distributable;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+    public boolean isNotifyListenersOnReplication() {
+        return notifyListenersOnReplication;
+    }
+    public void setNotifyListenersOnReplication(boolean notifyListenersOnReplication) {
+        this.notifyListenersOnReplication = notifyListenersOnReplication;
+    }
+
+    public void setMapSendOptions(int mapSendOptions) {
+        this.mapSendOptions = mapSendOptions;
+    }
+
+    /* 
+     * @see org.apache.catalina.ha.ClusterManager#getCluster()
+     */
+    public CatalinaCluster getCluster() {
+        return cluster;
+    }
+
+    public int getMapSendOptions() {
+        return mapSendOptions;
+    }
+
+    public String[] getInvalidatedSessions() {
+        return new String[0];
+    }
+    
+    public ClusterManager cloneFromTemplate() {
+        BackupManager result = new BackupManager();
+        result.mExpireSessionsOnShutdown = mExpireSessionsOnShutdown;
+        result.name = "Clone-from-"+name;
+        result.cluster = cluster;
+        result.notifyListenersOnReplication = notifyListenersOnReplication;
+        result.mapSendOptions = mapSendOptions;
+        return result;
+    }
+
+}

==================================================
ClusterSessionListener.java
index 71e04038a7..bdcebd1e05 100644
--- a/java/org/apache/catalina/ha/session/ClusterManagerBase.java
+++ b/java/org/apache/catalina/ha/session/ClusterManagerBase.java
@@ -1,74 +1,75 @@
-/*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha.session;
-
-import org.apache.catalina.ha.ClusterManager;
-import java.beans.PropertyChangeListener;
-import org.apache.catalina.Lifecycle;
-import org.apache.catalina.session.ManagerBase;
-import org.apache.catalina.Loader;
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import org.apache.catalina.tribes.io.ReplicationStream;
-import org.apache.catalina.Container;
-
-/**
- * 
- * @author Filip Hanik
- * @version $Revision: 380100 $ $Date: 2006-02-23 06:08:14 -0600 (Thu, 23 Feb 2006) $
- */
-
-public abstract class ClusterManagerBase extends ManagerBase implements Lifecycle, PropertyChangeListener, ClusterManager{
-    
-
-    public static ClassLoader[] getClassLoaders(Container container) {
-        Loader loader = null;
-        ClassLoader classLoader = null;
-        if (container != null) loader = container.getLoader();
-        if (loader != null) classLoader = loader.getClassLoader();
-        else classLoader = Thread.currentThread().getContextClassLoader();
-        if ( classLoader == Thread.currentThread().getContextClassLoader() ) {
-            return new ClassLoader[] {classLoader};
-        } else {
-            return new ClassLoader[] {classLoader,Thread.currentThread().getContextClassLoader()};
-        }
-    }
-
-
-    public ClassLoader[] getClassLoaders() {
-        return getClassLoaders(container);
-    }
-
-    /**
-     * Open Stream and use correct ClassLoader (Container) Switch
-     * ThreadClassLoader
-     * 
-     * @param data
-     * @return The object input stream
-     * @throws IOException
-     */
-    public ReplicationStream getReplicationStream(byte[] data) throws IOException {
-        return getReplicationStream(data,0,data.length);
-    }
-
-    public ReplicationStream getReplicationStream(byte[] data, int offset, int length) throws IOException {
-        ByteArrayInputStream fis = new ByteArrayInputStream(data, offset, length);
-        return new ReplicationStream(fis, getClassLoaders());
-    }    
-
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha.session;
+
+import org.apache.catalina.ha.ClusterManager;
+import java.beans.PropertyChangeListener;
+import org.apache.catalina.Lifecycle;
+import org.apache.catalina.session.ManagerBase;
+import org.apache.catalina.Loader;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import org.apache.catalina.tribes.io.ReplicationStream;
+import org.apache.catalina.Container;
+
+/**
+ * 
+ * @author Filip Hanik
+ * @version $Revision: 380100 $ $Date: 2006-02-23 06:08:14 -0600 (Thu, 23 Feb 2006) $
+ */
+
+public abstract class ClusterManagerBase extends ManagerBase implements Lifecycle, PropertyChangeListener, ClusterManager{
+    
+
+    public static ClassLoader[] getClassLoaders(Container container) {
+        Loader loader = null;
+        ClassLoader classLoader = null;
+        if (container != null) loader = container.getLoader();
+        if (loader != null) classLoader = loader.getClassLoader();
+        else classLoader = Thread.currentThread().getContextClassLoader();
+        if ( classLoader == Thread.currentThread().getContextClassLoader() ) {
+            return new ClassLoader[] {classLoader};
+        } else {
+            return new ClassLoader[] {classLoader,Thread.currentThread().getContextClassLoader()};
+        }
+    }
+
+
+    public ClassLoader[] getClassLoaders() {
+        return getClassLoaders(container);
+    }
+
+    /**
+     * Open Stream and use correct ClassLoader (Container) Switch
+     * ThreadClassLoader
+     * 
+     * @param data
+     * @return The object input stream
+     * @throws IOException
+     */
+    public ReplicationStream getReplicationStream(byte[] data) throws IOException {
+        return getReplicationStream(data,0,data.length);
+    }
+
+    public ReplicationStream getReplicationStream(byte[] data, int offset, int length) throws IOException {
+        ByteArrayInputStream fis = new ByteArrayInputStream(data, offset, length);
+        return new ReplicationStream(fis, getClassLoaders());
+    }    
+
+
 }
\ No newline at end of file

==================================================
Constants.java
index 3150ec9378..14d2d03445 100644
--- a/java/org/apache/catalina/ha/session/ClusterSessionListener.java
+++ b/java/org/apache/catalina/ha/session/ClusterSessionListener.java
@@ -1,107 +1,108 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha.session;
-
-import java.util.Map;
-
-import org.apache.catalina.ha.ClusterManager;
-import org.apache.catalina.ha.ClusterMessage;
-import org.apache.catalina.ha.*;
-
-/**
- * Receive replicated SessionMessage form other cluster node.
- * @author Filip Hanik
- * @author Peter Rossbach
- * @version $Revision: 378258 $ $Date: 2006-02-16 08:42:35 -0600 (Thu, 16 Feb 2006) $
- */
-public class ClusterSessionListener extends ClusterListener {
- 
-    /**
-     * The descriptive information about this implementation.
-     */
-    protected static final String info = "org.apache.catalina.session.ClusterSessionListener/1.1";
-
-    //--Constructor---------------------------------------------
-
-    public ClusterSessionListener() {
-    }
-
-    //--Logic---------------------------------------------------
-
-    /**
-     * Return descriptive information about this implementation.
-     */
-    public String getInfo() {
-
-        return (info);
-
-    }
-
-    /**
-     * Callback from the cluster, when a message is received, The cluster will
-     * broadcast it invoking the messageReceived on the receiver.
-     * 
-     * @param myobj
-     *            ClusterMessage - the message received from the cluster
-     */
-    public void messageReceived(ClusterMessage myobj) {
-        if (myobj != null && myobj instanceof SessionMessage) {
-            SessionMessage msg = (SessionMessage) myobj;
-            String ctxname = msg.getContextName();
-            //check if the message is a EVT_GET_ALL_SESSIONS,
-            //if so, wait until we are fully started up
-            Map managers = cluster.getManagers() ;
-            if (ctxname == null) {
-                java.util.Iterator i = managers.keySet().iterator();
-                while (i.hasNext()) {
-                    String key = (String) i.next();
-                    ClusterManager mgr = (ClusterManager) managers.get(key);
-                    if (mgr != null)
-                        mgr.messageDataReceived(msg);
-                    else {
-                        //this happens a lot before the system has started
-                        // up
-                        if (log.isDebugEnabled())
-                            log.debug("Context manager doesn't exist:"
-                                    + key);
-                    }
-                }
-            } else {
-                ClusterManager mgr = (ClusterManager) managers.get(ctxname);
-                if (mgr != null)
-                    mgr.messageDataReceived(msg);
-                else if (log.isWarnEnabled())
-                    log.warn("Context manager doesn't exist:" + ctxname);
-            }
-        }
-        return;
-    }
-
-    /**
-     * Accept only SessionMessage
-     * 
-     * @param msg
-     *            ClusterMessage
-     * @return boolean - returns true to indicate that messageReceived should be
-     *         invoked. If false is returned, the messageReceived method will
-     *         not be invoked.
-     */
-    public boolean accept(ClusterMessage msg) {
-        return (msg instanceof SessionMessage);
-    }
-}
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha.session;
+
+import java.util.Map;
+
+import org.apache.catalina.ha.ClusterManager;
+import org.apache.catalina.ha.ClusterMessage;
+import org.apache.catalina.ha.*;
+
+/**
+ * Receive replicated SessionMessage form other cluster node.
+ * @author Filip Hanik
+ * @author Peter Rossbach
+ * @version $Revision: 378258 $ $Date: 2006-02-16 08:42:35 -0600 (Thu, 16 Feb 2006) $
+ */
+public class ClusterSessionListener extends ClusterListener {
+ 
+    /**
+     * The descriptive information about this implementation.
+     */
+    protected static final String info = "org.apache.catalina.session.ClusterSessionListener/1.1";
+
+    //--Constructor---------------------------------------------
+
+    public ClusterSessionListener() {
+    }
+
+    //--Logic---------------------------------------------------
+
+    /**
+     * Return descriptive information about this implementation.
+     */
+    public String getInfo() {
+
+        return (info);
+
+    }
+
+    /**
+     * Callback from the cluster, when a message is received, The cluster will
+     * broadcast it invoking the messageReceived on the receiver.
+     * 
+     * @param myobj
+     *            ClusterMessage - the message received from the cluster
+     */
+    public void messageReceived(ClusterMessage myobj) {
+        if (myobj != null && myobj instanceof SessionMessage) {
+            SessionMessage msg = (SessionMessage) myobj;
+            String ctxname = msg.getContextName();
+            //check if the message is a EVT_GET_ALL_SESSIONS,
+            //if so, wait until we are fully started up
+            Map managers = cluster.getManagers() ;
+            if (ctxname == null) {
+                java.util.Iterator i = managers.keySet().iterator();
+                while (i.hasNext()) {
+                    String key = (String) i.next();
+                    ClusterManager mgr = (ClusterManager) managers.get(key);
+                    if (mgr != null)
+                        mgr.messageDataReceived(msg);
+                    else {
+                        //this happens a lot before the system has started
+                        // up
+                        if (log.isDebugEnabled())
+                            log.debug("Context manager doesn't exist:"
+                                    + key);
+                    }
+                }
+            } else {
+                ClusterManager mgr = (ClusterManager) managers.get(ctxname);
+                if (mgr != null)
+                    mgr.messageDataReceived(msg);
+                else if (log.isWarnEnabled())
+                    log.warn("Context manager doesn't exist:" + ctxname);
+            }
+        }
+        return;
+    }
+
+    /**
+     * Accept only SessionMessage
+     * 
+     * @param msg
+     *            ClusterMessage
+     * @return boolean - returns true to indicate that messageReceived should be
+     *         invoked. If false is returned, the messageReceived method will
+     *         not be invoked.
+     */
+    public boolean accept(ClusterMessage msg) {
+        return (msg instanceof SessionMessage);
+    }
+}
+

==================================================
DeltaManager.java
index 9240308e3b..16e2e90856 100644
--- a/java/org/apache/catalina/ha/session/Constants.java
+++ b/java/org/apache/catalina/ha/session/Constants.java
@@ -1,31 +1,32 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina.ha.session;
-
-/**
- * Manifest constants for the <code>org.apache.catalina.ha.session</code>
- * package.
- *
- * @author Peter Rossbach Pero
- */
-
-public class Constants {
-
-    public static final String Package = "org.apache.catalina.ha.session";
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.catalina.ha.session;
+
+/**
+ * Manifest constants for the <code>org.apache.catalina.ha.session</code>
+ * package.
+ *
+ * @author Peter Rossbach Pero
+ */
+
+public class Constants {
+
+    public static final String Package = "org.apache.catalina.ha.session";
+
+}

==================================================
DeltaRequest.java
index 30d39e9eb1..3aae2f950a 100644
--- a/java/org/apache/catalina/ha/session/DeltaManager.java
+++ b/java/org/apache/catalina/ha/session/DeltaManager.java
@@ -1,1519 +1,1520 @@
-/*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha.session;
-
-import java.beans.PropertyChangeEvent;
-import java.io.BufferedOutputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.Iterator;
-
-import org.apache.catalina.Cluster;
-import org.apache.catalina.Container;
-import org.apache.catalina.Context;
-import org.apache.catalina.Engine;
-import org.apache.catalina.Host;
-import org.apache.catalina.LifecycleException;
-import org.apache.catalina.LifecycleListener;
-import org.apache.catalina.Session;
-import org.apache.catalina.Valve;
-import org.apache.catalina.core.StandardContext;
-import org.apache.catalina.ha.CatalinaCluster;
-import org.apache.catalina.ha.ClusterMessage;
-import org.apache.catalina.ha.tcp.ReplicationValve;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.io.ReplicationStream;
-import org.apache.catalina.util.LifecycleSupport;
-import org.apache.catalina.util.StringManager;
-import org.apache.catalina.ha.ClusterManager;
-
-/**
- * The DeltaManager manages replicated sessions by only replicating the deltas
- * in data. For applications written to handle this, the DeltaManager is the
- * optimal way of replicating data.
- * 
- * This code is almost identical to StandardManager with a difference in how it
- * persists sessions and some modifications to it.
- * 
- * <b>IMPLEMENTATION NOTE </b>: Correct behavior of session storing and
- * reloading depends upon external calls to the <code>start()</code> and
- * <code>stop()</code> methods of this class at the correct times.
- * 
- * @author Filip Hanik
- * @author Craig R. McClanahan
- * @author Jean-Francois Arcand
- * @author Peter Rossbach
- * @version $Revision: 380100 $ $Date: 2006-02-23 06:08:14 -0600 (Thu, 23 Feb 2006) $
- */
-
-public class DeltaManager extends ClusterManagerBase{
-
-    // ---------------------------------------------------- Security Classes
-    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(DeltaManager.class);
-
-    /**
-     * The string manager for this package.
-     */
-    protected static StringManager sm = StringManager.getManager(Constants.Package);
-
-    // ----------------------------------------------------- Instance Variables
-
-    /**
-     * The descriptive information about this implementation.
-     */
-    private static final String info = "DeltaManager/2.1";
-
-    /**
-     * Has this component been started yet?
-     */
-    private boolean started = false;
-
-    /**
-     * The descriptive name of this Manager implementation (for logging).
-     */
-    protected static String managerName = "DeltaManager";
-    protected String name = null;
-    protected boolean defaultMode = false;
-    private CatalinaCluster cluster = null;
-
-    /**
-     * cached replication valve cluster container!
-     */
-    private ReplicationValve replicationValve = null ;
-    
-    /**
-     * The lifecycle event support for this component.
-     */
-    protected LifecycleSupport lifecycle = new LifecycleSupport(this);
-
-    /**
-     * The maximum number of active Sessions allowed, or -1 for no limit.
-     */
-    private int maxActiveSessions = -1;
-    private boolean expireSessionsOnShutdown = false;
-    private boolean notifyListenersOnReplication = true;
-    private boolean notifySessionListenersOnReplication = true;
-    private boolean stateTransfered = false ;
-    private int stateTransferTimeout = 60;
-    private boolean sendAllSessions = true;
-    private boolean sendClusterDomainOnly = true ;
-    private int sendAllSessionsSize = 1000 ;
-    
-    /**
-     * wait time between send session block (default 2 sec) 
-     */
-    private int sendAllSessionsWaitTime = 2 * 1000 ; 
-    private ArrayList receivedMessageQueue = new ArrayList() ;
-    private boolean receiverQueue = false ;
-    private boolean stateTimestampDrop = true ;
-    private long stateTransferCreateSendTime; 
-    
-    // ------------------------------------------------------------------ stats attributes
-    
-    int rejectedSessions = 0;
-    private long sessionReplaceCounter = 0 ;
-    long processingTime = 0;
-    private long counterReceive_EVT_GET_ALL_SESSIONS = 0 ;
-    private long counterSend_EVT_ALL_SESSION_DATA = 0 ;
-    private long counterReceive_EVT_ALL_SESSION_DATA = 0 ;
-    private long counterReceive_EVT_SESSION_CREATED = 0 ;
-    private long counterReceive_EVT_SESSION_EXPIRED = 0;
-    private long counterReceive_EVT_SESSION_ACCESSED = 0 ;
-    private long counterReceive_EVT_SESSION_DELTA = 0;
-    private long counterSend_EVT_GET_ALL_SESSIONS = 0 ;
-    private long counterSend_EVT_SESSION_CREATED = 0;
-    private long counterSend_EVT_SESSION_DELTA = 0 ;
-    private long counterSend_EVT_SESSION_ACCESSED = 0;
-    private long counterSend_EVT_SESSION_EXPIRED = 0;
-    private int counterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE = 0 ;
-    private int counterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE = 0 ;
-    private int counterNoStateTransfered = 0 ;
-
-
-    // ------------------------------------------------------------- Constructor
-    public DeltaManager() {
-        super();
-    }
-
-    // ------------------------------------------------------------- Properties
-    
-    /**
-     * Return descriptive information about this Manager implementation and the
-     * corresponding version number, in the format
-     * <code>&lt;description&gt;/&lt;version&gt;</code>.
-     */
-    public String getInfo() {
-        return info;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-
-    /**
-     * Return the descriptive short name of this Manager implementation.
-     */
-    public String getName() {
-        return name;
-    }
-
-    /**
-     * @return Returns the counterSend_EVT_GET_ALL_SESSIONS.
-     */
-    public long getCounterSend_EVT_GET_ALL_SESSIONS() {
-        return counterSend_EVT_GET_ALL_SESSIONS;
-    }
-    
-    /**
-     * @return Returns the counterSend_EVT_SESSION_ACCESSED.
-     */
-    public long getCounterSend_EVT_SESSION_ACCESSED() {
-        return counterSend_EVT_SESSION_ACCESSED;
-    }
-    
-    /**
-     * @return Returns the counterSend_EVT_SESSION_CREATED.
-     */
-    public long getCounterSend_EVT_SESSION_CREATED() {
-        return counterSend_EVT_SESSION_CREATED;
-    }
-
-    /**
-     * @return Returns the counterSend_EVT_SESSION_DELTA.
-     */
-    public long getCounterSend_EVT_SESSION_DELTA() {
-        return counterSend_EVT_SESSION_DELTA;
-    }
-
-    /**
-     * @return Returns the counterSend_EVT_SESSION_EXPIRED.
-     */
-    public long getCounterSend_EVT_SESSION_EXPIRED() {
-        return counterSend_EVT_SESSION_EXPIRED;
-    }
- 
-    /**
-     * @return Returns the counterSend_EVT_ALL_SESSION_DATA.
-     */
-    public long getCounterSend_EVT_ALL_SESSION_DATA() {
-        return counterSend_EVT_ALL_SESSION_DATA;
-    }
-
-    /**
-     * @return Returns the counterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE.
-     */
-    public int getCounterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE() {
-        return counterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE;
-    }
- 
-    /**
-     * @return Returns the counterReceive_EVT_ALL_SESSION_DATA.
-     */
-    public long getCounterReceive_EVT_ALL_SESSION_DATA() {
-        return counterReceive_EVT_ALL_SESSION_DATA;
-    }
-    
-    /**
-     * @return Returns the counterReceive_EVT_GET_ALL_SESSIONS.
-     */
-    public long getCounterReceive_EVT_GET_ALL_SESSIONS() {
-        return counterReceive_EVT_GET_ALL_SESSIONS;
-    }
-    
-    /**
-     * @return Returns the counterReceive_EVT_SESSION_ACCESSED.
-     */
-    public long getCounterReceive_EVT_SESSION_ACCESSED() {
-        return counterReceive_EVT_SESSION_ACCESSED;
-    }
-    
-    /**
-     * @return Returns the counterReceive_EVT_SESSION_CREATED.
-     */
-    public long getCounterReceive_EVT_SESSION_CREATED() {
-        return counterReceive_EVT_SESSION_CREATED;
-    }
-    
-    /**
-     * @return Returns the counterReceive_EVT_SESSION_DELTA.
-     */
-    public long getCounterReceive_EVT_SESSION_DELTA() {
-        return counterReceive_EVT_SESSION_DELTA;
-    }
-    
-    /**
-     * @return Returns the counterReceive_EVT_SESSION_EXPIRED.
-     */
-    public long getCounterReceive_EVT_SESSION_EXPIRED() {
-        return counterReceive_EVT_SESSION_EXPIRED;
-    }
-    
-    
-    /**
-     * @return Returns the counterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE.
-     */
-    public int getCounterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE() {
-        return counterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE;
-    }
-    
-    /**
-     * @return Returns the processingTime.
-     */
-    public long getProcessingTime() {
-        return processingTime;
-    }
- 
-    /**
-     * @return Returns the sessionReplaceCounter.
-     */
-    public long getSessionReplaceCounter() {
-        return sessionReplaceCounter;
-    }
-    
-    /**
-     * Number of session creations that failed due to maxActiveSessions
-     * 
-     * @return The count
-     */
-    public int getRejectedSessions() {
-        return rejectedSessions;
-    }
-
-    public void setRejectedSessions(int rejectedSessions) {
-        this.rejectedSessions = rejectedSessions;
-    }
-
-    /**
-     * @return Returns the counterNoStateTransfered.
-     */
-    public int getCounterNoStateTransfered() {
-        return counterNoStateTransfered;
-    }
-    
-    public int getReceivedQueueSize() {
-        return receivedMessageQueue.size() ;
-    }
-    
-    /**
-     * @return Returns the stateTransferTimeout.
-     */
-    public int getStateTransferTimeout() {
-        return stateTransferTimeout;
-    }
-    /**
-     * @param timeoutAllSession The timeout
-     */
-    public void setStateTransferTimeout(int timeoutAllSession) {
-        this.stateTransferTimeout = timeoutAllSession;
-    }
-
-    /**
-     * is session state transfered complete?
-     * 
-     */
-    public boolean getStateTransfered() {
-        return stateTransfered;
-    }
-
-    /**
-     * set that state ist complete transfered  
-     * @param stateTransfered
-     */
-    public void setStateTransfered(boolean stateTransfered) {
-        this.stateTransfered = stateTransfered;
-    }
-    
-    /**
-     * @return Returns the sendAllSessionsWaitTime in msec
-     */
-    public int getSendAllSessionsWaitTime() {
-        return sendAllSessionsWaitTime;
-    }
-    
-    /**
-     * @param sendAllSessionsWaitTime The sendAllSessionsWaitTime to set at msec.
-     */
-    public void setSendAllSessionsWaitTime(int sendAllSessionsWaitTime) {
-        this.sendAllSessionsWaitTime = sendAllSessionsWaitTime;
-    }
-    
-    /**
-     * @return Returns the sendClusterDomainOnly.
-     */
-    public boolean doDomainReplication() {
-        return sendClusterDomainOnly;
-    }
-    
-    /**
-     * @param sendClusterDomainOnly The sendClusterDomainOnly to set.
-     */
-    public void setDomainReplication(boolean sendClusterDomainOnly) {
-        this.sendClusterDomainOnly = sendClusterDomainOnly;
-    }
-
-    /**
-     * @return Returns the stateTimestampDrop.
-     */
-    public boolean isStateTimestampDrop() {
-        return stateTimestampDrop;
-    }
-    
-    /**
-     * @param isTimestampDrop The new flag value
-     */
-    public void setStateTimestampDrop(boolean isTimestampDrop) {
-        this.stateTimestampDrop = isTimestampDrop;
-    }
-    
-    /**
-     * Return the maximum number of active Sessions allowed, or -1 for no limit.
-     */
-    public int getMaxActiveSessions() {
-        return (this.maxActiveSessions);
-    }
-
-    /**
-     * Set the maximum number of actives Sessions allowed, or -1 for no limit.
-     * 
-     * @param max
-     *            The new maximum number of sessions
-     */
-    public void setMaxActiveSessions(int max) {
-        int oldMaxActiveSessions = this.maxActiveSessions;
-        this.maxActiveSessions = max;
-        support.firePropertyChange("maxActiveSessions", new Integer(oldMaxActiveSessions), new Integer(this.maxActiveSessions));
-    }
-    
-    /**
-     * 
-     * @return Returns the sendAllSessions.
-     */
-    public boolean isSendAllSessions() {
-        return sendAllSessions;
-    }
-    
-    /**
-     * @param sendAllSessions The sendAllSessions to set.
-     */
-    public void setSendAllSessions(boolean sendAllSessions) {
-        this.sendAllSessions = sendAllSessions;
-    }
-    
-    /**
-     * @return Returns the sendAllSessionsSize.
-     */
-    public int getSendAllSessionsSize() {
-        return sendAllSessionsSize;
-    }
-    
-    /**
-     * @param sendAllSessionsSize The sendAllSessionsSize to set.
-     */
-    public void setSendAllSessionsSize(int sendAllSessionsSize) {
-        this.sendAllSessionsSize = sendAllSessionsSize;
-    }
-    
-    /**
-     * @return Returns the notifySessionListenersOnReplication.
-     */
-    public boolean isNotifySessionListenersOnReplication() {
-        return notifySessionListenersOnReplication;
-    }
-    
-    /**
-     * @param notifyListenersCreateSessionOnReplication The notifySessionListenersOnReplication to set.
-     */
-    public void setNotifySessionListenersOnReplication(boolean notifyListenersCreateSessionOnReplication) {
-        this.notifySessionListenersOnReplication = notifyListenersCreateSessionOnReplication;
-    }
-    
-    
-    public boolean isExpireSessionsOnShutdown() {
-        return expireSessionsOnShutdown;
-    }
-
-    public void setExpireSessionsOnShutdown(boolean expireSessionsOnShutdown) {
-        this.expireSessionsOnShutdown = expireSessionsOnShutdown;
-    }
-    
-    public boolean isNotifyListenersOnReplication() {
-        return notifyListenersOnReplication;
-    }
-
-    public void setNotifyListenersOnReplication(boolean notifyListenersOnReplication) {
-        this.notifyListenersOnReplication = notifyListenersOnReplication;
-    }
-
-    
-    /**
-     * @return Returns the defaultMode.
-     */
-    public boolean isDefaultMode() {
-        return defaultMode;
-    }
-    /**
-     * @param defaultMode The defaultMode to set.
-     */
-    public void setDefaultMode(boolean defaultMode) {
-        this.defaultMode = defaultMode;
-    }
-    
-    public CatalinaCluster getCluster() {
-        return cluster;
-    }
-
-    public void setCluster(CatalinaCluster cluster) {
-        this.cluster = cluster;
-    }
-
-    /**
-     * Set the Container with which this Manager has been associated. If it is a
-     * Context (the usual case), listen for changes to the session timeout
-     * property.
-     * 
-     * @param container
-     *            The associated Container
-     */
-    public void setContainer(Container container) {
-        // De-register from the old Container (if any)
-        if ((this.container != null) && (this.container instanceof Context))
-            ((Context) this.container).removePropertyChangeListener(this);
-
-        // Default processing provided by our superclass
-        super.setContainer(container);
-
-        // Register with the new Container (if any)
-        if ((this.container != null) && (this.container instanceof Context)) {
-            setMaxInactiveInterval(((Context) this.container).getSessionTimeout() * 60);
-            ((Context) this.container).addPropertyChangeListener(this);
-        }
-
-    }
-    
-    // --------------------------------------------------------- Public Methods
-
-    /**
-     * Construct and return a new session object, based on the default settings
-     * specified by this Manager's properties. The session id will be assigned
-     * by this method, and available via the getId() method of the returned
-     * session. If a new session cannot be created for any reason, return
-     * <code>null</code>.
-     * 
-     * @exception IllegalStateException
-     *                if a new session cannot be instantiated for any reason
-     * 
-     * Construct and return a new session object, based on the default settings
-     * specified by this Manager's properties. The session id will be assigned
-     * by this method, and available via the getId() method of the returned
-     * session. If a new session cannot be created for any reason, return
-     * <code>null</code>.
-     * 
-     * @exception IllegalStateException
-     *                if a new session cannot be instantiated for any reason
-     */
-    public Session createSession(String sessionId) {
-        return createSession(sessionId, true);
-    }
-
-    /**
-     * create new session with check maxActiveSessions and send session creation
-     * to other cluster nodes.
-     * 
-     * @param distribute
-     * @return The session
-     */
-    public Session createSession(String sessionId, boolean distribute) {
-        if ((maxActiveSessions >= 0) && (sessions.size() >= maxActiveSessions)) {
-            rejectedSessions++;
-            throw new IllegalStateException(sm.getString("deltaManager.createSession.ise"));
-        }
-        DeltaSession session = (DeltaSession) super.createSession(sessionId) ;
-        if (distribute) {
-            sendCreateSession(session.getId(), session);
-        }
-        if (log.isDebugEnabled())
-            log.debug(sm.getString("deltaManager.createSession.newSession",session.getId(), new Integer(sessions.size())));
-        return (session);
-
-    }
-
-    /**
-     * Send create session evt to all backup node
-     * @param sessionId
-     * @param session
-     */
-    protected void sendCreateSession(String sessionId, DeltaSession session) {
-        if(cluster.getMembers().length > 0 ) {
-            SessionMessage msg = 
-                new SessionMessageImpl(getName(),
-                                       SessionMessage.EVT_SESSION_CREATED, 
-                                       null, 
-                                       sessionId,
-                                       sessionId + "-" + System.currentTimeMillis());
-            if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.sendMessage.newSession",name, sessionId));
-            msg.setTimestamp(session.getCreationTime());
-            counterSend_EVT_SESSION_CREATED++;
-            send(msg);
-        }
-    }
-    
-    /**
-     * Send messages to other backup member (domain or all)
-     * @param msg Session message
-     */
-    protected void send(SessionMessage msg) {
-        if(cluster != null) {
-            if(doDomainReplication())
-                cluster.sendClusterDomain(msg);
-            else
-                cluster.send(msg);
-        }
-    }
-
-    /**
-     * Create DeltaSession
-     * @see org.apache.catalina.Manager#createEmptySession()
-     */
-    public Session createEmptySession() {
-        return getNewDeltaSession() ;
-    }
-    
-    /**
-     * Get new session class to be used in the doLoad() method.
-     */
-    protected DeltaSession getNewDeltaSession() {
-        return new DeltaSession(this);
-    }
-
-    /**
-     * Load Deltarequest from external node
-     * Load the Class at container classloader
-     * @see DeltaRequest#readExternal(java.io.ObjectInput)
-     * @param session
-     * @param data message data
-     * @return The request
-     * @throws ClassNotFoundException
-     * @throws IOException
-     */
-    protected DeltaRequest deserializeDeltaRequest(DeltaSession session, byte[] data) throws ClassNotFoundException, IOException {
-        ReplicationStream ois = getReplicationStream(data);
-        session.getDeltaRequest().readExternal(ois);
-        ois.close();
-        return session.getDeltaRequest();
-    }
-
-    /**
-     * serialize DeltaRequest
-     * @see DeltaRequest#writeExternal(java.io.ObjectOutput)
-     * 
-     * @param deltaRequest
-     * @return serialized delta request
-     * @throws IOException
-     */
-    protected byte[] serializeDeltaRequest(DeltaRequest deltaRequest) throws IOException {
-        return deltaRequest.serialize();
-    }
-
-    /**
-     * Load sessions from other cluster node.
-     * FIXME replace currently sessions with same id without notifcation.
-     * FIXME SSO handling is not really correct with the session replacement!
-     * @exception ClassNotFoundException
-     *                if a serialized class cannot be found during the reload
-     * @exception IOException
-     *                if an input/output error occurs
-     */
-    protected void deserializeSessions(byte[] data) throws ClassNotFoundException,IOException {
-
-        // Initialize our internal data structures
-        //sessions.clear(); //should not do this
-        // Open an input stream to the specified pathname, if any
-        ClassLoader originalLoader = Thread.currentThread().getContextClassLoader();
-        ObjectInputStream ois = null;
-        // Load the previously unloaded active sessions
-        try {
-            ois = getReplicationStream(data);
-            Integer count = (Integer) ois.readObject();
-            int n = count.intValue();
-            for (int i = 0; i < n; i++) {
-                DeltaSession session = (DeltaSession) createEmptySession();
-                session.readObjectData(ois);
-                session.setManager(this);
-                session.setValid(true);
-                session.setPrimarySession(false);
-                //in case the nodes in the cluster are out of
-                //time synch, this will make sure that we have the
-                //correct timestamp, isValid returns true, cause
-                // accessCount=1
-                session.access();
-                //make sure that the session gets ready to expire if
-                // needed
-                session.setAccessCount(0);
-                session.resetDeltaRequest();
-                // FIXME How inform other session id cache like SingleSignOn
-                // increment sessionCounter to correct stats report
-                if (findSession(session.getIdInternal()) == null ) {
-                    sessionCounter++;
-                } else {
-                    sessionReplaceCounter++;
-                    // FIXME better is to grap this sessions again !
-                    if (log.isWarnEnabled()) log.warn(sm.getString("deltaManager.loading.existing.session",session.getIdInternal()));
-                }
-                add(session);
-            }
-        } catch (ClassNotFoundException e) {
-            log.error(sm.getString("deltaManager.loading.cnfe", e), e);
-            throw e;
-        } catch (IOException e) {
-            log.error(sm.getString("deltaManager.loading.ioe", e), e);
-            throw e;
-        } finally {
-            // Close the input stream
-            try {
-                if (ois != null) ois.close();
-            } catch (IOException f) {
-                // ignored
-            }
-            ois = null;
-            if (originalLoader != null) Thread.currentThread().setContextClassLoader(originalLoader);
-        }
-
-    }
-
-    
-
-    /**
-     * Save any currently active sessions in the appropriate persistence
-     * mechanism, if any. If persistence is not supported, this method returns
-     * without doing anything.
-     * 
-     * @exception IOException
-     *                if an input/output error occurs
-     */
-    protected byte[] serializeSessions(Session[] currentSessions) throws IOException {
-
-        // Open an output stream to the specified pathname, if any
-        ByteArrayOutputStream fos = null;
-        ObjectOutputStream oos = null;
-
-        try {
-            fos = new ByteArrayOutputStream();
-            oos = new ObjectOutputStream(new BufferedOutputStream(fos));
-            oos.writeObject(new Integer(currentSessions.length));
-            for(int i=0 ; i < currentSessions.length;i++) {
-                ((DeltaSession)currentSessions[i]).writeObjectData(oos);                
-            }
-            // Flush and close the output stream
-            oos.flush();
-        } catch (IOException e) {
-            log.error(sm.getString("deltaManager.unloading.ioe", e), e);
-            throw e;
-        } finally {
-            if (oos != null) {
-                try {
-                    oos.close();
-                } catch (IOException f) {
-                    ;
-                }
-                oos = null;
-            }
-        }
-        // send object data as byte[]
-        return fos.toByteArray();
-    }
-
-    // ------------------------------------------------------ Lifecycle Methods
-
-    /**
-     * Add a lifecycle event listener to this component.
-     * 
-     * @param listener
-     *            The listener to add
-     */
-    public void addLifecycleListener(LifecycleListener listener) {
-        lifecycle.addLifecycleListener(listener);
-    }
-
-    /**
-     * Get the lifecycle listeners associated with this lifecycle. If this
-     * Lifecycle has no listeners registered, a zero-length array is returned.
-     */
-    public LifecycleListener[] findLifecycleListeners() {
-        return lifecycle.findLifecycleListeners();
-    }
-
-    /**
-     * Remove a lifecycle event listener from this component.
-     * 
-     * @param listener
-     *            The listener to remove
-     */
-    public void removeLifecycleListener(LifecycleListener listener) {
-        lifecycle.removeLifecycleListener(listener);
-    }
-
-    /**
-     * Prepare for the beginning of active use of the public methods of this
-     * component. This method should be called after <code>configure()</code>,
-     * and before any of the public methods of the component are utilized.
-     * 
-     * @exception LifecycleException
-     *                if this component detects a fatal error that prevents this
-     *                component from being used
-     */
-    public void start() throws LifecycleException {
-        if (!initialized) init();
-
-        // Validate and update our current component state
-        if (started) {
-            return;
-        }
-        started = true;
-        lifecycle.fireLifecycleEvent(START_EVENT, null);
-
-        // Force initialization of the random number generator
-        generateSessionId();
-
-        // Load unloaded sessions, if any
-        try {
-            //the channel is already running
-            Cluster cluster = getCluster() ;
-            // stop remove cluster binding
-            //wow, how many nested levels of if statements can we have ;)
-            if(cluster == null) {
-                Container context = getContainer() ;
-                if(context != null && context instanceof Context) {
-                     Container host = context.getParent() ;
-                     if(host != null && host instanceof Host) {
-                         cluster = host.getCluster();
-                         if(cluster != null && cluster instanceof CatalinaCluster) {
-                             setCluster((CatalinaCluster) cluster) ;
-                         } else {
-                             Container engine = host.getParent() ;
-                             if(engine != null && engine instanceof Engine) {
-                                 cluster = engine.getCluster();
-                                 if(cluster != null && cluster instanceof CatalinaCluster) {
-                                     setCluster((CatalinaCluster) cluster) ;
-                                 }
-                             } else {
-                                     cluster = null ;
-                             }
-                         }
-                     }
-                }
-            }
-            if (cluster == null) {
-                log.error(sm.getString("deltaManager.noCluster", getName()));
-                return;
-            } else {
-                if (log.isInfoEnabled()) {
-                    String type = "unknown" ;
-                    if( cluster.getContainer() instanceof Host){
-                        type = "Host" ;
-                    } else if( cluster.getContainer() instanceof Engine){
-                        type = "Engine" ;
-                    }
-                    log.info(sm.getString("deltaManager.registerCluster", getName(), type, cluster.getClusterName()));
-                }
-            }
-            if (log.isInfoEnabled()) log.info(sm.getString("deltaManager.startClustering", getName()));
-            //to survice context reloads, as only a stop/start is called, not
-            // createManager
-            cluster.registerManager(this);
-
-            getAllClusterSessions();
-
-        } catch (Throwable t) {
-            log.error(sm.getString("deltaManager.managerLoad"), t);
-        }
-    }
-
-    /**
-     * get from first session master the backup from all clustered sessions
-     * @see #findSessionMasterMember()
-     */
-    public synchronized void getAllClusterSessions() {
-        if (cluster != null && cluster.getMembers().length > 0) {
-            long beforeSendTime = System.currentTimeMillis();
-            Member mbr = findSessionMasterMember();
-            if(mbr == null) { // No domain member found
-                 return;
-            }
-            SessionMessage msg = new SessionMessageImpl(this.getName(),SessionMessage.EVT_GET_ALL_SESSIONS, null, "GET-ALL","GET-ALL-" + getName());
-            // set reference time
-            stateTransferCreateSendTime = beforeSendTime ;
-            // request session state
-            counterSend_EVT_GET_ALL_SESSIONS++;
-            stateTransfered = false ;
-            // FIXME This send call block the deploy thread, when sender waitForAck is enabled
-            try {
-                synchronized(receivedMessageQueue) {
-                     receiverQueue = true ;
-                }
-                cluster.send(msg, mbr);
-                if (log.isWarnEnabled()) log.warn(sm.getString("deltaManager.waitForSessionState",getName(), mbr));
-                // FIXME At sender ack mode this method check only the state transfer and resend is a problem!
-                waitForSendAllSessions(beforeSendTime);
-            } finally {
-                synchronized(receivedMessageQueue) {
-                    for (Iterator iter = receivedMessageQueue.iterator(); iter.hasNext();) {
-                        SessionMessage smsg = (SessionMessage) iter.next();
-                        if (!stateTimestampDrop) {
-                            messageReceived(smsg, smsg.getAddress() != null ? (Member) smsg.getAddress() : null);
-                        } else {
-                            if (smsg.getEventType() != SessionMessage.EVT_GET_ALL_SESSIONS && smsg.getTimestamp() >= stateTransferCreateSendTime) {
-                                // FIXME handle EVT_GET_ALL_SESSIONS later
-                                messageReceived(smsg,smsg.getAddress() != null ? (Member) smsg.getAddress() : null);
-                            } else {
-                                if (log.isWarnEnabled()) {
-                                    log.warn(sm.getString("deltaManager.dropMessage",getName(), smsg.getEventTypeString(),new Date(stateTransferCreateSendTime), new Date(smsg.getTimestamp())));
-                                }
-                            }
-                        }
-                    }        
-                    receivedMessageQueue.clear();
-                    receiverQueue = false ;
-                }
-           }
-        } else {
-            if (log.isInfoEnabled()) log.info(sm.getString("deltaManager.noMembers", getName()));
-        }
-    }
-
-    /**
-     * Register cross context session at replication valve thread local
-     * @param session cross context session
-     */
-    protected void registerSessionAtReplicationValve(DeltaSession session) {
-        if(replicationValve == null) {
-            if(container instanceof StandardContext && ((StandardContext)container).getCrossContext()) {
-                Cluster cluster = getCluster() ;
-                if(cluster != null && cluster instanceof CatalinaCluster) {
-                    Valve[] valves = ((CatalinaCluster)cluster).getValves();
-                    if(valves != null && valves.length > 0) {
-                        for(int i=0; replicationValve == null && i < valves.length ; i++ ){
-                            if(valves[i] instanceof ReplicationValve) replicationValve = (ReplicationValve)valves[i] ;
-                        }//for
-
-                        if(replicationValve == null && log.isDebugEnabled()) {
-                            log.debug("no ReplicationValve found for CrossContext Support");
-                        }//endif 
-                    }//end if
-                }//endif
-            }//end if
-        }//end if
-        if(replicationValve != null) {
-            replicationValve.registerReplicationSession(session);
-        }
-    }
-    
-    /**
-     * Find the master of the session state
-     * @return master member of sessions 
-     */
-    protected Member findSessionMasterMember() {
-        Member mbr = null;
-        Member mbrs[] = cluster.getMembers();
-        if(mbrs.length != 0 ) mbr = mbrs[0];
-        if(mbr == null && log.isWarnEnabled()) log.warn(sm.getString("deltaManager.noMasterMember",getName(), ""));
-        if(mbr != null && log.isDebugEnabled()) log.warn(sm.getString("deltaManager.foundMasterMember",getName(), mbr));
-        return mbr;
-    }
-
-    /**
-     * Wait that cluster session state is transfer or timeout after 60 Sec
-     * With stateTransferTimeout == -1 wait that backup is transfered (forever mode)
-     */
-    protected void waitForSendAllSessions(long beforeSendTime) {
-        long reqStart = System.currentTimeMillis();
-        long reqNow = reqStart ;
-        boolean isTimeout = false;
-        if(getStateTransferTimeout() > 0) {
-            // wait that state is transfered with timeout check
-            do {
-                try {
-                    Thread.sleep(100);
-                } catch (Exception sleep) {
-                    //
-                }
-                reqNow = System.currentTimeMillis();
-                isTimeout = ((reqNow - reqStart) > (1000 * getStateTransferTimeout()));
-            } while ((!getStateTransfered()) && (!isTimeout));
-        } else {
-            if(getStateTransferTimeout() == -1) {
-                // wait that state is transfered
-                do {
-                    try {
-                        Thread.sleep(100);
-                    } catch (Exception sleep) {
-                    }
-                } while ((!getStateTransfered()));
-                reqNow = System.currentTimeMillis();
-            }
-        }
-        if (isTimeout || (!getStateTransfered())) {
-            counterNoStateTransfered++ ;
-            log.error(sm.getString("deltaManager.noSessionState",getName(),new Date(beforeSendTime),new Long(reqNow - beforeSendTime)));
-        } else {
-            if (log.isInfoEnabled())
-                log.info(sm.getString("deltaManager.sessionReceived",getName(), new Date(beforeSendTime), new Long(reqNow - beforeSendTime)));
-        }
-    }
-
-    /**
-     * Gracefully terminate the active use of the public methods of this
-     * component. This method should be the last one called on a given instance
-     * of this component.
-     * 
-     * @exception LifecycleException
-     *                if this component detects a fatal error that needs to be
-     *                reported
-     */
-    public void stop() throws LifecycleException {
-
-        if (log.isDebugEnabled())
-            log.debug(sm.getString("deltaManager.stopped", getName()));
-
-
-        // Validate and update our current component state
-        if (!started)
-            throw new LifecycleException(sm.getString("deltaManager.notStarted"));
-        lifecycle.fireLifecycleEvent(STOP_EVENT, null);
-        started = false;
-
-        // Expire all active sessions
-        if (log.isInfoEnabled()) log.info(sm.getString("deltaManager.expireSessions", getName()));
-        Session sessions[] = findSessions();
-        for (int i = 0; i < sessions.length; i++) {
-            DeltaSession session = (DeltaSession) sessions[i];
-            if (!session.isValid())
-                continue;
-            try {
-                session.expire(true, isExpireSessionsOnShutdown());
-            } catch (Throwable ignore) {
-                ;
-            } 
-        }
-
-        // Require a new random number generator if we are restarted
-        this.random = null;
-        getCluster().removeManager(this);
-        replicationValve = null;
-        if (initialized) {
-            destroy();
-        }
-    }
-
-    // ----------------------------------------- PropertyChangeListener Methods
-
-    /**
-     * Process property change events from our associated Context.
-     * 
-     * @param event
-     *            The property change event that has occurred
-     */
-    public void propertyChange(PropertyChangeEvent event) {
-
-        // Validate the source of this event
-        if (!(event.getSource() instanceof Context))
-            return;
-        // Process a relevant property change
-        if (event.getPropertyName().equals("sessionTimeout")) {
-            try {
-                setMaxInactiveInterval(((Integer) event.getNewValue()).intValue() * 60);
-            } catch (NumberFormatException e) {
-                log.error(sm.getString("deltaManager.sessionTimeout", event.getNewValue()));
-            }
-        }
-
-    }
-
-    // -------------------------------------------------------- Replication
-    // Methods
-
-    /**
-     * A message was received from another node, this is the callback method to
-     * implement if you are interested in receiving replication messages.
-     * 
-     * @param cmsg -
-     *            the message received.
-     */
-    public void messageDataReceived(ClusterMessage cmsg) {
-        if (cmsg != null && cmsg instanceof SessionMessage) {
-            SessionMessage msg = (SessionMessage) cmsg;
-            switch (msg.getEventType()) {
-                case SessionMessage.EVT_GET_ALL_SESSIONS:
-                case SessionMessage.EVT_SESSION_CREATED: 
-                case SessionMessage.EVT_SESSION_EXPIRED: 
-                case SessionMessage.EVT_SESSION_ACCESSED:
-                case SessionMessage.EVT_SESSION_DELTA: {
-                    synchronized(receivedMessageQueue) {
-                        if(receiverQueue) {
-                            receivedMessageQueue.add(msg);
-                            return ;
-                        }
-                    }
-                   break;
-                }
-                default: {
-                    //we didn't queue, do nothing
-                    break;
-                }
-            } //switch
-            
-            messageReceived(msg, msg.getAddress() != null ? (Member) msg.getAddress() : null);
-        }
-    }
-
-    /**
-     * When the request has been completed, the replication valve will notify
-     * the manager, and the manager will decide whether any replication is
-     * needed or not. If there is a need for replication, the manager will
-     * create a session message and that will be replicated. The cluster
-     * determines where it gets sent.
-     * 
-     * @param sessionId -
-     *            the sessionId that just completed.
-     * @return a SessionMessage to be sent,
-     */
-    public ClusterMessage requestCompleted(String sessionId) {
-        try {
-            DeltaSession session = (DeltaSession) findSession(sessionId);
-            DeltaRequest deltaRequest = session.getDeltaRequest();
-            SessionMessage msg = null;
-            boolean isDeltaRequest = false ;
-            synchronized(deltaRequest) {
-                isDeltaRequest = deltaRequest.getSize() > 0 ;
-                if (isDeltaRequest) {    
-                    counterSend_EVT_SESSION_DELTA++;
-                    byte[] data = serializeDeltaRequest(deltaRequest);
-                    msg = new SessionMessageImpl(getName(),
-                                                 SessionMessage.EVT_SESSION_DELTA, 
-                                                 data, 
-                                                 sessionId,
-                                                 sessionId + "-" + System.currentTimeMillis());
-                    session.resetDeltaRequest();
-                }  
-            }
-            if(!isDeltaRequest) {
-                if(!session.isPrimarySession()) {               
-                    counterSend_EVT_SESSION_ACCESSED++;
-                    msg = new SessionMessageImpl(getName(),
-                                                 SessionMessage.EVT_SESSION_ACCESSED, 
-                                                 null, 
-                                                 sessionId,
-                                                 sessionId + "-" + System.currentTimeMillis());
-                    if (log.isDebugEnabled()) {
-                        log.debug(sm.getString("deltaManager.createMessage.accessChangePrimary",getName(), sessionId));
-                    }
-                }    
-            } else { // log only outside synch block!
-                if (log.isDebugEnabled()) {
-                    log.debug(sm.getString("deltaManager.createMessage.delta",getName(), sessionId));
-                }
-            }
-            session.setPrimarySession(true);
-            //check to see if we need to send out an access message
-            if ((msg == null)) {
-                long replDelta = System.currentTimeMillis() - session.getLastTimeReplicated();
-                if (replDelta > (getMaxInactiveInterval() * 1000)) {
-                    counterSend_EVT_SESSION_ACCESSED++;
-                    msg = new SessionMessageImpl(getName(),
-                                                 SessionMessage.EVT_SESSION_ACCESSED, 
-                                                 null,
-                                                 sessionId, 
-                                                 sessionId + "-" + System.currentTimeMillis());
-                    if (log.isDebugEnabled()) {
-                        log.debug(sm.getString("deltaManager.createMessage.access", getName(),sessionId));
-                    }
-                }
-
-            }
-
-            //update last replicated time
-            if (msg != null) session.setLastTimeReplicated(System.currentTimeMillis());
-            return msg;
-        } catch (IOException x) {
-            log.error(sm.getString("deltaManager.createMessage.unableCreateDeltaRequest",sessionId), x);
-            return null;
-        }
-
-    }
-    /**
-     * Reset manager statistics
-     */
-    public synchronized void resetStatistics() {
-        processingTime = 0 ;
-        expiredSessions = 0 ;
-        rejectedSessions = 0 ;
-        sessionReplaceCounter = 0 ;
-        counterNoStateTransfered = 0 ;
-        maxActive = getActiveSessions() ;
-        sessionCounter = getActiveSessions() ;
-        counterReceive_EVT_ALL_SESSION_DATA = 0;
-        counterReceive_EVT_GET_ALL_SESSIONS = 0;
-        counterReceive_EVT_SESSION_ACCESSED = 0 ;
-        counterReceive_EVT_SESSION_CREATED = 0 ;
-        counterReceive_EVT_SESSION_DELTA = 0 ;
-        counterReceive_EVT_SESSION_EXPIRED = 0 ;
-        counterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE = 0;
-        counterSend_EVT_ALL_SESSION_DATA = 0;
-        counterSend_EVT_GET_ALL_SESSIONS = 0;
-        counterSend_EVT_SESSION_ACCESSED = 0 ;
-        counterSend_EVT_SESSION_CREATED = 0 ;
-        counterSend_EVT_SESSION_DELTA = 0 ;
-        counterSend_EVT_SESSION_EXPIRED = 0 ;
-        counterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE = 0;
-        
-    }
-   
-    //  -------------------------------------------------------- persistence handler
-
-    public void load() {
-
-    }
-
-    public void unload() {
-
-    }
-
-    //  -------------------------------------------------------- expire
-
-    /**
-     * send session expired to other cluster nodes
-     * 
-     * @param id
-     *            session id
-     */
-    protected void sessionExpired(String id) {
-        counterSend_EVT_SESSION_EXPIRED++ ;
-        SessionMessage msg = new SessionMessageImpl(getName(),SessionMessage.EVT_SESSION_EXPIRED, null, id, id+ "-EXPIRED-MSG");
-        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.createMessage.expire",getName(), id));
-        send(msg);
-    }
-
-    /**
-     * Exipre all find sessions.
-     */
-    public void expireAllLocalSessions()
-    {
-        long timeNow = System.currentTimeMillis();
-        Session sessions[] = findSessions();
-        int expireDirect  = 0 ;
-        int expireIndirect = 0 ;
-        
-        if(log.isDebugEnabled()) log.debug("Start expire all sessions " + getName() + " at " + timeNow + " sessioncount " + sessions.length);
-        for (int i = 0; i < sessions.length; i++) {
-            if (sessions[i] instanceof DeltaSession) {
-                DeltaSession session = (DeltaSession) sessions[i];
-                if (session.isPrimarySession()) {
-                    if (session.isValid()) {
-                        session.expire();
-                        expireDirect++;
-                    } else {
-                        expireIndirect++;
-                    }//end if
-                }//end if
-            }//end if
-        }//for
-        long timeEnd = System.currentTimeMillis();
-        if(log.isDebugEnabled()) log.debug("End expire sessions " + getName() + " exipre processingTime " + (timeEnd - timeNow) + " expired direct sessions: " + expireDirect + " expired direct sessions: " + expireIndirect);
-      
-    }
-    
-    /**
-     * When the manager expires session not tied to a request. The cluster will
-     * periodically ask for a list of sessions that should expire and that
-     * should be sent across the wire.
-     * 
-     * @return The invalidated sessions array
-     */
-    public String[] getInvalidatedSessions() {
-        return new String[0];
-    }
-
-    //  -------------------------------------------------------- message receive
-
-    /**
-     * Test that sender and local domain is the same
-     */
-    protected boolean checkSenderDomain(SessionMessage msg,Member sender) {
-        boolean sameDomain= true;
-        if (!sameDomain && log.isWarnEnabled()) {
-                log.warn(sm.getString("deltaManager.receiveMessage.fromWrongDomain",
-                         new Object[] {getName(), 
-                         msg.getEventTypeString(), 
-                         sender,
-                         "",
-                         "" }));
-        }
-        return sameDomain ;
-    }
-
-    /**
-     * This method is called by the received thread when a SessionMessage has
-     * been received from one of the other nodes in the cluster.
-     * 
-     * @param msg -
-     *            the message received
-     * @param sender -
-     *            the sender of the message, this is used if we receive a
-     *            EVT_GET_ALL_SESSION message, so that we only reply to the
-     *            requesting node
-     */
-    protected void messageReceived(SessionMessage msg, Member sender) {
-        if(doDomainReplication() && !checkSenderDomain(msg,sender)) {
-            return;
-        }
-        ClassLoader contextLoader = Thread.currentThread().getContextClassLoader();
-        try {
-            
-            ClassLoader[] loaders = getClassLoaders();
-            if ( loaders != null && loaders.length > 0) Thread.currentThread().setContextClassLoader(loaders[0]);
-            if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.eventType",getName(), msg.getEventTypeString(), sender));
- 
-            switch (msg.getEventType()) {
-                case SessionMessage.EVT_GET_ALL_SESSIONS: {
-                    handleGET_ALL_SESSIONS(msg,sender);
-                    break;
-                }
-                case SessionMessage.EVT_ALL_SESSION_DATA: {
-                    handleALL_SESSION_DATA(msg,sender);
-                    break;
-                }
-                case SessionMessage.EVT_ALL_SESSION_TRANSFERCOMPLETE: {
-                    handleALL_SESSION_TRANSFERCOMPLETE(msg,sender);
-                    break;
-                }
-                case SessionMessage.EVT_SESSION_CREATED: {
-                    handleSESSION_CREATED(msg,sender);
-                    break;
-                }
-                case SessionMessage.EVT_SESSION_EXPIRED: {
-                    handleSESSION_EXPIRED(msg,sender);
-                    break;
-                }
-                case SessionMessage.EVT_SESSION_ACCESSED: {
-                    handleSESSION_ACCESSED(msg,sender);
-                    break;
-                }
-                case SessionMessage.EVT_SESSION_DELTA: {
-                   handleSESSION_DELTA(msg,sender);
-                   break;
-                }
-                default: {
-                    //we didn't recognize the message type, do nothing
-                    break;
-                }
-            } //switch
-        } catch (Exception x) {
-            log.error(sm.getString("deltaManager.receiveMessage.error",getName()), x);
-        } finally {
-            Thread.currentThread().setContextClassLoader(contextLoader);
-        }
-    }
-
-    // -------------------------------------------------------- message receiver handler
-
-
-    /**
-     * handle receive session state is complete transfered
-     * @param msg
-     * @param sender
-     */
-    protected void handleALL_SESSION_TRANSFERCOMPLETE(SessionMessage msg, Member sender) {
-        counterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE++ ;
-        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.transfercomplete",getName(), sender.getHost(), new Integer(sender.getPort())));
-        stateTransferCreateSendTime = msg.getTimestamp() ;
-        stateTransfered = true ;
-    }
-
-    /**
-     * handle receive session delta
-     * @param msg
-     * @param sender
-     * @throws IOException
-     * @throws ClassNotFoundException
-     */
-    protected void handleSESSION_DELTA(SessionMessage msg, Member sender) throws IOException, ClassNotFoundException {
-        counterReceive_EVT_SESSION_DELTA++;
-        byte[] delta = msg.getSession();
-        DeltaSession session = (DeltaSession) findSession(msg.getSessionID());
-        if (session != null) {
-            if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.delta",getName(), msg.getSessionID()));
-            DeltaRequest dreq = deserializeDeltaRequest(session, delta);
-            dreq.execute(session, notifyListenersOnReplication);
-            session.setPrimarySession(false);
-        }
-    }
-
-    /**
-     * handle receive session is access at other node ( primary session is now false)
-     * @param msg
-     * @param sender
-     * @throws IOException
-     */
-    protected void handleSESSION_ACCESSED(SessionMessage msg,Member sender) throws IOException {
-        counterReceive_EVT_SESSION_ACCESSED++;
-        DeltaSession session = (DeltaSession) findSession(msg.getSessionID());
-        if (session != null) {
-            if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.accessed",getName(), msg.getSessionID()));
-            session.access();
-            session.setPrimarySession(false);
-            session.endAccess();
-        }
-    }
-
-    /**
-     * handle receive session is expire at other node ( expire session also here)
-     * @param msg
-     * @param sender
-     * @throws IOException
-     */
-    protected void handleSESSION_EXPIRED(SessionMessage msg,Member sender) throws IOException {
-        counterReceive_EVT_SESSION_EXPIRED++;
-        DeltaSession session = (DeltaSession) findSession(msg.getSessionID());
-        if (session != null) {
-            if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.expired",getName(), msg.getSessionID()));
-            session.expire(notifySessionListenersOnReplication, false);
-        }
-    }
-
-    /**
-     * handle receive new session is created at other node (create backup - primary false)
-     * @param msg
-     * @param sender
-     */
-    protected void handleSESSION_CREATED(SessionMessage msg,Member sender) {
-        counterReceive_EVT_SESSION_CREATED++;
-        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.createNewSession",getName(), msg.getSessionID()));
-        DeltaSession session = (DeltaSession) createEmptySession();
-        session.setManager(this);
-        session.setValid(true);
-        session.setPrimarySession(false);
-        session.setCreationTime(msg.getTimestamp());
-        session.access();
-        if(notifySessionListenersOnReplication)
-            session.setId(msg.getSessionID());
-        else
-            session.setIdInternal(msg.getSessionID());
-        session.resetDeltaRequest();
-        session.endAccess();
-
-    }
-
-    /**
-     * handle receive sessions from other not ( restart )
-     * @param msg
-     * @param sender
-     * @throws ClassNotFoundException
-     * @throws IOException
-     */
-    protected void handleALL_SESSION_DATA(SessionMessage msg,Member sender) throws ClassNotFoundException, IOException {
-        counterReceive_EVT_ALL_SESSION_DATA++;
-        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.allSessionDataBegin",getName()));
-        byte[] data = msg.getSession();
-        deserializeSessions(data);
-        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.allSessionDataAfter",getName()));
-        //stateTransferred = true;
-    }
-
-    /**
-     * handle receive that other node want all sessions ( restart )
-     * a) send all sessions with one message
-     * b) send session at blocks
-     * After sending send state is complete transfered
-     * @param msg
-     * @param sender
-     * @throws IOException
-     */
-    protected void handleGET_ALL_SESSIONS(SessionMessage msg, Member sender) throws IOException {
-        counterReceive_EVT_GET_ALL_SESSIONS++;
-        //get a list of all the session from this manager
-        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.unloadingBegin", getName()));
-        // Write the number of active sessions, followed by the details
-        // get all sessions and serialize without sync
-        Session[] currentSessions = findSessions();
-        long findSessionTimestamp = System.currentTimeMillis() ;
-        if (isSendAllSessions()) {
-            sendSessions(sender, currentSessions, findSessionTimestamp);
-        } else {
-            // send session at blocks
-            int len = currentSessions.length < getSendAllSessionsSize() ? currentSessions.length : getSendAllSessionsSize();
-            Session[] sendSessions = new Session[len];
-            for (int i = 0; i < currentSessions.length; i += getSendAllSessionsSize()) {
-                len = i + getSendAllSessionsSize() > currentSessions.length ? currentSessions.length - i : getSendAllSessionsSize();
-                System.arraycopy(currentSessions, i, sendSessions, 0, len);
-                sendSessions(sender, sendSessions,findSessionTimestamp);
-                if (getSendAllSessionsWaitTime() > 0) {
-                    try {
-                        Thread.sleep(getSendAllSessionsWaitTime());
-                    } catch (Exception sleep) {
-                    }
-                }//end if
-            }//for
-        }//end if
-        
-        SessionMessage newmsg = new SessionMessageImpl(name,SessionMessage.EVT_ALL_SESSION_TRANSFERCOMPLETE, null,"SESSION-STATE-TRANSFERED", "SESSION-STATE-TRANSFERED"+ getName());
-        newmsg.setTimestamp(findSessionTimestamp);
-        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.createMessage.allSessionTransfered",getName()));
-        counterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE++;
-        cluster.send(newmsg, sender);
-    }
-
-
-    /**
-     * send a block of session to sender
-     * @param sender
-     * @param currentSessions
-     * @param sendTimestamp
-     * @throws IOException
-     */
-    protected void sendSessions(Member sender, Session[] currentSessions,long sendTimestamp) throws IOException {
-        byte[] data = serializeSessions(currentSessions);
-        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.unloadingAfter",getName()));
-        SessionMessage newmsg = new SessionMessageImpl(name,SessionMessage.EVT_ALL_SESSION_DATA, data,"SESSION-STATE", "SESSION-STATE-" + getName());
-        newmsg.setTimestamp(sendTimestamp);
-        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.createMessage.allSessionData",getName()));
-        counterSend_EVT_ALL_SESSION_DATA++;
-        cluster.send(newmsg, sender);
-    }
-
-    public ClusterManager cloneFromTemplate() {
-        DeltaManager result = new DeltaManager();
-        result.name = "Clone-from-"+name;
-        result.cluster = cluster;
-        result.replicationValve = replicationValve;
-        result.maxActiveSessions = maxActiveSessions;
-        result.expireSessionsOnShutdown = expireSessionsOnShutdown;
-        result.notifyListenersOnReplication = notifyListenersOnReplication;
-        result.notifySessionListenersOnReplication = notifySessionListenersOnReplication;
-        result.stateTransferTimeout = stateTransferTimeout;
-        result.sendAllSessions = sendAllSessions;
-        result.sendClusterDomainOnly = sendClusterDomainOnly ;
-        result.sendAllSessionsSize = sendAllSessionsSize;
-        result.sendAllSessionsWaitTime = sendAllSessionsWaitTime ; 
-        result.receiverQueue = receiverQueue ;
-        result.stateTimestampDrop = stateTimestampDrop ;
-        result.stateTransferCreateSendTime = stateTransferCreateSendTime; 
-        return result;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha.session;
+
+import java.beans.PropertyChangeEvent;
+import java.io.BufferedOutputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.Iterator;
+
+import org.apache.catalina.Cluster;
+import org.apache.catalina.Container;
+import org.apache.catalina.Context;
+import org.apache.catalina.Engine;
+import org.apache.catalina.Host;
+import org.apache.catalina.LifecycleException;
+import org.apache.catalina.LifecycleListener;
+import org.apache.catalina.Session;
+import org.apache.catalina.Valve;
+import org.apache.catalina.core.StandardContext;
+import org.apache.catalina.ha.CatalinaCluster;
+import org.apache.catalina.ha.ClusterMessage;
+import org.apache.catalina.ha.tcp.ReplicationValve;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.io.ReplicationStream;
+import org.apache.catalina.util.LifecycleSupport;
+import org.apache.catalina.util.StringManager;
+import org.apache.catalina.ha.ClusterManager;
+
+/**
+ * The DeltaManager manages replicated sessions by only replicating the deltas
+ * in data. For applications written to handle this, the DeltaManager is the
+ * optimal way of replicating data.
+ * 
+ * This code is almost identical to StandardManager with a difference in how it
+ * persists sessions and some modifications to it.
+ * 
+ * <b>IMPLEMENTATION NOTE </b>: Correct behavior of session storing and
+ * reloading depends upon external calls to the <code>start()</code> and
+ * <code>stop()</code> methods of this class at the correct times.
+ * 
+ * @author Filip Hanik
+ * @author Craig R. McClanahan
+ * @author Jean-Francois Arcand
+ * @author Peter Rossbach
+ * @version $Revision: 380100 $ $Date: 2006-02-23 06:08:14 -0600 (Thu, 23 Feb 2006) $
+ */
+
+public class DeltaManager extends ClusterManagerBase{
+
+    // ---------------------------------------------------- Security Classes
+    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(DeltaManager.class);
+
+    /**
+     * The string manager for this package.
+     */
+    protected static StringManager sm = StringManager.getManager(Constants.Package);
+
+    // ----------------------------------------------------- Instance Variables
+
+    /**
+     * The descriptive information about this implementation.
+     */
+    private static final String info = "DeltaManager/2.1";
+
+    /**
+     * Has this component been started yet?
+     */
+    private boolean started = false;
+
+    /**
+     * The descriptive name of this Manager implementation (for logging).
+     */
+    protected static String managerName = "DeltaManager";
+    protected String name = null;
+    protected boolean defaultMode = false;
+    private CatalinaCluster cluster = null;
+
+    /**
+     * cached replication valve cluster container!
+     */
+    private ReplicationValve replicationValve = null ;
+    
+    /**
+     * The lifecycle event support for this component.
+     */
+    protected LifecycleSupport lifecycle = new LifecycleSupport(this);
+
+    /**
+     * The maximum number of active Sessions allowed, or -1 for no limit.
+     */
+    private int maxActiveSessions = -1;
+    private boolean expireSessionsOnShutdown = false;
+    private boolean notifyListenersOnReplication = true;
+    private boolean notifySessionListenersOnReplication = true;
+    private boolean stateTransfered = false ;
+    private int stateTransferTimeout = 60;
+    private boolean sendAllSessions = true;
+    private boolean sendClusterDomainOnly = true ;
+    private int sendAllSessionsSize = 1000 ;
+    
+    /**
+     * wait time between send session block (default 2 sec) 
+     */
+    private int sendAllSessionsWaitTime = 2 * 1000 ; 
+    private ArrayList receivedMessageQueue = new ArrayList() ;
+    private boolean receiverQueue = false ;
+    private boolean stateTimestampDrop = true ;
+    private long stateTransferCreateSendTime; 
+    
+    // ------------------------------------------------------------------ stats attributes
+    
+    int rejectedSessions = 0;
+    private long sessionReplaceCounter = 0 ;
+    long processingTime = 0;
+    private long counterReceive_EVT_GET_ALL_SESSIONS = 0 ;
+    private long counterSend_EVT_ALL_SESSION_DATA = 0 ;
+    private long counterReceive_EVT_ALL_SESSION_DATA = 0 ;
+    private long counterReceive_EVT_SESSION_CREATED = 0 ;
+    private long counterReceive_EVT_SESSION_EXPIRED = 0;
+    private long counterReceive_EVT_SESSION_ACCESSED = 0 ;
+    private long counterReceive_EVT_SESSION_DELTA = 0;
+    private long counterSend_EVT_GET_ALL_SESSIONS = 0 ;
+    private long counterSend_EVT_SESSION_CREATED = 0;
+    private long counterSend_EVT_SESSION_DELTA = 0 ;
+    private long counterSend_EVT_SESSION_ACCESSED = 0;
+    private long counterSend_EVT_SESSION_EXPIRED = 0;
+    private int counterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE = 0 ;
+    private int counterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE = 0 ;
+    private int counterNoStateTransfered = 0 ;
+
+
+    // ------------------------------------------------------------- Constructor
+    public DeltaManager() {
+        super();
+    }
+
+    // ------------------------------------------------------------- Properties
+    
+    /**
+     * Return descriptive information about this Manager implementation and the
+     * corresponding version number, in the format
+     * <code>&lt;description&gt;/&lt;version&gt;</code>.
+     */
+    public String getInfo() {
+        return info;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    /**
+     * Return the descriptive short name of this Manager implementation.
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * @return Returns the counterSend_EVT_GET_ALL_SESSIONS.
+     */
+    public long getCounterSend_EVT_GET_ALL_SESSIONS() {
+        return counterSend_EVT_GET_ALL_SESSIONS;
+    }
+    
+    /**
+     * @return Returns the counterSend_EVT_SESSION_ACCESSED.
+     */
+    public long getCounterSend_EVT_SESSION_ACCESSED() {
+        return counterSend_EVT_SESSION_ACCESSED;
+    }
+    
+    /**
+     * @return Returns the counterSend_EVT_SESSION_CREATED.
+     */
+    public long getCounterSend_EVT_SESSION_CREATED() {
+        return counterSend_EVT_SESSION_CREATED;
+    }
+
+    /**
+     * @return Returns the counterSend_EVT_SESSION_DELTA.
+     */
+    public long getCounterSend_EVT_SESSION_DELTA() {
+        return counterSend_EVT_SESSION_DELTA;
+    }
+
+    /**
+     * @return Returns the counterSend_EVT_SESSION_EXPIRED.
+     */
+    public long getCounterSend_EVT_SESSION_EXPIRED() {
+        return counterSend_EVT_SESSION_EXPIRED;
+    }
+ 
+    /**
+     * @return Returns the counterSend_EVT_ALL_SESSION_DATA.
+     */
+    public long getCounterSend_EVT_ALL_SESSION_DATA() {
+        return counterSend_EVT_ALL_SESSION_DATA;
+    }
+
+    /**
+     * @return Returns the counterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE.
+     */
+    public int getCounterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE() {
+        return counterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE;
+    }
+ 
+    /**
+     * @return Returns the counterReceive_EVT_ALL_SESSION_DATA.
+     */
+    public long getCounterReceive_EVT_ALL_SESSION_DATA() {
+        return counterReceive_EVT_ALL_SESSION_DATA;
+    }
+    
+    /**
+     * @return Returns the counterReceive_EVT_GET_ALL_SESSIONS.
+     */
+    public long getCounterReceive_EVT_GET_ALL_SESSIONS() {
+        return counterReceive_EVT_GET_ALL_SESSIONS;
+    }
+    
+    /**
+     * @return Returns the counterReceive_EVT_SESSION_ACCESSED.
+     */
+    public long getCounterReceive_EVT_SESSION_ACCESSED() {
+        return counterReceive_EVT_SESSION_ACCESSED;
+    }
+    
+    /**
+     * @return Returns the counterReceive_EVT_SESSION_CREATED.
+     */
+    public long getCounterReceive_EVT_SESSION_CREATED() {
+        return counterReceive_EVT_SESSION_CREATED;
+    }
+    
+    /**
+     * @return Returns the counterReceive_EVT_SESSION_DELTA.
+     */
+    public long getCounterReceive_EVT_SESSION_DELTA() {
+        return counterReceive_EVT_SESSION_DELTA;
+    }
+    
+    /**
+     * @return Returns the counterReceive_EVT_SESSION_EXPIRED.
+     */
+    public long getCounterReceive_EVT_SESSION_EXPIRED() {
+        return counterReceive_EVT_SESSION_EXPIRED;
+    }
+    
+    
+    /**
+     * @return Returns the counterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE.
+     */
+    public int getCounterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE() {
+        return counterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE;
+    }
+    
+    /**
+     * @return Returns the processingTime.
+     */
+    public long getProcessingTime() {
+        return processingTime;
+    }
+ 
+    /**
+     * @return Returns the sessionReplaceCounter.
+     */
+    public long getSessionReplaceCounter() {
+        return sessionReplaceCounter;
+    }
+    
+    /**
+     * Number of session creations that failed due to maxActiveSessions
+     * 
+     * @return The count
+     */
+    public int getRejectedSessions() {
+        return rejectedSessions;
+    }
+
+    public void setRejectedSessions(int rejectedSessions) {
+        this.rejectedSessions = rejectedSessions;
+    }
+
+    /**
+     * @return Returns the counterNoStateTransfered.
+     */
+    public int getCounterNoStateTransfered() {
+        return counterNoStateTransfered;
+    }
+    
+    public int getReceivedQueueSize() {
+        return receivedMessageQueue.size() ;
+    }
+    
+    /**
+     * @return Returns the stateTransferTimeout.
+     */
+    public int getStateTransferTimeout() {
+        return stateTransferTimeout;
+    }
+    /**
+     * @param timeoutAllSession The timeout
+     */
+    public void setStateTransferTimeout(int timeoutAllSession) {
+        this.stateTransferTimeout = timeoutAllSession;
+    }
+
+    /**
+     * is session state transfered complete?
+     * 
+     */
+    public boolean getStateTransfered() {
+        return stateTransfered;
+    }
+
+    /**
+     * set that state ist complete transfered  
+     * @param stateTransfered
+     */
+    public void setStateTransfered(boolean stateTransfered) {
+        this.stateTransfered = stateTransfered;
+    }
+    
+    /**
+     * @return Returns the sendAllSessionsWaitTime in msec
+     */
+    public int getSendAllSessionsWaitTime() {
+        return sendAllSessionsWaitTime;
+    }
+    
+    /**
+     * @param sendAllSessionsWaitTime The sendAllSessionsWaitTime to set at msec.
+     */
+    public void setSendAllSessionsWaitTime(int sendAllSessionsWaitTime) {
+        this.sendAllSessionsWaitTime = sendAllSessionsWaitTime;
+    }
+    
+    /**
+     * @return Returns the sendClusterDomainOnly.
+     */
+    public boolean doDomainReplication() {
+        return sendClusterDomainOnly;
+    }
+    
+    /**
+     * @param sendClusterDomainOnly The sendClusterDomainOnly to set.
+     */
+    public void setDomainReplication(boolean sendClusterDomainOnly) {
+        this.sendClusterDomainOnly = sendClusterDomainOnly;
+    }
+
+    /**
+     * @return Returns the stateTimestampDrop.
+     */
+    public boolean isStateTimestampDrop() {
+        return stateTimestampDrop;
+    }
+    
+    /**
+     * @param isTimestampDrop The new flag value
+     */
+    public void setStateTimestampDrop(boolean isTimestampDrop) {
+        this.stateTimestampDrop = isTimestampDrop;
+    }
+    
+    /**
+     * Return the maximum number of active Sessions allowed, or -1 for no limit.
+     */
+    public int getMaxActiveSessions() {
+        return (this.maxActiveSessions);
+    }
+
+    /**
+     * Set the maximum number of actives Sessions allowed, or -1 for no limit.
+     * 
+     * @param max
+     *            The new maximum number of sessions
+     */
+    public void setMaxActiveSessions(int max) {
+        int oldMaxActiveSessions = this.maxActiveSessions;
+        this.maxActiveSessions = max;
+        support.firePropertyChange("maxActiveSessions", new Integer(oldMaxActiveSessions), new Integer(this.maxActiveSessions));
+    }
+    
+    /**
+     * 
+     * @return Returns the sendAllSessions.
+     */
+    public boolean isSendAllSessions() {
+        return sendAllSessions;
+    }
+    
+    /**
+     * @param sendAllSessions The sendAllSessions to set.
+     */
+    public void setSendAllSessions(boolean sendAllSessions) {
+        this.sendAllSessions = sendAllSessions;
+    }
+    
+    /**
+     * @return Returns the sendAllSessionsSize.
+     */
+    public int getSendAllSessionsSize() {
+        return sendAllSessionsSize;
+    }
+    
+    /**
+     * @param sendAllSessionsSize The sendAllSessionsSize to set.
+     */
+    public void setSendAllSessionsSize(int sendAllSessionsSize) {
+        this.sendAllSessionsSize = sendAllSessionsSize;
+    }
+    
+    /**
+     * @return Returns the notifySessionListenersOnReplication.
+     */
+    public boolean isNotifySessionListenersOnReplication() {
+        return notifySessionListenersOnReplication;
+    }
+    
+    /**
+     * @param notifyListenersCreateSessionOnReplication The notifySessionListenersOnReplication to set.
+     */
+    public void setNotifySessionListenersOnReplication(boolean notifyListenersCreateSessionOnReplication) {
+        this.notifySessionListenersOnReplication = notifyListenersCreateSessionOnReplication;
+    }
+    
+    
+    public boolean isExpireSessionsOnShutdown() {
+        return expireSessionsOnShutdown;
+    }
+
+    public void setExpireSessionsOnShutdown(boolean expireSessionsOnShutdown) {
+        this.expireSessionsOnShutdown = expireSessionsOnShutdown;
+    }
+    
+    public boolean isNotifyListenersOnReplication() {
+        return notifyListenersOnReplication;
+    }
+
+    public void setNotifyListenersOnReplication(boolean notifyListenersOnReplication) {
+        this.notifyListenersOnReplication = notifyListenersOnReplication;
+    }
+
+    
+    /**
+     * @return Returns the defaultMode.
+     */
+    public boolean isDefaultMode() {
+        return defaultMode;
+    }
+    /**
+     * @param defaultMode The defaultMode to set.
+     */
+    public void setDefaultMode(boolean defaultMode) {
+        this.defaultMode = defaultMode;
+    }
+    
+    public CatalinaCluster getCluster() {
+        return cluster;
+    }
+
+    public void setCluster(CatalinaCluster cluster) {
+        this.cluster = cluster;
+    }
+
+    /**
+     * Set the Container with which this Manager has been associated. If it is a
+     * Context (the usual case), listen for changes to the session timeout
+     * property.
+     * 
+     * @param container
+     *            The associated Container
+     */
+    public void setContainer(Container container) {
+        // De-register from the old Container (if any)
+        if ((this.container != null) && (this.container instanceof Context))
+            ((Context) this.container).removePropertyChangeListener(this);
+
+        // Default processing provided by our superclass
+        super.setContainer(container);
+
+        // Register with the new Container (if any)
+        if ((this.container != null) && (this.container instanceof Context)) {
+            setMaxInactiveInterval(((Context) this.container).getSessionTimeout() * 60);
+            ((Context) this.container).addPropertyChangeListener(this);
+        }
+
+    }
+    
+    // --------------------------------------------------------- Public Methods
+
+    /**
+     * Construct and return a new session object, based on the default settings
+     * specified by this Manager's properties. The session id will be assigned
+     * by this method, and available via the getId() method of the returned
+     * session. If a new session cannot be created for any reason, return
+     * <code>null</code>.
+     * 
+     * @exception IllegalStateException
+     *                if a new session cannot be instantiated for any reason
+     * 
+     * Construct and return a new session object, based on the default settings
+     * specified by this Manager's properties. The session id will be assigned
+     * by this method, and available via the getId() method of the returned
+     * session. If a new session cannot be created for any reason, return
+     * <code>null</code>.
+     * 
+     * @exception IllegalStateException
+     *                if a new session cannot be instantiated for any reason
+     */
+    public Session createSession(String sessionId) {
+        return createSession(sessionId, true);
+    }
+
+    /**
+     * create new session with check maxActiveSessions and send session creation
+     * to other cluster nodes.
+     * 
+     * @param distribute
+     * @return The session
+     */
+    public Session createSession(String sessionId, boolean distribute) {
+        if ((maxActiveSessions >= 0) && (sessions.size() >= maxActiveSessions)) {
+            rejectedSessions++;
+            throw new IllegalStateException(sm.getString("deltaManager.createSession.ise"));
+        }
+        DeltaSession session = (DeltaSession) super.createSession(sessionId) ;
+        if (distribute) {
+            sendCreateSession(session.getId(), session);
+        }
+        if (log.isDebugEnabled())
+            log.debug(sm.getString("deltaManager.createSession.newSession",session.getId(), new Integer(sessions.size())));
+        return (session);
+
+    }
+
+    /**
+     * Send create session evt to all backup node
+     * @param sessionId
+     * @param session
+     */
+    protected void sendCreateSession(String sessionId, DeltaSession session) {
+        if(cluster.getMembers().length > 0 ) {
+            SessionMessage msg = 
+                new SessionMessageImpl(getName(),
+                                       SessionMessage.EVT_SESSION_CREATED, 
+                                       null, 
+                                       sessionId,
+                                       sessionId + "-" + System.currentTimeMillis());
+            if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.sendMessage.newSession",name, sessionId));
+            msg.setTimestamp(session.getCreationTime());
+            counterSend_EVT_SESSION_CREATED++;
+            send(msg);
+        }
+    }
+    
+    /**
+     * Send messages to other backup member (domain or all)
+     * @param msg Session message
+     */
+    protected void send(SessionMessage msg) {
+        if(cluster != null) {
+            if(doDomainReplication())
+                cluster.sendClusterDomain(msg);
+            else
+                cluster.send(msg);
+        }
+    }
+
+    /**
+     * Create DeltaSession
+     * @see org.apache.catalina.Manager#createEmptySession()
+     */
+    public Session createEmptySession() {
+        return getNewDeltaSession() ;
+    }
+    
+    /**
+     * Get new session class to be used in the doLoad() method.
+     */
+    protected DeltaSession getNewDeltaSession() {
+        return new DeltaSession(this);
+    }
+
+    /**
+     * Load Deltarequest from external node
+     * Load the Class at container classloader
+     * @see DeltaRequest#readExternal(java.io.ObjectInput)
+     * @param session
+     * @param data message data
+     * @return The request
+     * @throws ClassNotFoundException
+     * @throws IOException
+     */
+    protected DeltaRequest deserializeDeltaRequest(DeltaSession session, byte[] data) throws ClassNotFoundException, IOException {
+        ReplicationStream ois = getReplicationStream(data);
+        session.getDeltaRequest().readExternal(ois);
+        ois.close();
+        return session.getDeltaRequest();
+    }
+
+    /**
+     * serialize DeltaRequest
+     * @see DeltaRequest#writeExternal(java.io.ObjectOutput)
+     * 
+     * @param deltaRequest
+     * @return serialized delta request
+     * @throws IOException
+     */
+    protected byte[] serializeDeltaRequest(DeltaRequest deltaRequest) throws IOException {
+        return deltaRequest.serialize();
+    }
+
+    /**
+     * Load sessions from other cluster node.
+     * FIXME replace currently sessions with same id without notifcation.
+     * FIXME SSO handling is not really correct with the session replacement!
+     * @exception ClassNotFoundException
+     *                if a serialized class cannot be found during the reload
+     * @exception IOException
+     *                if an input/output error occurs
+     */
+    protected void deserializeSessions(byte[] data) throws ClassNotFoundException,IOException {
+
+        // Initialize our internal data structures
+        //sessions.clear(); //should not do this
+        // Open an input stream to the specified pathname, if any
+        ClassLoader originalLoader = Thread.currentThread().getContextClassLoader();
+        ObjectInputStream ois = null;
+        // Load the previously unloaded active sessions
+        try {
+            ois = getReplicationStream(data);
+            Integer count = (Integer) ois.readObject();
+            int n = count.intValue();
+            for (int i = 0; i < n; i++) {
+                DeltaSession session = (DeltaSession) createEmptySession();
+                session.readObjectData(ois);
+                session.setManager(this);
+                session.setValid(true);
+                session.setPrimarySession(false);
+                //in case the nodes in the cluster are out of
+                //time synch, this will make sure that we have the
+                //correct timestamp, isValid returns true, cause
+                // accessCount=1
+                session.access();
+                //make sure that the session gets ready to expire if
+                // needed
+                session.setAccessCount(0);
+                session.resetDeltaRequest();
+                // FIXME How inform other session id cache like SingleSignOn
+                // increment sessionCounter to correct stats report
+                if (findSession(session.getIdInternal()) == null ) {
+                    sessionCounter++;
+                } else {
+                    sessionReplaceCounter++;
+                    // FIXME better is to grap this sessions again !
+                    if (log.isWarnEnabled()) log.warn(sm.getString("deltaManager.loading.existing.session",session.getIdInternal()));
+                }
+                add(session);
+            }
+        } catch (ClassNotFoundException e) {
+            log.error(sm.getString("deltaManager.loading.cnfe", e), e);
+            throw e;
+        } catch (IOException e) {
+            log.error(sm.getString("deltaManager.loading.ioe", e), e);
+            throw e;
+        } finally {
+            // Close the input stream
+            try {
+                if (ois != null) ois.close();
+            } catch (IOException f) {
+                // ignored
+            }
+            ois = null;
+            if (originalLoader != null) Thread.currentThread().setContextClassLoader(originalLoader);
+        }
+
+    }
+
+    
+
+    /**
+     * Save any currently active sessions in the appropriate persistence
+     * mechanism, if any. If persistence is not supported, this method returns
+     * without doing anything.
+     * 
+     * @exception IOException
+     *                if an input/output error occurs
+     */
+    protected byte[] serializeSessions(Session[] currentSessions) throws IOException {
+
+        // Open an output stream to the specified pathname, if any
+        ByteArrayOutputStream fos = null;
+        ObjectOutputStream oos = null;
+
+        try {
+            fos = new ByteArrayOutputStream();
+            oos = new ObjectOutputStream(new BufferedOutputStream(fos));
+            oos.writeObject(new Integer(currentSessions.length));
+            for(int i=0 ; i < currentSessions.length;i++) {
+                ((DeltaSession)currentSessions[i]).writeObjectData(oos);                
+            }
+            // Flush and close the output stream
+            oos.flush();
+        } catch (IOException e) {
+            log.error(sm.getString("deltaManager.unloading.ioe", e), e);
+            throw e;
+        } finally {
+            if (oos != null) {
+                try {
+                    oos.close();
+                } catch (IOException f) {
+                    ;
+                }
+                oos = null;
+            }
+        }
+        // send object data as byte[]
+        return fos.toByteArray();
+    }
+
+    // ------------------------------------------------------ Lifecycle Methods
+
+    /**
+     * Add a lifecycle event listener to this component.
+     * 
+     * @param listener
+     *            The listener to add
+     */
+    public void addLifecycleListener(LifecycleListener listener) {
+        lifecycle.addLifecycleListener(listener);
+    }
+
+    /**
+     * Get the lifecycle listeners associated with this lifecycle. If this
+     * Lifecycle has no listeners registered, a zero-length array is returned.
+     */
+    public LifecycleListener[] findLifecycleListeners() {
+        return lifecycle.findLifecycleListeners();
+    }
+
+    /**
+     * Remove a lifecycle event listener from this component.
+     * 
+     * @param listener
+     *            The listener to remove
+     */
+    public void removeLifecycleListener(LifecycleListener listener) {
+        lifecycle.removeLifecycleListener(listener);
+    }
+
+    /**
+     * Prepare for the beginning of active use of the public methods of this
+     * component. This method should be called after <code>configure()</code>,
+     * and before any of the public methods of the component are utilized.
+     * 
+     * @exception LifecycleException
+     *                if this component detects a fatal error that prevents this
+     *                component from being used
+     */
+    public void start() throws LifecycleException {
+        if (!initialized) init();
+
+        // Validate and update our current component state
+        if (started) {
+            return;
+        }
+        started = true;
+        lifecycle.fireLifecycleEvent(START_EVENT, null);
+
+        // Force initialization of the random number generator
+        generateSessionId();
+
+        // Load unloaded sessions, if any
+        try {
+            //the channel is already running
+            Cluster cluster = getCluster() ;
+            // stop remove cluster binding
+            //wow, how many nested levels of if statements can we have ;)
+            if(cluster == null) {
+                Container context = getContainer() ;
+                if(context != null && context instanceof Context) {
+                     Container host = context.getParent() ;
+                     if(host != null && host instanceof Host) {
+                         cluster = host.getCluster();
+                         if(cluster != null && cluster instanceof CatalinaCluster) {
+                             setCluster((CatalinaCluster) cluster) ;
+                         } else {
+                             Container engine = host.getParent() ;
+                             if(engine != null && engine instanceof Engine) {
+                                 cluster = engine.getCluster();
+                                 if(cluster != null && cluster instanceof CatalinaCluster) {
+                                     setCluster((CatalinaCluster) cluster) ;
+                                 }
+                             } else {
+                                     cluster = null ;
+                             }
+                         }
+                     }
+                }
+            }
+            if (cluster == null) {
+                log.error(sm.getString("deltaManager.noCluster", getName()));
+                return;
+            } else {
+                if (log.isInfoEnabled()) {
+                    String type = "unknown" ;
+                    if( cluster.getContainer() instanceof Host){
+                        type = "Host" ;
+                    } else if( cluster.getContainer() instanceof Engine){
+                        type = "Engine" ;
+                    }
+                    log.info(sm.getString("deltaManager.registerCluster", getName(), type, cluster.getClusterName()));
+                }
+            }
+            if (log.isInfoEnabled()) log.info(sm.getString("deltaManager.startClustering", getName()));
+            //to survice context reloads, as only a stop/start is called, not
+            // createManager
+            cluster.registerManager(this);
+
+            getAllClusterSessions();
+
+        } catch (Throwable t) {
+            log.error(sm.getString("deltaManager.managerLoad"), t);
+        }
+    }
+
+    /**
+     * get from first session master the backup from all clustered sessions
+     * @see #findSessionMasterMember()
+     */
+    public synchronized void getAllClusterSessions() {
+        if (cluster != null && cluster.getMembers().length > 0) {
+            long beforeSendTime = System.currentTimeMillis();
+            Member mbr = findSessionMasterMember();
+            if(mbr == null) { // No domain member found
+                 return;
+            }
+            SessionMessage msg = new SessionMessageImpl(this.getName(),SessionMessage.EVT_GET_ALL_SESSIONS, null, "GET-ALL","GET-ALL-" + getName());
+            // set reference time
+            stateTransferCreateSendTime = beforeSendTime ;
+            // request session state
+            counterSend_EVT_GET_ALL_SESSIONS++;
+            stateTransfered = false ;
+            // FIXME This send call block the deploy thread, when sender waitForAck is enabled
+            try {
+                synchronized(receivedMessageQueue) {
+                     receiverQueue = true ;
+                }
+                cluster.send(msg, mbr);
+                if (log.isWarnEnabled()) log.warn(sm.getString("deltaManager.waitForSessionState",getName(), mbr));
+                // FIXME At sender ack mode this method check only the state transfer and resend is a problem!
+                waitForSendAllSessions(beforeSendTime);
+            } finally {
+                synchronized(receivedMessageQueue) {
+                    for (Iterator iter = receivedMessageQueue.iterator(); iter.hasNext();) {
+                        SessionMessage smsg = (SessionMessage) iter.next();
+                        if (!stateTimestampDrop) {
+                            messageReceived(smsg, smsg.getAddress() != null ? (Member) smsg.getAddress() : null);
+                        } else {
+                            if (smsg.getEventType() != SessionMessage.EVT_GET_ALL_SESSIONS && smsg.getTimestamp() >= stateTransferCreateSendTime) {
+                                // FIXME handle EVT_GET_ALL_SESSIONS later
+                                messageReceived(smsg,smsg.getAddress() != null ? (Member) smsg.getAddress() : null);
+                            } else {
+                                if (log.isWarnEnabled()) {
+                                    log.warn(sm.getString("deltaManager.dropMessage",getName(), smsg.getEventTypeString(),new Date(stateTransferCreateSendTime), new Date(smsg.getTimestamp())));
+                                }
+                            }
+                        }
+                    }        
+                    receivedMessageQueue.clear();
+                    receiverQueue = false ;
+                }
+           }
+        } else {
+            if (log.isInfoEnabled()) log.info(sm.getString("deltaManager.noMembers", getName()));
+        }
+    }
+
+    /**
+     * Register cross context session at replication valve thread local
+     * @param session cross context session
+     */
+    protected void registerSessionAtReplicationValve(DeltaSession session) {
+        if(replicationValve == null) {
+            if(container instanceof StandardContext && ((StandardContext)container).getCrossContext()) {
+                Cluster cluster = getCluster() ;
+                if(cluster != null && cluster instanceof CatalinaCluster) {
+                    Valve[] valves = ((CatalinaCluster)cluster).getValves();
+                    if(valves != null && valves.length > 0) {
+                        for(int i=0; replicationValve == null && i < valves.length ; i++ ){
+                            if(valves[i] instanceof ReplicationValve) replicationValve = (ReplicationValve)valves[i] ;
+                        }//for
+
+                        if(replicationValve == null && log.isDebugEnabled()) {
+                            log.debug("no ReplicationValve found for CrossContext Support");
+                        }//endif 
+                    }//end if
+                }//endif
+            }//end if
+        }//end if
+        if(replicationValve != null) {
+            replicationValve.registerReplicationSession(session);
+        }
+    }
+    
+    /**
+     * Find the master of the session state
+     * @return master member of sessions 
+     */
+    protected Member findSessionMasterMember() {
+        Member mbr = null;
+        Member mbrs[] = cluster.getMembers();
+        if(mbrs.length != 0 ) mbr = mbrs[0];
+        if(mbr == null && log.isWarnEnabled()) log.warn(sm.getString("deltaManager.noMasterMember",getName(), ""));
+        if(mbr != null && log.isDebugEnabled()) log.warn(sm.getString("deltaManager.foundMasterMember",getName(), mbr));
+        return mbr;
+    }
+
+    /**
+     * Wait that cluster session state is transfer or timeout after 60 Sec
+     * With stateTransferTimeout == -1 wait that backup is transfered (forever mode)
+     */
+    protected void waitForSendAllSessions(long beforeSendTime) {
+        long reqStart = System.currentTimeMillis();
+        long reqNow = reqStart ;
+        boolean isTimeout = false;
+        if(getStateTransferTimeout() > 0) {
+            // wait that state is transfered with timeout check
+            do {
+                try {
+                    Thread.sleep(100);
+                } catch (Exception sleep) {
+                    //
+                }
+                reqNow = System.currentTimeMillis();
+                isTimeout = ((reqNow - reqStart) > (1000 * getStateTransferTimeout()));
+            } while ((!getStateTransfered()) && (!isTimeout));
+        } else {
+            if(getStateTransferTimeout() == -1) {
+                // wait that state is transfered
+                do {
+                    try {
+                        Thread.sleep(100);
+                    } catch (Exception sleep) {
+                    }
+                } while ((!getStateTransfered()));
+                reqNow = System.currentTimeMillis();
+            }
+        }
+        if (isTimeout || (!getStateTransfered())) {
+            counterNoStateTransfered++ ;
+            log.error(sm.getString("deltaManager.noSessionState",getName(),new Date(beforeSendTime),new Long(reqNow - beforeSendTime)));
+        } else {
+            if (log.isInfoEnabled())
+                log.info(sm.getString("deltaManager.sessionReceived",getName(), new Date(beforeSendTime), new Long(reqNow - beforeSendTime)));
+        }
+    }
+
+    /**
+     * Gracefully terminate the active use of the public methods of this
+     * component. This method should be the last one called on a given instance
+     * of this component.
+     * 
+     * @exception LifecycleException
+     *                if this component detects a fatal error that needs to be
+     *                reported
+     */
+    public void stop() throws LifecycleException {
+
+        if (log.isDebugEnabled())
+            log.debug(sm.getString("deltaManager.stopped", getName()));
+
+
+        // Validate and update our current component state
+        if (!started)
+            throw new LifecycleException(sm.getString("deltaManager.notStarted"));
+        lifecycle.fireLifecycleEvent(STOP_EVENT, null);
+        started = false;
+
+        // Expire all active sessions
+        if (log.isInfoEnabled()) log.info(sm.getString("deltaManager.expireSessions", getName()));
+        Session sessions[] = findSessions();
+        for (int i = 0; i < sessions.length; i++) {
+            DeltaSession session = (DeltaSession) sessions[i];
+            if (!session.isValid())
+                continue;
+            try {
+                session.expire(true, isExpireSessionsOnShutdown());
+            } catch (Throwable ignore) {
+                ;
+            } 
+        }
+
+        // Require a new random number generator if we are restarted
+        this.random = null;
+        getCluster().removeManager(this);
+        replicationValve = null;
+        if (initialized) {
+            destroy();
+        }
+    }
+
+    // ----------------------------------------- PropertyChangeListener Methods
+
+    /**
+     * Process property change events from our associated Context.
+     * 
+     * @param event
+     *            The property change event that has occurred
+     */
+    public void propertyChange(PropertyChangeEvent event) {
+
+        // Validate the source of this event
+        if (!(event.getSource() instanceof Context))
+            return;
+        // Process a relevant property change
+        if (event.getPropertyName().equals("sessionTimeout")) {
+            try {
+                setMaxInactiveInterval(((Integer) event.getNewValue()).intValue() * 60);
+            } catch (NumberFormatException e) {
+                log.error(sm.getString("deltaManager.sessionTimeout", event.getNewValue()));
+            }
+        }
+
+    }
+
+    // -------------------------------------------------------- Replication
+    // Methods
+
+    /**
+     * A message was received from another node, this is the callback method to
+     * implement if you are interested in receiving replication messages.
+     * 
+     * @param cmsg -
+     *            the message received.
+     */
+    public void messageDataReceived(ClusterMessage cmsg) {
+        if (cmsg != null && cmsg instanceof SessionMessage) {
+            SessionMessage msg = (SessionMessage) cmsg;
+            switch (msg.getEventType()) {
+                case SessionMessage.EVT_GET_ALL_SESSIONS:
+                case SessionMessage.EVT_SESSION_CREATED: 
+                case SessionMessage.EVT_SESSION_EXPIRED: 
+                case SessionMessage.EVT_SESSION_ACCESSED:
+                case SessionMessage.EVT_SESSION_DELTA: {
+                    synchronized(receivedMessageQueue) {
+                        if(receiverQueue) {
+                            receivedMessageQueue.add(msg);
+                            return ;
+                        }
+                    }
+                   break;
+                }
+                default: {
+                    //we didn't queue, do nothing
+                    break;
+                }
+            } //switch
+            
+            messageReceived(msg, msg.getAddress() != null ? (Member) msg.getAddress() : null);
+        }
+    }
+
+    /**
+     * When the request has been completed, the replication valve will notify
+     * the manager, and the manager will decide whether any replication is
+     * needed or not. If there is a need for replication, the manager will
+     * create a session message and that will be replicated. The cluster
+     * determines where it gets sent.
+     * 
+     * @param sessionId -
+     *            the sessionId that just completed.
+     * @return a SessionMessage to be sent,
+     */
+    public ClusterMessage requestCompleted(String sessionId) {
+        try {
+            DeltaSession session = (DeltaSession) findSession(sessionId);
+            DeltaRequest deltaRequest = session.getDeltaRequest();
+            SessionMessage msg = null;
+            boolean isDeltaRequest = false ;
+            synchronized(deltaRequest) {
+                isDeltaRequest = deltaRequest.getSize() > 0 ;
+                if (isDeltaRequest) {    
+                    counterSend_EVT_SESSION_DELTA++;
+                    byte[] data = serializeDeltaRequest(deltaRequest);
+                    msg = new SessionMessageImpl(getName(),
+                                                 SessionMessage.EVT_SESSION_DELTA, 
+                                                 data, 
+                                                 sessionId,
+                                                 sessionId + "-" + System.currentTimeMillis());
+                    session.resetDeltaRequest();
+                }  
+            }
+            if(!isDeltaRequest) {
+                if(!session.isPrimarySession()) {               
+                    counterSend_EVT_SESSION_ACCESSED++;
+                    msg = new SessionMessageImpl(getName(),
+                                                 SessionMessage.EVT_SESSION_ACCESSED, 
+                                                 null, 
+                                                 sessionId,
+                                                 sessionId + "-" + System.currentTimeMillis());
+                    if (log.isDebugEnabled()) {
+                        log.debug(sm.getString("deltaManager.createMessage.accessChangePrimary",getName(), sessionId));
+                    }
+                }    
+            } else { // log only outside synch block!
+                if (log.isDebugEnabled()) {
+                    log.debug(sm.getString("deltaManager.createMessage.delta",getName(), sessionId));
+                }
+            }
+            session.setPrimarySession(true);
+            //check to see if we need to send out an access message
+            if ((msg == null)) {
+                long replDelta = System.currentTimeMillis() - session.getLastTimeReplicated();
+                if (replDelta > (getMaxInactiveInterval() * 1000)) {
+                    counterSend_EVT_SESSION_ACCESSED++;
+                    msg = new SessionMessageImpl(getName(),
+                                                 SessionMessage.EVT_SESSION_ACCESSED, 
+                                                 null,
+                                                 sessionId, 
+                                                 sessionId + "-" + System.currentTimeMillis());
+                    if (log.isDebugEnabled()) {
+                        log.debug(sm.getString("deltaManager.createMessage.access", getName(),sessionId));
+                    }
+                }
+
+            }
+
+            //update last replicated time
+            if (msg != null) session.setLastTimeReplicated(System.currentTimeMillis());
+            return msg;
+        } catch (IOException x) {
+            log.error(sm.getString("deltaManager.createMessage.unableCreateDeltaRequest",sessionId), x);
+            return null;
+        }
+
+    }
+    /**
+     * Reset manager statistics
+     */
+    public synchronized void resetStatistics() {
+        processingTime = 0 ;
+        expiredSessions = 0 ;
+        rejectedSessions = 0 ;
+        sessionReplaceCounter = 0 ;
+        counterNoStateTransfered = 0 ;
+        maxActive = getActiveSessions() ;
+        sessionCounter = getActiveSessions() ;
+        counterReceive_EVT_ALL_SESSION_DATA = 0;
+        counterReceive_EVT_GET_ALL_SESSIONS = 0;
+        counterReceive_EVT_SESSION_ACCESSED = 0 ;
+        counterReceive_EVT_SESSION_CREATED = 0 ;
+        counterReceive_EVT_SESSION_DELTA = 0 ;
+        counterReceive_EVT_SESSION_EXPIRED = 0 ;
+        counterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE = 0;
+        counterSend_EVT_ALL_SESSION_DATA = 0;
+        counterSend_EVT_GET_ALL_SESSIONS = 0;
+        counterSend_EVT_SESSION_ACCESSED = 0 ;
+        counterSend_EVT_SESSION_CREATED = 0 ;
+        counterSend_EVT_SESSION_DELTA = 0 ;
+        counterSend_EVT_SESSION_EXPIRED = 0 ;
+        counterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE = 0;
+        
+    }
+   
+    //  -------------------------------------------------------- persistence handler
+
+    public void load() {
+
+    }
+
+    public void unload() {
+
+    }
+
+    //  -------------------------------------------------------- expire
+
+    /**
+     * send session expired to other cluster nodes
+     * 
+     * @param id
+     *            session id
+     */
+    protected void sessionExpired(String id) {
+        counterSend_EVT_SESSION_EXPIRED++ ;
+        SessionMessage msg = new SessionMessageImpl(getName(),SessionMessage.EVT_SESSION_EXPIRED, null, id, id+ "-EXPIRED-MSG");
+        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.createMessage.expire",getName(), id));
+        send(msg);
+    }
+
+    /**
+     * Exipre all find sessions.
+     */
+    public void expireAllLocalSessions()
+    {
+        long timeNow = System.currentTimeMillis();
+        Session sessions[] = findSessions();
+        int expireDirect  = 0 ;
+        int expireIndirect = 0 ;
+        
+        if(log.isDebugEnabled()) log.debug("Start expire all sessions " + getName() + " at " + timeNow + " sessioncount " + sessions.length);
+        for (int i = 0; i < sessions.length; i++) {
+            if (sessions[i] instanceof DeltaSession) {
+                DeltaSession session = (DeltaSession) sessions[i];
+                if (session.isPrimarySession()) {
+                    if (session.isValid()) {
+                        session.expire();
+                        expireDirect++;
+                    } else {
+                        expireIndirect++;
+                    }//end if
+                }//end if
+            }//end if
+        }//for
+        long timeEnd = System.currentTimeMillis();
+        if(log.isDebugEnabled()) log.debug("End expire sessions " + getName() + " exipre processingTime " + (timeEnd - timeNow) + " expired direct sessions: " + expireDirect + " expired direct sessions: " + expireIndirect);
+      
+    }
+    
+    /**
+     * When the manager expires session not tied to a request. The cluster will
+     * periodically ask for a list of sessions that should expire and that
+     * should be sent across the wire.
+     * 
+     * @return The invalidated sessions array
+     */
+    public String[] getInvalidatedSessions() {
+        return new String[0];
+    }
+
+    //  -------------------------------------------------------- message receive
+
+    /**
+     * Test that sender and local domain is the same
+     */
+    protected boolean checkSenderDomain(SessionMessage msg,Member sender) {
+        boolean sameDomain= true;
+        if (!sameDomain && log.isWarnEnabled()) {
+                log.warn(sm.getString("deltaManager.receiveMessage.fromWrongDomain",
+                         new Object[] {getName(), 
+                         msg.getEventTypeString(), 
+                         sender,
+                         "",
+                         "" }));
+        }
+        return sameDomain ;
+    }
+
+    /**
+     * This method is called by the received thread when a SessionMessage has
+     * been received from one of the other nodes in the cluster.
+     * 
+     * @param msg -
+     *            the message received
+     * @param sender -
+     *            the sender of the message, this is used if we receive a
+     *            EVT_GET_ALL_SESSION message, so that we only reply to the
+     *            requesting node
+     */
+    protected void messageReceived(SessionMessage msg, Member sender) {
+        if(doDomainReplication() && !checkSenderDomain(msg,sender)) {
+            return;
+        }
+        ClassLoader contextLoader = Thread.currentThread().getContextClassLoader();
+        try {
+            
+            ClassLoader[] loaders = getClassLoaders();
+            if ( loaders != null && loaders.length > 0) Thread.currentThread().setContextClassLoader(loaders[0]);
+            if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.eventType",getName(), msg.getEventTypeString(), sender));
+ 
+            switch (msg.getEventType()) {
+                case SessionMessage.EVT_GET_ALL_SESSIONS: {
+                    handleGET_ALL_SESSIONS(msg,sender);
+                    break;
+                }
+                case SessionMessage.EVT_ALL_SESSION_DATA: {
+                    handleALL_SESSION_DATA(msg,sender);
+                    break;
+                }
+                case SessionMessage.EVT_ALL_SESSION_TRANSFERCOMPLETE: {
+                    handleALL_SESSION_TRANSFERCOMPLETE(msg,sender);
+                    break;
+                }
+                case SessionMessage.EVT_SESSION_CREATED: {
+                    handleSESSION_CREATED(msg,sender);
+                    break;
+                }
+                case SessionMessage.EVT_SESSION_EXPIRED: {
+                    handleSESSION_EXPIRED(msg,sender);
+                    break;
+                }
+                case SessionMessage.EVT_SESSION_ACCESSED: {
+                    handleSESSION_ACCESSED(msg,sender);
+                    break;
+                }
+                case SessionMessage.EVT_SESSION_DELTA: {
+                   handleSESSION_DELTA(msg,sender);
+                   break;
+                }
+                default: {
+                    //we didn't recognize the message type, do nothing
+                    break;
+                }
+            } //switch
+        } catch (Exception x) {
+            log.error(sm.getString("deltaManager.receiveMessage.error",getName()), x);
+        } finally {
+            Thread.currentThread().setContextClassLoader(contextLoader);
+        }
+    }
+
+    // -------------------------------------------------------- message receiver handler
+
+
+    /**
+     * handle receive session state is complete transfered
+     * @param msg
+     * @param sender
+     */
+    protected void handleALL_SESSION_TRANSFERCOMPLETE(SessionMessage msg, Member sender) {
+        counterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE++ ;
+        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.transfercomplete",getName(), sender.getHost(), new Integer(sender.getPort())));
+        stateTransferCreateSendTime = msg.getTimestamp() ;
+        stateTransfered = true ;
+    }
+
+    /**
+     * handle receive session delta
+     * @param msg
+     * @param sender
+     * @throws IOException
+     * @throws ClassNotFoundException
+     */
+    protected void handleSESSION_DELTA(SessionMessage msg, Member sender) throws IOException, ClassNotFoundException {
+        counterReceive_EVT_SESSION_DELTA++;
+        byte[] delta = msg.getSession();
+        DeltaSession session = (DeltaSession) findSession(msg.getSessionID());
+        if (session != null) {
+            if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.delta",getName(), msg.getSessionID()));
+            DeltaRequest dreq = deserializeDeltaRequest(session, delta);
+            dreq.execute(session, notifyListenersOnReplication);
+            session.setPrimarySession(false);
+        }
+    }
+
+    /**
+     * handle receive session is access at other node ( primary session is now false)
+     * @param msg
+     * @param sender
+     * @throws IOException
+     */
+    protected void handleSESSION_ACCESSED(SessionMessage msg,Member sender) throws IOException {
+        counterReceive_EVT_SESSION_ACCESSED++;
+        DeltaSession session = (DeltaSession) findSession(msg.getSessionID());
+        if (session != null) {
+            if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.accessed",getName(), msg.getSessionID()));
+            session.access();
+            session.setPrimarySession(false);
+            session.endAccess();
+        }
+    }
+
+    /**
+     * handle receive session is expire at other node ( expire session also here)
+     * @param msg
+     * @param sender
+     * @throws IOException
+     */
+    protected void handleSESSION_EXPIRED(SessionMessage msg,Member sender) throws IOException {
+        counterReceive_EVT_SESSION_EXPIRED++;
+        DeltaSession session = (DeltaSession) findSession(msg.getSessionID());
+        if (session != null) {
+            if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.expired",getName(), msg.getSessionID()));
+            session.expire(notifySessionListenersOnReplication, false);
+        }
+    }
+
+    /**
+     * handle receive new session is created at other node (create backup - primary false)
+     * @param msg
+     * @param sender
+     */
+    protected void handleSESSION_CREATED(SessionMessage msg,Member sender) {
+        counterReceive_EVT_SESSION_CREATED++;
+        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.createNewSession",getName(), msg.getSessionID()));
+        DeltaSession session = (DeltaSession) createEmptySession();
+        session.setManager(this);
+        session.setValid(true);
+        session.setPrimarySession(false);
+        session.setCreationTime(msg.getTimestamp());
+        session.access();
+        if(notifySessionListenersOnReplication)
+            session.setId(msg.getSessionID());
+        else
+            session.setIdInternal(msg.getSessionID());
+        session.resetDeltaRequest();
+        session.endAccess();
+
+    }
+
+    /**
+     * handle receive sessions from other not ( restart )
+     * @param msg
+     * @param sender
+     * @throws ClassNotFoundException
+     * @throws IOException
+     */
+    protected void handleALL_SESSION_DATA(SessionMessage msg,Member sender) throws ClassNotFoundException, IOException {
+        counterReceive_EVT_ALL_SESSION_DATA++;
+        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.allSessionDataBegin",getName()));
+        byte[] data = msg.getSession();
+        deserializeSessions(data);
+        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.allSessionDataAfter",getName()));
+        //stateTransferred = true;
+    }
+
+    /**
+     * handle receive that other node want all sessions ( restart )
+     * a) send all sessions with one message
+     * b) send session at blocks
+     * After sending send state is complete transfered
+     * @param msg
+     * @param sender
+     * @throws IOException
+     */
+    protected void handleGET_ALL_SESSIONS(SessionMessage msg, Member sender) throws IOException {
+        counterReceive_EVT_GET_ALL_SESSIONS++;
+        //get a list of all the session from this manager
+        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.unloadingBegin", getName()));
+        // Write the number of active sessions, followed by the details
+        // get all sessions and serialize without sync
+        Session[] currentSessions = findSessions();
+        long findSessionTimestamp = System.currentTimeMillis() ;
+        if (isSendAllSessions()) {
+            sendSessions(sender, currentSessions, findSessionTimestamp);
+        } else {
+            // send session at blocks
+            int len = currentSessions.length < getSendAllSessionsSize() ? currentSessions.length : getSendAllSessionsSize();
+            Session[] sendSessions = new Session[len];
+            for (int i = 0; i < currentSessions.length; i += getSendAllSessionsSize()) {
+                len = i + getSendAllSessionsSize() > currentSessions.length ? currentSessions.length - i : getSendAllSessionsSize();
+                System.arraycopy(currentSessions, i, sendSessions, 0, len);
+                sendSessions(sender, sendSessions,findSessionTimestamp);
+                if (getSendAllSessionsWaitTime() > 0) {
+                    try {
+                        Thread.sleep(getSendAllSessionsWaitTime());
+                    } catch (Exception sleep) {
+                    }
+                }//end if
+            }//for
+        }//end if
+        
+        SessionMessage newmsg = new SessionMessageImpl(name,SessionMessage.EVT_ALL_SESSION_TRANSFERCOMPLETE, null,"SESSION-STATE-TRANSFERED", "SESSION-STATE-TRANSFERED"+ getName());
+        newmsg.setTimestamp(findSessionTimestamp);
+        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.createMessage.allSessionTransfered",getName()));
+        counterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE++;
+        cluster.send(newmsg, sender);
+    }
+
+
+    /**
+     * send a block of session to sender
+     * @param sender
+     * @param currentSessions
+     * @param sendTimestamp
+     * @throws IOException
+     */
+    protected void sendSessions(Member sender, Session[] currentSessions,long sendTimestamp) throws IOException {
+        byte[] data = serializeSessions(currentSessions);
+        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.unloadingAfter",getName()));
+        SessionMessage newmsg = new SessionMessageImpl(name,SessionMessage.EVT_ALL_SESSION_DATA, data,"SESSION-STATE", "SESSION-STATE-" + getName());
+        newmsg.setTimestamp(sendTimestamp);
+        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.createMessage.allSessionData",getName()));
+        counterSend_EVT_ALL_SESSION_DATA++;
+        cluster.send(newmsg, sender);
+    }
+
+    public ClusterManager cloneFromTemplate() {
+        DeltaManager result = new DeltaManager();
+        result.name = "Clone-from-"+name;
+        result.cluster = cluster;
+        result.replicationValve = replicationValve;
+        result.maxActiveSessions = maxActiveSessions;
+        result.expireSessionsOnShutdown = expireSessionsOnShutdown;
+        result.notifyListenersOnReplication = notifyListenersOnReplication;
+        result.notifySessionListenersOnReplication = notifySessionListenersOnReplication;
+        result.stateTransferTimeout = stateTransferTimeout;
+        result.sendAllSessions = sendAllSessions;
+        result.sendClusterDomainOnly = sendClusterDomainOnly ;
+        result.sendAllSessionsSize = sendAllSessionsSize;
+        result.sendAllSessionsWaitTime = sendAllSessionsWaitTime ; 
+        result.receiverQueue = receiverQueue ;
+        result.stateTimestampDrop = stateTimestampDrop ;
+        result.stateTransferCreateSendTime = stateTransferCreateSendTime; 
+        return result;
+    }
+}

==================================================
DeltaSession.java
index 9a2c378616..0762255bc1 100644
--- a/java/org/apache/catalina/ha/session/DeltaRequest.java
+++ b/java/org/apache/catalina/ha/session/DeltaRequest.java
@@ -1,386 +1,387 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina.ha.session;
-
-/**
- * This class is used to track the series of actions that happens when
- * a request is executed. These actions will then translate into invokations of methods 
- * on the actual session.
- * This class is NOT thread safe. One DeltaRequest per session
- * @author <a href="mailto:fhanik@apache.org">Filip Hanik</a>
- * @version 1.0
- */
-
-import java.io.Externalizable;
-import java.security.Principal;
-import java.util.LinkedList;
-
-import org.apache.catalina.realm.GenericPrincipal;
-import org.apache.catalina.util.StringManager;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.ObjectOutputStream;
-
-
-public class DeltaRequest implements Externalizable {
-
-    public static org.apache.juli.logging.Log log =
-        org.apache.juli.logging.LogFactory.getLog( DeltaRequest.class );
-
-    /**
-     * The string manager for this package.
-     */
-    protected static StringManager sm = StringManager
-            .getManager(Constants.Package);
-
-    public static final int TYPE_ATTRIBUTE = 0;
-    public static final int TYPE_PRINCIPAL = 1;
-    public static final int TYPE_ISNEW = 2;
-    public static final int TYPE_MAXINTERVAL = 3;
-
-    public static final int ACTION_SET = 0;
-    public static final int ACTION_REMOVE = 1;
-
-    public static final String NAME_PRINCIPAL = "__SET__PRINCIPAL__";
-    public static final String NAME_MAXINTERVAL = "__SET__MAXINTERVAL__";
-    public static final String NAME_ISNEW = "__SET__ISNEW__";
-
-    private String sessionId;
-    private LinkedList actions = new LinkedList();
-    private LinkedList actionPool = new LinkedList();
-    
-    private boolean recordAllActions = false;
-
-    public DeltaRequest() {
-        
-    }
-    
-    public DeltaRequest(String sessionId, boolean recordAllActions) {
-        this.recordAllActions=recordAllActions;
-        if(sessionId != null)
-            setSessionId(sessionId);
-    }
-
-
-    public void setAttribute(String name, Object value) {
-        int action = (value==null)?ACTION_REMOVE:ACTION_SET;
-        addAction(TYPE_ATTRIBUTE,action,name,value);
-    }
-
-    public void removeAttribute(String name) {
-        int action = ACTION_REMOVE;
-        addAction(TYPE_ATTRIBUTE,action,name,null);
-    }
-
-    public void setMaxInactiveInterval(int interval) {
-        int action = ACTION_SET;
-        addAction(TYPE_MAXINTERVAL,action,NAME_MAXINTERVAL,new Integer(interval));
-    }
-    
-    /**
-     * convert principal at SerializablePrincipal for backup nodes.
-     * Only support principals from type {@link GenericPrincipal GenericPrincipal}
-     * @param p Session principal
-     * @see GenericPrincipal
-     */
-    public void setPrincipal(Principal p) {
-        int action = (p==null)?ACTION_REMOVE:ACTION_SET;
-        SerializablePrincipal sp = null;
-        if ( p != null ) {
-            if(p instanceof GenericPrincipal) {
-                sp = SerializablePrincipal.createPrincipal((GenericPrincipal)p);
-                if(log.isDebugEnabled())
-                    log.debug(sm.getString("deltaRequest.showPrincipal", p.getName() , getSessionId()));
-            } else
-                log.error(sm.getString("deltaRequest.wrongPrincipalClass",p.getClass().getName()));
-        }
-        addAction(TYPE_PRINCIPAL,action,NAME_PRINCIPAL,sp);
-    }
-
-    public void setNew(boolean n) {
-        int action = ACTION_SET;
-        addAction(TYPE_ISNEW,action,NAME_ISNEW,new Boolean(n));
-    }
-
-    protected synchronized void addAction(int type,
-                             int action,
-                             String name,
-                             Object value) {
-        AttributeInfo info = null;
-        if ( this.actionPool.size() > 0 ) {
-            try {
-                info = (AttributeInfo) actionPool.removeFirst();
-            }catch ( Exception x ) {
-                log.error("Unable to remove element:",x);
-                info = new AttributeInfo(type, action, name, value);
-            }
-            info.init(type,action,name,value);
-        } else {
-            info = new AttributeInfo(type, action, name, value);
-        }
-        //if we have already done something to this attribute, make sure
-        //we don't send multiple actions across the wire
-        if ( !recordAllActions) {
-            try {
-                actions.remove(info);
-            } catch (java.util.NoSuchElementException x) {
-                //do nothing, we wanted to remove it anyway
-            }
-        }
-        //add the action
-        actions.addLast(info);
-    }
-    
-    public void execute(DeltaSession session) {
-        execute(session,true);
-    }
-
-    public synchronized void execute(DeltaSession session, boolean notifyListeners) {
-        if ( !this.sessionId.equals( session.getId() ) )
-            throw new java.lang.IllegalArgumentException("Session id mismatch, not executing the delta request");
-        session.access();
-        for ( int i=0; i<actions.size(); i++ ) {
-            AttributeInfo info = (AttributeInfo)actions.get(i);
-            switch ( info.getType() ) {
-                case TYPE_ATTRIBUTE: {
-                    if ( info.getAction() == ACTION_SET ) {
-                        if ( log.isTraceEnabled() ) log.trace("Session.setAttribute('"+info.getName()+"', '"+info.getValue()+"')");
-                        session.setAttribute(info.getName(), info.getValue(),notifyListeners,false);
-                    }  else {
-                        if ( log.isTraceEnabled() ) log.trace("Session.removeAttribute('"+info.getName()+"')");
-                        session.removeAttribute(info.getName(),notifyListeners,false);
-                    }
-                        
-                    break;
-                }//case
-                case TYPE_ISNEW: {
-                if ( log.isTraceEnabled() ) log.trace("Session.setNew('"+info.getValue()+"')");
-                    session.setNew(((Boolean)info.getValue()).booleanValue(),false);
-                    break;
-                }//case
-                case TYPE_MAXINTERVAL: {
-                    if ( log.isTraceEnabled() ) log.trace("Session.setMaxInactiveInterval('"+info.getValue()+"')");
-                    session.setMaxInactiveInterval(((Integer)info.getValue()).intValue(),false);
-                    break;
-                }//case
-                case TYPE_PRINCIPAL: {
-                    Principal p = null;
-                    if ( info.getAction() == ACTION_SET ) {
-                        SerializablePrincipal sp = (SerializablePrincipal)info.getValue();
-                        p = (Principal)sp.getPrincipal(session.getManager().getContainer().getRealm());
-                    }
-                    session.setPrincipal(p,false);
-                    break;
-                }//case
-                default : throw new java.lang.IllegalArgumentException("Invalid attribute info type="+info);
-            }//switch
-        }//for
-        session.endAccess();
-        reset();
-    }
-
-    public synchronized void reset() {
-        while ( actions.size() > 0 ) {
-            try {
-                AttributeInfo info = (AttributeInfo) actions.removeFirst();
-                info.recycle();
-                actionPool.addLast(info);
-            }catch  ( Exception x ) {
-                log.error("Unable to remove element",x);
-            }
-        }
-        actions.clear();
-    }
-    
-    public String getSessionId() {
-        return sessionId;
-    }
-    public void setSessionId(String sessionId) {
-        this.sessionId = sessionId;
-        if ( sessionId == null ) {
-            new Exception("Session Id is null for setSessionId").fillInStackTrace().printStackTrace();
-        }
-    }
-    public int getSize() {
-        return actions.size();
-    }
-    
-    public synchronized void clear() {
-        actions.clear();
-        actionPool.clear();
-    }
-    
-    public synchronized void readExternal(java.io.ObjectInput in) throws IOException,ClassNotFoundException {
-        //sessionId - String
-        //recordAll - boolean
-        //size - int
-        //AttributeInfo - in an array
-        reset();
-        sessionId = in.readUTF();
-        recordAllActions = in.readBoolean();
-        int cnt = in.readInt();
-        if (actions == null)
-            actions = new LinkedList();
-        else
-            actions.clear();
-        for (int i = 0; i < cnt; i++) {
-            AttributeInfo info = null;
-            if (this.actionPool.size() > 0) {
-                try {
-                    info = (AttributeInfo) actionPool.removeFirst();
-                } catch ( Exception x )  {
-                    log.error("Unable to remove element",x);
-                    info = new AttributeInfo(-1,-1,null,null);
-                }
-            }
-            else {
-                info = new AttributeInfo(-1,-1,null,null);
-            }
-            info.readExternal(in);
-            actions.addLast(info);
-        }//for
-    }
-        
-
-
-    public synchronized void writeExternal(java.io.ObjectOutput out ) throws java.io.IOException {
-        //sessionId - String
-        //recordAll - boolean
-        //size - int
-        //AttributeInfo - in an array
-        out.writeUTF(getSessionId());
-        out.writeBoolean(recordAllActions);
-        out.writeInt(getSize());
-        for ( int i=0; i<getSize(); i++ ) {
-            AttributeInfo info = (AttributeInfo)actions.get(i);
-            info.writeExternal(out);
-        }
-    }
-    
-    /**
-     * serialize DeltaRequest
-     * @see DeltaRequest#writeExternal(java.io.ObjectOutput)
-     * 
-     * @param deltaRequest
-     * @return serialized delta request
-     * @throws IOException
-     */
-    protected byte[] serialize() throws IOException {
-        ByteArrayOutputStream bos = new ByteArrayOutputStream();
-        ObjectOutputStream oos = new ObjectOutputStream(bos);
-        writeExternal(oos);
-        oos.flush();
-        oos.close();
-        return bos.toByteArray();
-    }
-    
-    private static class AttributeInfo implements java.io.Externalizable {
-        private String name = null;
-        private Object value = null;
-        private int action;
-        private int type;
-
-        public AttributeInfo() {}
-
-        public AttributeInfo(int type,
-                             int action,
-                             String name,
-                             Object value) {
-            super();
-            init(type,action,name,value);
-        }
-
-        public void init(int type,
-                         int action,
-                         String name,
-                         Object value) {
-            this.name = name;
-            this.value = value;
-            this.action = action;
-            this.type = type;
-        }
-
-        public int getType() {
-            return type;
-        }
-
-        public int getAction() {
-            return action;
-        }
-
-        public Object getValue() {
-            return value;
-        }
-        public int hashCode() {
-            return name.hashCode();
-        }
-
-        public String getName() {
-            return name;
-        }
-        
-        public void recycle() {
-            name = null;
-            value = null;
-            type=-1;
-            action=-1;
-        }
-
-        public boolean equals(Object o) {
-            if ( ! (o instanceof AttributeInfo ) ) return false;
-            AttributeInfo other =  (AttributeInfo)o;
-            return other.getName().equals(this.getName());
-        }
-        
-        public synchronized void readExternal(java.io.ObjectInput in ) throws IOException,ClassNotFoundException {
-            //type - int
-            //action - int
-            //name - String
-            //hasvalue - boolean
-            //value - object
-            type = in.readInt();
-            action = in.readInt();
-            name = in.readUTF();
-            boolean hasValue = in.readBoolean();
-            if ( hasValue ) value = in.readObject();
-        }
-
-        public synchronized void writeExternal(java.io.ObjectOutput out) throws IOException {
-            //type - int
-            //action - int
-            //name - String
-            //hasvalue - boolean
-            //value - object
-            out.writeInt(getType());
-            out.writeInt(getAction());
-            out.writeUTF(getName());
-            out.writeBoolean(getValue()!=null);
-            if (getValue()!=null) out.writeObject(getValue());
-        }
-        
-        public String toString() {
-            StringBuffer buf = new StringBuffer("AttributeInfo[type=");
-            buf.append(getType()).append(", action=").append(getAction());
-            buf.append(", name=").append(getName()).append(", value=").append(getValue());
-            buf.append(", addr=").append(super.toString()).append("]");
-            return buf.toString();
-        }
-
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.catalina.ha.session;
+
+/**
+ * This class is used to track the series of actions that happens when
+ * a request is executed. These actions will then translate into invokations of methods 
+ * on the actual session.
+ * This class is NOT thread safe. One DeltaRequest per session
+ * @author <a href="mailto:fhanik@apache.org">Filip Hanik</a>
+ * @version 1.0
+ */
+
+import java.io.Externalizable;
+import java.security.Principal;
+import java.util.LinkedList;
+
+import org.apache.catalina.realm.GenericPrincipal;
+import org.apache.catalina.util.StringManager;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.ObjectOutputStream;
+
+
+public class DeltaRequest implements Externalizable {
+
+    public static org.apache.juli.logging.Log log =
+        org.apache.juli.logging.LogFactory.getLog( DeltaRequest.class );
+
+    /**
+     * The string manager for this package.
+     */
+    protected static StringManager sm = StringManager
+            .getManager(Constants.Package);
+
+    public static final int TYPE_ATTRIBUTE = 0;
+    public static final int TYPE_PRINCIPAL = 1;
+    public static final int TYPE_ISNEW = 2;
+    public static final int TYPE_MAXINTERVAL = 3;
+
+    public static final int ACTION_SET = 0;
+    public static final int ACTION_REMOVE = 1;
+
+    public static final String NAME_PRINCIPAL = "__SET__PRINCIPAL__";
+    public static final String NAME_MAXINTERVAL = "__SET__MAXINTERVAL__";
+    public static final String NAME_ISNEW = "__SET__ISNEW__";
+
+    private String sessionId;
+    private LinkedList actions = new LinkedList();
+    private LinkedList actionPool = new LinkedList();
+    
+    private boolean recordAllActions = false;
+
+    public DeltaRequest() {
+        
+    }
+    
+    public DeltaRequest(String sessionId, boolean recordAllActions) {
+        this.recordAllActions=recordAllActions;
+        if(sessionId != null)
+            setSessionId(sessionId);
+    }
+
+
+    public void setAttribute(String name, Object value) {
+        int action = (value==null)?ACTION_REMOVE:ACTION_SET;
+        addAction(TYPE_ATTRIBUTE,action,name,value);
+    }
+
+    public void removeAttribute(String name) {
+        int action = ACTION_REMOVE;
+        addAction(TYPE_ATTRIBUTE,action,name,null);
+    }
+
+    public void setMaxInactiveInterval(int interval) {
+        int action = ACTION_SET;
+        addAction(TYPE_MAXINTERVAL,action,NAME_MAXINTERVAL,new Integer(interval));
+    }
+    
+    /**
+     * convert principal at SerializablePrincipal for backup nodes.
+     * Only support principals from type {@link GenericPrincipal GenericPrincipal}
+     * @param p Session principal
+     * @see GenericPrincipal
+     */
+    public void setPrincipal(Principal p) {
+        int action = (p==null)?ACTION_REMOVE:ACTION_SET;
+        SerializablePrincipal sp = null;
+        if ( p != null ) {
+            if(p instanceof GenericPrincipal) {
+                sp = SerializablePrincipal.createPrincipal((GenericPrincipal)p);
+                if(log.isDebugEnabled())
+                    log.debug(sm.getString("deltaRequest.showPrincipal", p.getName() , getSessionId()));
+            } else
+                log.error(sm.getString("deltaRequest.wrongPrincipalClass",p.getClass().getName()));
+        }
+        addAction(TYPE_PRINCIPAL,action,NAME_PRINCIPAL,sp);
+    }
+
+    public void setNew(boolean n) {
+        int action = ACTION_SET;
+        addAction(TYPE_ISNEW,action,NAME_ISNEW,new Boolean(n));
+    }
+
+    protected synchronized void addAction(int type,
+                             int action,
+                             String name,
+                             Object value) {
+        AttributeInfo info = null;
+        if ( this.actionPool.size() > 0 ) {
+            try {
+                info = (AttributeInfo) actionPool.removeFirst();
+            }catch ( Exception x ) {
+                log.error("Unable to remove element:",x);
+                info = new AttributeInfo(type, action, name, value);
+            }
+            info.init(type,action,name,value);
+        } else {
+            info = new AttributeInfo(type, action, name, value);
+        }
+        //if we have already done something to this attribute, make sure
+        //we don't send multiple actions across the wire
+        if ( !recordAllActions) {
+            try {
+                actions.remove(info);
+            } catch (java.util.NoSuchElementException x) {
+                //do nothing, we wanted to remove it anyway
+            }
+        }
+        //add the action
+        actions.addLast(info);
+    }
+    
+    public void execute(DeltaSession session) {
+        execute(session,true);
+    }
+
+    public synchronized void execute(DeltaSession session, boolean notifyListeners) {
+        if ( !this.sessionId.equals( session.getId() ) )
+            throw new java.lang.IllegalArgumentException("Session id mismatch, not executing the delta request");
+        session.access();
+        for ( int i=0; i<actions.size(); i++ ) {
+            AttributeInfo info = (AttributeInfo)actions.get(i);
+            switch ( info.getType() ) {
+                case TYPE_ATTRIBUTE: {
+                    if ( info.getAction() == ACTION_SET ) {
+                        if ( log.isTraceEnabled() ) log.trace("Session.setAttribute('"+info.getName()+"', '"+info.getValue()+"')");
+                        session.setAttribute(info.getName(), info.getValue(),notifyListeners,false);
+                    }  else {
+                        if ( log.isTraceEnabled() ) log.trace("Session.removeAttribute('"+info.getName()+"')");
+                        session.removeAttribute(info.getName(),notifyListeners,false);
+                    }
+                        
+                    break;
+                }//case
+                case TYPE_ISNEW: {
+                if ( log.isTraceEnabled() ) log.trace("Session.setNew('"+info.getValue()+"')");
+                    session.setNew(((Boolean)info.getValue()).booleanValue(),false);
+                    break;
+                }//case
+                case TYPE_MAXINTERVAL: {
+                    if ( log.isTraceEnabled() ) log.trace("Session.setMaxInactiveInterval('"+info.getValue()+"')");
+                    session.setMaxInactiveInterval(((Integer)info.getValue()).intValue(),false);
+                    break;
+                }//case
+                case TYPE_PRINCIPAL: {
+                    Principal p = null;
+                    if ( info.getAction() == ACTION_SET ) {
+                        SerializablePrincipal sp = (SerializablePrincipal)info.getValue();
+                        p = (Principal)sp.getPrincipal(session.getManager().getContainer().getRealm());
+                    }
+                    session.setPrincipal(p,false);
+                    break;
+                }//case
+                default : throw new java.lang.IllegalArgumentException("Invalid attribute info type="+info);
+            }//switch
+        }//for
+        session.endAccess();
+        reset();
+    }
+
+    public synchronized void reset() {
+        while ( actions.size() > 0 ) {
+            try {
+                AttributeInfo info = (AttributeInfo) actions.removeFirst();
+                info.recycle();
+                actionPool.addLast(info);
+            }catch  ( Exception x ) {
+                log.error("Unable to remove element",x);
+            }
+        }
+        actions.clear();
+    }
+    
+    public String getSessionId() {
+        return sessionId;
+    }
+    public void setSessionId(String sessionId) {
+        this.sessionId = sessionId;
+        if ( sessionId == null ) {
+            new Exception("Session Id is null for setSessionId").fillInStackTrace().printStackTrace();
+        }
+    }
+    public int getSize() {
+        return actions.size();
+    }
+    
+    public synchronized void clear() {
+        actions.clear();
+        actionPool.clear();
+    }
+    
+    public synchronized void readExternal(java.io.ObjectInput in) throws IOException,ClassNotFoundException {
+        //sessionId - String
+        //recordAll - boolean
+        //size - int
+        //AttributeInfo - in an array
+        reset();
+        sessionId = in.readUTF();
+        recordAllActions = in.readBoolean();
+        int cnt = in.readInt();
+        if (actions == null)
+            actions = new LinkedList();
+        else
+            actions.clear();
+        for (int i = 0; i < cnt; i++) {
+            AttributeInfo info = null;
+            if (this.actionPool.size() > 0) {
+                try {
+                    info = (AttributeInfo) actionPool.removeFirst();
+                } catch ( Exception x )  {
+                    log.error("Unable to remove element",x);
+                    info = new AttributeInfo(-1,-1,null,null);
+                }
+            }
+            else {
+                info = new AttributeInfo(-1,-1,null,null);
+            }
+            info.readExternal(in);
+            actions.addLast(info);
+        }//for
+    }
+        
+
+
+    public synchronized void writeExternal(java.io.ObjectOutput out ) throws java.io.IOException {
+        //sessionId - String
+        //recordAll - boolean
+        //size - int
+        //AttributeInfo - in an array
+        out.writeUTF(getSessionId());
+        out.writeBoolean(recordAllActions);
+        out.writeInt(getSize());
+        for ( int i=0; i<getSize(); i++ ) {
+            AttributeInfo info = (AttributeInfo)actions.get(i);
+            info.writeExternal(out);
+        }
+    }
+    
+    /**
+     * serialize DeltaRequest
+     * @see DeltaRequest#writeExternal(java.io.ObjectOutput)
+     * 
+     * @param deltaRequest
+     * @return serialized delta request
+     * @throws IOException
+     */
+    protected byte[] serialize() throws IOException {
+        ByteArrayOutputStream bos = new ByteArrayOutputStream();
+        ObjectOutputStream oos = new ObjectOutputStream(bos);
+        writeExternal(oos);
+        oos.flush();
+        oos.close();
+        return bos.toByteArray();
+    }
+    
+    private static class AttributeInfo implements java.io.Externalizable {
+        private String name = null;
+        private Object value = null;
+        private int action;
+        private int type;
+
+        public AttributeInfo() {}
+
+        public AttributeInfo(int type,
+                             int action,
+                             String name,
+                             Object value) {
+            super();
+            init(type,action,name,value);
+        }
+
+        public void init(int type,
+                         int action,
+                         String name,
+                         Object value) {
+            this.name = name;
+            this.value = value;
+            this.action = action;
+            this.type = type;
+        }
+
+        public int getType() {
+            return type;
+        }
+
+        public int getAction() {
+            return action;
+        }
+
+        public Object getValue() {
+            return value;
+        }
+        public int hashCode() {
+            return name.hashCode();
+        }
+
+        public String getName() {
+            return name;
+        }
+        
+        public void recycle() {
+            name = null;
+            value = null;
+            type=-1;
+            action=-1;
+        }
+
+        public boolean equals(Object o) {
+            if ( ! (o instanceof AttributeInfo ) ) return false;
+            AttributeInfo other =  (AttributeInfo)o;
+            return other.getName().equals(this.getName());
+        }
+        
+        public synchronized void readExternal(java.io.ObjectInput in ) throws IOException,ClassNotFoundException {
+            //type - int
+            //action - int
+            //name - String
+            //hasvalue - boolean
+            //value - object
+            type = in.readInt();
+            action = in.readInt();
+            name = in.readUTF();
+            boolean hasValue = in.readBoolean();
+            if ( hasValue ) value = in.readObject();
+        }
+
+        public synchronized void writeExternal(java.io.ObjectOutput out) throws IOException {
+            //type - int
+            //action - int
+            //name - String
+            //hasvalue - boolean
+            //value - object
+            out.writeInt(getType());
+            out.writeInt(getAction());
+            out.writeUTF(getName());
+            out.writeBoolean(getValue()!=null);
+            if (getValue()!=null) out.writeObject(getValue());
+        }
+        
+        public String toString() {
+            StringBuffer buf = new StringBuffer("AttributeInfo[type=");
+            buf.append(getType()).append(", action=").append(getAction());
+            buf.append(", name=").append(getName()).append(", value=").append(getValue());
+            buf.append(", addr=").append(super.toString()).append("]");
+            return buf.toString();
+        }
+
+    }
+
+}

==================================================
JvmRouteBinderValve.java
index 683e2da1ff..1104db5e3a 100644
--- a/java/org/apache/catalina/ha/session/DeltaSession.java
+++ b/java/org/apache/catalina/ha/session/DeltaSession.java
@@ -1,751 +1,752 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha.session;
-
-import java.io.Externalizable;
-import java.io.IOException;
-import java.io.NotSerializableException;
-import java.io.ObjectInput;
-import java.io.ObjectOutput;
-import java.io.Serializable;
-import java.security.Principal;
-import java.util.ArrayList;
-import java.util.Enumeration;
-import java.util.HashMap;
-import java.util.Hashtable;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantReadWriteLock;
-import javax.servlet.http.HttpSession;
-import javax.servlet.http.HttpSessionContext;
-
-import org.apache.catalina.Manager;
-import org.apache.catalina.ha.ClusterManager;
-import org.apache.catalina.ha.ClusterSession;
-import org.apache.catalina.realm.GenericPrincipal;
-import org.apache.catalina.session.StandardSession;
-import org.apache.catalina.tribes.io.ReplicationStream;
-import org.apache.catalina.tribes.tipis.ReplicatedMapEntry;
-import org.apache.catalina.util.Enumerator;
-import org.apache.catalina.util.StringManager;
-import org.apache.catalina.session.StandardManager;
-import org.apache.catalina.session.ManagerBase;
-import java.util.concurrent.atomic.AtomicInteger;
-
-/**
- *
- * Similar to the StandardSession except that this session will keep
- * track of deltas during a request.
- *
- * @author Filip Hanik
- * @version $Revision: 372887 $ $Date: 2006-01-27 09:58:58 -0600 (Fri, 27 Jan 2006) $
- */
-
-public class DeltaSession extends StandardSession implements Externalizable,ClusterSession,ReplicatedMapEntry {
-
-    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(DeltaSession.class);
-
-    /**
-     * The string manager for this package.
-     */
-    protected static StringManager sm = StringManager.getManager(Constants.Package);
-
-    // ----------------------------------------------------- Instance Variables
-
-    /**
-     * only the primary session will expire, or be able to expire due to
-     * inactivity. This is set to false as soon as I receive this session over
-     * the wire in a session message. That means that someone else has made a
-     * request on another server.
-     */
-    private transient boolean isPrimarySession = true;
-
-    /**
-     * The delta request contains all the action info
-     *
-     */
-    private transient DeltaRequest deltaRequest = null;
-
-    /**
-     * Last time the session was replicatd, used for distributed expiring of
-     * session
-     */
-    private transient long lastTimeReplicated = System.currentTimeMillis();
-
-
-    protected Lock diffLock = new ReentrantReadWriteLock().writeLock();
-
-    private long version;
-
-    // ----------------------------------------------------------- Constructors
-
-    /**
-     * Construct a new Session associated with the specified Manager.
-     *
-     * @param manager
-     *            The manager with which this Session is associated
-     */
-    public DeltaSession() {
-        this(null);
-    }
-
-    public DeltaSession(Manager manager) {
-        super(manager);
-        this.resetDeltaRequest();
-    }
-
-    // ----------------------------------------------------- ReplicatedMapEntry
-
-    /**
-         * Has the object changed since last replication
-         * and is not in a locked state
-         * @return boolean
-         */
-        public boolean isDirty() {
-            return getDeltaRequest().getSize()>0;
-        }
-
-        /**
-         * If this returns true, the map will extract the diff using getDiff()
-         * Otherwise it will serialize the entire object.
-         * @return boolean
-         */
-        public boolean isDiffable() {
-            return true;
-        }
-
-        /**
-         * Returns a diff and sets the dirty map to false
-         * @return byte[]
-         * @throws IOException
-         */
-        public byte[] getDiff() throws IOException {
-            return getDeltaRequest().serialize();
-        }
-
-        public ClassLoader[] getClassLoaders() {
-            if ( manager instanceof BackupManager ) return ((BackupManager)manager).getClassLoaders();
-            else if ( manager instanceof ClusterManagerBase ) return ((ClusterManagerBase)manager).getClassLoaders();
-            else if ( manager instanceof StandardManager ) {
-                StandardManager sm = (StandardManager)manager;
-                return ClusterManagerBase.getClassLoaders(sm.getContainer());
-            } else if ( manager instanceof ManagerBase ) {
-                ManagerBase mb = (ManagerBase)manager;
-                return ClusterManagerBase.getClassLoaders(mb.getContainer());
-            }//end if
-            return null;
-        }
-
-        /**
-         * Applies a diff to an existing object.
-         * @param diff byte[]
-         * @param offset int
-         * @param length int
-         * @throws IOException
-         */
-        public void applyDiff(byte[] diff, int offset, int length) throws IOException, ClassNotFoundException {
-            ReplicationStream stream = ((ClusterManager)getManager()).getReplicationStream(diff,offset,length);
-            getDeltaRequest().readExternal(stream);
-            ClassLoader contextLoader = Thread.currentThread().getContextClassLoader();
-            try {
-                ClassLoader[] loaders = getClassLoaders();
-                if ( loaders != null && loaders.length >0 ) Thread.currentThread().setContextClassLoader(loaders[0]);
-                getDeltaRequest().execute(this);
-            }finally {
-                Thread.currentThread().setContextClassLoader(contextLoader);
-            }
-        }
-
-        /**
-         * Resets the current diff state and resets the dirty flag
-         */
-        public void resetDiff() {
-            resetDeltaRequest();
-        }
-
-        /**
-         * Lock during serialization
-         */
-        public void lock() {
-            diffLock.lock();
-        }
-
-        /**
-         * Unlock after serialization
-         */
-        public void unlock() {
-            diffLock.unlock();
-        }
-
-        public void setOwner(Object owner) {
-            if ( owner instanceof ClusterManager && getManager()==null) {
-                ClusterManager cm = (ClusterManager)owner;
-                this.setManager(cm);
-                this.setValid(true);
-                this.setPrimarySession(false);
-                this.access();
-                this.resetDeltaRequest();
-                this.endAccess();
-            }
-        }
-    // ----------------------------------------------------- Session Properties
-
-    /**
-     * returns true if this session is the primary session, if that is the case,
-     * the manager can expire it upon timeout.
-     */
-    public boolean isPrimarySession() {
-        return isPrimarySession;
-    }
-
-    /**
-     * Sets whether this is the primary session or not.
-     *
-     * @param primarySession
-     *            Flag value
-     */
-    public void setPrimarySession(boolean primarySession) {
-        this.isPrimarySession = primarySession;
-    }
-
-    /**
-     * Set the session identifier for this session without notify listeners.
-     *
-     * @param id
-     *            The new session identifier
-     */
-    public void setIdInternal(String id) {
-        this.id = id;
-        resetDeltaRequest();
-    }
-
-    /**
-     * Set the session identifier for this session.
-     *
-     * @param id
-     *            The new session identifier
-     */
-    public void setId(String id) {
-        super.setId(id);
-        resetDeltaRequest();
-    }
-
-   
-
-    /**
-     * Return the last client access time without invalidation check
-     * @see #getLastAccessedTime().
-     */
-    public long getLastAccessedTimeInternal() {
-        return (this.lastAccessedTime);
-    }
-
-
-   
-    public void setMaxInactiveInterval(int interval, boolean addDeltaRequest) {
-        super.maxInactiveInterval = interval;
-        if (isValid && interval == 0) {
-            expire();
-        } else {
-            if (addDeltaRequest && (deltaRequest != null))
-                deltaRequest.setMaxInactiveInterval(interval);
-        }
-    }
-
-    /**
-     * Set the <code>isNew</code> flag for this session.
-     *
-     * @param isNew
-     *            The new value for the <code>isNew</code> flag
-     */
-    public void setNew(boolean isNew) {
-        setNew(isNew, true);
-    }
-
-    public void setNew(boolean isNew, boolean addDeltaRequest) {
-        super.setNew(isNew);
-        if (addDeltaRequest && (deltaRequest != null))
-            deltaRequest.setNew(isNew);
-    }
-
-    /**
-     * Set the authenticated Principal that is associated with this Session.
-     * This provides an <code>Authenticator</code> with a means to cache a
-     * previously authenticated Principal, and avoid potentially expensive
-     * <code>Realm.authenticate()</code> calls on every request.
-     *
-     * @param principal
-     *            The new Principal, or <code>null</code> if none
-     */
-    public void setPrincipal(Principal principal) {
-        setPrincipal(principal, true);
-    }
-
-    public void setPrincipal(Principal principal, boolean addDeltaRequest) {
-        try { 
-            lock();
-            super.setPrincipal(principal);
-            if (addDeltaRequest && (deltaRequest != null))
-                deltaRequest.setPrincipal(principal);
-        } finally {
-            unlock();
-        }
-    }
-
-    /**
-     * Return the <code>isValid</code> flag for this session.
-     */
-    public boolean isValid() {
-        if (this.expiring) {
-            return true;
-        }
-        if (!this.isValid) {
-            return false;
-        }
-        if (ACTIVITY_CHECK && accessCount.get() > 0) {
-            return true;
-        }
-        if (maxInactiveInterval >= 0) {
-            long timeNow = System.currentTimeMillis();
-            int timeIdle = (int) ( (timeNow - thisAccessedTime) / 1000L);
-            if (isPrimarySession()) {
-                if (timeIdle >= maxInactiveInterval) {
-                    expire(true);
-                }
-            } else {
-                if (timeIdle >= (2 * maxInactiveInterval)) {
-                    //if the session has been idle twice as long as allowed,
-                    //the primary session has probably crashed, and no other
-                    //requests are coming in. that is why we do this. otherwise
-                    //we would have a memory leak
-                    expire(true, false);
-                }
-            }
-        }
-        return (this.isValid);
-    }
-
-    // ------------------------------------------------- Session Public Methods
-
-    /**
-     * Perform the internal processing required to invalidate this session,
-     * without triggering an exception if the session has already expired.
-     *
-     * @param notify
-     *            Should we notify listeners about the demise of this session?
-     */
-    public void expire(boolean notify) {
-        expire(notify, true);
-    }
-
-    public void expire(boolean notify, boolean notifyCluster) {
-        String expiredId = getIdInternal();
-        super.expire(notify);
-
-        if (notifyCluster) {
-            if (log.isDebugEnabled())
-                log.debug(sm.getString("deltaSession.notifying",
-                                       ((DeltaManager)manager).getName(), 
-                                       new Boolean(isPrimarySession()), 
-                                       expiredId));
-            if ( manager instanceof DeltaManager ) {
-                ( (DeltaManager) manager).sessionExpired(expiredId);
-            }
-        }
-    }
-
-    /**
-     * Release all object references, and initialize instance variables, in
-     * preparation for reuse of this object.
-     */
-    public void recycle() {
-        super.recycle();
-        deltaRequest.clear();
-    }
-
-
-    /**
-     * Return a string representation of this object.
-     */
-    public String toString() {
-        StringBuffer sb = new StringBuffer();
-        sb.append("DeltaSession[");
-        sb.append(id);
-        sb.append("]");
-        return (sb.toString());
-    }
-
-    // ------------------------------------------------ Session Package Methods
-
-    public synchronized void readExternal(ObjectInput in) throws IOException,ClassNotFoundException {
-        readObjectData(in);
-    }
-
-
-    /**
-     * Read a serialized version of the contents of this session object from the
-     * specified object input stream, without requiring that the StandardSession
-     * itself have been serialized.
-     *
-     * @param stream
-     *            The object input stream to read from
-     *
-     * @exception ClassNotFoundException
-     *                if an unknown class is specified
-     * @exception IOException
-     *                if an input/output error occurs
-     */
-    public void readObjectData(ObjectInput stream) throws ClassNotFoundException, IOException {
-        readObject(stream);
-    }
-
-    /**
-     * Write a serialized version of the contents of this session object to the
-     * specified object output stream, without requiring that the
-     * StandardSession itself have been serialized.
-     *
-     * @param stream
-     *            The object output stream to write to
-     *
-     * @exception IOException
-     *                if an input/output error occurs
-     */
-    public void writeObjectData(ObjectOutput stream) throws IOException {
-        writeObject(stream);
-    }
-
-    public void resetDeltaRequest() {
-        if (deltaRequest == null) {
-            deltaRequest = new DeltaRequest(getIdInternal(), false);
-        } else {
-            deltaRequest.reset();
-            deltaRequest.setSessionId(getIdInternal());
-        }
-    }
-
-    public DeltaRequest getDeltaRequest() {
-        if (deltaRequest == null) resetDeltaRequest();
-        return deltaRequest;
-    }
-
-    // ------------------------------------------------- HttpSession Properties
-
-    // ----------------------------------------------HttpSession Public Methods
-
-
-
-    /**
-     * Remove the object bound with the specified name from this session. If the
-     * session does not have an object bound with this name, this method does
-     * nothing.
-     * <p>
-     * After this method executes, and if the object implements
-     * <code>HttpSessionBindingListener</code>, the container calls
-     * <code>valueUnbound()</code> on the object.
-     *
-     * @param name
-     *            Name of the object to remove from this session.
-     * @param notify
-     *            Should we notify interested listeners that this attribute is
-     *            being removed?
-     *
-     * @exception IllegalStateException
-     *                if this method is called on an invalidated session
-     */
-    public void removeAttribute(String name, boolean notify) {
-        removeAttribute(name, notify, true);
-    }
-
-    public void removeAttribute(String name, boolean notify,boolean addDeltaRequest) {
-        // Validate our current state
-        if (!isValid()) throw new IllegalStateException(sm.getString("standardSession.removeAttribute.ise"));
-        removeAttributeInternal(name, notify, addDeltaRequest);
-    }
-
-    /**
-     * Bind an object to this session, using the specified name. If an object of
-     * the same name is already bound to this session, the object is replaced.
-     * <p>
-     * After this method executes, and if the object implements
-     * <code>HttpSessionBindingListener</code>, the container calls
-     * <code>valueBound()</code> on the object.
-     *
-     * @param name
-     *            Name to which the object is bound, cannot be null
-     * @param value
-     *            Object to be bound, cannot be null
-     *
-     * @exception IllegalArgumentException
-     *                if an attempt is made to add a non-serializable object in
-     *                an environment marked distributable.
-     * @exception IllegalStateException
-     *                if this method is called on an invalidated session
-     */
-    public void setAttribute(String name, Object value) {
-        setAttribute(name, value, true, true);
-    }
-
-    public void setAttribute(String name, Object value, boolean notify,boolean addDeltaRequest) {
-
-        // Name cannot be null
-        if (name == null) throw new IllegalArgumentException(sm.getString("standardSession.setAttribute.namenull"));
-
-        // Null value is the same as removeAttribute()
-        if (value == null) {
-            removeAttribute(name);
-            return;
-        }
-
-        try {
-            lock();
-            super.setAttribute(name,value, notify);
-            if (addDeltaRequest && (deltaRequest != null)) deltaRequest.setAttribute(name, value);
-        } finally {
-            unlock();
-        }
-    }
-
-    // -------------------------------------------- HttpSession Private Methods
-
-    /**
-     * Read a serialized version of this session object from the specified
-     * object input stream.
-     * <p>
-     * <b>IMPLEMENTATION NOTE </b>: The reference to the owning Manager is not
-     * restored by this method, and must be set explicitly.
-     *
-     * @param stream
-     *            The input stream to read from
-     *
-     * @exception ClassNotFoundException
-     *                if an unknown class is specified
-     * @exception IOException
-     *                if an input/output error occurs
-     */
-    private void readObject(ObjectInput stream) throws ClassNotFoundException, IOException {
-
-        // Deserialize the scalar instance variables (except Manager)
-        authType = null; // Transient only
-        creationTime = ( (Long) stream.readObject()).longValue();
-        lastAccessedTime = ( (Long) stream.readObject()).longValue();
-        maxInactiveInterval = ( (Integer) stream.readObject()).intValue();
-        isNew = ( (Boolean) stream.readObject()).booleanValue();
-        isValid = ( (Boolean) stream.readObject()).booleanValue();
-        thisAccessedTime = ( (Long) stream.readObject()).longValue();
-        version = ( (Long) stream.readObject()).longValue();
-        boolean hasPrincipal = stream.readBoolean();
-        principal = null;
-        if (hasPrincipal) {
-            principal = SerializablePrincipal.readPrincipal(stream,getManager().getContainer().getRealm());
-        }
-
-        //        setId((String) stream.readObject());
-        id = (String) stream.readObject();
-        if (log.isDebugEnabled()) log.debug(sm.getString("deltaSession.readSession", id));
-
-        // Deserialize the attribute count and attribute values
-        if (attributes == null) attributes = new Hashtable();
-        int n = ( (Integer) stream.readObject()).intValue();
-        boolean isValidSave = isValid;
-        isValid = true;
-        for (int i = 0; i < n; i++) {
-            String name = (String) stream.readObject();
-            Object value = (Object) stream.readObject();
-            if ( (value instanceof String) && (value.equals(NOT_SERIALIZED)))
-                continue;
-            attributes.put(name, value);
-        }
-        isValid = isValidSave;
-
-        if (listeners == null) {
-            listeners = new ArrayList();
-        }
-
-        if (notes == null) {
-            notes = new Hashtable();
-        }
-        activate();
-    }
-
-    public synchronized void writeExternal(ObjectOutput out ) throws java.io.IOException {
-        writeObject(out);
-    }
-
-
-    /**
-     * Write a serialized version of this session object to the specified object
-     * output stream.
-     * <p>
-     * <b>IMPLEMENTATION NOTE </b>: The owning Manager will not be stored in the
-     * serialized representation of this Session. After calling
-     * <code>readObject()</code>, you must set the associated Manager
-     * explicitly.
-     * <p>
-     * <b>IMPLEMENTATION NOTE </b>: Any attribute that is not Serializable will
-     * be unbound from the session, with appropriate actions if it implements
-     * HttpSessionBindingListener. If you do not want any such attributes, be
-     * sure the <code>distributable</code> property of the associated Manager
-     * is set to <code>true</code>.
-     *
-     * @param stream
-     *            The output stream to write to
-     *
-     * @exception IOException
-     *                if an input/output error occurs
-     */
-    private void writeObject(ObjectOutput stream) throws IOException {
-        // Write the scalar instance variables (except Manager)
-        stream.writeObject(new Long(creationTime));
-        stream.writeObject(new Long(lastAccessedTime));
-        stream.writeObject(new Integer(maxInactiveInterval));
-        stream.writeObject(new Boolean(isNew));
-        stream.writeObject(new Boolean(isValid));
-        stream.writeObject(new Long(thisAccessedTime));
-        stream.writeObject(new Long(version));
-        stream.writeBoolean(getPrincipal() != null);
-        if (getPrincipal() != null) {
-            SerializablePrincipal.writePrincipal((GenericPrincipal) principal,stream);
-        }
-
-        stream.writeObject(id);
-        if (log.isDebugEnabled()) log.debug(sm.getString("deltaSession.writeSession", id));
-
-        // Accumulate the names of serializable and non-serializable attributes
-        String keys[] = keys();
-        ArrayList saveNames = new ArrayList();
-        ArrayList saveValues = new ArrayList();
-        for (int i = 0; i < keys.length; i++) {
-            Object value = null;
-            value = attributes.get(keys[i]);
-            if (value == null)
-                continue;
-            else if (value instanceof Serializable) {
-                saveNames.add(keys[i]);
-                saveValues.add(value);
-            }
-        }
-
-        // Serialize the attribute count and the Serializable attributes
-        int n = saveNames.size();
-        stream.writeObject(new Integer(n));
-        for (int i = 0; i < n; i++) {
-            stream.writeObject( (String) saveNames.get(i));
-            try {
-                stream.writeObject(saveValues.get(i));
-            } catch (NotSerializableException e) {
-                log.error(sm.getString("standardSession.notSerializable",saveNames.get(i), id), e);
-                stream.writeObject(NOT_SERIALIZED);
-                log.error("  storing attribute '" + saveNames.get(i)+ "' with value NOT_SERIALIZED");
-            }
-        }
-
-    }
-
-    // -------------------------------------------------------- Private Methods
-
-    
-
-    /**
-     * Return the value of an attribute without a check for validity.
-     */
-    protected Object getAttributeInternal(String name) {
-        return (attributes.get(name));
-    }
-
-    protected void removeAttributeInternal(String name, boolean notify,
-                                           boolean addDeltaRequest) {
-        try {
-            lock();
-            // Remove this attribute from our collection
-            Object value = attributes.get(name);
-            if (value == null) return;
-
-            super.removeAttributeInternal(name,notify);
-            if (addDeltaRequest && (deltaRequest != null)) deltaRequest.removeAttribute(name);
-
-        }finally {
-            unlock();
-        }
-    }
-
-    protected long getLastTimeReplicated() {
-        return lastTimeReplicated;
-    }
-
-    public long getVersion() {
-        return version;
-    }
-
-    protected void setLastTimeReplicated(long lastTimeReplicated) {
-        this.lastTimeReplicated = lastTimeReplicated;
-    }
-
-    public void setVersion(long version) {
-        this.version = version;
-    }
-
-    protected void setAccessCount(int count) {
-        if ( accessCount == null && ACTIVITY_CHECK ) accessCount = new AtomicInteger();
-        if ( accessCount != null ) super.accessCount.set(count);
-    }
-}
-
-// -------------------------------------------------------------- Private Class
-
-/**
- * This class is a dummy implementation of the <code>HttpSessionContext</code>
- * interface, to conform to the requirement that such an object be returned when
- * <code>HttpSession.getSessionContext()</code> is called.
- *
- * @author Craig R. McClanahan
- *
- * @deprecated As of Java Servlet API 2.1 with no replacement. The interface
- *             will be removed in a future version of this API.
- */
-
-final class StandardSessionContext
-    implements HttpSessionContext {
-
-    private HashMap dummy = new HashMap();
-
-    /**
-     * Return the session identifiers of all sessions defined within this
-     * context.
-     *
-     * @deprecated As of Java Servlet API 2.1 with no replacement. This method
-     *             must return an empty <code>Enumeration</code> and will be
-     *             removed in a future version of the API.
-     */
-    public Enumeration getIds() {
-        return (new Enumerator(dummy));
-    }
-
-    /**
-     * Return the <code>HttpSession</code> associated with the specified
-     * session identifier.
-     *
-     * @param id
-     *            Session identifier for which to look up a session
-     *
-     * @deprecated As of Java Servlet API 2.1 with no replacement. This method
-     *             must return null and will be removed in a future version of
-     *             the API.
-     */
-    public HttpSession getSession(String id) {
-        return (null);
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha.session;
+
+import java.io.Externalizable;
+import java.io.IOException;
+import java.io.NotSerializableException;
+import java.io.ObjectInput;
+import java.io.ObjectOutput;
+import java.io.Serializable;
+import java.security.Principal;
+import java.util.ArrayList;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Hashtable;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+import javax.servlet.http.HttpSession;
+import javax.servlet.http.HttpSessionContext;
+
+import org.apache.catalina.Manager;
+import org.apache.catalina.ha.ClusterManager;
+import org.apache.catalina.ha.ClusterSession;
+import org.apache.catalina.realm.GenericPrincipal;
+import org.apache.catalina.session.StandardSession;
+import org.apache.catalina.tribes.io.ReplicationStream;
+import org.apache.catalina.tribes.tipis.ReplicatedMapEntry;
+import org.apache.catalina.util.Enumerator;
+import org.apache.catalina.util.StringManager;
+import org.apache.catalina.session.StandardManager;
+import org.apache.catalina.session.ManagerBase;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ *
+ * Similar to the StandardSession except that this session will keep
+ * track of deltas during a request.
+ *
+ * @author Filip Hanik
+ * @version $Revision: 372887 $ $Date: 2006-01-27 09:58:58 -0600 (Fri, 27 Jan 2006) $
+ */
+
+public class DeltaSession extends StandardSession implements Externalizable,ClusterSession,ReplicatedMapEntry {
+
+    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(DeltaSession.class);
+
+    /**
+     * The string manager for this package.
+     */
+    protected static StringManager sm = StringManager.getManager(Constants.Package);
+
+    // ----------------------------------------------------- Instance Variables
+
+    /**
+     * only the primary session will expire, or be able to expire due to
+     * inactivity. This is set to false as soon as I receive this session over
+     * the wire in a session message. That means that someone else has made a
+     * request on another server.
+     */
+    private transient boolean isPrimarySession = true;
+
+    /**
+     * The delta request contains all the action info
+     *
+     */
+    private transient DeltaRequest deltaRequest = null;
+
+    /**
+     * Last time the session was replicatd, used for distributed expiring of
+     * session
+     */
+    private transient long lastTimeReplicated = System.currentTimeMillis();
+
+
+    protected Lock diffLock = new ReentrantReadWriteLock().writeLock();
+
+    private long version;
+
+    // ----------------------------------------------------------- Constructors
+
+    /**
+     * Construct a new Session associated with the specified Manager.
+     *
+     * @param manager
+     *            The manager with which this Session is associated
+     */
+    public DeltaSession() {
+        this(null);
+    }
+
+    public DeltaSession(Manager manager) {
+        super(manager);
+        this.resetDeltaRequest();
+    }
+
+    // ----------------------------------------------------- ReplicatedMapEntry
+
+    /**
+         * Has the object changed since last replication
+         * and is not in a locked state
+         * @return boolean
+         */
+        public boolean isDirty() {
+            return getDeltaRequest().getSize()>0;
+        }
+
+        /**
+         * If this returns true, the map will extract the diff using getDiff()
+         * Otherwise it will serialize the entire object.
+         * @return boolean
+         */
+        public boolean isDiffable() {
+            return true;
+        }
+
+        /**
+         * Returns a diff and sets the dirty map to false
+         * @return byte[]
+         * @throws IOException
+         */
+        public byte[] getDiff() throws IOException {
+            return getDeltaRequest().serialize();
+        }
+
+        public ClassLoader[] getClassLoaders() {
+            if ( manager instanceof BackupManager ) return ((BackupManager)manager).getClassLoaders();
+            else if ( manager instanceof ClusterManagerBase ) return ((ClusterManagerBase)manager).getClassLoaders();
+            else if ( manager instanceof StandardManager ) {
+                StandardManager sm = (StandardManager)manager;
+                return ClusterManagerBase.getClassLoaders(sm.getContainer());
+            } else if ( manager instanceof ManagerBase ) {
+                ManagerBase mb = (ManagerBase)manager;
+                return ClusterManagerBase.getClassLoaders(mb.getContainer());
+            }//end if
+            return null;
+        }
+
+        /**
+         * Applies a diff to an existing object.
+         * @param diff byte[]
+         * @param offset int
+         * @param length int
+         * @throws IOException
+         */
+        public void applyDiff(byte[] diff, int offset, int length) throws IOException, ClassNotFoundException {
+            ReplicationStream stream = ((ClusterManager)getManager()).getReplicationStream(diff,offset,length);
+            getDeltaRequest().readExternal(stream);
+            ClassLoader contextLoader = Thread.currentThread().getContextClassLoader();
+            try {
+                ClassLoader[] loaders = getClassLoaders();
+                if ( loaders != null && loaders.length >0 ) Thread.currentThread().setContextClassLoader(loaders[0]);
+                getDeltaRequest().execute(this);
+            }finally {
+                Thread.currentThread().setContextClassLoader(contextLoader);
+            }
+        }
+
+        /**
+         * Resets the current diff state and resets the dirty flag
+         */
+        public void resetDiff() {
+            resetDeltaRequest();
+        }
+
+        /**
+         * Lock during serialization
+         */
+        public void lock() {
+            diffLock.lock();
+        }
+
+        /**
+         * Unlock after serialization
+         */
+        public void unlock() {
+            diffLock.unlock();
+        }
+
+        public void setOwner(Object owner) {
+            if ( owner instanceof ClusterManager && getManager()==null) {
+                ClusterManager cm = (ClusterManager)owner;
+                this.setManager(cm);
+                this.setValid(true);
+                this.setPrimarySession(false);
+                this.access();
+                this.resetDeltaRequest();
+                this.endAccess();
+            }
+        }
+    // ----------------------------------------------------- Session Properties
+
+    /**
+     * returns true if this session is the primary session, if that is the case,
+     * the manager can expire it upon timeout.
+     */
+    public boolean isPrimarySession() {
+        return isPrimarySession;
+    }
+
+    /**
+     * Sets whether this is the primary session or not.
+     *
+     * @param primarySession
+     *            Flag value
+     */
+    public void setPrimarySession(boolean primarySession) {
+        this.isPrimarySession = primarySession;
+    }
+
+    /**
+     * Set the session identifier for this session without notify listeners.
+     *
+     * @param id
+     *            The new session identifier
+     */
+    public void setIdInternal(String id) {
+        this.id = id;
+        resetDeltaRequest();
+    }
+
+    /**
+     * Set the session identifier for this session.
+     *
+     * @param id
+     *            The new session identifier
+     */
+    public void setId(String id) {
+        super.setId(id);
+        resetDeltaRequest();
+    }
+
+   
+
+    /**
+     * Return the last client access time without invalidation check
+     * @see #getLastAccessedTime().
+     */
+    public long getLastAccessedTimeInternal() {
+        return (this.lastAccessedTime);
+    }
+
+
+   
+    public void setMaxInactiveInterval(int interval, boolean addDeltaRequest) {
+        super.maxInactiveInterval = interval;
+        if (isValid && interval == 0) {
+            expire();
+        } else {
+            if (addDeltaRequest && (deltaRequest != null))
+                deltaRequest.setMaxInactiveInterval(interval);
+        }
+    }
+
+    /**
+     * Set the <code>isNew</code> flag for this session.
+     *
+     * @param isNew
+     *            The new value for the <code>isNew</code> flag
+     */
+    public void setNew(boolean isNew) {
+        setNew(isNew, true);
+    }
+
+    public void setNew(boolean isNew, boolean addDeltaRequest) {
+        super.setNew(isNew);
+        if (addDeltaRequest && (deltaRequest != null))
+            deltaRequest.setNew(isNew);
+    }
+
+    /**
+     * Set the authenticated Principal that is associated with this Session.
+     * This provides an <code>Authenticator</code> with a means to cache a
+     * previously authenticated Principal, and avoid potentially expensive
+     * <code>Realm.authenticate()</code> calls on every request.
+     *
+     * @param principal
+     *            The new Principal, or <code>null</code> if none
+     */
+    public void setPrincipal(Principal principal) {
+        setPrincipal(principal, true);
+    }
+
+    public void setPrincipal(Principal principal, boolean addDeltaRequest) {
+        try { 
+            lock();
+            super.setPrincipal(principal);
+            if (addDeltaRequest && (deltaRequest != null))
+                deltaRequest.setPrincipal(principal);
+        } finally {
+            unlock();
+        }
+    }
+
+    /**
+     * Return the <code>isValid</code> flag for this session.
+     */
+    public boolean isValid() {
+        if (this.expiring) {
+            return true;
+        }
+        if (!this.isValid) {
+            return false;
+        }
+        if (ACTIVITY_CHECK && accessCount.get() > 0) {
+            return true;
+        }
+        if (maxInactiveInterval >= 0) {
+            long timeNow = System.currentTimeMillis();
+            int timeIdle = (int) ( (timeNow - thisAccessedTime) / 1000L);
+            if (isPrimarySession()) {
+                if (timeIdle >= maxInactiveInterval) {
+                    expire(true);
+                }
+            } else {
+                if (timeIdle >= (2 * maxInactiveInterval)) {
+                    //if the session has been idle twice as long as allowed,
+                    //the primary session has probably crashed, and no other
+                    //requests are coming in. that is why we do this. otherwise
+                    //we would have a memory leak
+                    expire(true, false);
+                }
+            }
+        }
+        return (this.isValid);
+    }
+
+    // ------------------------------------------------- Session Public Methods
+
+    /**
+     * Perform the internal processing required to invalidate this session,
+     * without triggering an exception if the session has already expired.
+     *
+     * @param notify
+     *            Should we notify listeners about the demise of this session?
+     */
+    public void expire(boolean notify) {
+        expire(notify, true);
+    }
+
+    public void expire(boolean notify, boolean notifyCluster) {
+        String expiredId = getIdInternal();
+        super.expire(notify);
+
+        if (notifyCluster) {
+            if (log.isDebugEnabled())
+                log.debug(sm.getString("deltaSession.notifying",
+                                       ((DeltaManager)manager).getName(), 
+                                       new Boolean(isPrimarySession()), 
+                                       expiredId));
+            if ( manager instanceof DeltaManager ) {
+                ( (DeltaManager) manager).sessionExpired(expiredId);
+            }
+        }
+    }
+
+    /**
+     * Release all object references, and initialize instance variables, in
+     * preparation for reuse of this object.
+     */
+    public void recycle() {
+        super.recycle();
+        deltaRequest.clear();
+    }
+
+
+    /**
+     * Return a string representation of this object.
+     */
+    public String toString() {
+        StringBuffer sb = new StringBuffer();
+        sb.append("DeltaSession[");
+        sb.append(id);
+        sb.append("]");
+        return (sb.toString());
+    }
+
+    // ------------------------------------------------ Session Package Methods
+
+    public synchronized void readExternal(ObjectInput in) throws IOException,ClassNotFoundException {
+        readObjectData(in);
+    }
+
+
+    /**
+     * Read a serialized version of the contents of this session object from the
+     * specified object input stream, without requiring that the StandardSession
+     * itself have been serialized.
+     *
+     * @param stream
+     *            The object input stream to read from
+     *
+     * @exception ClassNotFoundException
+     *                if an unknown class is specified
+     * @exception IOException
+     *                if an input/output error occurs
+     */
+    public void readObjectData(ObjectInput stream) throws ClassNotFoundException, IOException {
+        readObject(stream);
+    }
+
+    /**
+     * Write a serialized version of the contents of this session object to the
+     * specified object output stream, without requiring that the
+     * StandardSession itself have been serialized.
+     *
+     * @param stream
+     *            The object output stream to write to
+     *
+     * @exception IOException
+     *                if an input/output error occurs
+     */
+    public void writeObjectData(ObjectOutput stream) throws IOException {
+        writeObject(stream);
+    }
+
+    public void resetDeltaRequest() {
+        if (deltaRequest == null) {
+            deltaRequest = new DeltaRequest(getIdInternal(), false);
+        } else {
+            deltaRequest.reset();
+            deltaRequest.setSessionId(getIdInternal());
+        }
+    }
+
+    public DeltaRequest getDeltaRequest() {
+        if (deltaRequest == null) resetDeltaRequest();
+        return deltaRequest;
+    }
+
+    // ------------------------------------------------- HttpSession Properties
+
+    // ----------------------------------------------HttpSession Public Methods
+
+
+
+    /**
+     * Remove the object bound with the specified name from this session. If the
+     * session does not have an object bound with this name, this method does
+     * nothing.
+     * <p>
+     * After this method executes, and if the object implements
+     * <code>HttpSessionBindingListener</code>, the container calls
+     * <code>valueUnbound()</code> on the object.
+     *
+     * @param name
+     *            Name of the object to remove from this session.
+     * @param notify
+     *            Should we notify interested listeners that this attribute is
+     *            being removed?
+     *
+     * @exception IllegalStateException
+     *                if this method is called on an invalidated session
+     */
+    public void removeAttribute(String name, boolean notify) {
+        removeAttribute(name, notify, true);
+    }
+
+    public void removeAttribute(String name, boolean notify,boolean addDeltaRequest) {
+        // Validate our current state
+        if (!isValid()) throw new IllegalStateException(sm.getString("standardSession.removeAttribute.ise"));
+        removeAttributeInternal(name, notify, addDeltaRequest);
+    }
+
+    /**
+     * Bind an object to this session, using the specified name. If an object of
+     * the same name is already bound to this session, the object is replaced.
+     * <p>
+     * After this method executes, and if the object implements
+     * <code>HttpSessionBindingListener</code>, the container calls
+     * <code>valueBound()</code> on the object.
+     *
+     * @param name
+     *            Name to which the object is bound, cannot be null
+     * @param value
+     *            Object to be bound, cannot be null
+     *
+     * @exception IllegalArgumentException
+     *                if an attempt is made to add a non-serializable object in
+     *                an environment marked distributable.
+     * @exception IllegalStateException
+     *                if this method is called on an invalidated session
+     */
+    public void setAttribute(String name, Object value) {
+        setAttribute(name, value, true, true);
+    }
+
+    public void setAttribute(String name, Object value, boolean notify,boolean addDeltaRequest) {
+
+        // Name cannot be null
+        if (name == null) throw new IllegalArgumentException(sm.getString("standardSession.setAttribute.namenull"));
+
+        // Null value is the same as removeAttribute()
+        if (value == null) {
+            removeAttribute(name);
+            return;
+        }
+
+        try {
+            lock();
+            super.setAttribute(name,value, notify);
+            if (addDeltaRequest && (deltaRequest != null)) deltaRequest.setAttribute(name, value);
+        } finally {
+            unlock();
+        }
+    }
+
+    // -------------------------------------------- HttpSession Private Methods
+
+    /**
+     * Read a serialized version of this session object from the specified
+     * object input stream.
+     * <p>
+     * <b>IMPLEMENTATION NOTE </b>: The reference to the owning Manager is not
+     * restored by this method, and must be set explicitly.
+     *
+     * @param stream
+     *            The input stream to read from
+     *
+     * @exception ClassNotFoundException
+     *                if an unknown class is specified
+     * @exception IOException
+     *                if an input/output error occurs
+     */
+    private void readObject(ObjectInput stream) throws ClassNotFoundException, IOException {
+
+        // Deserialize the scalar instance variables (except Manager)
+        authType = null; // Transient only
+        creationTime = ( (Long) stream.readObject()).longValue();
+        lastAccessedTime = ( (Long) stream.readObject()).longValue();
+        maxInactiveInterval = ( (Integer) stream.readObject()).intValue();
+        isNew = ( (Boolean) stream.readObject()).booleanValue();
+        isValid = ( (Boolean) stream.readObject()).booleanValue();
+        thisAccessedTime = ( (Long) stream.readObject()).longValue();
+        version = ( (Long) stream.readObject()).longValue();
+        boolean hasPrincipal = stream.readBoolean();
+        principal = null;
+        if (hasPrincipal) {
+            principal = SerializablePrincipal.readPrincipal(stream,getManager().getContainer().getRealm());
+        }
+
+        //        setId((String) stream.readObject());
+        id = (String) stream.readObject();
+        if (log.isDebugEnabled()) log.debug(sm.getString("deltaSession.readSession", id));
+
+        // Deserialize the attribute count and attribute values
+        if (attributes == null) attributes = new Hashtable();
+        int n = ( (Integer) stream.readObject()).intValue();
+        boolean isValidSave = isValid;
+        isValid = true;
+        for (int i = 0; i < n; i++) {
+            String name = (String) stream.readObject();
+            Object value = (Object) stream.readObject();
+            if ( (value instanceof String) && (value.equals(NOT_SERIALIZED)))
+                continue;
+            attributes.put(name, value);
+        }
+        isValid = isValidSave;
+
+        if (listeners == null) {
+            listeners = new ArrayList();
+        }
+
+        if (notes == null) {
+            notes = new Hashtable();
+        }
+        activate();
+    }
+
+    public synchronized void writeExternal(ObjectOutput out ) throws java.io.IOException {
+        writeObject(out);
+    }
+
+
+    /**
+     * Write a serialized version of this session object to the specified object
+     * output stream.
+     * <p>
+     * <b>IMPLEMENTATION NOTE </b>: The owning Manager will not be stored in the
+     * serialized representation of this Session. After calling
+     * <code>readObject()</code>, you must set the associated Manager
+     * explicitly.
+     * <p>
+     * <b>IMPLEMENTATION NOTE </b>: Any attribute that is not Serializable will
+     * be unbound from the session, with appropriate actions if it implements
+     * HttpSessionBindingListener. If you do not want any such attributes, be
+     * sure the <code>distributable</code> property of the associated Manager
+     * is set to <code>true</code>.
+     *
+     * @param stream
+     *            The output stream to write to
+     *
+     * @exception IOException
+     *                if an input/output error occurs
+     */
+    private void writeObject(ObjectOutput stream) throws IOException {
+        // Write the scalar instance variables (except Manager)
+        stream.writeObject(new Long(creationTime));
+        stream.writeObject(new Long(lastAccessedTime));
+        stream.writeObject(new Integer(maxInactiveInterval));
+        stream.writeObject(new Boolean(isNew));
+        stream.writeObject(new Boolean(isValid));
+        stream.writeObject(new Long(thisAccessedTime));
+        stream.writeObject(new Long(version));
+        stream.writeBoolean(getPrincipal() != null);
+        if (getPrincipal() != null) {
+            SerializablePrincipal.writePrincipal((GenericPrincipal) principal,stream);
+        }
+
+        stream.writeObject(id);
+        if (log.isDebugEnabled()) log.debug(sm.getString("deltaSession.writeSession", id));
+
+        // Accumulate the names of serializable and non-serializable attributes
+        String keys[] = keys();
+        ArrayList saveNames = new ArrayList();
+        ArrayList saveValues = new ArrayList();
+        for (int i = 0; i < keys.length; i++) {
+            Object value = null;
+            value = attributes.get(keys[i]);
+            if (value == null)
+                continue;
+            else if (value instanceof Serializable) {
+                saveNames.add(keys[i]);
+                saveValues.add(value);
+            }
+        }
+
+        // Serialize the attribute count and the Serializable attributes
+        int n = saveNames.size();
+        stream.writeObject(new Integer(n));
+        for (int i = 0; i < n; i++) {
+            stream.writeObject( (String) saveNames.get(i));
+            try {
+                stream.writeObject(saveValues.get(i));
+            } catch (NotSerializableException e) {
+                log.error(sm.getString("standardSession.notSerializable",saveNames.get(i), id), e);
+                stream.writeObject(NOT_SERIALIZED);
+                log.error("  storing attribute '" + saveNames.get(i)+ "' with value NOT_SERIALIZED");
+            }
+        }
+
+    }
+
+    // -------------------------------------------------------- Private Methods
+
+    
+
+    /**
+     * Return the value of an attribute without a check for validity.
+     */
+    protected Object getAttributeInternal(String name) {
+        return (attributes.get(name));
+    }
+
+    protected void removeAttributeInternal(String name, boolean notify,
+                                           boolean addDeltaRequest) {
+        try {
+            lock();
+            // Remove this attribute from our collection
+            Object value = attributes.get(name);
+            if (value == null) return;
+
+            super.removeAttributeInternal(name,notify);
+            if (addDeltaRequest && (deltaRequest != null)) deltaRequest.removeAttribute(name);
+
+        }finally {
+            unlock();
+        }
+    }
+
+    protected long getLastTimeReplicated() {
+        return lastTimeReplicated;
+    }
+
+    public long getVersion() {
+        return version;
+    }
+
+    protected void setLastTimeReplicated(long lastTimeReplicated) {
+        this.lastTimeReplicated = lastTimeReplicated;
+    }
+
+    public void setVersion(long version) {
+        this.version = version;
+    }
+
+    protected void setAccessCount(int count) {
+        if ( accessCount == null && ACTIVITY_CHECK ) accessCount = new AtomicInteger();
+        if ( accessCount != null ) super.accessCount.set(count);
+    }
+}
+
+// -------------------------------------------------------------- Private Class
+
+/**
+ * This class is a dummy implementation of the <code>HttpSessionContext</code>
+ * interface, to conform to the requirement that such an object be returned when
+ * <code>HttpSession.getSessionContext()</code> is called.
+ *
+ * @author Craig R. McClanahan
+ *
+ * @deprecated As of Java Servlet API 2.1 with no replacement. The interface
+ *             will be removed in a future version of this API.
+ */
+
+final class StandardSessionContext
+    implements HttpSessionContext {
+
+    private HashMap dummy = new HashMap();
+
+    /**
+     * Return the session identifiers of all sessions defined within this
+     * context.
+     *
+     * @deprecated As of Java Servlet API 2.1 with no replacement. This method
+     *             must return an empty <code>Enumeration</code> and will be
+     *             removed in a future version of the API.
+     */
+    public Enumeration getIds() {
+        return (new Enumerator(dummy));
+    }
+
+    /**
+     * Return the <code>HttpSession</code> associated with the specified
+     * session identifier.
+     *
+     * @param id
+     *            Session identifier for which to look up a session
+     *
+     * @deprecated As of Java Servlet API 2.1 with no replacement. This method
+     *             must return null and will be removed in a future version of
+     *             the API.
+     */
+    public HttpSession getSession(String id) {
+        return (null);
+    }
+
+}

==================================================
JvmRouteSessionIDBinderListener.java
index 691f1e51af..b0e0a0b38c 100644
--- a/java/org/apache/catalina/ha/session/JvmRouteBinderValve.java
+++ b/java/org/apache/catalina/ha/session/JvmRouteBinderValve.java
@@ -1,543 +1,544 @@
-/*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.ha.session;
-
-import java.io.IOException;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.Cookie;
-
-import org.apache.catalina.Container;
-import org.apache.catalina.Context;
-import org.apache.catalina.Engine;
-import org.apache.catalina.Globals;
-import org.apache.catalina.Host;
-import org.apache.catalina.Lifecycle;
-import org.apache.catalina.LifecycleException;
-import org.apache.catalina.LifecycleListener;
-import org.apache.catalina.Manager;
-import org.apache.catalina.Session;
-import org.apache.catalina.ha.CatalinaCluster;
-import org.apache.catalina.ha.ClusterManager;
-import org.apache.catalina.ha.ClusterMessage;
-import org.apache.catalina.ha.ClusterValve;
-import org.apache.catalina.connector.Request;
-import org.apache.catalina.connector.Response;
-import org.apache.catalina.session.ManagerBase;
-import org.apache.catalina.util.LifecycleSupport;
-import org.apache.catalina.util.StringManager;
-import org.apache.catalina.valves.ValveBase;
-
-/**
- * Valve to handle Tomcat jvmRoute takeover using mod_jk module after node
- * failure. After a node crashed the next request going to other cluster node.
- * Now the answering from apache is slower ( make some error handshaking. Very
- * bad with apache at my windows.). We rewrite now the cookie jsessionid
- * information to the backup cluster node. After the next response all client
- * request goes direct to the backup node. The change sessionid send also to all
- * other cluster nodes. Well, now the session stickyness work directly to the
- * backup node and traffic don't go back too restarted cluster nodes!
- * 
- * At all cluster node you must configure the as ClusterListener since 5.5.10
- * {@link org.apache.catalina.ha.session.JvmRouteSessionIDBinderListener JvmRouteSessionIDBinderListener}
- * or before with
- * org.apache.catalina.ha.session.JvmRouteSessionIDBinderListenerLifecycle.
- * 
- * Add this Valve to your host definition at conf/server.xml .
- * 
- * Since 5.5.10 as direct cluster valve:<br/>
- * <pre>
- *  &lt;Cluster&gt;
- *  &lt;Valve className=&quot;org.apache.catalina.ha.session.JvmRouteBinderValve&quot; /&gt;  
- *  &lt;/Cluster&gt;
- * </pre>
- * <br />
- * Before 5.5.10 as Host element:<br/>
- * <pre>
- *  &lt;Hostr&gt;
- *  &lt;Valve className=&quot;org.apache.catalina.ha.session.JvmRouteBinderValve&quot; /&gt;  
- *  &lt;/Hostr&gt;
- * </pre>
- * 
- * Trick:<br/>
- * You can enable this mod_jk turnover mode via JMX before you drop a node to all backup nodes!
- * Set enable true on all JvmRouteBinderValve backups, disable worker at mod_jk 
- * and then drop node and restart it! Then enable mod_jk Worker and disable JvmRouteBinderValves again. 
- * This use case means that only requested session are migrated.
- * 
- * @author Peter Rossbach
- * @version $Revision: 326110 $ $Date: 2005-10-18 09:08:36 -0500 (Tue, 18 Oct 2005) $
- */
-public class JvmRouteBinderValve extends ValveBase implements ClusterValve, Lifecycle {
-
-    /*--Static Variables----------------------------------------*/
-    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory
-            .getLog(JvmRouteBinderValve.class);
-
-    /**
-     * The descriptive information about this implementation.
-     */
-    protected static final String info = "org.apache.catalina.ha.session.JvmRouteBinderValve/1.2";
-
-    /*--Instance Variables--------------------------------------*/
-
-    /**
-     * the cluster
-     */
-    protected CatalinaCluster cluster;
-
-    /**
-     * The string manager for this package.
-     */
-    protected StringManager sm = StringManager.getManager(Constants.Package);
-
-    /**
-     * Has this component been started yet?
-     */
-    protected boolean started = false;
-
-    /**
-     * enabled this component
-     */
-    protected boolean enabled = true;
-
-    /**
-     * number of session that no at this tomcat instanz hosted
-     */
-    protected long numberOfSessions = 0;
-
-    protected String sessionIdAttribute = "org.apache.catalina.ha.session.JvmRouteOrignalSessionID";
-
-    /**
-     * The lifecycle event support for this component.
-     */
-    protected LifecycleSupport lifecycle = new LifecycleSupport(this);
-
-    /*--Logic---------------------------------------------------*/
-
-    /**
-     * Return descriptive information about this implementation.
-     */
-    public String getInfo() {
-
-        return (info);
-
-    }
-
-    /**
-     * set session id attribute to failed node for request.
-     * 
-     * @return Returns the sessionIdAttribute.
-     */
-    public String getSessionIdAttribute() {
-        return sessionIdAttribute;
-    }
-
-    /**
-     * get name of failed reqeust session attribute
-     * 
-     * @param sessionIdAttribute
-     *            The sessionIdAttribute to set.
-     */
-    public void setSessionIdAttribute(String sessionIdAttribute) {
-        this.sessionIdAttribute = sessionIdAttribute;
-    }
-
-    /**
-     * @return Returns the number of migrated sessions.
-     */
-    public long getNumberOfSessions() {
-        return numberOfSessions;
-    }
-
-    /**
-     * @return Returns the enabled.
-     */
-    public boolean getEnabled() {
-        return enabled;
-    }
-
-    /**
-     * @param enabled
-     *            The enabled to set.
-     */
-    public void setEnabled(boolean enabled) {
-        this.enabled = enabled;
-    }
-
-    /**
-     * Detect possible the JVMRoute change at cluster backup node..
-     * 
-     * @param request
-     *            tomcat request being processed
-     * @param response
-     *            tomcat response being processed
-     * @exception IOException
-     *                if an input/output error has occurred
-     * @exception ServletException
-     *                if a servlet error has occurred
-     */
-    public void invoke(Request request, Response response) throws IOException,
-            ServletException {
-
-         if (getEnabled() 
-             && getCluster() != null
-             && request.getContext() != null
-             && request.getContext().getDistributable() ) {
-             // valve cluster can access manager - other cluster handle turnover 
-             // at host level - hopefully!
-             Manager manager = request.getContext().getManager();
-             if (manager != null && manager instanceof ClusterManager
-                     && getCluster().getManager(((ClusterManager)manager).getName()) != null)
-                 handlePossibleTurnover(request, response);
-        }
-        // Pass this request on to the next valve in our pipeline
-        getNext().invoke(request, response);
-    }
-
-    /**
-     * handle possible session turn over.
-     * 
-     * @see JvmRouteBinderValve#handleJvmRoute(Request, Response, String, String)
-     * @param request current request
-     * @param response current response
-     */
-    protected void handlePossibleTurnover(Request request, Response response) {
-        Session session = request.getSessionInternal(false);
-        if (session != null) {
-            long t1 = System.currentTimeMillis();
-            String jvmRoute = getLocalJvmRoute(request);
-            if (jvmRoute == null) {
-                if (log.isDebugEnabled())
-                    log.debug(sm.getString("jvmRoute.missingJvmRouteAttribute"));
-                return;
-            }
-            handleJvmRoute( request, response,session.getIdInternal(), jvmRoute);
-            if (log.isDebugEnabled()) {
-                long t2 = System.currentTimeMillis();
-                long time = t2 - t1;
-                log.debug(sm.getString("jvmRoute.turnoverInfo", new Long(time)));
-            }
-        }
-    }
-
-    /**
-     * get jvmroute from engine
-     * 
-     * @param request current request
-     * @return return jvmRoute from ManagerBase or null
-     */
-    protected String getLocalJvmRoute(Request request) {
-        Manager manager = getManager(request);
-        if(manager instanceof ManagerBase)
-            return ((ManagerBase) manager).getJvmRoute();
-        return null ;
-    }
-
-    /**
-     * get Cluster DeltaManager
-     * 
-     * @param request current request
-     * @return manager or null
-     */
-    protected Manager getManager(Request request) {
-        Manager manager = request.getContext().getManager();
-        if (log.isDebugEnabled()) {
-            if(manager != null)
-                log.debug(sm.getString("jvmRoute.foundManager", manager,  request.getContext().getName()));
-            else 
-                log.debug(sm.getString("jvmRoute.notFoundManager", manager,  request.getContext().getName()));
-        }
-        return manager;
-    }
-
-    /**
-     * @return Returns the cluster.
-     */
-    public CatalinaCluster getCluster() {
-        return cluster;
-    }
-    
-    /**
-     * @param cluster The cluster to set.
-     */
-    public void setCluster(CatalinaCluster cluster) {
-        this.cluster = cluster;
-    }
-    
-    /**
-     * Handle jvmRoute stickyness after tomcat instance failed. After this
-     * correction a new Cookie send to client with new jvmRoute and the
-     * SessionID change propage to the other cluster nodes.
-     * 
-     * @param request current request
-     * @param response
-     *            Tomcat Response
-     * @param sessionId
-     *            request SessionID from Cookie
-     * @param localJvmRoute
-     *            local jvmRoute
-     */
-    protected void handleJvmRoute(
-            Request request, Response response,String sessionId, String localJvmRoute) {
-        // get requested jvmRoute.
-        String requestJvmRoute = null;
-        int index = sessionId.indexOf(".");
-        if (index > 0) {
-            requestJvmRoute = sessionId
-                    .substring(index + 1, sessionId.length());
-        }
-        if (requestJvmRoute != null && !requestJvmRoute.equals(localJvmRoute)) {
-            if (log.isDebugEnabled()) {
-                log.debug(sm.getString("jvmRoute.failover", requestJvmRoute,
-                        localJvmRoute, sessionId));
-            }
-            // OK - turnover the session ?
-            String newSessionID = sessionId.substring(0, index) + "."
-                    + localJvmRoute;
-            Session catalinaSession = null;
-            try {
-                catalinaSession = getManager(request).findSession(sessionId);
-            } catch (IOException e) {
-                // Hups!
-            }
-            if (catalinaSession != null) {
-                changeSessionID(request, response, sessionId, newSessionID,
-                        catalinaSession);
-                numberOfSessions++;
-            } else {
-                if (log.isDebugEnabled()) {
-                    log.debug(sm.getString("jvmRoute.cannotFindSession",
-                            sessionId));
-                }
-            }
-        }
-    }
-
-    /**
-     * change session id and send to all cluster nodes
-     * 
-     * @param request current request
-     * @param response current response
-     * @param sessionId
-     *            original session id
-     * @param newSessionID
-     *            new session id for node migration
-     * @param catalinaSession
-     *            current session with original session id
-     */
-    protected void changeSessionID(Request request,
-            Response response, String sessionId, String newSessionID, Session catalinaSession) {
-        lifecycle.fireLifecycleEvent("Before session migration",
-                catalinaSession);
-        request.setRequestedSessionId(newSessionID);
-        catalinaSession.setId(newSessionID);
-        if (catalinaSession instanceof DeltaSession)
-            ((DeltaSession) catalinaSession).resetDeltaRequest();
-        if(request.isRequestedSessionIdFromCookie()) setNewSessionCookie(request, response,newSessionID);
-        // set orginal sessionid at request, to allow application detect the
-        // change
-        if (sessionIdAttribute != null && !"".equals(sessionIdAttribute)) {
-            if (log.isDebugEnabled()) {
-                log.debug(sm.getString("jvmRoute.set.orignalsessionid",sessionIdAttribute,sessionId));
-            }
-            request.setAttribute(sessionIdAttribute, sessionId);
-        }
-        // now sending the change to all other clusternode!
-        ClusterManager manager = (ClusterManager)catalinaSession.getManager();
-        sendSessionIDClusterBackup(manager,request,sessionId, newSessionID);
-        lifecycle
-                .fireLifecycleEvent("After session migration", catalinaSession);
-        if (log.isDebugEnabled()) {
-            log.debug(sm.getString("jvmRoute.changeSession", sessionId,
-                    newSessionID));
-        }
-    }
-
-    /**
-     * Send the changed Sessionid to all clusternodes.
-     * 
-     * @see JvmRouteSessionIDBinderListener#messageReceived(ClusterMessage)
-     * @param manager
-     *            ClusterManager
-     * @param sessionId
-     *            current failed sessionid
-     * @param newSessionID
-     *            new session id, bind to the new cluster node
-     */
-    protected void sendSessionIDClusterBackup(ClusterManager manager,Request request,String sessionId,
-            String newSessionID) {
-        SessionIDMessage msg = new SessionIDMessage();
-        msg.setOrignalSessionID(sessionId);
-        msg.setBackupSessionID(newSessionID);
-        Context context = request.getContext();
-        msg.setContextPath(context.getPath());
-        msg.setHost(context.getParent().getName());
-        if(manager.doDomainReplication())
-            cluster.sendClusterDomain(msg);
-        else
-            cluster.send(msg);
-    }
-
-    /**
-     * Sets a new cookie for the given session id and response and see
-     * {@link org.apache.catalina.connector.Request#configureSessionCookie(javax.servlet.http.Cookie)}
-     * 
-     * @param request current request
-     * @param response Tomcat Response
-     * @param sessionId The session id
-     */
-    protected void setNewSessionCookie(Request request,
-                                       Response response, String sessionId) {
-        if (response != null) {
-            Context context = request.getContext();
-            if (context.getCookies()) {
-                // set a new session cookie
-                Cookie newCookie = new Cookie(Globals.SESSION_COOKIE_NAME,
-                        sessionId);
-                newCookie.setMaxAge(-1);
-                String contextPath = null;
-                if (!response.getConnector().getEmptySessionPath()
-                        && (context != null)) {
-                    contextPath = context.getEncodedPath();
-                }
-                if ((contextPath != null) && (contextPath.length() > 0)) {
-                    newCookie.setPath(contextPath);
-                } else {
-                    newCookie.setPath("/");
-                }
-                if (request.isSecure()) {
-                    newCookie.setSecure(true);
-                }
-                if (log.isDebugEnabled()) {
-                    log.debug(sm.getString("jvmRoute.newSessionCookie",
-                            sessionId, Globals.SESSION_COOKIE_NAME, newCookie
-                                    .getPath(), new Boolean(newCookie
-                                    .getSecure())));
-                }
-                response.addCookie(newCookie);
-            }
-        }
-    }
-
-    // ------------------------------------------------------ Lifecycle Methods
-
-    /**
-     * Add a lifecycle event listener to this component.
-     * 
-     * @param listener
-     *            The listener to add
-     */
-    public void addLifecycleListener(LifecycleListener listener) {
-
-        lifecycle.addLifecycleListener(listener);
-
-    }
-
-    /**
-     * Get the lifecycle listeners associated with this lifecycle. If this
-     * Lifecycle has no listeners registered, a zero-length array is returned.
-     */
-    public LifecycleListener[] findLifecycleListeners() {
-
-        return lifecycle.findLifecycleListeners();
-
-    }
-
-    /**
-     * Remove a lifecycle event listener from this component.
-     * 
-     * @param listener
-     *            The listener to add
-     */
-    public void removeLifecycleListener(LifecycleListener listener) {
-
-        lifecycle.removeLifecycleListener(listener);
-
-    }
-
-    /**
-     * Prepare for the beginning of active use of the public methods of this
-     * component. This method should be called after <code>configure()</code>,
-     * and before any of the public methods of the component are utilized.
-     * 
-     * @exception LifecycleException
-     *                if this component detects a fatal error that prevents this
-     *                component from being used
-     */
-    public void start() throws LifecycleException {
-
-        // Validate and update our current component state
-        if (started)
-            throw new LifecycleException(sm
-                    .getString("jvmRoute.valve.alreadyStarted"));
-        lifecycle.fireLifecycleEvent(START_EVENT, null);
-        started = true;
-        if (cluster == null) {
-            Container hostContainer = getContainer();
-            // compatibility with JvmRouteBinderValve version 1.1
-            // ( setup at context.xml or context.xml.default )
-            if (!(hostContainer instanceof Host)) {
-                if (log.isWarnEnabled())
-                    log.warn(sm.getString("jvmRoute.configure.warn"));
-                hostContainer = hostContainer.getParent();
-            }
-            if (hostContainer instanceof Host
-                    && ((Host) hostContainer).getCluster() != null) {
-                cluster = (CatalinaCluster) ((Host) hostContainer).getCluster();
-            } else {
-                Container engine = hostContainer.getParent() ;
-                if (engine instanceof Engine
-                        && ((Engine) engine).getCluster() != null) {
-                    cluster = (CatalinaCluster) ((Engine) engine).getCluster();
-                }
-            }
-        }
-        if (cluster == null) {
-            throw new RuntimeException("No clustering support at container "
-                    + container.getName());
-        }
-        
-        if (log.isInfoEnabled())
-            log.info(sm.getString("jvmRoute.valve.started"));
-
-    }
-
-    /**
-     * Gracefully terminate the active use of the public methods of this
-     * component. This method should be the last one called on a given instance
-     * of this component.
-     * 
-     * @exception LifecycleException
-     *                if this component detects a fatal error that needs to be
-     *                reported
-     */
-    public void stop() throws LifecycleException {
-
-        // Validate and update our current component state
-        if (!started)
-            throw new LifecycleException(sm
-                    .getString("jvmRoute.valve.notStarted"));
-        lifecycle.fireLifecycleEvent(STOP_EVENT, null);
-        started = false;
-        cluster = null;
-        numberOfSessions = 0;
-        if (log.isInfoEnabled())
-            log.info(sm.getString("jvmRoute.valve.stopped"));
-
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.ha.session;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.Cookie;
+
+import org.apache.catalina.Container;
+import org.apache.catalina.Context;
+import org.apache.catalina.Engine;
+import org.apache.catalina.Globals;
+import org.apache.catalina.Host;
+import org.apache.catalina.Lifecycle;
+import org.apache.catalina.LifecycleException;
+import org.apache.catalina.LifecycleListener;
+import org.apache.catalina.Manager;
+import org.apache.catalina.Session;
+import org.apache.catalina.ha.CatalinaCluster;
+import org.apache.catalina.ha.ClusterManager;
+import org.apache.catalina.ha.ClusterMessage;
+import org.apache.catalina.ha.ClusterValve;
+import org.apache.catalina.connector.Request;
+import org.apache.catalina.connector.Response;
+import org.apache.catalina.session.ManagerBase;
+import org.apache.catalina.util.LifecycleSupport;
+import org.apache.catalina.util.StringManager;
+import org.apache.catalina.valves.ValveBase;
+
+/**
+ * Valve to handle Tomcat jvmRoute takeover using mod_jk module after node
+ * failure. After a node crashed the next request going to other cluster node.
+ * Now the answering from apache is slower ( make some error handshaking. Very
+ * bad with apache at my windows.). We rewrite now the cookie jsessionid
+ * information to the backup cluster node. After the next response all client
+ * request goes direct to the backup node. The change sessionid send also to all
+ * other cluster nodes. Well, now the session stickyness work directly to the
+ * backup node and traffic don't go back too restarted cluster nodes!
+ * 
+ * At all cluster node you must configure the as ClusterListener since 5.5.10
+ * {@link org.apache.catalina.ha.session.JvmRouteSessionIDBinderListener JvmRouteSessionIDBinderListener}
+ * or before with
+ * org.apache.catalina.ha.session.JvmRouteSessionIDBinderListenerLifecycle.
+ * 
+ * Add this Valve to your host definition at conf/server.xml .
+ * 
+ * Since 5.5.10 as direct cluster valve:<br/>
+ * <pre>
+ *  &lt;Cluster&gt;
+ *  &lt;Valve className=&quot;org.apache.catalina.ha.session.JvmRouteBinderValve&quot; /&gt;  
+ *  &lt;/Cluster&gt;
+ * </pre>
+ * <br />
+ * Before 5.5.10 as Host element:<br/>
+ * <pre>
+ *  &lt;Hostr&gt;
+ *  &lt;Valve className=&quot;org.apache.catalina.ha.session.JvmRouteBinderValve&quot; /&gt;  
+ *  &lt;/Hostr&gt;
+ * </pre>
+ * 
+ * Trick:<br/>
+ * You can enable this mod_jk turnover mode via JMX before you drop a node to all backup nodes!
+ * Set enable true on all JvmRouteBinderValve backups, disable worker at mod_jk 
+ * and then drop node and restart it! Then enable mod_jk Worker and disable JvmRouteBinderValves again. 
+ * This use case means that only requested session are migrated.
+ * 
+ * @author Peter Rossbach
+ * @version $Revision: 326110 $ $Date: 2005-10-18 09:08:36 -0500 (Tue, 18 Oct 2005) $
+ */
+public class JvmRouteBinderValve extends ValveBase implements ClusterValve, Lifecycle {
+
+    /*--Static Variables----------------------------------------*/
+    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory
+            .getLog(JvmRouteBinderValve.class);
+
+    /**
+     * The descriptive information about this implementation.
+     */
+    protected static final String info = "org.apache.catalina.ha.session.JvmRouteBinderValve/1.2";
+
+    /*--Instance Variables--------------------------------------*/
+
+    /**
+     * the cluster
+     */
+    protected CatalinaCluster cluster;
+
+    /**
+     * The string manager for this package.
+     */
+    protected StringManager sm = StringManager.getManager(Constants.Package);
+
+    /**
+     * Has this component been started yet?
+     */
+    protected boolean started = false;
+
+    /**
+     * enabled this component
+     */
+    protected boolean enabled = true;
+
+    /**
+     * number of session that no at this tomcat instanz hosted
+     */
+    protected long numberOfSessions = 0;
+
+    protected String sessionIdAttribute = "org.apache.catalina.ha.session.JvmRouteOrignalSessionID";
+
+    /**
+     * The lifecycle event support for this component.
+     */
+    protected LifecycleSupport lifecycle = new LifecycleSupport(this);
+
+    /*--Logic---------------------------------------------------*/
+
+    /**
+     * Return descriptive information about this implementation.
+     */
+    public String getInfo() {
+
+        return (info);
+
+    }
+
+    /**
+     * set session id attribute to failed node for request.
+     * 
+     * @return Returns the sessionIdAttribute.
+     */
+    public String getSessionIdAttribute() {
+        return sessionIdAttribute;
+    }
+
+    /**
+     * get name of failed reqeust session attribute
+     * 
+     * @param sessionIdAttribute
+     *            The sessionIdAttribute to set.
+     */
+    public void setSessionIdAttribute(String sessionIdAttribute) {
+        this.sessionIdAttribute = sessionIdAttribute;
+    }
+
+    /**
+     * @return Returns the number of migrated sessions.
+     */
+    public long getNumberOfSessions() {
+        return numberOfSessions;
+    }
+
+    /**
+     * @return Returns the enabled.
+     */
+    public boolean getEnabled() {
+        return enabled;
+    }
+
+    /**
+     * @param enabled
+     *            The enabled to set.
+     */
+    public void setEnabled(boolean enabled) {
+        this.enabled = enabled;
+    }
+
+    /**
+     * Detect possible the JVMRoute change at cluster backup node..
+     * 
+     * @param request
+     *            tomcat request being processed
+     * @param response
+     *            tomcat response being processed
+     * @exception IOException
+     *                if an input/output error has occurred
+     * @exception ServletException
+     *                if a servlet error has occurred
+     */
+    public void invoke(Request request, Response response) throws IOException,
+            ServletException {
+
+         if (getEnabled() 
+             && getCluster() != null
+             && request.getContext() != null
+             && request.getContext().getDistributable() ) {
+             // valve cluster can access manager - other cluster handle turnover 
+             // at host level - hopefully!
+             Manager manager = request.getContext().getManager();
+             if (manager != null && manager instanceof ClusterManager
+                     && getCluster().getManager(((ClusterManager)manager).getName()) != null)
+                 handlePossibleTurnover(request, response);
+        }
+        // Pass this request on to the next valve in our pipeline
+        getNext().invoke(request, response);
+    }
+
+    /**
+     * handle possible session turn over.
+     * 
+     * @see JvmRouteBinderValve#handleJvmRoute(Request, Response, String, String)
+     * @param request current request
+     * @param response current response
+     */
+    protected void handlePossibleTurnover(Request request, Response response) {
+        Session session = request.getSessionInternal(false);
+        if (session != null) {
+            long t1 = System.currentTimeMillis();
+            String jvmRoute = getLocalJvmRoute(request);
+            if (jvmRoute == null) {
+                if (log.isDebugEnabled())
+                    log.debug(sm.getString("jvmRoute.missingJvmRouteAttribute"));
+                return;
+            }
+            handleJvmRoute( request, response,session.getIdInternal(), jvmRoute);
+            if (log.isDebugEnabled()) {
+                long t2 = System.currentTimeMillis();
+                long time = t2 - t1;
+                log.debug(sm.getString("jvmRoute.turnoverInfo", new Long(time)));
+            }
+        }
+    }
+
+    /**
+     * get jvmroute from engine
+     * 
+     * @param request current request
+     * @return return jvmRoute from ManagerBase or null
+     */
+    protected String getLocalJvmRoute(Request request) {
+        Manager manager = getManager(request);
+        if(manager instanceof ManagerBase)
+            return ((ManagerBase) manager).getJvmRoute();
+        return null ;
+    }
+
+    /**
+     * get Cluster DeltaManager
+     * 
+     * @param request current request
+     * @return manager or null
+     */
+    protected Manager getManager(Request request) {
+        Manager manager = request.getContext().getManager();
+        if (log.isDebugEnabled()) {
+            if(manager != null)
+                log.debug(sm.getString("jvmRoute.foundManager", manager,  request.getContext().getName()));
+            else 
+                log.debug(sm.getString("jvmRoute.notFoundManager", manager,  request.getContext().getName()));
+        }
+        return manager;
+    }
+
+    /**
+     * @return Returns the cluster.
+     */
+    public CatalinaCluster getCluster() {
+        return cluster;
+    }
+    
+    /**
+     * @param cluster The cluster to set.
+     */
+    public void setCluster(CatalinaCluster cluster) {
+        this.cluster = cluster;
+    }
+    
+    /**
+     * Handle jvmRoute stickyness after tomcat instance failed. After this
+     * correction a new Cookie send to client with new jvmRoute and the
+     * SessionID change propage to the other cluster nodes.
+     * 
+     * @param request current request
+     * @param response
+     *            Tomcat Response
+     * @param sessionId
+     *            request SessionID from Cookie
+     * @param localJvmRoute
+     *            local jvmRoute
+     */
+    protected void handleJvmRoute(
+            Request request, Response response,String sessionId, String localJvmRoute) {
+        // get requested jvmRoute.
+        String requestJvmRoute = null;
+        int index = sessionId.indexOf(".");
+        if (index > 0) {
+            requestJvmRoute = sessionId
+                    .substring(index + 1, sessionId.length());
+        }
+        if (requestJvmRoute != null && !requestJvmRoute.equals(localJvmRoute)) {
+            if (log.isDebugEnabled()) {
+                log.debug(sm.getString("jvmRoute.failover", requestJvmRoute,
+                        localJvmRoute, sessionId));
+            }
+            // OK - turnover the session ?
+            String newSessionID = sessionId.substring(0, index) + "."
+                    + localJvmRoute;
+            Session catalinaSession = null;
+            try {
+                catalinaSession = getManager(request).findSession(sessionId);
+            } catch (IOException e) {
+                // Hups!
+            }
+            if (catalinaSession != null) {
+                changeSessionID(request, response, sessionId, newSessionID,
+                        catalinaSession);
+                numberOfSessions++;
+            } else {
+                if (log.isDebugEnabled()) {
+                    log.debug(sm.getString("jvmRoute.cannotFindSession",
+                            sessionId));
+                }
+            }
+        }
+    }
+
+    /**
+     * change session id and send to all cluster nodes
+     * 
+     * @param request current request
+     * @param response current response
+     * @param sessionId
+     *            original session id
+     * @param newSessionID
+     *            new session id for node migration
+     * @param catalinaSession
+     *            current session with original session id
+     */
+    protected void changeSessionID(Request request,
+            Response response, String sessionId, String newSessionID, Session catalinaSession) {
+        lifecycle.fireLifecycleEvent("Before session migration",
+                catalinaSession);
+        request.setRequestedSessionId(newSessionID);
+        catalinaSession.setId(newSessionID);
+        if (catalinaSession instanceof DeltaSession)
+            ((DeltaSession) catalinaSession).resetDeltaRequest();
+        if(request.isRequestedSessionIdFromCookie()) setNewSessionCookie(request, response,newSessionID);
+        // set orginal sessionid at request, to allow application detect the
+        // change
+        if (sessionIdAttribute != null && !"".equals(sessionIdAttribute)) {
+            if (log.isDebugEnabled()) {
+                log.debug(sm.getString("jvmRoute.set.orignalsessionid",sessionIdAttribute,sessionId));
+            }
+            request.setAttribute(sessionIdAttribute, sessionId);
+        }
+        // now sending the change to all other clusternode!
+        ClusterManager manager = (ClusterManager)catalinaSession.getManager();
+        sendSessionIDClusterBackup(manager,request,sessionId, newSessionID);
+        lifecycle
+                .fireLifecycleEvent("After session migration", catalinaSession);
+        if (log.isDebugEnabled()) {
+            log.debug(sm.getString("jvmRoute.changeSession", sessionId,
+                    newSessionID));
+        }
+    }
+
+    /**
+     * Send the changed Sessionid to all clusternodes.
+     * 
+     * @see JvmRouteSessionIDBinderListener#messageReceived(ClusterMessage)
+     * @param manager
+     *            ClusterManager
+     * @param sessionId
+     *            current failed sessionid
+     * @param newSessionID
+     *            new session id, bind to the new cluster node
+     */
+    protected void sendSessionIDClusterBackup(ClusterManager manager,Request request,String sessionId,
+            String newSessionID) {
+        SessionIDMessage msg = new SessionIDMessage();
+        msg.setOrignalSessionID(sessionId);
+        msg.setBackupSessionID(newSessionID);
+        Context context = request.getContext();
+        msg.setContextPath(context.getPath());
+        msg.setHost(context.getParent().getName());
+        if(manager.doDomainReplication())
+            cluster.sendClusterDomain(msg);
+        else
+            cluster.send(msg);
+    }
+
+    /**
+     * Sets a new cookie for the given session id and response and see
+     * {@link org.apache.catalina.connector.Request#configureSessionCookie(javax.servlet.http.Cookie)}
+     * 
+     * @param request current request
+     * @param response Tomcat Response
+     * @param sessionId The session id
+     */
+    protected void setNewSessionCookie(Request request,
+                                       Response response, String sessionId) {
+        if (response != null) {
+            Context context = request.getContext();
+            if (context.getCookies()) {
+                // set a new session cookie
+                Cookie newCookie = new Cookie(Globals.SESSION_COOKIE_NAME,
+                        sessionId);
+                newCookie.setMaxAge(-1);
+                String contextPath = null;
+                if (!response.getConnector().getEmptySessionPath()
+                        && (context != null)) {
+                    contextPath = context.getEncodedPath();
+                }
+                if ((contextPath != null) && (contextPath.length() > 0)) {
+                    newCookie.setPath(contextPath);
+                } else {
+                    newCookie.setPath("/");
+                }
+                if (request.isSecure()) {
+                    newCookie.setSecure(true);
+                }
+                if (log.isDebugEnabled()) {
+                    log.debug(sm.getString("jvmRoute.newSessionCookie",
+                            sessionId, Globals.SESSION_COOKIE_NAME, newCookie
+                                    .getPath(), new Boolean(newCookie
+                                    .getSecure())));
+                }
+                response.addCookie(newCookie);
+            }
+        }
+    }
+
+    // ------------------------------------------------------ Lifecycle Methods
+
+    /**
+     * Add a lifecycle event listener to this component.
+     * 
+     * @param listener
+     *            The listener to add
+     */
+    public void addLifecycleListener(LifecycleListener listener) {
+
+        lifecycle.addLifecycleListener(listener);
+
+    }
+
+    /**
+     * Get the lifecycle listeners associated with this lifecycle. If this
+     * Lifecycle has no listeners registered, a zero-length array is returned.
+     */
+    public LifecycleListener[] findLifecycleListeners() {
+
+        return lifecycle.findLifecycleListeners();
+
+    }
+
+    /**
+     * Remove a lifecycle event listener from this component.
+     * 
+     * @param listener
+     *            The listener to add
+     */
+    public void removeLifecycleListener(LifecycleListener listener) {
+
+        lifecycle.removeLifecycleListener(listener);
+
+    }
+
+    /**
+     * Prepare for the beginning of active use of the public methods of this
+     * component. This method should be called after <code>configure()</code>,
+     * and before any of the public methods of the component are utilized.
+     * 
+     * @exception LifecycleException
+     *                if this component detects a fatal error that prevents this
+     *                component from being used
+     */
+    public void start() throws LifecycleException {
+
+        // Validate and update our current component state
+        if (started)
+            throw new LifecycleException(sm
+                    .getString("jvmRoute.valve.alreadyStarted"));
+        lifecycle.fireLifecycleEvent(START_EVENT, null);
+        started = true;
+        if (cluster == null) {
+            Container hostContainer = getContainer();
+            // compatibility with JvmRouteBinderValve version 1.1
+            // ( setup at context.xml or context.xml.default )
+            if (!(hostContainer instanceof Host)) {
+                if (log.isWarnEnabled())
+                    log.warn(sm.getString("jvmRoute.configure.warn"));
+                hostContainer = hostContainer.getParent();
+            }
+            if (hostContainer instanceof Host
+                    && ((Host) hostContainer).getCluster() != null) {
+                cluster = (CatalinaCluster) ((Host) hostContainer).getCluster();
+            } else {
+                Container engine = hostContainer.getParent() ;
+                if (engine instanceof Engine
+                        && ((Engine) engine).getCluster() != null) {
+                    cluster = (CatalinaCluster) ((Engine) engine).getCluster();
+                }
+            }
+        }
+        if (cluster == null) {
+            throw new RuntimeException("No clustering support at container "
+                    + container.getName());
+        }
+        
+        if (log.isInfoEnabled())
+            log.info(sm.getString("jvmRoute.valve.started"));
+
+    }
+
+    /**
+     * Gracefully terminate the active use of the public methods of this
+     * component. This method should be the last one called on a given instance
+     * of this component.
+     * 
+     * @exception LifecycleException
+     *                if this component detects a fatal error that needs to be
+     *                reported
+     */
+    public void stop() throws LifecycleException {
+
+        // Validate and update our current component state
+        if (!started)
+            throw new LifecycleException(sm
+                    .getString("jvmRoute.valve.notStarted"));
+        lifecycle.fireLifecycleEvent(STOP_EVENT, null);
+        started = false;
+        cluster = null;
+        numberOfSessions = 0;
+        if (log.isInfoEnabled())
+            log.info(sm.getString("jvmRoute.valve.stopped"));
+
+    }
+
+}

==================================================
ReplicatedSession.java
index 3d23939a94..509a136400 100644
--- a/java/org/apache/catalina/ha/session/JvmRouteSessionIDBinderListener.java
+++ b/java/org/apache/catalina/ha/session/JvmRouteSessionIDBinderListener.java
@@ -1,166 +1,167 @@
-/*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha.session;
-
-import java.io.IOException;
-
-import org.apache.catalina.Container;
-import org.apache.catalina.Context;
-import org.apache.catalina.Engine;
-import org.apache.catalina.LifecycleException;
-import org.apache.catalina.Session;
-import org.apache.catalina.ha.ClusterMessage;
-import org.apache.catalina.core.StandardEngine;
-import org.apache.catalina.ha.*;
-
-/**
- * Receive SessionID cluster change from other backup node after primary session
- * node is failed.
- * 
- * @author Peter Rossbach
- * @version $Revision: 378258 $ $Date: 2006-02-16 08:42:35 -0600 (Thu, 16 Feb 2006) $
- */
-public class JvmRouteSessionIDBinderListener extends ClusterListener {
- 
-    /**
-     * The descriptive information about this implementation.
-     */
-    protected static final String info = "org.apache.catalina.ha.session.JvmRouteSessionIDBinderListener/1.1";
-
-    //--Instance Variables--------------------------------------
-
-
-    protected boolean started = false;
-
-    /**
-     * number of session that goes to this cluster node
-     */
-    private long numberOfSessions = 0;
-
-    //--Constructor---------------------------------------------
-
-    public JvmRouteSessionIDBinderListener() {
-    }
-
-    //--Logic---------------------------------------------------
-
-    /**
-     * Return descriptive information about this implementation.
-     */
-    public String getInfo() {
-
-        return (info);
-
-    }
-
-    /**
-     * @return Returns the numberOfSessions.
-     */
-    public long getNumberOfSessions() {
-        return numberOfSessions;
-    }
-
-    /**
-     * Add this Mover as Cluster Listener ( receiver)
-     * 
-     * @throws LifecycleException
-     */
-    public void start() throws LifecycleException {
-        if (started)
-            return;
-        getCluster().addClusterListener(this);
-        started = true;
-        if (log.isInfoEnabled())
-            log.info(sm.getString("jvmRoute.clusterListener.started"));
-    }
-
-    /**
-     * Remove this from Cluster Listener
-     * 
-     * @throws LifecycleException
-     */
-    public void stop() throws LifecycleException {
-        started = false;
-        getCluster().removeClusterListener(this);
-        if (log.isInfoEnabled())
-            log.info(sm.getString("jvmRoute.clusterListener.stopped"));
-    }
-
-    /**
-     * Callback from the cluster, when a message is received, The cluster will
-     * broadcast it invoking the messageReceived on the receiver.
-     * 
-     * @param msg
-     *            ClusterMessage - the message received from the cluster
-     */
-    public void messageReceived(ClusterMessage msg) {
-        if (msg instanceof SessionIDMessage && msg != null) {
-            SessionIDMessage sessionmsg = (SessionIDMessage) msg;
-            if (log.isDebugEnabled())
-                log.debug(sm.getString(
-                        "jvmRoute.receiveMessage.sessionIDChanged", sessionmsg
-                                .getOrignalSessionID(), sessionmsg
-                                .getBackupSessionID(), sessionmsg
-                                .getContextPath()));
-            Container container = getCluster().getContainer();
-            Container host = null ;
-            if(container instanceof Engine) {
-                host = container.findChild(sessionmsg.getHost());
-            } else {
-                host = container ;
-            }
-            if (host != null) {
-                Context context = (Context) host.findChild(sessionmsg
-                        .getContextPath());
-                if (context != null) {
-                    try {
-                        Session session = context.getManager().findSession(
-                                sessionmsg.getOrignalSessionID());
-                        if (session != null) {
-                            session.setId(sessionmsg.getBackupSessionID());
-                        } else if (log.isInfoEnabled())
-                            log.info(sm.getString("jvmRoute.lostSession",
-                                    sessionmsg.getOrignalSessionID(),
-                                    sessionmsg.getContextPath()));
-                    } catch (IOException e) {
-                        log.error(e);
-                    }
-
-                } else if (log.isErrorEnabled())
-                    log.error(sm.getString("jvmRoute.contextNotFound",
-                            sessionmsg.getContextPath(), ((StandardEngine) host
-                                    .getParent()).getJvmRoute()));
-            } else if (log.isErrorEnabled())
-                log.error(sm.getString("jvmRoute.hostNotFound", sessionmsg.getContextPath()));
-        }
-        return;
-    }
-
-    /**
-     * Accept only SessionIDMessages
-     * 
-     * @param msg
-     *            ClusterMessage
-     * @return boolean - returns true to indicate that messageReceived should be
-     *         invoked. If false is returned, the messageReceived method will
-     *         not be invoked.
-     */
-    public boolean accept(ClusterMessage msg) {
-        return (msg instanceof SessionIDMessage);
-    }
-}
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha.session;
+
+import java.io.IOException;
+
+import org.apache.catalina.Container;
+import org.apache.catalina.Context;
+import org.apache.catalina.Engine;
+import org.apache.catalina.LifecycleException;
+import org.apache.catalina.Session;
+import org.apache.catalina.ha.ClusterMessage;
+import org.apache.catalina.core.StandardEngine;
+import org.apache.catalina.ha.*;
+
+/**
+ * Receive SessionID cluster change from other backup node after primary session
+ * node is failed.
+ * 
+ * @author Peter Rossbach
+ * @version $Revision: 378258 $ $Date: 2006-02-16 08:42:35 -0600 (Thu, 16 Feb 2006) $
+ */
+public class JvmRouteSessionIDBinderListener extends ClusterListener {
+ 
+    /**
+     * The descriptive information about this implementation.
+     */
+    protected static final String info = "org.apache.catalina.ha.session.JvmRouteSessionIDBinderListener/1.1";
+
+    //--Instance Variables--------------------------------------
+
+
+    protected boolean started = false;
+
+    /**
+     * number of session that goes to this cluster node
+     */
+    private long numberOfSessions = 0;
+
+    //--Constructor---------------------------------------------
+
+    public JvmRouteSessionIDBinderListener() {
+    }
+
+    //--Logic---------------------------------------------------
+
+    /**
+     * Return descriptive information about this implementation.
+     */
+    public String getInfo() {
+
+        return (info);
+
+    }
+
+    /**
+     * @return Returns the numberOfSessions.
+     */
+    public long getNumberOfSessions() {
+        return numberOfSessions;
+    }
+
+    /**
+     * Add this Mover as Cluster Listener ( receiver)
+     * 
+     * @throws LifecycleException
+     */
+    public void start() throws LifecycleException {
+        if (started)
+            return;
+        getCluster().addClusterListener(this);
+        started = true;
+        if (log.isInfoEnabled())
+            log.info(sm.getString("jvmRoute.clusterListener.started"));
+    }
+
+    /**
+     * Remove this from Cluster Listener
+     * 
+     * @throws LifecycleException
+     */
+    public void stop() throws LifecycleException {
+        started = false;
+        getCluster().removeClusterListener(this);
+        if (log.isInfoEnabled())
+            log.info(sm.getString("jvmRoute.clusterListener.stopped"));
+    }
+
+    /**
+     * Callback from the cluster, when a message is received, The cluster will
+     * broadcast it invoking the messageReceived on the receiver.
+     * 
+     * @param msg
+     *            ClusterMessage - the message received from the cluster
+     */
+    public void messageReceived(ClusterMessage msg) {
+        if (msg instanceof SessionIDMessage && msg != null) {
+            SessionIDMessage sessionmsg = (SessionIDMessage) msg;
+            if (log.isDebugEnabled())
+                log.debug(sm.getString(
+                        "jvmRoute.receiveMessage.sessionIDChanged", sessionmsg
+                                .getOrignalSessionID(), sessionmsg
+                                .getBackupSessionID(), sessionmsg
+                                .getContextPath()));
+            Container container = getCluster().getContainer();
+            Container host = null ;
+            if(container instanceof Engine) {
+                host = container.findChild(sessionmsg.getHost());
+            } else {
+                host = container ;
+            }
+            if (host != null) {
+                Context context = (Context) host.findChild(sessionmsg
+                        .getContextPath());
+                if (context != null) {
+                    try {
+                        Session session = context.getManager().findSession(
+                                sessionmsg.getOrignalSessionID());
+                        if (session != null) {
+                            session.setId(sessionmsg.getBackupSessionID());
+                        } else if (log.isInfoEnabled())
+                            log.info(sm.getString("jvmRoute.lostSession",
+                                    sessionmsg.getOrignalSessionID(),
+                                    sessionmsg.getContextPath()));
+                    } catch (IOException e) {
+                        log.error(e);
+                    }
+
+                } else if (log.isErrorEnabled())
+                    log.error(sm.getString("jvmRoute.contextNotFound",
+                            sessionmsg.getContextPath(), ((StandardEngine) host
+                                    .getParent()).getJvmRoute()));
+            } else if (log.isErrorEnabled())
+                log.error(sm.getString("jvmRoute.hostNotFound", sessionmsg.getContextPath()));
+        }
+        return;
+    }
+
+    /**
+     * Accept only SessionIDMessages
+     * 
+     * @param msg
+     *            ClusterMessage
+     * @return boolean - returns true to indicate that messageReceived should be
+     *         invoked. If false is returned, the messageReceived method will
+     *         not be invoked.
+     */
+    public boolean accept(ClusterMessage msg) {
+        return (msg instanceof SessionIDMessage);
+    }
+}
+

==================================================
SerializablePrincipal.java
index 7f4017a19a..33d9ca4a98 100644
--- a/java/org/apache/catalina/ha/session/ReplicatedSession.java
+++ b/java/org/apache/catalina/ha/session/ReplicatedSession.java
@@ -1,285 +1,286 @@
-
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha.session;
-
-/**
- * Title:        Tomcat Session Replication for Tomcat 4.0 <BR>
- * Description:  A very simple straight forward implementation of
- *               session replication of servers in a cluster.<BR>
- *               This session replication is implemented "live". By live
- *               I mean, when a session attribute is added into a session on Node A
- *               a message is broadcasted to other messages and setAttribute is called on the replicated
- *               sessions.<BR>
- *               A full description of this implementation can be found under
- *               <href="http://www.filip.net/tomcat/">Filip's Tomcat Page</a><BR>
- *
- * Copyright:    See apache license
- * @author  Filip Hanik
- * @version $Revision: 303842 $ $Date: 2005-04-10 11:20:46 -0500 (Sun, 10 Apr 2005) $
- * Description:<BR>
- * The ReplicatedSession class is a simple extension of the StandardSession class
- * It overrides a few methods (setAttribute, removeAttribute, expire, access) and has
- * hooks into the InMemoryReplicationManager to broadcast and receive events from the cluster.<BR>
- * This class inherits the readObjectData and writeObject data methods from the StandardSession
- * and does not contain any serializable elements in addition to the inherited ones from the StandardSession
- *
- */
-import org.apache.catalina.Manager;
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.security.Principal;
-
-public class ReplicatedSession extends org.apache.catalina.session.StandardSession
-implements org.apache.catalina.ha.ClusterSession{
-
-    private transient Manager mManager = null;
-    protected boolean isDirty = false;
-    private transient long lastAccessWasDistributed = System.currentTimeMillis();
-    private boolean isPrimarySession=true;
-    
-
-    public ReplicatedSession(Manager manager) {
-        super(manager);
-        mManager = manager;
-    }
-
-
-    public boolean isDirty()
-    {
-        return isDirty;
-    }
-
-    public void setIsDirty(boolean dirty)
-    {
-        isDirty = dirty;
-    }
-
-
-    public void setLastAccessWasDistributed(long time) {
-        lastAccessWasDistributed = time;
-    }
-
-    public long getLastAccessWasDistributed() {
-        return lastAccessWasDistributed;
-    }
-
-
-    public void removeAttribute(String name) {
-        setIsDirty(true);
-        super.removeAttribute(name);
-    }
-
-    /**
-     * see parent description,
-     * plus we also notify other nodes in the cluster
-     */
-    public void removeAttribute(String name, boolean notify) {
-        setIsDirty(true);
-        super.removeAttribute(name,notify);
-    }
-
-
-    /**
-     * Sets an attribute and notifies the other nodes in the cluster
-     */
-    public void setAttribute(String name, Object value)
-    {
-        if ( value == null ) {
-          removeAttribute(name);
-          return;
-        }
-        if (!(value instanceof java.io.Serializable))
-            throw new java.lang.IllegalArgumentException("Value for attribute "+name+" is not serializable.");
-        setIsDirty(true);
-        super.setAttribute(name,value);
-    }
-
-    public void setMaxInactiveInterval(int interval) {
-        setIsDirty(true);
-        super.setMaxInactiveInterval(interval);
-    }
-
-
-    /**
-     * Sets the manager for this session
-     * @param mgr - the servers InMemoryReplicationManager
-     */
-    public void setManager(SimpleTcpReplicationManager mgr)
-    {
-        mManager = mgr;
-        super.setManager(mgr);
-    }
-
-
-    /**
-     * Set the authenticated Principal that is associated with this Session.
-     * This provides an <code>Authenticator</code> with a means to cache a
-     * previously authenticated Principal, and avoid potentially expensive
-     * <code>Realm.authenticate()</code> calls on every request.
-     *
-     * @param principal The new Principal, or <code>null</code> if none
-     */
-    public void setPrincipal(Principal principal) {
-        super.setPrincipal(principal);
-        setIsDirty(true);
-    }
-
-    public void expire() {
-        SimpleTcpReplicationManager mgr =(SimpleTcpReplicationManager)getManager();
-        mgr.sessionInvalidated(getIdInternal());
-        setIsDirty(true);
-        super.expire();
-    }
-
-    public void invalidate() {
-        SimpleTcpReplicationManager mgr =(SimpleTcpReplicationManager)getManager();
-        mgr.sessionInvalidated(getIdInternal());
-        setIsDirty(true);
-        super.invalidate();
-    }
-
-
-    /**
-     * Read a serialized version of the contents of this session object from
-     * the specified object input stream, without requiring that the
-     * StandardSession itself have been serialized.
-     *
-     * @param stream The object input stream to read from
-     *
-     * @exception ClassNotFoundException if an unknown class is specified
-     * @exception IOException if an input/output error occurs
-     */
-    public void readObjectData(ObjectInputStream stream)
-        throws ClassNotFoundException, IOException {
-
-        super.readObjectData(stream);
-
-    }
-
-
-    /**
-     * Write a serialized version of the contents of this session object to
-     * the specified object output stream, without requiring that the
-     * StandardSession itself have been serialized.
-     *
-     * @param stream The object output stream to write to
-     *
-     * @exception IOException if an input/output error occurs
-     */
-    public void writeObjectData(ObjectOutputStream stream)
-        throws IOException {
-
-        super.writeObjectData(stream);
-
-    }
-    
-    public void setId(String id, boolean tellNew) {
-
-        if ((this.id != null) && (manager != null))
-            manager.remove(this);
-
-        this.id = id;
-
-        if (manager != null)
-            manager.add(this);
-        if (tellNew) tellNew();
-    }
-    
-    
-
-
-
-
-
-
-    /**
-     * returns true if this session is the primary session, if that is the
-     * case, the manager can expire it upon timeout.
-     */
-    public boolean isPrimarySession() {
-        return isPrimarySession;
-    }
-
-    /**
-     * Sets whether this is the primary session or not.
-     * @param primarySession Flag value
-     */
-    public void setPrimarySession(boolean primarySession) {
-        this.isPrimarySession=primarySession;
-    }
-
-
-
-
-    /**
-     * Implements a log method to log through the manager
-     */
-    protected void log(String message) {
-
-        if ((mManager != null) && (mManager instanceof SimpleTcpReplicationManager)) {
-            ((SimpleTcpReplicationManager) mManager).log.debug("ReplicatedSession: " + message);
-        } else {
-            System.out.println("ReplicatedSession: " + message);
-        }
-
-    }
-
-    protected void log(String message, Throwable x) {
-
-        if ((mManager != null) && (mManager instanceof SimpleTcpReplicationManager)) {
-            ((SimpleTcpReplicationManager) mManager).log.error("ReplicatedSession: " + message,x);
-        } else {
-            System.out.println("ReplicatedSession: " + message);
-            x.printStackTrace();
-        }
-
-    }
-
-    public String toString() {
-        StringBuffer buf = new StringBuffer("ReplicatedSession id=");
-        buf.append(getIdInternal()).append(" ref=").append(super.toString()).append("\n");
-        java.util.Enumeration e = getAttributeNames();
-        while ( e.hasMoreElements() ) {
-            String name = (String)e.nextElement();
-            Object value = getAttribute(name);
-            buf.append("\tname=").append(name).append("; value=").append(value).append("\n");
-        }
-        buf.append("\tLastAccess=").append(getLastAccessedTime()).append("\n");
-        return buf.toString();
-    }
-    public int getAccessCount() {
-        return accessCount.get();
-    }
-    public void setAccessCount(int accessCount) {
-        this.accessCount.set(accessCount);
-    }
-    public long getLastAccessedTime() {
-        return lastAccessedTime;
-    }
-    public void setLastAccessedTime(long lastAccessedTime) {
-        this.lastAccessedTime = lastAccessedTime;
-    }
-    public long getThisAccessedTime() {
-        return thisAccessedTime;
-    }
-    public void setThisAccessedTime(long thisAccessedTime) {
-        this.thisAccessedTime = thisAccessedTime;
-    }
-
-}
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha.session;
+
+/**
+ * Title:        Tomcat Session Replication for Tomcat 4.0 <BR>
+ * Description:  A very simple straight forward implementation of
+ *               session replication of servers in a cluster.<BR>
+ *               This session replication is implemented "live". By live
+ *               I mean, when a session attribute is added into a session on Node A
+ *               a message is broadcasted to other messages and setAttribute is called on the replicated
+ *               sessions.<BR>
+ *               A full description of this implementation can be found under
+ *               <href="http://www.filip.net/tomcat/">Filip's Tomcat Page</a><BR>
+ *
+ * Copyright:    See apache license
+ * @author  Filip Hanik
+ * @version $Revision: 303842 $ $Date: 2005-04-10 11:20:46 -0500 (Sun, 10 Apr 2005) $
+ * Description:<BR>
+ * The ReplicatedSession class is a simple extension of the StandardSession class
+ * It overrides a few methods (setAttribute, removeAttribute, expire, access) and has
+ * hooks into the InMemoryReplicationManager to broadcast and receive events from the cluster.<BR>
+ * This class inherits the readObjectData and writeObject data methods from the StandardSession
+ * and does not contain any serializable elements in addition to the inherited ones from the StandardSession
+ *
+ */
+import org.apache.catalina.Manager;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.security.Principal;
+
+public class ReplicatedSession extends org.apache.catalina.session.StandardSession
+implements org.apache.catalina.ha.ClusterSession{
+
+    private transient Manager mManager = null;
+    protected boolean isDirty = false;
+    private transient long lastAccessWasDistributed = System.currentTimeMillis();
+    private boolean isPrimarySession=true;
+    
+
+    public ReplicatedSession(Manager manager) {
+        super(manager);
+        mManager = manager;
+    }
+
+
+    public boolean isDirty()
+    {
+        return isDirty;
+    }
+
+    public void setIsDirty(boolean dirty)
+    {
+        isDirty = dirty;
+    }
+
+
+    public void setLastAccessWasDistributed(long time) {
+        lastAccessWasDistributed = time;
+    }
+
+    public long getLastAccessWasDistributed() {
+        return lastAccessWasDistributed;
+    }
+
+
+    public void removeAttribute(String name) {
+        setIsDirty(true);
+        super.removeAttribute(name);
+    }
+
+    /**
+     * see parent description,
+     * plus we also notify other nodes in the cluster
+     */
+    public void removeAttribute(String name, boolean notify) {
+        setIsDirty(true);
+        super.removeAttribute(name,notify);
+    }
+
+
+    /**
+     * Sets an attribute and notifies the other nodes in the cluster
+     */
+    public void setAttribute(String name, Object value)
+    {
+        if ( value == null ) {
+          removeAttribute(name);
+          return;
+        }
+        if (!(value instanceof java.io.Serializable))
+            throw new java.lang.IllegalArgumentException("Value for attribute "+name+" is not serializable.");
+        setIsDirty(true);
+        super.setAttribute(name,value);
+    }
+
+    public void setMaxInactiveInterval(int interval) {
+        setIsDirty(true);
+        super.setMaxInactiveInterval(interval);
+    }
+
+
+    /**
+     * Sets the manager for this session
+     * @param mgr - the servers InMemoryReplicationManager
+     */
+    public void setManager(SimpleTcpReplicationManager mgr)
+    {
+        mManager = mgr;
+        super.setManager(mgr);
+    }
+
+
+    /**
+     * Set the authenticated Principal that is associated with this Session.
+     * This provides an <code>Authenticator</code> with a means to cache a
+     * previously authenticated Principal, and avoid potentially expensive
+     * <code>Realm.authenticate()</code> calls on every request.
+     *
+     * @param principal The new Principal, or <code>null</code> if none
+     */
+    public void setPrincipal(Principal principal) {
+        super.setPrincipal(principal);
+        setIsDirty(true);
+    }
+
+    public void expire() {
+        SimpleTcpReplicationManager mgr =(SimpleTcpReplicationManager)getManager();
+        mgr.sessionInvalidated(getIdInternal());
+        setIsDirty(true);
+        super.expire();
+    }
+
+    public void invalidate() {
+        SimpleTcpReplicationManager mgr =(SimpleTcpReplicationManager)getManager();
+        mgr.sessionInvalidated(getIdInternal());
+        setIsDirty(true);
+        super.invalidate();
+    }
+
+
+    /**
+     * Read a serialized version of the contents of this session object from
+     * the specified object input stream, without requiring that the
+     * StandardSession itself have been serialized.
+     *
+     * @param stream The object input stream to read from
+     *
+     * @exception ClassNotFoundException if an unknown class is specified
+     * @exception IOException if an input/output error occurs
+     */
+    public void readObjectData(ObjectInputStream stream)
+        throws ClassNotFoundException, IOException {
+
+        super.readObjectData(stream);
+
+    }
+
+
+    /**
+     * Write a serialized version of the contents of this session object to
+     * the specified object output stream, without requiring that the
+     * StandardSession itself have been serialized.
+     *
+     * @param stream The object output stream to write to
+     *
+     * @exception IOException if an input/output error occurs
+     */
+    public void writeObjectData(ObjectOutputStream stream)
+        throws IOException {
+
+        super.writeObjectData(stream);
+
+    }
+    
+    public void setId(String id, boolean tellNew) {
+
+        if ((this.id != null) && (manager != null))
+            manager.remove(this);
+
+        this.id = id;
+
+        if (manager != null)
+            manager.add(this);
+        if (tellNew) tellNew();
+    }
+    
+    
+
+
+
+
+
+
+    /**
+     * returns true if this session is the primary session, if that is the
+     * case, the manager can expire it upon timeout.
+     */
+    public boolean isPrimarySession() {
+        return isPrimarySession;
+    }
+
+    /**
+     * Sets whether this is the primary session or not.
+     * @param primarySession Flag value
+     */
+    public void setPrimarySession(boolean primarySession) {
+        this.isPrimarySession=primarySession;
+    }
+
+
+
+
+    /**
+     * Implements a log method to log through the manager
+     */
+    protected void log(String message) {
+
+        if ((mManager != null) && (mManager instanceof SimpleTcpReplicationManager)) {
+            ((SimpleTcpReplicationManager) mManager).log.debug("ReplicatedSession: " + message);
+        } else {
+            System.out.println("ReplicatedSession: " + message);
+        }
+
+    }
+
+    protected void log(String message, Throwable x) {
+
+        if ((mManager != null) && (mManager instanceof SimpleTcpReplicationManager)) {
+            ((SimpleTcpReplicationManager) mManager).log.error("ReplicatedSession: " + message,x);
+        } else {
+            System.out.println("ReplicatedSession: " + message);
+            x.printStackTrace();
+        }
+
+    }
+
+    public String toString() {
+        StringBuffer buf = new StringBuffer("ReplicatedSession id=");
+        buf.append(getIdInternal()).append(" ref=").append(super.toString()).append("\n");
+        java.util.Enumeration e = getAttributeNames();
+        while ( e.hasMoreElements() ) {
+            String name = (String)e.nextElement();
+            Object value = getAttribute(name);
+            buf.append("\tname=").append(name).append("; value=").append(value).append("\n");
+        }
+        buf.append("\tLastAccess=").append(getLastAccessedTime()).append("\n");
+        return buf.toString();
+    }
+    public int getAccessCount() {
+        return accessCount.get();
+    }
+    public void setAccessCount(int accessCount) {
+        this.accessCount.set(accessCount);
+    }
+    public long getLastAccessedTime() {
+        return lastAccessedTime;
+    }
+    public void setLastAccessedTime(long lastAccessedTime) {
+        this.lastAccessedTime = lastAccessedTime;
+    }
+    public long getThisAccessedTime() {
+        return thisAccessedTime;
+    }
+    public void setThisAccessedTime(long thisAccessedTime) {
+        this.thisAccessedTime = thisAccessedTime;
+    }
+
+}

==================================================
SessionIDMessage.java
index 08518b6ceb..7e3d223e6d 100644
--- a/java/org/apache/catalina/ha/session/SerializablePrincipal.java
+++ b/java/org/apache/catalina/ha/session/SerializablePrincipal.java
@@ -1,192 +1,193 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina.ha.session;
-
-
-import java.util.Arrays;
-import java.util.List;
-import org.apache.catalina.Realm;
-
-
-/**
- * Generic implementation of <strong>java.security.Principal</strong> that
- * is available for use by <code>Realm</code> implementations.
- * The GenericPrincipal does NOT implement serializable and I didn't want to change that implementation
- * hence I implemented this one instead.
- * @author Filip Hanik
- * @version $Revision: 303587 $ $Date: 2004-12-09 08:36:43 -0600 (Thu, 09 Dec 2004) $
- */
-import org.apache.catalina.realm.GenericPrincipal;
-import java.io.ObjectInput;
-import java.io.ObjectOutput;
-public class SerializablePrincipal  implements java.io.Serializable {
-
-
-    // ----------------------------------------------------------- Constructors
-
-    public SerializablePrincipal()
-    {
-        super();
-    }
-    /**
-     * Construct a new Principal, associated with the specified Realm, for the
-     * specified username and password.
-     *
-     * @param realm The Realm that owns this Principal
-     * @param name The username of the user represented by this Principal
-     * @param password Credentials used to authenticate this user
-     */
-    public SerializablePrincipal(Realm realm, String name, String password) {
-
-        this(realm, name, password, null);
-
-    }
-
-
-    /**
-     * Construct a new Principal, associated with the specified Realm, for the
-     * specified username and password, with the specified role names
-     * (as Strings).
-     *
-     * @param realm The Realm that owns this principal
-     * @param name The username of the user represented by this Principal
-     * @param password Credentials used to authenticate this user
-     * @param roles List of roles (must be Strings) possessed by this user
-     */
-    public SerializablePrincipal(Realm realm, String name, String password,
-                            List roles) {
-
-        super();
-        this.realm = realm;
-        this.name = name;
-        this.password = password;
-        if (roles != null) {
-            this.roles = new String[roles.size()];
-            this.roles = (String[]) roles.toArray(this.roles);
-            if (this.roles.length > 0)
-                Arrays.sort(this.roles);
-        }
-
-    }
-
-
-    // ------------------------------------------------------------- Properties
-
-
-    /**
-     * The username of the user represented by this Principal.
-     */
-    protected String name = null;
-
-    public String getName() {
-        return (this.name);
-    }
-
-
-    /**
-     * The authentication credentials for the user represented by
-     * this Principal.
-     */
-    protected String password = null;
-
-    public String getPassword() {
-        return (this.password);
-    }
-
-
-    /**
-     * The Realm with which this Principal is associated.
-     */
-    protected transient Realm realm = null;
-
-    public Realm getRealm() {
-        return (this.realm);
-    }
-
-    public void setRealm(Realm realm) {
-        this.realm = realm;
-    }
-
-
-
-
-    /**
-     * The set of roles associated with this user.
-     */
-    protected String roles[] = new String[0];
-
-    public String[] getRoles() {
-        return (this.roles);
-    }
-
-
-    // --------------------------------------------------------- Public Methods
-
-
-
-
-    /**
-     * Return a String representation of this object, which exposes only
-     * information that should be public.
-     */
-    public String toString() {
-
-        StringBuffer sb = new StringBuffer("SerializablePrincipal[");
-        sb.append(this.name);
-        sb.append("]");
-        return (sb.toString());
-
-    }
-
-    public static SerializablePrincipal createPrincipal(GenericPrincipal principal)
-    {
-        if ( principal==null) return null;
-        return new SerializablePrincipal(principal.getRealm(),
-                                         principal.getName(),
-                                         principal.getPassword(),
-                                         principal.getRoles()!=null?Arrays.asList(principal.getRoles()):null);
-    }
-
-    public GenericPrincipal getPrincipal( Realm realm )
-    {
-        return new GenericPrincipal(realm,name,password,getRoles()!=null?Arrays.asList(getRoles()):null);
-    }
-    
-    public static GenericPrincipal readPrincipal(ObjectInput in, Realm realm) throws java.io.IOException{
-        String name = in.readUTF();
-        boolean hasPwd = in.readBoolean();
-        String pwd = null;
-        if ( hasPwd ) pwd = in.readUTF();
-        int size = in.readInt();
-        String[] roles = new String[size];
-        for ( int i=0; i<size; i++ ) roles[i] = in.readUTF();
-        return new GenericPrincipal(realm,name,pwd,Arrays.asList(roles));
-    }
-    
-    public static void writePrincipal(GenericPrincipal p, ObjectOutput out) throws java.io.IOException {
-        out.writeUTF(p.getName());
-        out.writeBoolean(p.getPassword()!=null);
-        if ( p.getPassword()!= null ) out.writeUTF(p.getPassword());
-        String[] roles = p.getRoles();
-        if ( roles == null ) roles = new String[0];
-        out.writeInt(roles.length);
-        for ( int i=0; i<roles.length; i++ ) out.writeUTF(roles[i]);
-    }
-
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.catalina.ha.session;
+
+
+import java.util.Arrays;
+import java.util.List;
+import org.apache.catalina.Realm;
+
+
+/**
+ * Generic implementation of <strong>java.security.Principal</strong> that
+ * is available for use by <code>Realm</code> implementations.
+ * The GenericPrincipal does NOT implement serializable and I didn't want to change that implementation
+ * hence I implemented this one instead.
+ * @author Filip Hanik
+ * @version $Revision: 303587 $ $Date: 2004-12-09 08:36:43 -0600 (Thu, 09 Dec 2004) $
+ */
+import org.apache.catalina.realm.GenericPrincipal;
+import java.io.ObjectInput;
+import java.io.ObjectOutput;
+public class SerializablePrincipal  implements java.io.Serializable {
+
+
+    // ----------------------------------------------------------- Constructors
+
+    public SerializablePrincipal()
+    {
+        super();
+    }
+    /**
+     * Construct a new Principal, associated with the specified Realm, for the
+     * specified username and password.
+     *
+     * @param realm The Realm that owns this Principal
+     * @param name The username of the user represented by this Principal
+     * @param password Credentials used to authenticate this user
+     */
+    public SerializablePrincipal(Realm realm, String name, String password) {
+
+        this(realm, name, password, null);
+
+    }
+
+
+    /**
+     * Construct a new Principal, associated with the specified Realm, for the
+     * specified username and password, with the specified role names
+     * (as Strings).
+     *
+     * @param realm The Realm that owns this principal
+     * @param name The username of the user represented by this Principal
+     * @param password Credentials used to authenticate this user
+     * @param roles List of roles (must be Strings) possessed by this user
+     */
+    public SerializablePrincipal(Realm realm, String name, String password,
+                            List roles) {
+
+        super();
+        this.realm = realm;
+        this.name = name;
+        this.password = password;
+        if (roles != null) {
+            this.roles = new String[roles.size()];
+            this.roles = (String[]) roles.toArray(this.roles);
+            if (this.roles.length > 0)
+                Arrays.sort(this.roles);
+        }
+
+    }
+
+
+    // ------------------------------------------------------------- Properties
+
+
+    /**
+     * The username of the user represented by this Principal.
+     */
+    protected String name = null;
+
+    public String getName() {
+        return (this.name);
+    }
+
+
+    /**
+     * The authentication credentials for the user represented by
+     * this Principal.
+     */
+    protected String password = null;
+
+    public String getPassword() {
+        return (this.password);
+    }
+
+
+    /**
+     * The Realm with which this Principal is associated.
+     */
+    protected transient Realm realm = null;
+
+    public Realm getRealm() {
+        return (this.realm);
+    }
+
+    public void setRealm(Realm realm) {
+        this.realm = realm;
+    }
+
+
+
+
+    /**
+     * The set of roles associated with this user.
+     */
+    protected String roles[] = new String[0];
+
+    public String[] getRoles() {
+        return (this.roles);
+    }
+
+
+    // --------------------------------------------------------- Public Methods
+
+
+
+
+    /**
+     * Return a String representation of this object, which exposes only
+     * information that should be public.
+     */
+    public String toString() {
+
+        StringBuffer sb = new StringBuffer("SerializablePrincipal[");
+        sb.append(this.name);
+        sb.append("]");
+        return (sb.toString());
+
+    }
+
+    public static SerializablePrincipal createPrincipal(GenericPrincipal principal)
+    {
+        if ( principal==null) return null;
+        return new SerializablePrincipal(principal.getRealm(),
+                                         principal.getName(),
+                                         principal.getPassword(),
+                                         principal.getRoles()!=null?Arrays.asList(principal.getRoles()):null);
+    }
+
+    public GenericPrincipal getPrincipal( Realm realm )
+    {
+        return new GenericPrincipal(realm,name,password,getRoles()!=null?Arrays.asList(getRoles()):null);
+    }
+    
+    public static GenericPrincipal readPrincipal(ObjectInput in, Realm realm) throws java.io.IOException{
+        String name = in.readUTF();
+        boolean hasPwd = in.readBoolean();
+        String pwd = null;
+        if ( hasPwd ) pwd = in.readUTF();
+        int size = in.readInt();
+        String[] roles = new String[size];
+        for ( int i=0; i<size; i++ ) roles[i] = in.readUTF();
+        return new GenericPrincipal(realm,name,pwd,Arrays.asList(roles));
+    }
+    
+    public static void writePrincipal(GenericPrincipal p, ObjectOutput out) throws java.io.IOException {
+        out.writeUTF(p.getName());
+        out.writeBoolean(p.getPassword()!=null);
+        if ( p.getPassword()!= null ) out.writeUTF(p.getPassword());
+        String[] roles = p.getRoles();
+        if ( roles == null ) roles = new String[0];
+        out.writeInt(roles.length);
+        for ( int i=0; i<roles.length; i++ ) out.writeUTF(roles[i]);
+    }
+
+
+}

==================================================
SessionMessage.java
index 126aa4d8a5..e03cf5ec66 100644
--- a/java/org/apache/catalina/ha/session/SessionIDMessage.java
+++ b/java/org/apache/catalina/ha/session/SessionIDMessage.java
@@ -1,128 +1,129 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.ha.session;
-
-import org.apache.catalina.ha.ClusterMessage;
-import org.apache.catalina.ha.ClusterMessageBase;
-
-/**
- * Session id change cluster message
- * 
- * @author Peter Rossbach
- * 
- * @version $Revision: 326110 $ $Date: 2005-10-18 09:08:36 -0500 (Tue, 18 Oct 2005) $
- */
-public class SessionIDMessage extends ClusterMessageBase implements ClusterMessage {
-
-	private int messageNumber;
-
-	private String orignalSessionID;
-
-	private String backupSessionID;
-
-	private String host ;
-	private String contextPath;
-
-	public String getUniqueId() {
-		StringBuffer result = new StringBuffer(getOrignalSessionID());
-		result.append("#-#");
-		result.append(getHost());
-                result.append("#-#");
-                result.append(getContextPath());
-		result.append("#-#");
-		result.append(getMessageNumber());
-		result.append("#-#");
-		result.append(System.currentTimeMillis());
-		return result.toString();
-	}
-
-    /**
-     * @return Returns the host.
-     */
-    public String getHost() {
-        return host;
-    }
-
-    /**
-     * @param host The host to set.
-     */
-    public void setHost(String host) {
-        this.host = host;
-    }
-    
-	/**
-	 * @return Returns the contextPath.
-	 */
-	public String getContextPath() {
-		return contextPath;
-	}
-	/**
-	 * @param contextPath The contextPath to set.
-	 */
-	public void setContextPath(String contextPath) {
-		this.contextPath = contextPath;
-	}
-	/**
-	 * @return Returns the messageNumber.
-	 */
-	public int getMessageNumber() {
-		return messageNumber;
-	}
-
-	/**
-	 * @param messageNumber
-	 *            The messageNumber to set.
-	 */
-	public void setMessageNumber(int messageNumber) {
-		this.messageNumber = messageNumber;
-	}
-
-	
-	/**
-	 * @return Returns the backupSessionID.
-	 */
-	public String getBackupSessionID() {
-		return backupSessionID;
-	}
-
-	/**
-	 * @param backupSessionID
-	 *            The backupSessionID to set.
-	 */
-	public void setBackupSessionID(String backupSessionID) {
-		this.backupSessionID = backupSessionID;
-	}
-
-	/**
-	 * @return Returns the orignalSessionID.
-	 */
-	public String getOrignalSessionID() {
-		return orignalSessionID;
-	}
-
-	/**
-	 * @param orignalSessionID
-	 *            The orignalSessionID to set.
-	 */
-	public void setOrignalSessionID(String orignalSessionID) {
-		this.orignalSessionID = orignalSessionID;
-	}
-
-    
-
-
-}
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.ha.session;
+
+import org.apache.catalina.ha.ClusterMessage;
+import org.apache.catalina.ha.ClusterMessageBase;
+
+/**
+ * Session id change cluster message
+ * 
+ * @author Peter Rossbach
+ * 
+ * @version $Revision: 326110 $ $Date: 2005-10-18 09:08:36 -0500 (Tue, 18 Oct 2005) $
+ */
+public class SessionIDMessage extends ClusterMessageBase implements ClusterMessage {
+
+	private int messageNumber;
+
+	private String orignalSessionID;
+
+	private String backupSessionID;
+
+	private String host ;
+	private String contextPath;
+
+	public String getUniqueId() {
+		StringBuffer result = new StringBuffer(getOrignalSessionID());
+		result.append("#-#");
+		result.append(getHost());
+                result.append("#-#");
+                result.append(getContextPath());
+		result.append("#-#");
+		result.append(getMessageNumber());
+		result.append("#-#");
+		result.append(System.currentTimeMillis());
+		return result.toString();
+	}
+
+    /**
+     * @return Returns the host.
+     */
+    public String getHost() {
+        return host;
+    }
+
+    /**
+     * @param host The host to set.
+     */
+    public void setHost(String host) {
+        this.host = host;
+    }
+    
+	/**
+	 * @return Returns the contextPath.
+	 */
+	public String getContextPath() {
+		return contextPath;
+	}
+	/**
+	 * @param contextPath The contextPath to set.
+	 */
+	public void setContextPath(String contextPath) {
+		this.contextPath = contextPath;
+	}
+	/**
+	 * @return Returns the messageNumber.
+	 */
+	public int getMessageNumber() {
+		return messageNumber;
+	}
+
+	/**
+	 * @param messageNumber
+	 *            The messageNumber to set.
+	 */
+	public void setMessageNumber(int messageNumber) {
+		this.messageNumber = messageNumber;
+	}
+
+	
+	/**
+	 * @return Returns the backupSessionID.
+	 */
+	public String getBackupSessionID() {
+		return backupSessionID;
+	}
+
+	/**
+	 * @param backupSessionID
+	 *            The backupSessionID to set.
+	 */
+	public void setBackupSessionID(String backupSessionID) {
+		this.backupSessionID = backupSessionID;
+	}
+
+	/**
+	 * @return Returns the orignalSessionID.
+	 */
+	public String getOrignalSessionID() {
+		return orignalSessionID;
+	}
+
+	/**
+	 * @param orignalSessionID
+	 *            The orignalSessionID to set.
+	 */
+	public void setOrignalSessionID(String orignalSessionID) {
+		this.orignalSessionID = orignalSessionID;
+	}
+
+    
+
+
+}
+

==================================================
SessionMessageImpl.java
index 13fb89b52f..ab28acf283 100644
--- a/java/org/apache/catalina/ha/session/SessionMessage.java
+++ b/java/org/apache/catalina/ha/session/SessionMessage.java
@@ -1,103 +1,104 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.ha.session;
-import org.apache.catalina.ha.ClusterMessage;
-
-/**
- *
- * <B>Class Description:</B><BR>
- * The SessionMessage class is a class that is used when a session has been
- * created, modified, expired in a Tomcat cluster node.<BR>
- *
- * The following events are currently available:
- * <ul>
- *   <li><pre>public static final int EVT_SESSION_CREATED</pre><li>
- *   <li><pre>public static final int EVT_SESSION_ACCESSED</pre><li>
- *   <li><pre>public static final int EVT_ATTRIBUTE_ADDED</pre><li>
- *   <li><pre>public static final int EVT_ATTRIBUTE_REMOVED</pre><li>
- *   <li><pre>public static final int EVT_SESSION_EXPIRED_WONOTIFY</pre><li>
- *   <li><pre>public static final int EVT_SESSION_EXPIRED_WNOTIFY</pre><li>
- *   <li><pre>public static final int EVT_GET_ALL_SESSIONS</pre><li>
- *   <li><pre>public static final int EVT_SET_USER_PRINCIPAL</pre><li>
- *   <li><pre>public static final int EVT_SET_SESSION_NOTE</pre><li>
- *   <li><pre>public static final int EVT_REMOVE_SESSION_NOTE</pre><li>
- * </ul>
- *
- */
-
-public interface SessionMessage extends ClusterMessage, java.io.Serializable
-{
-
-    /**
-     * Event type used when a session has been created on a node
-     */
-    public static final int EVT_SESSION_CREATED = 1;
-    /**
-     * Event type used when a session has expired
-     */
-    public static final int EVT_SESSION_EXPIRED = 2;
-
-    /**
-     * Event type used when a session has been accessed (ie, last access time
-     * has been updated. This is used so that the replicated sessions will not expire
-     * on the network
-     */
-    public static final int EVT_SESSION_ACCESSED = 3;
-    /**
-     * Event type used when a server comes online for the first time.
-     * The first thing the newly started server wants to do is to grab the
-     * all the sessions from one of the nodes and keep the same state in there
-     */
-    public static final int EVT_GET_ALL_SESSIONS = 4;
-    /**
-     * Event type used when an attribute has been added to a session,
-     * the attribute will be sent to all the other nodes in the cluster
-     */
-    public static final int EVT_SESSION_DELTA  = 13;
-
-    /**
-     * When a session state is transferred, this is the event.
-     */
-    public static final int EVT_ALL_SESSION_DATA = 12;
-    
-    /**
-     * When a session state is complete transferred, this is the event.
-     */
-    public static final int EVT_ALL_SESSION_TRANSFERCOMPLETE = 14;
-    
-
-    
-    public String getContextName();
-    
-    public String getEventTypeString();
-    
-    /**
-     * returns the event type
-     * @return one of the event types EVT_XXXX
-     */
-    public int getEventType(); 
-    /**
-     * @return the serialized data for the session
-     */
-    public byte[] getSession();
-    /**
-     * @return the session ID for the session
-     */
-    public String getSessionID();
-    
-
-
-}//SessionMessage
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.ha.session;
+import org.apache.catalina.ha.ClusterMessage;
+
+/**
+ *
+ * <B>Class Description:</B><BR>
+ * The SessionMessage class is a class that is used when a session has been
+ * created, modified, expired in a Tomcat cluster node.<BR>
+ *
+ * The following events are currently available:
+ * <ul>
+ *   <li><pre>public static final int EVT_SESSION_CREATED</pre><li>
+ *   <li><pre>public static final int EVT_SESSION_ACCESSED</pre><li>
+ *   <li><pre>public static final int EVT_ATTRIBUTE_ADDED</pre><li>
+ *   <li><pre>public static final int EVT_ATTRIBUTE_REMOVED</pre><li>
+ *   <li><pre>public static final int EVT_SESSION_EXPIRED_WONOTIFY</pre><li>
+ *   <li><pre>public static final int EVT_SESSION_EXPIRED_WNOTIFY</pre><li>
+ *   <li><pre>public static final int EVT_GET_ALL_SESSIONS</pre><li>
+ *   <li><pre>public static final int EVT_SET_USER_PRINCIPAL</pre><li>
+ *   <li><pre>public static final int EVT_SET_SESSION_NOTE</pre><li>
+ *   <li><pre>public static final int EVT_REMOVE_SESSION_NOTE</pre><li>
+ * </ul>
+ *
+ */
+
+public interface SessionMessage extends ClusterMessage, java.io.Serializable
+{
+
+    /**
+     * Event type used when a session has been created on a node
+     */
+    public static final int EVT_SESSION_CREATED = 1;
+    /**
+     * Event type used when a session has expired
+     */
+    public static final int EVT_SESSION_EXPIRED = 2;
+
+    /**
+     * Event type used when a session has been accessed (ie, last access time
+     * has been updated. This is used so that the replicated sessions will not expire
+     * on the network
+     */
+    public static final int EVT_SESSION_ACCESSED = 3;
+    /**
+     * Event type used when a server comes online for the first time.
+     * The first thing the newly started server wants to do is to grab the
+     * all the sessions from one of the nodes and keep the same state in there
+     */
+    public static final int EVT_GET_ALL_SESSIONS = 4;
+    /**
+     * Event type used when an attribute has been added to a session,
+     * the attribute will be sent to all the other nodes in the cluster
+     */
+    public static final int EVT_SESSION_DELTA  = 13;
+
+    /**
+     * When a session state is transferred, this is the event.
+     */
+    public static final int EVT_ALL_SESSION_DATA = 12;
+    
+    /**
+     * When a session state is complete transferred, this is the event.
+     */
+    public static final int EVT_ALL_SESSION_TRANSFERCOMPLETE = 14;
+    
+
+    
+    public String getContextName();
+    
+    public String getEventTypeString();
+    
+    /**
+     * returns the event type
+     * @return one of the event types EVT_XXXX
+     */
+    public int getEventType(); 
+    /**
+     * @return the serialized data for the session
+     */
+    public byte[] getSession();
+    /**
+     * @return the session ID for the session
+     */
+    public String getSessionID();
+    
+
+
+}//SessionMessage

==================================================
SimpleTcpReplicationManager.java
index f08d623457..137a9e199a 100644
--- a/java/org/apache/catalina/ha/session/SessionMessageImpl.java
+++ b/java/org/apache/catalina/ha/session/SessionMessageImpl.java
@@ -1,157 +1,158 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.ha.session;
-
-
-import org.apache.catalina.ha.ClusterMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.ha.ClusterMessageBase;
-
-/**
- * Session cluster message
- * 
- * @author Filip Hanik
- * @author Peter Rossbach
- * 
- * @version $Revision: 326110 $ $Date: 2005-10-18 09:08:36 -0500 (Tue, 18 Oct 2005) $
- */
-public class SessionMessageImpl extends ClusterMessageBase implements SessionMessage, java.io.Serializable {
-    
-    public SessionMessageImpl() {
-    }
-    
-    
-    /*
-
-     * Private serializable variables to keep the messages state
-     */
-    private int mEvtType = -1;
-    private byte[] mSession;
-    private String mSessionID;
-
-    private String mContextName;
-    private long serializationTimestamp;
-    private boolean timestampSet = false ;
-    private String uniqueId;
-
-
-    private SessionMessageImpl( String contextName,
-                           int eventtype,
-                           byte[] session,
-                           String sessionID)
-    {
-        mEvtType = eventtype;
-        mSession = session;
-        mSessionID = sessionID;
-        mContextName = contextName;
-        uniqueId = sessionID;
-    }
-
-    /**
-     * Creates a session message. Depending on what event type you want this
-     * message to represent, you populate the different parameters in the constructor<BR>
-      * The following rules apply dependent on what event type argument you use:<BR>
-     * <B>EVT_SESSION_CREATED</B><BR>
-     *    The parameters: session, sessionID must be set.<BR>
-     * <B>EVT_SESSION_EXPIRED</B><BR>
-     *    The parameters: sessionID must be set.<BR>
-     * <B>EVT_SESSION_ACCESSED</B><BR>
-     *    The parameters: sessionID must be set.<BR>
-     * <B>EVT_SESSION_EXPIRED_XXXX</B><BR>
-     *    The parameters: sessionID must be set.<BR>
-     * <B>EVT_SESSION_DELTA</B><BR>
-     *    Send attribute delta (add,update,remove attribute or principal, ...).<BR>
-     * <B>EVT_ALL_SESSION_DATA</B><BR>
-     *    Send complete serializes session list<BR>
-     * <B>EVT_ALL_SESSION_TRANSFERCOMPLETE</B><BR>
-     *    send that all session state information are transfered
-     *    after GET_ALL_SESSION received from this sender.<BR>
-     * @param contextName - the name of the context (application
-     * @param eventtype - one of the 8 event type defined in this class
-     * @param session - the serialized byte array of the session itself
-     * @param sessionID - the id that identifies this session
-     * @param uniqueID - the id that identifies this message
-     */
-    public SessionMessageImpl( String contextName,
-                           int eventtype,
-                           byte[] session,
-                           String sessionID,
-                           String uniqueID)
-    {
-        this(contextName,eventtype,session,sessionID);
-        uniqueId = uniqueID;
-    }
-
-    /**
-     * returns the event type
-     * @return one of the event types EVT_XXXX
-     */
-    public int getEventType() { return mEvtType; }
-
-    /**
-     * @return the serialized data for the session
-     */
-    public byte[] getSession() { return mSession;}
-
-    /**
-     * @return the session ID for the session
-     */
-    public String getSessionID(){ return mSessionID; }
-    
-    /**
-     * set message send time but only the first setting works (one shot)
-     */
-    public void setTimestamp(long time) {
-        synchronized(this) {
-            if(!timestampSet) {
-                serializationTimestamp=time;
-                timestampSet = true ;
-            }
-        }
-    }
-    
-    public long getTimestamp() { return serializationTimestamp;}
-    
-    /**
-     * clear text event type name (for logging purpose only) 
-     * @return the event type in a string representating, useful for debugging
-     */
-    public String getEventTypeString()
-    {
-        switch (mEvtType)
-        {
-            case EVT_SESSION_CREATED : return "SESSION-MODIFIED";
-            case EVT_SESSION_EXPIRED : return "SESSION-EXPIRED";
-            case EVT_SESSION_ACCESSED : return "SESSION-ACCESSED";
-            case EVT_GET_ALL_SESSIONS : return "SESSION-GET-ALL";
-            case EVT_SESSION_DELTA : return "SESSION-DELTA";
-            case EVT_ALL_SESSION_DATA : return "ALL-SESSION-DATA";
-            case EVT_ALL_SESSION_TRANSFERCOMPLETE : return "SESSION-STATE-TRANSFERED";
-            default : return "UNKNOWN-EVENT-TYPE";
-        }
-    }
-
-    public String getContextName() {
-       return mContextName;
-    }
-    public String getUniqueId() {
-        return uniqueId;
-    }
-    public void setUniqueId(String uniqueId) {
-        this.uniqueId = uniqueId;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.ha.session;
+
+
+import org.apache.catalina.ha.ClusterMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.ha.ClusterMessageBase;
+
+/**
+ * Session cluster message
+ * 
+ * @author Filip Hanik
+ * @author Peter Rossbach
+ * 
+ * @version $Revision: 326110 $ $Date: 2005-10-18 09:08:36 -0500 (Tue, 18 Oct 2005) $
+ */
+public class SessionMessageImpl extends ClusterMessageBase implements SessionMessage, java.io.Serializable {
+    
+    public SessionMessageImpl() {
+    }
+    
+    
+    /*
+
+     * Private serializable variables to keep the messages state
+     */
+    private int mEvtType = -1;
+    private byte[] mSession;
+    private String mSessionID;
+
+    private String mContextName;
+    private long serializationTimestamp;
+    private boolean timestampSet = false ;
+    private String uniqueId;
+
+
+    private SessionMessageImpl( String contextName,
+                           int eventtype,
+                           byte[] session,
+                           String sessionID)
+    {
+        mEvtType = eventtype;
+        mSession = session;
+        mSessionID = sessionID;
+        mContextName = contextName;
+        uniqueId = sessionID;
+    }
+
+    /**
+     * Creates a session message. Depending on what event type you want this
+     * message to represent, you populate the different parameters in the constructor<BR>
+      * The following rules apply dependent on what event type argument you use:<BR>
+     * <B>EVT_SESSION_CREATED</B><BR>
+     *    The parameters: session, sessionID must be set.<BR>
+     * <B>EVT_SESSION_EXPIRED</B><BR>
+     *    The parameters: sessionID must be set.<BR>
+     * <B>EVT_SESSION_ACCESSED</B><BR>
+     *    The parameters: sessionID must be set.<BR>
+     * <B>EVT_SESSION_EXPIRED_XXXX</B><BR>
+     *    The parameters: sessionID must be set.<BR>
+     * <B>EVT_SESSION_DELTA</B><BR>
+     *    Send attribute delta (add,update,remove attribute or principal, ...).<BR>
+     * <B>EVT_ALL_SESSION_DATA</B><BR>
+     *    Send complete serializes session list<BR>
+     * <B>EVT_ALL_SESSION_TRANSFERCOMPLETE</B><BR>
+     *    send that all session state information are transfered
+     *    after GET_ALL_SESSION received from this sender.<BR>
+     * @param contextName - the name of the context (application
+     * @param eventtype - one of the 8 event type defined in this class
+     * @param session - the serialized byte array of the session itself
+     * @param sessionID - the id that identifies this session
+     * @param uniqueID - the id that identifies this message
+     */
+    public SessionMessageImpl( String contextName,
+                           int eventtype,
+                           byte[] session,
+                           String sessionID,
+                           String uniqueID)
+    {
+        this(contextName,eventtype,session,sessionID);
+        uniqueId = uniqueID;
+    }
+
+    /**
+     * returns the event type
+     * @return one of the event types EVT_XXXX
+     */
+    public int getEventType() { return mEvtType; }
+
+    /**
+     * @return the serialized data for the session
+     */
+    public byte[] getSession() { return mSession;}
+
+    /**
+     * @return the session ID for the session
+     */
+    public String getSessionID(){ return mSessionID; }
+    
+    /**
+     * set message send time but only the first setting works (one shot)
+     */
+    public void setTimestamp(long time) {
+        synchronized(this) {
+            if(!timestampSet) {
+                serializationTimestamp=time;
+                timestampSet = true ;
+            }
+        }
+    }
+    
+    public long getTimestamp() { return serializationTimestamp;}
+    
+    /**
+     * clear text event type name (for logging purpose only) 
+     * @return the event type in a string representating, useful for debugging
+     */
+    public String getEventTypeString()
+    {
+        switch (mEvtType)
+        {
+            case EVT_SESSION_CREATED : return "SESSION-MODIFIED";
+            case EVT_SESSION_EXPIRED : return "SESSION-EXPIRED";
+            case EVT_SESSION_ACCESSED : return "SESSION-ACCESSED";
+            case EVT_GET_ALL_SESSIONS : return "SESSION-GET-ALL";
+            case EVT_SESSION_DELTA : return "SESSION-DELTA";
+            case EVT_ALL_SESSION_DATA : return "ALL-SESSION-DATA";
+            case EVT_ALL_SESSION_TRANSFERCOMPLETE : return "SESSION-STATE-TRANSFERED";
+            default : return "UNKNOWN-EVENT-TYPE";
+        }
+    }
+
+    public String getContextName() {
+       return mContextName;
+    }
+    public String getUniqueId() {
+        return uniqueId;
+    }
+    public void setUniqueId(String uniqueId) {
+        this.uniqueId = uniqueId;
+    }
+
+}

==================================================
Constants.java
index 99ef6a8e98..b4e89cd982 100644
--- a/java/org/apache/catalina/ha/session/SimpleTcpReplicationManager.java
+++ b/java/org/apache/catalina/ha/session/SimpleTcpReplicationManager.java
@@ -1,684 +1,685 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.ha.session;
-
-import java.io.IOException;
-
-import org.apache.catalina.LifecycleException;
-import org.apache.catalina.Session;
-import org.apache.catalina.ha.CatalinaCluster;
-import org.apache.catalina.ha.ClusterManager;
-import org.apache.catalina.ha.ClusterMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.realm.GenericPrincipal;
-import org.apache.catalina.session.StandardManager;
-import org.apache.catalina.tribes.io.ReplicationStream;
-import java.io.ByteArrayInputStream;
-import org.apache.catalina.Loader;
-
-/**
- * Title:        Tomcat Session Replication for Tomcat 4.0 <BR>
- * Description:  A very simple straight forward implementation of
- *               session replication of servers in a cluster.<BR>
- *               This session replication is implemented "live". By live
- *               I mean, when a session attribute is added into a session on Node A
- *               a message is broadcasted to other messages and setAttribute is called on the
- *               replicated sessions.<BR>
- *               A full description of this implementation can be found under
- *               <href="http://www.filip.net/tomcat/">Filip's Tomcat Page</a><BR>
- *
- * Copyright:    See apache license
- * Company:      www.filip.net
- * @author  <a href="mailto:mail@filip.net">Filip Hanik</a>
- * @author Bela Ban (modifications for synchronous replication)
- * @version 1.0 for TC 4.0
- * Description: The InMemoryReplicationManager is a session manager that replicated
- * session information in memory. 
- * <BR><BR>
- * The InMemoryReplicationManager extends the StandardManager hence it allows for us
- * to inherit all the basic session management features like expiration, session listeners etc
- * <BR><BR>
- * To communicate with other nodes in the cluster, the InMemoryReplicationManager sends out 7 different type of multicast messages
- * all defined in the SessionMessage class.<BR>
- * When a session is replicated (not an attribute added/removed) the session is serialized into
- * a byte array using the StandardSession.readObjectData, StandardSession.writeObjectData methods.
- */
-public class SimpleTcpReplicationManager extends StandardManager implements ClusterManager
-{
-    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( SimpleTcpReplicationManager.class );
-
-    //the channel configuration
-    protected String mChannelConfig = null;
-
-    //the group name
-    protected String mGroupName = "TomcatReplication";
-
-    //somehow start() gets called more than once
-    protected boolean mChannelStarted = false;
-
-    //log to screen
-    protected boolean mPrintToScreen = true;
-
-    protected boolean defaultMode = false;
-
-    protected boolean mManagerRunning = false;
-
-    /** Use synchronous rather than asynchronous replication. Every session modification (creation, change, removal etc)
-     * will be sent to all members. The call will then wait for max milliseconds, or forever (if timeout is 0) for
-     * all responses.
-     */
-    protected boolean synchronousReplication=true;
-
-    /** Set to true if we don't want the sessions to expire on shutdown */
-    protected boolean mExpireSessionsOnShutdown = true;
-
-    protected boolean useDirtyFlag = false;
-
-    protected String name;
-
-    protected boolean distributable = true;
-
-    protected CatalinaCluster cluster;
-
-    protected java.util.HashMap invalidatedSessions = new java.util.HashMap();
-
-    /**
-     * Flag to keep track if the state has been transferred or not
-     * Assumes false.
-     */
-    protected boolean stateTransferred = false;
-    private boolean notifyListenersOnReplication;
-    private boolean sendClusterDomainOnly = true ;
-
-    /**
-     * Constructor, just calls super()
-     *
-     */
-    public SimpleTcpReplicationManager()
-    {
-        super();
-    }
-
-    public boolean doDomainReplication() {
-        return sendClusterDomainOnly;
-    }
-    
-    /**
-     * @param sendClusterDomainOnly The sendClusterDomainOnly to set.
-     */
-    public void setDomainReplication(boolean sendClusterDomainOnly) {
-        this.sendClusterDomainOnly = sendClusterDomainOnly;
-    }
-  
-    /**
-     * @return Returns the defaultMode.
-     */
-    public boolean isDefaultMode() {
-        return defaultMode;
-    }
-    /**
-     * @param defaultMode The defaultMode to set.
-     */
-    public void setDefaultMode(boolean defaultMode) {
-        this.defaultMode = defaultMode;
-    }
-    
-    public boolean isManagerRunning()
-    {
-        return mManagerRunning;
-    }
-
-    public void setUseDirtyFlag(boolean usedirtyflag)
-    {
-        this.useDirtyFlag = usedirtyflag;
-    }
-
-    public void setExpireSessionsOnShutdown(boolean expireSessionsOnShutdown)
-    {
-        mExpireSessionsOnShutdown = expireSessionsOnShutdown;
-    }
-
-    public void setCluster(CatalinaCluster cluster) {
-        if(log.isDebugEnabled())
-            log.debug("Cluster associated with SimpleTcpReplicationManager");
-        this.cluster = cluster;
-    }
-
-    public boolean getExpireSessionsOnShutdown()
-    {
-        return mExpireSessionsOnShutdown;
-    }
-
-    public void setPrintToScreen(boolean printtoscreen)
-    {
-        if(log.isDebugEnabled())
-            log.debug("Setting screen debug to:"+printtoscreen);
-        mPrintToScreen = printtoscreen;
-    }
-
-    public void setSynchronousReplication(boolean flag)
-    {
-        synchronousReplication=flag;
-    }
-
-    /**
-     * Override persistence since they don't go hand in hand with replication for now.
-     */
-    public void unload() throws IOException {
-        if ( !getDistributable() ) {
-            super.unload();
-        }
-    }
-
-    /**
-     * Creates a HTTP session.
-     * Most of the code in here is copied from the StandardManager.
-     * This is not pretty, yeah I know, but it was necessary since the
-     * StandardManager had hard coded the session instantiation to the a
-     * StandardSession, when we actually want to instantiate a ReplicatedSession<BR>
-     * If the call comes from the Tomcat servlet engine, a SessionMessage goes out to the other
-     * nodes in the cluster that this session has been created.
-     * @param notify - if set to true the other nodes in the cluster will be notified.
-     *                 This flag is needed so that we can create a session before we deserialize
-     *                 a replicated one
-     *
-     * @see ReplicatedSession
-     */
-    protected Session createSession(String sessionId, boolean notify, boolean setId)
-    {
-
-        //inherited from the basic manager
-        if ((getMaxActiveSessions() >= 0) &&
-           (sessions.size() >= getMaxActiveSessions()))
-            throw new IllegalStateException(sm.getString("standardManager.createSession.ise"));
-
-
-        Session session = new ReplicatedSession(this);
-
-        // Initialize the properties of the new session and return it
-        session.setNew(true);
-        session.setValid(true);
-        session.setCreationTime(System.currentTimeMillis());
-        session.setMaxInactiveInterval(this.maxInactiveInterval);
-        if(sessionId == null)
-            sessionId = generateSessionId();
-        if ( setId ) session.setId(sessionId);
-        if ( notify && (cluster!=null) ) {
-            ((ReplicatedSession)session).setIsDirty(true);
-        }
-        return (session);
-    }//createSession
-
-    //=========================================================================
-    // OVERRIDE THESE METHODS TO IMPLEMENT THE REPLICATION
-    //=========================================================================
-
-    /**
-     * Construct and return a new session object, based on the default
-     * settings specified by this Manager's properties.  The session
-     * id will be assigned by this method, and available via the getId()
-     * method of the returned session.  If a new session cannot be created
-     * for any reason, return <code>null</code>.
-     *
-     * @exception IllegalStateException if a new session cannot be
-     *  instantiated for any reason
-     */
-    public Session createSession(String sessionId)
-    {
-        //create a session and notify the other nodes in the cluster
-        Session session =  createSession(sessionId,getDistributable(),true);
-        add(session);
-        return session;
-    }
-
-    public void sessionInvalidated(String sessionId) {
-        synchronized ( invalidatedSessions ) {
-            invalidatedSessions.put(sessionId, sessionId);
-        }
-    }
-
-    public String[] getInvalidatedSessions() {
-        synchronized ( invalidatedSessions ) {
-            String[] result = new String[invalidatedSessions.size()];
-            invalidatedSessions.values().toArray(result);
-            return result;
-        }
-
-    }
-
-    public ClusterMessage requestCompleted(String sessionId)
-    {
-        if (  !getDistributable() ) {
-            log.warn("Received requestCompleted message, although this context["+
-                     getName()+"] is not distributable. Ignoring message");
-            return null;
-        }
-        try
-        {
-            if ( invalidatedSessions.get(sessionId) != null ) {
-                synchronized ( invalidatedSessions ) {
-                    invalidatedSessions.remove(sessionId);
-                    SessionMessage msg = new SessionMessageImpl(name,
-                    SessionMessage.EVT_SESSION_EXPIRED,
-                    null,
-                    sessionId,
-                    sessionId);
-                return msg;
-                }
-            } else {
-                ReplicatedSession session = (ReplicatedSession) findSession(
-                    sessionId);
-                if (session != null) {
-                    //return immediately if the session is not dirty
-                    if (useDirtyFlag && (!session.isDirty())) {
-                        //but before we return doing nothing,
-                        //see if we should send
-                        //an updated last access message so that
-                        //sessions across cluster dont expire
-                        long interval = session.getMaxInactiveInterval();
-                        long lastaccdist = System.currentTimeMillis() -
-                            session.getLastAccessWasDistributed();
-                        if ( ((interval*1000) / lastaccdist)< 3 ) {
-                            SessionMessage accmsg = new SessionMessageImpl(name,
-                                SessionMessage.EVT_SESSION_ACCESSED,
-                                null,
-                                sessionId,
-                                sessionId);
-                            session.setLastAccessWasDistributed(System.currentTimeMillis());
-                            return accmsg;
-                        }
-                        return null;
-                    }
-
-                    session.setIsDirty(false);
-                    if (log.isDebugEnabled()) {
-                        try {
-                            log.debug("Sending session to cluster=" + session);
-                        }
-                        catch (Exception ignore) {}
-                    }
-                    SessionMessage msg = new SessionMessageImpl(name,
-                        SessionMessage.EVT_SESSION_CREATED,
-                        writeSession(session),
-                        session.getIdInternal(),
-                        session.getIdInternal());
-                    return msg;
-                } //end if
-            }//end if
-        }
-        catch (Exception x )
-        {
-            log.error("Unable to replicate session",x);
-        }
-        return null;
-    }
-
-    /**
-     * Serialize a session into a byte array<BR>
-     * This method simple calls the writeObjectData method on the session
-     * and returns the byte data from that call
-     * @param session - the session to be serialized
-     * @return a byte array containing the session data, null if the serialization failed
-     */
-    protected byte[] writeSession( Session session )
-    {
-        try
-        {
-            java.io.ByteArrayOutputStream session_data = new java.io.ByteArrayOutputStream();
-            java.io.ObjectOutputStream session_out = new java.io.ObjectOutputStream(session_data);
-            session_out.flush();
-            boolean hasPrincipal = session.getPrincipal() != null;
-            session_out.writeBoolean(hasPrincipal);
-            if ( hasPrincipal )
-            {
-                session_out.writeObject(SerializablePrincipal.createPrincipal((GenericPrincipal)session.getPrincipal()));
-            }//end if
-            ((ReplicatedSession)session).writeObjectData(session_out);
-            return session_data.toByteArray();
-
-        }
-        catch ( Exception x )
-        {
-            log.error("Failed to serialize the session!",x);
-        }
-        return null;
-    }
-    
-    /**
-     * Open Stream and use correct ClassLoader (Container) Switch
-     * ThreadClassLoader
-     * 
-     * @param data
-     * @return The object input stream
-     * @throws IOException
-     */
-    public ReplicationStream getReplicationStream(byte[] data) throws IOException {
-        return getReplicationStream(data,0,data.length);
-    }
-    
-    public ReplicationStream getReplicationStream(byte[] data, int offset, int length) throws IOException {
-        ByteArrayInputStream fis =null;
-        ReplicationStream ois = null;
-        Loader loader = null;
-        ClassLoader classLoader = null;
-        //fix to be able to run the DeltaManager
-        //stand alone without a container.
-        //use the Threads context class loader
-        if (container != null)
-            loader = container.getLoader();
-        if (loader != null)
-            classLoader = loader.getClassLoader();
-        else
-            classLoader = Thread.currentThread().getContextClassLoader();
-        //end fix
-        fis = new ByteArrayInputStream(data, offset, length);
-        if ( classLoader == Thread.currentThread().getContextClassLoader() ) {
-            ois = new ReplicationStream(fis, new ClassLoader[] {classLoader});
-        } else {
-            ois = new ReplicationStream(fis, new ClassLoader[] {classLoader,Thread.currentThread().getContextClassLoader()});
-        }
-        return ois;
-    }    
-
-
-    
-
-    /**
-     * Reinstantiates a serialized session from the data passed in.
-     * This will first call createSession() so that we get a fresh instance with all
-     * the managers set and all the transient fields validated.
-     * Then it calls Session.readObjectData(byte[]) to deserialize the object
-     * @param data - a byte array containing session data
-     * @return a valid Session object, null if an error occurs
-     *
-     */
-    protected Session readSession( byte[] data, String sessionId )
-    {
-        try
-        {
-            ReplicationStream session_in = getReplicationStream(data);
-
-            Session session = sessionId!=null?this.findSession(sessionId):null;
-            boolean isNew = (session==null);
-            //clear the old values from the existing session
-            if ( session!=null ) {
-                ReplicatedSession rs = (ReplicatedSession)session;
-                rs.expire(false);  //cleans up the previous values, since we are not doing removes
-                session = null;
-            }//end if
-
-            if (session==null) {
-                session = createSession(null,false, false);
-                sessions.remove(session.getIdInternal());
-            }
-            
-            
-            boolean hasPrincipal = session_in.readBoolean();
-            SerializablePrincipal p = null;
-            if ( hasPrincipal )
-                p = (SerializablePrincipal)session_in.readObject();
-            ((ReplicatedSession)session).readObjectData(session_in);
-            if ( hasPrincipal )
-                session.setPrincipal(p.getPrincipal(getContainer().getRealm()));
-            ((ReplicatedSession)session).setId(sessionId,isNew);
-            ReplicatedSession rsession = (ReplicatedSession)session; 
-            rsession.setAccessCount(1);
-            session.setManager(this);
-            session.setValid(true);
-            rsession.setLastAccessedTime(System.currentTimeMillis());
-            rsession.setThisAccessedTime(System.currentTimeMillis());
-            ((ReplicatedSession)session).setAccessCount(0);
-            session.setNew(false);
-            if(log.isTraceEnabled())
-                 log.trace("Session loaded id="+sessionId +
-                               " actualId="+session.getId()+ 
-                               " exists="+this.sessions.containsKey(sessionId)+
-                               " valid="+rsession.isValid());
-            return session;
-
-        }
-        catch ( Exception x )
-        {
-            log.error("Failed to deserialize the session!",x);
-        }
-        return null;
-    }
-
-    public String getName() {
-        return this.name;
-    }
-    /**
-     * Prepare for the beginning of active use of the public methods of this
-     * component.  This method should be called after <code>configure()</code>,
-     * and before any of the public methods of the component are utilized.<BR>
-     * Starts the cluster communication channel, this will connect with the other nodes
-     * in the cluster, and request the current session state to be transferred to this node.
-     * @exception IllegalStateException if this component has already been
-     *  started
-     * @exception LifecycleException if this component detects a fatal error
-     *  that prevents this component from being used
-     */
-    public void start() throws LifecycleException {
-        mManagerRunning = true;
-        super.start();
-        try {
-            //the channel is already running
-            if ( mChannelStarted ) return;
-            if(log.isInfoEnabled())
-                log.info("Starting clustering manager...:"+getName());
-            if ( cluster == null ) {
-                log.error("Starting... no cluster associated with this context:"+getName());
-                return;
-            }
-            cluster.registerManager(this);
-
-            if (cluster.getMembers().length > 0) {
-                Member mbr = cluster.getMembers()[0];
-                SessionMessage msg =
-                    new SessionMessageImpl(this.getName(),
-                                       SessionMessage.EVT_GET_ALL_SESSIONS,
-                                       null,
-                                       "GET-ALL",
-                                       "GET-ALL-"+this.getName());
-                cluster.send(msg, mbr);
-                if(log.isWarnEnabled())
-                     log.warn("Manager["+getName()+"], requesting session state from "+mbr+
-                         ". This operation will timeout if no session state has been received within "+
-                         "60 seconds");
-                long reqStart = System.currentTimeMillis();
-                long reqNow = 0;
-                boolean isTimeout=false;
-                do {
-                    try {
-                        Thread.sleep(100);
-                    }catch ( Exception sleep) {}
-                    reqNow = System.currentTimeMillis();
-                    isTimeout=((reqNow-reqStart)>(1000*60));
-                } while ( (!isStateTransferred()) && (!isTimeout));
-                if ( isTimeout || (!isStateTransferred()) ) {
-                    log.error("Manager["+getName()+"], No session state received, timing out.");
-                }else {
-                    if(log.isInfoEnabled())
-                        log.info("Manager["+getName()+"], session state received in "+(reqNow-reqStart)+" ms.");
-                }
-            } else {
-                if(log.isInfoEnabled())
-                    log.info("Manager["+getName()+"], skipping state transfer. No members active in cluster group.");
-            }//end if
-            mChannelStarted = true;
-        }  catch ( Exception x ) {
-            log.error("Unable to start SimpleTcpReplicationManager",x);
-        }
-    }
-
-    /**
-     * Gracefully terminate the active use of the public methods of this
-     * component.  This method should be the last one called on a given
-     * instance of this component.<BR>
-     * This will disconnect the cluster communication channel and stop the listener thread.
-     * @exception IllegalStateException if this component has not been started
-     * @exception LifecycleException if this component detects a fatal error
-     *  that needs to be reported
-     */
-    public void stop() throws LifecycleException
-    {
-        mManagerRunning = false;
-        mChannelStarted = false;
-        super.stop();
-        try
-        {
-            this.sessions.clear();
-            cluster.removeManager(this);
-        }
-        catch ( Exception x )
-        {
-            log.error("Unable to stop SimpleTcpReplicationManager",x);
-        }
-    }
-
-    public void setDistributable(boolean dist) {
-        this.distributable = dist;
-    }
-
-    public boolean getDistributable() {
-        return distributable;
-    }
-
-    /**
-     * This method is called by the received thread when a SessionMessage has
-     * been received from one of the other nodes in the cluster.
-     * @param msg - the message received
-     * @param sender - the sender of the message, this is used if we receive a
-     *                 EVT_GET_ALL_SESSION message, so that we only reply to
-     *                 the requesting node
-     */
-    protected void messageReceived( SessionMessage msg, Member sender ) {
-        try  {
-            if(log.isInfoEnabled()) {
-                log.debug("Received SessionMessage of type="+msg.getEventTypeString());
-                log.debug("Received SessionMessage sender="+sender);
-            }
-            switch ( msg.getEventType() ) {
-                case SessionMessage.EVT_GET_ALL_SESSIONS: {
-                    //get a list of all the session from this manager
-                    Object[] sessions = findSessions();
-                    java.io.ByteArrayOutputStream bout = new java.io.ByteArrayOutputStream();
-                    java.io.ObjectOutputStream oout = new java.io.ObjectOutputStream(bout);
-                    oout.writeInt(sessions.length);
-                    for (int i=0; i<sessions.length; i++){
-                        ReplicatedSession ses = (ReplicatedSession)sessions[i];
-                        oout.writeUTF(ses.getIdInternal());
-                        byte[] data = writeSession(ses);
-                        oout.writeObject(data);
-                    }//for
-                    //don't send a message if we don't have to
-                    oout.flush();
-                    oout.close();
-                    byte[] data = bout.toByteArray();
-                    SessionMessage newmsg = new SessionMessageImpl(name,
-                        SessionMessage.EVT_ALL_SESSION_DATA,
-                        data, "SESSION-STATE","SESSION-STATE-"+getName());
-                    cluster.send(newmsg, sender);
-                    break;
-                }
-                case SessionMessage.EVT_ALL_SESSION_DATA: {
-                    java.io.ByteArrayInputStream bin =
-                        new java.io.ByteArrayInputStream(msg.getSession());
-                    java.io.ObjectInputStream oin = new java.io.ObjectInputStream(bin);
-                    int size = oin.readInt();
-                    for ( int i=0; i<size; i++) {
-                        String id = oin.readUTF();
-                        byte[] data = (byte[])oin.readObject();
-                        Session session = readSession(data,id);
-                    }//for
-                    stateTransferred=true;
-                    break;
-                }
-                case SessionMessage.EVT_SESSION_CREATED: {
-                    Session session = this.readSession(msg.getSession(),msg.getSessionID());
-                    if ( log.isDebugEnabled() ) {
-                        log.debug("Received replicated session=" + session +
-                            " isValid=" + session.isValid());
-                    }
-                    break;
-                }
-                case SessionMessage.EVT_SESSION_EXPIRED: {
-                    Session session = findSession(msg.getSessionID());
-                    if ( session != null ) {
-                        session.expire();
-                        this.remove(session);
-                    }//end if
-                    break;
-                }
-                case SessionMessage.EVT_SESSION_ACCESSED :{
-                    Session session = findSession(msg.getSessionID());
-                    if ( session != null ) {
-                        session.access();
-                        session.endAccess();
-                    }
-                    break;
-                }
-                default:  {
-                    //we didn't recognize the message type, do nothing
-                    break;
-                }
-            }//switch
-        }
-        catch ( Exception x )
-        {
-            log.error("Unable to receive message through TCP channel",x);
-        }
-    }
-
-    public void messageDataReceived(ClusterMessage cmsg) {
-        try {
-            if ( cmsg instanceof SessionMessage ) {
-                SessionMessage msg = (SessionMessage)cmsg;
-                messageReceived(msg,
-                                msg.getAddress() != null ? (Member) msg.getAddress() : null);
-            }
-        } catch(Throwable ex){
-            log.error("InMemoryReplicationManager.messageDataReceived()", ex);
-        }//catch
-    }
-
-    public boolean isStateTransferred() {
-        return stateTransferred;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-    public boolean isNotifyListenersOnReplication() {
-        return notifyListenersOnReplication;
-    }
-    public void setNotifyListenersOnReplication(boolean notifyListenersOnReplication) {
-        this.notifyListenersOnReplication = notifyListenersOnReplication;
-    }
-
-
-    /* 
-     * @see org.apache.catalina.ha.ClusterManager#getCluster()
-     */
-    public CatalinaCluster getCluster() {
-        return cluster;
-    }
-
-    public ClusterManager cloneFromTemplate() {
-        throw new UnsupportedOperationException();
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.ha.session;
+
+import java.io.IOException;
+
+import org.apache.catalina.LifecycleException;
+import org.apache.catalina.Session;
+import org.apache.catalina.ha.CatalinaCluster;
+import org.apache.catalina.ha.ClusterManager;
+import org.apache.catalina.ha.ClusterMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.realm.GenericPrincipal;
+import org.apache.catalina.session.StandardManager;
+import org.apache.catalina.tribes.io.ReplicationStream;
+import java.io.ByteArrayInputStream;
+import org.apache.catalina.Loader;
+
+/**
+ * Title:        Tomcat Session Replication for Tomcat 4.0 <BR>
+ * Description:  A very simple straight forward implementation of
+ *               session replication of servers in a cluster.<BR>
+ *               This session replication is implemented "live". By live
+ *               I mean, when a session attribute is added into a session on Node A
+ *               a message is broadcasted to other messages and setAttribute is called on the
+ *               replicated sessions.<BR>
+ *               A full description of this implementation can be found under
+ *               <href="http://www.filip.net/tomcat/">Filip's Tomcat Page</a><BR>
+ *
+ * Copyright:    See apache license
+ * Company:      www.filip.net
+ * @author  <a href="mailto:mail@filip.net">Filip Hanik</a>
+ * @author Bela Ban (modifications for synchronous replication)
+ * @version 1.0 for TC 4.0
+ * Description: The InMemoryReplicationManager is a session manager that replicated
+ * session information in memory. 
+ * <BR><BR>
+ * The InMemoryReplicationManager extends the StandardManager hence it allows for us
+ * to inherit all the basic session management features like expiration, session listeners etc
+ * <BR><BR>
+ * To communicate with other nodes in the cluster, the InMemoryReplicationManager sends out 7 different type of multicast messages
+ * all defined in the SessionMessage class.<BR>
+ * When a session is replicated (not an attribute added/removed) the session is serialized into
+ * a byte array using the StandardSession.readObjectData, StandardSession.writeObjectData methods.
+ */
+public class SimpleTcpReplicationManager extends StandardManager implements ClusterManager
+{
+    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( SimpleTcpReplicationManager.class );
+
+    //the channel configuration
+    protected String mChannelConfig = null;
+
+    //the group name
+    protected String mGroupName = "TomcatReplication";
+
+    //somehow start() gets called more than once
+    protected boolean mChannelStarted = false;
+
+    //log to screen
+    protected boolean mPrintToScreen = true;
+
+    protected boolean defaultMode = false;
+
+    protected boolean mManagerRunning = false;
+
+    /** Use synchronous rather than asynchronous replication. Every session modification (creation, change, removal etc)
+     * will be sent to all members. The call will then wait for max milliseconds, or forever (if timeout is 0) for
+     * all responses.
+     */
+    protected boolean synchronousReplication=true;
+
+    /** Set to true if we don't want the sessions to expire on shutdown */
+    protected boolean mExpireSessionsOnShutdown = true;
+
+    protected boolean useDirtyFlag = false;
+
+    protected String name;
+
+    protected boolean distributable = true;
+
+    protected CatalinaCluster cluster;
+
+    protected java.util.HashMap invalidatedSessions = new java.util.HashMap();
+
+    /**
+     * Flag to keep track if the state has been transferred or not
+     * Assumes false.
+     */
+    protected boolean stateTransferred = false;
+    private boolean notifyListenersOnReplication;
+    private boolean sendClusterDomainOnly = true ;
+
+    /**
+     * Constructor, just calls super()
+     *
+     */
+    public SimpleTcpReplicationManager()
+    {
+        super();
+    }
+
+    public boolean doDomainReplication() {
+        return sendClusterDomainOnly;
+    }
+    
+    /**
+     * @param sendClusterDomainOnly The sendClusterDomainOnly to set.
+     */
+    public void setDomainReplication(boolean sendClusterDomainOnly) {
+        this.sendClusterDomainOnly = sendClusterDomainOnly;
+    }
+  
+    /**
+     * @return Returns the defaultMode.
+     */
+    public boolean isDefaultMode() {
+        return defaultMode;
+    }
+    /**
+     * @param defaultMode The defaultMode to set.
+     */
+    public void setDefaultMode(boolean defaultMode) {
+        this.defaultMode = defaultMode;
+    }
+    
+    public boolean isManagerRunning()
+    {
+        return mManagerRunning;
+    }
+
+    public void setUseDirtyFlag(boolean usedirtyflag)
+    {
+        this.useDirtyFlag = usedirtyflag;
+    }
+
+    public void setExpireSessionsOnShutdown(boolean expireSessionsOnShutdown)
+    {
+        mExpireSessionsOnShutdown = expireSessionsOnShutdown;
+    }
+
+    public void setCluster(CatalinaCluster cluster) {
+        if(log.isDebugEnabled())
+            log.debug("Cluster associated with SimpleTcpReplicationManager");
+        this.cluster = cluster;
+    }
+
+    public boolean getExpireSessionsOnShutdown()
+    {
+        return mExpireSessionsOnShutdown;
+    }
+
+    public void setPrintToScreen(boolean printtoscreen)
+    {
+        if(log.isDebugEnabled())
+            log.debug("Setting screen debug to:"+printtoscreen);
+        mPrintToScreen = printtoscreen;
+    }
+
+    public void setSynchronousReplication(boolean flag)
+    {
+        synchronousReplication=flag;
+    }
+
+    /**
+     * Override persistence since they don't go hand in hand with replication for now.
+     */
+    public void unload() throws IOException {
+        if ( !getDistributable() ) {
+            super.unload();
+        }
+    }
+
+    /**
+     * Creates a HTTP session.
+     * Most of the code in here is copied from the StandardManager.
+     * This is not pretty, yeah I know, but it was necessary since the
+     * StandardManager had hard coded the session instantiation to the a
+     * StandardSession, when we actually want to instantiate a ReplicatedSession<BR>
+     * If the call comes from the Tomcat servlet engine, a SessionMessage goes out to the other
+     * nodes in the cluster that this session has been created.
+     * @param notify - if set to true the other nodes in the cluster will be notified.
+     *                 This flag is needed so that we can create a session before we deserialize
+     *                 a replicated one
+     *
+     * @see ReplicatedSession
+     */
+    protected Session createSession(String sessionId, boolean notify, boolean setId)
+    {
+
+        //inherited from the basic manager
+        if ((getMaxActiveSessions() >= 0) &&
+           (sessions.size() >= getMaxActiveSessions()))
+            throw new IllegalStateException(sm.getString("standardManager.createSession.ise"));
+
+
+        Session session = new ReplicatedSession(this);
+
+        // Initialize the properties of the new session and return it
+        session.setNew(true);
+        session.setValid(true);
+        session.setCreationTime(System.currentTimeMillis());
+        session.setMaxInactiveInterval(this.maxInactiveInterval);
+        if(sessionId == null)
+            sessionId = generateSessionId();
+        if ( setId ) session.setId(sessionId);
+        if ( notify && (cluster!=null) ) {
+            ((ReplicatedSession)session).setIsDirty(true);
+        }
+        return (session);
+    }//createSession
+
+    //=========================================================================
+    // OVERRIDE THESE METHODS TO IMPLEMENT THE REPLICATION
+    //=========================================================================
+
+    /**
+     * Construct and return a new session object, based on the default
+     * settings specified by this Manager's properties.  The session
+     * id will be assigned by this method, and available via the getId()
+     * method of the returned session.  If a new session cannot be created
+     * for any reason, return <code>null</code>.
+     *
+     * @exception IllegalStateException if a new session cannot be
+     *  instantiated for any reason
+     */
+    public Session createSession(String sessionId)
+    {
+        //create a session and notify the other nodes in the cluster
+        Session session =  createSession(sessionId,getDistributable(),true);
+        add(session);
+        return session;
+    }
+
+    public void sessionInvalidated(String sessionId) {
+        synchronized ( invalidatedSessions ) {
+            invalidatedSessions.put(sessionId, sessionId);
+        }
+    }
+
+    public String[] getInvalidatedSessions() {
+        synchronized ( invalidatedSessions ) {
+            String[] result = new String[invalidatedSessions.size()];
+            invalidatedSessions.values().toArray(result);
+            return result;
+        }
+
+    }
+
+    public ClusterMessage requestCompleted(String sessionId)
+    {
+        if (  !getDistributable() ) {
+            log.warn("Received requestCompleted message, although this context["+
+                     getName()+"] is not distributable. Ignoring message");
+            return null;
+        }
+        try
+        {
+            if ( invalidatedSessions.get(sessionId) != null ) {
+                synchronized ( invalidatedSessions ) {
+                    invalidatedSessions.remove(sessionId);
+                    SessionMessage msg = new SessionMessageImpl(name,
+                    SessionMessage.EVT_SESSION_EXPIRED,
+                    null,
+                    sessionId,
+                    sessionId);
+                return msg;
+                }
+            } else {
+                ReplicatedSession session = (ReplicatedSession) findSession(
+                    sessionId);
+                if (session != null) {
+                    //return immediately if the session is not dirty
+                    if (useDirtyFlag && (!session.isDirty())) {
+                        //but before we return doing nothing,
+                        //see if we should send
+                        //an updated last access message so that
+                        //sessions across cluster dont expire
+                        long interval = session.getMaxInactiveInterval();
+                        long lastaccdist = System.currentTimeMillis() -
+                            session.getLastAccessWasDistributed();
+                        if ( ((interval*1000) / lastaccdist)< 3 ) {
+                            SessionMessage accmsg = new SessionMessageImpl(name,
+                                SessionMessage.EVT_SESSION_ACCESSED,
+                                null,
+                                sessionId,
+                                sessionId);
+                            session.setLastAccessWasDistributed(System.currentTimeMillis());
+                            return accmsg;
+                        }
+                        return null;
+                    }
+
+                    session.setIsDirty(false);
+                    if (log.isDebugEnabled()) {
+                        try {
+                            log.debug("Sending session to cluster=" + session);
+                        }
+                        catch (Exception ignore) {}
+                    }
+                    SessionMessage msg = new SessionMessageImpl(name,
+                        SessionMessage.EVT_SESSION_CREATED,
+                        writeSession(session),
+                        session.getIdInternal(),
+                        session.getIdInternal());
+                    return msg;
+                } //end if
+            }//end if
+        }
+        catch (Exception x )
+        {
+            log.error("Unable to replicate session",x);
+        }
+        return null;
+    }
+
+    /**
+     * Serialize a session into a byte array<BR>
+     * This method simple calls the writeObjectData method on the session
+     * and returns the byte data from that call
+     * @param session - the session to be serialized
+     * @return a byte array containing the session data, null if the serialization failed
+     */
+    protected byte[] writeSession( Session session )
+    {
+        try
+        {
+            java.io.ByteArrayOutputStream session_data = new java.io.ByteArrayOutputStream();
+            java.io.ObjectOutputStream session_out = new java.io.ObjectOutputStream(session_data);
+            session_out.flush();
+            boolean hasPrincipal = session.getPrincipal() != null;
+            session_out.writeBoolean(hasPrincipal);
+            if ( hasPrincipal )
+            {
+                session_out.writeObject(SerializablePrincipal.createPrincipal((GenericPrincipal)session.getPrincipal()));
+            }//end if
+            ((ReplicatedSession)session).writeObjectData(session_out);
+            return session_data.toByteArray();
+
+        }
+        catch ( Exception x )
+        {
+            log.error("Failed to serialize the session!",x);
+        }
+        return null;
+    }
+    
+    /**
+     * Open Stream and use correct ClassLoader (Container) Switch
+     * ThreadClassLoader
+     * 
+     * @param data
+     * @return The object input stream
+     * @throws IOException
+     */
+    public ReplicationStream getReplicationStream(byte[] data) throws IOException {
+        return getReplicationStream(data,0,data.length);
+    }
+    
+    public ReplicationStream getReplicationStream(byte[] data, int offset, int length) throws IOException {
+        ByteArrayInputStream fis =null;
+        ReplicationStream ois = null;
+        Loader loader = null;
+        ClassLoader classLoader = null;
+        //fix to be able to run the DeltaManager
+        //stand alone without a container.
+        //use the Threads context class loader
+        if (container != null)
+            loader = container.getLoader();
+        if (loader != null)
+            classLoader = loader.getClassLoader();
+        else
+            classLoader = Thread.currentThread().getContextClassLoader();
+        //end fix
+        fis = new ByteArrayInputStream(data, offset, length);
+        if ( classLoader == Thread.currentThread().getContextClassLoader() ) {
+            ois = new ReplicationStream(fis, new ClassLoader[] {classLoader});
+        } else {
+            ois = new ReplicationStream(fis, new ClassLoader[] {classLoader,Thread.currentThread().getContextClassLoader()});
+        }
+        return ois;
+    }    
+
+
+    
+
+    /**
+     * Reinstantiates a serialized session from the data passed in.
+     * This will first call createSession() so that we get a fresh instance with all
+     * the managers set and all the transient fields validated.
+     * Then it calls Session.readObjectData(byte[]) to deserialize the object
+     * @param data - a byte array containing session data
+     * @return a valid Session object, null if an error occurs
+     *
+     */
+    protected Session readSession( byte[] data, String sessionId )
+    {
+        try
+        {
+            ReplicationStream session_in = getReplicationStream(data);
+
+            Session session = sessionId!=null?this.findSession(sessionId):null;
+            boolean isNew = (session==null);
+            //clear the old values from the existing session
+            if ( session!=null ) {
+                ReplicatedSession rs = (ReplicatedSession)session;
+                rs.expire(false);  //cleans up the previous values, since we are not doing removes
+                session = null;
+            }//end if
+
+            if (session==null) {
+                session = createSession(null,false, false);
+                sessions.remove(session.getIdInternal());
+            }
+            
+            
+            boolean hasPrincipal = session_in.readBoolean();
+            SerializablePrincipal p = null;
+            if ( hasPrincipal )
+                p = (SerializablePrincipal)session_in.readObject();
+            ((ReplicatedSession)session).readObjectData(session_in);
+            if ( hasPrincipal )
+                session.setPrincipal(p.getPrincipal(getContainer().getRealm()));
+            ((ReplicatedSession)session).setId(sessionId,isNew);
+            ReplicatedSession rsession = (ReplicatedSession)session; 
+            rsession.setAccessCount(1);
+            session.setManager(this);
+            session.setValid(true);
+            rsession.setLastAccessedTime(System.currentTimeMillis());
+            rsession.setThisAccessedTime(System.currentTimeMillis());
+            ((ReplicatedSession)session).setAccessCount(0);
+            session.setNew(false);
+            if(log.isTraceEnabled())
+                 log.trace("Session loaded id="+sessionId +
+                               " actualId="+session.getId()+ 
+                               " exists="+this.sessions.containsKey(sessionId)+
+                               " valid="+rsession.isValid());
+            return session;
+
+        }
+        catch ( Exception x )
+        {
+            log.error("Failed to deserialize the session!",x);
+        }
+        return null;
+    }
+
+    public String getName() {
+        return this.name;
+    }
+    /**
+     * Prepare for the beginning of active use of the public methods of this
+     * component.  This method should be called after <code>configure()</code>,
+     * and before any of the public methods of the component are utilized.<BR>
+     * Starts the cluster communication channel, this will connect with the other nodes
+     * in the cluster, and request the current session state to be transferred to this node.
+     * @exception IllegalStateException if this component has already been
+     *  started
+     * @exception LifecycleException if this component detects a fatal error
+     *  that prevents this component from being used
+     */
+    public void start() throws LifecycleException {
+        mManagerRunning = true;
+        super.start();
+        try {
+            //the channel is already running
+            if ( mChannelStarted ) return;
+            if(log.isInfoEnabled())
+                log.info("Starting clustering manager...:"+getName());
+            if ( cluster == null ) {
+                log.error("Starting... no cluster associated with this context:"+getName());
+                return;
+            }
+            cluster.registerManager(this);
+
+            if (cluster.getMembers().length > 0) {
+                Member mbr = cluster.getMembers()[0];
+                SessionMessage msg =
+                    new SessionMessageImpl(this.getName(),
+                                       SessionMessage.EVT_GET_ALL_SESSIONS,
+                                       null,
+                                       "GET-ALL",
+                                       "GET-ALL-"+this.getName());
+                cluster.send(msg, mbr);
+                if(log.isWarnEnabled())
+                     log.warn("Manager["+getName()+"], requesting session state from "+mbr+
+                         ". This operation will timeout if no session state has been received within "+
+                         "60 seconds");
+                long reqStart = System.currentTimeMillis();
+                long reqNow = 0;
+                boolean isTimeout=false;
+                do {
+                    try {
+                        Thread.sleep(100);
+                    }catch ( Exception sleep) {}
+                    reqNow = System.currentTimeMillis();
+                    isTimeout=((reqNow-reqStart)>(1000*60));
+                } while ( (!isStateTransferred()) && (!isTimeout));
+                if ( isTimeout || (!isStateTransferred()) ) {
+                    log.error("Manager["+getName()+"], No session state received, timing out.");
+                }else {
+                    if(log.isInfoEnabled())
+                        log.info("Manager["+getName()+"], session state received in "+(reqNow-reqStart)+" ms.");
+                }
+            } else {
+                if(log.isInfoEnabled())
+                    log.info("Manager["+getName()+"], skipping state transfer. No members active in cluster group.");
+            }//end if
+            mChannelStarted = true;
+        }  catch ( Exception x ) {
+            log.error("Unable to start SimpleTcpReplicationManager",x);
+        }
+    }
+
+    /**
+     * Gracefully terminate the active use of the public methods of this
+     * component.  This method should be the last one called on a given
+     * instance of this component.<BR>
+     * This will disconnect the cluster communication channel and stop the listener thread.
+     * @exception IllegalStateException if this component has not been started
+     * @exception LifecycleException if this component detects a fatal error
+     *  that needs to be reported
+     */
+    public void stop() throws LifecycleException
+    {
+        mManagerRunning = false;
+        mChannelStarted = false;
+        super.stop();
+        try
+        {
+            this.sessions.clear();
+            cluster.removeManager(this);
+        }
+        catch ( Exception x )
+        {
+            log.error("Unable to stop SimpleTcpReplicationManager",x);
+        }
+    }
+
+    public void setDistributable(boolean dist) {
+        this.distributable = dist;
+    }
+
+    public boolean getDistributable() {
+        return distributable;
+    }
+
+    /**
+     * This method is called by the received thread when a SessionMessage has
+     * been received from one of the other nodes in the cluster.
+     * @param msg - the message received
+     * @param sender - the sender of the message, this is used if we receive a
+     *                 EVT_GET_ALL_SESSION message, so that we only reply to
+     *                 the requesting node
+     */
+    protected void messageReceived( SessionMessage msg, Member sender ) {
+        try  {
+            if(log.isInfoEnabled()) {
+                log.debug("Received SessionMessage of type="+msg.getEventTypeString());
+                log.debug("Received SessionMessage sender="+sender);
+            }
+            switch ( msg.getEventType() ) {
+                case SessionMessage.EVT_GET_ALL_SESSIONS: {
+                    //get a list of all the session from this manager
+                    Object[] sessions = findSessions();
+                    java.io.ByteArrayOutputStream bout = new java.io.ByteArrayOutputStream();
+                    java.io.ObjectOutputStream oout = new java.io.ObjectOutputStream(bout);
+                    oout.writeInt(sessions.length);
+                    for (int i=0; i<sessions.length; i++){
+                        ReplicatedSession ses = (ReplicatedSession)sessions[i];
+                        oout.writeUTF(ses.getIdInternal());
+                        byte[] data = writeSession(ses);
+                        oout.writeObject(data);
+                    }//for
+                    //don't send a message if we don't have to
+                    oout.flush();
+                    oout.close();
+                    byte[] data = bout.toByteArray();
+                    SessionMessage newmsg = new SessionMessageImpl(name,
+                        SessionMessage.EVT_ALL_SESSION_DATA,
+                        data, "SESSION-STATE","SESSION-STATE-"+getName());
+                    cluster.send(newmsg, sender);
+                    break;
+                }
+                case SessionMessage.EVT_ALL_SESSION_DATA: {
+                    java.io.ByteArrayInputStream bin =
+                        new java.io.ByteArrayInputStream(msg.getSession());
+                    java.io.ObjectInputStream oin = new java.io.ObjectInputStream(bin);
+                    int size = oin.readInt();
+                    for ( int i=0; i<size; i++) {
+                        String id = oin.readUTF();
+                        byte[] data = (byte[])oin.readObject();
+                        Session session = readSession(data,id);
+                    }//for
+                    stateTransferred=true;
+                    break;
+                }
+                case SessionMessage.EVT_SESSION_CREATED: {
+                    Session session = this.readSession(msg.getSession(),msg.getSessionID());
+                    if ( log.isDebugEnabled() ) {
+                        log.debug("Received replicated session=" + session +
+                            " isValid=" + session.isValid());
+                    }
+                    break;
+                }
+                case SessionMessage.EVT_SESSION_EXPIRED: {
+                    Session session = findSession(msg.getSessionID());
+                    if ( session != null ) {
+                        session.expire();
+                        this.remove(session);
+                    }//end if
+                    break;
+                }
+                case SessionMessage.EVT_SESSION_ACCESSED :{
+                    Session session = findSession(msg.getSessionID());
+                    if ( session != null ) {
+                        session.access();
+                        session.endAccess();
+                    }
+                    break;
+                }
+                default:  {
+                    //we didn't recognize the message type, do nothing
+                    break;
+                }
+            }//switch
+        }
+        catch ( Exception x )
+        {
+            log.error("Unable to receive message through TCP channel",x);
+        }
+    }
+
+    public void messageDataReceived(ClusterMessage cmsg) {
+        try {
+            if ( cmsg instanceof SessionMessage ) {
+                SessionMessage msg = (SessionMessage)cmsg;
+                messageReceived(msg,
+                                msg.getAddress() != null ? (Member) msg.getAddress() : null);
+            }
+        } catch(Throwable ex){
+            log.error("InMemoryReplicationManager.messageDataReceived()", ex);
+        }//catch
+    }
+
+    public boolean isStateTransferred() {
+        return stateTransferred;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+    public boolean isNotifyListenersOnReplication() {
+        return notifyListenersOnReplication;
+    }
+    public void setNotifyListenersOnReplication(boolean notifyListenersOnReplication) {
+        this.notifyListenersOnReplication = notifyListenersOnReplication;
+    }
+
+
+    /* 
+     * @see org.apache.catalina.ha.ClusterManager#getCluster()
+     */
+    public CatalinaCluster getCluster() {
+        return cluster;
+    }
+
+    public ClusterManager cloneFromTemplate() {
+        throw new UnsupportedOperationException();
+    }
+
+}

==================================================
ReplicationValve.java
index 7ed1dd583b..01fa2571d4 100644
--- a/java/org/apache/catalina/ha/tcp/Constants.java
+++ b/java/org/apache/catalina/ha/tcp/Constants.java
@@ -1,32 +1,33 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina.ha.tcp;
-
-/**
- * Manifest constants for the <code>org.apache.catalina.ha.tcp</code>
- * package.
- *
- * @author Peter Rossbach
- * @version $Revision: 303753 $ $Date: 2005-03-14 15:24:30 -0600 (Mon, 14 Mar 2005) $
- */
-
-public class Constants {
-
-    public static final String Package = "org.apache.catalina.ha.tcp";
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.catalina.ha.tcp;
+
+/**
+ * Manifest constants for the <code>org.apache.catalina.ha.tcp</code>
+ * package.
+ *
+ * @author Peter Rossbach
+ * @version $Revision: 303753 $ $Date: 2005-03-14 15:24:30 -0600 (Mon, 14 Mar 2005) $
+ */
+
+public class Constants {
+
+    public static final String Package = "org.apache.catalina.ha.tcp";
+
+}

==================================================
SimpleTcpCluster.java
index c1730b83b7..733dae4fc2 100644
--- a/java/org/apache/catalina/ha/tcp/ReplicationValve.java
+++ b/java/org/apache/catalina/ha/tcp/ReplicationValve.java
@@ -1,657 +1,658 @@
-/*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha.tcp;
-
-import java.io.IOException;
-import java.util.StringTokenizer;
-import java.util.regex.Pattern;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Iterator;
-import javax.servlet.ServletException;
-
-import org.apache.catalina.Manager;
-import org.apache.catalina.Session;
-import org.apache.catalina.Context;
-import org.apache.catalina.core.StandardContext;
-import org.apache.catalina.ha.CatalinaCluster;
-import org.apache.catalina.ha.ClusterManager;
-import org.apache.catalina.ha.ClusterMessage;
-import org.apache.catalina.ha.ClusterSession;
-import org.apache.catalina.ha.ClusterValve;
-import org.apache.catalina.ha.session.DeltaManager;
-import org.apache.catalina.ha.session.DeltaSession;
-import org.apache.catalina.connector.Request;
-import org.apache.catalina.connector.Response;
-import org.apache.catalina.util.StringManager;
-import org.apache.catalina.valves.ValveBase;
-
-/**
- * <p>Implementation of a Valve that logs interesting contents from the
- * specified Request (before processing) and the corresponding Response
- * (after processing).  It is especially useful in debugging problems
- * related to headers and cookies.</p>
- *
- * <p>This Valve may be attached to any Container, depending on the granularity
- * of the logging you wish to perform.</p>
- *
- * <p>primaryIndicator=true, then the request attribute <i>org.apache.catalina.ha.tcp.isPrimarySession.</i>
- * is set true, when request processing is at sessions primary node.
- * </p>
- *
- * @author Craig R. McClanahan
- * @author Filip Hanik
- * @author Peter Rossbach
- * @version $Revision: 375709 $ $Date: 2006-02-07 15:13:25 -0600 (Tue, 07 Feb 2006) $
- */
-
-public class ReplicationValve
-    extends ValveBase implements ClusterValve {
-    
-    private static org.apache.juli.logging.Log log =
-        org.apache.juli.logging.LogFactory.getLog( ReplicationValve.class );
-
-    // ----------------------------------------------------- Instance Variables
-
-    /**
-     * The descriptive information related to this implementation.
-     */
-    private static final String info =
-        "org.apache.catalina.ha.tcp.ReplicationValve/2.0";
-
-
-    /**
-     * The StringManager for this package.
-     */
-    protected static StringManager sm =
-        StringManager.getManager(Constants.Package);
-
-    private CatalinaCluster cluster = null ;
-
-    /**
-     * holds file endings to not call for like images and others
-     */
-    protected java.util.regex.Pattern[] reqFilters = new java.util.regex.Pattern[0];
-    
-    /**
-     * Orginal filter 
-     */
-    protected String filter ;
-    
-    /**
-     * crossContext session container 
-     */
-    protected ThreadLocal crossContextSessions = new ThreadLocal() ;
-    
-    /**
-     * doProcessingStats (default = off)
-     */
-    protected boolean doProcessingStats = false;
-    
-    protected long totalRequestTime = 0;
-    protected long totalSendTime = 0;
-    protected long nrOfRequests = 0;
-    protected long lastSendTime = 0;
-    protected long nrOfFilterRequests = 0;
-    protected long nrOfSendRequests = 0;
-    protected long nrOfCrossContextSendRequests = 0;
-    
-    /**
-     * must primary change indicator set 
-     */
-    protected boolean primaryIndicator = false ;
-    
-    /**
-     * Name of primary change indicator as request attribute
-     */
-    protected String primaryIndicatorName = "org.apache.catalina.ha.tcp.isPrimarySession";
-   
-    // ------------------------------------------------------------- Properties
-
-    public ReplicationValve() {
-    }
-    
-    /**
-     * Return descriptive information about this Valve implementation.
-     */
-    public String getInfo() {
-
-        return (info);
-
-    }
-    
-    /**
-     * @return Returns the cluster.
-     */
-    public CatalinaCluster getCluster() {
-        return cluster;
-    }
-    
-    /**
-     * @param cluster The cluster to set.
-     */
-    public void setCluster(CatalinaCluster cluster) {
-        this.cluster = cluster;
-    }
- 
-    /**
-     * @return Returns the filter
-     */
-    public String getFilter() {
-       return filter ;
-    }
-
-    /**
-     * compile filter string to regular expressions
-     * @see Pattern#compile(java.lang.String)
-     * @param filter
-     *            The filter to set.
-     */
-    public void setFilter(String filter) {
-        if (log.isDebugEnabled())
-            log.debug(sm.getString("ReplicationValve.filter.loading", filter));
-        this.filter = filter;
-        StringTokenizer t = new StringTokenizer(filter, ";");
-        this.reqFilters = new Pattern[t.countTokens()];
-        int i = 0;
-        while (t.hasMoreTokens()) {
-            String s = t.nextToken();
-            if (log.isTraceEnabled())
-                log.trace(sm.getString("ReplicationValve.filter.token", s));
-            try {
-                reqFilters[i++] = Pattern.compile(s);
-            } catch (Exception x) {
-                log.error(sm.getString("ReplicationValve.filter.token.failure",
-                        s), x);
-            }
-        }
-    }
-
-    /**
-     * @return Returns the primaryIndicator.
-     */
-    public boolean isPrimaryIndicator() {
-        return primaryIndicator;
-    }
-
-    /**
-     * @param primaryIndicator The primaryIndicator to set.
-     */
-    public void setPrimaryIndicator(boolean primaryIndicator) {
-        this.primaryIndicator = primaryIndicator;
-    }
-    
-    /**
-     * @return Returns the primaryIndicatorName.
-     */
-    public String getPrimaryIndicatorName() {
-        return primaryIndicatorName;
-    }
-    
-    /**
-     * @param primaryIndicatorName The primaryIndicatorName to set.
-     */
-    public void setPrimaryIndicatorName(String primaryIndicatorName) {
-        this.primaryIndicatorName = primaryIndicatorName;
-    }
-    
-    /**
-     * Calc processing stats
-     */
-    public boolean doStatistics() {
-        return doProcessingStats;
-    }
-
-    /**
-     * Set Calc processing stats
-     * @see #resetStatistics()
-     */
-    public void setStatistics(boolean doProcessingStats) {
-        this.doProcessingStats = doProcessingStats;
-    }
-
-    /**
-     * @return Returns the lastSendTime.
-     */
-    public long getLastSendTime() {
-        return lastSendTime;
-    }
-    
-    /**
-     * @return Returns the nrOfRequests.
-     */
-    public long getNrOfRequests() {
-        return nrOfRequests;
-    }
-    
-    /**
-     * @return Returns the nrOfFilterRequests.
-     */
-    public long getNrOfFilterRequests() {
-        return nrOfFilterRequests;
-    }
-
-    /**
-     * @return Returns the nrOfCrossContextSendRequests.
-     */
-    public long getNrOfCrossContextSendRequests() {
-        return nrOfCrossContextSendRequests;
-    }
-
-    /**
-     * @return Returns the nrOfSendRequests.
-     */
-    public long getNrOfSendRequests() {
-        return nrOfSendRequests;
-    }
-
-    /**
-     * @return Returns the totalRequestTime.
-     */
-    public long getTotalRequestTime() {
-        return totalRequestTime;
-    }
-    
-    /**
-     * @return Returns the totalSendTime.
-     */
-    public long getTotalSendTime() {
-        return totalSendTime;
-    }
-
-    /**
-     * @return Returns the reqFilters.
-     */
-    protected java.util.regex.Pattern[] getReqFilters() {
-        return reqFilters;
-    }
-    
-    /**
-     * @param reqFilters The reqFilters to set.
-     */
-    protected void setReqFilters(java.util.regex.Pattern[] reqFilters) {
-        this.reqFilters = reqFilters;
-    }
-    
-    
-    // --------------------------------------------------------- Public Methods
-    
-    /**
-     * Register all cross context sessions inside endAccess.
-     * Use a list with contains check, that the Portlet API can include a lot of fragments from same or
-     * different applications with session changes.
-     *
-     * @param session cross context session
-     */
-    public void registerReplicationSession(DeltaSession session) {
-        List sessions = (List)crossContextSessions.get();
-        if(sessions != null) {
-            if(!sessions.contains(session)) {
-                if(log.isDebugEnabled())
-                    log.debug(sm.getString("ReplicationValve.crossContext.registerSession",
-                        session.getIdInternal(),
-                        session.getManager().getContainer().getName()));
-                sessions.add(session);
-            }
-        }
-    }
-
-    /**
-     * Log the interesting request parameters, invoke the next Valve in the
-     * sequence, and log the interesting response parameters.
-     *
-     * @param request The servlet request to be processed
-     * @param response The servlet response to be created
-     *
-     * @exception IOException if an input/output error occurs
-     * @exception ServletException if a servlet error occurs
-     */
-    public void invoke(Request request, Response response)
-        throws IOException, ServletException
-    {
-        long totalstart = 0;
-
-        //this happens before the request
-        if(doStatistics()) {
-            totalstart = System.currentTimeMillis();
-        }
-        if (primaryIndicator) {
-            createPrimaryIndicator(request) ;
-        }
-        Context context = request.getContext();
-        boolean isCrossContext = context != null
-                && context instanceof StandardContext
-                && ((StandardContext) context).getCrossContext();
-        try {
-            if(isCrossContext) {
-                if(log.isDebugEnabled())
-                    log.debug(sm.getString("ReplicationValve.crossContext.add"));
-                //FIXME add Pool of Arraylists
-                crossContextSessions.set(new ArrayList());
-            }
-            getNext().invoke(request, response);
-            Manager manager = request.getContext().getManager();
-            if (manager != null && manager instanceof ClusterManager) {
-                ClusterManager clusterManager = (ClusterManager) manager;
-                CatalinaCluster containerCluster = (CatalinaCluster) getContainer().getCluster();
-                if (containerCluster == null) {
-                    if (log.isWarnEnabled())
-                        log.warn(sm.getString("ReplicationValve.nocluster"));
-                    return;
-                }
-                // valve cluster can access manager - other cluster handle replication 
-                // at host level - hopefully!
-                if(containerCluster.getManager(clusterManager.getName()) == null)
-                    return ;
-                if(containerCluster.hasMembers()) {
-                    sendReplicationMessage(request, totalstart, isCrossContext, clusterManager, containerCluster);
-                } else {
-                    resetReplicationRequest(request,isCrossContext);
-                }        
-            }
-        } finally {
-            // Array must be remove: Current master request send endAccess at recycle. 
-            // Don't register this request session again!
-            if(isCrossContext) {
-                if(log.isDebugEnabled())
-                    log.debug(sm.getString("ReplicationValve.crossContext.remove"));
-                // crossContextSessions.remove() only exist at Java 5
-                // register ArrayList at a pool
-                crossContextSessions.set(null);
-            }
-        }
-    }
-
-    
-    /**
-     * reset the active statitics 
-     */
-    public void resetStatistics() {
-        totalRequestTime = 0 ;
-        totalSendTime = 0 ;
-        lastSendTime = 0 ;
-        nrOfFilterRequests = 0 ;
-        nrOfRequests = 0 ;
-        nrOfSendRequests = 0;
-        nrOfCrossContextSendRequests = 0;
-    }
-    
-    /**
-     * Return a String rendering of this object.
-     */
-    public String toString() {
-
-        StringBuffer sb = new StringBuffer("ReplicationValve[");
-        if (container != null)
-            sb.append(container.getName());
-        sb.append("]");
-        return (sb.toString());
-
-    }
-
-    // --------------------------------------------------------- Protected Methods
-
-    /**
-     * @param request
-     * @param totalstart
-     * @param isCrossContext
-     * @param clusterManager
-     * @param containerCluster
-     */
-    protected void sendReplicationMessage(Request request, long totalstart, boolean isCrossContext, ClusterManager clusterManager, CatalinaCluster containerCluster) {
-        //this happens after the request
-        long start = 0;
-        if(doStatistics()) {
-            start = System.currentTimeMillis();
-        }
-        try {
-            // send invalid sessions
-            // DeltaManager returns String[0]
-            if (!(clusterManager instanceof DeltaManager))
-                sendInvalidSessions(clusterManager, containerCluster);
-            // send replication
-            sendSessionReplicationMessage(request, clusterManager, containerCluster);
-            if(isCrossContext)
-                sendCrossContextSession(containerCluster);
-        } catch (Exception x) {
-            // FIXME we have a lot of sends, but the trouble with one node stops the correct replication to other nodes!
-            log.error(sm.getString("ReplicationValve.send.failure"), x);
-        } finally {
-            // FIXME this stats update are not cheap!!
-            if(doStatistics()) {
-                updateStats(totalstart,start);
-            }
-        }
-    }
-
-    /**
-     * Send all changed cross context sessions to backups
-     * @param containerCluster
-     */
-    protected void sendCrossContextSession(CatalinaCluster containerCluster) {
-        Object sessions = crossContextSessions.get();
-        if(sessions != null && sessions instanceof List
-                && ((List)sessions).size() >0) {
-            for(Iterator iter = ((List)sessions).iterator(); iter.hasNext() ;) {          
-                Session session = (Session)iter.next();
-                if(log.isDebugEnabled())
-                    log.debug(sm.getString("ReplicationValve.crossContext.sendDelta",  
-                            session.getManager().getContainer().getName() ));
-                sendMessage(session,(ClusterManager)session.getManager(),containerCluster);
-                if(doStatistics()) {
-                    nrOfCrossContextSendRequests++;
-                }
-            }
-        }
-    }
-  
-    /**
-     * Fix memory leak for long sessions with many changes, when no backup member exists!
-     * @param request current request after responce is generated
-     * @param isCrossContext check crosscontext threadlocal
-     */
-    protected void resetReplicationRequest(Request request, boolean isCrossContext) {
-        Session contextSession = request.getSessionInternal(false);
-        if(contextSession != null & contextSession instanceof DeltaSession){
-            resetDeltaRequest(contextSession);
-            ((DeltaSession)contextSession).setPrimarySession(true);
-        }
-        if(isCrossContext) {
-            Object sessions = crossContextSessions.get();
-            if(sessions != null && sessions instanceof List
-               && ((List)sessions).size() >0) {
-                Iterator iter = ((List)sessions).iterator();
-                for(; iter.hasNext() ;) {          
-                    Session session = (Session)iter.next();
-                    resetDeltaRequest(session);
-                    if(session instanceof DeltaSession)
-                        ((DeltaSession)contextSession).setPrimarySession(true);
-
-                }
-            }
-        }                     
-    }
-
-    /**
-     * Reset DeltaRequest from session
-     * @param session HttpSession from current request or cross context session
-     */
-    protected void resetDeltaRequest(Session session) {
-        if(log.isDebugEnabled()) {
-            log.debug(sm.getString("ReplicationValve.resetDeltaRequest" , 
-                session.getManager().getContainer().getName() ));
-        }
-        ((DeltaSession)session).resetDeltaRequest();
-    }
-
-    /**
-     * Send Cluster Replication Request
-     * @param request current request
-     * @param manager session manager
-     * @param cluster replication cluster
-     */
-    protected void sendSessionReplicationMessage(Request request,
-            ClusterManager manager, CatalinaCluster cluster) {
-        Session session = request.getSessionInternal(false);
-        if (session != null) {
-            String uri = request.getDecodedRequestURI();
-            // request without session change
-            if (!isRequestWithoutSessionChange(uri)) {
-                if (log.isDebugEnabled())
-                    log.debug(sm.getString("ReplicationValve.invoke.uri", uri));
-                sendMessage(session,manager,cluster);
-            } else
-                if(doStatistics())
-                    nrOfFilterRequests++;
-        }
-
-    }
-
-   /**
-    * Send message delta message from request session 
-    * @param request current request
-    * @param manager session manager
-    * @param cluster replication cluster
-    */
-    protected void sendMessage(Session session,
-             ClusterManager manager, CatalinaCluster cluster) {
-        String id = session.getIdInternal();
-        if (id != null) {
-            send(manager, cluster, id);
-        }
-    }
-
-    /**
-     * send manager requestCompleted message to cluster
-     * @param manager SessionManager
-     * @param cluster replication cluster
-     * @param sessionId sessionid from the manager
-     * @see DeltaManager#requestCompleted(String)
-     * @see SimpleTcpCluster#send(ClusterMessage)
-     */
-    protected void send(ClusterManager manager, CatalinaCluster cluster, String sessionId) {
-        ClusterMessage msg = manager.requestCompleted(sessionId);
-        if (msg != null) {
-            if(manager.doDomainReplication()) {
-                cluster.sendClusterDomain(msg);
-            } else {
-                cluster.send(msg);
-            }
-            if(doStatistics())
-                nrOfSendRequests++;
-        }
-    }
-    
-    /**
-     * check for session invalidations
-     * @param manager
-     * @param cluster
-     */
-    protected void sendInvalidSessions(ClusterManager manager, CatalinaCluster cluster) {
-        String[] invalidIds=manager.getInvalidatedSessions();
-        if ( invalidIds.length > 0 ) {
-            for ( int i=0;i<invalidIds.length; i++ ) {
-                try {
-                    send(manager,cluster,invalidIds[i]);
-                } catch ( Exception x ) {
-                    log.error(sm.getString("ReplicationValve.send.invalid.failure",invalidIds[i]),x);
-                }
-            }
-        }
-    }
-    
-    /**
-     * is request without possible session change
-     * @param uri The request uri
-     * @return True if no session change
-     */
-    protected boolean isRequestWithoutSessionChange(String uri) {
-
-        boolean filterfound = false;
-
-        for (int i = 0; (i < reqFilters.length) && (!filterfound); i++) {
-            java.util.regex.Matcher matcher = reqFilters[i].matcher(uri);
-            filterfound = matcher.matches();
-        }
-        return filterfound;
-    }
-
-    /**
-     * protocol cluster replications stats
-     * @param requestTime
-     * @param clusterTime
-     */
-    protected  void updateStats(long requestTime, long clusterTime) {
-        synchronized(this) {
-            lastSendTime=System.currentTimeMillis();
-            totalSendTime+=lastSendTime - clusterTime;
-            totalRequestTime+=lastSendTime - requestTime;
-            nrOfRequests++;
-        }
-        if(log.isInfoEnabled()) {
-            if ( (nrOfRequests % 100) == 0 ) {
-                 log.info(sm.getString("ReplicationValve.stats",
-                     new Object[]{
-                         new Long(totalRequestTime/nrOfRequests),
-                         new Long(totalSendTime/nrOfRequests),
-                         new Long(nrOfRequests),
-                         new Long(nrOfSendRequests),
-                         new Long(nrOfCrossContextSendRequests),
-                         new Long(nrOfFilterRequests),
-                         new Long(totalRequestTime),
-                         new Long(totalSendTime)}));
-             }
-        }
-    }
-
-
-    /**
-     * Mark Request that processed at primary node with attribute
-     * primaryIndicatorName
-     * 
-     * @param request
-     * @throws IOException
-     */
-    protected void createPrimaryIndicator(Request request) throws IOException {
-        String id = request.getRequestedSessionId();
-        if ((id != null) && (id.length() > 0)) {
-            Manager manager = request.getContext().getManager();
-            Session session = manager.findSession(id);
-            if (session instanceof ClusterSession) {
-                ClusterSession cses = (ClusterSession) session;
-                if (cses != null) {
-                    if (log.isDebugEnabled())
-                        log.debug(sm.getString(
-                                "ReplicationValve.session.indicator", request.getContext().getName(),id,
-                                primaryIndicatorName, cses.isPrimarySession()));
-                    request.setAttribute(primaryIndicatorName, cses.isPrimarySession()?Boolean.TRUE:Boolean.FALSE);
-                }
-            } else {
-                if (log.isDebugEnabled()) {
-                    if (session != null) {
-                        log.debug(sm.getString(
-                                "ReplicationValve.session.found", request.getContext().getName(),id));
-                    } else {
-                        log.debug(sm.getString(
-                                "ReplicationValve.session.invalid", request.getContext().getName(),id));
-                    }
-                }
-            }
-        }
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha.tcp;
+
+import java.io.IOException;
+import java.util.StringTokenizer;
+import java.util.regex.Pattern;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Iterator;
+import javax.servlet.ServletException;
+
+import org.apache.catalina.Manager;
+import org.apache.catalina.Session;
+import org.apache.catalina.Context;
+import org.apache.catalina.core.StandardContext;
+import org.apache.catalina.ha.CatalinaCluster;
+import org.apache.catalina.ha.ClusterManager;
+import org.apache.catalina.ha.ClusterMessage;
+import org.apache.catalina.ha.ClusterSession;
+import org.apache.catalina.ha.ClusterValve;
+import org.apache.catalina.ha.session.DeltaManager;
+import org.apache.catalina.ha.session.DeltaSession;
+import org.apache.catalina.connector.Request;
+import org.apache.catalina.connector.Response;
+import org.apache.catalina.util.StringManager;
+import org.apache.catalina.valves.ValveBase;
+
+/**
+ * <p>Implementation of a Valve that logs interesting contents from the
+ * specified Request (before processing) and the corresponding Response
+ * (after processing).  It is especially useful in debugging problems
+ * related to headers and cookies.</p>
+ *
+ * <p>This Valve may be attached to any Container, depending on the granularity
+ * of the logging you wish to perform.</p>
+ *
+ * <p>primaryIndicator=true, then the request attribute <i>org.apache.catalina.ha.tcp.isPrimarySession.</i>
+ * is set true, when request processing is at sessions primary node.
+ * </p>
+ *
+ * @author Craig R. McClanahan
+ * @author Filip Hanik
+ * @author Peter Rossbach
+ * @version $Revision: 375709 $ $Date: 2006-02-07 15:13:25 -0600 (Tue, 07 Feb 2006) $
+ */
+
+public class ReplicationValve
+    extends ValveBase implements ClusterValve {
+    
+    private static org.apache.juli.logging.Log log =
+        org.apache.juli.logging.LogFactory.getLog( ReplicationValve.class );
+
+    // ----------------------------------------------------- Instance Variables
+
+    /**
+     * The descriptive information related to this implementation.
+     */
+    private static final String info =
+        "org.apache.catalina.ha.tcp.ReplicationValve/2.0";
+
+
+    /**
+     * The StringManager for this package.
+     */
+    protected static StringManager sm =
+        StringManager.getManager(Constants.Package);
+
+    private CatalinaCluster cluster = null ;
+
+    /**
+     * holds file endings to not call for like images and others
+     */
+    protected java.util.regex.Pattern[] reqFilters = new java.util.regex.Pattern[0];
+    
+    /**
+     * Orginal filter 
+     */
+    protected String filter ;
+    
+    /**
+     * crossContext session container 
+     */
+    protected ThreadLocal crossContextSessions = new ThreadLocal() ;
+    
+    /**
+     * doProcessingStats (default = off)
+     */
+    protected boolean doProcessingStats = false;
+    
+    protected long totalRequestTime = 0;
+    protected long totalSendTime = 0;
+    protected long nrOfRequests = 0;
+    protected long lastSendTime = 0;
+    protected long nrOfFilterRequests = 0;
+    protected long nrOfSendRequests = 0;
+    protected long nrOfCrossContextSendRequests = 0;
+    
+    /**
+     * must primary change indicator set 
+     */
+    protected boolean primaryIndicator = false ;
+    
+    /**
+     * Name of primary change indicator as request attribute
+     */
+    protected String primaryIndicatorName = "org.apache.catalina.ha.tcp.isPrimarySession";
+   
+    // ------------------------------------------------------------- Properties
+
+    public ReplicationValve() {
+    }
+    
+    /**
+     * Return descriptive information about this Valve implementation.
+     */
+    public String getInfo() {
+
+        return (info);
+
+    }
+    
+    /**
+     * @return Returns the cluster.
+     */
+    public CatalinaCluster getCluster() {
+        return cluster;
+    }
+    
+    /**
+     * @param cluster The cluster to set.
+     */
+    public void setCluster(CatalinaCluster cluster) {
+        this.cluster = cluster;
+    }
+ 
+    /**
+     * @return Returns the filter
+     */
+    public String getFilter() {
+       return filter ;
+    }
+
+    /**
+     * compile filter string to regular expressions
+     * @see Pattern#compile(java.lang.String)
+     * @param filter
+     *            The filter to set.
+     */
+    public void setFilter(String filter) {
+        if (log.isDebugEnabled())
+            log.debug(sm.getString("ReplicationValve.filter.loading", filter));
+        this.filter = filter;
+        StringTokenizer t = new StringTokenizer(filter, ";");
+        this.reqFilters = new Pattern[t.countTokens()];
+        int i = 0;
+        while (t.hasMoreTokens()) {
+            String s = t.nextToken();
+            if (log.isTraceEnabled())
+                log.trace(sm.getString("ReplicationValve.filter.token", s));
+            try {
+                reqFilters[i++] = Pattern.compile(s);
+            } catch (Exception x) {
+                log.error(sm.getString("ReplicationValve.filter.token.failure",
+                        s), x);
+            }
+        }
+    }
+
+    /**
+     * @return Returns the primaryIndicator.
+     */
+    public boolean isPrimaryIndicator() {
+        return primaryIndicator;
+    }
+
+    /**
+     * @param primaryIndicator The primaryIndicator to set.
+     */
+    public void setPrimaryIndicator(boolean primaryIndicator) {
+        this.primaryIndicator = primaryIndicator;
+    }
+    
+    /**
+     * @return Returns the primaryIndicatorName.
+     */
+    public String getPrimaryIndicatorName() {
+        return primaryIndicatorName;
+    }
+    
+    /**
+     * @param primaryIndicatorName The primaryIndicatorName to set.
+     */
+    public void setPrimaryIndicatorName(String primaryIndicatorName) {
+        this.primaryIndicatorName = primaryIndicatorName;
+    }
+    
+    /**
+     * Calc processing stats
+     */
+    public boolean doStatistics() {
+        return doProcessingStats;
+    }
+
+    /**
+     * Set Calc processing stats
+     * @see #resetStatistics()
+     */
+    public void setStatistics(boolean doProcessingStats) {
+        this.doProcessingStats = doProcessingStats;
+    }
+
+    /**
+     * @return Returns the lastSendTime.
+     */
+    public long getLastSendTime() {
+        return lastSendTime;
+    }
+    
+    /**
+     * @return Returns the nrOfRequests.
+     */
+    public long getNrOfRequests() {
+        return nrOfRequests;
+    }
+    
+    /**
+     * @return Returns the nrOfFilterRequests.
+     */
+    public long getNrOfFilterRequests() {
+        return nrOfFilterRequests;
+    }
+
+    /**
+     * @return Returns the nrOfCrossContextSendRequests.
+     */
+    public long getNrOfCrossContextSendRequests() {
+        return nrOfCrossContextSendRequests;
+    }
+
+    /**
+     * @return Returns the nrOfSendRequests.
+     */
+    public long getNrOfSendRequests() {
+        return nrOfSendRequests;
+    }
+
+    /**
+     * @return Returns the totalRequestTime.
+     */
+    public long getTotalRequestTime() {
+        return totalRequestTime;
+    }
+    
+    /**
+     * @return Returns the totalSendTime.
+     */
+    public long getTotalSendTime() {
+        return totalSendTime;
+    }
+
+    /**
+     * @return Returns the reqFilters.
+     */
+    protected java.util.regex.Pattern[] getReqFilters() {
+        return reqFilters;
+    }
+    
+    /**
+     * @param reqFilters The reqFilters to set.
+     */
+    protected void setReqFilters(java.util.regex.Pattern[] reqFilters) {
+        this.reqFilters = reqFilters;
+    }
+    
+    
+    // --------------------------------------------------------- Public Methods
+    
+    /**
+     * Register all cross context sessions inside endAccess.
+     * Use a list with contains check, that the Portlet API can include a lot of fragments from same or
+     * different applications with session changes.
+     *
+     * @param session cross context session
+     */
+    public void registerReplicationSession(DeltaSession session) {
+        List sessions = (List)crossContextSessions.get();
+        if(sessions != null) {
+            if(!sessions.contains(session)) {
+                if(log.isDebugEnabled())
+                    log.debug(sm.getString("ReplicationValve.crossContext.registerSession",
+                        session.getIdInternal(),
+                        session.getManager().getContainer().getName()));
+                sessions.add(session);
+            }
+        }
+    }
+
+    /**
+     * Log the interesting request parameters, invoke the next Valve in the
+     * sequence, and log the interesting response parameters.
+     *
+     * @param request The servlet request to be processed
+     * @param response The servlet response to be created
+     *
+     * @exception IOException if an input/output error occurs
+     * @exception ServletException if a servlet error occurs
+     */
+    public void invoke(Request request, Response response)
+        throws IOException, ServletException
+    {
+        long totalstart = 0;
+
+        //this happens before the request
+        if(doStatistics()) {
+            totalstart = System.currentTimeMillis();
+        }
+        if (primaryIndicator) {
+            createPrimaryIndicator(request) ;
+        }
+        Context context = request.getContext();
+        boolean isCrossContext = context != null
+                && context instanceof StandardContext
+                && ((StandardContext) context).getCrossContext();
+        try {
+            if(isCrossContext) {
+                if(log.isDebugEnabled())
+                    log.debug(sm.getString("ReplicationValve.crossContext.add"));
+                //FIXME add Pool of Arraylists
+                crossContextSessions.set(new ArrayList());
+            }
+            getNext().invoke(request, response);
+            Manager manager = request.getContext().getManager();
+            if (manager != null && manager instanceof ClusterManager) {
+                ClusterManager clusterManager = (ClusterManager) manager;
+                CatalinaCluster containerCluster = (CatalinaCluster) getContainer().getCluster();
+                if (containerCluster == null) {
+                    if (log.isWarnEnabled())
+                        log.warn(sm.getString("ReplicationValve.nocluster"));
+                    return;
+                }
+                // valve cluster can access manager - other cluster handle replication 
+                // at host level - hopefully!
+                if(containerCluster.getManager(clusterManager.getName()) == null)
+                    return ;
+                if(containerCluster.hasMembers()) {
+                    sendReplicationMessage(request, totalstart, isCrossContext, clusterManager, containerCluster);
+                } else {
+                    resetReplicationRequest(request,isCrossContext);
+                }        
+            }
+        } finally {
+            // Array must be remove: Current master request send endAccess at recycle. 
+            // Don't register this request session again!
+            if(isCrossContext) {
+                if(log.isDebugEnabled())
+                    log.debug(sm.getString("ReplicationValve.crossContext.remove"));
+                // crossContextSessions.remove() only exist at Java 5
+                // register ArrayList at a pool
+                crossContextSessions.set(null);
+            }
+        }
+    }
+
+    
+    /**
+     * reset the active statitics 
+     */
+    public void resetStatistics() {
+        totalRequestTime = 0 ;
+        totalSendTime = 0 ;
+        lastSendTime = 0 ;
+        nrOfFilterRequests = 0 ;
+        nrOfRequests = 0 ;
+        nrOfSendRequests = 0;
+        nrOfCrossContextSendRequests = 0;
+    }
+    
+    /**
+     * Return a String rendering of this object.
+     */
+    public String toString() {
+
+        StringBuffer sb = new StringBuffer("ReplicationValve[");
+        if (container != null)
+            sb.append(container.getName());
+        sb.append("]");
+        return (sb.toString());
+
+    }
+
+    // --------------------------------------------------------- Protected Methods
+
+    /**
+     * @param request
+     * @param totalstart
+     * @param isCrossContext
+     * @param clusterManager
+     * @param containerCluster
+     */
+    protected void sendReplicationMessage(Request request, long totalstart, boolean isCrossContext, ClusterManager clusterManager, CatalinaCluster containerCluster) {
+        //this happens after the request
+        long start = 0;
+        if(doStatistics()) {
+            start = System.currentTimeMillis();
+        }
+        try {
+            // send invalid sessions
+            // DeltaManager returns String[0]
+            if (!(clusterManager instanceof DeltaManager))
+                sendInvalidSessions(clusterManager, containerCluster);
+            // send replication
+            sendSessionReplicationMessage(request, clusterManager, containerCluster);
+            if(isCrossContext)
+                sendCrossContextSession(containerCluster);
+        } catch (Exception x) {
+            // FIXME we have a lot of sends, but the trouble with one node stops the correct replication to other nodes!
+            log.error(sm.getString("ReplicationValve.send.failure"), x);
+        } finally {
+            // FIXME this stats update are not cheap!!
+            if(doStatistics()) {
+                updateStats(totalstart,start);
+            }
+        }
+    }
+
+    /**
+     * Send all changed cross context sessions to backups
+     * @param containerCluster
+     */
+    protected void sendCrossContextSession(CatalinaCluster containerCluster) {
+        Object sessions = crossContextSessions.get();
+        if(sessions != null && sessions instanceof List
+                && ((List)sessions).size() >0) {
+            for(Iterator iter = ((List)sessions).iterator(); iter.hasNext() ;) {          
+                Session session = (Session)iter.next();
+                if(log.isDebugEnabled())
+                    log.debug(sm.getString("ReplicationValve.crossContext.sendDelta",  
+                            session.getManager().getContainer().getName() ));
+                sendMessage(session,(ClusterManager)session.getManager(),containerCluster);
+                if(doStatistics()) {
+                    nrOfCrossContextSendRequests++;
+                }
+            }
+        }
+    }
+  
+    /**
+     * Fix memory leak for long sessions with many changes, when no backup member exists!
+     * @param request current request after responce is generated
+     * @param isCrossContext check crosscontext threadlocal
+     */
+    protected void resetReplicationRequest(Request request, boolean isCrossContext) {
+        Session contextSession = request.getSessionInternal(false);
+        if(contextSession != null & contextSession instanceof DeltaSession){
+            resetDeltaRequest(contextSession);
+            ((DeltaSession)contextSession).setPrimarySession(true);
+        }
+        if(isCrossContext) {
+            Object sessions = crossContextSessions.get();
+            if(sessions != null && sessions instanceof List
+               && ((List)sessions).size() >0) {
+                Iterator iter = ((List)sessions).iterator();
+                for(; iter.hasNext() ;) {          
+                    Session session = (Session)iter.next();
+                    resetDeltaRequest(session);
+                    if(session instanceof DeltaSession)
+                        ((DeltaSession)contextSession).setPrimarySession(true);
+
+                }
+            }
+        }                     
+    }
+
+    /**
+     * Reset DeltaRequest from session
+     * @param session HttpSession from current request or cross context session
+     */
+    protected void resetDeltaRequest(Session session) {
+        if(log.isDebugEnabled()) {
+            log.debug(sm.getString("ReplicationValve.resetDeltaRequest" , 
+                session.getManager().getContainer().getName() ));
+        }
+        ((DeltaSession)session).resetDeltaRequest();
+    }
+
+    /**
+     * Send Cluster Replication Request
+     * @param request current request
+     * @param manager session manager
+     * @param cluster replication cluster
+     */
+    protected void sendSessionReplicationMessage(Request request,
+            ClusterManager manager, CatalinaCluster cluster) {
+        Session session = request.getSessionInternal(false);
+        if (session != null) {
+            String uri = request.getDecodedRequestURI();
+            // request without session change
+            if (!isRequestWithoutSessionChange(uri)) {
+                if (log.isDebugEnabled())
+                    log.debug(sm.getString("ReplicationValve.invoke.uri", uri));
+                sendMessage(session,manager,cluster);
+            } else
+                if(doStatistics())
+                    nrOfFilterRequests++;
+        }
+
+    }
+
+   /**
+    * Send message delta message from request session 
+    * @param request current request
+    * @param manager session manager
+    * @param cluster replication cluster
+    */
+    protected void sendMessage(Session session,
+             ClusterManager manager, CatalinaCluster cluster) {
+        String id = session.getIdInternal();
+        if (id != null) {
+            send(manager, cluster, id);
+        }
+    }
+
+    /**
+     * send manager requestCompleted message to cluster
+     * @param manager SessionManager
+     * @param cluster replication cluster
+     * @param sessionId sessionid from the manager
+     * @see DeltaManager#requestCompleted(String)
+     * @see SimpleTcpCluster#send(ClusterMessage)
+     */
+    protected void send(ClusterManager manager, CatalinaCluster cluster, String sessionId) {
+        ClusterMessage msg = manager.requestCompleted(sessionId);
+        if (msg != null) {
+            if(manager.doDomainReplication()) {
+                cluster.sendClusterDomain(msg);
+            } else {
+                cluster.send(msg);
+            }
+            if(doStatistics())
+                nrOfSendRequests++;
+        }
+    }
+    
+    /**
+     * check for session invalidations
+     * @param manager
+     * @param cluster
+     */
+    protected void sendInvalidSessions(ClusterManager manager, CatalinaCluster cluster) {
+        String[] invalidIds=manager.getInvalidatedSessions();
+        if ( invalidIds.length > 0 ) {
+            for ( int i=0;i<invalidIds.length; i++ ) {
+                try {
+                    send(manager,cluster,invalidIds[i]);
+                } catch ( Exception x ) {
+                    log.error(sm.getString("ReplicationValve.send.invalid.failure",invalidIds[i]),x);
+                }
+            }
+        }
+    }
+    
+    /**
+     * is request without possible session change
+     * @param uri The request uri
+     * @return True if no session change
+     */
+    protected boolean isRequestWithoutSessionChange(String uri) {
+
+        boolean filterfound = false;
+
+        for (int i = 0; (i < reqFilters.length) && (!filterfound); i++) {
+            java.util.regex.Matcher matcher = reqFilters[i].matcher(uri);
+            filterfound = matcher.matches();
+        }
+        return filterfound;
+    }
+
+    /**
+     * protocol cluster replications stats
+     * @param requestTime
+     * @param clusterTime
+     */
+    protected  void updateStats(long requestTime, long clusterTime) {
+        synchronized(this) {
+            lastSendTime=System.currentTimeMillis();
+            totalSendTime+=lastSendTime - clusterTime;
+            totalRequestTime+=lastSendTime - requestTime;
+            nrOfRequests++;
+        }
+        if(log.isInfoEnabled()) {
+            if ( (nrOfRequests % 100) == 0 ) {
+                 log.info(sm.getString("ReplicationValve.stats",
+                     new Object[]{
+                         new Long(totalRequestTime/nrOfRequests),
+                         new Long(totalSendTime/nrOfRequests),
+                         new Long(nrOfRequests),
+                         new Long(nrOfSendRequests),
+                         new Long(nrOfCrossContextSendRequests),
+                         new Long(nrOfFilterRequests),
+                         new Long(totalRequestTime),
+                         new Long(totalSendTime)}));
+             }
+        }
+    }
+
+
+    /**
+     * Mark Request that processed at primary node with attribute
+     * primaryIndicatorName
+     * 
+     * @param request
+     * @throws IOException
+     */
+    protected void createPrimaryIndicator(Request request) throws IOException {
+        String id = request.getRequestedSessionId();
+        if ((id != null) && (id.length() > 0)) {
+            Manager manager = request.getContext().getManager();
+            Session session = manager.findSession(id);
+            if (session instanceof ClusterSession) {
+                ClusterSession cses = (ClusterSession) session;
+                if (cses != null) {
+                    if (log.isDebugEnabled())
+                        log.debug(sm.getString(
+                                "ReplicationValve.session.indicator", request.getContext().getName(),id,
+                                primaryIndicatorName, cses.isPrimarySession()));
+                    request.setAttribute(primaryIndicatorName, cses.isPrimarySession()?Boolean.TRUE:Boolean.FALSE);
+                }
+            } else {
+                if (log.isDebugEnabled()) {
+                    if (session != null) {
+                        log.debug(sm.getString(
+                                "ReplicationValve.session.found", request.getContext().getName(),id));
+                    } else {
+                        log.debug(sm.getString(
+                                "ReplicationValve.session.invalid", request.getContext().getName(),id));
+                    }
+                }
+            }
+        }
+    }
+
+}

==================================================
IDynamicProperty.java
index 6812302bd7..be8c8fc244 100644
--- a/java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java
+++ b/java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java
@@ -1,955 +1,956 @@
-/*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha.tcp;
-
-import java.beans.PropertyChangeSupport;
-import java.io.IOException;
-import java.io.Serializable;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-import org.apache.catalina.Container;
-import org.apache.catalina.Context;
-import org.apache.catalina.Engine;
-import org.apache.catalina.Host;
-import org.apache.catalina.Lifecycle;
-import org.apache.catalina.LifecycleEvent;
-import org.apache.catalina.LifecycleException;
-import org.apache.catalina.LifecycleListener;
-import org.apache.catalina.Manager;
-import org.apache.catalina.Valve;
-import org.apache.catalina.ha.CatalinaCluster;
-import org.apache.catalina.ha.ClusterListener;
-import org.apache.catalina.ha.ClusterManager;
-import org.apache.catalina.ha.ClusterMessage;
-import org.apache.catalina.ha.ClusterValve;
-import org.apache.catalina.ha.session.DeltaManager;
-import org.apache.catalina.ha.util.IDynamicProperty;
-import org.apache.catalina.tribes.Channel;
-import org.apache.catalina.tribes.ChannelListener;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.MembershipListener;
-import org.apache.catalina.tribes.group.GroupChannel;
-import org.apache.catalina.util.LifecycleSupport;
-import org.apache.catalina.util.StringManager;
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-import org.apache.tomcat.util.IntrospectionUtils;
-import org.apache.catalina.ha.session.ClusterSessionListener;
-import org.apache.catalina.tribes.group.interceptors.MessageDispatch15Interceptor;
-import org.apache.catalina.tribes.group.interceptors.TcpFailureDetector;
-import org.apache.catalina.ha.session.JvmRouteBinderValve;
-import org.apache.catalina.ha.session.JvmRouteSessionIDBinderListener;
-
-/**
- * A <b>Cluster </b> implementation using simple multicast. Responsible for
- * setting up a cluster and provides callers with a valid multicast
- * receiver/sender.
- * 
- * FIXME remove install/remove/start/stop context dummys
- * FIXME wrote testcases 
- * 
- * @author Filip Hanik
- * @author Remy Maucherat
- * @author Peter Rossbach
- * @version $Revision: 379550 $, $Date: 2006-02-21 12:06:35 -0600 (Tue, 21 Feb 2006) $
- */
-public class SimpleTcpCluster 
-    implements CatalinaCluster, Lifecycle, LifecycleListener, IDynamicProperty,
-               MembershipListener, ChannelListener{
-
-    public static Log log = LogFactory.getLog(SimpleTcpCluster.class);
-
-    // ----------------------------------------------------- Instance Variables
-
-    /**
-     * Descriptive information about this component implementation.
-     */
-    protected static final String info = "SimpleTcpCluster/2.2";
-
-    public static final String BEFORE_MEMBERREGISTER_EVENT = "before_member_register";
-
-    public static final String AFTER_MEMBERREGISTER_EVENT = "after_member_register";
-
-    public static final String BEFORE_MANAGERREGISTER_EVENT = "before_manager_register";
-
-    public static final String AFTER_MANAGERREGISTER_EVENT = "after_manager_register";
-
-    public static final String BEFORE_MANAGERUNREGISTER_EVENT = "before_manager_unregister";
-
-    public static final String AFTER_MANAGERUNREGISTER_EVENT = "after_manager_unregister";
-
-    public static final String BEFORE_MEMBERUNREGISTER_EVENT = "before_member_unregister";
-
-    public static final String AFTER_MEMBERUNREGISTER_EVENT = "after_member_unregister";
-
-    public static final String SEND_MESSAGE_FAILURE_EVENT = "send_message_failure";
-
-    public static final String RECEIVE_MESSAGE_FAILURE_EVENT = "receive_message_failure";
-    
-    /**
-     * Group channel.
-     */
-    protected Channel channel = new GroupChannel();
-
-
-    /**
-     * Name for logging purpose
-     */
-    protected String clusterImpName = "SimpleTcpCluster";
-
-    /**
-     * The string manager for this package.
-     */
-    protected StringManager sm = StringManager.getManager(Constants.Package);
-
-    /**
-     * The cluster name to join
-     */
-    protected String clusterName ;
-
-    /**
-     * The Container associated with this Cluster.
-     */
-    protected Container container = null;
-
-    /**
-     * The lifecycle event support for this component.
-     */
-    protected LifecycleSupport lifecycle = new LifecycleSupport(this);
-
-    /**
-     * Has this component been started?
-     */
-    protected boolean started = false;
-
-    /**
-     * The property change support for this component.
-     */
-    protected PropertyChangeSupport support = new PropertyChangeSupport(this);
-
-    /**
-     * The context name <->manager association for distributed contexts.
-     */
-    protected Map managers = new HashMap();
-
-    protected ClusterManager managerTemplate = new DeltaManager();
-
-    private List valves = new ArrayList();
-
-    private org.apache.catalina.ha.ClusterDeployer clusterDeployer;
-
-    /**
-     * Listeners of messages
-     */
-    protected List clusterListeners = new ArrayList();
-
-    /**
-     * Comment for <code>notifyLifecycleListenerOnFailure</code>
-     */
-    private boolean notifyLifecycleListenerOnFailure = false;
-
-    /**
-     * dynamic sender <code>properties</code>
-     */
-    private Map properties = new HashMap();
-    
-    private int channelSendOptions = Channel.SEND_OPTIONS_ASYNCHRONOUS;
-
-    // ------------------------------------------------------------- Properties
-
-    public SimpleTcpCluster() {
-    }
-
-    /**
-     * Return descriptive information about this Cluster implementation and the
-     * corresponding version number, in the format
-     * <code>&lt;description&gt;/&lt;version&gt;</code>.
-     */
-    public String getInfo() {
-        return (info);
-    }
-
-    /**
-     * Set the name of the cluster to join, if no cluster with this name is
-     * present create one.
-     * 
-     * @param clusterName
-     *            The clustername to join
-     */
-    public void setClusterName(String clusterName) {
-        this.clusterName = clusterName;
-    }
-
-    /**
-     * Return the name of the cluster that this Server is currently configured
-     * to operate within.
-     * 
-     * @return The name of the cluster associated with this server
-     */
-    public String getClusterName() {
-        if(clusterName == null && container != null)
-            return container.getName() ;
-        return clusterName;
-    }
-
-    /**
-     * Set the Container associated with our Cluster
-     * 
-     * @param container
-     *            The Container to use
-     */
-    public void setContainer(Container container) {
-        Container oldContainer = this.container;
-        this.container = container;
-        support.firePropertyChange("container", oldContainer, this.container);
-    }
-
-    /**
-     * Get the Container associated with our Cluster
-     * 
-     * @return The Container associated with our Cluster
-     */
-    public Container getContainer() {
-        return (this.container);
-    }
-
-    /**
-     * @return Returns the notifyLifecycleListenerOnFailure.
-     */
-    public boolean isNotifyLifecycleListenerOnFailure() {
-        return notifyLifecycleListenerOnFailure;
-    }
-
-    /**
-     * @param notifyListenerOnFailure
-     *            The notifyLifecycleListenerOnFailure to set.
-     */
-    public void setNotifyLifecycleListenerOnFailure(
-            boolean notifyListenerOnFailure) {
-        boolean oldNotifyListenerOnFailure = this.notifyLifecycleListenerOnFailure;
-        this.notifyLifecycleListenerOnFailure = notifyListenerOnFailure;
-        support.firePropertyChange("notifyLifecycleListenerOnFailure",
-                oldNotifyListenerOnFailure,
-                this.notifyLifecycleListenerOnFailure);
-    }
-
-    /**
-     * @deprecated use getManagerTemplate().getClass().getName() instead.
-     * @return String
-     */
-    public String getManagerClassName() {
-        return managerTemplate.getClass().getName();
-    }
-
-    /**
-     * @deprecated use nested &lt;Manager&gt; element inside the cluster config instead.
-     * @param managerClassName String
-     */
-    public void setManagerClassName(String managerClassName) {
-        log.warn("setManagerClassName is deprecated, use nested <Manager> element inside the <Cluster> element instead, this request will be ignored.");
-    }
-
-    /**
-     * Add cluster valve 
-     * Cluster Valves are only add to container when cluster is started!
-     * @param valve The new cluster Valve.
-     */
-    public void addValve(Valve valve) {
-        if (valve instanceof ClusterValve && (!valves.contains(valve)))
-            valves.add(valve);
-    }
-
-    /**
-     * get all cluster valves
-     * @return current cluster valves
-     */
-    public Valve[] getValves() {
-        return (Valve[]) valves.toArray(new Valve[valves.size()]);
-    }
-
-    /**
-     * Get the cluster listeners associated with this cluster. If this Array has
-     * no listeners registered, a zero-length array is returned.
-     */
-    public ClusterListener[] findClusterListeners() {
-        if (clusterListeners.size() > 0) {
-            ClusterListener[] listener = new ClusterListener[clusterListeners.size()];
-            clusterListeners.toArray(listener);
-            return listener;
-        } else
-            return new ClusterListener[0];
-
-    }
-
-    /**
-     * add cluster message listener and register cluster to this listener
-     * 
-     * @see org.apache.catalina.ha.CatalinaCluster#addClusterListener(org.apache.catalina.ha.MessageListener)
-     */
-    public void addClusterListener(ClusterListener listener) {
-        if (listener != null && !clusterListeners.contains(listener)) {
-            clusterListeners.add(listener);
-            listener.setCluster(this);
-        }
-    }
-
-    /**
-     * remove message listener and deregister Cluster from listener
-     * 
-     * @see org.apache.catalina.ha.CatalinaCluster#removeClusterListener(org.apache.catalina.ha.MessageListener)
-     */
-    public void removeClusterListener(ClusterListener listener) {
-        if (listener != null) {
-            clusterListeners.remove(listener);
-            listener.setCluster(null);
-        }
-    }
-
-    /**
-     * get current Deployer
-     */
-    public org.apache.catalina.ha.ClusterDeployer getClusterDeployer() {
-        return clusterDeployer;
-    }
-
-    /**
-     * set a new Deployer, must be set before cluster started!
-     */
-    public void setClusterDeployer(
-            org.apache.catalina.ha.ClusterDeployer clusterDeployer) {
-        this.clusterDeployer = clusterDeployer;
-    }
-
-    public void setChannel(Channel channel) {
-        this.channel = channel;
-    }
-
-    public void setManagerTemplate(ClusterManager managerTemplate) {
-        this.managerTemplate = managerTemplate;
-    }
-
-    public void setChannelSendOptions(int channelSendOptions) {
-        this.channelSendOptions = channelSendOptions;
-    }
-
-    /**
-     * has members
-     */
-    protected boolean hasMembers = false;
-    public boolean hasMembers() {
-        return hasMembers;
-    }
-    
-    /**
-     * Get all current cluster members
-     * @return all members or empty array 
-     */
-    public Member[] getMembers() {
-        return channel.getMembers();
-    }
-
-    /**
-     * Return the member that represents this node.
-     * 
-     * @return Member
-     */
-    public Member getLocalMember() {
-        return channel.getLocalMember(true);
-    }
-
-    // ------------------------------------------------------------- dynamic
-    // manager property handling
-
-    /**
-     * JMX hack to direct use at jconsole
-     * 
-     * @param name
-     * @param value
-     */
-    public void setProperty(String name, String value) {
-        setProperty(name, (Object) value);
-    }
-
-    /**
-     * set config attributes with reflect and propagate to all managers
-     * 
-     * @param name
-     * @param value
-     */
-    public void setProperty(String name, Object value) {
-        if (log.isTraceEnabled())
-            log.trace(sm.getString("SimpleTcpCluster.setProperty", name, value,properties.get(name)));
-        properties.put(name, value);
-        //using a dynamic way of setting properties is nice, but a security risk
-        //if exposed through JMX. This way you can sit and try to guess property names,
-        //we will only allow explicit property names
-        log.warn("Dynamic setProperty("+name+",value) has been disabled, please use explicit properties for the element you are trying to identify");
-        if(started) {
-            // FIXME Hmm, is that correct when some DeltaManagers are direct configured inside Context?
-            // Why we not support it for other elements, like sender, receiver or membership?
-            // Must we restart element after change?
-//            if (name.startsWith("manager")) {
-//                String key = name.substring("manager".length() + 1);
-//                String pvalue = value.toString();
-//                for (Iterator iter = managers.values().iterator(); iter.hasNext();) {
-//                    Manager manager = (Manager) iter.next();
-//                    if(manager instanceof DeltaManager && ((ClusterManager) manager).isDefaultMode()) {
-//                        IntrospectionUtils.setProperty(manager, key, pvalue );
-//                    }
-//                }
-//            } 
-        }
-    }
-
-    /**
-     * get current config
-     * 
-     * @param key
-     * @return The property
-     */
-    public Object getProperty(String key) {
-        if (log.isTraceEnabled())
-            log.trace(sm.getString("SimpleTcpCluster.getProperty", key));
-        return properties.get(key);
-    }
-
-    /**
-     * Get all properties keys
-     * 
-     * @return An iterator over the property names.
-     */
-    public Iterator getPropertyNames() {
-        return properties.keySet().iterator();
-    }
-
-    /**
-     * remove a configured property.
-     * 
-     * @param key
-     */
-    public void removeProperty(String key) {
-        properties.remove(key);
-    }
-
-    /**
-     * transfer properties from cluster configuration to subelement bean.
-     * @param prefix
-     * @param bean
-     */
-    protected void transferProperty(String prefix, Object bean) {
-        if (prefix != null) {
-            for (Iterator iter = getPropertyNames(); iter.hasNext();) {
-                String pkey = (String) iter.next();
-                if (pkey.startsWith(prefix)) {
-                    String key = pkey.substring(prefix.length() + 1);
-                    Object value = getProperty(pkey);
-                    IntrospectionUtils.setProperty(bean, key, value.toString());
-                }
-            }
-        }
-    }
-
-    // --------------------------------------------------------- Public Methods
-
-    /**
-     * @return Returns the managers.
-     */
-    public Map getManagers() {
-        return managers;
-    }
-
-    public Channel getChannel() {
-        return channel;
-    }
-
-    public ClusterManager getManagerTemplate() {
-        return managerTemplate;
-    }
-
-    public int getChannelSendOptions() {
-        return channelSendOptions;
-    }
-
-    /**
-     * Create new Manager without add to cluster (comes with start the manager)
-     * 
-     * @param name
-     *            Context Name of this manager
-     * @see org.apache.catalina.Cluster#createManager(java.lang.String)
-     * @see #addManager(String, Manager)
-     * @see DeltaManager#start()
-     */
-    public synchronized Manager createManager(String name) {
-        if (log.isDebugEnabled()) log.debug("Creating ClusterManager for context " + name + " using class " + getManagerClassName());
-        Manager manager = null;
-        try {
-            manager = managerTemplate.cloneFromTemplate();
-            ((ClusterManager)manager).setName(name);
-        } catch (Exception x) {
-            log.error("Unable to clone cluster manager, defaulting to org.apache.catalina.ha.session.DeltaManager", x);
-            manager = new org.apache.catalina.ha.session.DeltaManager();
-        } finally {
-            if ( manager != null && (manager instanceof ClusterManager)) ((ClusterManager)manager).setCluster(this);
-        }
-        return manager;
-    }
-    
-    public void registerManager(Manager manager) {
-    
-        if (! (manager instanceof ClusterManager)) {
-            log.warn("Manager [ " + manager + "] does not implement ClusterManager, addition to cluster has been aborted.");
-            return;
-        }
-        ClusterManager cmanager = (ClusterManager) manager ;
-        cmanager.setDistributable(true);
-        // Notify our interested LifecycleListeners
-        lifecycle.fireLifecycleEvent(BEFORE_MANAGERREGISTER_EVENT, manager);
-        String clusterName = getManagerName(cmanager.getName(), manager);
-        cmanager.setName(clusterName);
-        cmanager.setCluster(this);
-        cmanager.setDefaultMode(false);
-    
-        managers.put(clusterName, manager);
-        // Notify our interested LifecycleListeners
-        lifecycle.fireLifecycleEvent(AFTER_MANAGERREGISTER_EVENT, manager);    
-    }
-
-    /**
-     * remove an application form cluster replication bus
-     * 
-     * @see org.apache.catalina.ha.CatalinaCluster#removeManager(java.lang.String,Manager)
-     */
-    public void removeManager(Manager manager) {
-        if (manager != null && manager instanceof ClusterManager ) {
-            ClusterManager cmgr = (ClusterManager) manager;
-            // Notify our interested LifecycleListeners
-            lifecycle.fireLifecycleEvent(BEFORE_MANAGERUNREGISTER_EVENT,manager);
-            managers.remove(getManagerName(cmgr.getName(),manager));
-            cmgr.setCluster(null);
-            // Notify our interested LifecycleListeners
-            lifecycle.fireLifecycleEvent(AFTER_MANAGERUNREGISTER_EVENT, manager);
-        }
-    }
-
-    /**
-     * @param name
-     * @param manager
-     * @return
-     */
-    public String getManagerName(String name, Manager manager) {
-        String clusterName = name ;
-        if ( clusterName == null ) clusterName = manager.getContainer().getName();
-        if(getContainer() instanceof Engine) {
-            Container context = manager.getContainer() ;
-            if(context != null && context instanceof Context) {
-                Container host = ((Context)context).getParent();
-                if(host != null && host instanceof Host && clusterName!=null && !(clusterName.indexOf("#")>=0))
-                    clusterName = host.getName() +"#" + clusterName ;
-            }
-        }
-        return clusterName;
-    }
-
-    /*
-     * Get Manager
-     * 
-     * @see org.apache.catalina.ha.CatalinaCluster#getManager(java.lang.String)
-     */
-    public Manager getManager(String name) {
-        return (Manager) managers.get(name);
-    }
-    
-    // ------------------------------------------------------ Lifecycle Methods
-
-    /**
-     * Execute a periodic task, such as reloading, etc. This method will be
-     * invoked inside the classloading context of this container. Unexpected
-     * throwables will be caught and logged.
-     * @see org.apache.catalina.ha.deploy.FarmWarDeployer#backgroundProcess()
-     * @see ReplicationTransmitter#backgroundProcess()
-     */
-    public void backgroundProcess() {
-        if (clusterDeployer != null) clusterDeployer.backgroundProcess();
-        //send a heartbeat through the channel
-        if ( channel !=null ) channel.heartbeat();
-    }
-
-    /**
-     * Add a lifecycle event listener to this component.
-     * 
-     * @param listener
-     *            The listener to add
-     */
-    public void addLifecycleListener(LifecycleListener listener) {
-        lifecycle.addLifecycleListener(listener);
-    }
-
-    /**
-     * Get the lifecycle listeners associated with this lifecycle. If this
-     * Lifecycle has no listeners registered, a zero-length array is returned.
-     */
-    public LifecycleListener[] findLifecycleListeners() {
-
-        return lifecycle.findLifecycleListeners();
-
-    }
-
-    /**
-     * Remove a lifecycle event listener from this component.
-     * 
-     * @param listener
-     *            The listener to remove
-     */
-    public void removeLifecycleListener(LifecycleListener listener) {
-        lifecycle.removeLifecycleListener(listener);
-    }
-
-    /**
-     * Use as base to handle start/stop/periodic Events from host. Currently
-     * only log the messages as trace level.
-     * 
-     * @see org.apache.catalina.LifecycleListener#lifecycleEvent(org.apache.catalina.LifecycleEvent)
-     */
-    public void lifecycleEvent(LifecycleEvent lifecycleEvent) {
-        if (log.isTraceEnabled())
-            log.trace(sm.getString("SimpleTcpCluster.event.log", lifecycleEvent.getType(), lifecycleEvent.getData()));
-    }
-
-    // ------------------------------------------------------ public
-
-    /**
-     * Prepare for the beginning of active use of the public methods of this
-     * component. This method should be called after <code>configure()</code>,
-     * and before any of the public methods of the component are utilized. <BR>
-     * Starts the cluster communication channel, this will connect with the
-     * other nodes in the cluster, and request the current session state to be
-     * transferred to this node.
-     * 
-     * @exception IllegalStateException
-     *                if this component has already been started
-     * @exception LifecycleException
-     *                if this component detects a fatal error that prevents this
-     *                component from being used
-     */
-    public void start() throws LifecycleException {
-        if (started)
-            throw new LifecycleException(sm.getString("cluster.alreadyStarted"));
-        if (log.isInfoEnabled()) log.info("Cluster is about to start");
-
-        // Notify our interested LifecycleListeners
-        lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, this);
-        try {
-            checkDefaults();
-            registerClusterValve();
-            channel.addMembershipListener(this);
-            channel.addChannelListener(this);
-            channel.start(channel.DEFAULT);
-            if (clusterDeployer != null) clusterDeployer.start();
-            this.started = true;
-            // Notify our interested LifecycleListeners
-            lifecycle.fireLifecycleEvent(AFTER_START_EVENT, this);
-        } catch (Exception x) {
-            log.error("Unable to start cluster.", x);
-            throw new LifecycleException(x);
-        }
-    }
-
-    protected void checkDefaults() {
-        if ( clusterListeners.size() == 0 ) {
-            addClusterListener(new JvmRouteSessionIDBinderListener()); 
-            addClusterListener(new ClusterSessionListener());
-        }
-        if ( valves.size() == 0 ) {
-            addValve(new JvmRouteBinderValve());
-            addValve(new ReplicationValve());
-        }
-        if ( clusterDeployer != null ) clusterDeployer.setCluster(this);
-        if ( channel == null ) channel = new GroupChannel();
-        if ( channel instanceof GroupChannel && !((GroupChannel)channel).getInterceptors().hasNext()) {
-            channel.addInterceptor(new MessageDispatch15Interceptor());
-            channel.addInterceptor(new TcpFailureDetector());
-        }
-    }
-
-    /**
-     * register all cluster valve to host or engine
-     * @throws Exception
-     * @throws ClassNotFoundException
-     */
-    protected void registerClusterValve() throws Exception {
-        if(container != null ) {
-            for (Iterator iter = valves.iterator(); iter.hasNext();) {
-                ClusterValve valve = (ClusterValve) iter.next();
-                if (log.isDebugEnabled())
-                    log.debug("Invoking addValve on " + getContainer()
-                            + " with class=" + valve.getClass().getName());
-                if (valve != null) {
-                    IntrospectionUtils.callMethodN(getContainer(), "addValve",
-                            new Object[] { valve },
-                            new Class[] { org.apache.catalina.Valve.class });
-
-                }
-                valve.setCluster(this);
-            }
-        }
-    }
-
-    /**
-     * unregister all cluster valve to host or engine
-     * @throws Exception
-     * @throws ClassNotFoundException
-     */
-    protected void unregisterClusterValve() throws Exception {
-        for (Iterator iter = valves.iterator(); iter.hasNext();) {
-            ClusterValve valve = (ClusterValve) iter.next();
-            if (log.isDebugEnabled())
-                log.debug("Invoking removeValve on " + getContainer()
-                        + " with class=" + valve.getClass().getName());
-            if (valve != null) {
-                    IntrospectionUtils.callMethodN(getContainer(), "removeValve",
-                        new Object[] { valve }, new Class[] { org.apache.catalina.Valve.class });
-            }
-            valve.setCluster(this);
-        }
-    }
-
-    /**
-     * Gracefully terminate the active cluster component.<br/>
-     * This will disconnect the cluster communication channel, stop the
-     * listener and deregister the valves from host or engine.<br/><br/>
-     * <b>Note:</b><br/>The sub elements receiver, sender, membership,
-     * listener or valves are not removed. You can easily start the cluster again.
-     * 
-     * @exception IllegalStateException
-     *                if this component has not been started
-     * @exception LifecycleException
-     *                if this component detects a fatal error that needs to be
-     *                reported
-     */
-    public void stop() throws LifecycleException {
-
-        if (!started)
-            throw new IllegalStateException(sm.getString("cluster.notStarted"));
-        // Notify our interested LifecycleListeners
-        lifecycle.fireLifecycleEvent(BEFORE_STOP_EVENT, this);
-
-        if (clusterDeployer != null) clusterDeployer.stop();
-        this.managers.clear();
-        try {
-            if ( clusterDeployer != null ) clusterDeployer.setCluster(null);
-            channel.stop(Channel.DEFAULT);
-            channel.removeChannelListener(this);
-            channel.removeMembershipListener(this);
-            this.unregisterClusterValve();
-        } catch (Exception x) {
-            log.error("Unable to stop cluster valve.", x);
-        }
-        started = false;
-        // Notify our interested LifecycleListeners
-        lifecycle.fireLifecycleEvent(AFTER_STOP_EVENT, this);
-   }
-
-    
-
-
-    /**
-     * send message to all cluster members
-     * @param msg message to transfer
-     * 
-     * @see org.apache.catalina.ha.CatalinaCluster#send(org.apache.catalina.ha.ClusterMessage)
-     */
-    public void send(ClusterMessage msg) {
-        send(msg, null);
-    }
-
-    /**
-     * send message to all cluster members same cluster domain
-     * 
-     * @see org.apache.catalina.ha.CatalinaCluster#send(org.apache.catalina.ha.ClusterMessage)
-     */
-    public void sendClusterDomain(ClusterMessage msg) {
-        send(msg,null);
-    } 
-
-    
-    /**
-     * send a cluster message to one member
-     * 
-     * @param msg message to transfer
-     * @param dest Receiver member
-     * @see org.apache.catalina.ha.CatalinaCluster#send(org.apache.catalina.ha.ClusterMessage,
-     *      org.apache.catalina.ha.Member)
-     */
-    public void send(ClusterMessage msg, Member dest) {
-        try {
-            msg.setAddress(getLocalMember());
-            if (dest != null) {
-                if (!getLocalMember().equals(dest)) {
-                    channel.send(new Member[] {dest}, msg,channelSendOptions);
-                } else
-                    log.error("Unable to send message to local member " + msg);
-            } else {
-                channel.send(channel.getMembers(),msg,channelSendOptions);
-            }
-        } catch (Exception x) {
-            log.error("Unable to send message through cluster sender.", x);
-        }
-    }
-
-    /**
-     * New cluster member is registered
-     * 
-     * @see org.apache.catalina.ha.MembershipListener#memberAdded(org.apache.catalina.ha.Member)
-     */
-    public void memberAdded(Member member) {
-        try {
-            hasMembers = channel.hasMembers();
-            if (log.isInfoEnabled()) log.info("Replication member added:" + member);
-            // Notify our interested LifecycleListeners
-            lifecycle.fireLifecycleEvent(BEFORE_MEMBERREGISTER_EVENT, member);
-            // Notify our interested LifecycleListeners
-            lifecycle.fireLifecycleEvent(AFTER_MEMBERREGISTER_EVENT, member);
-        } catch (Exception x) {
-            log.error("Unable to connect to replication system.", x);
-        }
-
-    }
-
-    /**
-     * Cluster member is gone
-     * 
-     * @see org.apache.catalina.ha.MembershipListener#memberDisappeared(org.apache.catalina.ha.Member)
-     */
-    public void memberDisappeared(Member member) {
-        try {
-            hasMembers = channel.hasMembers();            
-            if (log.isInfoEnabled()) log.info("Received member disappeared:" + member);
-            // Notify our interested LifecycleListeners
-            lifecycle.fireLifecycleEvent(BEFORE_MEMBERUNREGISTER_EVENT, member);
-            // Notify our interested LifecycleListeners
-            lifecycle.fireLifecycleEvent(AFTER_MEMBERUNREGISTER_EVENT, member);
-        } catch (Exception x) {
-            log.error("Unable remove cluster node from replication system.", x);
-        }
-    }
-
-    // --------------------------------------------------------- receiver
-    // messages
-
-    /**
-     * notify all listeners from receiving a new message is not ClusterMessage
-     * emitt Failure Event to LifecylceListener
-     * 
-     * @param message
-     *            receveived Message
-     */
-    public boolean accept(Serializable msg, Member sender) {
-        return (msg instanceof ClusterMessage);
-    }
-    
-    
-    public void messageReceived(Serializable message, Member sender) {
-        ClusterMessage fwd = (ClusterMessage)message;
-        fwd.setAddress(sender);
-        messageReceived(fwd);
-    }
-
-    public void messageReceived(ClusterMessage message) {
-
-        long start = 0;
-        if (log.isDebugEnabled() && message != null)
-            log.debug("Assuming clocks are synched: Replication for "
-                    + message.getUniqueId() + " took="
-                    + (System.currentTimeMillis() - (message).getTimestamp())
-                    + " ms.");
-
-        //invoke all the listeners
-        boolean accepted = false;
-        if (message != null) {
-            for (Iterator iter = clusterListeners.iterator(); iter.hasNext();) {
-                ClusterListener listener = (ClusterListener) iter.next();
-                if (listener.accept(message)) {
-                    accepted = true;
-                    listener.messageReceived(message);
-                }
-            }
-        }
-        if (!accepted && log.isDebugEnabled()) {
-            if (notifyLifecycleListenerOnFailure) {
-                Member dest = message.getAddress();
-                // Notify our interested LifecycleListeners
-                lifecycle.fireLifecycleEvent(RECEIVE_MESSAGE_FAILURE_EVENT,
-                        new SendMessageData(message, dest, null));
-            }
-            log.debug("Message " + message.toString() + " from type "
-                    + message.getClass().getName()
-                    + " transfered but no listener registered");
-        }
-        return;
-    }
-
-    // --------------------------------------------------------- Logger
-
-    public Log getLogger() {
-        return log;
-    }
-
-
-
-    
-    // ------------------------------------------------------------- deprecated
-
-    /**
-     * 
-     * @see org.apache.catalina.Cluster#setProtocol(java.lang.String)
-     */
-    public void setProtocol(String protocol) {
-    }
-
-    /**
-     * @see org.apache.catalina.Cluster#getProtocol()
-     */
-    public String getProtocol() {
-        return null;
-    }
-
-    /**
-     * @see org.apache.catalina.Cluster#startContext(java.lang.String)
-     */
-    public void startContext(String contextPath) throws IOException {
-        
-    }
-
-    /**
-     * @see org.apache.catalina.Cluster#installContext(java.lang.String, java.net.URL)
-     */
-    public void installContext(String contextPath, URL war) {
-        
-    }
-
-    /**
-     * @see org.apache.catalina.Cluster#stop(java.lang.String)
-     */
-    public void stop(String contextPath) throws IOException {
-        
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha.tcp;
+
+import java.beans.PropertyChangeSupport;
+import java.io.IOException;
+import java.io.Serializable;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.catalina.Container;
+import org.apache.catalina.Context;
+import org.apache.catalina.Engine;
+import org.apache.catalina.Host;
+import org.apache.catalina.Lifecycle;
+import org.apache.catalina.LifecycleEvent;
+import org.apache.catalina.LifecycleException;
+import org.apache.catalina.LifecycleListener;
+import org.apache.catalina.Manager;
+import org.apache.catalina.Valve;
+import org.apache.catalina.ha.CatalinaCluster;
+import org.apache.catalina.ha.ClusterListener;
+import org.apache.catalina.ha.ClusterManager;
+import org.apache.catalina.ha.ClusterMessage;
+import org.apache.catalina.ha.ClusterValve;
+import org.apache.catalina.ha.session.DeltaManager;
+import org.apache.catalina.ha.util.IDynamicProperty;
+import org.apache.catalina.tribes.Channel;
+import org.apache.catalina.tribes.ChannelListener;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.MembershipListener;
+import org.apache.catalina.tribes.group.GroupChannel;
+import org.apache.catalina.util.LifecycleSupport;
+import org.apache.catalina.util.StringManager;
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+import org.apache.tomcat.util.IntrospectionUtils;
+import org.apache.catalina.ha.session.ClusterSessionListener;
+import org.apache.catalina.tribes.group.interceptors.MessageDispatch15Interceptor;
+import org.apache.catalina.tribes.group.interceptors.TcpFailureDetector;
+import org.apache.catalina.ha.session.JvmRouteBinderValve;
+import org.apache.catalina.ha.session.JvmRouteSessionIDBinderListener;
+
+/**
+ * A <b>Cluster </b> implementation using simple multicast. Responsible for
+ * setting up a cluster and provides callers with a valid multicast
+ * receiver/sender.
+ * 
+ * FIXME remove install/remove/start/stop context dummys
+ * FIXME wrote testcases 
+ * 
+ * @author Filip Hanik
+ * @author Remy Maucherat
+ * @author Peter Rossbach
+ * @version $Revision: 379550 $, $Date: 2006-02-21 12:06:35 -0600 (Tue, 21 Feb 2006) $
+ */
+public class SimpleTcpCluster 
+    implements CatalinaCluster, Lifecycle, LifecycleListener, IDynamicProperty,
+               MembershipListener, ChannelListener{
+
+    public static Log log = LogFactory.getLog(SimpleTcpCluster.class);
+
+    // ----------------------------------------------------- Instance Variables
+
+    /**
+     * Descriptive information about this component implementation.
+     */
+    protected static final String info = "SimpleTcpCluster/2.2";
+
+    public static final String BEFORE_MEMBERREGISTER_EVENT = "before_member_register";
+
+    public static final String AFTER_MEMBERREGISTER_EVENT = "after_member_register";
+
+    public static final String BEFORE_MANAGERREGISTER_EVENT = "before_manager_register";
+
+    public static final String AFTER_MANAGERREGISTER_EVENT = "after_manager_register";
+
+    public static final String BEFORE_MANAGERUNREGISTER_EVENT = "before_manager_unregister";
+
+    public static final String AFTER_MANAGERUNREGISTER_EVENT = "after_manager_unregister";
+
+    public static final String BEFORE_MEMBERUNREGISTER_EVENT = "before_member_unregister";
+
+    public static final String AFTER_MEMBERUNREGISTER_EVENT = "after_member_unregister";
+
+    public static final String SEND_MESSAGE_FAILURE_EVENT = "send_message_failure";
+
+    public static final String RECEIVE_MESSAGE_FAILURE_EVENT = "receive_message_failure";
+    
+    /**
+     * Group channel.
+     */
+    protected Channel channel = new GroupChannel();
+
+
+    /**
+     * Name for logging purpose
+     */
+    protected String clusterImpName = "SimpleTcpCluster";
+
+    /**
+     * The string manager for this package.
+     */
+    protected StringManager sm = StringManager.getManager(Constants.Package);
+
+    /**
+     * The cluster name to join
+     */
+    protected String clusterName ;
+
+    /**
+     * The Container associated with this Cluster.
+     */
+    protected Container container = null;
+
+    /**
+     * The lifecycle event support for this component.
+     */
+    protected LifecycleSupport lifecycle = new LifecycleSupport(this);
+
+    /**
+     * Has this component been started?
+     */
+    protected boolean started = false;
+
+    /**
+     * The property change support for this component.
+     */
+    protected PropertyChangeSupport support = new PropertyChangeSupport(this);
+
+    /**
+     * The context name <->manager association for distributed contexts.
+     */
+    protected Map managers = new HashMap();
+
+    protected ClusterManager managerTemplate = new DeltaManager();
+
+    private List valves = new ArrayList();
+
+    private org.apache.catalina.ha.ClusterDeployer clusterDeployer;
+
+    /**
+     * Listeners of messages
+     */
+    protected List clusterListeners = new ArrayList();
+
+    /**
+     * Comment for <code>notifyLifecycleListenerOnFailure</code>
+     */
+    private boolean notifyLifecycleListenerOnFailure = false;
+
+    /**
+     * dynamic sender <code>properties</code>
+     */
+    private Map properties = new HashMap();
+    
+    private int channelSendOptions = Channel.SEND_OPTIONS_ASYNCHRONOUS;
+
+    // ------------------------------------------------------------- Properties
+
+    public SimpleTcpCluster() {
+    }
+
+    /**
+     * Return descriptive information about this Cluster implementation and the
+     * corresponding version number, in the format
+     * <code>&lt;description&gt;/&lt;version&gt;</code>.
+     */
+    public String getInfo() {
+        return (info);
+    }
+
+    /**
+     * Set the name of the cluster to join, if no cluster with this name is
+     * present create one.
+     * 
+     * @param clusterName
+     *            The clustername to join
+     */
+    public void setClusterName(String clusterName) {
+        this.clusterName = clusterName;
+    }
+
+    /**
+     * Return the name of the cluster that this Server is currently configured
+     * to operate within.
+     * 
+     * @return The name of the cluster associated with this server
+     */
+    public String getClusterName() {
+        if(clusterName == null && container != null)
+            return container.getName() ;
+        return clusterName;
+    }
+
+    /**
+     * Set the Container associated with our Cluster
+     * 
+     * @param container
+     *            The Container to use
+     */
+    public void setContainer(Container container) {
+        Container oldContainer = this.container;
+        this.container = container;
+        support.firePropertyChange("container", oldContainer, this.container);
+    }
+
+    /**
+     * Get the Container associated with our Cluster
+     * 
+     * @return The Container associated with our Cluster
+     */
+    public Container getContainer() {
+        return (this.container);
+    }
+
+    /**
+     * @return Returns the notifyLifecycleListenerOnFailure.
+     */
+    public boolean isNotifyLifecycleListenerOnFailure() {
+        return notifyLifecycleListenerOnFailure;
+    }
+
+    /**
+     * @param notifyListenerOnFailure
+     *            The notifyLifecycleListenerOnFailure to set.
+     */
+    public void setNotifyLifecycleListenerOnFailure(
+            boolean notifyListenerOnFailure) {
+        boolean oldNotifyListenerOnFailure = this.notifyLifecycleListenerOnFailure;
+        this.notifyLifecycleListenerOnFailure = notifyListenerOnFailure;
+        support.firePropertyChange("notifyLifecycleListenerOnFailure",
+                oldNotifyListenerOnFailure,
+                this.notifyLifecycleListenerOnFailure);
+    }
+
+    /**
+     * @deprecated use getManagerTemplate().getClass().getName() instead.
+     * @return String
+     */
+    public String getManagerClassName() {
+        return managerTemplate.getClass().getName();
+    }
+
+    /**
+     * @deprecated use nested &lt;Manager&gt; element inside the cluster config instead.
+     * @param managerClassName String
+     */
+    public void setManagerClassName(String managerClassName) {
+        log.warn("setManagerClassName is deprecated, use nested <Manager> element inside the <Cluster> element instead, this request will be ignored.");
+    }
+
+    /**
+     * Add cluster valve 
+     * Cluster Valves are only add to container when cluster is started!
+     * @param valve The new cluster Valve.
+     */
+    public void addValve(Valve valve) {
+        if (valve instanceof ClusterValve && (!valves.contains(valve)))
+            valves.add(valve);
+    }
+
+    /**
+     * get all cluster valves
+     * @return current cluster valves
+     */
+    public Valve[] getValves() {
+        return (Valve[]) valves.toArray(new Valve[valves.size()]);
+    }
+
+    /**
+     * Get the cluster listeners associated with this cluster. If this Array has
+     * no listeners registered, a zero-length array is returned.
+     */
+    public ClusterListener[] findClusterListeners() {
+        if (clusterListeners.size() > 0) {
+            ClusterListener[] listener = new ClusterListener[clusterListeners.size()];
+            clusterListeners.toArray(listener);
+            return listener;
+        } else
+            return new ClusterListener[0];
+
+    }
+
+    /**
+     * add cluster message listener and register cluster to this listener
+     * 
+     * @see org.apache.catalina.ha.CatalinaCluster#addClusterListener(org.apache.catalina.ha.MessageListener)
+     */
+    public void addClusterListener(ClusterListener listener) {
+        if (listener != null && !clusterListeners.contains(listener)) {
+            clusterListeners.add(listener);
+            listener.setCluster(this);
+        }
+    }
+
+    /**
+     * remove message listener and deregister Cluster from listener
+     * 
+     * @see org.apache.catalina.ha.CatalinaCluster#removeClusterListener(org.apache.catalina.ha.MessageListener)
+     */
+    public void removeClusterListener(ClusterListener listener) {
+        if (listener != null) {
+            clusterListeners.remove(listener);
+            listener.setCluster(null);
+        }
+    }
+
+    /**
+     * get current Deployer
+     */
+    public org.apache.catalina.ha.ClusterDeployer getClusterDeployer() {
+        return clusterDeployer;
+    }
+
+    /**
+     * set a new Deployer, must be set before cluster started!
+     */
+    public void setClusterDeployer(
+            org.apache.catalina.ha.ClusterDeployer clusterDeployer) {
+        this.clusterDeployer = clusterDeployer;
+    }
+
+    public void setChannel(Channel channel) {
+        this.channel = channel;
+    }
+
+    public void setManagerTemplate(ClusterManager managerTemplate) {
+        this.managerTemplate = managerTemplate;
+    }
+
+    public void setChannelSendOptions(int channelSendOptions) {
+        this.channelSendOptions = channelSendOptions;
+    }
+
+    /**
+     * has members
+     */
+    protected boolean hasMembers = false;
+    public boolean hasMembers() {
+        return hasMembers;
+    }
+    
+    /**
+     * Get all current cluster members
+     * @return all members or empty array 
+     */
+    public Member[] getMembers() {
+        return channel.getMembers();
+    }
+
+    /**
+     * Return the member that represents this node.
+     * 
+     * @return Member
+     */
+    public Member getLocalMember() {
+        return channel.getLocalMember(true);
+    }
+
+    // ------------------------------------------------------------- dynamic
+    // manager property handling
+
+    /**
+     * JMX hack to direct use at jconsole
+     * 
+     * @param name
+     * @param value
+     */
+    public void setProperty(String name, String value) {
+        setProperty(name, (Object) value);
+    }
+
+    /**
+     * set config attributes with reflect and propagate to all managers
+     * 
+     * @param name
+     * @param value
+     */
+    public void setProperty(String name, Object value) {
+        if (log.isTraceEnabled())
+            log.trace(sm.getString("SimpleTcpCluster.setProperty", name, value,properties.get(name)));
+        properties.put(name, value);
+        //using a dynamic way of setting properties is nice, but a security risk
+        //if exposed through JMX. This way you can sit and try to guess property names,
+        //we will only allow explicit property names
+        log.warn("Dynamic setProperty("+name+",value) has been disabled, please use explicit properties for the element you are trying to identify");
+        if(started) {
+            // FIXME Hmm, is that correct when some DeltaManagers are direct configured inside Context?
+            // Why we not support it for other elements, like sender, receiver or membership?
+            // Must we restart element after change?
+//            if (name.startsWith("manager")) {
+//                String key = name.substring("manager".length() + 1);
+//                String pvalue = value.toString();
+//                for (Iterator iter = managers.values().iterator(); iter.hasNext();) {
+//                    Manager manager = (Manager) iter.next();
+//                    if(manager instanceof DeltaManager && ((ClusterManager) manager).isDefaultMode()) {
+//                        IntrospectionUtils.setProperty(manager, key, pvalue );
+//                    }
+//                }
+//            } 
+        }
+    }
+
+    /**
+     * get current config
+     * 
+     * @param key
+     * @return The property
+     */
+    public Object getProperty(String key) {
+        if (log.isTraceEnabled())
+            log.trace(sm.getString("SimpleTcpCluster.getProperty", key));
+        return properties.get(key);
+    }
+
+    /**
+     * Get all properties keys
+     * 
+     * @return An iterator over the property names.
+     */
+    public Iterator getPropertyNames() {
+        return properties.keySet().iterator();
+    }
+
+    /**
+     * remove a configured property.
+     * 
+     * @param key
+     */
+    public void removeProperty(String key) {
+        properties.remove(key);
+    }
+
+    /**
+     * transfer properties from cluster configuration to subelement bean.
+     * @param prefix
+     * @param bean
+     */
+    protected void transferProperty(String prefix, Object bean) {
+        if (prefix != null) {
+            for (Iterator iter = getPropertyNames(); iter.hasNext();) {
+                String pkey = (String) iter.next();
+                if (pkey.startsWith(prefix)) {
+                    String key = pkey.substring(prefix.length() + 1);
+                    Object value = getProperty(pkey);
+                    IntrospectionUtils.setProperty(bean, key, value.toString());
+                }
+            }
+        }
+    }
+
+    // --------------------------------------------------------- Public Methods
+
+    /**
+     * @return Returns the managers.
+     */
+    public Map getManagers() {
+        return managers;
+    }
+
+    public Channel getChannel() {
+        return channel;
+    }
+
+    public ClusterManager getManagerTemplate() {
+        return managerTemplate;
+    }
+
+    public int getChannelSendOptions() {
+        return channelSendOptions;
+    }
+
+    /**
+     * Create new Manager without add to cluster (comes with start the manager)
+     * 
+     * @param name
+     *            Context Name of this manager
+     * @see org.apache.catalina.Cluster#createManager(java.lang.String)
+     * @see #addManager(String, Manager)
+     * @see DeltaManager#start()
+     */
+    public synchronized Manager createManager(String name) {
+        if (log.isDebugEnabled()) log.debug("Creating ClusterManager for context " + name + " using class " + getManagerClassName());
+        Manager manager = null;
+        try {
+            manager = managerTemplate.cloneFromTemplate();
+            ((ClusterManager)manager).setName(name);
+        } catch (Exception x) {
+            log.error("Unable to clone cluster manager, defaulting to org.apache.catalina.ha.session.DeltaManager", x);
+            manager = new org.apache.catalina.ha.session.DeltaManager();
+        } finally {
+            if ( manager != null && (manager instanceof ClusterManager)) ((ClusterManager)manager).setCluster(this);
+        }
+        return manager;
+    }
+    
+    public void registerManager(Manager manager) {
+    
+        if (! (manager instanceof ClusterManager)) {
+            log.warn("Manager [ " + manager + "] does not implement ClusterManager, addition to cluster has been aborted.");
+            return;
+        }
+        ClusterManager cmanager = (ClusterManager) manager ;
+        cmanager.setDistributable(true);
+        // Notify our interested LifecycleListeners
+        lifecycle.fireLifecycleEvent(BEFORE_MANAGERREGISTER_EVENT, manager);
+        String clusterName = getManagerName(cmanager.getName(), manager);
+        cmanager.setName(clusterName);
+        cmanager.setCluster(this);
+        cmanager.setDefaultMode(false);
+    
+        managers.put(clusterName, manager);
+        // Notify our interested LifecycleListeners
+        lifecycle.fireLifecycleEvent(AFTER_MANAGERREGISTER_EVENT, manager);    
+    }
+
+    /**
+     * remove an application form cluster replication bus
+     * 
+     * @see org.apache.catalina.ha.CatalinaCluster#removeManager(java.lang.String,Manager)
+     */
+    public void removeManager(Manager manager) {
+        if (manager != null && manager instanceof ClusterManager ) {
+            ClusterManager cmgr = (ClusterManager) manager;
+            // Notify our interested LifecycleListeners
+            lifecycle.fireLifecycleEvent(BEFORE_MANAGERUNREGISTER_EVENT,manager);
+            managers.remove(getManagerName(cmgr.getName(),manager));
+            cmgr.setCluster(null);
+            // Notify our interested LifecycleListeners
+            lifecycle.fireLifecycleEvent(AFTER_MANAGERUNREGISTER_EVENT, manager);
+        }
+    }
+
+    /**
+     * @param name
+     * @param manager
+     * @return
+     */
+    public String getManagerName(String name, Manager manager) {
+        String clusterName = name ;
+        if ( clusterName == null ) clusterName = manager.getContainer().getName();
+        if(getContainer() instanceof Engine) {
+            Container context = manager.getContainer() ;
+            if(context != null && context instanceof Context) {
+                Container host = ((Context)context).getParent();
+                if(host != null && host instanceof Host && clusterName!=null && !(clusterName.indexOf("#")>=0))
+                    clusterName = host.getName() +"#" + clusterName ;
+            }
+        }
+        return clusterName;
+    }
+
+    /*
+     * Get Manager
+     * 
+     * @see org.apache.catalina.ha.CatalinaCluster#getManager(java.lang.String)
+     */
+    public Manager getManager(String name) {
+        return (Manager) managers.get(name);
+    }
+    
+    // ------------------------------------------------------ Lifecycle Methods
+
+    /**
+     * Execute a periodic task, such as reloading, etc. This method will be
+     * invoked inside the classloading context of this container. Unexpected
+     * throwables will be caught and logged.
+     * @see org.apache.catalina.ha.deploy.FarmWarDeployer#backgroundProcess()
+     * @see ReplicationTransmitter#backgroundProcess()
+     */
+    public void backgroundProcess() {
+        if (clusterDeployer != null) clusterDeployer.backgroundProcess();
+        //send a heartbeat through the channel
+        if ( channel !=null ) channel.heartbeat();
+    }
+
+    /**
+     * Add a lifecycle event listener to this component.
+     * 
+     * @param listener
+     *            The listener to add
+     */
+    public void addLifecycleListener(LifecycleListener listener) {
+        lifecycle.addLifecycleListener(listener);
+    }
+
+    /**
+     * Get the lifecycle listeners associated with this lifecycle. If this
+     * Lifecycle has no listeners registered, a zero-length array is returned.
+     */
+    public LifecycleListener[] findLifecycleListeners() {
+
+        return lifecycle.findLifecycleListeners();
+
+    }
+
+    /**
+     * Remove a lifecycle event listener from this component.
+     * 
+     * @param listener
+     *            The listener to remove
+     */
+    public void removeLifecycleListener(LifecycleListener listener) {
+        lifecycle.removeLifecycleListener(listener);
+    }
+
+    /**
+     * Use as base to handle start/stop/periodic Events from host. Currently
+     * only log the messages as trace level.
+     * 
+     * @see org.apache.catalina.LifecycleListener#lifecycleEvent(org.apache.catalina.LifecycleEvent)
+     */
+    public void lifecycleEvent(LifecycleEvent lifecycleEvent) {
+        if (log.isTraceEnabled())
+            log.trace(sm.getString("SimpleTcpCluster.event.log", lifecycleEvent.getType(), lifecycleEvent.getData()));
+    }
+
+    // ------------------------------------------------------ public
+
+    /**
+     * Prepare for the beginning of active use of the public methods of this
+     * component. This method should be called after <code>configure()</code>,
+     * and before any of the public methods of the component are utilized. <BR>
+     * Starts the cluster communication channel, this will connect with the
+     * other nodes in the cluster, and request the current session state to be
+     * transferred to this node.
+     * 
+     * @exception IllegalStateException
+     *                if this component has already been started
+     * @exception LifecycleException
+     *                if this component detects a fatal error that prevents this
+     *                component from being used
+     */
+    public void start() throws LifecycleException {
+        if (started)
+            throw new LifecycleException(sm.getString("cluster.alreadyStarted"));
+        if (log.isInfoEnabled()) log.info("Cluster is about to start");
+
+        // Notify our interested LifecycleListeners
+        lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, this);
+        try {
+            checkDefaults();
+            registerClusterValve();
+            channel.addMembershipListener(this);
+            channel.addChannelListener(this);
+            channel.start(channel.DEFAULT);
+            if (clusterDeployer != null) clusterDeployer.start();
+            this.started = true;
+            // Notify our interested LifecycleListeners
+            lifecycle.fireLifecycleEvent(AFTER_START_EVENT, this);
+        } catch (Exception x) {
+            log.error("Unable to start cluster.", x);
+            throw new LifecycleException(x);
+        }
+    }
+
+    protected void checkDefaults() {
+        if ( clusterListeners.size() == 0 ) {
+            addClusterListener(new JvmRouteSessionIDBinderListener()); 
+            addClusterListener(new ClusterSessionListener());
+        }
+        if ( valves.size() == 0 ) {
+            addValve(new JvmRouteBinderValve());
+            addValve(new ReplicationValve());
+        }
+        if ( clusterDeployer != null ) clusterDeployer.setCluster(this);
+        if ( channel == null ) channel = new GroupChannel();
+        if ( channel instanceof GroupChannel && !((GroupChannel)channel).getInterceptors().hasNext()) {
+            channel.addInterceptor(new MessageDispatch15Interceptor());
+            channel.addInterceptor(new TcpFailureDetector());
+        }
+    }
+
+    /**
+     * register all cluster valve to host or engine
+     * @throws Exception
+     * @throws ClassNotFoundException
+     */
+    protected void registerClusterValve() throws Exception {
+        if(container != null ) {
+            for (Iterator iter = valves.iterator(); iter.hasNext();) {
+                ClusterValve valve = (ClusterValve) iter.next();
+                if (log.isDebugEnabled())
+                    log.debug("Invoking addValve on " + getContainer()
+                            + " with class=" + valve.getClass().getName());
+                if (valve != null) {
+                    IntrospectionUtils.callMethodN(getContainer(), "addValve",
+                            new Object[] { valve },
+                            new Class[] { org.apache.catalina.Valve.class });
+
+                }
+                valve.setCluster(this);
+            }
+        }
+    }
+
+    /**
+     * unregister all cluster valve to host or engine
+     * @throws Exception
+     * @throws ClassNotFoundException
+     */
+    protected void unregisterClusterValve() throws Exception {
+        for (Iterator iter = valves.iterator(); iter.hasNext();) {
+            ClusterValve valve = (ClusterValve) iter.next();
+            if (log.isDebugEnabled())
+                log.debug("Invoking removeValve on " + getContainer()
+                        + " with class=" + valve.getClass().getName());
+            if (valve != null) {
+                    IntrospectionUtils.callMethodN(getContainer(), "removeValve",
+                        new Object[] { valve }, new Class[] { org.apache.catalina.Valve.class });
+            }
+            valve.setCluster(this);
+        }
+    }
+
+    /**
+     * Gracefully terminate the active cluster component.<br/>
+     * This will disconnect the cluster communication channel, stop the
+     * listener and deregister the valves from host or engine.<br/><br/>
+     * <b>Note:</b><br/>The sub elements receiver, sender, membership,
+     * listener or valves are not removed. You can easily start the cluster again.
+     * 
+     * @exception IllegalStateException
+     *                if this component has not been started
+     * @exception LifecycleException
+     *                if this component detects a fatal error that needs to be
+     *                reported
+     */
+    public void stop() throws LifecycleException {
+
+        if (!started)
+            throw new IllegalStateException(sm.getString("cluster.notStarted"));
+        // Notify our interested LifecycleListeners
+        lifecycle.fireLifecycleEvent(BEFORE_STOP_EVENT, this);
+
+        if (clusterDeployer != null) clusterDeployer.stop();
+        this.managers.clear();
+        try {
+            if ( clusterDeployer != null ) clusterDeployer.setCluster(null);
+            channel.stop(Channel.DEFAULT);
+            channel.removeChannelListener(this);
+            channel.removeMembershipListener(this);
+            this.unregisterClusterValve();
+        } catch (Exception x) {
+            log.error("Unable to stop cluster valve.", x);
+        }
+        started = false;
+        // Notify our interested LifecycleListeners
+        lifecycle.fireLifecycleEvent(AFTER_STOP_EVENT, this);
+   }
+
+    
+
+
+    /**
+     * send message to all cluster members
+     * @param msg message to transfer
+     * 
+     * @see org.apache.catalina.ha.CatalinaCluster#send(org.apache.catalina.ha.ClusterMessage)
+     */
+    public void send(ClusterMessage msg) {
+        send(msg, null);
+    }
+
+    /**
+     * send message to all cluster members same cluster domain
+     * 
+     * @see org.apache.catalina.ha.CatalinaCluster#send(org.apache.catalina.ha.ClusterMessage)
+     */
+    public void sendClusterDomain(ClusterMessage msg) {
+        send(msg,null);
+    } 
+
+    
+    /**
+     * send a cluster message to one member
+     * 
+     * @param msg message to transfer
+     * @param dest Receiver member
+     * @see org.apache.catalina.ha.CatalinaCluster#send(org.apache.catalina.ha.ClusterMessage,
+     *      org.apache.catalina.ha.Member)
+     */
+    public void send(ClusterMessage msg, Member dest) {
+        try {
+            msg.setAddress(getLocalMember());
+            if (dest != null) {
+                if (!getLocalMember().equals(dest)) {
+                    channel.send(new Member[] {dest}, msg,channelSendOptions);
+                } else
+                    log.error("Unable to send message to local member " + msg);
+            } else {
+                channel.send(channel.getMembers(),msg,channelSendOptions);
+            }
+        } catch (Exception x) {
+            log.error("Unable to send message through cluster sender.", x);
+        }
+    }
+
+    /**
+     * New cluster member is registered
+     * 
+     * @see org.apache.catalina.ha.MembershipListener#memberAdded(org.apache.catalina.ha.Member)
+     */
+    public void memberAdded(Member member) {
+        try {
+            hasMembers = channel.hasMembers();
+            if (log.isInfoEnabled()) log.info("Replication member added:" + member);
+            // Notify our interested LifecycleListeners
+            lifecycle.fireLifecycleEvent(BEFORE_MEMBERREGISTER_EVENT, member);
+            // Notify our interested LifecycleListeners
+            lifecycle.fireLifecycleEvent(AFTER_MEMBERREGISTER_EVENT, member);
+        } catch (Exception x) {
+            log.error("Unable to connect to replication system.", x);
+        }
+
+    }
+
+    /**
+     * Cluster member is gone
+     * 
+     * @see org.apache.catalina.ha.MembershipListener#memberDisappeared(org.apache.catalina.ha.Member)
+     */
+    public void memberDisappeared(Member member) {
+        try {
+            hasMembers = channel.hasMembers();            
+            if (log.isInfoEnabled()) log.info("Received member disappeared:" + member);
+            // Notify our interested LifecycleListeners
+            lifecycle.fireLifecycleEvent(BEFORE_MEMBERUNREGISTER_EVENT, member);
+            // Notify our interested LifecycleListeners
+            lifecycle.fireLifecycleEvent(AFTER_MEMBERUNREGISTER_EVENT, member);
+        } catch (Exception x) {
+            log.error("Unable remove cluster node from replication system.", x);
+        }
+    }
+
+    // --------------------------------------------------------- receiver
+    // messages
+
+    /**
+     * notify all listeners from receiving a new message is not ClusterMessage
+     * emitt Failure Event to LifecylceListener
+     * 
+     * @param message
+     *            receveived Message
+     */
+    public boolean accept(Serializable msg, Member sender) {
+        return (msg instanceof ClusterMessage);
+    }
+    
+    
+    public void messageReceived(Serializable message, Member sender) {
+        ClusterMessage fwd = (ClusterMessage)message;
+        fwd.setAddress(sender);
+        messageReceived(fwd);
+    }
+
+    public void messageReceived(ClusterMessage message) {
+
+        long start = 0;
+        if (log.isDebugEnabled() && message != null)
+            log.debug("Assuming clocks are synched: Replication for "
+                    + message.getUniqueId() + " took="
+                    + (System.currentTimeMillis() - (message).getTimestamp())
+                    + " ms.");
+
+        //invoke all the listeners
+        boolean accepted = false;
+        if (message != null) {
+            for (Iterator iter = clusterListeners.iterator(); iter.hasNext();) {
+                ClusterListener listener = (ClusterListener) iter.next();
+                if (listener.accept(message)) {
+                    accepted = true;
+                    listener.messageReceived(message);
+                }
+            }
+        }
+        if (!accepted && log.isDebugEnabled()) {
+            if (notifyLifecycleListenerOnFailure) {
+                Member dest = message.getAddress();
+                // Notify our interested LifecycleListeners
+                lifecycle.fireLifecycleEvent(RECEIVE_MESSAGE_FAILURE_EVENT,
+                        new SendMessageData(message, dest, null));
+            }
+            log.debug("Message " + message.toString() + " from type "
+                    + message.getClass().getName()
+                    + " transfered but no listener registered");
+        }
+        return;
+    }
+
+    // --------------------------------------------------------- Logger
+
+    public Log getLogger() {
+        return log;
+    }
+
+
+
+    
+    // ------------------------------------------------------------- deprecated
+
+    /**
+     * 
+     * @see org.apache.catalina.Cluster#setProtocol(java.lang.String)
+     */
+    public void setProtocol(String protocol) {
+    }
+
+    /**
+     * @see org.apache.catalina.Cluster#getProtocol()
+     */
+    public String getProtocol() {
+        return null;
+    }
+
+    /**
+     * @see org.apache.catalina.Cluster#startContext(java.lang.String)
+     */
+    public void startContext(String contextPath) throws IOException {
+        
+    }
+
+    /**
+     * @see org.apache.catalina.Cluster#installContext(java.lang.String, java.net.URL)
+     */
+    public void installContext(String contextPath, URL war) {
+        
+    }
+
+    /**
+     * @see org.apache.catalina.Cluster#stop(java.lang.String)
+     */
+    public void stop(String contextPath) throws IOException {
+        
+    }
+}

==================================================
Constants.java
index b3a2ba23b0..645f349ad2 100644
--- a/java/org/apache/catalina/ha/util/IDynamicProperty.java
+++ b/java/org/apache/catalina/ha/util/IDynamicProperty.java
@@ -1,57 +1,58 @@
-/*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha.util;
-
-import java.util.Iterator;
-
-/**
- * @author Peter Rossbach
- * @version $Revision: 304032 $, $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
- */
-
-public interface IDynamicProperty {
-
-    /**
-     * set config attributes with reflect
-     * 
-     * @param name
-     * @param value
-     */
-    public void setProperty(String name, Object value) ;
-
-    /**
-     * get current config
-     * 
-     * @param key
-     * @return The property
-     */
-    public Object getProperty(String key) ;
-    /**
-     * Get all properties keys
-     * 
-     * @return An iterator over the property names
-     */
-    public Iterator getPropertyNames() ;
-
-    /**
-     * remove a configured property.
-     * 
-     * @param key
-     */
-    public void removeProperty(String key) ;
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha.util;
+
+import java.util.Iterator;
+
+/**
+ * @author Peter Rossbach
+ * @version $Revision: 304032 $, $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
+ */
+
+public interface IDynamicProperty {
+
+    /**
+     * set config attributes with reflect
+     * 
+     * @param name
+     * @param value
+     */
+    public void setProperty(String name, Object value) ;
+
+    /**
+     * get current config
+     * 
+     * @param key
+     * @return The property
+     */
+    public Object getProperty(String key) ;
+    /**
+     * Get all properties keys
+     * 
+     * @return An iterator over the property names
+     */
+    public Iterator getPropertyNames() ;
+
+    /**
+     * remove a configured property.
+     * 
+     * @param key
+     */
+    public void removeProperty(String key) ;
+
+}

==================================================
Reloader.java
index 23cb78b160..56e88aab3c 100644
--- a/java/org/apache/catalina/loader/Constants.java
+++ b/java/org/apache/catalina/loader/Constants.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ResourceEntry.java
index 7670a7f824..0711062358 100644
--- a/java/org/apache/catalina/loader/Reloader.java
+++ b/java/org/apache/catalina/loader/Reloader.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
StandardClassLoader.java
index 70928ec187..2817f2c513 100644
--- a/java/org/apache/catalina/loader/ResourceEntry.java
+++ b/java/org/apache/catalina/loader/ResourceEntry.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
StandardClassLoaderMBean.java
index cfe1d7cde5..2c80459f3b 100644
--- a/java/org/apache/catalina/loader/StandardClassLoader.java
+++ b/java/org/apache/catalina/loader/StandardClassLoader.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
WebappClassLoader.java
index 237601582b..c5ea26a5e3 100644
--- a/java/org/apache/catalina/loader/StandardClassLoaderMBean.java
+++ b/java/org/apache/catalina/loader/StandardClassLoaderMBean.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
WebappLoader.java
index b7983aab04..2001dd2e1c 100644
--- a/java/org/apache/catalina/loader/WebappClassLoader.java
+++ b/java/org/apache/catalina/loader/WebappClassLoader.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Constants.java
index 07b08880cd..554ddc8058 100644
--- a/java/org/apache/catalina/loader/WebappLoader.java
+++ b/java/org/apache/catalina/loader/WebappLoader.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
HTMLManagerServlet.java
index 124f7dca20..4097d8d41b 100644
--- a/java/org/apache/catalina/manager/Constants.java
+++ b/java/org/apache/catalina/manager/Constants.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JMXProxyServlet.java
index e53396fef0..7deea1dccd 100644
--- a/java/org/apache/catalina/manager/HTMLManagerServlet.java
+++ b/java/org/apache/catalina/manager/HTMLManagerServlet.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ManagerServlet.java
index 7509ed85fd..27e2b345ec 100644
--- a/java/org/apache/catalina/manager/JMXProxyServlet.java
+++ b/java/org/apache/catalina/manager/JMXProxyServlet.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
StatusManagerServlet.java
index d7dffceb3a..bad0c69bd3 100644
--- a/java/org/apache/catalina/manager/ManagerServlet.java
+++ b/java/org/apache/catalina/manager/ManagerServlet.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
StatusTransformer.java
index abb9050fca..de557805e4 100644
--- a/java/org/apache/catalina/manager/StatusManagerServlet.java
+++ b/java/org/apache/catalina/manager/StatusManagerServlet.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Constants.java
index 1220adfb06..ddf2e98459 100644
--- a/java/org/apache/catalina/manager/StatusTransformer.java
+++ b/java/org/apache/catalina/manager/StatusTransformer.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
HTMLHostManagerServlet.java
index 84b3db67ba..51d9bfd42b 100644
--- a/java/org/apache/catalina/manager/host/Constants.java
+++ b/java/org/apache/catalina/manager/host/Constants.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
HostManagerServlet.java
index c377e8054c..effea1deca 100644
--- a/java/org/apache/catalina/manager/host/HTMLHostManagerServlet.java
+++ b/java/org/apache/catalina/manager/host/HTMLHostManagerServlet.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ClassNameMBean.java
index ca5b40bb37..3cfdc2aaaa 100644
--- a/java/org/apache/catalina/manager/host/HostManagerServlet.java
+++ b/java/org/apache/catalina/manager/host/HostManagerServlet.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ConnectorMBean.java
index e03f89affa..1b55d3ad2b 100644
--- a/java/org/apache/catalina/mbeans/ClassNameMBean.java
+++ b/java/org/apache/catalina/mbeans/ClassNameMBean.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ContextEnvironmentMBean.java
index a27f778109..b97ec379c0 100644
--- a/java/org/apache/catalina/mbeans/ConnectorMBean.java
+++ b/java/org/apache/catalina/mbeans/ConnectorMBean.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ContextResourceLinkMBean.java
index 2f79235af6..bda039f502 100644
--- a/java/org/apache/catalina/mbeans/ContextEnvironmentMBean.java
+++ b/java/org/apache/catalina/mbeans/ContextEnvironmentMBean.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ContextResourceMBean.java
index a72e9ae593..c79ef9b5ac 100644
--- a/java/org/apache/catalina/mbeans/ContextResourceLinkMBean.java
+++ b/java/org/apache/catalina/mbeans/ContextResourceLinkMBean.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
DefaultContextMBean.java
index 4f362053d9..651ba1473e 100644
--- a/java/org/apache/catalina/mbeans/ContextResourceMBean.java
+++ b/java/org/apache/catalina/mbeans/ContextResourceMBean.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
GlobalResourcesLifecycleListener.java
index 302198581c..69cf7bcece 100644
--- a/java/org/apache/catalina/mbeans/DefaultContextMBean.java
+++ b/java/org/apache/catalina/mbeans/DefaultContextMBean.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
GroupMBean.java
index 53737bb0d9..765d160b6c 100644
--- a/java/org/apache/catalina/mbeans/GlobalResourcesLifecycleListener.java
+++ b/java/org/apache/catalina/mbeans/GlobalResourcesLifecycleListener.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
MBeanFactory.java
index 7975fb692c..6cad755f52 100644
--- a/java/org/apache/catalina/mbeans/GroupMBean.java
+++ b/java/org/apache/catalina/mbeans/GroupMBean.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
MBeanUtils.java
index 2e00f9e9da..8c00ed5a8b 100644
--- a/java/org/apache/catalina/mbeans/MBeanFactory.java
+++ b/java/org/apache/catalina/mbeans/MBeanFactory.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2002,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
MemoryUserDatabaseMBean.java
index e042e79de4..2b83206999 100644
--- a/java/org/apache/catalina/mbeans/MBeanUtils.java
+++ b/java/org/apache/catalina/mbeans/MBeanUtils.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
NamingResourcesMBean.java
index 4bd3f155d5..08be635798 100644
--- a/java/org/apache/catalina/mbeans/MemoryUserDatabaseMBean.java
+++ b/java/org/apache/catalina/mbeans/MemoryUserDatabaseMBean.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
RoleMBean.java
index a9b402a81e..29215d1180 100644
--- a/java/org/apache/catalina/mbeans/NamingResourcesMBean.java
+++ b/java/org/apache/catalina/mbeans/NamingResourcesMBean.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ServerLifecycleListener.java
index bba28ebe3e..18967be6b0 100644
--- a/java/org/apache/catalina/mbeans/RoleMBean.java
+++ b/java/org/apache/catalina/mbeans/RoleMBean.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
StandardContextMBean.java
index 4d694e8d65..2a9120c618 100644
--- a/java/org/apache/catalina/mbeans/ServerLifecycleListener.java
+++ b/java/org/apache/catalina/mbeans/ServerLifecycleListener.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
StandardEngineMBean.java
index 760676ebd8..b10eb1f753 100644
--- a/java/org/apache/catalina/mbeans/StandardContextMBean.java
+++ b/java/org/apache/catalina/mbeans/StandardContextMBean.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
StandardHostMBean.java
index 910361ae06..b303219c60 100644
--- a/java/org/apache/catalina/mbeans/StandardEngineMBean.java
+++ b/java/org/apache/catalina/mbeans/StandardEngineMBean.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
StandardServerMBean.java
index 6dbe64e71e..7692a3283d 100644
--- a/java/org/apache/catalina/mbeans/StandardHostMBean.java
+++ b/java/org/apache/catalina/mbeans/StandardHostMBean.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
StandardServiceMBean.java
index 204b2d56b3..0463bd4c52 100644
--- a/java/org/apache/catalina/mbeans/StandardServerMBean.java
+++ b/java/org/apache/catalina/mbeans/StandardServerMBean.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
UserMBean.java
index a387932717..d6e53e09fb 100644
--- a/java/org/apache/catalina/mbeans/StandardServiceMBean.java
+++ b/java/org/apache/catalina/mbeans/StandardServiceMBean.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Constants.java
index c5d7b1d40d..adcd02b1c7 100644
--- a/java/org/apache/catalina/mbeans/UserMBean.java
+++ b/java/org/apache/catalina/mbeans/UserMBean.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
DataSourceRealm.java
index d81f92bc1f..eb29ad2385 100644
--- a/java/org/apache/catalina/realm/Constants.java
+++ b/java/org/apache/catalina/realm/Constants.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
GenericPrincipal.java
index 8b7f32d0d3..9766641a8f 100644
--- a/java/org/apache/catalina/realm/DataSourceRealm.java
+++ b/java/org/apache/catalina/realm/DataSourceRealm.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JAASCallbackHandler.java
index fff728d866..d181af4bbc 100644
--- a/java/org/apache/catalina/realm/GenericPrincipal.java
+++ b/java/org/apache/catalina/realm/GenericPrincipal.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JAASMemoryLoginModule.java
index 2ec00f30cd..bee4ede256 100644
--- a/java/org/apache/catalina/realm/JAASCallbackHandler.java
+++ b/java/org/apache/catalina/realm/JAASCallbackHandler.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JAASRealm.java
index d1311a1770..5db1296d96 100644
--- a/java/org/apache/catalina/realm/JAASMemoryLoginModule.java
+++ b/java/org/apache/catalina/realm/JAASMemoryLoginModule.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JDBCRealm.java
index 45755598b3..28ccb4bf5b 100644
--- a/java/org/apache/catalina/realm/JAASRealm.java
+++ b/java/org/apache/catalina/realm/JAASRealm.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2001-2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JNDIRealm.java
index ffff0e9fd8..ab9573b34b 100644
--- a/java/org/apache/catalina/realm/JDBCRealm.java
+++ b/java/org/apache/catalina/realm/JDBCRealm.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
MemoryRealm.java
index ab1dcd9376..7c1c21d47f 100644
--- a/java/org/apache/catalina/realm/JNDIRealm.java
+++ b/java/org/apache/catalina/realm/JNDIRealm.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2002,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
MemoryRuleSet.java
index f67a14ca8d..274e0e55c3 100644
--- a/java/org/apache/catalina/realm/MemoryRealm.java
+++ b/java/org/apache/catalina/realm/MemoryRealm.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
RealmBase.java
index 9d74d31d68..66512be822 100644
--- a/java/org/apache/catalina/realm/MemoryRuleSet.java
+++ b/java/org/apache/catalina/realm/MemoryRuleSet.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
UserDatabaseRealm.java
index 501420c8ed..8e763a0f21 100644
--- a/java/org/apache/catalina/realm/RealmBase.java
+++ b/java/org/apache/catalina/realm/RealmBase.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SecurityClassLoad.java
index e2e469db35..2fef268551 100644
--- a/java/org/apache/catalina/realm/UserDatabaseRealm.java
+++ b/java/org/apache/catalina/realm/UserDatabaseRealm.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SecurityConfig.java
index 8912a770c8..98fd56d40f 100644
--- a/java/org/apache/catalina/security/SecurityClassLoad.java
+++ b/java/org/apache/catalina/security/SecurityClassLoad.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SecurityUtil.java
index 5f151fa094..12102ea351 100644
--- a/java/org/apache/catalina/security/SecurityConfig.java
+++ b/java/org/apache/catalina/security/SecurityConfig.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
CGIServlet.java
index 902aa29c27..afd5a81c82 100644
--- a/java/org/apache/catalina/security/SecurityUtil.java
+++ b/java/org/apache/catalina/security/SecurityUtil.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Constants.java
index 23c728c357..31742eb1db 100644
--- a/java/org/apache/catalina/servlets/CGIServlet.java
+++ b/java/org/apache/catalina/servlets/CGIServlet.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
DefaultServlet.java
index 7909f9fccb..f716da1d17 100644
--- a/java/org/apache/catalina/servlets/Constants.java
+++ b/java/org/apache/catalina/servlets/Constants.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
InvokerHttpRequest.java
index 2b5b1b35be..ffba049222 100644
--- a/java/org/apache/catalina/servlets/DefaultServlet.java
+++ b/java/org/apache/catalina/servlets/DefaultServlet.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
InvokerServlet.java
index fdc6fc4dca..3138db5588 100644
--- a/java/org/apache/catalina/servlets/InvokerHttpRequest.java
+++ b/java/org/apache/catalina/servlets/InvokerHttpRequest.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
WebdavServlet.java
index a460f81730..a21a1b65ae 100644
--- a/java/org/apache/catalina/servlets/InvokerServlet.java
+++ b/java/org/apache/catalina/servlets/InvokerServlet.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Constants.java
index 4989d0e1e4..44ae4ac30b 100644
--- a/java/org/apache/catalina/servlets/WebdavServlet.java
+++ b/java/org/apache/catalina/servlets/WebdavServlet.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
FileStore.java
index f719852326..24546879e5 100644
--- a/java/org/apache/catalina/session/Constants.java
+++ b/java/org/apache/catalina/session/Constants.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JDBCStore.java
index 3f7eacdbed..3a63630847 100644
--- a/java/org/apache/catalina/session/FileStore.java
+++ b/java/org/apache/catalina/session/FileStore.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ManagerBase.java
index 2f06500a60..c33c1edb5e 100644
--- a/java/org/apache/catalina/session/JDBCStore.java
+++ b/java/org/apache/catalina/session/JDBCStore.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
PersistentManager.java
index cf74cb2c36..a2fa69cd75 100644
--- a/java/org/apache/catalina/session/ManagerBase.java
+++ b/java/org/apache/catalina/session/ManagerBase.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
PersistentManagerBase.java
index e92b4e050a..29a8a9dd48 100644
--- a/java/org/apache/catalina/session/PersistentManager.java
+++ b/java/org/apache/catalina/session/PersistentManager.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
StandardManager.java
index 51264d0660..ff078671e2 100644
--- a/java/org/apache/catalina/session/PersistentManagerBase.java
+++ b/java/org/apache/catalina/session/PersistentManagerBase.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
StandardSession.java
index 3a785eca7c..490bc8f35e 100644
--- a/java/org/apache/catalina/session/StandardManager.java
+++ b/java/org/apache/catalina/session/StandardManager.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
StandardSessionFacade.java
index 30f6cbe931..22e1b6a2e7 100644
--- a/java/org/apache/catalina/session/StandardSession.java
+++ b/java/org/apache/catalina/session/StandardSession.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
StoreBase.java
index e9a734614c..4a42b7a377 100644
--- a/java/org/apache/catalina/session/StandardSessionFacade.java
+++ b/java/org/apache/catalina/session/StandardSessionFacade.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ByteArrayServletOutputStream.java
index 7412cee41c..526eb9a243 100644
--- a/java/org/apache/catalina/session/StoreBase.java
+++ b/java/org/apache/catalina/session/StoreBase.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ResponseIncludeWrapper.java
index c3d2271a46..ace4911107 100644
--- a/java/org/apache/catalina/ssi/ByteArrayServletOutputStream.java
+++ b/java/org/apache/catalina/ssi/ByteArrayServletOutputStream.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2002,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Bootstrap.java
index 3c7b89faaa..e6bfb78e6e 100644
--- a/java/org/apache/catalina/ssi/ResponseIncludeWrapper.java
+++ b/java/org/apache/catalina/ssi/ResponseIncludeWrapper.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2002,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Catalina.java
index bb8cfea546..28bc37b861 100644
--- a/java/org/apache/catalina/startup/Bootstrap.java
+++ b/java/org/apache/catalina/startup/Bootstrap.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
CatalinaProperties.java
index 974dab6315..1f9b76d6e6 100644
--- a/java/org/apache/catalina/startup/Catalina.java
+++ b/java/org/apache/catalina/startup/Catalina.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ClassLoaderFactory.java
index 296f59bff1..1e0bd15029 100644
--- a/java/org/apache/catalina/startup/CatalinaProperties.java
+++ b/java/org/apache/catalina/startup/CatalinaProperties.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ClusterRuleSetFactory.java
index 243d9f6223..6d83660066 100644
--- a/java/org/apache/catalina/startup/ClassLoaderFactory.java
+++ b/java/org/apache/catalina/startup/ClassLoaderFactory.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ConnectorCreateRule.java
index 64dddb66a5..1011080f17 100644
--- a/java/org/apache/catalina/startup/ClusterRuleSetFactory.java
+++ b/java/org/apache/catalina/startup/ClusterRuleSetFactory.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Constants.java
index 96f030d748..7e4cbb67f3 100644
--- a/java/org/apache/catalina/startup/ConnectorCreateRule.java
+++ b/java/org/apache/catalina/startup/ConnectorCreateRule.java
@@ -1,10 +1,11 @@
 /* $Id: ConnectorCreateRule.java 303287 2004-09-29 09:55:39Z remm $
  *
- * Copyright 2001-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ContextConfig.java
index 289401af5a..c7c67766d2 100644
--- a/java/org/apache/catalina/startup/Constants.java
+++ b/java/org/apache/catalina/startup/Constants.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ContextRuleSet.java
index 62f0e54acd..73df31c38e 100644
--- a/java/org/apache/catalina/startup/ContextConfig.java
+++ b/java/org/apache/catalina/startup/ContextConfig.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
CopyParentClassLoaderRule.java
index e52faba379..490b1ddb28 100644
--- a/java/org/apache/catalina/startup/ContextRuleSet.java
+++ b/java/org/apache/catalina/startup/ContextRuleSet.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
DigesterFactory.java
index 604aa3a84e..51544321ac 100644
--- a/java/org/apache/catalina/startup/CopyParentClassLoaderRule.java
+++ b/java/org/apache/catalina/startup/CopyParentClassLoaderRule.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Embedded.java
index 6e319fb01e..96dee1b139 100644
--- a/java/org/apache/catalina/startup/DigesterFactory.java
+++ b/java/org/apache/catalina/startup/DigesterFactory.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
EngineConfig.java
index efb440fff2..9be97480c3 100644
--- a/java/org/apache/catalina/startup/Embedded.java
+++ b/java/org/apache/catalina/startup/Embedded.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
EngineRuleSet.java
index d8ffc8e4e1..683f38f062 100644
--- a/java/org/apache/catalina/startup/EngineConfig.java
+++ b/java/org/apache/catalina/startup/EngineConfig.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ExpandWar.java
index bd9311855b..545c4a6705 100644
--- a/java/org/apache/catalina/startup/EngineRuleSet.java
+++ b/java/org/apache/catalina/startup/EngineRuleSet.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
HomesUserDatabase.java
index da35c76e1d..5a22a2f1b9 100644
--- a/java/org/apache/catalina/startup/ExpandWar.java
+++ b/java/org/apache/catalina/startup/ExpandWar.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
HostConfig.java
index ad74394495..663e7df846 100644
--- a/java/org/apache/catalina/startup/HomesUserDatabase.java
+++ b/java/org/apache/catalina/startup/HomesUserDatabase.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
HostRuleSet.java
index 5046945739..2f5fe37fba 100644
--- a/java/org/apache/catalina/startup/HostConfig.java
+++ b/java/org/apache/catalina/startup/HostConfig.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
LifecycleListenerRule.java
index 0f9557fbdd..2b533f1a3a 100644
--- a/java/org/apache/catalina/startup/HostRuleSet.java
+++ b/java/org/apache/catalina/startup/HostRuleSet.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
NamingRuleSet.java
index e8b2938c9f..6bb169cd69 100644
--- a/java/org/apache/catalina/startup/LifecycleListenerRule.java
+++ b/java/org/apache/catalina/startup/LifecycleListenerRule.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
PasswdUserDatabase.java
index c0eb70a435..76d902c234 100644
--- a/java/org/apache/catalina/startup/NamingRuleSet.java
+++ b/java/org/apache/catalina/startup/NamingRuleSet.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SetAllPropertiesRule.java
index 4d96e84938..4ad7041fbb 100644
--- a/java/org/apache/catalina/startup/PasswdUserDatabase.java
+++ b/java/org/apache/catalina/startup/PasswdUserDatabase.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SetContextPropertiesRule.java
index a9a6492f7e..4c99c472b6 100644
--- a/java/org/apache/catalina/startup/SetAllPropertiesRule.java
+++ b/java/org/apache/catalina/startup/SetAllPropertiesRule.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SetNextNamingRule.java
index 2216565e8c..3ecb6d74fc 100644
--- a/java/org/apache/catalina/startup/SetContextPropertiesRule.java
+++ b/java/org/apache/catalina/startup/SetContextPropertiesRule.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
TldConfig.java
index c73782ede1..9e3b1f767e 100644
--- a/java/org/apache/catalina/startup/SetNextNamingRule.java
+++ b/java/org/apache/catalina/startup/SetNextNamingRule.java
@@ -1,10 +1,11 @@
 /* $Id: SetNextNamingRule.java 303133 2004-08-29 16:46:15Z yoavs $
  *
- * Copyright 2001-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
TldRuleSet.java
index fc20acccd9..08ed404d3d 100644
--- a/java/org/apache/catalina/startup/TldConfig.java
+++ b/java/org/apache/catalina/startup/TldConfig.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Tool.java
index 3037498f27..b24b540db8 100644
--- a/java/org/apache/catalina/startup/TldRuleSet.java
+++ b/java/org/apache/catalina/startup/TldRuleSet.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
UserConfig.java
index f54bd81920..9faee0c17f 100644
--- a/java/org/apache/catalina/startup/Tool.java
+++ b/java/org/apache/catalina/startup/Tool.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
UserDatabase.java
index 240c3607a3..994dbe313a 100644
--- a/java/org/apache/catalina/startup/UserConfig.java
+++ b/java/org/apache/catalina/startup/UserConfig.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
WebAnnotationSet.java
index fcac2704f4..8cc0b543bf 100644
--- a/java/org/apache/catalina/startup/UserDatabase.java
+++ b/java/org/apache/catalina/startup/UserDatabase.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
WebRuleSet.java
index f9022584c5..b1fa073796 100644
--- a/java/org/apache/catalina/startup/WebAnnotationSet.java
+++ b/java/org/apache/catalina/startup/WebAnnotationSet.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ByteMessage.java
index 4ba55412a6..38d6da5ad6 100644
--- a/java/org/apache/catalina/startup/WebRuleSet.java
+++ b/java/org/apache/catalina/startup/WebRuleSet.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Channel.java
index 7ce371db43..ee356777dd 100644
--- a/java/org/apache/catalina/tribes/ByteMessage.java
+++ b/java/org/apache/catalina/tribes/ByteMessage.java
@@ -1,101 +1,102 @@
-/*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes;
-
-import java.io.Serializable;
-import java.io.Externalizable;
-import java.io.ObjectInput;
-import java.io.IOException;
-import java.io.ObjectOutput;
-
-/**
- * A byte message is not serialized and deserialized by the channel
- * instead it is sent as a byte array<br>
- * By default Tribes uses java serialization when it receives an object
- * to be sent over the wire. Java serialization is not the most
- * efficient of serializing data, and Tribes might not even
- * have access to the correct class loaders to deserialize the object properly.
- * <br>
- * The ByteMessage class is a class where the channel when it receives it will
- * not attempt to perform serialization, instead it will simply stream the <code>getMessage()</code>
- * bytes.<br>
- * If you are using multiple applications on top of Tribes you should add some sort of header
- * so that you can decide with the <code>ChannelListener.accept()</code> whether this message was intended
- * for you.
- * @author Filip Hanik
- * @version $Revision: 304032 $, $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
- */
-
-public class ByteMessage implements Serializable, Externalizable {
-    /**
-     * Storage for the message to be sent
-     */
-    private byte[] message;
-
-
-    /**
-     * Creates an empty byte message
-     * Constructor also for deserialization
-     */
-    public ByteMessage() {
-    }
-
-    /**
-     * Creates a byte message wit h
-     * @param data byte[] - the message contents
-     */
-    public ByteMessage(byte[] data) {
-        message = data;
-    }
-
-    /**
-     * Returns the message contents of this byte message
-     * @return byte[] - message contents, can be null
-     */
-    public byte[] getMessage() {
-        return message;
-    }
-
-    /**
-     * Sets the message contents of this byte message
-     * @param message byte[]
-     */
-    public void setMessage(byte[] message) {
-        this.message = message;
-    }
-
-    /**
-     * @see java.io.Externalizable#readExternal
-     * @param in ObjectInput
-     * @throws IOException
-     */
-    public void readExternal(ObjectInput in ) throws IOException {
-        int length = in.readInt();
-        message = new byte[length];
-        in.read(message,0,length);
-    }
-
-    /**
-     * @see java.io.Externalizable#writeExternal
-     * @param out ObjectOutput
-     * @throws IOException
-     */
-    public void writeExternal(ObjectOutput out) throws IOException {
-        out.writeInt(message!=null?message.length:0);
-        if ( message!=null ) out.write(message,0,message.length);
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes;
+
+import java.io.Serializable;
+import java.io.Externalizable;
+import java.io.ObjectInput;
+import java.io.IOException;
+import java.io.ObjectOutput;
+
+/**
+ * A byte message is not serialized and deserialized by the channel
+ * instead it is sent as a byte array<br>
+ * By default Tribes uses java serialization when it receives an object
+ * to be sent over the wire. Java serialization is not the most
+ * efficient of serializing data, and Tribes might not even
+ * have access to the correct class loaders to deserialize the object properly.
+ * <br>
+ * The ByteMessage class is a class where the channel when it receives it will
+ * not attempt to perform serialization, instead it will simply stream the <code>getMessage()</code>
+ * bytes.<br>
+ * If you are using multiple applications on top of Tribes you should add some sort of header
+ * so that you can decide with the <code>ChannelListener.accept()</code> whether this message was intended
+ * for you.
+ * @author Filip Hanik
+ * @version $Revision: 304032 $, $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
+ */
+
+public class ByteMessage implements Serializable, Externalizable {
+    /**
+     * Storage for the message to be sent
+     */
+    private byte[] message;
+
+
+    /**
+     * Creates an empty byte message
+     * Constructor also for deserialization
+     */
+    public ByteMessage() {
+    }
+
+    /**
+     * Creates a byte message wit h
+     * @param data byte[] - the message contents
+     */
+    public ByteMessage(byte[] data) {
+        message = data;
+    }
+
+    /**
+     * Returns the message contents of this byte message
+     * @return byte[] - message contents, can be null
+     */
+    public byte[] getMessage() {
+        return message;
+    }
+
+    /**
+     * Sets the message contents of this byte message
+     * @param message byte[]
+     */
+    public void setMessage(byte[] message) {
+        this.message = message;
+    }
+
+    /**
+     * @see java.io.Externalizable#readExternal
+     * @param in ObjectInput
+     * @throws IOException
+     */
+    public void readExternal(ObjectInput in ) throws IOException {
+        int length = in.readInt();
+        message = new byte[length];
+        in.read(message,0,length);
+    }
+
+    /**
+     * @see java.io.Externalizable#writeExternal
+     * @param out ObjectOutput
+     * @throws IOException
+     */
+    public void writeExternal(ObjectOutput out) throws IOException {
+        out.writeInt(message!=null?message.length:0);
+        if ( message!=null ) out.write(message,0,message.length);
+    }
+
+}

==================================================
ChannelException.java
index fb8bc0af13..c0859187e1 100644
--- a/java/org/apache/catalina/tribes/Channel.java
+++ b/java/org/apache/catalina/tribes/Channel.java
@@ -1,346 +1,347 @@
-/*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes;
-
-import java.io.Serializable;
-
-/**
- * Channel interface<br>
- * A channel is a representation of a group of nodes all participating in some sort of
- * communication with each other.<br>
- * The channel is the main API class for Tribes, this is essentially the only class
- * that an application needs to be aware of. Through the channel the application can:<br>
- * 1. send messages<br>
- * 2. receive message (by registering a <code>ChannelListener</code><br>
- * 3. get all members of the group <code>getMembers()</code><br>
- * 4. receive notifications of members added and members disappeared by
- *    registerering a <code>MembershipListener</code><br>
- * <br>
- * The channel has 5 major components:<br>
- * 1. Data receiver, with a built in thread pool to receive messages from other peers<br>
- * 2. Data sender, an implementation for sending data using NIO or java.io<br>
- * 3. Membership listener,listens for membership broadcasts<br>
- * 4. Membership broadcaster, broadcasts membership pings.<br>
- * 5. Channel interceptors, the ability to manipulate messages as they are sent or arrive<br><br>
- * The channel layout is:
- * <pre><code>
- *  ChannelListener_1..ChannelListener_N MembershipListener_1..MembershipListener_N [Application Layer]
- *            \          \                  /                   /
- *             \          \                /                   /
- *              \          \              /                   /
- *               \          \            /                   /
- *                \          \          /                   /
- *                 \          \        /                   /
- *                  ---------------------------------------
- *                                  |
- *                                  |
- *                               Channel
- *                                  |
- *                         ChannelInterceptor_1
- *                                  |                                               [Channel stack]
- *                         ChannelInterceptor_N
- *                                  |
- *                             Coordinator (implements MessageListener,MembershipListener,ChannelInterceptor)
- *                          --------------------
- *                         /        |           \ 
- *                        /         |            \
- *                       /          |             \
- *                      /           |              \
- *                     /            |               \
- *           MembershipService ChannelSender ChannelReceiver                        [IO layer]
- * </code></pre>
- * 
- * For example usage @see org.apache.catalina.tribes.group.GroupChannel
- * @author Filip Hanik
- * @version $Revision: 304032 $, $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
- */
-public interface Channel {
-    
-    /**
-     * Start and stop sequences can be controlled by these constants
-     * This allows you to start separate components of the channel <br>
-     * DEFAULT - starts or stops all components in the channel
-     * @see #start(int)
-     * @see #stop(int)
-     */
-    public static final int DEFAULT = 15;
-
-    /**
-     * Start and stop sequences can be controlled by these constants
-     * This allows you to start separate components of the channel <br>
-     * SND_RX_SEQ - starts or stops the data receiver. Start means opening a server socket
-     * in case of a TCP implementation
-     * @see #start(int)
-     * @see #stop(int)
-     */
-    public static final int SND_RX_SEQ = 1;
-
-    /**
-     * Start and stop sequences can be controlled by these constants
-     * This allows you to start separate components of the channel <br>
-     * SND_TX_SEQ - starts or stops the data sender. This should not open any sockets,
-     * as sockets are opened on demand when a message is being sent
-     * @see #start(int)
-     * @see #stop(int)
-     */
-    public static final int SND_TX_SEQ = 2;
-
-    /**
-     * Start and stop sequences can be controlled by these constants
-     * This allows you to start separate components of the channel <br>
-     * MBR_RX_SEQ - starts or stops the membership listener. In a multicast implementation
-     * this will open a datagram socket and join a group and listen for membership messages
-     * members joining
-     * @see #start(int)
-     * @see #stop(int)
-     */
-    public static final int MBR_RX_SEQ = 4;
-
-    /**
-     * Start and stop sequences can be controlled by these constants
-     * This allows you to start separate components of the channel <br>
-     * MBR_TX_SEQ - starts or stops the membership broadcaster. In a multicast implementation
-     * this will open a datagram socket and join a group and broadcast the local member information
-     * @see #start(int)
-     * @see #stop(int)
-     */
-    public static final int MBR_TX_SEQ = 8;
-    
-    /**
-     * Send options, when a message is sent, it can have an option flag
-     * to trigger certain behavior. Most flags are used to trigger channel interceptors
-     * as the message passes through the channel stack. <br>
-     * However, there are five default flags that every channel implementation must implement<br>
-     * SEND_OPTIONS_BYTE_MESSAGE - The message is a pure byte message and no marshalling or unmarshalling will
-     * be performed.<br>
-     * 
-     * @see #send(Member[], Serializable , int)
-     * @see #send(Member[], Serializable, int, ErrorHandler)
-     */
-    public static final int SEND_OPTIONS_BYTE_MESSAGE = 0x0001;
-
-    /**
-     * Send options, when a message is sent, it can have an option flag
-     * to trigger certain behavior. Most flags are used to trigger channel interceptors
-     * as the message passes through the channel stack. <br>
-     * However, there are five default flags that every channel implementation must implement<br>
-     * SEND_OPTIONS_USE_ACK - Message is sent and an ACK is received when the message has been received by the recipient<br>
-     * If no ack is received, the message is not considered successful<br>
-     * @see #send(Member[], Serializable , int)
-     * @see #send(Member[], Serializable, int, ErrorHandler)
-     */
-    public static final int SEND_OPTIONS_USE_ACK = 0x0002;
-
-    /**
-     * Send options, when a message is sent, it can have an option flag
-     * to trigger certain behavior. Most flags are used to trigger channel interceptors
-     * as the message passes through the channel stack. <br>
-     * However, there are five default flags that every channel implementation must implement<br>
-     * SEND_OPTIONS_SYNCHRONIZED_ACK - Message is sent and an ACK is received when the message has been received and 
-     * processed by the recipient<br>
-     * If no ack is received, the message is not considered successful<br>
-     * @see #send(Member[], Serializable , int)
-     * @see #send(Member[], Serializable, int, ErrorHandler)
-     */
-    public static final int SEND_OPTIONS_SYNCHRONIZED_ACK = 0x0004;
-    
-    /**
-     * Send options, when a message is sent, it can have an option flag
-     * to trigger certain behavior. Most flags are used to trigger channel interceptors
-     * as the message passes through the channel stack. <br>
-     * However, there are five default flags that every channel implementation must implement<br>
-     * SEND_OPTIONS_ASYNCHRONOUS - Message is sent and an ACK is received when the message has been received and 
-     * processed by the recipient<br>
-     * If no ack is received, the message is not considered successful<br>
-     * @see #send(Member[], Serializable , int)
-     * @see #send(Member[], Serializable, int, ErrorHandler)
-     */
-    public static final int SEND_OPTIONS_ASYNCHRONOUS = 0x0008;
-    
-    /**
-     * Send options, when a message is sent, it can have an option flag
-     * to trigger certain behavior. Most flags are used to trigger channel interceptors
-     * as the message passes through the channel stack. <br>
-     * However, there are five default flags that every channel implementation must implement<br>
-     * SEND_OPTIONS_SECURE - Message is sent over an encrypted channel<br>
-     * @see #send(Member[], Serializable , int)
-     * @see #send(Member[], Serializable, int, ErrorHandler)
-     */
-    public static final int SEND_OPTIONS_SECURE = 0x0010;
-    
-
-    /**
-     * Send options, when a message is sent, it can have an option flag
-     * to trigger certain behavior. Most flags are used to trigger channel interceptors
-     * as the message passes through the channel stack. <br>
-     * However, there are five default flags that every channel implementation must implement<br>
-     * SEND_OPTIONS_DEFAULT - the default sending options, just a helper variable. <br>
-     * The default is <code>int SEND_OPTIONS_DEFAULT = SEND_OPTIONS_USE_ACK;</code><br>
-     * @see #SEND_OPTIONS_USE_ACK
-     * @see #send(Member[], Serializable , int)
-     * @see #send(Member[], Serializable, int, ErrorHandler)
-     */
-    public static final int SEND_OPTIONS_DEFAULT = SEND_OPTIONS_USE_ACK;
-
-    
-    /**
-     * Adds an interceptor to the channel message chain.
-     * @param interceptor ChannelInterceptor
-     */
-    public void addInterceptor(ChannelInterceptor interceptor);
-    
-    /**
-     * Starts up the channel. This can be called multiple times for individual services to start
-     * The svc parameter can be the logical or value of any constants
-     * @param svc int value of <BR>
-     * DEFAULT - will start all services <BR>
-     * MBR_RX_SEQ - starts the membership receiver <BR>
-     * MBR_TX_SEQ - starts the membership broadcaster <BR>
-     * SND_TX_SEQ - starts the replication transmitter<BR>
-     * SND_RX_SEQ - starts the replication receiver<BR>
-     * <b>Note:</b> In order for the membership broadcaster to 
-     * transmit the correct information, it has to be started after the replication receiver.
-     * @throws ChannelException if a startup error occurs or the service is already started or an error occurs.
-     */
-    public void start(int svc) throws ChannelException;
-
-    /**
-     * Shuts down the channel. This can be called multiple times for individual services to shutdown
-     * The svc parameter can be the logical or value of any constants
-     * @param svc int value of <BR>
-     * DEFAULT - will shutdown all services <BR>
-     * MBR_RX_SEQ - stops the membership receiver <BR>
-     * MBR_TX_SEQ - stops the membership broadcaster <BR>
-     * SND_TX_SEQ - stops the replication transmitter<BR>
-     * SND_RX_SEQ - stops the replication receiver<BR>
-     * @throws ChannelException if a startup error occurs or the service is already stopped or an error occurs.
-     */
-    public void stop(int svc) throws ChannelException;    
-    
-    /**
-     * Send a message to one or more members in the cluster
-     * @param destination Member[] - the destinations, can not be null or zero length, the reason for that
-     * is that a membership change can occur and at that time the application is uncertain what group the message
-     * actually got sent to.
-     * @param msg Serializable - the message to send, has to be serializable, or a <code>ByteMessage</code> to 
-     * send a pure byte array
-     * @param options int - sender options, see class documentation for each interceptor that is configured in order to trigger interceptors
-     * @return a unique Id that identifies the message that is sent
-     * @see ByteMessage
-     * @see #SEND_OPTIONS_USE_ACK
-     * @see #SEND_OPTIONS_ASYNCHRONOUS
-     * @see #SEND_OPTIONS_SYNCHRONIZED_ACK
-     */
-    public UniqueId send(Member[] destination, Serializable msg, int options) throws ChannelException;
-
-    /**
-     * Send a message to one or more members in the cluster
-     * @param destination Member[] - the destinations, null or zero length means all
-     * @param msg ClusterMessage - the message to send
-     * @param options int - sender options, see class documentation
-     * @param handler ErrorHandler - handle errors through a callback, rather than throw it
-     * @return a unique Id that identifies the message that is sent
-     * @exception ChannelException - if a serialization error happens.
-     */
-    public UniqueId send(Member[] destination, Serializable msg, int options, ErrorHandler handler) throws ChannelException;
-    
-    /**
-     * Sends a heart beat through the interceptor stacks
-     * Use this method to alert interceptors and other components to 
-     * clean up garbage, timed out messages etc.<br>
-     * If you application has a background thread, then you can save one thread,
-     * by configuring your channel to not use an internal heartbeat thread
-     * and invoking this method.
-     * @see #setHeartbeat(boolean)
-     */
-    public void heartbeat();
-    
-    /**
-     * Enables or disables internal heartbeat.
-     * @param enable boolean - default value is implementation specific
-     * @see #heartbeat()
-     */
-    public void setHeartbeat(boolean enable);
-    
-    /**
-     * Add a membership listener, will get notified when a new member joins, leaves or crashes
-     * <br>If the membership listener implements the Heartbeat interface
-     * the <code>heartbeat()</code> method will be invoked when the heartbeat runs on the channel
-     * @param listener MembershipListener
-     * @see MembershipListener
-     */
-    public void addMembershipListener(MembershipListener listener);
-    
-    /**
-     * Add a channel listener, this is a callback object when messages are received
-     * <br>If the channel listener implements the Heartbeat interface
-     * the <code>heartbeat()</code> method will be invoked when the heartbeat runs on the channel
-     * @param listener ChannelListener
-     * @see ChannelListener
-     * @see Heartbeat
-     */
-    public void addChannelListener(ChannelListener listener);
-
-    /**
-     * remove a membership listener, listeners are removed based on Object.hashCode and Object.equals
-     * @param listener MembershipListener
-     * @see MembershipListener
-     */
-    public void removeMembershipListener(MembershipListener listener);
-    /**
-     * remove a channel listener, listeners are removed based on Object.hashCode and Object.equals
-     * @param listener ChannelListener
-     * @see ChannelListener
-     */
-    public void removeChannelListener(ChannelListener listener);
-    
-    /**
-     * Returns true if there are any members in the group,
-     * this call is the same as <code>getMembers().length>0</code>
-     * @return boolean - true if there are any members automatically discovered
-     */
-    public boolean hasMembers() ;
-
-    /**
-     * Get all current group members
-     * @return all members or empty array, never null 
-     */
-    public Member[] getMembers() ;
-
-    /**
-     * Return the member that represents this node. This is also the data
-     * that gets broadcasted through the membership broadcaster component
-     * @param incAlive - optimization, true if you want it to calculate alive time
-     * since the membership service started.
-     * @return Member
-     */
-    public Member getLocalMember(boolean incAlive);
-    
-    /**
-     * Returns the member from the membership service with complete and 
-     * recent data. Some implementations might serialize and send 
-     * membership information along with a message, and instead of sending
-     * complete membership details, only send the primary identifier for the member
-     * but not the payload or other information. When such message is received
-     * the application can retrieve the cached member through this call.<br>
-     * In most cases, this is not necessary.
-     * @param mbr Member
-     * @return Member
-     */
-    public Member getMember(Member mbr);
-
-    
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes;
+
+import java.io.Serializable;
+
+/**
+ * Channel interface<br>
+ * A channel is a representation of a group of nodes all participating in some sort of
+ * communication with each other.<br>
+ * The channel is the main API class for Tribes, this is essentially the only class
+ * that an application needs to be aware of. Through the channel the application can:<br>
+ * 1. send messages<br>
+ * 2. receive message (by registering a <code>ChannelListener</code><br>
+ * 3. get all members of the group <code>getMembers()</code><br>
+ * 4. receive notifications of members added and members disappeared by
+ *    registerering a <code>MembershipListener</code><br>
+ * <br>
+ * The channel has 5 major components:<br>
+ * 1. Data receiver, with a built in thread pool to receive messages from other peers<br>
+ * 2. Data sender, an implementation for sending data using NIO or java.io<br>
+ * 3. Membership listener,listens for membership broadcasts<br>
+ * 4. Membership broadcaster, broadcasts membership pings.<br>
+ * 5. Channel interceptors, the ability to manipulate messages as they are sent or arrive<br><br>
+ * The channel layout is:
+ * <pre><code>
+ *  ChannelListener_1..ChannelListener_N MembershipListener_1..MembershipListener_N [Application Layer]
+ *            \          \                  /                   /
+ *             \          \                /                   /
+ *              \          \              /                   /
+ *               \          \            /                   /
+ *                \          \          /                   /
+ *                 \          \        /                   /
+ *                  ---------------------------------------
+ *                                  |
+ *                                  |
+ *                               Channel
+ *                                  |
+ *                         ChannelInterceptor_1
+ *                                  |                                               [Channel stack]
+ *                         ChannelInterceptor_N
+ *                                  |
+ *                             Coordinator (implements MessageListener,MembershipListener,ChannelInterceptor)
+ *                          --------------------
+ *                         /        |           \ 
+ *                        /         |            \
+ *                       /          |             \
+ *                      /           |              \
+ *                     /            |               \
+ *           MembershipService ChannelSender ChannelReceiver                        [IO layer]
+ * </code></pre>
+ * 
+ * For example usage @see org.apache.catalina.tribes.group.GroupChannel
+ * @author Filip Hanik
+ * @version $Revision: 304032 $, $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
+ */
+public interface Channel {
+    
+    /**
+     * Start and stop sequences can be controlled by these constants
+     * This allows you to start separate components of the channel <br>
+     * DEFAULT - starts or stops all components in the channel
+     * @see #start(int)
+     * @see #stop(int)
+     */
+    public static final int DEFAULT = 15;
+
+    /**
+     * Start and stop sequences can be controlled by these constants
+     * This allows you to start separate components of the channel <br>
+     * SND_RX_SEQ - starts or stops the data receiver. Start means opening a server socket
+     * in case of a TCP implementation
+     * @see #start(int)
+     * @see #stop(int)
+     */
+    public static final int SND_RX_SEQ = 1;
+
+    /**
+     * Start and stop sequences can be controlled by these constants
+     * This allows you to start separate components of the channel <br>
+     * SND_TX_SEQ - starts or stops the data sender. This should not open any sockets,
+     * as sockets are opened on demand when a message is being sent
+     * @see #start(int)
+     * @see #stop(int)
+     */
+    public static final int SND_TX_SEQ = 2;
+
+    /**
+     * Start and stop sequences can be controlled by these constants
+     * This allows you to start separate components of the channel <br>
+     * MBR_RX_SEQ - starts or stops the membership listener. In a multicast implementation
+     * this will open a datagram socket and join a group and listen for membership messages
+     * members joining
+     * @see #start(int)
+     * @see #stop(int)
+     */
+    public static final int MBR_RX_SEQ = 4;
+
+    /**
+     * Start and stop sequences can be controlled by these constants
+     * This allows you to start separate components of the channel <br>
+     * MBR_TX_SEQ - starts or stops the membership broadcaster. In a multicast implementation
+     * this will open a datagram socket and join a group and broadcast the local member information
+     * @see #start(int)
+     * @see #stop(int)
+     */
+    public static final int MBR_TX_SEQ = 8;
+    
+    /**
+     * Send options, when a message is sent, it can have an option flag
+     * to trigger certain behavior. Most flags are used to trigger channel interceptors
+     * as the message passes through the channel stack. <br>
+     * However, there are five default flags that every channel implementation must implement<br>
+     * SEND_OPTIONS_BYTE_MESSAGE - The message is a pure byte message and no marshalling or unmarshalling will
+     * be performed.<br>
+     * 
+     * @see #send(Member[], Serializable , int)
+     * @see #send(Member[], Serializable, int, ErrorHandler)
+     */
+    public static final int SEND_OPTIONS_BYTE_MESSAGE = 0x0001;
+
+    /**
+     * Send options, when a message is sent, it can have an option flag
+     * to trigger certain behavior. Most flags are used to trigger channel interceptors
+     * as the message passes through the channel stack. <br>
+     * However, there are five default flags that every channel implementation must implement<br>
+     * SEND_OPTIONS_USE_ACK - Message is sent and an ACK is received when the message has been received by the recipient<br>
+     * If no ack is received, the message is not considered successful<br>
+     * @see #send(Member[], Serializable , int)
+     * @see #send(Member[], Serializable, int, ErrorHandler)
+     */
+    public static final int SEND_OPTIONS_USE_ACK = 0x0002;
+
+    /**
+     * Send options, when a message is sent, it can have an option flag
+     * to trigger certain behavior. Most flags are used to trigger channel interceptors
+     * as the message passes through the channel stack. <br>
+     * However, there are five default flags that every channel implementation must implement<br>
+     * SEND_OPTIONS_SYNCHRONIZED_ACK - Message is sent and an ACK is received when the message has been received and 
+     * processed by the recipient<br>
+     * If no ack is received, the message is not considered successful<br>
+     * @see #send(Member[], Serializable , int)
+     * @see #send(Member[], Serializable, int, ErrorHandler)
+     */
+    public static final int SEND_OPTIONS_SYNCHRONIZED_ACK = 0x0004;
+    
+    /**
+     * Send options, when a message is sent, it can have an option flag
+     * to trigger certain behavior. Most flags are used to trigger channel interceptors
+     * as the message passes through the channel stack. <br>
+     * However, there are five default flags that every channel implementation must implement<br>
+     * SEND_OPTIONS_ASYNCHRONOUS - Message is sent and an ACK is received when the message has been received and 
+     * processed by the recipient<br>
+     * If no ack is received, the message is not considered successful<br>
+     * @see #send(Member[], Serializable , int)
+     * @see #send(Member[], Serializable, int, ErrorHandler)
+     */
+    public static final int SEND_OPTIONS_ASYNCHRONOUS = 0x0008;
+    
+    /**
+     * Send options, when a message is sent, it can have an option flag
+     * to trigger certain behavior. Most flags are used to trigger channel interceptors
+     * as the message passes through the channel stack. <br>
+     * However, there are five default flags that every channel implementation must implement<br>
+     * SEND_OPTIONS_SECURE - Message is sent over an encrypted channel<br>
+     * @see #send(Member[], Serializable , int)
+     * @see #send(Member[], Serializable, int, ErrorHandler)
+     */
+    public static final int SEND_OPTIONS_SECURE = 0x0010;
+    
+
+    /**
+     * Send options, when a message is sent, it can have an option flag
+     * to trigger certain behavior. Most flags are used to trigger channel interceptors
+     * as the message passes through the channel stack. <br>
+     * However, there are five default flags that every channel implementation must implement<br>
+     * SEND_OPTIONS_DEFAULT - the default sending options, just a helper variable. <br>
+     * The default is <code>int SEND_OPTIONS_DEFAULT = SEND_OPTIONS_USE_ACK;</code><br>
+     * @see #SEND_OPTIONS_USE_ACK
+     * @see #send(Member[], Serializable , int)
+     * @see #send(Member[], Serializable, int, ErrorHandler)
+     */
+    public static final int SEND_OPTIONS_DEFAULT = SEND_OPTIONS_USE_ACK;
+
+    
+    /**
+     * Adds an interceptor to the channel message chain.
+     * @param interceptor ChannelInterceptor
+     */
+    public void addInterceptor(ChannelInterceptor interceptor);
+    
+    /**
+     * Starts up the channel. This can be called multiple times for individual services to start
+     * The svc parameter can be the logical or value of any constants
+     * @param svc int value of <BR>
+     * DEFAULT - will start all services <BR>
+     * MBR_RX_SEQ - starts the membership receiver <BR>
+     * MBR_TX_SEQ - starts the membership broadcaster <BR>
+     * SND_TX_SEQ - starts the replication transmitter<BR>
+     * SND_RX_SEQ - starts the replication receiver<BR>
+     * <b>Note:</b> In order for the membership broadcaster to 
+     * transmit the correct information, it has to be started after the replication receiver.
+     * @throws ChannelException if a startup error occurs or the service is already started or an error occurs.
+     */
+    public void start(int svc) throws ChannelException;
+
+    /**
+     * Shuts down the channel. This can be called multiple times for individual services to shutdown
+     * The svc parameter can be the logical or value of any constants
+     * @param svc int value of <BR>
+     * DEFAULT - will shutdown all services <BR>
+     * MBR_RX_SEQ - stops the membership receiver <BR>
+     * MBR_TX_SEQ - stops the membership broadcaster <BR>
+     * SND_TX_SEQ - stops the replication transmitter<BR>
+     * SND_RX_SEQ - stops the replication receiver<BR>
+     * @throws ChannelException if a startup error occurs or the service is already stopped or an error occurs.
+     */
+    public void stop(int svc) throws ChannelException;    
+    
+    /**
+     * Send a message to one or more members in the cluster
+     * @param destination Member[] - the destinations, can not be null or zero length, the reason for that
+     * is that a membership change can occur and at that time the application is uncertain what group the message
+     * actually got sent to.
+     * @param msg Serializable - the message to send, has to be serializable, or a <code>ByteMessage</code> to 
+     * send a pure byte array
+     * @param options int - sender options, see class documentation for each interceptor that is configured in order to trigger interceptors
+     * @return a unique Id that identifies the message that is sent
+     * @see ByteMessage
+     * @see #SEND_OPTIONS_USE_ACK
+     * @see #SEND_OPTIONS_ASYNCHRONOUS
+     * @see #SEND_OPTIONS_SYNCHRONIZED_ACK
+     */
+    public UniqueId send(Member[] destination, Serializable msg, int options) throws ChannelException;
+
+    /**
+     * Send a message to one or more members in the cluster
+     * @param destination Member[] - the destinations, null or zero length means all
+     * @param msg ClusterMessage - the message to send
+     * @param options int - sender options, see class documentation
+     * @param handler ErrorHandler - handle errors through a callback, rather than throw it
+     * @return a unique Id that identifies the message that is sent
+     * @exception ChannelException - if a serialization error happens.
+     */
+    public UniqueId send(Member[] destination, Serializable msg, int options, ErrorHandler handler) throws ChannelException;
+    
+    /**
+     * Sends a heart beat through the interceptor stacks
+     * Use this method to alert interceptors and other components to 
+     * clean up garbage, timed out messages etc.<br>
+     * If you application has a background thread, then you can save one thread,
+     * by configuring your channel to not use an internal heartbeat thread
+     * and invoking this method.
+     * @see #setHeartbeat(boolean)
+     */
+    public void heartbeat();
+    
+    /**
+     * Enables or disables internal heartbeat.
+     * @param enable boolean - default value is implementation specific
+     * @see #heartbeat()
+     */
+    public void setHeartbeat(boolean enable);
+    
+    /**
+     * Add a membership listener, will get notified when a new member joins, leaves or crashes
+     * <br>If the membership listener implements the Heartbeat interface
+     * the <code>heartbeat()</code> method will be invoked when the heartbeat runs on the channel
+     * @param listener MembershipListener
+     * @see MembershipListener
+     */
+    public void addMembershipListener(MembershipListener listener);
+    
+    /**
+     * Add a channel listener, this is a callback object when messages are received
+     * <br>If the channel listener implements the Heartbeat interface
+     * the <code>heartbeat()</code> method will be invoked when the heartbeat runs on the channel
+     * @param listener ChannelListener
+     * @see ChannelListener
+     * @see Heartbeat
+     */
+    public void addChannelListener(ChannelListener listener);
+
+    /**
+     * remove a membership listener, listeners are removed based on Object.hashCode and Object.equals
+     * @param listener MembershipListener
+     * @see MembershipListener
+     */
+    public void removeMembershipListener(MembershipListener listener);
+    /**
+     * remove a channel listener, listeners are removed based on Object.hashCode and Object.equals
+     * @param listener ChannelListener
+     * @see ChannelListener
+     */
+    public void removeChannelListener(ChannelListener listener);
+    
+    /**
+     * Returns true if there are any members in the group,
+     * this call is the same as <code>getMembers().length>0</code>
+     * @return boolean - true if there are any members automatically discovered
+     */
+    public boolean hasMembers() ;
+
+    /**
+     * Get all current group members
+     * @return all members or empty array, never null 
+     */
+    public Member[] getMembers() ;
+
+    /**
+     * Return the member that represents this node. This is also the data
+     * that gets broadcasted through the membership broadcaster component
+     * @param incAlive - optimization, true if you want it to calculate alive time
+     * since the membership service started.
+     * @return Member
+     */
+    public Member getLocalMember(boolean incAlive);
+    
+    /**
+     * Returns the member from the membership service with complete and 
+     * recent data. Some implementations might serialize and send 
+     * membership information along with a message, and instead of sending
+     * complete membership details, only send the primary identifier for the member
+     * but not the payload or other information. When such message is received
+     * the application can retrieve the cached member through this call.<br>
+     * In most cases, this is not necessary.
+     * @param mbr Member
+     * @return Member
+     */
+    public Member getMember(Member mbr);
+
+    
+}

==================================================
ChannelInterceptor.java
index 7d5f04c8c3..d7a885f6ab 100644
--- a/java/org/apache/catalina/tribes/ChannelException.java
+++ b/java/org/apache/catalina/tribes/ChannelException.java
@@ -1,161 +1,162 @@
-/*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes;
-
-import java.util.ArrayList;
-
-/**
- * Channel Exception<br>
- * A channel exception is thrown when an internal error happens
- * somewhere in the channel. <br>
- * When a global error happens, the cause can be retrieved using <code>getCause()</code><br><br>
- * If an application is sending a message and some of the recipients fail to receive it,
- * the application can retrieve what recipients failed by using the <code>getFaultyMembers()</code>
- * method. This way, an application will always know if a message was delivered successfully or not.
- * @author Filip Hanik
- * @version $Revision: 304032 $, $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
- */
-
-public class ChannelException extends Exception {
-    /*
-     * Holds a list of faulty members
-     */
-    private ArrayList faultyMembers=null;
-    
-    /**
-     * Constructor, creates a ChannelException
-     * @see java.lang.Exception#Exception()
-     */
-    public ChannelException() {
-        super();
-    }
-
-    /**
-     * Constructor, creates a ChannelException with an error message
-     * @see java.lang.Exception#Exception(String)
-     */
-    public ChannelException(String message) {
-        super(message);
-    }
-
-    /**
-     * Constructor, creates a ChannelException with an error message and a cause
-     * @param message String
-     * @param cause Throwable
-     * @see java.lang.Exception#Exception(String,Throwable)
-     */
-    public ChannelException(String message, Throwable cause) {
-        super(message, cause);
-    }
-
-    /**
-     * Constructor, creates a ChannelException with a cause
-     * @param cause Throwable
-     * @see java.lang.Exception#Exception(Throwable)
-     */
-    public ChannelException(Throwable cause) {
-        super(cause);
-    }
-    
-    /**
-     * Returns the message for this exception
-     * @return String
-     * @see java.lang.Exception#getMessage()
-     */
-    public String getMessage() {
-        StringBuffer buf = new StringBuffer(super.getMessage());
-        if (faultyMembers==null || faultyMembers.size() == 0 ) {
-            buf.append("; No faulty members identified.");
-        } else {
-            buf.append("; Faulty members:");
-            for ( int i=0; i<faultyMembers.size(); i++ ) {
-                FaultyMember mbr = (FaultyMember)faultyMembers.get(i);
-                buf.append(mbr.getMember().getName());
-                buf.append("; ");
-            }
-        }
-        return buf.toString();
-    }
-    
-    /**
-     * Adds a faulty member, and the reason the member failed.
-     * @param mbr Member
-     * @param x Exception
-     */
-    public void addFaultyMember(Member mbr, Exception x ) {
-        addFaultyMember(new FaultyMember(mbr,x));
-    }
-    
-    /**
-     * Adds a list of faulty members
-     * @param mbrs FaultyMember[]
-     */
-    public void addFaultyMember(FaultyMember[] mbrs) {
-        for (int i=0; mbrs!=null && i<mbrs.length; i++ ) {
-            addFaultyMember(mbrs[i]);
-        }
-    }
-
-    /**
-     * Adds a faulty member
-     * @param mbr FaultyMember
-     */
-    public void addFaultyMember(FaultyMember mbr) {
-        if ( this.faultyMembers==null ) this.faultyMembers = new ArrayList();
-        faultyMembers.add(mbr);
-    }
-    
-    /**
-     * Returns an array of members that failed and the reason they failed.
-     * @return FaultyMember[]
-     */
-    public FaultyMember[] getFaultyMembers() {
-        if ( this.faultyMembers==null ) return new FaultyMember[0];
-        return (FaultyMember[])faultyMembers.toArray(new FaultyMember[faultyMembers.size()]);
-    }
-    
-    /**
-     * 
-     * <p>Title: FaultyMember class</p> 
-     * 
-     * <p>Description: Represent a failure to a specific member when a message was sent
-     * to more than one member</p> 
-     * 
-     * @author Filip Hanik
-     * @version 1.0
-     */
-    public static class FaultyMember {
-        protected Exception cause;
-        protected Member member;
-        public FaultyMember(Member mbr, Exception x) { 
-            this.member = mbr;
-            this.cause = x;
-        }
-        
-        public Member getMember() {
-            return member;
-        }
-        
-        public Exception getCause() {
-            return cause;
-        }
-        
-        public String toString() {
-            return "FaultyMember:"+member.toString();
-        }
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes;
+
+import java.util.ArrayList;
+
+/**
+ * Channel Exception<br>
+ * A channel exception is thrown when an internal error happens
+ * somewhere in the channel. <br>
+ * When a global error happens, the cause can be retrieved using <code>getCause()</code><br><br>
+ * If an application is sending a message and some of the recipients fail to receive it,
+ * the application can retrieve what recipients failed by using the <code>getFaultyMembers()</code>
+ * method. This way, an application will always know if a message was delivered successfully or not.
+ * @author Filip Hanik
+ * @version $Revision: 304032 $, $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
+ */
+
+public class ChannelException extends Exception {
+    /*
+     * Holds a list of faulty members
+     */
+    private ArrayList faultyMembers=null;
+    
+    /**
+     * Constructor, creates a ChannelException
+     * @see java.lang.Exception#Exception()
+     */
+    public ChannelException() {
+        super();
+    }
+
+    /**
+     * Constructor, creates a ChannelException with an error message
+     * @see java.lang.Exception#Exception(String)
+     */
+    public ChannelException(String message) {
+        super(message);
+    }
+
+    /**
+     * Constructor, creates a ChannelException with an error message and a cause
+     * @param message String
+     * @param cause Throwable
+     * @see java.lang.Exception#Exception(String,Throwable)
+     */
+    public ChannelException(String message, Throwable cause) {
+        super(message, cause);
+    }
+
+    /**
+     * Constructor, creates a ChannelException with a cause
+     * @param cause Throwable
+     * @see java.lang.Exception#Exception(Throwable)
+     */
+    public ChannelException(Throwable cause) {
+        super(cause);
+    }
+    
+    /**
+     * Returns the message for this exception
+     * @return String
+     * @see java.lang.Exception#getMessage()
+     */
+    public String getMessage() {
+        StringBuffer buf = new StringBuffer(super.getMessage());
+        if (faultyMembers==null || faultyMembers.size() == 0 ) {
+            buf.append("; No faulty members identified.");
+        } else {
+            buf.append("; Faulty members:");
+            for ( int i=0; i<faultyMembers.size(); i++ ) {
+                FaultyMember mbr = (FaultyMember)faultyMembers.get(i);
+                buf.append(mbr.getMember().getName());
+                buf.append("; ");
+            }
+        }
+        return buf.toString();
+    }
+    
+    /**
+     * Adds a faulty member, and the reason the member failed.
+     * @param mbr Member
+     * @param x Exception
+     */
+    public void addFaultyMember(Member mbr, Exception x ) {
+        addFaultyMember(new FaultyMember(mbr,x));
+    }
+    
+    /**
+     * Adds a list of faulty members
+     * @param mbrs FaultyMember[]
+     */
+    public void addFaultyMember(FaultyMember[] mbrs) {
+        for (int i=0; mbrs!=null && i<mbrs.length; i++ ) {
+            addFaultyMember(mbrs[i]);
+        }
+    }
+
+    /**
+     * Adds a faulty member
+     * @param mbr FaultyMember
+     */
+    public void addFaultyMember(FaultyMember mbr) {
+        if ( this.faultyMembers==null ) this.faultyMembers = new ArrayList();
+        faultyMembers.add(mbr);
+    }
+    
+    /**
+     * Returns an array of members that failed and the reason they failed.
+     * @return FaultyMember[]
+     */
+    public FaultyMember[] getFaultyMembers() {
+        if ( this.faultyMembers==null ) return new FaultyMember[0];
+        return (FaultyMember[])faultyMembers.toArray(new FaultyMember[faultyMembers.size()]);
+    }
+    
+    /**
+     * 
+     * <p>Title: FaultyMember class</p> 
+     * 
+     * <p>Description: Represent a failure to a specific member when a message was sent
+     * to more than one member</p> 
+     * 
+     * @author Filip Hanik
+     * @version 1.0
+     */
+    public static class FaultyMember {
+        protected Exception cause;
+        protected Member member;
+        public FaultyMember(Member mbr, Exception x) { 
+            this.member = mbr;
+            this.cause = x;
+        }
+        
+        public Member getMember() {
+            return member;
+        }
+        
+        public Exception getCause() {
+            return cause;
+        }
+        
+        public String toString() {
+            return "FaultyMember:"+member.toString();
+        }
+    }
+
+}

==================================================
ChannelListener.java
index 14b8f11606..b457ef122f 100644
--- a/java/org/apache/catalina/tribes/ChannelInterceptor.java
+++ b/java/org/apache/catalina/tribes/ChannelInterceptor.java
@@ -1,179 +1,180 @@
-/*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes;
-
-import org.apache.catalina.tribes.group.InterceptorPayload;
-
-/**
- * A ChannelInterceptor is an interceptor that intercepts 
- * messages and membership messages in the channel stack.
- * This allows interceptors to modify the message or perform
- * other actions when a message is sent or received.<br>
- * Interceptors are tied together in a linked list.
- * @see org.apache.catalina.tribes.group.ChannelInterceptorBase
- * @author Filip Hanik
- * @version $Revision: 304032 $, $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
- */   
-
-public interface ChannelInterceptor extends MembershipListener, Heartbeat {
-
-    /**
-     * An interceptor can react to a message based on a set bit on the 
-     * message options. <br>
-     * When a message is sent, the options can be retrieved from ChannelMessage.getOptions()
-     * and if the bit is set, this interceptor will react to it.<br>
-     * A simple evaluation if an interceptor should react to the message would be:<br>
-     * <code>boolean react = (getOptionFlag() == (getOptionFlag() & ChannelMessage.getOptions()));</code><br>
-     * The default option is 0, meaning there is no way for the application to trigger the
-     * interceptor. The interceptor itself will decide.<br>
-     * @return int
-     * @see ChannelMessage#getOptions()
-     */
-    public int getOptionFlag();
-    
-    /**
-     * Sets the option flag
-     * @param flag int
-     * @see #getOptionFlag()
-     */
-    public void setOptionFlag(int flag);
-
-    /**
-     * Set the next interceptor in the list of interceptors
-     * @param next ChannelInterceptor
-     */
-    public void setNext(ChannelInterceptor next) ;
-
-    /**
-     * Retrieve the next interceptor in the list
-     * @return ChannelInterceptor - returns the next interceptor in the list or null if no more interceptors exist
-     */
-    public ChannelInterceptor getNext();
-
-    /**
-     * Set the previous interceptor in the list
-     * @param previous ChannelInterceptor
-     */
-    public void setPrevious(ChannelInterceptor previous);
-
-    /**
-     * Retrieve the previous interceptor in the list
-     * @return ChannelInterceptor - returns the previous interceptor in the list or null if no more interceptors exist
-     */
-    public ChannelInterceptor getPrevious();
-
-    /**
-     * The <code>sendMessage</code> method is called when a message is being sent to one more destinations.
-     * The interceptor can modify any of the parameters and then pass on the message down the stack by
-     * invoking <code>getNext().sendMessage(destination,msg,payload)</code><br>
-     * Alternatively the interceptor can stop the message from being sent by not invoking 
-     * <code>getNext().sendMessage(destination,msg,payload)</code><br>
-     * If the message is to be sent asynchronous the application can be notified of completion and 
-     * errors by passing in an error handler attached to a payload object.<br>
-     * The ChannelMessage.getAddress contains Channel.getLocalMember, and can be overwritten 
-     * to simulate a message sent from another node.<br>
-     * @param destination Member[] - the destination for this message
-     * @param msg ChannelMessage - the message to be sent
-     * @param payload InterceptorPayload - the payload, carrying an error handler and future useful data, can be null
-     * @throws ChannelException
-     * @see ErrorHandler
-     * @see InterceptorPayload
-     */
-    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException;
-    
-    /**
-     * the <code>messageReceived</code> is invoked when a message is received.
-     * <code>ChannelMessage.getAddress()</code> is the sender, or the reply-to address
-     * if it has been overwritten.
-     * @param data ChannelMessage
-     */
-    public void messageReceived(ChannelMessage data);
-    
-    /**
-     * The <code>heartbeat()</code> method gets invoked periodically
-     * to allow interceptors to clean up resources, time out object and 
-     * perform actions that are unrelated to sending/receiving data.
-     */
-    public void heartbeat();
-    
-    /**
-     * Intercepts the <code>Channel.hasMembers()</code> method
-     * @return boolean - if the channel has members in its membership group
-     * @see Channel#hasMembers()
-     */
-    public boolean hasMembers() ;
-
-    /**
-     * Intercepts the code>Channel.getMembers()</code> method
-     * @return Member[]
-     * @see Channel#getMembers()
-     */
-    public Member[] getMembers() ;
-
-    /**
-     * Intercepts the code>Channel.getLocalMember(boolean)</code> method
-     * @param incAliveTime boolean
-     * @return Member
-     * @see Channel#getLocalMember(boolean)
-     */
-    public Member getLocalMember(boolean incAliveTime) ;
-
-    /**
-     * Intercepts the code>Channel.getMember(Member)</code> method
-     * @param mbr Member
-     * @return Member - the actual member information, including stay alive
-     * @see Channel#getMember(Member)
-     */
-    public Member getMember(Member mbr);
-    
-    /**
-     * Starts up the channel. This can be called multiple times for individual services to start
-     * The svc parameter can be the logical or value of any constants
-     * @param svc int value of <BR>
-     * Channel.DEFAULT - will start all services <BR>
-     * Channel.MBR_RX_SEQ - starts the membership receiver <BR>
-     * Channel.MBR_TX_SEQ - starts the membership broadcaster <BR>
-     * Channel.SND_TX_SEQ - starts the replication transmitter<BR>
-     * Channel.SND_RX_SEQ - starts the replication receiver<BR>
-     * @throws ChannelException if a startup error occurs or the service is already started.
-     * @see Channel
-     */
-    public void start(int svc) throws ChannelException;
-
-    /**
-     * Shuts down the channel. This can be called multiple times for individual services to shutdown
-     * The svc parameter can be the logical or value of any constants
-     * @param svc int value of <BR>
-     * Channel.DEFAULT - will shutdown all services <BR>
-     * Channel.MBR_RX_SEQ - stops the membership receiver <BR>
-     * Channel.MBR_TX_SEQ - stops the membership broadcaster <BR>
-     * Channel.SND_TX_SEQ - stops the replication transmitter<BR>
-     * Channel.SND_RX_SEQ - stops the replication receiver<BR>
-     * @throws ChannelException if a startup error occurs or the service is already started.
-     * @see Channel
-     */
-    public void stop(int svc) throws ChannelException;
-    
-    public void fireInterceptorEvent(InterceptorEvent event);
-
-    interface InterceptorEvent {
-        int getEventType();
-        String getEventTypeDesc();
-        ChannelInterceptor getInterceptor();
-    }
-    
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes;
+
+import org.apache.catalina.tribes.group.InterceptorPayload;
+
+/**
+ * A ChannelInterceptor is an interceptor that intercepts 
+ * messages and membership messages in the channel stack.
+ * This allows interceptors to modify the message or perform
+ * other actions when a message is sent or received.<br>
+ * Interceptors are tied together in a linked list.
+ * @see org.apache.catalina.tribes.group.ChannelInterceptorBase
+ * @author Filip Hanik
+ * @version $Revision: 304032 $, $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
+ */   
+
+public interface ChannelInterceptor extends MembershipListener, Heartbeat {
+
+    /**
+     * An interceptor can react to a message based on a set bit on the 
+     * message options. <br>
+     * When a message is sent, the options can be retrieved from ChannelMessage.getOptions()
+     * and if the bit is set, this interceptor will react to it.<br>
+     * A simple evaluation if an interceptor should react to the message would be:<br>
+     * <code>boolean react = (getOptionFlag() == (getOptionFlag() & ChannelMessage.getOptions()));</code><br>
+     * The default option is 0, meaning there is no way for the application to trigger the
+     * interceptor. The interceptor itself will decide.<br>
+     * @return int
+     * @see ChannelMessage#getOptions()
+     */
+    public int getOptionFlag();
+    
+    /**
+     * Sets the option flag
+     * @param flag int
+     * @see #getOptionFlag()
+     */
+    public void setOptionFlag(int flag);
+
+    /**
+     * Set the next interceptor in the list of interceptors
+     * @param next ChannelInterceptor
+     */
+    public void setNext(ChannelInterceptor next) ;
+
+    /**
+     * Retrieve the next interceptor in the list
+     * @return ChannelInterceptor - returns the next interceptor in the list or null if no more interceptors exist
+     */
+    public ChannelInterceptor getNext();
+
+    /**
+     * Set the previous interceptor in the list
+     * @param previous ChannelInterceptor
+     */
+    public void setPrevious(ChannelInterceptor previous);
+
+    /**
+     * Retrieve the previous interceptor in the list
+     * @return ChannelInterceptor - returns the previous interceptor in the list or null if no more interceptors exist
+     */
+    public ChannelInterceptor getPrevious();
+
+    /**
+     * The <code>sendMessage</code> method is called when a message is being sent to one more destinations.
+     * The interceptor can modify any of the parameters and then pass on the message down the stack by
+     * invoking <code>getNext().sendMessage(destination,msg,payload)</code><br>
+     * Alternatively the interceptor can stop the message from being sent by not invoking 
+     * <code>getNext().sendMessage(destination,msg,payload)</code><br>
+     * If the message is to be sent asynchronous the application can be notified of completion and 
+     * errors by passing in an error handler attached to a payload object.<br>
+     * The ChannelMessage.getAddress contains Channel.getLocalMember, and can be overwritten 
+     * to simulate a message sent from another node.<br>
+     * @param destination Member[] - the destination for this message
+     * @param msg ChannelMessage - the message to be sent
+     * @param payload InterceptorPayload - the payload, carrying an error handler and future useful data, can be null
+     * @throws ChannelException
+     * @see ErrorHandler
+     * @see InterceptorPayload
+     */
+    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException;
+    
+    /**
+     * the <code>messageReceived</code> is invoked when a message is received.
+     * <code>ChannelMessage.getAddress()</code> is the sender, or the reply-to address
+     * if it has been overwritten.
+     * @param data ChannelMessage
+     */
+    public void messageReceived(ChannelMessage data);
+    
+    /**
+     * The <code>heartbeat()</code> method gets invoked periodically
+     * to allow interceptors to clean up resources, time out object and 
+     * perform actions that are unrelated to sending/receiving data.
+     */
+    public void heartbeat();
+    
+    /**
+     * Intercepts the <code>Channel.hasMembers()</code> method
+     * @return boolean - if the channel has members in its membership group
+     * @see Channel#hasMembers()
+     */
+    public boolean hasMembers() ;
+
+    /**
+     * Intercepts the code>Channel.getMembers()</code> method
+     * @return Member[]
+     * @see Channel#getMembers()
+     */
+    public Member[] getMembers() ;
+
+    /**
+     * Intercepts the code>Channel.getLocalMember(boolean)</code> method
+     * @param incAliveTime boolean
+     * @return Member
+     * @see Channel#getLocalMember(boolean)
+     */
+    public Member getLocalMember(boolean incAliveTime) ;
+
+    /**
+     * Intercepts the code>Channel.getMember(Member)</code> method
+     * @param mbr Member
+     * @return Member - the actual member information, including stay alive
+     * @see Channel#getMember(Member)
+     */
+    public Member getMember(Member mbr);
+    
+    /**
+     * Starts up the channel. This can be called multiple times for individual services to start
+     * The svc parameter can be the logical or value of any constants
+     * @param svc int value of <BR>
+     * Channel.DEFAULT - will start all services <BR>
+     * Channel.MBR_RX_SEQ - starts the membership receiver <BR>
+     * Channel.MBR_TX_SEQ - starts the membership broadcaster <BR>
+     * Channel.SND_TX_SEQ - starts the replication transmitter<BR>
+     * Channel.SND_RX_SEQ - starts the replication receiver<BR>
+     * @throws ChannelException if a startup error occurs or the service is already started.
+     * @see Channel
+     */
+    public void start(int svc) throws ChannelException;
+
+    /**
+     * Shuts down the channel. This can be called multiple times for individual services to shutdown
+     * The svc parameter can be the logical or value of any constants
+     * @param svc int value of <BR>
+     * Channel.DEFAULT - will shutdown all services <BR>
+     * Channel.MBR_RX_SEQ - stops the membership receiver <BR>
+     * Channel.MBR_TX_SEQ - stops the membership broadcaster <BR>
+     * Channel.SND_TX_SEQ - stops the replication transmitter<BR>
+     * Channel.SND_RX_SEQ - stops the replication receiver<BR>
+     * @throws ChannelException if a startup error occurs or the service is already started.
+     * @see Channel
+     */
+    public void stop(int svc) throws ChannelException;
+    
+    public void fireInterceptorEvent(InterceptorEvent event);
+
+    interface InterceptorEvent {
+        int getEventType();
+        String getEventTypeDesc();
+        ChannelInterceptor getInterceptor();
+    }
+    
+
+}

==================================================
ChannelMessage.java
index 97819b6679..ad29211a0f 100644
--- a/java/org/apache/catalina/tribes/ChannelListener.java
+++ b/java/org/apache/catalina/tribes/ChannelListener.java
@@ -1,67 +1,68 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes;
-
-import java.io.Serializable;
-/**
- * 
- * <p>Title: ChannelListener</p> 
- * 
- * <p>Description: An interface to listens to incoming messages from a channel </p> 
- * When a message is received, the Channel will invoke the channel listener in a conditional sequence.
- * <code>if ( listener.accept(msg,sender) ) listener.messageReceived(msg,sender);</code><br>
- * A ChannelListener implementation MUST NOT return true on <code>accept(Serializable, Member)</code>
- * if it doesn't intend to process the message. The channel can this way track whether a message
- * was processed by an above application or if it was just received and forgot about, a featuer required
- * to support message-response(RPC) calls<br>
- * 
- * @author Filip Hanik
- * @version 1.0
- */
-
-public interface ChannelListener {
-
-    /**
-     * Receive a message from the channel
-     * @param msg Serializable
-     * @param sender - the source of the message
-     */
-    public void messageReceived(Serializable msg, Member sender);
-
-    /**
-     * Invoked by the channel to determine if the listener will process this message or not.
-     * @param msg Serializable
-     * @param sender Member
-     * @return boolean
-     */
-    public boolean accept(Serializable msg, Member sender);
-
-    /**
-     * 
-     * @param listener Object
-     * @return boolean
-     * @see Object#equals(Object)
-     */
-    public boolean equals(Object listener);
-
-    /**
-     * 
-     * @return int
-     * @see Object#hashCode(int)
-     */
-    public int hashCode();
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes;
+
+import java.io.Serializable;
+/**
+ * 
+ * <p>Title: ChannelListener</p> 
+ * 
+ * <p>Description: An interface to listens to incoming messages from a channel </p> 
+ * When a message is received, the Channel will invoke the channel listener in a conditional sequence.
+ * <code>if ( listener.accept(msg,sender) ) listener.messageReceived(msg,sender);</code><br>
+ * A ChannelListener implementation MUST NOT return true on <code>accept(Serializable, Member)</code>
+ * if it doesn't intend to process the message. The channel can this way track whether a message
+ * was processed by an above application or if it was just received and forgot about, a featuer required
+ * to support message-response(RPC) calls<br>
+ * 
+ * @author Filip Hanik
+ * @version 1.0
+ */
+
+public interface ChannelListener {
+
+    /**
+     * Receive a message from the channel
+     * @param msg Serializable
+     * @param sender - the source of the message
+     */
+    public void messageReceived(Serializable msg, Member sender);
+
+    /**
+     * Invoked by the channel to determine if the listener will process this message or not.
+     * @param msg Serializable
+     * @param sender Member
+     * @return boolean
+     */
+    public boolean accept(Serializable msg, Member sender);
+
+    /**
+     * 
+     * @param listener Object
+     * @return boolean
+     * @see Object#equals(Object)
+     */
+    public boolean equals(Object listener);
+
+    /**
+     * 
+     * @return int
+     * @see Object#hashCode(int)
+     */
+    public int hashCode();
+
+}

==================================================
ChannelReceiver.java
index 21a434b083..98a438cbbf 100644
--- a/java/org/apache/catalina/tribes/ChannelMessage.java
+++ b/java/org/apache/catalina/tribes/ChannelMessage.java
@@ -1,108 +1,109 @@
-/*
- * Copyright 1999,2005 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes;
-
-import java.io.Serializable;
-import org.apache.catalina.tribes.io.XByteBuffer;
-
-/**
- * Message that is passed through the interceptor stack after the 
- * data serialized in the Channel object and then passed down to the 
- * interceptor and eventually down to the ChannelSender component
- * @author Filip Hanik
- * 
- */
-public interface ChannelMessage extends Serializable {
-    
-    
-    
-    
-    /**
-     * Get the address that this message originated from.  
-     * Almost always <code>Channel.getLocalMember(boolean)</code><br>
-     * This would be set to a different address 
-     * if the message was being relayed from a host other than the one
-     * that originally sent it.
-     * @return the source or reply-to address of this message
-     */
-    public Member getAddress();
-
-    /**
-     * Sets the source or reply-to address of this message
-     * @param member Member
-     */
-    public void setAddress(Member member);
-
-    /**
-     * Timestamp of when the message was created.
-     * @return long timestamp in milliseconds
-     */
-    public long getTimestamp();
-
-    /**
-     *
-     * Sets the timestamp of this message
-     * @param timestamp The timestamp
-     */
-    public void setTimestamp(long timestamp);
-
-    /**
-     * Each message must have a globally unique Id.
-     * interceptors heavily depend on this id for message processing
-     * @return byte
-     */
-    public byte[] getUniqueId();
-    
-    /**
-     * The byte buffer that contains the actual message payload
-     * @param buf XByteBuffer
-     */
-    public void setMessage(XByteBuffer buf);
-    
-    /**
-     * returns the byte buffer that contains the actual message payload
-     * @return XByteBuffer
-     */
-    public XByteBuffer getMessage();
-    
-    /**
-     * The message options is a 32 bit flag set
-     * that triggers interceptors and message behavior.
-     * @see Channel#send(Member[], Serializable, int) 
-     * @see ChannelInterceptor#getOptionFlag
-     * @return int - the option bits set for this message
-     */
-    public int getOptions();
-    
-    /**
-     * sets the option bits for this message
-     * @param options int
-     * @see #getOptions()
-     */
-    public void setOptions(int options);
-    
-    /**
-     * Shallow clone, what gets cloned depends on the implementation
-     * @return ChannelMessage
-     */
-    public Object clone();
-
-    /**
-     * Deep clone, all fields MUST get cloned
-     * @return ChannelMessage
-     */
-    public Object deepclone();
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes;
+
+import java.io.Serializable;
+import org.apache.catalina.tribes.io.XByteBuffer;
+
+/**
+ * Message that is passed through the interceptor stack after the 
+ * data serialized in the Channel object and then passed down to the 
+ * interceptor and eventually down to the ChannelSender component
+ * @author Filip Hanik
+ * 
+ */
+public interface ChannelMessage extends Serializable {
+    
+    
+    
+    
+    /**
+     * Get the address that this message originated from.  
+     * Almost always <code>Channel.getLocalMember(boolean)</code><br>
+     * This would be set to a different address 
+     * if the message was being relayed from a host other than the one
+     * that originally sent it.
+     * @return the source or reply-to address of this message
+     */
+    public Member getAddress();
+
+    /**
+     * Sets the source or reply-to address of this message
+     * @param member Member
+     */
+    public void setAddress(Member member);
+
+    /**
+     * Timestamp of when the message was created.
+     * @return long timestamp in milliseconds
+     */
+    public long getTimestamp();
+
+    /**
+     *
+     * Sets the timestamp of this message
+     * @param timestamp The timestamp
+     */
+    public void setTimestamp(long timestamp);
+
+    /**
+     * Each message must have a globally unique Id.
+     * interceptors heavily depend on this id for message processing
+     * @return byte
+     */
+    public byte[] getUniqueId();
+    
+    /**
+     * The byte buffer that contains the actual message payload
+     * @param buf XByteBuffer
+     */
+    public void setMessage(XByteBuffer buf);
+    
+    /**
+     * returns the byte buffer that contains the actual message payload
+     * @return XByteBuffer
+     */
+    public XByteBuffer getMessage();
+    
+    /**
+     * The message options is a 32 bit flag set
+     * that triggers interceptors and message behavior.
+     * @see Channel#send(Member[], Serializable, int) 
+     * @see ChannelInterceptor#getOptionFlag
+     * @return int - the option bits set for this message
+     */
+    public int getOptions();
+    
+    /**
+     * sets the option bits for this message
+     * @param options int
+     * @see #getOptions()
+     */
+    public void setOptions(int options);
+    
+    /**
+     * Shallow clone, what gets cloned depends on the implementation
+     * @return ChannelMessage
+     */
+    public Object clone();
+
+    /**
+     * Deep clone, all fields MUST get cloned
+     * @return ChannelMessage
+     */
+    public Object deepclone();
+}

==================================================
ChannelSender.java
index 2c7eea8fec..3aaae9cd90 100644
--- a/java/org/apache/catalina/tribes/ChannelReceiver.java
+++ b/java/org/apache/catalina/tribes/ChannelReceiver.java
@@ -1,74 +1,75 @@
-/*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes;
-
-
-/**
- * ChannelReceiver Interface<br>
- * The <code>ChannelReceiver</code> interface is the data receiver component 
- * at the bottom layer, the IO layer (for layers see the javadoc for the {@link Channel} interface).
- * This class may optionally implement a thread pool for parallel processing of incoming messages.
- * @author Filip Hanik
- * @version $Revision: 379904 $, $Date: 2006-02-22 15:16:25 -0600 (Wed, 22 Feb 2006) $
- */
-public interface ChannelReceiver extends Heartbeat {
-    /**
-     * Start listening for incoming messages on the host/port
-     * @throws java.io.IOException
-     */
-    public void start() throws java.io.IOException;
-
-    /**
-     * Stop listening for messages
-     */
-    public void stop();
-
-    /**
-     * String representation of the IPv4 or IPv6 address that this host is listening
-     * to.
-     * @return the host that this receiver is listening to
-     */
-    public String getHost();
-    
-    
-    /**
-     * Returns the listening port
-     * @return port
-     */
-    public int getPort();
-    
-    /**
-     * Returns the secure listening port
-     * @return port, -1 if a secure port is not activated
-     */
-    public int getSecurePort();
-    
-    /**
-     * Sets the message listener to receive notification of incoming
-     * @param listener MessageListener
-     * @see MessageListener
-     */
-    public void setMessageListener(MessageListener listener);
-    
-    /**
-     * Returns the message listener that is associated with this receiver
-     * @return MessageListener
-     * @see MessageListener
-     */
-    public MessageListener getMessageListener();
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes;
+
+
+/**
+ * ChannelReceiver Interface<br>
+ * The <code>ChannelReceiver</code> interface is the data receiver component 
+ * at the bottom layer, the IO layer (for layers see the javadoc for the {@link Channel} interface).
+ * This class may optionally implement a thread pool for parallel processing of incoming messages.
+ * @author Filip Hanik
+ * @version $Revision: 379904 $, $Date: 2006-02-22 15:16:25 -0600 (Wed, 22 Feb 2006) $
+ */
+public interface ChannelReceiver extends Heartbeat {
+    /**
+     * Start listening for incoming messages on the host/port
+     * @throws java.io.IOException
+     */
+    public void start() throws java.io.IOException;
+
+    /**
+     * Stop listening for messages
+     */
+    public void stop();
+
+    /**
+     * String representation of the IPv4 or IPv6 address that this host is listening
+     * to.
+     * @return the host that this receiver is listening to
+     */
+    public String getHost();
+    
+    
+    /**
+     * Returns the listening port
+     * @return port
+     */
+    public int getPort();
+    
+    /**
+     * Returns the secure listening port
+     * @return port, -1 if a secure port is not activated
+     */
+    public int getSecurePort();
+    
+    /**
+     * Sets the message listener to receive notification of incoming
+     * @param listener MessageListener
+     * @see MessageListener
+     */
+    public void setMessageListener(MessageListener listener);
+    
+    /**
+     * Returns the message listener that is associated with this receiver
+     * @return MessageListener
+     * @see MessageListener
+     */
+    public MessageListener getMessageListener();
+
+}

==================================================
Constants.java
index fd245e130e..1dea5f8d67 100644
--- a/java/org/apache/catalina/tribes/ChannelSender.java
+++ b/java/org/apache/catalina/tribes/ChannelSender.java
@@ -1,68 +1,69 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes;
-
-
-/**
- * ChannelReceiver Interface<br>
- * The <code>ChannelSender</code> interface is the data sender component 
- * at the bottom layer, the IO layer (for layers see the javadoc for the {@link Channel} interface).<br>
- * The channel sender must support "silent" members, ie, be able to send a message to a member
- * that is not in the membership, but is part of the destination parameter
- * @author Filip Hanik
- * @version $Revision: 379904 $, $Date: 2006-02-22 15:16:25 -0600 (Wed, 22 Feb 2006) $
- */
-public interface ChannelSender extends Heartbeat
-{
-    /**
-     * Notify the sender of a member being added to the group.<br>
-     * Optional. This can be an empty implementation, that does nothing
-     * @param member Member
-     */
-    public void add(Member member);
-    /**
-     * Notification that a member has been removed or crashed.
-     * Can be used to clean up open connections etc
-     * @param member Member
-     */
-    public void remove(Member member);
-    
-    /**
-     * Start the channel sender
-     * @throws IOException if preprocessing takes place and an error happens
-     */
-    public void start() throws java.io.IOException;
-    /**
-     * Stop the channel sender
-     */
-    public void stop();
-    
-    /**
-     * A channel heartbeat, use this method to clean up resources
-     */
-    public void heartbeat() ;
-    
-    /**
-     * Send a message to one or more recipients.
-     * @param message ChannelMessage - the message to be sent
-     * @param destination Member[] - the destinations
-     * @throws ChannelException - if an error happens, the ChannelSender MUST report
-     * individual send failures on a per member basis, using ChannelException.addFaultyMember
-     * @see ChannelException#addFaultyMember(Member,java.lang.Exception)
-     */
-    public void sendMessage(ChannelMessage message, Member[] destination) throws ChannelException;
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes;
+
+
+/**
+ * ChannelReceiver Interface<br>
+ * The <code>ChannelSender</code> interface is the data sender component 
+ * at the bottom layer, the IO layer (for layers see the javadoc for the {@link Channel} interface).<br>
+ * The channel sender must support "silent" members, ie, be able to send a message to a member
+ * that is not in the membership, but is part of the destination parameter
+ * @author Filip Hanik
+ * @version $Revision: 379904 $, $Date: 2006-02-22 15:16:25 -0600 (Wed, 22 Feb 2006) $
+ */
+public interface ChannelSender extends Heartbeat
+{
+    /**
+     * Notify the sender of a member being added to the group.<br>
+     * Optional. This can be an empty implementation, that does nothing
+     * @param member Member
+     */
+    public void add(Member member);
+    /**
+     * Notification that a member has been removed or crashed.
+     * Can be used to clean up open connections etc
+     * @param member Member
+     */
+    public void remove(Member member);
+    
+    /**
+     * Start the channel sender
+     * @throws IOException if preprocessing takes place and an error happens
+     */
+    public void start() throws java.io.IOException;
+    /**
+     * Stop the channel sender
+     */
+    public void stop();
+    
+    /**
+     * A channel heartbeat, use this method to clean up resources
+     */
+    public void heartbeat() ;
+    
+    /**
+     * Send a message to one or more recipients.
+     * @param message ChannelMessage - the message to be sent
+     * @param destination Member[] - the destinations
+     * @throws ChannelException - if an error happens, the ChannelSender MUST report
+     * individual send failures on a per member basis, using ChannelException.addFaultyMember
+     * @see ChannelException#addFaultyMember(Member,java.lang.Exception)
+     */
+    public void sendMessage(ChannelMessage message, Member[] destination) throws ChannelException;
+}

==================================================
ErrorHandler.java
index 019d1062c9..8e7feb2aea 100644
--- a/java/org/apache/catalina/tribes/Constants.java
+++ b/java/org/apache/catalina/tribes/Constants.java
@@ -1,31 +1,32 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina.tribes;
-
-/**
- * Manifest constants for the <code>org.apache.catalina.tribes</code>
- * package.
- *
- * @author Bip Thelin
- * @author Filip Hanik
- * @version $Revision: 302726 $, $Date: 2004-02-27 08:59:07 -0600 (Fri, 27 Feb 2004) $
- */
-
-public final class Constants {
-    public static final String Package = "org.apache.catalina.tribes";
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.catalina.tribes;
+
+/**
+ * Manifest constants for the <code>org.apache.catalina.tribes</code>
+ * package.
+ *
+ * @author Bip Thelin
+ * @author Filip Hanik
+ * @version $Revision: 302726 $, $Date: 2004-02-27 08:59:07 -0600 (Fri, 27 Feb 2004) $
+ */
+
+public final class Constants {
+    public static final String Package = "org.apache.catalina.tribes";
+}

==================================================
Heartbeat.java
index 6496acecb6..4b79be0fc4 100644
--- a/java/org/apache/catalina/tribes/ErrorHandler.java
+++ b/java/org/apache/catalina/tribes/ErrorHandler.java
@@ -1,45 +1,46 @@
-/*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes;
-
-
-
-/**
- * The <code>ErrorHandler</code> class is used when sending messages
- * that are sent asynchronously and the application still needs to get 
- * confirmation when the message was sent successfully or when a message errored out.
- * @author Filip Hanik
- * @version 1.0
- */
-public interface ErrorHandler {
-    
-    /**
-     * Invoked if the message is dispatched asynch, and an error occurs
-     * @param x ChannelException - the error that happened
-     * @param id - the unique id for the message
-     * @see Channel#send(Member[], Serializable, int, ErrorHandler)
-     */
-    public void handleError(ChannelException x, UniqueId id);
-    
-    /**
-     * Invoked when the message has been sent successfully.
-     * @param id - the unique id for the message
-     * @see Channel#send(Member[], Serializable, int, ErrorHandler)
-     */
-    public void handleCompletion(UniqueId id);
-    
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes;
+
+
+
+/**
+ * The <code>ErrorHandler</code> class is used when sending messages
+ * that are sent asynchronously and the application still needs to get 
+ * confirmation when the message was sent successfully or when a message errored out.
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public interface ErrorHandler {
+    
+    /**
+     * Invoked if the message is dispatched asynch, and an error occurs
+     * @param x ChannelException - the error that happened
+     * @param id - the unique id for the message
+     * @see Channel#send(Member[], Serializable, int, ErrorHandler)
+     */
+    public void handleError(ChannelException x, UniqueId id);
+    
+    /**
+     * Invoked when the message has been sent successfully.
+     * @param id - the unique id for the message
+     * @see Channel#send(Member[], Serializable, int, ErrorHandler)
+     */
+    public void handleCompletion(UniqueId id);
+    
 }
\ No newline at end of file

==================================================
ManagedChannel.java
index ba5db2b4d8..21277309b8 100644
--- a/java/org/apache/catalina/tribes/Heartbeat.java
+++ b/java/org/apache/catalina/tribes/Heartbeat.java
@@ -1,33 +1,34 @@
-/*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes;
-
-/**
- * Can be implemented by the ChannelListener and Membership listeners to receive heartbeat
- * notifications from the Channel
- * @author Filip Hanik
- * @version 1.0
- * @see Channel
- * @see Channel#heartbeat()
- */
-public interface Heartbeat {
-    
-    /**
-     * Heartbeat invokation for resources cleanup etc
-     */
-    public void heartbeat();
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes;
+
+/**
+ * Can be implemented by the ChannelListener and Membership listeners to receive heartbeat
+ * notifications from the Channel
+ * @author Filip Hanik
+ * @version 1.0
+ * @see Channel
+ * @see Channel#heartbeat()
+ */
+public interface Heartbeat {
+    
+    /**
+     * Heartbeat invokation for resources cleanup etc
+     */
+    public void heartbeat();
+
 }
\ No newline at end of file

==================================================
Member.java
index aa56d3ac39..98d7e2c5cb 100644
--- a/java/org/apache/catalina/tribes/ManagedChannel.java
+++ b/java/org/apache/catalina/tribes/ManagedChannel.java
@@ -1,77 +1,78 @@
-/*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes;
-
-import java.util.Iterator;
-
-/**
- * Channel interface
- * A managed channel interface gives you access to the components of the channels
- * such as senders, receivers, interceptors etc for configurations purposes
- * @author Filip Hanik
- * @version $Revision: 304032 $, $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
- */
-public interface ManagedChannel extends Channel {
-
-    /**
-     * Sets the channel sender
-     * @param sender ChannelSender
-     * @see ChannelSender
-     */
-    public void setChannelSender(ChannelSender sender);
-
-    /**
-     * Sets the channel receiver
-     * @param receiver ChannelReceiver
-     * @see ChannelReceiver
-     */
-    public void setChannelReceiver(ChannelReceiver receiver);
-    
-    /**
-     * Sets the membership service
-     * @param service MembershipService
-     * @see MembershipService
-     */
-    public void setMembershipService(MembershipService service);
-
-    /**
-     * returns the channel sender
-     * @return ChannelSender
-     * @see ChannelSender
-     */
-    public ChannelSender getChannelSender();
-    
-    /**
-     * returns the channel receiver
-     * @return ChannelReceiver
-     * @see ChannelReceiver
-     */
-    public ChannelReceiver getChannelReceiver();
-    
-    /**
-     * Returns the membership service
-     * @return MembershipService
-     * @see MembershipService
-     */
-    public MembershipService getMembershipService();
-
-    /**
-     * Returns the interceptor stack
-     * @return Iterator
-     * @see Channel#addInterceptor(ChannelInterceptor)
-     */
-    public Iterator getInterceptors();
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes;
+
+import java.util.Iterator;
+
+/**
+ * Channel interface
+ * A managed channel interface gives you access to the components of the channels
+ * such as senders, receivers, interceptors etc for configurations purposes
+ * @author Filip Hanik
+ * @version $Revision: 304032 $, $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
+ */
+public interface ManagedChannel extends Channel {
+
+    /**
+     * Sets the channel sender
+     * @param sender ChannelSender
+     * @see ChannelSender
+     */
+    public void setChannelSender(ChannelSender sender);
+
+    /**
+     * Sets the channel receiver
+     * @param receiver ChannelReceiver
+     * @see ChannelReceiver
+     */
+    public void setChannelReceiver(ChannelReceiver receiver);
+    
+    /**
+     * Sets the membership service
+     * @param service MembershipService
+     * @see MembershipService
+     */
+    public void setMembershipService(MembershipService service);
+
+    /**
+     * returns the channel sender
+     * @return ChannelSender
+     * @see ChannelSender
+     */
+    public ChannelSender getChannelSender();
+    
+    /**
+     * returns the channel receiver
+     * @return ChannelReceiver
+     * @see ChannelReceiver
+     */
+    public ChannelReceiver getChannelReceiver();
+    
+    /**
+     * Returns the membership service
+     * @return MembershipService
+     * @see MembershipService
+     */
+    public MembershipService getMembershipService();
+
+    /**
+     * Returns the interceptor stack
+     * @return Iterator
+     * @see Channel#addInterceptor(ChannelInterceptor)
+     */
+    public Iterator getInterceptors();
+}

==================================================
MembershipListener.java
index 566493bddb..351aa77d96 100644
--- a/java/org/apache/catalina/tribes/Member.java
+++ b/java/org/apache/catalina/tribes/Member.java
@@ -1,118 +1,119 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes;
-
-/**
- * The Member interface, defines a member in the group.
- * Each member can carry a set of properties, defined by the actual implementation.<BR>
- * A member is identified by the host/ip/uniqueId<br>
- * The host is what interface the member is listening to, to receive data<br>
- * The port is what port the member is listening to, to receive data<br>
- * The uniqueId defines the session id for the member. This is an important feature
- * since a member that has crashed and the starts up again on the same port/host is 
- * not guaranteed to be the same member, so no state transfers will ever be confused
- * @author Filip Hanik
- * @version $Revision: 303950 $, $Date: 2005-06-09 15:38:30 -0500 (Thu, 09 Jun 2005) $
- */
-
-
-public interface Member {
-    
-    /**
-     * When a member leaves the cluster, the payload of the memberDisappeared member
-     * will be the following bytes. This indicates a soft shutdown, and not a crash
-     */
-    public static final byte[] SHUTDOWN_PAYLOAD = new byte[] {66, 65, 66, 89, 45, 65, 76, 69, 88};
-    
-    /**
-     * Returns the name of this node, should be unique within the group.
-     */
-    public String getName();
-  
-    /**
-     * Returns the listen host for the ChannelReceiver implementation
-     * @return IPv4 or IPv6 representation of the host address this member listens to incoming data
-     * @see ChannelReceiver
-     */
-    public byte[] getHost();
-
-    /**
-     * Returns the listen port for the ChannelReceiver implementation
-     * @return the listen port for this member, -1 if its not listening on an unsecure port
-     * @see ChannelReceiver
-     */
-    public int getPort();
-    
-    /**
-     * Returns the secure listen port for the ChannelReceiver implementation.
-     * Returns -1 if its not listening to a secure port.
-     * @return the listen port for this member, -1 if its not listening on a secure port
-     * @see ChannelReceiver
-     */
-    public int getSecurePort();
-    
-
-    /**
-     * Contains information on how long this member has been online.
-     * The result is the number of milli seconds this member has been
-     * broadcasting its membership to the group.
-     * @return nr of milliseconds since this member started.
-     */
-    public long getMemberAliveTime();
-    
-    /**
-     * The current state of the member
-     * @return boolean - true if the member is functioning correctly
-     */
-    public boolean isReady();
-    /**
-     * The current state of the member
-     * @return boolean - true if the member is suspect, but the crash has not been confirmed
-     */
-    public boolean isSuspect();
-    
-    /**
-     * 
-     * @return boolean - true if the member has been confirmed to malfunction 
-     */
-    public boolean isFailing();
-    
-    /**
-     * returns a UUID unique for this member over all sessions.
-     * If the member crashes and restarts, the uniqueId will be different.
-     * @return byte[]
-     */
-    public byte[] getUniqueId();
-    
-    /**
-     * returns the payload associated with this member
-     * @return byte[]
-     */
-    public byte[] getPayload();
-    
-    /**
-     * returns the command associated with this member
-     * @return byte[]
-     */
-    public byte[] getCommand();
-    
-    /**
-     * Domain for this cluster
-     * @return byte[]
-     */
-    public byte[] getDomain();
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes;
+
+/**
+ * The Member interface, defines a member in the group.
+ * Each member can carry a set of properties, defined by the actual implementation.<BR>
+ * A member is identified by the host/ip/uniqueId<br>
+ * The host is what interface the member is listening to, to receive data<br>
+ * The port is what port the member is listening to, to receive data<br>
+ * The uniqueId defines the session id for the member. This is an important feature
+ * since a member that has crashed and the starts up again on the same port/host is 
+ * not guaranteed to be the same member, so no state transfers will ever be confused
+ * @author Filip Hanik
+ * @version $Revision: 303950 $, $Date: 2005-06-09 15:38:30 -0500 (Thu, 09 Jun 2005) $
+ */
+
+
+public interface Member {
+    
+    /**
+     * When a member leaves the cluster, the payload of the memberDisappeared member
+     * will be the following bytes. This indicates a soft shutdown, and not a crash
+     */
+    public static final byte[] SHUTDOWN_PAYLOAD = new byte[] {66, 65, 66, 89, 45, 65, 76, 69, 88};
+    
+    /**
+     * Returns the name of this node, should be unique within the group.
+     */
+    public String getName();
+  
+    /**
+     * Returns the listen host for the ChannelReceiver implementation
+     * @return IPv4 or IPv6 representation of the host address this member listens to incoming data
+     * @see ChannelReceiver
+     */
+    public byte[] getHost();
+
+    /**
+     * Returns the listen port for the ChannelReceiver implementation
+     * @return the listen port for this member, -1 if its not listening on an unsecure port
+     * @see ChannelReceiver
+     */
+    public int getPort();
+    
+    /**
+     * Returns the secure listen port for the ChannelReceiver implementation.
+     * Returns -1 if its not listening to a secure port.
+     * @return the listen port for this member, -1 if its not listening on a secure port
+     * @see ChannelReceiver
+     */
+    public int getSecurePort();
+    
+
+    /**
+     * Contains information on how long this member has been online.
+     * The result is the number of milli seconds this member has been
+     * broadcasting its membership to the group.
+     * @return nr of milliseconds since this member started.
+     */
+    public long getMemberAliveTime();
+    
+    /**
+     * The current state of the member
+     * @return boolean - true if the member is functioning correctly
+     */
+    public boolean isReady();
+    /**
+     * The current state of the member
+     * @return boolean - true if the member is suspect, but the crash has not been confirmed
+     */
+    public boolean isSuspect();
+    
+    /**
+     * 
+     * @return boolean - true if the member has been confirmed to malfunction 
+     */
+    public boolean isFailing();
+    
+    /**
+     * returns a UUID unique for this member over all sessions.
+     * If the member crashes and restarts, the uniqueId will be different.
+     * @return byte[]
+     */
+    public byte[] getUniqueId();
+    
+    /**
+     * returns the payload associated with this member
+     * @return byte[]
+     */
+    public byte[] getPayload();
+    
+    /**
+     * returns the command associated with this member
+     * @return byte[]
+     */
+    public byte[] getCommand();
+    
+    /**
+     * Domain for this cluster
+     * @return byte[]
+     */
+    public byte[] getDomain();
+}

==================================================
MembershipService.java
index 1c5d5fc865..50e34bc9a3 100644
--- a/java/org/apache/catalina/tribes/MembershipListener.java
+++ b/java/org/apache/catalina/tribes/MembershipListener.java
@@ -1,44 +1,45 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes;
-
-/**
- * The MembershipListener interface is used as a callback to the
- * membership service. It has two methods that will notify the listener
- * when a member has joined the group and when a member has disappeared (crashed)
- *
- * @author Filip Hanik
- * @version $Revision: 302726 $, $Date: 2004-02-27 08:59:07 -0600 (Fri, 27 Feb 2004) $
- */
-
-
-public interface MembershipListener {
-    /**
-     * A member was added to the group
-     * @param member Member - the member that was added
-     */
-    public void memberAdded(Member member);
-    
-    /**
-     * A member was removed from the group<br>
-     * If the member left voluntarily, the Member.getCommand will contain the Member.SHUTDOWN_PAYLOAD data
-     * @param member Member
-     * @see Member#SHUTDOWN_PAYLOAD
-     */
-    public void memberDisappeared(Member member);
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes;
+
+/**
+ * The MembershipListener interface is used as a callback to the
+ * membership service. It has two methods that will notify the listener
+ * when a member has joined the group and when a member has disappeared (crashed)
+ *
+ * @author Filip Hanik
+ * @version $Revision: 302726 $, $Date: 2004-02-27 08:59:07 -0600 (Fri, 27 Feb 2004) $
+ */
+
+
+public interface MembershipListener {
+    /**
+     * A member was added to the group
+     * @param member Member - the member that was added
+     */
+    public void memberAdded(Member member);
+    
+    /**
+     * A member was removed from the group<br>
+     * If the member left voluntarily, the Member.getCommand will contain the Member.SHUTDOWN_PAYLOAD data
+     * @param member Member
+     * @see Member#SHUTDOWN_PAYLOAD
+     */
+    public void memberDisappeared(Member member);
+
 }
\ No newline at end of file

==================================================
MessageListener.java
index 023cb83b60..95256de2dc 100644
--- a/java/org/apache/catalina/tribes/MembershipService.java
+++ b/java/org/apache/catalina/tribes/MembershipService.java
@@ -1,134 +1,135 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes;
-
-
-/**
- * MembershipService Interface<br>
- * The <code>MembershipService</code> interface is the membership component 
- * at the bottom layer, the IO layer (for layers see the javadoc for the {@link Channel} interface).<br>
- * @author Filip Hanik
- * @version $Revision: 378093 $, $Date: 2006-02-15 15:13:45 -0600 (Wed, 15 Feb 2006) $
- */
-
-
-public interface MembershipService {
-    
-    public static final int MBR_RX = Channel.MBR_RX_SEQ;
-    public static final int MBR_TX = Channel.MBR_TX_SEQ;
-    
-    /**
-     * Sets the properties for the membership service. This must be called before
-     * the <code>start()</code> method is called.
-     * The properties are implementation specific.
-     * @param properties - to be used to configure the membership service.
-     */
-    public void setProperties(java.util.Properties properties);
-    /**
-     * Returns the properties for the configuration used.
-     */
-    public java.util.Properties getProperties();
-    /**
-     * Starts the membership service. If a membership listeners is added
-     * the listener will start to receive membership events.
-     * Performs a start level 1 and 2
-     * @throws java.lang.Exception if the service fails to start.
-     */
-    public void start() throws java.lang.Exception;
-
-    /**
-     * Starts the membership service. If a membership listeners is added
-     * the listener will start to receive membership events.
-     * @param level - level MBR_RX starts listening for members, level MBR_TX 
-     * starts broad casting the server
-     * @throws java.lang.Exception if the service fails to start.
-     * @throws java.lang.IllegalArgumentException if the level is incorrect.
-     */
-    public void start(int level) throws java.lang.Exception;
-
-
-    /**
-     * Starts the membership service. If a membership listeners is added
-     * the listener will start to receive membership events.
-     * @param level - level MBR_RX stops listening for members, level MBR_TX 
-     * stops broad casting the server
-     * @throws java.lang.Exception if the service fails to stop
-     * @throws java.lang.IllegalArgumentException if the level is incorrect.
-     */
-
-    public void stop(int level);
-    
-    /**
-     * @return true if the the group contains members
-     */
-    public boolean hasMembers();
-    
-    
-    /**
-     * 
-     * @param mbr Member
-     * @return Member
-     */
-    public Member getMember(Member mbr);
-    /**
-     * Returns a list of all the members in the cluster.
-     */
-    
-    public Member[] getMembers();
-    
-    /**
-     * Returns the member object that defines this member
-     */
-    public Member getLocalMember(boolean incAliveTime);
-
-    /**
-     * Return all members by name
-     */
-    public String[] getMembersByName() ; 
-    
-    /**
-     * Return the member by name
-     */
-    public Member findMemberByName(String name) ;
-
-    /**
-     * Sets the local member properties for broadcasting
-     */
-    public void setLocalMemberProperties(String listenHost, int listenPort);
-    
-    /**
-     * Sets the membership listener, only one listener can be added.
-     * If you call this method twice, the last listener will be used.
-     * @param listener The listener
-     */
-    public void setMembershipListener(MembershipListener listener);
-    
-    /**
-     * removes the membership listener.
-     */
-    public void removeMembershipListener();
-    
-    /**
-     * Set a payload to be broadcasted with each membership 
-     * broadcast.
-     * @param payload byte[]
-     */
-    public void setPayload(byte[] payload);
-    
-    public void setDomain(byte[] domain);
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes;
+
+
+/**
+ * MembershipService Interface<br>
+ * The <code>MembershipService</code> interface is the membership component 
+ * at the bottom layer, the IO layer (for layers see the javadoc for the {@link Channel} interface).<br>
+ * @author Filip Hanik
+ * @version $Revision: 378093 $, $Date: 2006-02-15 15:13:45 -0600 (Wed, 15 Feb 2006) $
+ */
+
+
+public interface MembershipService {
+    
+    public static final int MBR_RX = Channel.MBR_RX_SEQ;
+    public static final int MBR_TX = Channel.MBR_TX_SEQ;
+    
+    /**
+     * Sets the properties for the membership service. This must be called before
+     * the <code>start()</code> method is called.
+     * The properties are implementation specific.
+     * @param properties - to be used to configure the membership service.
+     */
+    public void setProperties(java.util.Properties properties);
+    /**
+     * Returns the properties for the configuration used.
+     */
+    public java.util.Properties getProperties();
+    /**
+     * Starts the membership service. If a membership listeners is added
+     * the listener will start to receive membership events.
+     * Performs a start level 1 and 2
+     * @throws java.lang.Exception if the service fails to start.
+     */
+    public void start() throws java.lang.Exception;
+
+    /**
+     * Starts the membership service. If a membership listeners is added
+     * the listener will start to receive membership events.
+     * @param level - level MBR_RX starts listening for members, level MBR_TX 
+     * starts broad casting the server
+     * @throws java.lang.Exception if the service fails to start.
+     * @throws java.lang.IllegalArgumentException if the level is incorrect.
+     */
+    public void start(int level) throws java.lang.Exception;
+
+
+    /**
+     * Starts the membership service. If a membership listeners is added
+     * the listener will start to receive membership events.
+     * @param level - level MBR_RX stops listening for members, level MBR_TX 
+     * stops broad casting the server
+     * @throws java.lang.Exception if the service fails to stop
+     * @throws java.lang.IllegalArgumentException if the level is incorrect.
+     */
+
+    public void stop(int level);
+    
+    /**
+     * @return true if the the group contains members
+     */
+    public boolean hasMembers();
+    
+    
+    /**
+     * 
+     * @param mbr Member
+     * @return Member
+     */
+    public Member getMember(Member mbr);
+    /**
+     * Returns a list of all the members in the cluster.
+     */
+    
+    public Member[] getMembers();
+    
+    /**
+     * Returns the member object that defines this member
+     */
+    public Member getLocalMember(boolean incAliveTime);
+
+    /**
+     * Return all members by name
+     */
+    public String[] getMembersByName() ; 
+    
+    /**
+     * Return the member by name
+     */
+    public Member findMemberByName(String name) ;
+
+    /**
+     * Sets the local member properties for broadcasting
+     */
+    public void setLocalMemberProperties(String listenHost, int listenPort);
+    
+    /**
+     * Sets the membership listener, only one listener can be added.
+     * If you call this method twice, the last listener will be used.
+     * @param listener The listener
+     */
+    public void setMembershipListener(MembershipListener listener);
+    
+    /**
+     * removes the membership listener.
+     */
+    public void removeMembershipListener();
+    
+    /**
+     * Set a payload to be broadcasted with each membership 
+     * broadcast.
+     * @param payload byte[]
+     */
+    public void setPayload(byte[] payload);
+    
+    public void setDomain(byte[] domain);
+
+}

==================================================
UniqueId.java
index a6da94a36f..d9458f6594 100644
--- a/java/org/apache/catalina/tribes/MessageListener.java
+++ b/java/org/apache/catalina/tribes/MessageListener.java
@@ -1,42 +1,43 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes;
-
-/**
- * 
- * <p>Title: MessageListener</p> 
- * 
- * <p>Description: The listener to be registered with the ChannelReceiver, internal Tribes component</p> 
- * 
- * @author Filip Hanik
- * @version 1.0
- */
-
-public interface MessageListener {
-    
-    /**
-     * Receive a message from the IO components in the Channel stack
-     * @param msg ChannelMessage
-     */
-    public void messageReceived(ChannelMessage msg);
-    
-    public boolean accept(ChannelMessage msg);
-    
-    public boolean equals(Object listener);
-    
-    public int hashCode();
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes;
+
+/**
+ * 
+ * <p>Title: MessageListener</p> 
+ * 
+ * <p>Description: The listener to be registered with the ChannelReceiver, internal Tribes component</p> 
+ * 
+ * @author Filip Hanik
+ * @version 1.0
+ */
+
+public interface MessageListener {
+    
+    /**
+     * Receive a message from the IO components in the Channel stack
+     * @param msg ChannelMessage
+     */
+    public void messageReceived(ChannelMessage msg);
+    
+    public boolean accept(ChannelMessage msg);
+    
+    public boolean equals(Object listener);
+    
+    public int hashCode();
+
+}

==================================================
ChannelCoordinator.java
index 3e5852793e..4be5c43168 100644
--- a/java/org/apache/catalina/tribes/UniqueId.java
+++ b/java/org/apache/catalina/tribes/UniqueId.java
@@ -1,71 +1,72 @@
-/*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes;
-
-import org.apache.catalina.tribes.util.Arrays;
-import java.io.Serializable;
-
-/**
- * <p>Title: Represents a globabally unique Id</p>
- *
- * <p>Company: </p>
- *
- * @author Filip Hanik
- * @version 1.0
- */
-public final class UniqueId implements Serializable{
-    protected byte[] id;
-    
-    public UniqueId() {
-    }
-
-    public UniqueId(byte[] id) {
-        this.id = id;
-    }
-    
-    public UniqueId(byte[] id, int offset, int length) {
-        this.id = new byte[length];
-        System.arraycopy(id,offset,this.id,0,length);
-    }
-    
-    public int hashCode() {
-        if ( id == null ) return 0;
-        return Arrays.hashCode(id);
-    }
-    
-    public boolean equals(Object other) {
-        boolean result = (other instanceof UniqueId);
-        if ( result ) {
-            UniqueId uid = (UniqueId)other;
-            if ( this.id == null && uid.id == null ) result = true;
-            else if ( this.id == null && uid.id != null ) result = false;
-            else if ( this.id != null && uid.id == null ) result = false;
-            else result = Arrays.equals(this.id,uid.id);
-        }//end if
-        return result;
-    }
-    
-    public byte[] getBytes() {
-        return id;
-    }
-    
-    public String toString() {
-        StringBuffer buf = new StringBuffer("UniqueId");
-        buf.append(org.apache.catalina.tribes.util.Arrays.toString(id));
-        return buf.toString();
-    }
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes;
+
+import org.apache.catalina.tribes.util.Arrays;
+import java.io.Serializable;
+
+/**
+ * <p>Title: Represents a globabally unique Id</p>
+ *
+ * <p>Company: </p>
+ *
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public final class UniqueId implements Serializable{
+    protected byte[] id;
+    
+    public UniqueId() {
+    }
+
+    public UniqueId(byte[] id) {
+        this.id = id;
+    }
+    
+    public UniqueId(byte[] id, int offset, int length) {
+        this.id = new byte[length];
+        System.arraycopy(id,offset,this.id,0,length);
+    }
+    
+    public int hashCode() {
+        if ( id == null ) return 0;
+        return Arrays.hashCode(id);
+    }
+    
+    public boolean equals(Object other) {
+        boolean result = (other instanceof UniqueId);
+        if ( result ) {
+            UniqueId uid = (UniqueId)other;
+            if ( this.id == null && uid.id == null ) result = true;
+            else if ( this.id == null && uid.id != null ) result = false;
+            else if ( this.id != null && uid.id == null ) result = false;
+            else result = Arrays.equals(this.id,uid.id);
+        }//end if
+        return result;
+    }
+    
+    public byte[] getBytes() {
+        return id;
+    }
+    
+    public String toString() {
+        StringBuffer buf = new StringBuffer("UniqueId");
+        buf.append(org.apache.catalina.tribes.util.Arrays.toString(id));
+        return buf.toString();
+    }
+
 }
\ No newline at end of file

==================================================
ChannelInterceptorBase.java
index 8cb6b490d5..b3634dd16c 100644
--- a/java/org/apache/catalina/tribes/group/ChannelCoordinator.java
+++ b/java/org/apache/catalina/tribes/group/ChannelCoordinator.java
@@ -1,317 +1,318 @@
-/*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.group;
-
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.ChannelReceiver;
-import org.apache.catalina.tribes.ChannelSender;
-
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.MembershipService;
-import org.apache.catalina.tribes.MessageListener;
-import org.apache.catalina.tribes.transport.SenderState;
-import org.apache.catalina.tribes.transport.ReplicationTransmitter;
-import org.apache.catalina.tribes.membership.McastService;
-import org.apache.catalina.tribes.transport.nio.NioReceiver;
-import org.apache.catalina.tribes.Channel;
-import org.apache.catalina.tribes.util.Logs;
-import org.apache.catalina.tribes.UniqueId;
-import org.apache.catalina.tribes.util.Arrays;
-
-
-/**
- * The channel coordinator object coordinates the membership service,
- * the sender and the receiver.
- * This is the last interceptor in the chain.
- * @author Filip Hanik
- * @version $Revision: 304032 $, $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
- */
-public class ChannelCoordinator extends ChannelInterceptorBase implements MessageListener {
-    private ChannelReceiver clusterReceiver = new NioReceiver();
-    private ChannelSender clusterSender = new ReplicationTransmitter();
-    private MembershipService membershipService = new McastService();
-    
-    //override optionflag
-    protected int optionFlag = Channel.SEND_OPTIONS_BYTE_MESSAGE|Channel.SEND_OPTIONS_USE_ACK|Channel.SEND_OPTIONS_SYNCHRONIZED_ACK;
-    public int getOptionFlag() {return optionFlag;}
-    public void setOptionFlag(int flag) {optionFlag=flag;}
-    
-    private int startLevel = 0;
-
-    public ChannelCoordinator() {
-        
-    }
-    
-    public ChannelCoordinator(ChannelReceiver receiver,
-                              ChannelSender sender,
-                              MembershipService service) {
-        this();
-        this.setClusterReceiver(receiver);
-        this.setClusterSender(sender);
-        this.setMembershipService(service);
-    }
-    
-    /**
-     * Send a message to one or more members in the cluster
-     * @param destination Member[] - the destinations, null or zero length means all
-     * @param msg ClusterMessage - the message to send
-     * @param options int - sender options, see class documentation
-     * @return ClusterMessage[] - the replies from the members, if any.
-     */
-    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
-        if ( destination == null ) destination = membershipService.getMembers();
-        clusterSender.sendMessage(msg,destination);
-        if ( Logs.MESSAGES.isTraceEnabled() ) {
-            Logs.MESSAGES.trace("ChannelCoordinator - Sent msg:" + new UniqueId(msg.getUniqueId()) + " at " +new java.sql.Timestamp(System.currentTimeMillis())+ " to "+Arrays.toNameString(destination));
-        }
-    }
-    
-
-    /**
-     * Starts up the channel. This can be called multiple times for individual services to start
-     * The svc parameter can be the logical or value of any constants
-     * @param svc int value of <BR>
-     * DEFAULT - will start all services <BR>
-     * MBR_RX_SEQ - starts the membership receiver <BR>
-     * MBR_TX_SEQ - starts the membership broadcaster <BR>
-     * SND_TX_SEQ - starts the replication transmitter<BR>
-     * SND_RX_SEQ - starts the replication receiver<BR>
-     * @throws ChannelException if a startup error occurs or the service is already started.
-     */
-    public void start(int svc) throws ChannelException {
-        this.internalStart(svc);
-    }
-
-    /**
-     * Shuts down the channel. This can be called multiple times for individual services to shutdown
-     * The svc parameter can be the logical or value of any constants
-     * @param svc int value of <BR>
-     * DEFAULT - will shutdown all services <BR>
-     * MBR_RX_SEQ - stops the membership receiver <BR>
-     * MBR_TX_SEQ - stops the membership broadcaster <BR>
-     * SND_TX_SEQ - stops the replication transmitter<BR>
-     * SND_RX_SEQ - stops the replication receiver<BR>
-     * @throws ChannelException if a startup error occurs or the service is already started.
-     */
-    public void stop(int svc) throws ChannelException {
-        this.internalStop(svc);
-    }    
-
-
-    /**
-     * Starts up the channel. This can be called multiple times for individual services to start
-     * The svc parameter can be the logical or value of any constants
-     * @param svc int value of <BR>
-     * DEFAULT - will start all services <BR>
-     * MBR_RX_SEQ - starts the membership receiver <BR>
-     * MBR_TX_SEQ - starts the membership broadcaster <BR>
-     * SND_TX_SEQ - starts the replication transmitter<BR>
-     * SND_RX_SEQ - starts the replication receiver<BR>
-     * @throws ChannelException if a startup error occurs or the service is already started.
-     */
-    protected synchronized void internalStart(int svc) throws ChannelException {
-        try {
-            boolean valid = false;
-            //make sure we don't pass down any flags that are unrelated to the bottom layer
-            svc = svc & Channel.DEFAULT;
-
-            if (startLevel == Channel.DEFAULT) return; //we have already started up all components
-            if (svc == 0 ) return;//nothing to start
-            
-            if (svc == (svc & startLevel)) throw new ChannelException("Channel already started for level:"+svc);
-
-            //must start the receiver first so that we can coordinate the port it
-            //listens to with the local membership settings
-            if ( Channel.SND_RX_SEQ==(svc & Channel.SND_RX_SEQ) ) {
-                clusterReceiver.setMessageListener(this);
-                clusterReceiver.start();
-                //synchronize, big time FIXME
-                membershipService.setLocalMemberProperties(getClusterReceiver().getHost(), getClusterReceiver().getPort());
-                valid = true;
-            }
-            if ( Channel.SND_TX_SEQ==(svc & Channel.SND_TX_SEQ) ) {
-                clusterSender.start();
-                valid = true;
-            }
-            
-            if ( Channel.MBR_RX_SEQ==(svc & Channel.MBR_RX_SEQ) ) {
-                membershipService.setMembershipListener(this);
-                membershipService.start(MembershipService.MBR_RX);
-                valid = true;
-            }
-            if ( Channel.MBR_TX_SEQ==(svc & Channel.MBR_TX_SEQ) ) {
-                membershipService.start(MembershipService.MBR_TX);
-                valid = true;
-            }
-            
-            if ( !valid) {
-                throw new IllegalArgumentException("Invalid start level, valid levels are:SND_RX_SEQ,SND_TX_SEQ,MBR_TX_SEQ,MBR_RX_SEQ");
-            }
-            startLevel = (startLevel | svc);
-        }catch ( ChannelException cx ) {
-            throw cx;
-        }catch ( Exception x ) {
-            throw new ChannelException(x);
-        }
-    }
-
-    /**
-     * Shuts down the channel. This can be called multiple times for individual services to shutdown
-     * The svc parameter can be the logical or value of any constants
-     * @param svc int value of <BR>
-     * DEFAULT - will shutdown all services <BR>
-     * MBR_RX_SEQ - starts the membership receiver <BR>
-     * MBR_TX_SEQ - starts the membership broadcaster <BR>
-     * SND_TX_SEQ - starts the replication transmitter<BR>
-     * SND_RX_SEQ - starts the replication receiver<BR>
-     * @throws ChannelException if a startup error occurs or the service is already started.
-     */
-    protected synchronized void internalStop(int svc) throws ChannelException {
-        try {
-            //make sure we don't pass down any flags that are unrelated to the bottom layer
-            svc = svc & Channel.DEFAULT;
-
-            if (startLevel == 0) return; //we have already stopped up all components
-            if (svc == 0 ) return;//nothing to stop
-
-            boolean valid = false;
-            if ( Channel.SND_RX_SEQ==(svc & Channel.SND_RX_SEQ) ) {
-                clusterReceiver.stop();
-                clusterReceiver.setMessageListener(null);
-                valid = true;
-            }
-            if ( Channel.SND_TX_SEQ==(svc & Channel.SND_TX_SEQ) ) {
-                clusterSender.stop();
-                valid = true;
-            }
-
-            if ( Channel.MBR_RX_SEQ==(svc & Channel.MBR_RX_SEQ) ) {
-                membershipService.stop(MembershipService.MBR_RX);
-                membershipService.setMembershipListener(null);
-                valid = true;
-                
-            }
-            if ( Channel.MBR_TX_SEQ==(svc & Channel.MBR_TX_SEQ) ) {
-                valid = true;
-                membershipService.stop(MembershipService.MBR_TX);
-            }            
-            if ( !valid) {
-                throw new IllegalArgumentException("Invalid start level, valid levels are:SND_RX_SEQ,SND_TX_SEQ,MBR_TX_SEQ,MBR_RX_SEQ");
-            }
-
-            startLevel = (startLevel & (~svc));
-            
-        }catch ( Exception x ) {
-            throw new ChannelException(x);
-        } finally {
-            
-        }
-
-    }
-    
-    public void memberAdded(Member member){
-        SenderState.getSenderState(member);
-        if ( clusterSender!=null ) clusterSender.add(member);
-        super.memberAdded(member);
-    }
-    
-    public void memberDisappeared(Member member){
-        SenderState.removeSenderState(member);
-        if ( clusterSender!=null ) clusterSender.remove(member);
-        super.memberDisappeared(member);
-    }
-    
-    public void messageReceived(ChannelMessage msg) {
-        if ( Logs.MESSAGES.isTraceEnabled() ) {
-            Logs.MESSAGES.trace("ChannelCoordinator - Received msg:" + new UniqueId(msg.getUniqueId()) + " at " +new java.sql.Timestamp(System.currentTimeMillis())+ " from "+msg.getAddress().getName());
-        }
-        super.messageReceived(msg);
-    }
-
-
-    public ChannelReceiver getClusterReceiver() {
-        return clusterReceiver;
-    }
-
-    public ChannelSender getClusterSender() {
-        return clusterSender;
-    }
-
-    public MembershipService getMembershipService() {
-        return membershipService;
-    }
-
-    public void setClusterReceiver(ChannelReceiver clusterReceiver) {
-        if ( clusterReceiver != null ) {
-            this.clusterReceiver = clusterReceiver;
-            this.clusterReceiver.setMessageListener(this);
-        } else {
-            if  (this.clusterReceiver!=null ) this.clusterReceiver.setMessageListener(null);
-            this.clusterReceiver = null;
-        }
-    }
-
-    public void setClusterSender(ChannelSender clusterSender) {
-        this.clusterSender = clusterSender;
-    }
-
-    public void setMembershipService(MembershipService membershipService) {
-        this.membershipService = membershipService;
-        this.membershipService.setMembershipListener(this);
-    }
-    
-    public void hearbeat() {
-        if ( clusterSender!=null ) clusterSender.heartbeat();
-        super.heartbeat();
-    }
-    
-    /**
-     * has members
-     */
-    public boolean hasMembers() {
-        return this.getMembershipService().hasMembers();
-    }
-
-    /**
-     * Get all current cluster members
-     * @return all members or empty array
-     */
-    public Member[] getMembers() {
-        return this.getMembershipService().getMembers();
-    }
-
-    /**
-     * 
-     * @param mbr Member
-     * @return Member
-     */
-    public Member getMember(Member mbr){
-        return this.getMembershipService().getMember(mbr);
-    }
-
-
-    /**
-     * Return the member that represents this node.
-     *
-     * @return Member
-     */
-    public Member getLocalMember(boolean incAlive) {
-        return this.getMembershipService().getLocalMember(incAlive);
-    }
-
-   
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.group;
+
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.ChannelReceiver;
+import org.apache.catalina.tribes.ChannelSender;
+
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.MembershipService;
+import org.apache.catalina.tribes.MessageListener;
+import org.apache.catalina.tribes.transport.SenderState;
+import org.apache.catalina.tribes.transport.ReplicationTransmitter;
+import org.apache.catalina.tribes.membership.McastService;
+import org.apache.catalina.tribes.transport.nio.NioReceiver;
+import org.apache.catalina.tribes.Channel;
+import org.apache.catalina.tribes.util.Logs;
+import org.apache.catalina.tribes.UniqueId;
+import org.apache.catalina.tribes.util.Arrays;
+
+
+/**
+ * The channel coordinator object coordinates the membership service,
+ * the sender and the receiver.
+ * This is the last interceptor in the chain.
+ * @author Filip Hanik
+ * @version $Revision: 304032 $, $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
+ */
+public class ChannelCoordinator extends ChannelInterceptorBase implements MessageListener {
+    private ChannelReceiver clusterReceiver = new NioReceiver();
+    private ChannelSender clusterSender = new ReplicationTransmitter();
+    private MembershipService membershipService = new McastService();
+    
+    //override optionflag
+    protected int optionFlag = Channel.SEND_OPTIONS_BYTE_MESSAGE|Channel.SEND_OPTIONS_USE_ACK|Channel.SEND_OPTIONS_SYNCHRONIZED_ACK;
+    public int getOptionFlag() {return optionFlag;}
+    public void setOptionFlag(int flag) {optionFlag=flag;}
+    
+    private int startLevel = 0;
+
+    public ChannelCoordinator() {
+        
+    }
+    
+    public ChannelCoordinator(ChannelReceiver receiver,
+                              ChannelSender sender,
+                              MembershipService service) {
+        this();
+        this.setClusterReceiver(receiver);
+        this.setClusterSender(sender);
+        this.setMembershipService(service);
+    }
+    
+    /**
+     * Send a message to one or more members in the cluster
+     * @param destination Member[] - the destinations, null or zero length means all
+     * @param msg ClusterMessage - the message to send
+     * @param options int - sender options, see class documentation
+     * @return ClusterMessage[] - the replies from the members, if any.
+     */
+    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
+        if ( destination == null ) destination = membershipService.getMembers();
+        clusterSender.sendMessage(msg,destination);
+        if ( Logs.MESSAGES.isTraceEnabled() ) {
+            Logs.MESSAGES.trace("ChannelCoordinator - Sent msg:" + new UniqueId(msg.getUniqueId()) + " at " +new java.sql.Timestamp(System.currentTimeMillis())+ " to "+Arrays.toNameString(destination));
+        }
+    }
+    
+
+    /**
+     * Starts up the channel. This can be called multiple times for individual services to start
+     * The svc parameter can be the logical or value of any constants
+     * @param svc int value of <BR>
+     * DEFAULT - will start all services <BR>
+     * MBR_RX_SEQ - starts the membership receiver <BR>
+     * MBR_TX_SEQ - starts the membership broadcaster <BR>
+     * SND_TX_SEQ - starts the replication transmitter<BR>
+     * SND_RX_SEQ - starts the replication receiver<BR>
+     * @throws ChannelException if a startup error occurs or the service is already started.
+     */
+    public void start(int svc) throws ChannelException {
+        this.internalStart(svc);
+    }
+
+    /**
+     * Shuts down the channel. This can be called multiple times for individual services to shutdown
+     * The svc parameter can be the logical or value of any constants
+     * @param svc int value of <BR>
+     * DEFAULT - will shutdown all services <BR>
+     * MBR_RX_SEQ - stops the membership receiver <BR>
+     * MBR_TX_SEQ - stops the membership broadcaster <BR>
+     * SND_TX_SEQ - stops the replication transmitter<BR>
+     * SND_RX_SEQ - stops the replication receiver<BR>
+     * @throws ChannelException if a startup error occurs or the service is already started.
+     */
+    public void stop(int svc) throws ChannelException {
+        this.internalStop(svc);
+    }    
+
+
+    /**
+     * Starts up the channel. This can be called multiple times for individual services to start
+     * The svc parameter can be the logical or value of any constants
+     * @param svc int value of <BR>
+     * DEFAULT - will start all services <BR>
+     * MBR_RX_SEQ - starts the membership receiver <BR>
+     * MBR_TX_SEQ - starts the membership broadcaster <BR>
+     * SND_TX_SEQ - starts the replication transmitter<BR>
+     * SND_RX_SEQ - starts the replication receiver<BR>
+     * @throws ChannelException if a startup error occurs or the service is already started.
+     */
+    protected synchronized void internalStart(int svc) throws ChannelException {
+        try {
+            boolean valid = false;
+            //make sure we don't pass down any flags that are unrelated to the bottom layer
+            svc = svc & Channel.DEFAULT;
+
+            if (startLevel == Channel.DEFAULT) return; //we have already started up all components
+            if (svc == 0 ) return;//nothing to start
+            
+            if (svc == (svc & startLevel)) throw new ChannelException("Channel already started for level:"+svc);
+
+            //must start the receiver first so that we can coordinate the port it
+            //listens to with the local membership settings
+            if ( Channel.SND_RX_SEQ==(svc & Channel.SND_RX_SEQ) ) {
+                clusterReceiver.setMessageListener(this);
+                clusterReceiver.start();
+                //synchronize, big time FIXME
+                membershipService.setLocalMemberProperties(getClusterReceiver().getHost(), getClusterReceiver().getPort());
+                valid = true;
+            }
+            if ( Channel.SND_TX_SEQ==(svc & Channel.SND_TX_SEQ) ) {
+                clusterSender.start();
+                valid = true;
+            }
+            
+            if ( Channel.MBR_RX_SEQ==(svc & Channel.MBR_RX_SEQ) ) {
+                membershipService.setMembershipListener(this);
+                membershipService.start(MembershipService.MBR_RX);
+                valid = true;
+            }
+            if ( Channel.MBR_TX_SEQ==(svc & Channel.MBR_TX_SEQ) ) {
+                membershipService.start(MembershipService.MBR_TX);
+                valid = true;
+            }
+            
+            if ( !valid) {
+                throw new IllegalArgumentException("Invalid start level, valid levels are:SND_RX_SEQ,SND_TX_SEQ,MBR_TX_SEQ,MBR_RX_SEQ");
+            }
+            startLevel = (startLevel | svc);
+        }catch ( ChannelException cx ) {
+            throw cx;
+        }catch ( Exception x ) {
+            throw new ChannelException(x);
+        }
+    }
+
+    /**
+     * Shuts down the channel. This can be called multiple times for individual services to shutdown
+     * The svc parameter can be the logical or value of any constants
+     * @param svc int value of <BR>
+     * DEFAULT - will shutdown all services <BR>
+     * MBR_RX_SEQ - starts the membership receiver <BR>
+     * MBR_TX_SEQ - starts the membership broadcaster <BR>
+     * SND_TX_SEQ - starts the replication transmitter<BR>
+     * SND_RX_SEQ - starts the replication receiver<BR>
+     * @throws ChannelException if a startup error occurs or the service is already started.
+     */
+    protected synchronized void internalStop(int svc) throws ChannelException {
+        try {
+            //make sure we don't pass down any flags that are unrelated to the bottom layer
+            svc = svc & Channel.DEFAULT;
+
+            if (startLevel == 0) return; //we have already stopped up all components
+            if (svc == 0 ) return;//nothing to stop
+
+            boolean valid = false;
+            if ( Channel.SND_RX_SEQ==(svc & Channel.SND_RX_SEQ) ) {
+                clusterReceiver.stop();
+                clusterReceiver.setMessageListener(null);
+                valid = true;
+            }
+            if ( Channel.SND_TX_SEQ==(svc & Channel.SND_TX_SEQ) ) {
+                clusterSender.stop();
+                valid = true;
+            }
+
+            if ( Channel.MBR_RX_SEQ==(svc & Channel.MBR_RX_SEQ) ) {
+                membershipService.stop(MembershipService.MBR_RX);
+                membershipService.setMembershipListener(null);
+                valid = true;
+                
+            }
+            if ( Channel.MBR_TX_SEQ==(svc & Channel.MBR_TX_SEQ) ) {
+                valid = true;
+                membershipService.stop(MembershipService.MBR_TX);
+            }            
+            if ( !valid) {
+                throw new IllegalArgumentException("Invalid start level, valid levels are:SND_RX_SEQ,SND_TX_SEQ,MBR_TX_SEQ,MBR_RX_SEQ");
+            }
+
+            startLevel = (startLevel & (~svc));
+            
+        }catch ( Exception x ) {
+            throw new ChannelException(x);
+        } finally {
+            
+        }
+
+    }
+    
+    public void memberAdded(Member member){
+        SenderState.getSenderState(member);
+        if ( clusterSender!=null ) clusterSender.add(member);
+        super.memberAdded(member);
+    }
+    
+    public void memberDisappeared(Member member){
+        SenderState.removeSenderState(member);
+        if ( clusterSender!=null ) clusterSender.remove(member);
+        super.memberDisappeared(member);
+    }
+    
+    public void messageReceived(ChannelMessage msg) {
+        if ( Logs.MESSAGES.isTraceEnabled() ) {
+            Logs.MESSAGES.trace("ChannelCoordinator - Received msg:" + new UniqueId(msg.getUniqueId()) + " at " +new java.sql.Timestamp(System.currentTimeMillis())+ " from "+msg.getAddress().getName());
+        }
+        super.messageReceived(msg);
+    }
+
+
+    public ChannelReceiver getClusterReceiver() {
+        return clusterReceiver;
+    }
+
+    public ChannelSender getClusterSender() {
+        return clusterSender;
+    }
+
+    public MembershipService getMembershipService() {
+        return membershipService;
+    }
+
+    public void setClusterReceiver(ChannelReceiver clusterReceiver) {
+        if ( clusterReceiver != null ) {
+            this.clusterReceiver = clusterReceiver;
+            this.clusterReceiver.setMessageListener(this);
+        } else {
+            if  (this.clusterReceiver!=null ) this.clusterReceiver.setMessageListener(null);
+            this.clusterReceiver = null;
+        }
+    }
+
+    public void setClusterSender(ChannelSender clusterSender) {
+        this.clusterSender = clusterSender;
+    }
+
+    public void setMembershipService(MembershipService membershipService) {
+        this.membershipService = membershipService;
+        this.membershipService.setMembershipListener(this);
+    }
+    
+    public void hearbeat() {
+        if ( clusterSender!=null ) clusterSender.heartbeat();
+        super.heartbeat();
+    }
+    
+    /**
+     * has members
+     */
+    public boolean hasMembers() {
+        return this.getMembershipService().hasMembers();
+    }
+
+    /**
+     * Get all current cluster members
+     * @return all members or empty array
+     */
+    public Member[] getMembers() {
+        return this.getMembershipService().getMembers();
+    }
+
+    /**
+     * 
+     * @param mbr Member
+     * @return Member
+     */
+    public Member getMember(Member mbr){
+        return this.getMembershipService().getMember(mbr);
+    }
+
+
+    /**
+     * Return the member that represents this node.
+     *
+     * @return Member
+     */
+    public Member getLocalMember(boolean incAlive) {
+        return this.getMembershipService().getLocalMember(incAlive);
+    }
+
+   
+}

==================================================
GroupChannel.java
index d23829a3d5..3c1b6d63c3 100644
--- a/java/org/apache/catalina/tribes/group/ChannelInterceptorBase.java
+++ b/java/org/apache/catalina/tribes/group/ChannelInterceptorBase.java
@@ -1,171 +1,172 @@
-/*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.group;
-
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelInterceptor;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.Member;
-
-/**
- * Abstract class for the interceptor base class.
- * @author Filip Hanik
- * @version $Revision: 304032 $, $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
- */
-
-public abstract class ChannelInterceptorBase implements ChannelInterceptor {
-
-    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(
-        ChannelInterceptorBase.class);
-
-    private ChannelInterceptor next;
-    private ChannelInterceptor previous;
-    //default value, always process
-    protected int optionFlag = 0;
-
-    public ChannelInterceptorBase() {
-
-    }
-    
-    public boolean okToProcess(int messageFlags) { 
-        if (this.optionFlag == 0 ) return true;
-        return ((optionFlag&messageFlags) == optionFlag);
-    }
-
-    public final void setNext(ChannelInterceptor next) {
-        this.next = next;
-    }
-
-    public final ChannelInterceptor getNext() {
-        return next;
-    }
-
-    public final void setPrevious(ChannelInterceptor previous) {
-        this.previous = previous;
-    }
-
-    public void setOptionFlag(int optionFlag) {
-        this.optionFlag = optionFlag;
-    }
-
-    public final ChannelInterceptor getPrevious() {
-        return previous;
-    }
-
-    public int getOptionFlag() {
-        return optionFlag;
-    }
-
-    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws
-        ChannelException {
-        if (getNext() != null) getNext().sendMessage(destination, msg, payload);
-    }
-
-    public void messageReceived(ChannelMessage msg) {
-        if (getPrevious() != null) getPrevious().messageReceived(msg);
-    }
-
-    public boolean accept(ChannelMessage msg) {
-        return true;
-    }
-
-    public void memberAdded(Member member) {
-        //notify upwards
-        if (getPrevious() != null) getPrevious().memberAdded(member);
-    }
-
-    public void memberDisappeared(Member member) {
-        //notify upwards
-        if (getPrevious() != null) getPrevious().memberDisappeared(member);
-    }
-
-    public void heartbeat() {
-        if (getNext() != null) getNext().heartbeat();
-    }
-
-    /**
-     * has members
-     */
-    public boolean hasMembers() {
-        if ( getNext()!=null )return getNext().hasMembers();
-        else return false;
-    }
-
-    /**
-     * Get all current cluster members
-     * @return all members or empty array
-     */
-    public Member[] getMembers() {
-        if ( getNext()!=null ) return getNext().getMembers();
-        else return null;
-    }
-
-    /**
-     *
-     * @param mbr Member
-     * @return Member
-     */
-    public Member getMember(Member mbr) {
-        if ( getNext()!=null) return getNext().getMember(mbr);
-        else return null;
-    }
-
-    /**
-     * Return the member that represents this node.
-     *
-     * @return Member
-     */
-    public Member getLocalMember(boolean incAlive) {
-        if ( getNext()!=null ) return getNext().getLocalMember(incAlive);
-        else return null;
-    }
-    
-    /**
-     * Starts up the channel. This can be called multiple times for individual services to start
-     * The svc parameter can be the logical or value of any constants
-     * @param svc int value of <BR>
-     * DEFAULT - will start all services <BR>
-     * MBR_RX_SEQ - starts the membership receiver <BR>
-     * MBR_TX_SEQ - starts the membership broadcaster <BR>
-     * SND_TX_SEQ - starts the replication transmitter<BR>
-     * SND_RX_SEQ - starts the replication receiver<BR>
-     * @throws ChannelException if a startup error occurs or the service is already started.
-     */
-    public void start(int svc) throws ChannelException {
-        if ( getNext()!=null ) getNext().start(svc);
-    }
-
-    /**
-     * Shuts down the channel. This can be called multiple times for individual services to shutdown
-     * The svc parameter can be the logical or value of any constants
-     * @param svc int value of <BR>
-     * DEFAULT - will shutdown all services <BR>
-     * MBR_RX_SEQ - stops the membership receiver <BR>
-     * MBR_TX_SEQ - stops the membership broadcaster <BR>
-     * SND_TX_SEQ - stops the replication transmitter<BR>
-     * SND_RX_SEQ - stops the replication receiver<BR>
-     * @throws ChannelException if a startup error occurs or the service is already started.
-     */
-    public void stop(int svc) throws ChannelException {
-        if (getNext() != null) getNext().stop(svc);
-    }
-    
-    public void fireInterceptorEvent(InterceptorEvent event) {
-        //empty operation
-    }
-
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.group;
+
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelInterceptor;
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.Member;
+
+/**
+ * Abstract class for the interceptor base class.
+ * @author Filip Hanik
+ * @version $Revision: 304032 $, $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
+ */
+
+public abstract class ChannelInterceptorBase implements ChannelInterceptor {
+
+    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(
+        ChannelInterceptorBase.class);
+
+    private ChannelInterceptor next;
+    private ChannelInterceptor previous;
+    //default value, always process
+    protected int optionFlag = 0;
+
+    public ChannelInterceptorBase() {
+
+    }
+    
+    public boolean okToProcess(int messageFlags) { 
+        if (this.optionFlag == 0 ) return true;
+        return ((optionFlag&messageFlags) == optionFlag);
+    }
+
+    public final void setNext(ChannelInterceptor next) {
+        this.next = next;
+    }
+
+    public final ChannelInterceptor getNext() {
+        return next;
+    }
+
+    public final void setPrevious(ChannelInterceptor previous) {
+        this.previous = previous;
+    }
+
+    public void setOptionFlag(int optionFlag) {
+        this.optionFlag = optionFlag;
+    }
+
+    public final ChannelInterceptor getPrevious() {
+        return previous;
+    }
+
+    public int getOptionFlag() {
+        return optionFlag;
+    }
+
+    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws
+        ChannelException {
+        if (getNext() != null) getNext().sendMessage(destination, msg, payload);
+    }
+
+    public void messageReceived(ChannelMessage msg) {
+        if (getPrevious() != null) getPrevious().messageReceived(msg);
+    }
+
+    public boolean accept(ChannelMessage msg) {
+        return true;
+    }
+
+    public void memberAdded(Member member) {
+        //notify upwards
+        if (getPrevious() != null) getPrevious().memberAdded(member);
+    }
+
+    public void memberDisappeared(Member member) {
+        //notify upwards
+        if (getPrevious() != null) getPrevious().memberDisappeared(member);
+    }
+
+    public void heartbeat() {
+        if (getNext() != null) getNext().heartbeat();
+    }
+
+    /**
+     * has members
+     */
+    public boolean hasMembers() {
+        if ( getNext()!=null )return getNext().hasMembers();
+        else return false;
+    }
+
+    /**
+     * Get all current cluster members
+     * @return all members or empty array
+     */
+    public Member[] getMembers() {
+        if ( getNext()!=null ) return getNext().getMembers();
+        else return null;
+    }
+
+    /**
+     *
+     * @param mbr Member
+     * @return Member
+     */
+    public Member getMember(Member mbr) {
+        if ( getNext()!=null) return getNext().getMember(mbr);
+        else return null;
+    }
+
+    /**
+     * Return the member that represents this node.
+     *
+     * @return Member
+     */
+    public Member getLocalMember(boolean incAlive) {
+        if ( getNext()!=null ) return getNext().getLocalMember(incAlive);
+        else return null;
+    }
+    
+    /**
+     * Starts up the channel. This can be called multiple times for individual services to start
+     * The svc parameter can be the logical or value of any constants
+     * @param svc int value of <BR>
+     * DEFAULT - will start all services <BR>
+     * MBR_RX_SEQ - starts the membership receiver <BR>
+     * MBR_TX_SEQ - starts the membership broadcaster <BR>
+     * SND_TX_SEQ - starts the replication transmitter<BR>
+     * SND_RX_SEQ - starts the replication receiver<BR>
+     * @throws ChannelException if a startup error occurs or the service is already started.
+     */
+    public void start(int svc) throws ChannelException {
+        if ( getNext()!=null ) getNext().start(svc);
+    }
+
+    /**
+     * Shuts down the channel. This can be called multiple times for individual services to shutdown
+     * The svc parameter can be the logical or value of any constants
+     * @param svc int value of <BR>
+     * DEFAULT - will shutdown all services <BR>
+     * MBR_RX_SEQ - stops the membership receiver <BR>
+     * MBR_TX_SEQ - stops the membership broadcaster <BR>
+     * SND_TX_SEQ - stops the replication transmitter<BR>
+     * SND_RX_SEQ - stops the replication receiver<BR>
+     * @throws ChannelException if a startup error occurs or the service is already started.
+     */
+    public void stop(int svc) throws ChannelException {
+        if (getNext() != null) getNext().stop(svc);
+    }
+    
+    public void fireInterceptorEvent(InterceptorEvent event) {
+        //empty operation
+    }
+
+
+}

==================================================
InterceptorPayload.java
index 161144fade..c12529e44c 100644
--- a/java/org/apache/catalina/tribes/group/GroupChannel.java
+++ b/java/org/apache/catalina/tribes/group/GroupChannel.java
@@ -1,666 +1,667 @@
-/*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.group;
-
-
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.Iterator;
-
-import org.apache.catalina.tribes.ByteMessage;
-import org.apache.catalina.tribes.Channel;
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelInterceptor;
-import org.apache.catalina.tribes.ChannelListener;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.ChannelReceiver;
-import org.apache.catalina.tribes.ChannelSender;
-import org.apache.catalina.tribes.ErrorHandler;
-import org.apache.catalina.tribes.ManagedChannel;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.MembershipListener;
-import org.apache.catalina.tribes.MembershipService;
-import org.apache.catalina.tribes.group.interceptors.MessageDispatchInterceptor;
-import org.apache.catalina.tribes.io.ChannelData;
-import org.apache.catalina.tribes.io.XByteBuffer;
-import org.apache.catalina.tribes.UniqueId;
-import org.apache.catalina.tribes.Heartbeat;
-import org.apache.catalina.tribes.io.BufferPool;
-import java.io.IOException;
-import org.apache.catalina.tribes.RemoteProcessException;
-import org.apache.catalina.tribes.util.Logs;
-import org.apache.catalina.tribes.util.Arrays;
-
-/**
- * The default implementation of a Channel.<br>
- * The GroupChannel manages the replication channel. It coordinates
- * message being sent and received with membership announcements.
- * The channel has an chain of interceptors that can modify the message or perform other logic.<br>
- * It manages a complete group, both membership and replication.
- * @author Filip Hanik
- * @version $Revision: 304032 $, $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
- */
-public class GroupChannel extends ChannelInterceptorBase implements ManagedChannel {
-    /**
-     * Flag to determine if the channel manages its own heartbeat
-     * If set to true, the channel will start a local thread for the heart beat.
-     */
-    protected boolean heartbeat = true;
-    /**
-     * If <code>heartbeat == true</code> then how often do we want this
-     * heartbeat to run. default is one minute
-     */
-    protected long heartbeatSleeptime = 5*1000;//every 5 seconds
-
-    /**
-     * Internal heartbeat thread
-     */
-    protected HeartbeatThread hbthread = null;
-
-    /**
-     * The  <code>ChannelCoordinator</code> coordinates the bottom layer components:<br>
-     * - MembershipService<br>
-     * - ChannelSender <br>
-     * - ChannelReceiver<br>
-     */
-    protected ChannelCoordinator coordinator = new ChannelCoordinator();
-
-    /**
-     * The first interceptor in the inteceptor stack.
-     * The interceptors are chained in a linked list, so we only need a reference to the
-     * first one
-     */
-    protected ChannelInterceptor interceptors = null;
-
-    /**
-     * A list of membership listeners that subscribe to membership announcements
-     */
-    protected ArrayList membershipListeners = new ArrayList();
-
-    /**
-     * A list of channel listeners that subscribe to incoming messages
-     */
-    protected ArrayList channelListeners = new ArrayList();
-
-    /**
-     * If set to true, the GroupChannel will check to make sure that
-     */
-    protected boolean optionCheck = false;
-
-    /**
-     * Creates a GroupChannel. This constructor will also
-     * add the first interceptor in the GroupChannel.<br>
-     * The first interceptor is always the channel itself.
-     */
-    public GroupChannel() {
-        addInterceptor(this);
-    }
-
-
-    /**
-     * Adds an interceptor to the stack for message processing<br>
-     * Interceptors are ordered in the way they are added.<br>
-     * <code>channel.addInterceptor(A);</code><br>
-     * <code>channel.addInterceptor(C);</code><br>
-     * <code>channel.addInterceptor(B);</code><br>
-     * Will result in a interceptor stack like this:<br>
-     * <code>A -> C -> B</code><br>
-     * The complete stack will look like this:<br>
-     * <code>Channel -> A -> C -> B -> ChannelCoordinator</code><br>
-     * @param interceptor ChannelInterceptorBase
-     */
-    public void addInterceptor(ChannelInterceptor interceptor) {
-        if ( interceptors == null ) {
-            interceptors = interceptor;
-            interceptors.setNext(coordinator);
-            interceptors.setPrevious(null);
-            coordinator.setPrevious(interceptors);
-        } else {
-            ChannelInterceptor last = interceptors;
-            while ( last.getNext() != coordinator ) {
-                last = last.getNext();
-            }
-            last.setNext(interceptor);
-            interceptor.setNext(coordinator);
-            interceptor.setPrevious(last);
-            coordinator.setPrevious(interceptor);
-        }
-    }
-
-    /**
-     * Sends a heartbeat through the interceptor stack.<br>
-     * Invoke this method from the application on a periodic basis if
-     * you have turned off internal heartbeats <code>channel.setHeartbeat(false)</code>
-     */
-    public void heartbeat() {
-        super.heartbeat();
-        Iterator i = membershipListeners.iterator();
-        while ( i.hasNext() ) {
-            Object o = i.next();
-            if ( o instanceof Heartbeat ) ((Heartbeat)o).heartbeat();
-        }
-        i = channelListeners.iterator();
-        while ( i.hasNext() ) {
-            Object o = i.next();
-            if ( o instanceof Heartbeat ) ((Heartbeat)o).heartbeat();
-        }
-
-    }
-
-
-    /**
-     * Send a message to the destinations specified
-     * @param destination Member[] - destination.length > 1
-     * @param msg Serializable - the message to send
-     * @param options int - sender options, options can trigger guarantee levels and different interceptors to
-     * react to the message see class documentation for the <code>Channel</code> object.<br>
-     * @return UniqueId - the unique Id that was assigned to this message
-     * @throws ChannelException - if an error occurs processing the message
-     * @see org.apache.catalina.tribes.Channel
-     */
-    public UniqueId send(Member[] destination, Serializable msg, int options) throws ChannelException {
-        return send(destination,msg,options,null);
-    }
-
-    /**
-     *
-     * @param destination Member[] - destination.length > 1
-     * @param msg Serializable - the message to send
-     * @param options int - sender options, options can trigger guarantee levels and different interceptors to
-     * react to the message see class documentation for the <code>Channel</code> object.<br>
-     * @param handler - callback object for error handling and completion notification, used when a message is
-     * sent asynchronously using the <code>Channel.SEND_OPTIONS_ASYNCHRONOUS</code> flag enabled.
-     * @return UniqueId - the unique Id that was assigned to this message
-     * @throws ChannelException - if an error occurs processing the message
-     * @see org.apache.catalina.tribes.Channel
-     */
-    public UniqueId send(Member[] destination, Serializable msg, int options, ErrorHandler handler) throws ChannelException {
-        if ( msg == null ) throw new ChannelException("Cant send a NULL message");
-        XByteBuffer buffer = null;
-        try {
-            if ( destination == null || destination.length == 0) throw new ChannelException("No destination given");
-            ChannelData data = new ChannelData(true);//generates a unique Id
-            data.setAddress(getLocalMember(false));
-            data.setTimestamp(System.currentTimeMillis());
-            byte[] b = null;
-            if ( msg instanceof ByteMessage ){
-                b = ((ByteMessage)msg).getMessage();
-                options = options | SEND_OPTIONS_BYTE_MESSAGE;
-            } else {
-                b = XByteBuffer.serialize(msg);
-                options = options & (~SEND_OPTIONS_BYTE_MESSAGE);
-            }
-            data.setOptions(options);
-            //XByteBuffer buffer = new XByteBuffer(b.length+128,false);
-            buffer = BufferPool.getBufferPool().getBuffer(b.length+128, false);
-            buffer.append(b,0,b.length);
-            data.setMessage(buffer);
-            InterceptorPayload payload = null;
-            if ( handler != null ) {
-                payload = new InterceptorPayload();
-                payload.setErrorHandler(handler);
-            }
-            getFirstInterceptor().sendMessage(destination, data, payload);
-            if ( Logs.MESSAGES.isTraceEnabled() ) {
-                Logs.MESSAGES.trace("GroupChannel - Sent msg:" + new UniqueId(data.getUniqueId()) + " at " +new java.sql.Timestamp(System.currentTimeMillis())+ " to "+Arrays.toNameString(destination));
-                Logs.MESSAGES.trace("GroupChannel - Send Message:" + new UniqueId(data.getUniqueId()) + " is " +msg);
-            }
-
-            return new UniqueId(data.getUniqueId());
-        }catch ( Exception x ) {
-            if ( x instanceof ChannelException ) throw (ChannelException)x;
-            throw new ChannelException(x);
-        } finally {
-            if ( buffer != null ) BufferPool.getBufferPool().returnBuffer(buffer);
-        }
-    }
-
-
-    /**
-     * Callback from the interceptor stack. <br>
-     * When a message is received from a remote node, this method will be invoked by
-     * the previous interceptor.<br>
-     * This method can also be used to send a message to other components within the same application,
-     * but its an extreme case, and you're probably better off doing that logic between the applications itself.
-     * @param msg ChannelMessage
-     */
-    public void messageReceived(ChannelMessage msg) {
-        if ( msg == null ) return;
-        try {
-            if ( Logs.MESSAGES.isTraceEnabled() ) {
-                Logs.MESSAGES.trace("GroupChannel - Received msg:" + new UniqueId(msg.getUniqueId()) + " at " +new java.sql.Timestamp(System.currentTimeMillis())+ " from "+msg.getAddress().getName());
-            }
-
-            Serializable fwd = null;
-            if ( (msg.getOptions() & SEND_OPTIONS_BYTE_MESSAGE) == SEND_OPTIONS_BYTE_MESSAGE ) {
-                fwd = new ByteMessage(msg.getMessage().getBytes());
-            } else {
-                fwd = XByteBuffer.deserialize(msg.getMessage().getBytesDirect(),0,msg.getMessage().getLength());
-            }
-            if ( Logs.MESSAGES.isTraceEnabled() ) {
-                Logs.MESSAGES.trace("GroupChannel - Receive Message:" + new UniqueId(msg.getUniqueId()) + " is " +fwd);
-            }
-
-            //get the actual member with the correct alive time
-            Member source = msg.getAddress();
-            boolean rx = false;
-            boolean delivered = false;
-            for ( int i=0; i<channelListeners.size(); i++ ) {
-                ChannelListener channelListener = (ChannelListener)channelListeners.get(i);
-                if (channelListener != null && channelListener.accept(fwd, source)) {
-                    channelListener.messageReceived(fwd, source);
-                    delivered = true;
-                    //if the message was accepted by an RPC channel, that channel
-                    //is responsible for returning the reply, otherwise we send an absence reply
-                    if ( channelListener instanceof RpcChannel ) rx = true;
-                }
-            }//for
-            if ((!rx) && (fwd instanceof RpcMessage)) {
-                //if we have a message that requires a response,
-                //but none was given, send back an immediate one
-                sendNoRpcChannelReply((RpcMessage)fwd,source);
-            }
-            if ( Logs.MESSAGES.isTraceEnabled() ) {
-                Logs.MESSAGES.trace("GroupChannel delivered["+delivered+"] id:"+new UniqueId(msg.getUniqueId()));
-            }
-
-        } catch ( Exception x ) {
-            if ( log.isDebugEnabled() ) log.error("Unable to process channel:IOException.",x);
-            throw new RemoteProcessException("IOException:"+x.getMessage(),x);
-        }
-    }
-
-    /**
-     * Sends a <code>NoRpcChannelReply</code> message to a member<br>
-     * This method gets invoked by the channel if a RPC message comes in
-     * and no channel listener accepts the message. This avoids timeout
-     * @param msg RpcMessage
-     * @param destination Member - the destination for the reply
-     */
-    protected void sendNoRpcChannelReply(RpcMessage msg, Member destination) {
-        try {
-            //avoid circular loop
-            if ( msg instanceof RpcMessage.NoRpcChannelReply) return;
-            RpcMessage.NoRpcChannelReply reply = new RpcMessage.NoRpcChannelReply(msg.rpcId,msg.uuid);
-            send(new Member[]{destination},reply,Channel.SEND_OPTIONS_ASYNCHRONOUS);
-        } catch ( Exception x ) {
-            log.error("Unable to find rpc channel, failed to send NoRpcChannelReply.",x);
-        }
-    }
-
-    /**
-     * memberAdded gets invoked by the interceptor below the channel
-     * and the channel will broadcast it to the membership listeners
-     * @param member Member - the new member
-     */
-    public void memberAdded(Member member) {
-        //notify upwards
-        for (int i=0; i<membershipListeners.size(); i++ ) {
-            MembershipListener membershipListener = (MembershipListener)membershipListeners.get(i);
-            if (membershipListener != null) membershipListener.memberAdded(member);
-        }
-    }
-
-    /**
-     * memberDisappeared gets invoked by the interceptor below the channel
-     * and the channel will broadcast it to the membership listeners
-     * @param member Member - the member that left or crashed
-     */
-    public void memberDisappeared(Member member) {
-        //notify upwards
-        for (int i=0; i<membershipListeners.size(); i++ ) {
-            MembershipListener membershipListener = (MembershipListener)membershipListeners.get(i);
-            if (membershipListener != null) membershipListener.memberDisappeared(member);
-        }
-    }
-
-    /**
-     * Sets up the default implementation interceptor stack
-     * if no interceptors have been added
-     * @throws ChannelException
-     */
-    protected synchronized void setupDefaultStack() throws ChannelException {
-
-        if ( getFirstInterceptor() != null &&
-             ((getFirstInterceptor().getNext() instanceof ChannelCoordinator))) {
-            ChannelInterceptor interceptor = null;
-            Class clazz = null;
-            try {
-                clazz = Class.forName("org.apache.catalina.tribes.group.interceptors.MessageDispatch15Interceptor",
-                                      true,GroupChannel.class.getClassLoader());
-                clazz.newInstance();
-            } catch ( Throwable x ) {
-                clazz = MessageDispatchInterceptor.class;
-            }//catch
-            try {
-                interceptor = (ChannelInterceptor) clazz.newInstance();
-            } catch (Exception x) {
-                throw new ChannelException("Unable to add MessageDispatchInterceptor to interceptor chain.",x);
-            }
-            this.addInterceptor(interceptor);
-        }
-    }
-
-    /**
-     * Validates the option flags that each interceptor is using and reports
-     * an error if two interceptor share the same flag.
-     * @throws ChannelException
-     */
-    protected void checkOptionFlags() throws ChannelException {
-        StringBuffer conflicts = new StringBuffer();
-        ChannelInterceptor first = interceptors;
-        while ( first != null ) {
-            int flag = first.getOptionFlag();
-            if ( flag != 0 ) {
-                ChannelInterceptor next = first.getNext();
-                while ( next != null ) {
-                    int nflag = next.getOptionFlag();
-                    if (nflag!=0 && (((flag & nflag) == flag ) || ((flag & nflag) == nflag)) ) {
-                        conflicts.append("[");
-                        conflicts.append(first.getClass().getName());
-                        conflicts.append(":");
-                        conflicts.append(flag);
-                        conflicts.append(" == ");
-                        conflicts.append(next.getClass().getName());
-                        conflicts.append(":");
-                        conflicts.append(nflag);
-                        conflicts.append("] ");
-                    }//end if
-                    next = next.getNext();
-                }//while
-            }//end if
-            first = first.getNext();
-        }//while
-        if ( conflicts.length() > 0 ) throw new ChannelException("Interceptor option flag conflict: "+conflicts.toString());
-
-    }
-
-    /**
-     * Starts the channel
-     * @param svc int - what service to start
-     * @throws ChannelException
-     * @see org.apache.catalina.tribes.Channel#start(int)
-     */
-    public synchronized void start(int svc) throws ChannelException {
-        setupDefaultStack();
-        if (optionCheck) checkOptionFlags();
-        super.start(svc);
-        if ( hbthread == null && heartbeat ) {
-            hbthread = new HeartbeatThread(this,heartbeatSleeptime);
-            hbthread.start();
-        }
-    }
-
-    /**
-     * Stops the channel
-     * @param svc int
-     * @throws ChannelException
-     * @see org.apache.catalina.tribes.Channel#stop(int)
-     */
-    public synchronized void stop(int svc) throws ChannelException {
-        if (hbthread != null) {
-            hbthread.stopHeartbeat();
-            hbthread = null;
-        }
-        super.stop(svc);
-    }
-
-    /**
-     * Returns the first interceptor of the stack. Useful for traversal.
-     * @return ChannelInterceptor
-     */
-    public ChannelInterceptor getFirstInterceptor() {
-        if (interceptors != null) return interceptors;
-        else return coordinator;
-    }
-
-    /**
-     * Returns the channel receiver component
-     * @return ChannelReceiver
-     */
-    public ChannelReceiver getChannelReceiver() {
-        return coordinator.getClusterReceiver();
-    }
-
-    /**
-     * Returns the channel sender component
-     * @return ChannelSender
-     */
-    public ChannelSender getChannelSender() {
-        return coordinator.getClusterSender();
-    }
-
-    /**
-     * Returns the membership service component
-     * @return MembershipService
-     */
-    public MembershipService getMembershipService() {
-        return coordinator.getMembershipService();
-    }
-
-    /**
-     * Sets the channel receiver component
-     * @param clusterReceiver ChannelReceiver
-     */
-    public void setChannelReceiver(ChannelReceiver clusterReceiver) {
-        coordinator.setClusterReceiver(clusterReceiver);
-    }
-
-    /**
-     * Sets the channel sender component
-     * @param clusterSender ChannelSender
-     */
-    public void setChannelSender(ChannelSender clusterSender) {
-        coordinator.setClusterSender(clusterSender);
-    }
-
-    /**
-     * Sets the membership component
-     * @param membershipService MembershipService
-     */
-    public void setMembershipService(MembershipService membershipService) {
-        coordinator.setMembershipService(membershipService);
-    }
-
-    /**
-     * Adds a membership listener to the channel.<br>
-     * Membership listeners are uniquely identified using the equals(Object) method
-     * @param membershipListener MembershipListener
-     */
-    public void addMembershipListener(MembershipListener membershipListener) {
-        if (!this.membershipListeners.contains(membershipListener) )
-            this.membershipListeners.add(membershipListener);
-    }
-
-    /**
-     * Removes a membership listener from the channel.<br>
-     * Membership listeners are uniquely identified using the equals(Object) method
-     * @param membershipListener MembershipListener
-     */
-
-    public void removeMembershipListener(MembershipListener membershipListener) {
-        membershipListeners.remove(membershipListener);
-    }
-
-    /**
-     * Adds a channel listener to the channel.<br>
-     * Channel listeners are uniquely identified using the equals(Object) method
-     * @param channelListener ChannelListener
-     */
-    public void addChannelListener(ChannelListener channelListener) {
-        if (!this.channelListeners.contains(channelListener) ) {
-            this.channelListeners.add(channelListener);
-        } else {
-            throw new IllegalArgumentException("Listener already exists:"+channelListener+"["+channelListener.getClass().getName()+"]");
-        }
-    }
-
-    /**
-     *
-     * Removes a channel listener from the channel.<br>
-     * Channel listeners are uniquely identified using the equals(Object) method
-     * @param channelListener ChannelListener
-     */
-    public void removeChannelListener(ChannelListener channelListener) {
-        channelListeners.remove(channelListener);
-    }
-
-    /**
-     * Returns an iterator of all the interceptors in this stack
-     * @return Iterator
-     */
-    public Iterator getInterceptors() {
-        return new InterceptorIterator(this.getNext(),this.coordinator);
-    }
-
-    /**
-     * Enables/disables the option check<br>
-     * Setting this to true, will make the GroupChannel perform a conflict check
-     * on the interceptors. If two interceptors are using the same option flag
-     * and throw an error upon start.
-     * @param optionCheck boolean
-     */
-    public void setOptionCheck(boolean optionCheck) {
-        this.optionCheck = optionCheck;
-    }
-
-    /**
-     * Configure local heartbeat sleep time<br>
-     * Only used when <code>getHeartbeat()==true</code>
-     * @param heartbeatSleeptime long - time in milliseconds to sleep between heartbeats
-     */
-    public void setHeartbeatSleeptime(long heartbeatSleeptime) {
-        this.heartbeatSleeptime = heartbeatSleeptime;
-    }
-
-    /**
-     * Enables or disables local heartbeat.
-     * if <code>setHeartbeat(true)</code> is invoked then the channel will start an internal
-     * thread to invoke <code>Channel.heartbeat()</code> every <code>getHeartbeatSleeptime</code> milliseconds
-     * @param heartbeat boolean
-     */
-    public void setHeartbeat(boolean heartbeat) {
-        this.heartbeat = heartbeat;
-    }
-
-    /**
-     * @see #setOptionCheck(boolean)
-     * @return boolean
-     */
-    public boolean getOptionCheck() {
-        return optionCheck;
-    }
-
-    /**
-     * @see #setHeartbeat(boolean)
-     * @return boolean
-     */
-    public boolean getHeartbeat() {
-        return heartbeat;
-    }
-
-    /**
-     * Returns the sleep time in milliseconds that the internal heartbeat will
-     * sleep in between invokations of <code>Channel.heartbeat()</code>
-     * @return long
-     */
-    public long getHeartbeatSleeptime() {
-        return heartbeatSleeptime;
-    }
-
-    /**
-     *
-     * <p>Title: Interceptor Iterator</p>
-     *
-     * <p>Description: An iterator to loop through the interceptors in a channel</p>
-     *
-     * @version 1.0
-     */
-    public static class InterceptorIterator implements Iterator {
-        private ChannelInterceptor end;
-        private ChannelInterceptor start;
-        public InterceptorIterator(ChannelInterceptor start, ChannelInterceptor end) {
-            this.end = end;
-            this.start = start;
-        }
-
-        public boolean hasNext() {
-            return start!=null && start != end;
-        }
-
-        public Object next() {
-            Object result = null;
-            if ( hasNext() ) {
-                result = start;
-                start = start.getNext();
-            }
-            return result;
-        }
-
-        public void remove() {
-            //empty operation
-        }
-    }
-
-    /**
-     *
-     * <p>Title: Internal heartbeat thread</p>
-     *
-     * <p>Description: if <code>Channel.getHeartbeat()==true</code> then a thread of this class
-     * is created</p>
-     *
-     * @version 1.0
-     */
-    public static class HeartbeatThread extends Thread {
-        protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(HeartbeatThread.class);
-        protected static int counter = 1;
-        protected static synchronized int inc() {
-            return counter++;
-        }
-
-        protected boolean doRun = true;
-        protected GroupChannel channel;
-        protected long sleepTime;
-        public HeartbeatThread(GroupChannel channel, long sleepTime) {
-            super();
-            this.setPriority(MIN_PRIORITY);
-            setName("GroupChannel-Heartbeat-"+inc());
-            setDaemon(true);
-            this.channel = channel;
-            this.sleepTime = sleepTime;
-        }
-        public void stopHeartbeat() {
-            doRun = false;
-            interrupt();
-        }
-
-        public void run() {
-            while (doRun) {
-                try {
-                    Thread.sleep(sleepTime);
-                    channel.heartbeat();
-                } catch ( InterruptedException x ) {
-                    interrupted();
-                } catch ( Exception x ) {
-                    log.error("Unable to send heartbeat through Tribes interceptor stack. Will try to sleep again.",x);
-                }//catch
-            }//while
-        }//run
-    }//HeartbeatThread
-
-
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.group;
+
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Iterator;
+
+import org.apache.catalina.tribes.ByteMessage;
+import org.apache.catalina.tribes.Channel;
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelInterceptor;
+import org.apache.catalina.tribes.ChannelListener;
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.ChannelReceiver;
+import org.apache.catalina.tribes.ChannelSender;
+import org.apache.catalina.tribes.ErrorHandler;
+import org.apache.catalina.tribes.ManagedChannel;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.MembershipListener;
+import org.apache.catalina.tribes.MembershipService;
+import org.apache.catalina.tribes.group.interceptors.MessageDispatchInterceptor;
+import org.apache.catalina.tribes.io.ChannelData;
+import org.apache.catalina.tribes.io.XByteBuffer;
+import org.apache.catalina.tribes.UniqueId;
+import org.apache.catalina.tribes.Heartbeat;
+import org.apache.catalina.tribes.io.BufferPool;
+import java.io.IOException;
+import org.apache.catalina.tribes.RemoteProcessException;
+import org.apache.catalina.tribes.util.Logs;
+import org.apache.catalina.tribes.util.Arrays;
+
+/**
+ * The default implementation of a Channel.<br>
+ * The GroupChannel manages the replication channel. It coordinates
+ * message being sent and received with membership announcements.
+ * The channel has an chain of interceptors that can modify the message or perform other logic.<br>
+ * It manages a complete group, both membership and replication.
+ * @author Filip Hanik
+ * @version $Revision: 304032 $, $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
+ */
+public class GroupChannel extends ChannelInterceptorBase implements ManagedChannel {
+    /**
+     * Flag to determine if the channel manages its own heartbeat
+     * If set to true, the channel will start a local thread for the heart beat.
+     */
+    protected boolean heartbeat = true;
+    /**
+     * If <code>heartbeat == true</code> then how often do we want this
+     * heartbeat to run. default is one minute
+     */
+    protected long heartbeatSleeptime = 5*1000;//every 5 seconds
+
+    /**
+     * Internal heartbeat thread
+     */
+    protected HeartbeatThread hbthread = null;
+
+    /**
+     * The  <code>ChannelCoordinator</code> coordinates the bottom layer components:<br>
+     * - MembershipService<br>
+     * - ChannelSender <br>
+     * - ChannelReceiver<br>
+     */
+    protected ChannelCoordinator coordinator = new ChannelCoordinator();
+
+    /**
+     * The first interceptor in the inteceptor stack.
+     * The interceptors are chained in a linked list, so we only need a reference to the
+     * first one
+     */
+    protected ChannelInterceptor interceptors = null;
+
+    /**
+     * A list of membership listeners that subscribe to membership announcements
+     */
+    protected ArrayList membershipListeners = new ArrayList();
+
+    /**
+     * A list of channel listeners that subscribe to incoming messages
+     */
+    protected ArrayList channelListeners = new ArrayList();
+
+    /**
+     * If set to true, the GroupChannel will check to make sure that
+     */
+    protected boolean optionCheck = false;
+
+    /**
+     * Creates a GroupChannel. This constructor will also
+     * add the first interceptor in the GroupChannel.<br>
+     * The first interceptor is always the channel itself.
+     */
+    public GroupChannel() {
+        addInterceptor(this);
+    }
+
+
+    /**
+     * Adds an interceptor to the stack for message processing<br>
+     * Interceptors are ordered in the way they are added.<br>
+     * <code>channel.addInterceptor(A);</code><br>
+     * <code>channel.addInterceptor(C);</code><br>
+     * <code>channel.addInterceptor(B);</code><br>
+     * Will result in a interceptor stack like this:<br>
+     * <code>A -> C -> B</code><br>
+     * The complete stack will look like this:<br>
+     * <code>Channel -> A -> C -> B -> ChannelCoordinator</code><br>
+     * @param interceptor ChannelInterceptorBase
+     */
+    public void addInterceptor(ChannelInterceptor interceptor) {
+        if ( interceptors == null ) {
+            interceptors = interceptor;
+            interceptors.setNext(coordinator);
+            interceptors.setPrevious(null);
+            coordinator.setPrevious(interceptors);
+        } else {
+            ChannelInterceptor last = interceptors;
+            while ( last.getNext() != coordinator ) {
+                last = last.getNext();
+            }
+            last.setNext(interceptor);
+            interceptor.setNext(coordinator);
+            interceptor.setPrevious(last);
+            coordinator.setPrevious(interceptor);
+        }
+    }
+
+    /**
+     * Sends a heartbeat through the interceptor stack.<br>
+     * Invoke this method from the application on a periodic basis if
+     * you have turned off internal heartbeats <code>channel.setHeartbeat(false)</code>
+     */
+    public void heartbeat() {
+        super.heartbeat();
+        Iterator i = membershipListeners.iterator();
+        while ( i.hasNext() ) {
+            Object o = i.next();
+            if ( o instanceof Heartbeat ) ((Heartbeat)o).heartbeat();
+        }
+        i = channelListeners.iterator();
+        while ( i.hasNext() ) {
+            Object o = i.next();
+            if ( o instanceof Heartbeat ) ((Heartbeat)o).heartbeat();
+        }
+
+    }
+
+
+    /**
+     * Send a message to the destinations specified
+     * @param destination Member[] - destination.length > 1
+     * @param msg Serializable - the message to send
+     * @param options int - sender options, options can trigger guarantee levels and different interceptors to
+     * react to the message see class documentation for the <code>Channel</code> object.<br>
+     * @return UniqueId - the unique Id that was assigned to this message
+     * @throws ChannelException - if an error occurs processing the message
+     * @see org.apache.catalina.tribes.Channel
+     */
+    public UniqueId send(Member[] destination, Serializable msg, int options) throws ChannelException {
+        return send(destination,msg,options,null);
+    }
+
+    /**
+     *
+     * @param destination Member[] - destination.length > 1
+     * @param msg Serializable - the message to send
+     * @param options int - sender options, options can trigger guarantee levels and different interceptors to
+     * react to the message see class documentation for the <code>Channel</code> object.<br>
+     * @param handler - callback object for error handling and completion notification, used when a message is
+     * sent asynchronously using the <code>Channel.SEND_OPTIONS_ASYNCHRONOUS</code> flag enabled.
+     * @return UniqueId - the unique Id that was assigned to this message
+     * @throws ChannelException - if an error occurs processing the message
+     * @see org.apache.catalina.tribes.Channel
+     */
+    public UniqueId send(Member[] destination, Serializable msg, int options, ErrorHandler handler) throws ChannelException {
+        if ( msg == null ) throw new ChannelException("Cant send a NULL message");
+        XByteBuffer buffer = null;
+        try {
+            if ( destination == null || destination.length == 0) throw new ChannelException("No destination given");
+            ChannelData data = new ChannelData(true);//generates a unique Id
+            data.setAddress(getLocalMember(false));
+            data.setTimestamp(System.currentTimeMillis());
+            byte[] b = null;
+            if ( msg instanceof ByteMessage ){
+                b = ((ByteMessage)msg).getMessage();
+                options = options | SEND_OPTIONS_BYTE_MESSAGE;
+            } else {
+                b = XByteBuffer.serialize(msg);
+                options = options & (~SEND_OPTIONS_BYTE_MESSAGE);
+            }
+            data.setOptions(options);
+            //XByteBuffer buffer = new XByteBuffer(b.length+128,false);
+            buffer = BufferPool.getBufferPool().getBuffer(b.length+128, false);
+            buffer.append(b,0,b.length);
+            data.setMessage(buffer);
+            InterceptorPayload payload = null;
+            if ( handler != null ) {
+                payload = new InterceptorPayload();
+                payload.setErrorHandler(handler);
+            }
+            getFirstInterceptor().sendMessage(destination, data, payload);
+            if ( Logs.MESSAGES.isTraceEnabled() ) {
+                Logs.MESSAGES.trace("GroupChannel - Sent msg:" + new UniqueId(data.getUniqueId()) + " at " +new java.sql.Timestamp(System.currentTimeMillis())+ " to "+Arrays.toNameString(destination));
+                Logs.MESSAGES.trace("GroupChannel - Send Message:" + new UniqueId(data.getUniqueId()) + " is " +msg);
+            }
+
+            return new UniqueId(data.getUniqueId());
+        }catch ( Exception x ) {
+            if ( x instanceof ChannelException ) throw (ChannelException)x;
+            throw new ChannelException(x);
+        } finally {
+            if ( buffer != null ) BufferPool.getBufferPool().returnBuffer(buffer);
+        }
+    }
+
+
+    /**
+     * Callback from the interceptor stack. <br>
+     * When a message is received from a remote node, this method will be invoked by
+     * the previous interceptor.<br>
+     * This method can also be used to send a message to other components within the same application,
+     * but its an extreme case, and you're probably better off doing that logic between the applications itself.
+     * @param msg ChannelMessage
+     */
+    public void messageReceived(ChannelMessage msg) {
+        if ( msg == null ) return;
+        try {
+            if ( Logs.MESSAGES.isTraceEnabled() ) {
+                Logs.MESSAGES.trace("GroupChannel - Received msg:" + new UniqueId(msg.getUniqueId()) + " at " +new java.sql.Timestamp(System.currentTimeMillis())+ " from "+msg.getAddress().getName());
+            }
+
+            Serializable fwd = null;
+            if ( (msg.getOptions() & SEND_OPTIONS_BYTE_MESSAGE) == SEND_OPTIONS_BYTE_MESSAGE ) {
+                fwd = new ByteMessage(msg.getMessage().getBytes());
+            } else {
+                fwd = XByteBuffer.deserialize(msg.getMessage().getBytesDirect(),0,msg.getMessage().getLength());
+            }
+            if ( Logs.MESSAGES.isTraceEnabled() ) {
+                Logs.MESSAGES.trace("GroupChannel - Receive Message:" + new UniqueId(msg.getUniqueId()) + " is " +fwd);
+            }
+
+            //get the actual member with the correct alive time
+            Member source = msg.getAddress();
+            boolean rx = false;
+            boolean delivered = false;
+            for ( int i=0; i<channelListeners.size(); i++ ) {
+                ChannelListener channelListener = (ChannelListener)channelListeners.get(i);
+                if (channelListener != null && channelListener.accept(fwd, source)) {
+                    channelListener.messageReceived(fwd, source);
+                    delivered = true;
+                    //if the message was accepted by an RPC channel, that channel
+                    //is responsible for returning the reply, otherwise we send an absence reply
+                    if ( channelListener instanceof RpcChannel ) rx = true;
+                }
+            }//for
+            if ((!rx) && (fwd instanceof RpcMessage)) {
+                //if we have a message that requires a response,
+                //but none was given, send back an immediate one
+                sendNoRpcChannelReply((RpcMessage)fwd,source);
+            }
+            if ( Logs.MESSAGES.isTraceEnabled() ) {
+                Logs.MESSAGES.trace("GroupChannel delivered["+delivered+"] id:"+new UniqueId(msg.getUniqueId()));
+            }
+
+        } catch ( Exception x ) {
+            if ( log.isDebugEnabled() ) log.error("Unable to process channel:IOException.",x);
+            throw new RemoteProcessException("IOException:"+x.getMessage(),x);
+        }
+    }
+
+    /**
+     * Sends a <code>NoRpcChannelReply</code> message to a member<br>
+     * This method gets invoked by the channel if a RPC message comes in
+     * and no channel listener accepts the message. This avoids timeout
+     * @param msg RpcMessage
+     * @param destination Member - the destination for the reply
+     */
+    protected void sendNoRpcChannelReply(RpcMessage msg, Member destination) {
+        try {
+            //avoid circular loop
+            if ( msg instanceof RpcMessage.NoRpcChannelReply) return;
+            RpcMessage.NoRpcChannelReply reply = new RpcMessage.NoRpcChannelReply(msg.rpcId,msg.uuid);
+            send(new Member[]{destination},reply,Channel.SEND_OPTIONS_ASYNCHRONOUS);
+        } catch ( Exception x ) {
+            log.error("Unable to find rpc channel, failed to send NoRpcChannelReply.",x);
+        }
+    }
+
+    /**
+     * memberAdded gets invoked by the interceptor below the channel
+     * and the channel will broadcast it to the membership listeners
+     * @param member Member - the new member
+     */
+    public void memberAdded(Member member) {
+        //notify upwards
+        for (int i=0; i<membershipListeners.size(); i++ ) {
+            MembershipListener membershipListener = (MembershipListener)membershipListeners.get(i);
+            if (membershipListener != null) membershipListener.memberAdded(member);
+        }
+    }
+
+    /**
+     * memberDisappeared gets invoked by the interceptor below the channel
+     * and the channel will broadcast it to the membership listeners
+     * @param member Member - the member that left or crashed
+     */
+    public void memberDisappeared(Member member) {
+        //notify upwards
+        for (int i=0; i<membershipListeners.size(); i++ ) {
+            MembershipListener membershipListener = (MembershipListener)membershipListeners.get(i);
+            if (membershipListener != null) membershipListener.memberDisappeared(member);
+        }
+    }
+
+    /**
+     * Sets up the default implementation interceptor stack
+     * if no interceptors have been added
+     * @throws ChannelException
+     */
+    protected synchronized void setupDefaultStack() throws ChannelException {
+
+        if ( getFirstInterceptor() != null &&
+             ((getFirstInterceptor().getNext() instanceof ChannelCoordinator))) {
+            ChannelInterceptor interceptor = null;
+            Class clazz = null;
+            try {
+                clazz = Class.forName("org.apache.catalina.tribes.group.interceptors.MessageDispatch15Interceptor",
+                                      true,GroupChannel.class.getClassLoader());
+                clazz.newInstance();
+            } catch ( Throwable x ) {
+                clazz = MessageDispatchInterceptor.class;
+            }//catch
+            try {
+                interceptor = (ChannelInterceptor) clazz.newInstance();
+            } catch (Exception x) {
+                throw new ChannelException("Unable to add MessageDispatchInterceptor to interceptor chain.",x);
+            }
+            this.addInterceptor(interceptor);
+        }
+    }
+
+    /**
+     * Validates the option flags that each interceptor is using and reports
+     * an error if two interceptor share the same flag.
+     * @throws ChannelException
+     */
+    protected void checkOptionFlags() throws ChannelException {
+        StringBuffer conflicts = new StringBuffer();
+        ChannelInterceptor first = interceptors;
+        while ( first != null ) {
+            int flag = first.getOptionFlag();
+            if ( flag != 0 ) {
+                ChannelInterceptor next = first.getNext();
+                while ( next != null ) {
+                    int nflag = next.getOptionFlag();
+                    if (nflag!=0 && (((flag & nflag) == flag ) || ((flag & nflag) == nflag)) ) {
+                        conflicts.append("[");
+                        conflicts.append(first.getClass().getName());
+                        conflicts.append(":");
+                        conflicts.append(flag);
+                        conflicts.append(" == ");
+                        conflicts.append(next.getClass().getName());
+                        conflicts.append(":");
+                        conflicts.append(nflag);
+                        conflicts.append("] ");
+                    }//end if
+                    next = next.getNext();
+                }//while
+            }//end if
+            first = first.getNext();
+        }//while
+        if ( conflicts.length() > 0 ) throw new ChannelException("Interceptor option flag conflict: "+conflicts.toString());
+
+    }
+
+    /**
+     * Starts the channel
+     * @param svc int - what service to start
+     * @throws ChannelException
+     * @see org.apache.catalina.tribes.Channel#start(int)
+     */
+    public synchronized void start(int svc) throws ChannelException {
+        setupDefaultStack();
+        if (optionCheck) checkOptionFlags();
+        super.start(svc);
+        if ( hbthread == null && heartbeat ) {
+            hbthread = new HeartbeatThread(this,heartbeatSleeptime);
+            hbthread.start();
+        }
+    }
+
+    /**
+     * Stops the channel
+     * @param svc int
+     * @throws ChannelException
+     * @see org.apache.catalina.tribes.Channel#stop(int)
+     */
+    public synchronized void stop(int svc) throws ChannelException {
+        if (hbthread != null) {
+            hbthread.stopHeartbeat();
+            hbthread = null;
+        }
+        super.stop(svc);
+    }
+
+    /**
+     * Returns the first interceptor of the stack. Useful for traversal.
+     * @return ChannelInterceptor
+     */
+    public ChannelInterceptor getFirstInterceptor() {
+        if (interceptors != null) return interceptors;
+        else return coordinator;
+    }
+
+    /**
+     * Returns the channel receiver component
+     * @return ChannelReceiver
+     */
+    public ChannelReceiver getChannelReceiver() {
+        return coordinator.getClusterReceiver();
+    }
+
+    /**
+     * Returns the channel sender component
+     * @return ChannelSender
+     */
+    public ChannelSender getChannelSender() {
+        return coordinator.getClusterSender();
+    }
+
+    /**
+     * Returns the membership service component
+     * @return MembershipService
+     */
+    public MembershipService getMembershipService() {
+        return coordinator.getMembershipService();
+    }
+
+    /**
+     * Sets the channel receiver component
+     * @param clusterReceiver ChannelReceiver
+     */
+    public void setChannelReceiver(ChannelReceiver clusterReceiver) {
+        coordinator.setClusterReceiver(clusterReceiver);
+    }
+
+    /**
+     * Sets the channel sender component
+     * @param clusterSender ChannelSender
+     */
+    public void setChannelSender(ChannelSender clusterSender) {
+        coordinator.setClusterSender(clusterSender);
+    }
+
+    /**
+     * Sets the membership component
+     * @param membershipService MembershipService
+     */
+    public void setMembershipService(MembershipService membershipService) {
+        coordinator.setMembershipService(membershipService);
+    }
+
+    /**
+     * Adds a membership listener to the channel.<br>
+     * Membership listeners are uniquely identified using the equals(Object) method
+     * @param membershipListener MembershipListener
+     */
+    public void addMembershipListener(MembershipListener membershipListener) {
+        if (!this.membershipListeners.contains(membershipListener) )
+            this.membershipListeners.add(membershipListener);
+    }
+
+    /**
+     * Removes a membership listener from the channel.<br>
+     * Membership listeners are uniquely identified using the equals(Object) method
+     * @param membershipListener MembershipListener
+     */
+
+    public void removeMembershipListener(MembershipListener membershipListener) {
+        membershipListeners.remove(membershipListener);
+    }
+
+    /**
+     * Adds a channel listener to the channel.<br>
+     * Channel listeners are uniquely identified using the equals(Object) method
+     * @param channelListener ChannelListener
+     */
+    public void addChannelListener(ChannelListener channelListener) {
+        if (!this.channelListeners.contains(channelListener) ) {
+            this.channelListeners.add(channelListener);
+        } else {
+            throw new IllegalArgumentException("Listener already exists:"+channelListener+"["+channelListener.getClass().getName()+"]");
+        }
+    }
+
+    /**
+     *
+     * Removes a channel listener from the channel.<br>
+     * Channel listeners are uniquely identified using the equals(Object) method
+     * @param channelListener ChannelListener
+     */
+    public void removeChannelListener(ChannelListener channelListener) {
+        channelListeners.remove(channelListener);
+    }
+
+    /**
+     * Returns an iterator of all the interceptors in this stack
+     * @return Iterator
+     */
+    public Iterator getInterceptors() {
+        return new InterceptorIterator(this.getNext(),this.coordinator);
+    }
+
+    /**
+     * Enables/disables the option check<br>
+     * Setting this to true, will make the GroupChannel perform a conflict check
+     * on the interceptors. If two interceptors are using the same option flag
+     * and throw an error upon start.
+     * @param optionCheck boolean
+     */
+    public void setOptionCheck(boolean optionCheck) {
+        this.optionCheck = optionCheck;
+    }
+
+    /**
+     * Configure local heartbeat sleep time<br>
+     * Only used when <code>getHeartbeat()==true</code>
+     * @param heartbeatSleeptime long - time in milliseconds to sleep between heartbeats
+     */
+    public void setHeartbeatSleeptime(long heartbeatSleeptime) {
+        this.heartbeatSleeptime = heartbeatSleeptime;
+    }
+
+    /**
+     * Enables or disables local heartbeat.
+     * if <code>setHeartbeat(true)</code> is invoked then the channel will start an internal
+     * thread to invoke <code>Channel.heartbeat()</code> every <code>getHeartbeatSleeptime</code> milliseconds
+     * @param heartbeat boolean
+     */
+    public void setHeartbeat(boolean heartbeat) {
+        this.heartbeat = heartbeat;
+    }
+
+    /**
+     * @see #setOptionCheck(boolean)
+     * @return boolean
+     */
+    public boolean getOptionCheck() {
+        return optionCheck;
+    }
+
+    /**
+     * @see #setHeartbeat(boolean)
+     * @return boolean
+     */
+    public boolean getHeartbeat() {
+        return heartbeat;
+    }
+
+    /**
+     * Returns the sleep time in milliseconds that the internal heartbeat will
+     * sleep in between invokations of <code>Channel.heartbeat()</code>
+     * @return long
+     */
+    public long getHeartbeatSleeptime() {
+        return heartbeatSleeptime;
+    }
+
+    /**
+     *
+     * <p>Title: Interceptor Iterator</p>
+     *
+     * <p>Description: An iterator to loop through the interceptors in a channel</p>
+     *
+     * @version 1.0
+     */
+    public static class InterceptorIterator implements Iterator {
+        private ChannelInterceptor end;
+        private ChannelInterceptor start;
+        public InterceptorIterator(ChannelInterceptor start, ChannelInterceptor end) {
+            this.end = end;
+            this.start = start;
+        }
+
+        public boolean hasNext() {
+            return start!=null && start != end;
+        }
+
+        public Object next() {
+            Object result = null;
+            if ( hasNext() ) {
+                result = start;
+                start = start.getNext();
+            }
+            return result;
+        }
+
+        public void remove() {
+            //empty operation
+        }
+    }
+
+    /**
+     *
+     * <p>Title: Internal heartbeat thread</p>
+     *
+     * <p>Description: if <code>Channel.getHeartbeat()==true</code> then a thread of this class
+     * is created</p>
+     *
+     * @version 1.0
+     */
+    public static class HeartbeatThread extends Thread {
+        protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(HeartbeatThread.class);
+        protected static int counter = 1;
+        protected static synchronized int inc() {
+            return counter++;
+        }
+
+        protected boolean doRun = true;
+        protected GroupChannel channel;
+        protected long sleepTime;
+        public HeartbeatThread(GroupChannel channel, long sleepTime) {
+            super();
+            this.setPriority(MIN_PRIORITY);
+            setName("GroupChannel-Heartbeat-"+inc());
+            setDaemon(true);
+            this.channel = channel;
+            this.sleepTime = sleepTime;
+        }
+        public void stopHeartbeat() {
+            doRun = false;
+            interrupt();
+        }
+
+        public void run() {
+            while (doRun) {
+                try {
+                    Thread.sleep(sleepTime);
+                    channel.heartbeat();
+                } catch ( InterruptedException x ) {
+                    interrupted();
+                } catch ( Exception x ) {
+                    log.error("Unable to send heartbeat through Tribes interceptor stack. Will try to sleep again.",x);
+                }//catch
+            }//while
+        }//run
+    }//HeartbeatThread
+
+
+
+}

==================================================
Response.java
index 96902ef0b0..61b7bcf7d0 100644
--- a/java/org/apache/catalina/tribes/group/InterceptorPayload.java
+++ b/java/org/apache/catalina/tribes/group/InterceptorPayload.java
@@ -1,34 +1,35 @@
-/*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.group;
-
-import org.apache.catalina.tribes.ErrorHandler;
-
-/**
- * @author Filip Hanik
- * @version 1.0
- */
-public class InterceptorPayload  {
-    private ErrorHandler errorHandler;
-    
-    public ErrorHandler getErrorHandler() {
-        return errorHandler;
-    }
-
-    public void setErrorHandler(ErrorHandler errorHandler) {
-        this.errorHandler = errorHandler;
-    }
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.group;
+
+import org.apache.catalina.tribes.ErrorHandler;
+
+/**
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class InterceptorPayload  {
+    private ErrorHandler errorHandler;
+    
+    public ErrorHandler getErrorHandler() {
+        return errorHandler;
+    }
+
+    public void setErrorHandler(ErrorHandler errorHandler) {
+        this.errorHandler = errorHandler;
+    }
 }
\ No newline at end of file

==================================================
RpcCallback.java
index 1a7f88f2f0..03ee1d0b80 100644
--- a/java/org/apache/catalina/tribes/group/Response.java
+++ b/java/org/apache/catalina/tribes/group/Response.java
@@ -1,53 +1,54 @@
-/*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.group;
-
-import java.io.Serializable;
-
-import org.apache.catalina.tribes.Member;
-
-/**
- * A response object holds a message from a responding partner.
- * @author Filip Hanik
- * @version 1.0
- */
-public class Response {
-    private Member source;
-    private Serializable message;
-    public Response() {
-    }
-    
-    public Response(Member source, Serializable message) {
-        this.source = source;
-        this.message = message;
-    }
-
-    public void setSource(Member source) {
-        this.source = source;
-    }
-
-    public void setMessage(Serializable message) {
-        this.message = message;
-    }
-
-    public Member getSource() {
-        return source;
-    }
-
-    public Serializable getMessage() {
-        return message;
-    }
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.group;
+
+import java.io.Serializable;
+
+import org.apache.catalina.tribes.Member;
+
+/**
+ * A response object holds a message from a responding partner.
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class Response {
+    private Member source;
+    private Serializable message;
+    public Response() {
+    }
+    
+    public Response(Member source, Serializable message) {
+        this.source = source;
+        this.message = message;
+    }
+
+    public void setSource(Member source) {
+        this.source = source;
+    }
+
+    public void setMessage(Serializable message) {
+        this.message = message;
+    }
+
+    public Member getSource() {
+        return source;
+    }
+
+    public Serializable getMessage() {
+        return message;
+    }
 }
\ No newline at end of file

==================================================
RpcChannel.java
index 4309a24033..e19eea36b4 100644
--- a/java/org/apache/catalina/tribes/group/RpcCallback.java
+++ b/java/org/apache/catalina/tribes/group/RpcCallback.java
@@ -1,45 +1,46 @@
-/*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.group;
-
-import java.io.Serializable;
-
-import org.apache.catalina.tribes.Member;
-
-/**
- * The RpcCallback interface is an interface for the Tribes channel to request a
- * response object to a request that came in.
- * @author not attributable
- * @version 1.0
- */
-public interface RpcCallback {
-    
-    /**
-     * 
-     * @param msg Serializable
-     * @return Serializable - null if no reply should be sent
-     */
-    public Serializable replyRequest(Serializable msg, Member sender);
-    
-    /**
-     * If the reply has already been sent to the requesting thread,
-     * the rpc callback can handle any data that comes in after the fact.
-     * @param msg Serializable
-     * @param sender Member
-     */
-    public void leftOver(Serializable msg, Member sender);
-    
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.group;
+
+import java.io.Serializable;
+
+import org.apache.catalina.tribes.Member;
+
+/**
+ * The RpcCallback interface is an interface for the Tribes channel to request a
+ * response object to a request that came in.
+ * @author not attributable
+ * @version 1.0
+ */
+public interface RpcCallback {
+    
+    /**
+     * 
+     * @param msg Serializable
+     * @return Serializable - null if no reply should be sent
+     */
+    public Serializable replyRequest(Serializable msg, Member sender);
+    
+    /**
+     * If the reply has already been sent to the requesting thread,
+     * the rpc callback can handle any data that comes in after the fact.
+     * @param msg Serializable
+     * @param sender Member
+     */
+    public void leftOver(Serializable msg, Member sender);
+    
 }
\ No newline at end of file

==================================================
RpcMessage.java
index 873a961c77..2fb35ab700 100644
--- a/java/org/apache/catalina/tribes/group/RpcChannel.java
+++ b/java/org/apache/catalina/tribes/group/RpcChannel.java
@@ -1,261 +1,262 @@
-/*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.group;
-
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-
-import org.apache.catalina.tribes.Channel;
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelListener;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.util.UUIDGenerator;
-
-/**
- * A channel to handle RPC messaging
- * @author Filip Hanik
- */
-public class RpcChannel implements ChannelListener{
-    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(RpcChannel.class);
-    
-    public static final int FIRST_REPLY = 1;
-    public static final int MAJORITY_REPLY = 2;
-    public static final int ALL_REPLY = 3;
-    public static final int NO_REPLY = 4;
-    
-    private Channel channel;
-    private RpcCallback callback;
-    private byte[] rpcId;
-    
-    private HashMap responseMap = new HashMap();
-
-    /**
-     * Create an RPC channel. You can have several RPC channels attached to a group
-     * all separated out by the uniqueness
-     * @param rpcId - the unique Id for this RPC group
-     * @param channel Channel
-     * @param callback RpcCallback
-     */
-    public RpcChannel(byte[] rpcId, Channel channel, RpcCallback callback) {
-        this.channel = channel;
-        this.callback = callback;
-        this.rpcId = rpcId;
-        channel.addChannelListener(this);
-    }
-    
-    
-    /**
-     * Send a message and wait for the response.
-     * @param destination Member[] - the destination for the message, and the members you request a reply from
-     * @param message Serializable - the message you are sending out
-     * @param options int - FIRST_REPLY, MAJORITY_REPLY or ALL_REPLY
-     * @param timeout long - timeout in milliseconds, if no reply is received within this time null is returned
-     * @return Response[] - an array of response objects.
-     * @throws ChannelException
-     */
-    public Response[] send(Member[] destination, 
-                           Serializable message,
-                           int rpcOptions, 
-                           int channelOptions,
-                           long timeout) throws ChannelException {
-        
-        if ( destination==null || destination.length == 0 ) return new Response[0];
-        
-        //avoid dead lock
-        channelOptions = channelOptions & ~Channel.SEND_OPTIONS_SYNCHRONIZED_ACK;
-        
-        RpcCollectorKey key = new RpcCollectorKey(UUIDGenerator.randomUUID(false));
-        RpcCollector collector = new RpcCollector(key,rpcOptions,destination.length,timeout);
-        try {
-            synchronized (collector) {
-                if ( rpcOptions != NO_REPLY ) responseMap.put(key, collector);
-                RpcMessage rmsg = new RpcMessage(rpcId, key.id, message);
-                channel.send(destination, rmsg, channelOptions);
-                if ( rpcOptions != NO_REPLY ) collector.wait(timeout);
-            }
-        } catch ( InterruptedException ix ) {
-            Thread.currentThread().interrupted();
-            //throw new ChannelException(ix);
-        }finally {
-            responseMap.remove(key);
-        }
-        return collector.getResponses();
-    }
-    
-    public void messageReceived(Serializable msg, Member sender) {
-        RpcMessage rmsg = (RpcMessage)msg;
-        RpcCollectorKey key = new RpcCollectorKey(rmsg.uuid);
-        if ( rmsg.reply ) {
-            RpcCollector collector = (RpcCollector)responseMap.get(key);
-            if (collector == null) {
-                callback.leftOver(rmsg.message, sender);
-            } else {
-                synchronized (collector) {
-                    //make sure it hasn't been removed
-                    if ( responseMap.containsKey(key) ) {
-                        if ( (rmsg instanceof RpcMessage.NoRpcChannelReply) ) 
-                            collector.destcnt--;
-                        else 
-                            collector.addResponse(rmsg.message, sender);
-                        if (collector.isComplete()) collector.notifyAll();
-                    } else {
-                        if (! (rmsg instanceof RpcMessage.NoRpcChannelReply) ) 
-                            callback.leftOver(rmsg.message, sender);
-                    }
-                }//synchronized
-            }//end if
-        } else{
-            Serializable reply = callback.replyRequest(rmsg.message,sender);
-            rmsg.reply = true;
-            rmsg.message = reply;
-            try {
-                channel.send(new Member[] {sender}, rmsg,0);
-            }catch ( Exception x )  {
-                log.error("Unable to send back reply in RpcChannel.",x);
-            }
-        }//end if
-    }
-    
-    public void breakdown() {
-        channel.removeChannelListener(this);
-    }
-    
-    public void finalize() {
-        breakdown();
-    }
-    
-    public boolean accept(Serializable msg, Member sender) {
-        if ( msg instanceof RpcMessage ) {
-            RpcMessage rmsg = (RpcMessage)msg;
-            return Arrays.equals(rmsg.rpcId,rpcId);
-        }else return false;
-    }
-    
-    public Channel getChannel() {
-        return channel;
-    }
-
-    public RpcCallback getCallback() {
-        return callback;
-    }
-
-    public byte[] getRpcId() {
-        return rpcId;
-    }
-
-    public void setChannel(Channel channel) {
-        this.channel = channel;
-    }
-
-    public void setCallback(RpcCallback callback) {
-        this.callback = callback;
-    }
-
-    public void setRpcId(byte[] rpcId) {
-        this.rpcId = rpcId;
-    }
-    
-
-
-    /**
-     * 
-     * Class that holds all response.
-     * @author not attributable
-     * @version 1.0
-     */
-    public static class RpcCollector {
-        public ArrayList responses = new ArrayList(); 
-        public RpcCollectorKey key;
-        public int options;
-        public int destcnt;
-        public long timeout;
-        
-        public RpcCollector(RpcCollectorKey key, int options, int destcnt, long timeout) {
-            this.key = key;
-            this.options = options;
-            this.destcnt = destcnt;
-            this.timeout = timeout;
-        }
-        
-        public void addResponse(Serializable message, Member sender){
-            Response resp = new Response(sender,message);
-            responses.add(resp);
-        }
-        
-        public boolean isComplete() {
-            if ( destcnt <= 0 ) return true;
-            switch (options) {
-                case ALL_REPLY:
-                    return destcnt == responses.size();
-                case MAJORITY_REPLY:
-                {
-                    float perc = ((float)responses.size()) / ((float)destcnt);
-                    return perc >= 0.50f;
-                }
-                case FIRST_REPLY:
-                    return responses.size()>0;
-                default:
-                    return false;
-            }
-        }
-        
-        public int hashCode() {
-            return key.hashCode();
-        }
-        
-        public boolean equals(Object o) {
-            if ( o instanceof RpcCollector ) {
-                RpcCollector r = (RpcCollector)o;
-                return r.key.equals(this.key);
-            } else return false;
-        }
-        
-        public Response[] getResponses() {
-            return (Response[])responses.toArray(new Response[responses.size()]);
-        }
-    }
-    
-    public static class RpcCollectorKey {
-        byte[] id;
-        public RpcCollectorKey(byte[] id) {
-            this.id = id;
-        }
-        
-        public int hashCode() {
-            return id[0]+id[1]+id[2]+id[3];
-        }
-
-        public boolean equals(Object o) {
-            if ( o instanceof RpcCollectorKey ) {
-                RpcCollectorKey r = (RpcCollectorKey)o;
-                return Arrays.equals(id,r.id);
-            } else return false;
-        }
-        
-    }
-    
-    protected static String bToS(byte[] data) {
-        StringBuffer buf = new StringBuffer(4*16);
-        buf.append("{");
-        for (int i=0; data!=null && i<data.length; i++ ) buf.append(String.valueOf(data[i])).append(" ");
-        buf.append("}");
-        return buf.toString();
-    }
-
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.group;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+
+import org.apache.catalina.tribes.Channel;
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelListener;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.util.UUIDGenerator;
+
+/**
+ * A channel to handle RPC messaging
+ * @author Filip Hanik
+ */
+public class RpcChannel implements ChannelListener{
+    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(RpcChannel.class);
+    
+    public static final int FIRST_REPLY = 1;
+    public static final int MAJORITY_REPLY = 2;
+    public static final int ALL_REPLY = 3;
+    public static final int NO_REPLY = 4;
+    
+    private Channel channel;
+    private RpcCallback callback;
+    private byte[] rpcId;
+    
+    private HashMap responseMap = new HashMap();
+
+    /**
+     * Create an RPC channel. You can have several RPC channels attached to a group
+     * all separated out by the uniqueness
+     * @param rpcId - the unique Id for this RPC group
+     * @param channel Channel
+     * @param callback RpcCallback
+     */
+    public RpcChannel(byte[] rpcId, Channel channel, RpcCallback callback) {
+        this.channel = channel;
+        this.callback = callback;
+        this.rpcId = rpcId;
+        channel.addChannelListener(this);
+    }
+    
+    
+    /**
+     * Send a message and wait for the response.
+     * @param destination Member[] - the destination for the message, and the members you request a reply from
+     * @param message Serializable - the message you are sending out
+     * @param options int - FIRST_REPLY, MAJORITY_REPLY or ALL_REPLY
+     * @param timeout long - timeout in milliseconds, if no reply is received within this time null is returned
+     * @return Response[] - an array of response objects.
+     * @throws ChannelException
+     */
+    public Response[] send(Member[] destination, 
+                           Serializable message,
+                           int rpcOptions, 
+                           int channelOptions,
+                           long timeout) throws ChannelException {
+        
+        if ( destination==null || destination.length == 0 ) return new Response[0];
+        
+        //avoid dead lock
+        channelOptions = channelOptions & ~Channel.SEND_OPTIONS_SYNCHRONIZED_ACK;
+        
+        RpcCollectorKey key = new RpcCollectorKey(UUIDGenerator.randomUUID(false));
+        RpcCollector collector = new RpcCollector(key,rpcOptions,destination.length,timeout);
+        try {
+            synchronized (collector) {
+                if ( rpcOptions != NO_REPLY ) responseMap.put(key, collector);
+                RpcMessage rmsg = new RpcMessage(rpcId, key.id, message);
+                channel.send(destination, rmsg, channelOptions);
+                if ( rpcOptions != NO_REPLY ) collector.wait(timeout);
+            }
+        } catch ( InterruptedException ix ) {
+            Thread.currentThread().interrupted();
+            //throw new ChannelException(ix);
+        }finally {
+            responseMap.remove(key);
+        }
+        return collector.getResponses();
+    }
+    
+    public void messageReceived(Serializable msg, Member sender) {
+        RpcMessage rmsg = (RpcMessage)msg;
+        RpcCollectorKey key = new RpcCollectorKey(rmsg.uuid);
+        if ( rmsg.reply ) {
+            RpcCollector collector = (RpcCollector)responseMap.get(key);
+            if (collector == null) {
+                callback.leftOver(rmsg.message, sender);
+            } else {
+                synchronized (collector) {
+                    //make sure it hasn't been removed
+                    if ( responseMap.containsKey(key) ) {
+                        if ( (rmsg instanceof RpcMessage.NoRpcChannelReply) ) 
+                            collector.destcnt--;
+                        else 
+                            collector.addResponse(rmsg.message, sender);
+                        if (collector.isComplete()) collector.notifyAll();
+                    } else {
+                        if (! (rmsg instanceof RpcMessage.NoRpcChannelReply) ) 
+                            callback.leftOver(rmsg.message, sender);
+                    }
+                }//synchronized
+            }//end if
+        } else{
+            Serializable reply = callback.replyRequest(rmsg.message,sender);
+            rmsg.reply = true;
+            rmsg.message = reply;
+            try {
+                channel.send(new Member[] {sender}, rmsg,0);
+            }catch ( Exception x )  {
+                log.error("Unable to send back reply in RpcChannel.",x);
+            }
+        }//end if
+    }
+    
+    public void breakdown() {
+        channel.removeChannelListener(this);
+    }
+    
+    public void finalize() {
+        breakdown();
+    }
+    
+    public boolean accept(Serializable msg, Member sender) {
+        if ( msg instanceof RpcMessage ) {
+            RpcMessage rmsg = (RpcMessage)msg;
+            return Arrays.equals(rmsg.rpcId,rpcId);
+        }else return false;
+    }
+    
+    public Channel getChannel() {
+        return channel;
+    }
+
+    public RpcCallback getCallback() {
+        return callback;
+    }
+
+    public byte[] getRpcId() {
+        return rpcId;
+    }
+
+    public void setChannel(Channel channel) {
+        this.channel = channel;
+    }
+
+    public void setCallback(RpcCallback callback) {
+        this.callback = callback;
+    }
+
+    public void setRpcId(byte[] rpcId) {
+        this.rpcId = rpcId;
+    }
+    
+
+
+    /**
+     * 
+     * Class that holds all response.
+     * @author not attributable
+     * @version 1.0
+     */
+    public static class RpcCollector {
+        public ArrayList responses = new ArrayList(); 
+        public RpcCollectorKey key;
+        public int options;
+        public int destcnt;
+        public long timeout;
+        
+        public RpcCollector(RpcCollectorKey key, int options, int destcnt, long timeout) {
+            this.key = key;
+            this.options = options;
+            this.destcnt = destcnt;
+            this.timeout = timeout;
+        }
+        
+        public void addResponse(Serializable message, Member sender){
+            Response resp = new Response(sender,message);
+            responses.add(resp);
+        }
+        
+        public boolean isComplete() {
+            if ( destcnt <= 0 ) return true;
+            switch (options) {
+                case ALL_REPLY:
+                    return destcnt == responses.size();
+                case MAJORITY_REPLY:
+                {
+                    float perc = ((float)responses.size()) / ((float)destcnt);
+                    return perc >= 0.50f;
+                }
+                case FIRST_REPLY:
+                    return responses.size()>0;
+                default:
+                    return false;
+            }
+        }
+        
+        public int hashCode() {
+            return key.hashCode();
+        }
+        
+        public boolean equals(Object o) {
+            if ( o instanceof RpcCollector ) {
+                RpcCollector r = (RpcCollector)o;
+                return r.key.equals(this.key);
+            } else return false;
+        }
+        
+        public Response[] getResponses() {
+            return (Response[])responses.toArray(new Response[responses.size()]);
+        }
+    }
+    
+    public static class RpcCollectorKey {
+        byte[] id;
+        public RpcCollectorKey(byte[] id) {
+            this.id = id;
+        }
+        
+        public int hashCode() {
+            return id[0]+id[1]+id[2]+id[3];
+        }
+
+        public boolean equals(Object o) {
+            if ( o instanceof RpcCollectorKey ) {
+                RpcCollectorKey r = (RpcCollectorKey)o;
+                return Arrays.equals(id,r.id);
+            } else return false;
+        }
+        
+    }
+    
+    protected static String bToS(byte[] data) {
+        StringBuffer buf = new StringBuffer(4*16);
+        buf.append("{");
+        for (int i=0; data!=null && i<data.length; i++ ) buf.append(String.valueOf(data[i])).append(" ");
+        buf.append("}");
+        return buf.toString();
+    }
+
+
 }
\ No newline at end of file

==================================================
DomainFilterInterceptor.java
index 29c7d87ee7..53db66eb43 100644
--- a/java/org/apache/catalina/tribes/group/RpcMessage.java
+++ b/java/org/apache/catalina/tribes/group/RpcMessage.java
@@ -1,116 +1,117 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.group;
-
-import java.io.ObjectInput;
-import java.io.Serializable;
-import java.io.Externalizable;
-import java.io.IOException;
-import java.io.ObjectOutput;
-import org.apache.catalina.tribes.util.Arrays;
-
-/**
- * <p>Title: </p>
- *
- * <p>Description: </p>
- *
- * <p>Copyright: Copyright (c) 2005</p>
- *
- * <p>Company: </p>
- *
- * @author not attributable
- * @version 1.0
- */
-public class RpcMessage implements Externalizable {
-
-    protected Serializable message;
-    protected byte[] uuid;
-    protected byte[] rpcId;
-    protected boolean reply = false;
-
-    public RpcMessage() {
-        //for serialization
-    }
-
-    public RpcMessage(byte[] rpcId, byte[] uuid, Serializable message) {
-        this.rpcId = rpcId;
-        this.uuid = uuid;
-        this.message = message;
-    }
-
-    public void readExternal(ObjectInput in) throws IOException,ClassNotFoundException {
-        reply = in.readBoolean();
-        int length = in.readInt();
-        uuid = new byte[length];
-        in.read(uuid, 0, length);
-        length = in.readInt();
-        rpcId = new byte[length];
-        in.read(rpcId, 0, length);
-        message = (Serializable)in.readObject();
-    }
-
-    public void writeExternal(ObjectOutput out) throws IOException {
-        out.writeBoolean(reply);
-        out.writeInt(uuid.length);
-        out.write(uuid, 0, uuid.length);
-        out.writeInt(rpcId.length);
-        out.write(rpcId, 0, rpcId.length);
-        out.writeObject(message);
-    }
-    
-    public String toString() {
-        StringBuffer buf = new StringBuffer("RpcMessage[");
-        buf.append(super.toString());
-        buf.append("] rpcId=");
-        buf.append(Arrays.toString(rpcId));
-        buf.append("; uuid=");
-        buf.append(Arrays.toString(uuid));
-        buf.append("; msg=");
-        buf.append(message);
-        return buf.toString();
-    }
-    
-    public static class NoRpcChannelReply extends RpcMessage {
-        public NoRpcChannelReply() {
-            
-        }
-
-        public NoRpcChannelReply(byte[] rpcid, byte[] uuid) {
-            super(rpcid,uuid,null);
-            reply = true;
-        }
-
-        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
-            reply = true;
-            int length = in.readInt();
-            uuid = new byte[length];
-            in.read(uuid, 0, length);
-            length = in.readInt();
-            rpcId = new byte[length];
-            in.read(rpcId, 0, length);
-        }
-
-        public void writeExternal(ObjectOutput out) throws IOException {
-            out.writeInt(uuid.length);
-            out.write(uuid, 0, uuid.length);
-            out.writeInt(rpcId.length);
-            out.write(rpcId, 0, rpcId.length);
-        }
-    }    
-
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.group;
+
+import java.io.ObjectInput;
+import java.io.Serializable;
+import java.io.Externalizable;
+import java.io.IOException;
+import java.io.ObjectOutput;
+import org.apache.catalina.tribes.util.Arrays;
+
+/**
+ * <p>Title: </p>
+ *
+ * <p>Description: </p>
+ *
+ * <p>Copyright: Copyright (c) 2005</p>
+ *
+ * <p>Company: </p>
+ *
+ * @author not attributable
+ * @version 1.0
+ */
+public class RpcMessage implements Externalizable {
+
+    protected Serializable message;
+    protected byte[] uuid;
+    protected byte[] rpcId;
+    protected boolean reply = false;
+
+    public RpcMessage() {
+        //for serialization
+    }
+
+    public RpcMessage(byte[] rpcId, byte[] uuid, Serializable message) {
+        this.rpcId = rpcId;
+        this.uuid = uuid;
+        this.message = message;
+    }
+
+    public void readExternal(ObjectInput in) throws IOException,ClassNotFoundException {
+        reply = in.readBoolean();
+        int length = in.readInt();
+        uuid = new byte[length];
+        in.read(uuid, 0, length);
+        length = in.readInt();
+        rpcId = new byte[length];
+        in.read(rpcId, 0, length);
+        message = (Serializable)in.readObject();
+    }
+
+    public void writeExternal(ObjectOutput out) throws IOException {
+        out.writeBoolean(reply);
+        out.writeInt(uuid.length);
+        out.write(uuid, 0, uuid.length);
+        out.writeInt(rpcId.length);
+        out.write(rpcId, 0, rpcId.length);
+        out.writeObject(message);
+    }
+    
+    public String toString() {
+        StringBuffer buf = new StringBuffer("RpcMessage[");
+        buf.append(super.toString());
+        buf.append("] rpcId=");
+        buf.append(Arrays.toString(rpcId));
+        buf.append("; uuid=");
+        buf.append(Arrays.toString(uuid));
+        buf.append("; msg=");
+        buf.append(message);
+        return buf.toString();
+    }
+    
+    public static class NoRpcChannelReply extends RpcMessage {
+        public NoRpcChannelReply() {
+            
+        }
+
+        public NoRpcChannelReply(byte[] rpcid, byte[] uuid) {
+            super(rpcid,uuid,null);
+            reply = true;
+        }
+
+        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
+            reply = true;
+            int length = in.readInt();
+            uuid = new byte[length];
+            in.read(uuid, 0, length);
+            length = in.readInt();
+            rpcId = new byte[length];
+            in.read(rpcId, 0, length);
+        }
+
+        public void writeExternal(ObjectOutput out) throws IOException {
+            out.writeInt(uuid.length);
+            out.write(uuid, 0, uuid.length);
+            out.writeInt(rpcId.length);
+            out.write(rpcId, 0, rpcId.length);
+        }
+    }    
+
+
+}

==================================================
FragmentationInterceptor.java
index 395bd0af90..5ccd5bff20 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/DomainFilterInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/DomainFilterInterceptor.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
GzipInterceptor.java
index bbf15ab862..cf8e673e5f 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/FragmentationInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/FragmentationInterceptor.java
@@ -1,241 +1,242 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- */
-
-package org.apache.catalina.tribes.group.interceptors;
-
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.Set;
-
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.group.ChannelInterceptorBase;
-import org.apache.catalina.tribes.group.InterceptorPayload;
-import org.apache.catalina.tribes.io.XByteBuffer;
-
-/**
- *
- * The fragmentation interceptor splits up large messages into smaller messages and assembles them on the other end.
- * This is very useful when you don't want large messages hogging the sending sockets
- * and smaller messages can make it through.
- * 
- * <br><b>Configuration Options</b><br>
- * OrderInteceptor.expire=<milliseconds> - how long do we keep the fragments in memory and wait for the rest to arrive<b>default=60,000ms -> 60seconds</b>
- * This setting is useful to avoid OutOfMemoryErrors<br>
- * OrderInteceptor.maxSize=<max message size> - message size in bytes <b>default=1024*100 (around a tenth of a MB)</b><br>
- * @author Filip Hanik
- * @version 1.0
- */
-public class FragmentationInterceptor extends ChannelInterceptorBase {
-    private static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( FragmentationInterceptor.class );
-    
-    protected HashMap fragpieces = new HashMap();
-    private int maxSize = 1024*100;
-    private long expire = 1000 * 60; //one minute expiration
-    protected boolean deepclone = true;
-
-
-    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
-        int size = msg.getMessage().getLength();
-        boolean frag = (size>maxSize) && okToProcess(msg.getOptions());
-        if ( frag ) {
-            frag(destination, msg, payload);
-        } else {
-            msg.getMessage().append(frag);
-            super.sendMessage(destination, msg, payload);
-        }
-    }
-    
-    public void messageReceived(ChannelMessage msg) {
-        boolean isFrag = XByteBuffer.toBoolean(msg.getMessage().getBytesDirect(),msg.getMessage().getLength()-1);
-        msg.getMessage().trim(1);
-        if ( isFrag ) {
-            defrag(msg);
-        } else {
-            super.messageReceived(msg);
-        }
-    }
-
-    
-    public FragCollection getFragCollection(FragKey key, ChannelMessage msg) {
-        FragCollection coll = (FragCollection)fragpieces.get(key);
-        if ( coll == null ) {
-            synchronized (fragpieces) {
-                coll = (FragCollection)fragpieces.get(key);
-                if ( coll == null ) {
-                    coll = new FragCollection(msg);
-                    fragpieces.put(key, coll);
-                }
-            }
-        } 
-        return coll;
-    }
-    
-    public void removeFragCollection(FragKey key) {
-        fragpieces.remove(key);
-    }
-    
-    public void defrag(ChannelMessage msg ) { 
-        FragKey key = new FragKey(msg.getUniqueId());
-        FragCollection coll = getFragCollection(key,msg);
-        coll.addMessage((ChannelMessage)msg.deepclone());
-
-        if ( coll.complete() ) {
-            removeFragCollection(key);
-            ChannelMessage complete = coll.assemble();
-            super.messageReceived(complete);
-            
-        }
-    }
-
-    public void frag(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
-        int size = msg.getMessage().getLength();
-
-        int count = ((size / maxSize )+(size%maxSize==0?0:1));
-        ChannelMessage[] messages = new ChannelMessage[count];
-        int remaining = size;
-        for ( int i=0; i<count; i++ ) {
-            ChannelMessage tmp = (ChannelMessage)msg.clone();
-            int offset = (i*maxSize);
-            int length = Math.min(remaining,maxSize);
-            tmp.getMessage().clear();
-            tmp.getMessage().append(msg.getMessage().getBytesDirect(),offset,length);
-            //add the msg nr
-            //tmp.getMessage().append(XByteBuffer.toBytes(i),0,4);
-            tmp.getMessage().append(i);
-            //add the total nr of messages
-            //tmp.getMessage().append(XByteBuffer.toBytes(count),0,4);
-            tmp.getMessage().append(count);
-            //add true as the frag flag
-            //byte[] flag = XByteBuffer.toBytes(true);
-            //tmp.getMessage().append(flag,0,flag.length);
-            tmp.getMessage().append(true);
-            messages[i] = tmp;
-            remaining -= length;
-            
-        }
-        for ( int i=0; i<messages.length; i++ ) {
-            super.sendMessage(destination,messages[i],payload);
-        }
-    }
-    
-    public void heartbeat() {
-        try {
-            Set set = fragpieces.keySet(); 
-            Object[] keys = set.toArray();
-            for ( int i=0; i<keys.length; i++ ) {
-                FragKey key = (FragKey)keys[i];
-                if ( key != null && key.expired(getExpire()) ) 
-                    removeFragCollection(key);
-            }
-        }catch ( Exception x ) {
-            if ( log.isErrorEnabled() ) {
-                log.error("Unable to perform heartbeat clean up in the frag interceptor",x);
-            }
-        }
-        super.heartbeat();
-    }
-
-    
-
-    public int getMaxSize() {
-        return maxSize;
-    }
-
-    public long getExpire() {
-        return expire;
-    }
-
-    public void setMaxSize(int maxSize) {
-        this.maxSize = maxSize;
-    }
-
-    public void setExpire(long expire) {
-        this.expire = expire;
-    }
-
-    public static class FragCollection {
-        private long received = System.currentTimeMillis();
-        private ChannelMessage msg;
-        private XByteBuffer[] frags;
-        public FragCollection(ChannelMessage msg) {
-            //get the total messages
-            int count = XByteBuffer.toInt(msg.getMessage().getBytesDirect(),msg.getMessage().getLength()-4);
-            frags = new XByteBuffer[count];
-            this.msg = msg;
-        }
-        
-        public void addMessage(ChannelMessage msg) {
-            //remove the total messages
-            msg.getMessage().trim(4);
-            //get the msg nr
-            int nr = XByteBuffer.toInt(msg.getMessage().getBytesDirect(),msg.getMessage().getLength()-4);
-            //remove the msg nr
-            msg.getMessage().trim(4);
-            frags[nr] = msg.getMessage();
-            
-        }
-        
-        public boolean complete() {
-            boolean result = true;
-            for ( int i=0; (i<frags.length) && (result); i++ ) result = (frags[i] != null);
-            return result;
-        }
-        
-        public ChannelMessage assemble() {
-            if ( !complete() ) throw new IllegalStateException("Fragments are missing.");
-            int buffersize = 0;
-            for (int i=0; i<frags.length; i++ ) buffersize += frags[i].getLength();
-            XByteBuffer buf = new XByteBuffer(buffersize,false);
-            msg.setMessage(buf);
-            for ( int i=0; i<frags.length; i++ ) {
-                msg.getMessage().append(frags[i].getBytesDirect(),0,frags[i].getLength());
-            }
-            return msg;
-        }
-        
-        public boolean expired(long expire) {
-            return (System.currentTimeMillis()-received)>expire;
-        }
-
-        
-        
-    }
-    
-    public static class FragKey {
-        private byte[] uniqueId;
-        private long received = System.currentTimeMillis();
-        public FragKey(byte[] id ) {
-            this.uniqueId = id;
-        }
-        public int hashCode() {
-            return XByteBuffer.toInt(uniqueId,0);
-        }
-        
-        public boolean equals(Object o ) {
-            if ( o instanceof FragKey ) {
-            return Arrays.equals(uniqueId,((FragKey)o).uniqueId);
-        } else return false;
-
-        }
-        
-        public boolean expired(long expire) {
-            return (System.currentTimeMillis()-received)>expire;
-        }
-
-    }
-    
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ */
+
+package org.apache.catalina.tribes.group.interceptors;
+
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Set;
+
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.group.ChannelInterceptorBase;
+import org.apache.catalina.tribes.group.InterceptorPayload;
+import org.apache.catalina.tribes.io.XByteBuffer;
+
+/**
+ *
+ * The fragmentation interceptor splits up large messages into smaller messages and assembles them on the other end.
+ * This is very useful when you don't want large messages hogging the sending sockets
+ * and smaller messages can make it through.
+ * 
+ * <br><b>Configuration Options</b><br>
+ * OrderInteceptor.expire=<milliseconds> - how long do we keep the fragments in memory and wait for the rest to arrive<b>default=60,000ms -> 60seconds</b>
+ * This setting is useful to avoid OutOfMemoryErrors<br>
+ * OrderInteceptor.maxSize=<max message size> - message size in bytes <b>default=1024*100 (around a tenth of a MB)</b><br>
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class FragmentationInterceptor extends ChannelInterceptorBase {
+    private static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( FragmentationInterceptor.class );
+    
+    protected HashMap fragpieces = new HashMap();
+    private int maxSize = 1024*100;
+    private long expire = 1000 * 60; //one minute expiration
+    protected boolean deepclone = true;
+
+
+    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
+        int size = msg.getMessage().getLength();
+        boolean frag = (size>maxSize) && okToProcess(msg.getOptions());
+        if ( frag ) {
+            frag(destination, msg, payload);
+        } else {
+            msg.getMessage().append(frag);
+            super.sendMessage(destination, msg, payload);
+        }
+    }
+    
+    public void messageReceived(ChannelMessage msg) {
+        boolean isFrag = XByteBuffer.toBoolean(msg.getMessage().getBytesDirect(),msg.getMessage().getLength()-1);
+        msg.getMessage().trim(1);
+        if ( isFrag ) {
+            defrag(msg);
+        } else {
+            super.messageReceived(msg);
+        }
+    }
+
+    
+    public FragCollection getFragCollection(FragKey key, ChannelMessage msg) {
+        FragCollection coll = (FragCollection)fragpieces.get(key);
+        if ( coll == null ) {
+            synchronized (fragpieces) {
+                coll = (FragCollection)fragpieces.get(key);
+                if ( coll == null ) {
+                    coll = new FragCollection(msg);
+                    fragpieces.put(key, coll);
+                }
+            }
+        } 
+        return coll;
+    }
+    
+    public void removeFragCollection(FragKey key) {
+        fragpieces.remove(key);
+    }
+    
+    public void defrag(ChannelMessage msg ) { 
+        FragKey key = new FragKey(msg.getUniqueId());
+        FragCollection coll = getFragCollection(key,msg);
+        coll.addMessage((ChannelMessage)msg.deepclone());
+
+        if ( coll.complete() ) {
+            removeFragCollection(key);
+            ChannelMessage complete = coll.assemble();
+            super.messageReceived(complete);
+            
+        }
+    }
+
+    public void frag(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
+        int size = msg.getMessage().getLength();
+
+        int count = ((size / maxSize )+(size%maxSize==0?0:1));
+        ChannelMessage[] messages = new ChannelMessage[count];
+        int remaining = size;
+        for ( int i=0; i<count; i++ ) {
+            ChannelMessage tmp = (ChannelMessage)msg.clone();
+            int offset = (i*maxSize);
+            int length = Math.min(remaining,maxSize);
+            tmp.getMessage().clear();
+            tmp.getMessage().append(msg.getMessage().getBytesDirect(),offset,length);
+            //add the msg nr
+            //tmp.getMessage().append(XByteBuffer.toBytes(i),0,4);
+            tmp.getMessage().append(i);
+            //add the total nr of messages
+            //tmp.getMessage().append(XByteBuffer.toBytes(count),0,4);
+            tmp.getMessage().append(count);
+            //add true as the frag flag
+            //byte[] flag = XByteBuffer.toBytes(true);
+            //tmp.getMessage().append(flag,0,flag.length);
+            tmp.getMessage().append(true);
+            messages[i] = tmp;
+            remaining -= length;
+            
+        }
+        for ( int i=0; i<messages.length; i++ ) {
+            super.sendMessage(destination,messages[i],payload);
+        }
+    }
+    
+    public void heartbeat() {
+        try {
+            Set set = fragpieces.keySet(); 
+            Object[] keys = set.toArray();
+            for ( int i=0; i<keys.length; i++ ) {
+                FragKey key = (FragKey)keys[i];
+                if ( key != null && key.expired(getExpire()) ) 
+                    removeFragCollection(key);
+            }
+        }catch ( Exception x ) {
+            if ( log.isErrorEnabled() ) {
+                log.error("Unable to perform heartbeat clean up in the frag interceptor",x);
+            }
+        }
+        super.heartbeat();
+    }
+
+    
+
+    public int getMaxSize() {
+        return maxSize;
+    }
+
+    public long getExpire() {
+        return expire;
+    }
+
+    public void setMaxSize(int maxSize) {
+        this.maxSize = maxSize;
+    }
+
+    public void setExpire(long expire) {
+        this.expire = expire;
+    }
+
+    public static class FragCollection {
+        private long received = System.currentTimeMillis();
+        private ChannelMessage msg;
+        private XByteBuffer[] frags;
+        public FragCollection(ChannelMessage msg) {
+            //get the total messages
+            int count = XByteBuffer.toInt(msg.getMessage().getBytesDirect(),msg.getMessage().getLength()-4);
+            frags = new XByteBuffer[count];
+            this.msg = msg;
+        }
+        
+        public void addMessage(ChannelMessage msg) {
+            //remove the total messages
+            msg.getMessage().trim(4);
+            //get the msg nr
+            int nr = XByteBuffer.toInt(msg.getMessage().getBytesDirect(),msg.getMessage().getLength()-4);
+            //remove the msg nr
+            msg.getMessage().trim(4);
+            frags[nr] = msg.getMessage();
+            
+        }
+        
+        public boolean complete() {
+            boolean result = true;
+            for ( int i=0; (i<frags.length) && (result); i++ ) result = (frags[i] != null);
+            return result;
+        }
+        
+        public ChannelMessage assemble() {
+            if ( !complete() ) throw new IllegalStateException("Fragments are missing.");
+            int buffersize = 0;
+            for (int i=0; i<frags.length; i++ ) buffersize += frags[i].getLength();
+            XByteBuffer buf = new XByteBuffer(buffersize,false);
+            msg.setMessage(buf);
+            for ( int i=0; i<frags.length; i++ ) {
+                msg.getMessage().append(frags[i].getBytesDirect(),0,frags[i].getLength());
+            }
+            return msg;
+        }
+        
+        public boolean expired(long expire) {
+            return (System.currentTimeMillis()-received)>expire;
+        }
+
+        
+        
+    }
+    
+    public static class FragKey {
+        private byte[] uniqueId;
+        private long received = System.currentTimeMillis();
+        public FragKey(byte[] id ) {
+            this.uniqueId = id;
+        }
+        public int hashCode() {
+            return XByteBuffer.toInt(uniqueId,0);
+        }
+        
+        public boolean equals(Object o ) {
+            if ( o instanceof FragKey ) {
+            return Arrays.equals(uniqueId,((FragKey)o).uniqueId);
+        } else return false;
+
+        }
+        
+        public boolean expired(long expire) {
+            return (System.currentTimeMillis()-received)>expire;
+        }
+
+    }
+    
 }
\ No newline at end of file

==================================================
MessageDispatch15Interceptor.java
index 18b3024b94..de69869e19 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/GzipInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/GzipInterceptor.java
@@ -1,99 +1,100 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- */
-
-package org.apache.catalina.tribes.group.interceptors;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.zip.GZIPInputStream;
-import java.util.zip.GZIPOutputStream;
-
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.group.ChannelInterceptorBase;
-import org.apache.catalina.tribes.group.InterceptorPayload;
-
-
-
-/**
- *
- *
- * @author Filip Hanik
- * @version 1.0
- */
-public class GzipInterceptor extends ChannelInterceptorBase {
-    public static final int DEFAULT_BUFFER_SIZE = 2048;
-    
-    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
-        try {
-            byte[] data = compress(msg.getMessage().getBytes());
-            msg.getMessage().trim(msg.getMessage().getLength());
-            msg.getMessage().append(data,0,data.length);
-            getNext().sendMessage(destination, msg, payload);
-        } catch ( IOException x ) {
-            log.error("Unable to compress byte contents");
-            throw new ChannelException(x);
-        }
-    }
-
-    public void messageReceived(ChannelMessage msg) {
-        try {
-            byte[] data = decompress(msg.getMessage().getBytes());
-            msg.getMessage().trim(msg.getMessage().getLength());
-            msg.getMessage().append(data,0,data.length);
-            getPrevious().messageReceived(msg);
-        } catch ( IOException x ) {
-            log.error("Unable to decompress byte contents",x);
-        }
-    }
-    
-    public static byte[] compress(byte[] data) throws IOException {
-        ByteArrayOutputStream bout = new ByteArrayOutputStream();
-        GZIPOutputStream gout = new GZIPOutputStream(bout);
-        gout.write(data);
-        gout.flush();
-        gout.close();
-        return bout.toByteArray();
-    }
-    
-    /**
-     * @todo Fix to create an automatically growing buffer.
-     * @param data byte[]
-     * @return byte[]
-     * @throws IOException
-     */
-    public static byte[] decompress(byte[] data) throws IOException {
-        ByteArrayInputStream bin = new ByteArrayInputStream(data);
-        GZIPInputStream gin = new GZIPInputStream(bin);
-        byte[] tmp = new byte[DEFAULT_BUFFER_SIZE];
-        int length = gin.read(tmp);
-        byte[] result = new byte[length];
-        System.arraycopy(tmp,0,result,0,length);
-        return result;
-    }
-    
-    public static void main(String[] arg) throws Exception {
-        byte[] data = new byte[1024];
-        Arrays.fill(data,(byte)1);
-        byte[] compress = compress(data);
-        byte[] decompress = decompress(compress);
-        System.out.println("Debug test");
-        
-    }
-    
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ */
+
+package org.apache.catalina.tribes.group.interceptors;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.zip.GZIPInputStream;
+import java.util.zip.GZIPOutputStream;
+
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.group.ChannelInterceptorBase;
+import org.apache.catalina.tribes.group.InterceptorPayload;
+
+
+
+/**
+ *
+ *
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class GzipInterceptor extends ChannelInterceptorBase {
+    public static final int DEFAULT_BUFFER_SIZE = 2048;
+    
+    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
+        try {
+            byte[] data = compress(msg.getMessage().getBytes());
+            msg.getMessage().trim(msg.getMessage().getLength());
+            msg.getMessage().append(data,0,data.length);
+            getNext().sendMessage(destination, msg, payload);
+        } catch ( IOException x ) {
+            log.error("Unable to compress byte contents");
+            throw new ChannelException(x);
+        }
+    }
+
+    public void messageReceived(ChannelMessage msg) {
+        try {
+            byte[] data = decompress(msg.getMessage().getBytes());
+            msg.getMessage().trim(msg.getMessage().getLength());
+            msg.getMessage().append(data,0,data.length);
+            getPrevious().messageReceived(msg);
+        } catch ( IOException x ) {
+            log.error("Unable to decompress byte contents",x);
+        }
+    }
+    
+    public static byte[] compress(byte[] data) throws IOException {
+        ByteArrayOutputStream bout = new ByteArrayOutputStream();
+        GZIPOutputStream gout = new GZIPOutputStream(bout);
+        gout.write(data);
+        gout.flush();
+        gout.close();
+        return bout.toByteArray();
+    }
+    
+    /**
+     * @todo Fix to create an automatically growing buffer.
+     * @param data byte[]
+     * @return byte[]
+     * @throws IOException
+     */
+    public static byte[] decompress(byte[] data) throws IOException {
+        ByteArrayInputStream bin = new ByteArrayInputStream(data);
+        GZIPInputStream gin = new GZIPInputStream(bin);
+        byte[] tmp = new byte[DEFAULT_BUFFER_SIZE];
+        int length = gin.read(tmp);
+        byte[] result = new byte[length];
+        System.arraycopy(tmp,0,result,0,length);
+        return result;
+    }
+    
+    public static void main(String[] arg) throws Exception {
+        byte[] data = new byte[1024];
+        Arrays.fill(data,(byte)1);
+        byte[] compress = compress(data);
+        byte[] decompress = decompress(compress);
+        System.out.println("Debug test");
+        
+    }
+    
+}

==================================================
MessageDispatchInterceptor.java
index c0198ba951..0510218509 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/MessageDispatch15Interceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/MessageDispatch15Interceptor.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
NonBlockingCoordinator.java
index 7819208645..fa75355a2b 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/MessageDispatchInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/MessageDispatchInterceptor.java
@@ -1,201 +1,202 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- */
-
-package org.apache.catalina.tribes.group.interceptors;
-
-import org.apache.catalina.tribes.Channel;
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.group.ChannelInterceptorBase;
-import org.apache.catalina.tribes.group.InterceptorPayload;
-import org.apache.catalina.tribes.transport.bio.util.FastQueue;
-import org.apache.catalina.tribes.transport.bio.util.LinkObject;
-import org.apache.catalina.tribes.UniqueId;
-
-/**
- *
- * The message dispatcher is a way to enable asynchronous communication
- * through a channel. The dispatcher will look for the <code>Channel.SEND_OPTIONS_ASYNCHRONOUS</code>
- * flag to be set, if it is, it will queue the message for delivery and immediately return to the sender.
- * 
- * 
- * 
- * @author Filip Hanik
- * @version 1.0
- */
-public class MessageDispatchInterceptor extends ChannelInterceptorBase implements Runnable {
-    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(MessageDispatchInterceptor.class);
-
-    protected long maxQueueSize = 1024*1024*64; //64MB
-    protected FastQueue queue = new FastQueue();
-    protected boolean run = false;
-    protected Thread msgDispatchThread = null;
-    protected long currentSize = 0;
-    protected boolean useDeepClone = true;
-    protected boolean alwaysSend = true;
-
-    public MessageDispatchInterceptor() {
-        setOptionFlag(Channel.SEND_OPTIONS_ASYNCHRONOUS);
-    }
-
-    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
-        boolean async = (msg.getOptions() & Channel.SEND_OPTIONS_ASYNCHRONOUS) == Channel.SEND_OPTIONS_ASYNCHRONOUS;
-        if ( async && run ) {
-            if ( (getCurrentSize()+msg.getMessage().getLength()) > maxQueueSize ) {
-                if ( alwaysSend ) {
-                    super.sendMessage(destination,msg,payload);
-                    return;
-                } else {
-                    throw new ChannelException("Asynchronous queue is full, reached its limit of " + maxQueueSize +" bytes, current:" + getCurrentSize() + " bytes.");
-                }//end if
-            }//end if
-            //add to queue
-            if ( useDeepClone ) msg = (ChannelMessage)msg.deepclone();
-            if (!addToQueue(msg, destination, payload) ) {
-                throw new ChannelException("Unable to add the message to the async queue, queue bug?");
-            }
-            addAndGetCurrentSize(msg.getMessage().getLength());
-        } else {
-            super.sendMessage(destination, msg, payload);
-        }
-    }
-    
-    public boolean addToQueue(ChannelMessage msg, Member[] destination, InterceptorPayload payload) {
-        return queue.add(msg,destination,payload);
-    }
-    
-    public LinkObject removeFromQueue() {
-        return queue.remove();
-    }
-    
-    public void startQueue() {
-        msgDispatchThread = new Thread(this);
-        msgDispatchThread.setName("MessageDispatchInterceptor.MessageDispatchThread");
-        msgDispatchThread.setDaemon(true);
-        msgDispatchThread.setPriority(Thread.MAX_PRIORITY);
-        queue.setEnabled(true);
-        run = true;
-        msgDispatchThread.start();
-    }
-    
-    public void stopQueue() {
-        run = false;
-        msgDispatchThread.interrupt();
-        queue.setEnabled(false);
-        setAndGetCurrentSize(0);
-    }
-    
-    
-    public void setOptionFlag(int flag) {
-        if ( flag != Channel.SEND_OPTIONS_ASYNCHRONOUS ) log.warn("Warning, you are overriding the asynchronous option flag, this will disable the Channel.SEND_OPTIONS_ASYNCHRONOUS that other apps might use.");
-        super.setOptionFlag(flag);
-    }
-
-    public void setMaxQueueSize(long maxQueueSize) {
-        this.maxQueueSize = maxQueueSize;
-    }
-
-    public void setUseDeepClone(boolean useDeepClone) {
-        this.useDeepClone = useDeepClone;
-    }
-
-    public long getMaxQueueSize() {
-        return maxQueueSize;
-    }
-
-    public boolean getUseDeepClone() {
-        return useDeepClone;
-    }
-    
-    public long getCurrentSize() {
-        return currentSize;
-    }
-    
-    public synchronized long addAndGetCurrentSize(long inc) {
-        currentSize += inc;
-        return currentSize;
-    }
-    
-    public synchronized long setAndGetCurrentSize(long value) {
-        currentSize = value;
-        return value;
-    }
-
-    public void start(int svc) throws ChannelException {
-        //start the thread
-        if (!run ) {
-            synchronized (this) {
-                if ( !run && ((svc & Channel.SND_TX_SEQ)==Channel.SND_TX_SEQ) ) {//only start with the sender
-                    startQueue();
-                }//end if
-            }//sync
-        }//end if
-        super.start(svc);
-    }
-
-    
-    public void stop(int svc) throws ChannelException {
-        //stop the thread
-        if ( run ) {
-            synchronized (this) {
-                if ( run && ((svc & Channel.SND_TX_SEQ)==Channel.SND_TX_SEQ)) {
-                    stopQueue();
-                }//end if
-            }//sync
-        }//end if
-
-        super.stop(svc);
-    }
-    
-    public void run() {
-        while ( run ) {
-            LinkObject link = removeFromQueue();
-            if ( link == null ) continue; //should not happen unless we exceed wait time
-            while ( link != null && run ) {
-                link = sendAsyncData(link);
-            }//while
-        }//while
-    }//run
-
-    protected LinkObject sendAsyncData(LinkObject link) {
-        ChannelMessage msg = link.data();
-        Member[] destination = link.getDestination();
-        try {
-            super.sendMessage(destination,msg,null);
-            try {
-                if ( link.getHandler() != null ) link.getHandler().handleCompletion(new UniqueId(msg.getUniqueId())); 
-            } catch ( Exception ex ) {
-                log.error("Unable to report back completed message.",ex);
-            }
-        } catch ( Exception x ) {
-            ChannelException cx = null;
-            if ( x instanceof ChannelException ) cx = (ChannelException)x;
-            else cx = new ChannelException(x);
-            if ( log.isDebugEnabled() ) log.debug("Error while processing async message.",x);
-            try {
-                if (link.getHandler() != null) link.getHandler().handleError(cx, new UniqueId(msg.getUniqueId()));
-            } catch ( Exception ex ) {
-                log.error("Unable to report back error message.",ex);
-            }
-        } finally {
-            addAndGetCurrentSize(-msg.getMessage().getLength());
-            link = link.next();
-        }//try
-        return link;
-    }
-
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ */
+
+package org.apache.catalina.tribes.group.interceptors;
+
+import org.apache.catalina.tribes.Channel;
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.group.ChannelInterceptorBase;
+import org.apache.catalina.tribes.group.InterceptorPayload;
+import org.apache.catalina.tribes.transport.bio.util.FastQueue;
+import org.apache.catalina.tribes.transport.bio.util.LinkObject;
+import org.apache.catalina.tribes.UniqueId;
+
+/**
+ *
+ * The message dispatcher is a way to enable asynchronous communication
+ * through a channel. The dispatcher will look for the <code>Channel.SEND_OPTIONS_ASYNCHRONOUS</code>
+ * flag to be set, if it is, it will queue the message for delivery and immediately return to the sender.
+ * 
+ * 
+ * 
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class MessageDispatchInterceptor extends ChannelInterceptorBase implements Runnable {
+    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(MessageDispatchInterceptor.class);
+
+    protected long maxQueueSize = 1024*1024*64; //64MB
+    protected FastQueue queue = new FastQueue();
+    protected boolean run = false;
+    protected Thread msgDispatchThread = null;
+    protected long currentSize = 0;
+    protected boolean useDeepClone = true;
+    protected boolean alwaysSend = true;
+
+    public MessageDispatchInterceptor() {
+        setOptionFlag(Channel.SEND_OPTIONS_ASYNCHRONOUS);
+    }
+
+    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
+        boolean async = (msg.getOptions() & Channel.SEND_OPTIONS_ASYNCHRONOUS) == Channel.SEND_OPTIONS_ASYNCHRONOUS;
+        if ( async && run ) {
+            if ( (getCurrentSize()+msg.getMessage().getLength()) > maxQueueSize ) {
+                if ( alwaysSend ) {
+                    super.sendMessage(destination,msg,payload);
+                    return;
+                } else {
+                    throw new ChannelException("Asynchronous queue is full, reached its limit of " + maxQueueSize +" bytes, current:" + getCurrentSize() + " bytes.");
+                }//end if
+            }//end if
+            //add to queue
+            if ( useDeepClone ) msg = (ChannelMessage)msg.deepclone();
+            if (!addToQueue(msg, destination, payload) ) {
+                throw new ChannelException("Unable to add the message to the async queue, queue bug?");
+            }
+            addAndGetCurrentSize(msg.getMessage().getLength());
+        } else {
+            super.sendMessage(destination, msg, payload);
+        }
+    }
+    
+    public boolean addToQueue(ChannelMessage msg, Member[] destination, InterceptorPayload payload) {
+        return queue.add(msg,destination,payload);
+    }
+    
+    public LinkObject removeFromQueue() {
+        return queue.remove();
+    }
+    
+    public void startQueue() {
+        msgDispatchThread = new Thread(this);
+        msgDispatchThread.setName("MessageDispatchInterceptor.MessageDispatchThread");
+        msgDispatchThread.setDaemon(true);
+        msgDispatchThread.setPriority(Thread.MAX_PRIORITY);
+        queue.setEnabled(true);
+        run = true;
+        msgDispatchThread.start();
+    }
+    
+    public void stopQueue() {
+        run = false;
+        msgDispatchThread.interrupt();
+        queue.setEnabled(false);
+        setAndGetCurrentSize(0);
+    }
+    
+    
+    public void setOptionFlag(int flag) {
+        if ( flag != Channel.SEND_OPTIONS_ASYNCHRONOUS ) log.warn("Warning, you are overriding the asynchronous option flag, this will disable the Channel.SEND_OPTIONS_ASYNCHRONOUS that other apps might use.");
+        super.setOptionFlag(flag);
+    }
+
+    public void setMaxQueueSize(long maxQueueSize) {
+        this.maxQueueSize = maxQueueSize;
+    }
+
+    public void setUseDeepClone(boolean useDeepClone) {
+        this.useDeepClone = useDeepClone;
+    }
+
+    public long getMaxQueueSize() {
+        return maxQueueSize;
+    }
+
+    public boolean getUseDeepClone() {
+        return useDeepClone;
+    }
+    
+    public long getCurrentSize() {
+        return currentSize;
+    }
+    
+    public synchronized long addAndGetCurrentSize(long inc) {
+        currentSize += inc;
+        return currentSize;
+    }
+    
+    public synchronized long setAndGetCurrentSize(long value) {
+        currentSize = value;
+        return value;
+    }
+
+    public void start(int svc) throws ChannelException {
+        //start the thread
+        if (!run ) {
+            synchronized (this) {
+                if ( !run && ((svc & Channel.SND_TX_SEQ)==Channel.SND_TX_SEQ) ) {//only start with the sender
+                    startQueue();
+                }//end if
+            }//sync
+        }//end if
+        super.start(svc);
+    }
+
+    
+    public void stop(int svc) throws ChannelException {
+        //stop the thread
+        if ( run ) {
+            synchronized (this) {
+                if ( run && ((svc & Channel.SND_TX_SEQ)==Channel.SND_TX_SEQ)) {
+                    stopQueue();
+                }//end if
+            }//sync
+        }//end if
+
+        super.stop(svc);
+    }
+    
+    public void run() {
+        while ( run ) {
+            LinkObject link = removeFromQueue();
+            if ( link == null ) continue; //should not happen unless we exceed wait time
+            while ( link != null && run ) {
+                link = sendAsyncData(link);
+            }//while
+        }//while
+    }//run
+
+    protected LinkObject sendAsyncData(LinkObject link) {
+        ChannelMessage msg = link.data();
+        Member[] destination = link.getDestination();
+        try {
+            super.sendMessage(destination,msg,null);
+            try {
+                if ( link.getHandler() != null ) link.getHandler().handleCompletion(new UniqueId(msg.getUniqueId())); 
+            } catch ( Exception ex ) {
+                log.error("Unable to report back completed message.",ex);
+            }
+        } catch ( Exception x ) {
+            ChannelException cx = null;
+            if ( x instanceof ChannelException ) cx = (ChannelException)x;
+            else cx = new ChannelException(x);
+            if ( log.isDebugEnabled() ) log.debug("Error while processing async message.",x);
+            try {
+                if (link.getHandler() != null) link.getHandler().handleError(cx, new UniqueId(msg.getUniqueId()));
+            } catch ( Exception ex ) {
+                log.error("Unable to report back error message.",ex);
+            }
+        } finally {
+            addAndGetCurrentSize(-msg.getMessage().getLength());
+            link = link.next();
+        }//try
+        return link;
+    }
+
+
+}

==================================================
OrderInterceptor.java
index 8267f8f345..3e0b24494d 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java
@@ -1,839 +1,840 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- */
-package org.apache.catalina.tribes.group.interceptors;
-
-import java.util.concurrent.atomic.AtomicBoolean;
-
-import org.apache.catalina.tribes.Channel;
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelInterceptor;
-import org.apache.catalina.tribes.ChannelInterceptor.InterceptorEvent;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.UniqueId;
-import org.apache.catalina.tribes.group.AbsoluteOrder;
-import org.apache.catalina.tribes.group.ChannelInterceptorBase;
-import org.apache.catalina.tribes.group.InterceptorPayload;
-import org.apache.catalina.tribes.io.ChannelData;
-import org.apache.catalina.tribes.io.XByteBuffer;
-import org.apache.catalina.tribes.membership.MemberImpl;
-import org.apache.catalina.tribes.membership.Membership;
-import org.apache.catalina.tribes.util.Arrays;
-import org.apache.catalina.tribes.util.UUIDGenerator;
-
-/**
- * <p>Title: Auto merging leader election algorithm</p>
- *
- * <p>Description: Implementation of a simple coordinator algorithm that not only selects a coordinator,
- *    it also merges groups automatically when members are discovered that werent part of the 
- *    </p>
- * <p>This algorithm is non blocking meaning it allows for transactions while the coordination phase is going on
- * </p>
- * <p>This implementation is based on a home brewed algorithm that uses the AbsoluteOrder of a membership
- * to pass a token ring of the current membership.<br>
- * This is not the same as just using AbsoluteOrder! Consider the following scenario:<br>
- * Nodes, A,B,C,D,E on a network, in that priority. AbsoluteOrder will only work if all
- * nodes are receiving pings from all the other nodes. 
- * meaning, that node{i} receives pings from node{all}-node{i}<br>
- * but the following could happen if a multicast problem occurs.
- * A has members {B,C,D}<br>
- * B has members {A,C}<br>
- * C has members {D,E}<br>
- * D has members {A,B,C,E}<br>
- * E has members {A,C,D}<br>
- * Because the default Tribes membership implementation, relies on the multicast packets to 
- * arrive at all nodes correctly, there is nothing guaranteeing that it will.<br>
- * <br>
- * To best explain how this algorithm works, lets take the above example:
- * For simplicity we assume that a send operation is O(1) for all nodes, although this algorithm will work
- * where messages overlap, as they all depend on absolute order<br>
- * Scenario 1: A,B,C,D,E all come online at the same time
- * Eval phase, A thinks of itself as leader, B thinks of A as leader,
- * C thinks of itself as leader, D,E think of A as leader<br>
- * Token phase:<br>
- * (1) A sends out a message X{A-ldr, A-src, mbrs-A,B,C,D} to B where X is the id for the message(and the view)<br>
- * (1) C sends out a message Y{C-ldr, C-src, mbrs-C,D,E} to D where Y is the id for the message(and the view)<br>
- * (2) B receives X{A-ldr, A-src, mbrs-A,B,C,D}, sends X{A-ldr, A-src, mbrs-A,B,C,D} to C <br>
- * (2) D receives Y{C-ldr, C-src, mbrs-C,D,E} D is aware of A,B, sends Y{A-ldr, C-src, mbrs-A,B,C,D,E} to E<br>
- * (3) C receives X{A-ldr, A-src, mbrs-A,B,C,D}, sends X{A-ldr, A-src, mbrs-A,B,C,D,E} to D<br>
- * (3) E receives Y{A-ldr, C-src, mbrs-A,B,C,D,E} sends Y{A-ldr, C-src, mbrs-A,B,C,D,E} to A<br>
- * (4) D receives X{A-ldr, A-src, mbrs-A,B,C,D,E} sends sends X{A-ldr, A-src, mbrs-A,B,C,D,E} to A<br>
- * (4) A receives Y{A-ldr, C-src, mbrs-A,B,C,D,E}, holds the message, add E to its list of members<br>
- * (5) A receives X{A-ldr, A-src, mbrs-A,B,C,D,E} <br>
- * At this point, the state looks like<br>
- * A - {A-ldr, mbrs-A,B,C,D,E, id=X}<br>
- * B - {A-ldr, mbrs-A,B,C,D, id=X}<br>
- * C - {A-ldr, mbrs-A,B,C,D,E, id=X}<br>
- * D - {A-ldr, mbrs-A,B,C,D,E, id=X}<br>
- * E - {A-ldr, mbrs-A,B,C,D,E, id=Y}<br>
- * <br>
- * A message doesn't stop until it reaches its original sender, unless its dropped by a higher leader.
- * As you can see, E still thinks the viewId=Y, which is not correct. But at this point we have 
- * arrived at the same membership and all nodes are informed of each other.<br>
- * To synchronize the rest we simply perform the following check at A when A receives X:<br>
- * Original X{A-ldr, A-src, mbrs-A,B,C,D} == Arrived X{A-ldr, A-src, mbrs-A,B,C,D,E}<br>
- * Since the condition is false, A, will resend the token, and A sends X{A-ldr, A-src, mbrs-A,B,C,D,E} to B
- * When A receives X again, the token is complete. <br>
- * Optionally, A can send a message X{A-ldr, A-src, mbrs-A,B,C,D,E confirmed} to A,B,C,D,E who then
- * install and accept the view.
- * </p>
- * <p>
- * Lets assume that C1 arrives, C1 has lower priority than C, but higher priority than D.<br>
- * Lets also assume that C1 sees the following view {B,D,E}<br>
- * C1 waits for a token to arrive. When the token arrives, the same scenario as above will happen.<br>
- * In the scenario where C1 sees {D,E} and A,B,C can not see C1, no token will ever arrive.<br>
- * In this case, C1 sends a Z{C1-ldr, C1-src, mbrs-C1,D,E} to D<br>
- * D receives Z{C1-ldr, C1-src, mbrs-C1,D,E} and sends Z{A-ldr, C1-src, mbrs-A,B,C,C1,D,E} to E<br>
- * E receives Z{A-ldr, C1-src, mbrs-A,B,C,C1,D,E} and sends it to A<br>
- * A sends Z{A-ldr, A-src, mbrs-A,B,C,C1,D,E} to B and the chain continues until A receives the token again.
- * At that time A optionally sends out Z{A-ldr, A-src, mbrs-A,B,C,C1,D,E, confirmed} to A,B,C,C1,D,E
- * </p>
- * <p>To ensure that the view gets implemented at all nodes at the same time, 
- *    A will send out a VIEW_CONF message, this is the 'confirmed' message that is optional above.
- * <p>Ideally, the interceptor below this one would be the TcpFailureDetector to ensure correct memberships</p>
- *
- * <p>The example above, of course can be simplified with a finite statemachine:<br>
- * But I suck at writing state machines, my head gets all confused. One day I will document this algorithm though.<br>
- * Maybe I'll do a state diagram :)
- * </p>
- * <h2>State Diagrams</h2>
- * <a href="http://people.apache.org/~fhanik/tribes/docs/leader-election-initiate-election.jpg">Initiate an election</a><br><br>
- * <a href="http://people.apache.org/~fhanik/tribes/docs/leader-election-message-arrives.jpg">Receive an election message</a><br><br>
- * 
- * @author Filip Hanik
- * @version 1.0
- * 
- * 
- * 
- */
-public class NonBlockingCoordinator extends ChannelInterceptorBase {
-    
-    /**
-     * header for a coordination message
-     */
-    protected static final byte[] COORD_HEADER = new byte[] {-86, 38, -34, -29, -98, 90, 65, 63, -81, -122, -6, -110, 99, -54, 13, 63};
-    /**
-     * Coordination request
-     */
-    protected static final byte[] COORD_REQUEST = new byte[] {104, -95, -92, -42, 114, -36, 71, -19, -79, 20, 122, 101, -1, -48, -49, 30};
-    /**
-     * Coordination confirmation, for blocking installations
-     */
-    protected static final byte[] COORD_CONF = new byte[] {67, 88, 107, -86, 69, 23, 76, -70, -91, -23, -87, -25, -125, 86, 75, 20};
-    
-    /**
-     * Alive message
-     */
-    protected static final byte[] COORD_ALIVE = new byte[] {79, -121, -25, -15, -59, 5, 64, 94, -77, 113, -119, -88, 52, 114, -56, -46,
-                                                            -18, 102, 10, 34, -127, -9, 71, 115, -70, 72, -101, 88, 72, -124, 127, 111,
-                                                            74, 76, -116, 50, 111, 103, 65, 3, -77, 51, -35, 0, 119, 117, 9, -26,
-                                                            119, 50, -75, -105, -102, 36, 79, 37, -68, -84, -123, 15, -22, -109, 106, -55};
-    /**
-     * Time to wait for coordination timeout
-     */
-    protected long waitForCoordMsgTimeout = 15000;
-    /**
-     * Our current view
-     */
-    protected Membership view = null;
-    /**
-     * Out current viewId
-     */
-    protected UniqueId viewId;
-
-    /**
-     * Our nonblocking membership
-     */
-    protected Membership membership = null;
-    
-    /**
-     * indicates that we are running an election 
-     * and this is the one we are running
-     */
-    protected UniqueId suggestedviewId;
-    protected Membership suggestedView;
-    
-    protected boolean started = false;
-    protected final int startsvc = 0xFFFF;
-    
-    protected Object electionMutex = new Object();
-    
-    protected AtomicBoolean coordMsgReceived = new AtomicBoolean(false);
-    
-    public NonBlockingCoordinator() {
-        super();
-    }
-    
-//============================================================================================================    
-//              COORDINATION HANDLING
-//============================================================================================================
-    
-    public void startElection(boolean force) throws ChannelException {
-        synchronized (electionMutex) {
-            MemberImpl local = (MemberImpl)getLocalMember(false);
-            MemberImpl[] others = (MemberImpl[])membership.getMembers();
-            fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_START_ELECT,this,"Election initated"));
-            if ( others.length == 0 ) {
-                this.viewId = new UniqueId(UUIDGenerator.randomUUID(false));
-                this.view = new Membership(local,AbsoluteOrder.comp, true);
-                this.handleViewConf(this.createElectionMsg(local,others,local),local,view);
-                return; //the only member, no need for an election
-            }
-            if ( suggestedviewId != null ) {
-                
-                if ( view != null && Arrays.diff(view,suggestedView,local).length == 0 &&  Arrays.diff(suggestedView,view,local).length == 0) {
-                    suggestedviewId = null;
-                    suggestedView = null;
-                    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED,this,"Election abandoned, running election matches view"));
-                } else {
-                    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED,this,"Election abandoned, election running"));
-                }
-                return; //election already running, I'm not allowed to have two of them
-            }
-            if ( view != null && Arrays.diff(view,membership,local).length == 0 &&  Arrays.diff(membership,view,local).length == 0) {
-                fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED,this,"Election abandoned, view matches membership"));
-                return; //already have this view installed
-            }            
-            int prio = AbsoluteOrder.comp.compare(local,others[0]);
-            MemberImpl leader = ( prio < 0 )?local:others[0];//am I the leader in my view?
-            if ( local.equals(leader) || force ) {
-                CoordinationMessage msg = createElectionMsg(local, others, leader);
-                suggestedviewId = msg.getId();
-                suggestedView = new Membership(local,AbsoluteOrder.comp,true);
-                Arrays.fill(suggestedView,msg.getMembers());
-                fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_PROCESS_ELECT,this,"Election, sending request"));
-                sendElectionMsg(local,others[0],msg);
-            } else {
-                try {
-                    coordMsgReceived.set(false);
-                    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_WAIT_FOR_MSG,this,"Election, waiting for request"));
-                    electionMutex.wait(waitForCoordMsgTimeout);
-                }catch ( InterruptedException x ) {
-                    Thread.currentThread().interrupted();
-                }
-                if ( suggestedviewId == null && (!coordMsgReceived.get())) {
-                    //no message arrived, send the coord msg
-//                    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_WAIT_FOR_MSG,this,"Election, waiting timed out."));
-//                    startElection(true);
-                    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED,this,"Election abandoned, waiting timed out."));
-                } else {
-                    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED,this,"Election abandoned, received a message"));
-                }
-            }//end if
-            
-        }
-    }
-
-    private CoordinationMessage createElectionMsg(MemberImpl local, MemberImpl[] others, MemberImpl leader) {
-        Membership m = new Membership(local,AbsoluteOrder.comp,true);
-        Arrays.fill(m,others);
-        MemberImpl[] mbrs = m.getMembers();
-        m.reset(); 
-        CoordinationMessage msg = new CoordinationMessage(leader, local, mbrs,new UniqueId(UUIDGenerator.randomUUID(true)), this.COORD_REQUEST);
-        return msg;
-    }
-
-    protected void sendElectionMsg(MemberImpl local, MemberImpl next, CoordinationMessage msg) throws ChannelException {
-        fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_SEND_MSG,this,"Sending election message to("+next.getName()+")"));
-        super.sendMessage(new Member[] {next}, createData(msg, local), null);
-    }
-    
-    protected void sendElectionMsgToNextInline(MemberImpl local, CoordinationMessage msg) throws ChannelException { 
-        int next = Arrays.nextIndex(local,msg.getMembers());
-        int current = next;
-        msg.leader = msg.getMembers()[0];
-        boolean sent =  false;
-        while ( !sent && current >= 0 ) {
-            try {
-                sendElectionMsg(local, (MemberImpl) msg.getMembers()[current], msg);
-                sent = true;
-            }catch ( ChannelException x  ) {
-                log.warn("Unable to send election message to:"+msg.getMembers()[current]);
-                current = Arrays.nextIndex(msg.getMembers()[current],msg.getMembers());
-                if ( current == next ) throw x;
-            }
-        }
-    }
-    
-    public Member getNextInLine(MemberImpl local, MemberImpl[] others) {
-        MemberImpl result = null;
-        for ( int i=0; i<others.length; i++ ) {
-            
-        }
-        return result;
-    }
-    
-    public ChannelData createData(CoordinationMessage msg, MemberImpl local) {
-        msg.write();
-        ChannelData data = new ChannelData(true);
-        data.setAddress(local);
-        data.setMessage(msg.getBuffer());
-        data.setOptions(Channel.SEND_OPTIONS_USE_ACK);
-        data.setTimestamp(System.currentTimeMillis());
-        return data;
-    }
-    
-    protected void viewChange(UniqueId viewId, Member[] view) {
-        //invoke any listeners
-    }
-    
-    protected boolean alive(Member mbr) {
-        return TcpFailureDetector.memberAlive(mbr,
-                                              COORD_ALIVE,
-                                              false,
-                                              false,
-                                              waitForCoordMsgTimeout,
-                                              waitForCoordMsgTimeout,
-                                              getOptionFlag());
-    }
-    
-    protected Membership mergeOnArrive(CoordinationMessage msg, Member sender) {
-        fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_PRE_MERGE,this,"Pre merge"));
-        MemberImpl local = (MemberImpl)getLocalMember(false);
-        Membership merged = new Membership(local,AbsoluteOrder.comp,true);
-        Arrays.fill(merged,msg.getMembers());
-        Arrays.fill(merged,getMembers());
-        Member[] diff = Arrays.diff(merged,membership,local);
-        for ( int i=0; i<diff.length; i++ ) {
-            if (!alive(diff[i])) merged.removeMember((MemberImpl)diff[i]);
-            else memberAdded(diff[i],false);
-        }
-        fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_POST_MERGE,this,"Post merge"));
-        return merged;
-    }
-    
-    protected void processCoordMessage(CoordinationMessage msg, Member sender) throws ChannelException {
-        if ( !coordMsgReceived.get() ) {
-            coordMsgReceived.set(true);
-            synchronized (electionMutex) { electionMutex.notifyAll();}
-        } 
-        msg.timestamp = System.currentTimeMillis();
-        Membership merged = mergeOnArrive(msg, sender);
-        if (isViewConf(msg)) handleViewConf(msg, sender, merged);
-        else handleToken(msg, sender, merged);
-        ClassLoader loader;
-
-    }
-    
-    protected void handleToken(CoordinationMessage msg, Member sender,Membership merged) throws ChannelException {
-        MemberImpl local = (MemberImpl)getLocalMember(false);
-        if ( local.equals(msg.getSource()) ) {
-            //my message msg.src=local
-            handleMyToken(local, msg, sender,merged);
-        } else {
-            handleOtherToken(local, msg, sender,merged);
-        }
-    }
-    
-    protected void handleMyToken(MemberImpl local, CoordinationMessage msg, Member sender,Membership merged) throws ChannelException {
-        if ( local.equals(msg.getLeader()) ) {
-            //no leadership change
-            if ( Arrays.sameMembers(msg.getMembers(),merged.getMembers()) ) {
-                msg.type = COORD_CONF;
-                super.sendMessage(Arrays.remove(msg.getMembers(),local),createData(msg,local),null);
-                handleViewConf(msg,local,merged);
-            } else {
-                //membership change
-                suggestedView = new Membership(local,AbsoluteOrder.comp,true);
-                suggestedviewId = msg.getId();
-                Arrays.fill(suggestedView,merged.getMembers());
-                msg.view = (MemberImpl[])merged.getMembers();
-                sendElectionMsgToNextInline(local,msg);
-            }
-        } else {
-            //leadership change
-            suggestedView = null;
-            suggestedviewId = null;
-            msg.view = (MemberImpl[])merged.getMembers();
-            sendElectionMsgToNextInline(local,msg);
-        }
-    }
-    
-    protected void handleOtherToken(MemberImpl local, CoordinationMessage msg, Member sender,Membership merged) throws ChannelException {
-        if ( local.equals(msg.getLeader()) ) {
-            //I am the new leader
-            //startElection(false);
-        } else {
-            msg.view = (MemberImpl[])merged.getMembers();
-            sendElectionMsgToNextInline(local,msg);
-        }
-    }
-    
-    protected void handleViewConf(CoordinationMessage msg, Member sender,Membership merged) throws ChannelException {
-        if ( viewId != null && msg.getId().equals(viewId) ) return;//we already have this view
-        view = new Membership((MemberImpl)getLocalMember(false),AbsoluteOrder.comp,true);
-        Arrays.fill(view,msg.getMembers());
-        viewId = msg.getId();
-        
-        if ( viewId.equals(suggestedviewId) ) {
-            suggestedView = null;
-            suggestedviewId = null;
-        }
-        
-        if (suggestedView != null && AbsoluteOrder.comp.compare(suggestedView.getMembers()[0],merged.getMembers()[0])<0 ) {
-            suggestedView = null;
-            suggestedviewId = null;
-        }
-        
-        viewChange(viewId,view.getMembers());
-        fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_CONF_RX,this,"Accepted View"));
-        
-        if ( suggestedviewId == null && hasHigherPriority(merged.getMembers(),membership.getMembers()) ) {
-            startElection(false);
-        }
-    }
-    
-    protected boolean isViewConf(CoordinationMessage msg) {
-        return Arrays.contains(msg.getType(),0,COORD_CONF,0,COORD_CONF.length);
-    }
-    
-    protected boolean hasHigherPriority(Member[] complete, Member[] local) {
-        if ( local == null || local.length == 0 ) return false;
-        if ( complete == null || complete.length == 0 ) return true;
-        AbsoluteOrder.absoluteOrder(complete);
-        AbsoluteOrder.absoluteOrder(local);
-        return (AbsoluteOrder.comp.compare(complete[0],local[0]) > 0);
-        
-    }
-
-    
-    /**
-     * Returns coordinator if one is available
-     * @return Member
-     */
-    public Member getCoordinator() {
-        return (view != null && view.hasMembers()) ? view.getMembers()[0] : null;
-    }
-    
-    public Member[] getView() {
-        return (view != null && view.hasMembers()) ? view.getMembers() : new Member[0];
-    }
-    
-    public UniqueId getViewId() {
-        return viewId;
-    }
-    
-    /**
-    * Block in/out messages while a election is going on
-    */
-   protected void halt() {
-
-   }
-
-   /**
-    * Release lock for in/out messages election is completed
-    */
-   protected void release() {
-
-   }
-
-   /**
-    * Wait for an election to end
-    */
-   protected void waitForRelease() {
-
-   }
-
-    
-//============================================================================================================    
-//              OVERRIDDEN METHODS FROM CHANNEL INTERCEPTOR BASE    
-//============================================================================================================
-    public void start(int svc) throws ChannelException {
-            if (membership == null) setupMembership();
-            if (started)return;
-            fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_START, this, "Before start"));
-            super.start(startsvc);
-            started = true;
-            if (view == null) view = new Membership( (MemberImpl)super.getLocalMember(true), AbsoluteOrder.comp, true);
-            fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_START, this, "After start"));
-            startElection(false);
-    }
-
-    public void stop(int svc) throws ChannelException {
-        try {
-            halt();
-            synchronized (electionMutex) {
-                if (!started)return;
-                started = false;
-                fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_STOP, this, "Before stop"));
-                super.stop(startsvc);
-                this.view = null;
-                this.viewId = null;
-                this.suggestedView = null;
-                this.suggestedviewId = null;
-                this.membership.reset();
-                fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_STOP, this, "After stop"));
-            }
-        }finally {
-            release();
-        }
-    }
-    
-    
-    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
-        waitForRelease();
-        super.sendMessage(destination, msg, payload);
-    }
-
-    public void messageReceived(ChannelMessage msg) {
-        if ( Arrays.contains(msg.getMessage().getBytesDirect(),0,COORD_ALIVE,0,COORD_ALIVE.length) ) {
-            //ignore message, its an alive message
-            fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_MSG_ARRIVE,this,"Alive Message"));
-
-        } else if ( Arrays.contains(msg.getMessage().getBytesDirect(),0,COORD_HEADER,0,COORD_HEADER.length) ) {
-            try {
-                CoordinationMessage cmsg = new CoordinationMessage(msg.getMessage());
-                Member[] cmbr = cmsg.getMembers();
-                fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_MSG_ARRIVE,this,"Coord Msg Arrived("+Arrays.toNameString(cmbr)+")"));
-                processCoordMessage(cmsg, msg.getAddress());
-            }catch ( ChannelException x ) {
-                log.error("Error processing coordination message. Could be fatal.",x);
-            }
-        } else {
-            super.messageReceived(msg);
-        }
-    }
-
-    public boolean accept(ChannelMessage msg) {
-        return super.accept(msg);
-    }
-
-    public void memberAdded(Member member) {
-        memberAdded(member,true);
-    }
-
-    public void memberAdded(Member member,boolean elect) {
-        try {
-            if ( membership == null ) setupMembership();
-            if ( membership.memberAlive((MemberImpl)member) ) super.memberAdded(member);
-            try {
-                fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_MBR_ADD,this,"Member add("+member.getName()+")"));
-                if (started && elect) startElection(false);
-            }catch ( ChannelException x ) {
-                log.error("Unable to start election when member was added.",x);
-            }
-        }finally {
-        }
-        
-    }
-
-    public void memberDisappeared(Member member) {
-        try {
-            
-            membership.removeMember((MemberImpl)member);
-            super.memberDisappeared(member);
-            try {
-                fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_MBR_DEL,this,"Member remove("+member.getName()+")"));
-                if ( started && (isCoordinator() || isHighest()) ) 
-                    startElection(true); //to do, if a member disappears, only the coordinator can start
-            }catch ( ChannelException x ) {
-                log.error("Unable to start election when member was removed.",x);
-            }
-        }finally {
-        }
-    }
-    
-    public boolean isHighest() {
-        Member local = getLocalMember(false);
-        if ( membership.getMembers().length == 0 ) return true;
-        else return AbsoluteOrder.comp.compare(local,membership.getMembers()[0])<=0;
-    }
-    
-    public boolean isCoordinator() {
-        Member coord = getCoordinator();
-        return coord != null && getLocalMember(false).equals(coord);
-    }
-
-    public void heartbeat() {
-        try {
-            MemberImpl local = (MemberImpl)getLocalMember(false);
-            if ( view != null && (Arrays.diff(view,membership,local).length != 0 ||  Arrays.diff(membership,view,local).length != 0) ) {
-                if ( isHighest() ) {
-                    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_START_ELECT, this,
-                                                               "Heartbeat found inconsistency, restart election"));
-                    startElection(true);
-                }            
-            }
-        } catch ( Exception x  ){
-            log.error("Unable to perform heartbeat.",x);
-        } finally {
-            super.heartbeat();
-        }
-    }
-
-    /**
-     * has members
-     */
-    public boolean hasMembers() {
-        
-        return membership.hasMembers();
-    }
-
-    /**
-     * Get all current cluster members
-     * @return all members or empty array
-     */
-    public Member[] getMembers() {
-        
-        return membership.getMembers();
-    }
-
-    /**
-     *
-     * @param mbr Member
-     * @return Member
-     */
-    public Member getMember(Member mbr) {
-        
-        return membership.getMember(mbr);
-    }
-
-    /**
-     * Return the member that represents this node.
-     *
-     * @return Member
-     */
-    public Member getLocalMember(boolean incAlive) {
-        Member local = super.getLocalMember(incAlive);
-        if ( view == null && (local != null)) setupMembership();
-        return local;
-    }
-    
-    protected synchronized void setupMembership() {
-        if ( membership == null ) {
-            membership  = new Membership((MemberImpl)super.getLocalMember(true),AbsoluteOrder.comp,false);
-        }
-    }
-    
-    
-//============================================================================================================    
-//              HELPER CLASSES FOR COORDINATION
-//============================================================================================================
-    
-    
-   
-    
-    public static class CoordinationMessage {
-        //X{A-ldr, A-src, mbrs-A,B,C,D}
-        protected XByteBuffer buf;
-        protected MemberImpl leader;
-        protected MemberImpl source;
-        protected MemberImpl[] view;
-        protected UniqueId id;
-        protected byte[] type;
-        protected long timestamp = System.currentTimeMillis();
-        
-        public CoordinationMessage(XByteBuffer buf) {
-            this.buf = buf;
-            parse();
-        }
-
-        public CoordinationMessage(MemberImpl leader,
-                                   MemberImpl source, 
-                                   MemberImpl[] view,
-                                   UniqueId id,
-                                   byte[] type) {
-            this.buf = new XByteBuffer(4096,false);
-            this.leader = leader;
-            this.source = source;
-            this.view = view;
-            this.id = id;
-            this.type = type;
-            this.write();
-        }
-        
-
-        public byte[] getHeader() {
-            return NonBlockingCoordinator.COORD_HEADER;
-        }
-        
-        public MemberImpl getLeader() {
-            if ( leader == null ) parse();
-            return leader;
-        }
-        
-        public MemberImpl getSource() {
-            if ( source == null ) parse();
-            return source;
-        }
-        
-        public UniqueId getId() {
-            if ( id == null ) parse();
-            return id;
-        }
-        
-        public MemberImpl[] getMembers() {
-            if ( view == null ) parse();
-            return view;
-        }
-        
-        public byte[] getType() {
-            if (type == null ) parse();
-            return type;
-        }
-        
-        public XByteBuffer getBuffer() {
-            return this.buf;
-        }
-        
-        public void parse() {
-            //header
-            int offset = 16;
-            //leader
-            int ldrLen = buf.toInt(buf.getBytesDirect(),offset);
-            offset += 4;
-            byte[] ldr = new byte[ldrLen];
-            System.arraycopy(buf.getBytesDirect(),offset,ldr,0,ldrLen);
-            leader = MemberImpl.getMember(ldr);
-            offset += ldrLen;
-            //source
-            int srcLen = buf.toInt(buf.getBytesDirect(),offset);
-            offset += 4;
-            byte[] src = new byte[srcLen];
-            System.arraycopy(buf.getBytesDirect(),offset,src,0,srcLen);
-            source = MemberImpl.getMember(src);
-            offset += srcLen;
-            //view
-            int mbrCount = buf.toInt(buf.getBytesDirect(),offset);
-            offset += 4;
-            view = new MemberImpl[mbrCount];
-            for (int i=0; i<view.length; i++ ) {
-                int mbrLen = buf.toInt(buf.getBytesDirect(),offset);
-                offset += 4;
-                byte[] mbr = new byte[mbrLen];
-                System.arraycopy(buf.getBytesDirect(), offset, mbr, 0, mbrLen);
-                view[i] = MemberImpl.getMember(mbr);
-                offset += mbrLen;
-            }
-            //id
-            this.id = new UniqueId(buf.getBytesDirect(),offset,16);
-            offset += 16;
-            type = new byte[16];
-            System.arraycopy(buf.getBytesDirect(), offset, type, 0, type.length);
-            offset += 16;
-            
-        }
-        
-        public void write() {
-            buf.reset();
-            //header
-            buf.append(COORD_HEADER,0,COORD_HEADER.length);
-            //leader
-            byte[] ldr = leader.getData(false,false);
-            buf.append(ldr.length);
-            buf.append(ldr,0,ldr.length);
-            ldr = null;
-            //source
-            byte[] src = source.getData(false,false);
-            buf.append(src.length);
-            buf.append(src,0,src.length);
-            src = null;
-            //view
-            buf.append(view.length);
-            for (int i=0; i<view.length; i++ ) {
-                byte[] mbr = view[i].getData(false,false);
-                buf.append(mbr.length);
-                buf.append(mbr,0,mbr.length);
-            }
-            //id
-            buf.append(id.getBytes(),0,id.getBytes().length);
-            buf.append(type,0,type.length);
-        }
-    }
-    
-    public void fireInterceptorEvent(InterceptorEvent event) {
-        if (event instanceof CoordinationEvent &&
-            ((CoordinationEvent)event).type == CoordinationEvent.EVT_CONF_RX) 
-            log.info(event);
-    }
-    
-    public static class CoordinationEvent implements InterceptorEvent {
-        public static final int EVT_START = 1;
-        public static final int EVT_MBR_ADD = 2;
-        public static final int EVT_MBR_DEL = 3;
-        public static final int EVT_START_ELECT = 4;
-        public static final int EVT_PROCESS_ELECT = 5;
-        public static final int EVT_MSG_ARRIVE = 6;
-        public static final int EVT_PRE_MERGE = 7;
-        public static final int EVT_POST_MERGE = 8;
-        public static final int EVT_WAIT_FOR_MSG = 9;
-        public static final int EVT_SEND_MSG = 10;
-        public static final int EVT_STOP = 11;
-        public static final int EVT_CONF_RX = 12;
-        public static final int EVT_ELECT_ABANDONED = 13;
-        
-        int type;
-        ChannelInterceptor interceptor;
-        Member coord; 
-        Member[] mbrs;
-        String info;
-        Membership view;
-        Membership suggestedView;
-        public CoordinationEvent(int type,ChannelInterceptor interceptor, String info) {
-            this.type = type;
-            this.interceptor = interceptor;
-            this.coord = ((NonBlockingCoordinator)interceptor).getCoordinator();
-            this.mbrs = ((NonBlockingCoordinator)interceptor).membership.getMembers();
-            this.info = info;
-            this.view = ((NonBlockingCoordinator)interceptor).view;
-            this.suggestedView = ((NonBlockingCoordinator)interceptor).suggestedView;
-        }
-        
-        public int getEventType() {
-            return type;
-        }
-        
-        public String getEventTypeDesc() {
-            switch (type) {
-                case  EVT_START: return "EVT_START:"+info;
-                case  EVT_MBR_ADD: return "EVT_MBR_ADD:"+info;
-                case  EVT_MBR_DEL: return "EVT_MBR_DEL:"+info;
-                case  EVT_START_ELECT: return "EVT_START_ELECT:"+info;
-                case  EVT_PROCESS_ELECT: return "EVT_PROCESS_ELECT:"+info;
-                case  EVT_MSG_ARRIVE: return "EVT_MSG_ARRIVE:"+info;
-                case  EVT_PRE_MERGE: return "EVT_PRE_MERGE:"+info;
-                case  EVT_POST_MERGE: return "EVT_POST_MERGE:"+info;
-                case  EVT_WAIT_FOR_MSG: return "EVT_WAIT_FOR_MSG:"+info;
-                case  EVT_SEND_MSG: return "EVT_SEND_MSG:"+info;
-                case  EVT_STOP: return "EVT_STOP:"+info;
-                case  EVT_CONF_RX: return "EVT_CONF_RX:"+info;
-                case EVT_ELECT_ABANDONED: return "EVT_ELECT_ABANDONED:"+info;
-                default: return "Unknown";
-            }
-        }
-        
-        public ChannelInterceptor getInterceptor() {
-            return interceptor;
-        }
-        
-        public String toString() {
-            StringBuffer buf = new StringBuffer("CoordinationEvent[type=");
-            buf.append(type).append("\n\tLocal:");
-            Member local = interceptor.getLocalMember(false);
-            buf.append(local!=null?local.getName():"").append("\n\tCoord:");
-            buf.append(coord!=null?coord.getName():"").append("\n\tView:");
-            buf.append(Arrays.toNameString(view!=null?view.getMembers():null)).append("\n\tSuggested View:");
-            buf.append(Arrays.toNameString(suggestedView!=null?suggestedView.getMembers():null)).append("\n\tMembers:");
-            buf.append(Arrays.toNameString(mbrs)).append("\n\tInfo:");
-            buf.append(info).append("]");
-            return buf.toString();
-        }
-    }
-
-    
-
-
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ */
+package org.apache.catalina.tribes.group.interceptors;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.apache.catalina.tribes.Channel;
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelInterceptor;
+import org.apache.catalina.tribes.ChannelInterceptor.InterceptorEvent;
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.UniqueId;
+import org.apache.catalina.tribes.group.AbsoluteOrder;
+import org.apache.catalina.tribes.group.ChannelInterceptorBase;
+import org.apache.catalina.tribes.group.InterceptorPayload;
+import org.apache.catalina.tribes.io.ChannelData;
+import org.apache.catalina.tribes.io.XByteBuffer;
+import org.apache.catalina.tribes.membership.MemberImpl;
+import org.apache.catalina.tribes.membership.Membership;
+import org.apache.catalina.tribes.util.Arrays;
+import org.apache.catalina.tribes.util.UUIDGenerator;
+
+/**
+ * <p>Title: Auto merging leader election algorithm</p>
+ *
+ * <p>Description: Implementation of a simple coordinator algorithm that not only selects a coordinator,
+ *    it also merges groups automatically when members are discovered that werent part of the 
+ *    </p>
+ * <p>This algorithm is non blocking meaning it allows for transactions while the coordination phase is going on
+ * </p>
+ * <p>This implementation is based on a home brewed algorithm that uses the AbsoluteOrder of a membership
+ * to pass a token ring of the current membership.<br>
+ * This is not the same as just using AbsoluteOrder! Consider the following scenario:<br>
+ * Nodes, A,B,C,D,E on a network, in that priority. AbsoluteOrder will only work if all
+ * nodes are receiving pings from all the other nodes. 
+ * meaning, that node{i} receives pings from node{all}-node{i}<br>
+ * but the following could happen if a multicast problem occurs.
+ * A has members {B,C,D}<br>
+ * B has members {A,C}<br>
+ * C has members {D,E}<br>
+ * D has members {A,B,C,E}<br>
+ * E has members {A,C,D}<br>
+ * Because the default Tribes membership implementation, relies on the multicast packets to 
+ * arrive at all nodes correctly, there is nothing guaranteeing that it will.<br>
+ * <br>
+ * To best explain how this algorithm works, lets take the above example:
+ * For simplicity we assume that a send operation is O(1) for all nodes, although this algorithm will work
+ * where messages overlap, as they all depend on absolute order<br>
+ * Scenario 1: A,B,C,D,E all come online at the same time
+ * Eval phase, A thinks of itself as leader, B thinks of A as leader,
+ * C thinks of itself as leader, D,E think of A as leader<br>
+ * Token phase:<br>
+ * (1) A sends out a message X{A-ldr, A-src, mbrs-A,B,C,D} to B where X is the id for the message(and the view)<br>
+ * (1) C sends out a message Y{C-ldr, C-src, mbrs-C,D,E} to D where Y is the id for the message(and the view)<br>
+ * (2) B receives X{A-ldr, A-src, mbrs-A,B,C,D}, sends X{A-ldr, A-src, mbrs-A,B,C,D} to C <br>
+ * (2) D receives Y{C-ldr, C-src, mbrs-C,D,E} D is aware of A,B, sends Y{A-ldr, C-src, mbrs-A,B,C,D,E} to E<br>
+ * (3) C receives X{A-ldr, A-src, mbrs-A,B,C,D}, sends X{A-ldr, A-src, mbrs-A,B,C,D,E} to D<br>
+ * (3) E receives Y{A-ldr, C-src, mbrs-A,B,C,D,E} sends Y{A-ldr, C-src, mbrs-A,B,C,D,E} to A<br>
+ * (4) D receives X{A-ldr, A-src, mbrs-A,B,C,D,E} sends sends X{A-ldr, A-src, mbrs-A,B,C,D,E} to A<br>
+ * (4) A receives Y{A-ldr, C-src, mbrs-A,B,C,D,E}, holds the message, add E to its list of members<br>
+ * (5) A receives X{A-ldr, A-src, mbrs-A,B,C,D,E} <br>
+ * At this point, the state looks like<br>
+ * A - {A-ldr, mbrs-A,B,C,D,E, id=X}<br>
+ * B - {A-ldr, mbrs-A,B,C,D, id=X}<br>
+ * C - {A-ldr, mbrs-A,B,C,D,E, id=X}<br>
+ * D - {A-ldr, mbrs-A,B,C,D,E, id=X}<br>
+ * E - {A-ldr, mbrs-A,B,C,D,E, id=Y}<br>
+ * <br>
+ * A message doesn't stop until it reaches its original sender, unless its dropped by a higher leader.
+ * As you can see, E still thinks the viewId=Y, which is not correct. But at this point we have 
+ * arrived at the same membership and all nodes are informed of each other.<br>
+ * To synchronize the rest we simply perform the following check at A when A receives X:<br>
+ * Original X{A-ldr, A-src, mbrs-A,B,C,D} == Arrived X{A-ldr, A-src, mbrs-A,B,C,D,E}<br>
+ * Since the condition is false, A, will resend the token, and A sends X{A-ldr, A-src, mbrs-A,B,C,D,E} to B
+ * When A receives X again, the token is complete. <br>
+ * Optionally, A can send a message X{A-ldr, A-src, mbrs-A,B,C,D,E confirmed} to A,B,C,D,E who then
+ * install and accept the view.
+ * </p>
+ * <p>
+ * Lets assume that C1 arrives, C1 has lower priority than C, but higher priority than D.<br>
+ * Lets also assume that C1 sees the following view {B,D,E}<br>
+ * C1 waits for a token to arrive. When the token arrives, the same scenario as above will happen.<br>
+ * In the scenario where C1 sees {D,E} and A,B,C can not see C1, no token will ever arrive.<br>
+ * In this case, C1 sends a Z{C1-ldr, C1-src, mbrs-C1,D,E} to D<br>
+ * D receives Z{C1-ldr, C1-src, mbrs-C1,D,E} and sends Z{A-ldr, C1-src, mbrs-A,B,C,C1,D,E} to E<br>
+ * E receives Z{A-ldr, C1-src, mbrs-A,B,C,C1,D,E} and sends it to A<br>
+ * A sends Z{A-ldr, A-src, mbrs-A,B,C,C1,D,E} to B and the chain continues until A receives the token again.
+ * At that time A optionally sends out Z{A-ldr, A-src, mbrs-A,B,C,C1,D,E, confirmed} to A,B,C,C1,D,E
+ * </p>
+ * <p>To ensure that the view gets implemented at all nodes at the same time, 
+ *    A will send out a VIEW_CONF message, this is the 'confirmed' message that is optional above.
+ * <p>Ideally, the interceptor below this one would be the TcpFailureDetector to ensure correct memberships</p>
+ *
+ * <p>The example above, of course can be simplified with a finite statemachine:<br>
+ * But I suck at writing state machines, my head gets all confused. One day I will document this algorithm though.<br>
+ * Maybe I'll do a state diagram :)
+ * </p>
+ * <h2>State Diagrams</h2>
+ * <a href="http://people.apache.org/~fhanik/tribes/docs/leader-election-initiate-election.jpg">Initiate an election</a><br><br>
+ * <a href="http://people.apache.org/~fhanik/tribes/docs/leader-election-message-arrives.jpg">Receive an election message</a><br><br>
+ * 
+ * @author Filip Hanik
+ * @version 1.0
+ * 
+ * 
+ * 
+ */
+public class NonBlockingCoordinator extends ChannelInterceptorBase {
+    
+    /**
+     * header for a coordination message
+     */
+    protected static final byte[] COORD_HEADER = new byte[] {-86, 38, -34, -29, -98, 90, 65, 63, -81, -122, -6, -110, 99, -54, 13, 63};
+    /**
+     * Coordination request
+     */
+    protected static final byte[] COORD_REQUEST = new byte[] {104, -95, -92, -42, 114, -36, 71, -19, -79, 20, 122, 101, -1, -48, -49, 30};
+    /**
+     * Coordination confirmation, for blocking installations
+     */
+    protected static final byte[] COORD_CONF = new byte[] {67, 88, 107, -86, 69, 23, 76, -70, -91, -23, -87, -25, -125, 86, 75, 20};
+    
+    /**
+     * Alive message
+     */
+    protected static final byte[] COORD_ALIVE = new byte[] {79, -121, -25, -15, -59, 5, 64, 94, -77, 113, -119, -88, 52, 114, -56, -46,
+                                                            -18, 102, 10, 34, -127, -9, 71, 115, -70, 72, -101, 88, 72, -124, 127, 111,
+                                                            74, 76, -116, 50, 111, 103, 65, 3, -77, 51, -35, 0, 119, 117, 9, -26,
+                                                            119, 50, -75, -105, -102, 36, 79, 37, -68, -84, -123, 15, -22, -109, 106, -55};
+    /**
+     * Time to wait for coordination timeout
+     */
+    protected long waitForCoordMsgTimeout = 15000;
+    /**
+     * Our current view
+     */
+    protected Membership view = null;
+    /**
+     * Out current viewId
+     */
+    protected UniqueId viewId;
+
+    /**
+     * Our nonblocking membership
+     */
+    protected Membership membership = null;
+    
+    /**
+     * indicates that we are running an election 
+     * and this is the one we are running
+     */
+    protected UniqueId suggestedviewId;
+    protected Membership suggestedView;
+    
+    protected boolean started = false;
+    protected final int startsvc = 0xFFFF;
+    
+    protected Object electionMutex = new Object();
+    
+    protected AtomicBoolean coordMsgReceived = new AtomicBoolean(false);
+    
+    public NonBlockingCoordinator() {
+        super();
+    }
+    
+//============================================================================================================    
+//              COORDINATION HANDLING
+//============================================================================================================
+    
+    public void startElection(boolean force) throws ChannelException {
+        synchronized (electionMutex) {
+            MemberImpl local = (MemberImpl)getLocalMember(false);
+            MemberImpl[] others = (MemberImpl[])membership.getMembers();
+            fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_START_ELECT,this,"Election initated"));
+            if ( others.length == 0 ) {
+                this.viewId = new UniqueId(UUIDGenerator.randomUUID(false));
+                this.view = new Membership(local,AbsoluteOrder.comp, true);
+                this.handleViewConf(this.createElectionMsg(local,others,local),local,view);
+                return; //the only member, no need for an election
+            }
+            if ( suggestedviewId != null ) {
+                
+                if ( view != null && Arrays.diff(view,suggestedView,local).length == 0 &&  Arrays.diff(suggestedView,view,local).length == 0) {
+                    suggestedviewId = null;
+                    suggestedView = null;
+                    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED,this,"Election abandoned, running election matches view"));
+                } else {
+                    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED,this,"Election abandoned, election running"));
+                }
+                return; //election already running, I'm not allowed to have two of them
+            }
+            if ( view != null && Arrays.diff(view,membership,local).length == 0 &&  Arrays.diff(membership,view,local).length == 0) {
+                fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED,this,"Election abandoned, view matches membership"));
+                return; //already have this view installed
+            }            
+            int prio = AbsoluteOrder.comp.compare(local,others[0]);
+            MemberImpl leader = ( prio < 0 )?local:others[0];//am I the leader in my view?
+            if ( local.equals(leader) || force ) {
+                CoordinationMessage msg = createElectionMsg(local, others, leader);
+                suggestedviewId = msg.getId();
+                suggestedView = new Membership(local,AbsoluteOrder.comp,true);
+                Arrays.fill(suggestedView,msg.getMembers());
+                fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_PROCESS_ELECT,this,"Election, sending request"));
+                sendElectionMsg(local,others[0],msg);
+            } else {
+                try {
+                    coordMsgReceived.set(false);
+                    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_WAIT_FOR_MSG,this,"Election, waiting for request"));
+                    electionMutex.wait(waitForCoordMsgTimeout);
+                }catch ( InterruptedException x ) {
+                    Thread.currentThread().interrupted();
+                }
+                if ( suggestedviewId == null && (!coordMsgReceived.get())) {
+                    //no message arrived, send the coord msg
+//                    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_WAIT_FOR_MSG,this,"Election, waiting timed out."));
+//                    startElection(true);
+                    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED,this,"Election abandoned, waiting timed out."));
+                } else {
+                    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED,this,"Election abandoned, received a message"));
+                }
+            }//end if
+            
+        }
+    }
+
+    private CoordinationMessage createElectionMsg(MemberImpl local, MemberImpl[] others, MemberImpl leader) {
+        Membership m = new Membership(local,AbsoluteOrder.comp,true);
+        Arrays.fill(m,others);
+        MemberImpl[] mbrs = m.getMembers();
+        m.reset(); 
+        CoordinationMessage msg = new CoordinationMessage(leader, local, mbrs,new UniqueId(UUIDGenerator.randomUUID(true)), this.COORD_REQUEST);
+        return msg;
+    }
+
+    protected void sendElectionMsg(MemberImpl local, MemberImpl next, CoordinationMessage msg) throws ChannelException {
+        fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_SEND_MSG,this,"Sending election message to("+next.getName()+")"));
+        super.sendMessage(new Member[] {next}, createData(msg, local), null);
+    }
+    
+    protected void sendElectionMsgToNextInline(MemberImpl local, CoordinationMessage msg) throws ChannelException { 
+        int next = Arrays.nextIndex(local,msg.getMembers());
+        int current = next;
+        msg.leader = msg.getMembers()[0];
+        boolean sent =  false;
+        while ( !sent && current >= 0 ) {
+            try {
+                sendElectionMsg(local, (MemberImpl) msg.getMembers()[current], msg);
+                sent = true;
+            }catch ( ChannelException x  ) {
+                log.warn("Unable to send election message to:"+msg.getMembers()[current]);
+                current = Arrays.nextIndex(msg.getMembers()[current],msg.getMembers());
+                if ( current == next ) throw x;
+            }
+        }
+    }
+    
+    public Member getNextInLine(MemberImpl local, MemberImpl[] others) {
+        MemberImpl result = null;
+        for ( int i=0; i<others.length; i++ ) {
+            
+        }
+        return result;
+    }
+    
+    public ChannelData createData(CoordinationMessage msg, MemberImpl local) {
+        msg.write();
+        ChannelData data = new ChannelData(true);
+        data.setAddress(local);
+        data.setMessage(msg.getBuffer());
+        data.setOptions(Channel.SEND_OPTIONS_USE_ACK);
+        data.setTimestamp(System.currentTimeMillis());
+        return data;
+    }
+    
+    protected void viewChange(UniqueId viewId, Member[] view) {
+        //invoke any listeners
+    }
+    
+    protected boolean alive(Member mbr) {
+        return TcpFailureDetector.memberAlive(mbr,
+                                              COORD_ALIVE,
+                                              false,
+                                              false,
+                                              waitForCoordMsgTimeout,
+                                              waitForCoordMsgTimeout,
+                                              getOptionFlag());
+    }
+    
+    protected Membership mergeOnArrive(CoordinationMessage msg, Member sender) {
+        fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_PRE_MERGE,this,"Pre merge"));
+        MemberImpl local = (MemberImpl)getLocalMember(false);
+        Membership merged = new Membership(local,AbsoluteOrder.comp,true);
+        Arrays.fill(merged,msg.getMembers());
+        Arrays.fill(merged,getMembers());
+        Member[] diff = Arrays.diff(merged,membership,local);
+        for ( int i=0; i<diff.length; i++ ) {
+            if (!alive(diff[i])) merged.removeMember((MemberImpl)diff[i]);
+            else memberAdded(diff[i],false);
+        }
+        fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_POST_MERGE,this,"Post merge"));
+        return merged;
+    }
+    
+    protected void processCoordMessage(CoordinationMessage msg, Member sender) throws ChannelException {
+        if ( !coordMsgReceived.get() ) {
+            coordMsgReceived.set(true);
+            synchronized (electionMutex) { electionMutex.notifyAll();}
+        } 
+        msg.timestamp = System.currentTimeMillis();
+        Membership merged = mergeOnArrive(msg, sender);
+        if (isViewConf(msg)) handleViewConf(msg, sender, merged);
+        else handleToken(msg, sender, merged);
+        ClassLoader loader;
+
+    }
+    
+    protected void handleToken(CoordinationMessage msg, Member sender,Membership merged) throws ChannelException {
+        MemberImpl local = (MemberImpl)getLocalMember(false);
+        if ( local.equals(msg.getSource()) ) {
+            //my message msg.src=local
+            handleMyToken(local, msg, sender,merged);
+        } else {
+            handleOtherToken(local, msg, sender,merged);
+        }
+    }
+    
+    protected void handleMyToken(MemberImpl local, CoordinationMessage msg, Member sender,Membership merged) throws ChannelException {
+        if ( local.equals(msg.getLeader()) ) {
+            //no leadership change
+            if ( Arrays.sameMembers(msg.getMembers(),merged.getMembers()) ) {
+                msg.type = COORD_CONF;
+                super.sendMessage(Arrays.remove(msg.getMembers(),local),createData(msg,local),null);
+                handleViewConf(msg,local,merged);
+            } else {
+                //membership change
+                suggestedView = new Membership(local,AbsoluteOrder.comp,true);
+                suggestedviewId = msg.getId();
+                Arrays.fill(suggestedView,merged.getMembers());
+                msg.view = (MemberImpl[])merged.getMembers();
+                sendElectionMsgToNextInline(local,msg);
+            }
+        } else {
+            //leadership change
+            suggestedView = null;
+            suggestedviewId = null;
+            msg.view = (MemberImpl[])merged.getMembers();
+            sendElectionMsgToNextInline(local,msg);
+        }
+    }
+    
+    protected void handleOtherToken(MemberImpl local, CoordinationMessage msg, Member sender,Membership merged) throws ChannelException {
+        if ( local.equals(msg.getLeader()) ) {
+            //I am the new leader
+            //startElection(false);
+        } else {
+            msg.view = (MemberImpl[])merged.getMembers();
+            sendElectionMsgToNextInline(local,msg);
+        }
+    }
+    
+    protected void handleViewConf(CoordinationMessage msg, Member sender,Membership merged) throws ChannelException {
+        if ( viewId != null && msg.getId().equals(viewId) ) return;//we already have this view
+        view = new Membership((MemberImpl)getLocalMember(false),AbsoluteOrder.comp,true);
+        Arrays.fill(view,msg.getMembers());
+        viewId = msg.getId();
+        
+        if ( viewId.equals(suggestedviewId) ) {
+            suggestedView = null;
+            suggestedviewId = null;
+        }
+        
+        if (suggestedView != null && AbsoluteOrder.comp.compare(suggestedView.getMembers()[0],merged.getMembers()[0])<0 ) {
+            suggestedView = null;
+            suggestedviewId = null;
+        }
+        
+        viewChange(viewId,view.getMembers());
+        fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_CONF_RX,this,"Accepted View"));
+        
+        if ( suggestedviewId == null && hasHigherPriority(merged.getMembers(),membership.getMembers()) ) {
+            startElection(false);
+        }
+    }
+    
+    protected boolean isViewConf(CoordinationMessage msg) {
+        return Arrays.contains(msg.getType(),0,COORD_CONF,0,COORD_CONF.length);
+    }
+    
+    protected boolean hasHigherPriority(Member[] complete, Member[] local) {
+        if ( local == null || local.length == 0 ) return false;
+        if ( complete == null || complete.length == 0 ) return true;
+        AbsoluteOrder.absoluteOrder(complete);
+        AbsoluteOrder.absoluteOrder(local);
+        return (AbsoluteOrder.comp.compare(complete[0],local[0]) > 0);
+        
+    }
+
+    
+    /**
+     * Returns coordinator if one is available
+     * @return Member
+     */
+    public Member getCoordinator() {
+        return (view != null && view.hasMembers()) ? view.getMembers()[0] : null;
+    }
+    
+    public Member[] getView() {
+        return (view != null && view.hasMembers()) ? view.getMembers() : new Member[0];
+    }
+    
+    public UniqueId getViewId() {
+        return viewId;
+    }
+    
+    /**
+    * Block in/out messages while a election is going on
+    */
+   protected void halt() {
+
+   }
+
+   /**
+    * Release lock for in/out messages election is completed
+    */
+   protected void release() {
+
+   }
+
+   /**
+    * Wait for an election to end
+    */
+   protected void waitForRelease() {
+
+   }
+
+    
+//============================================================================================================    
+//              OVERRIDDEN METHODS FROM CHANNEL INTERCEPTOR BASE    
+//============================================================================================================
+    public void start(int svc) throws ChannelException {
+            if (membership == null) setupMembership();
+            if (started)return;
+            fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_START, this, "Before start"));
+            super.start(startsvc);
+            started = true;
+            if (view == null) view = new Membership( (MemberImpl)super.getLocalMember(true), AbsoluteOrder.comp, true);
+            fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_START, this, "After start"));
+            startElection(false);
+    }
+
+    public void stop(int svc) throws ChannelException {
+        try {
+            halt();
+            synchronized (electionMutex) {
+                if (!started)return;
+                started = false;
+                fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_STOP, this, "Before stop"));
+                super.stop(startsvc);
+                this.view = null;
+                this.viewId = null;
+                this.suggestedView = null;
+                this.suggestedviewId = null;
+                this.membership.reset();
+                fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_STOP, this, "After stop"));
+            }
+        }finally {
+            release();
+        }
+    }
+    
+    
+    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
+        waitForRelease();
+        super.sendMessage(destination, msg, payload);
+    }
+
+    public void messageReceived(ChannelMessage msg) {
+        if ( Arrays.contains(msg.getMessage().getBytesDirect(),0,COORD_ALIVE,0,COORD_ALIVE.length) ) {
+            //ignore message, its an alive message
+            fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_MSG_ARRIVE,this,"Alive Message"));
+
+        } else if ( Arrays.contains(msg.getMessage().getBytesDirect(),0,COORD_HEADER,0,COORD_HEADER.length) ) {
+            try {
+                CoordinationMessage cmsg = new CoordinationMessage(msg.getMessage());
+                Member[] cmbr = cmsg.getMembers();
+                fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_MSG_ARRIVE,this,"Coord Msg Arrived("+Arrays.toNameString(cmbr)+")"));
+                processCoordMessage(cmsg, msg.getAddress());
+            }catch ( ChannelException x ) {
+                log.error("Error processing coordination message. Could be fatal.",x);
+            }
+        } else {
+            super.messageReceived(msg);
+        }
+    }
+
+    public boolean accept(ChannelMessage msg) {
+        return super.accept(msg);
+    }
+
+    public void memberAdded(Member member) {
+        memberAdded(member,true);
+    }
+
+    public void memberAdded(Member member,boolean elect) {
+        try {
+            if ( membership == null ) setupMembership();
+            if ( membership.memberAlive((MemberImpl)member) ) super.memberAdded(member);
+            try {
+                fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_MBR_ADD,this,"Member add("+member.getName()+")"));
+                if (started && elect) startElection(false);
+            }catch ( ChannelException x ) {
+                log.error("Unable to start election when member was added.",x);
+            }
+        }finally {
+        }
+        
+    }
+
+    public void memberDisappeared(Member member) {
+        try {
+            
+            membership.removeMember((MemberImpl)member);
+            super.memberDisappeared(member);
+            try {
+                fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_MBR_DEL,this,"Member remove("+member.getName()+")"));
+                if ( started && (isCoordinator() || isHighest()) ) 
+                    startElection(true); //to do, if a member disappears, only the coordinator can start
+            }catch ( ChannelException x ) {
+                log.error("Unable to start election when member was removed.",x);
+            }
+        }finally {
+        }
+    }
+    
+    public boolean isHighest() {
+        Member local = getLocalMember(false);
+        if ( membership.getMembers().length == 0 ) return true;
+        else return AbsoluteOrder.comp.compare(local,membership.getMembers()[0])<=0;
+    }
+    
+    public boolean isCoordinator() {
+        Member coord = getCoordinator();
+        return coord != null && getLocalMember(false).equals(coord);
+    }
+
+    public void heartbeat() {
+        try {
+            MemberImpl local = (MemberImpl)getLocalMember(false);
+            if ( view != null && (Arrays.diff(view,membership,local).length != 0 ||  Arrays.diff(membership,view,local).length != 0) ) {
+                if ( isHighest() ) {
+                    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_START_ELECT, this,
+                                                               "Heartbeat found inconsistency, restart election"));
+                    startElection(true);
+                }            
+            }
+        } catch ( Exception x  ){
+            log.error("Unable to perform heartbeat.",x);
+        } finally {
+            super.heartbeat();
+        }
+    }
+
+    /**
+     * has members
+     */
+    public boolean hasMembers() {
+        
+        return membership.hasMembers();
+    }
+
+    /**
+     * Get all current cluster members
+     * @return all members or empty array
+     */
+    public Member[] getMembers() {
+        
+        return membership.getMembers();
+    }
+
+    /**
+     *
+     * @param mbr Member
+     * @return Member
+     */
+    public Member getMember(Member mbr) {
+        
+        return membership.getMember(mbr);
+    }
+
+    /**
+     * Return the member that represents this node.
+     *
+     * @return Member
+     */
+    public Member getLocalMember(boolean incAlive) {
+        Member local = super.getLocalMember(incAlive);
+        if ( view == null && (local != null)) setupMembership();
+        return local;
+    }
+    
+    protected synchronized void setupMembership() {
+        if ( membership == null ) {
+            membership  = new Membership((MemberImpl)super.getLocalMember(true),AbsoluteOrder.comp,false);
+        }
+    }
+    
+    
+//============================================================================================================    
+//              HELPER CLASSES FOR COORDINATION
+//============================================================================================================
+    
+    
+   
+    
+    public static class CoordinationMessage {
+        //X{A-ldr, A-src, mbrs-A,B,C,D}
+        protected XByteBuffer buf;
+        protected MemberImpl leader;
+        protected MemberImpl source;
+        protected MemberImpl[] view;
+        protected UniqueId id;
+        protected byte[] type;
+        protected long timestamp = System.currentTimeMillis();
+        
+        public CoordinationMessage(XByteBuffer buf) {
+            this.buf = buf;
+            parse();
+        }
+
+        public CoordinationMessage(MemberImpl leader,
+                                   MemberImpl source, 
+                                   MemberImpl[] view,
+                                   UniqueId id,
+                                   byte[] type) {
+            this.buf = new XByteBuffer(4096,false);
+            this.leader = leader;
+            this.source = source;
+            this.view = view;
+            this.id = id;
+            this.type = type;
+            this.write();
+        }
+        
+
+        public byte[] getHeader() {
+            return NonBlockingCoordinator.COORD_HEADER;
+        }
+        
+        public MemberImpl getLeader() {
+            if ( leader == null ) parse();
+            return leader;
+        }
+        
+        public MemberImpl getSource() {
+            if ( source == null ) parse();
+            return source;
+        }
+        
+        public UniqueId getId() {
+            if ( id == null ) parse();
+            return id;
+        }
+        
+        public MemberImpl[] getMembers() {
+            if ( view == null ) parse();
+            return view;
+        }
+        
+        public byte[] getType() {
+            if (type == null ) parse();
+            return type;
+        }
+        
+        public XByteBuffer getBuffer() {
+            return this.buf;
+        }
+        
+        public void parse() {
+            //header
+            int offset = 16;
+            //leader
+            int ldrLen = buf.toInt(buf.getBytesDirect(),offset);
+            offset += 4;
+            byte[] ldr = new byte[ldrLen];
+            System.arraycopy(buf.getBytesDirect(),offset,ldr,0,ldrLen);
+            leader = MemberImpl.getMember(ldr);
+            offset += ldrLen;
+            //source
+            int srcLen = buf.toInt(buf.getBytesDirect(),offset);
+            offset += 4;
+            byte[] src = new byte[srcLen];
+            System.arraycopy(buf.getBytesDirect(),offset,src,0,srcLen);
+            source = MemberImpl.getMember(src);
+            offset += srcLen;
+            //view
+            int mbrCount = buf.toInt(buf.getBytesDirect(),offset);
+            offset += 4;
+            view = new MemberImpl[mbrCount];
+            for (int i=0; i<view.length; i++ ) {
+                int mbrLen = buf.toInt(buf.getBytesDirect(),offset);
+                offset += 4;
+                byte[] mbr = new byte[mbrLen];
+                System.arraycopy(buf.getBytesDirect(), offset, mbr, 0, mbrLen);
+                view[i] = MemberImpl.getMember(mbr);
+                offset += mbrLen;
+            }
+            //id
+            this.id = new UniqueId(buf.getBytesDirect(),offset,16);
+            offset += 16;
+            type = new byte[16];
+            System.arraycopy(buf.getBytesDirect(), offset, type, 0, type.length);
+            offset += 16;
+            
+        }
+        
+        public void write() {
+            buf.reset();
+            //header
+            buf.append(COORD_HEADER,0,COORD_HEADER.length);
+            //leader
+            byte[] ldr = leader.getData(false,false);
+            buf.append(ldr.length);
+            buf.append(ldr,0,ldr.length);
+            ldr = null;
+            //source
+            byte[] src = source.getData(false,false);
+            buf.append(src.length);
+            buf.append(src,0,src.length);
+            src = null;
+            //view
+            buf.append(view.length);
+            for (int i=0; i<view.length; i++ ) {
+                byte[] mbr = view[i].getData(false,false);
+                buf.append(mbr.length);
+                buf.append(mbr,0,mbr.length);
+            }
+            //id
+            buf.append(id.getBytes(),0,id.getBytes().length);
+            buf.append(type,0,type.length);
+        }
+    }
+    
+    public void fireInterceptorEvent(InterceptorEvent event) {
+        if (event instanceof CoordinationEvent &&
+            ((CoordinationEvent)event).type == CoordinationEvent.EVT_CONF_RX) 
+            log.info(event);
+    }
+    
+    public static class CoordinationEvent implements InterceptorEvent {
+        public static final int EVT_START = 1;
+        public static final int EVT_MBR_ADD = 2;
+        public static final int EVT_MBR_DEL = 3;
+        public static final int EVT_START_ELECT = 4;
+        public static final int EVT_PROCESS_ELECT = 5;
+        public static final int EVT_MSG_ARRIVE = 6;
+        public static final int EVT_PRE_MERGE = 7;
+        public static final int EVT_POST_MERGE = 8;
+        public static final int EVT_WAIT_FOR_MSG = 9;
+        public static final int EVT_SEND_MSG = 10;
+        public static final int EVT_STOP = 11;
+        public static final int EVT_CONF_RX = 12;
+        public static final int EVT_ELECT_ABANDONED = 13;
+        
+        int type;
+        ChannelInterceptor interceptor;
+        Member coord; 
+        Member[] mbrs;
+        String info;
+        Membership view;
+        Membership suggestedView;
+        public CoordinationEvent(int type,ChannelInterceptor interceptor, String info) {
+            this.type = type;
+            this.interceptor = interceptor;
+            this.coord = ((NonBlockingCoordinator)interceptor).getCoordinator();
+            this.mbrs = ((NonBlockingCoordinator)interceptor).membership.getMembers();
+            this.info = info;
+            this.view = ((NonBlockingCoordinator)interceptor).view;
+            this.suggestedView = ((NonBlockingCoordinator)interceptor).suggestedView;
+        }
+        
+        public int getEventType() {
+            return type;
+        }
+        
+        public String getEventTypeDesc() {
+            switch (type) {
+                case  EVT_START: return "EVT_START:"+info;
+                case  EVT_MBR_ADD: return "EVT_MBR_ADD:"+info;
+                case  EVT_MBR_DEL: return "EVT_MBR_DEL:"+info;
+                case  EVT_START_ELECT: return "EVT_START_ELECT:"+info;
+                case  EVT_PROCESS_ELECT: return "EVT_PROCESS_ELECT:"+info;
+                case  EVT_MSG_ARRIVE: return "EVT_MSG_ARRIVE:"+info;
+                case  EVT_PRE_MERGE: return "EVT_PRE_MERGE:"+info;
+                case  EVT_POST_MERGE: return "EVT_POST_MERGE:"+info;
+                case  EVT_WAIT_FOR_MSG: return "EVT_WAIT_FOR_MSG:"+info;
+                case  EVT_SEND_MSG: return "EVT_SEND_MSG:"+info;
+                case  EVT_STOP: return "EVT_STOP:"+info;
+                case  EVT_CONF_RX: return "EVT_CONF_RX:"+info;
+                case EVT_ELECT_ABANDONED: return "EVT_ELECT_ABANDONED:"+info;
+                default: return "Unknown";
+            }
+        }
+        
+        public ChannelInterceptor getInterceptor() {
+            return interceptor;
+        }
+        
+        public String toString() {
+            StringBuffer buf = new StringBuffer("CoordinationEvent[type=");
+            buf.append(type).append("\n\tLocal:");
+            Member local = interceptor.getLocalMember(false);
+            buf.append(local!=null?local.getName():"").append("\n\tCoord:");
+            buf.append(coord!=null?coord.getName():"").append("\n\tView:");
+            buf.append(Arrays.toNameString(view!=null?view.getMembers():null)).append("\n\tSuggested View:");
+            buf.append(Arrays.toNameString(suggestedView!=null?suggestedView.getMembers():null)).append("\n\tMembers:");
+            buf.append(Arrays.toNameString(mbrs)).append("\n\tInfo:");
+            buf.append(info).append("]");
+            return buf.toString();
+        }
+    }
+
+    
+
+
+
 }
\ No newline at end of file

==================================================
TcpFailureDetector.java
index c4b1661921..c0610c419b 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/OrderInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/OrderInterceptor.java
@@ -1,298 +1,299 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- */
-
-package org.apache.catalina.tribes.group.interceptors;
-
-import java.util.HashMap;
-
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.group.ChannelInterceptorBase;
-import org.apache.catalina.tribes.group.InterceptorPayload;
-import org.apache.catalina.tribes.io.XByteBuffer;
-
-
-
-/**
- *
- * The order interceptor guarantees that messages are received in the same order they were 
- * sent.
- * This interceptor works best with the ack=true setting. <br>
- * There is no point in 
- * using this with the replicationMode="fastasynchqueue" as this mode guarantees ordering.<BR>
- * If you are using the mode ack=false replicationMode=pooled, and have a lot of concurrent threads,
- * this interceptor can really slow you down, as many messages will be completely out of order
- * and the queue might become rather large. If this is the case, then you might want to set 
- * the value OrderInterceptor.maxQueue = 25 (meaning that we will never keep more than 25 messages in our queue)
- * <br><b>Configuration Options</b><br>
- * OrderInteceptor.expire=<milliseconds> - if a message arrives out of order, how long before we act on it <b>default=3000ms</b><br>
- * OrderInteceptor.maxQueue=<max queue size> - how much can the queue grow to ensure ordering. 
- *   This setting is useful to avoid OutOfMemoryErrors<b>default=Integer.MAX_VALUE</b><br>
- * OrderInterceptor.forwardExpired=<boolean> - this flag tells the interceptor what to 
- * do when a message has expired or the queue has grown larger than the maxQueue value.
- * true means that the message is sent up the stack to the receiver that will receive and out of order message
- * false means, forget the message and reset the message counter. <b>default=true</b>
- * 
- * 
- * @author Filip Hanik
- * @version 1.0
- */
-public class OrderInterceptor extends ChannelInterceptorBase {
-    private HashMap outcounter = new HashMap();
-    private HashMap incounter = new HashMap();
-    private HashMap incoming = new HashMap();
-    private long expire = 3000;
-    private boolean forwardExpired = true;
-    private int maxQueue = Integer.MAX_VALUE;
-
-    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
-        for ( int i=0; i<destination.length; i++ ) {
-            int nr = incCounter(destination[i]);
-            //reduce byte copy
-            msg.getMessage().append(nr);
-            try {
-                getNext().sendMessage(new Member[] {destination[i]}, msg, payload);
-            }finally {
-                msg.getMessage().trim(4);
-            }
-        }
-    }
-
-    public void messageReceived(ChannelMessage msg) {
-        int msgnr = XByteBuffer.toInt(msg.getMessage().getBytesDirect(),msg.getMessage().getLength()-4);
-        msg.getMessage().trim(4);
-        MessageOrder order = new MessageOrder(msgnr,(ChannelMessage)msg.deepclone());
-        if ( processIncoming(order) ) processLeftOvers(msg.getAddress(),false);
-    }
-    
-    public synchronized void processLeftOvers(Member member, boolean force) {
-        MessageOrder tmp = (MessageOrder)incoming.get(member);
-        if ( force ) {
-            Counter cnt = getInCounter(member);
-            cnt.setCounter(Integer.MAX_VALUE);
-        }
-        if ( tmp!= null ) processIncoming(tmp);
-    }
-    /**
-     * 
-     * @param order MessageOrder
-     * @return boolean - true if a message expired and was processed
-     */
-    public synchronized boolean processIncoming(MessageOrder order) {
-        boolean result = false;
-        Member member = order.getMessage().getAddress();
-        Counter cnt = getInCounter(member);
-        
-        MessageOrder tmp = (MessageOrder)incoming.get(member);
-        if ( tmp != null ) {
-            order = MessageOrder.add(tmp,order);
-        }
-        
-        
-        while ( (order!=null) && (order.getMsgNr() <= cnt.getCounter())  ) {
-            //we are right on target. process orders
-            if ( order.getMsgNr() == cnt.getCounter() ) cnt.inc();
-            else if ( order.getMsgNr() > cnt.getCounter() ) cnt.setCounter(order.getMsgNr());
-            super.messageReceived(order.getMessage());
-            order.setMessage(null);
-            order = order.next;
-        }
-        MessageOrder head = order;
-        MessageOrder prev = null;
-        tmp = order;
-        //flag to empty out the queue when it larger than maxQueue
-        boolean empty = order!=null?order.getCount()>=maxQueue:false;
-        while ( tmp != null ) {
-            //process expired messages or empty out the queue
-            if ( tmp.isExpired(expire) || empty ) {
-                //reset the head
-                if ( tmp == head ) head = tmp.next;
-                cnt.setCounter(tmp.getMsgNr()+1);
-                if ( getForwardExpired() ) super.messageReceived(tmp.getMessage());
-                tmp.setMessage(null);
-                tmp = tmp.next;
-                if ( prev != null ) prev.next = tmp;  
-                result = true;
-            } else {
-                prev = tmp;
-                tmp = tmp.next;
-            }
-        }
-        if ( head == null ) incoming.remove(member);
-        else incoming.put(member, head);
-        return result;
-    }
-    
-    public void memberAdded(Member member) {
-        //notify upwards
-        getInCounter(member);
-        getOutCounter(member);
-        super.memberAdded(member);
-    }
-
-    public void memberDisappeared(Member member) {
-        //notify upwards
-        outcounter.remove(member);
-        incounter.remove(member);
-        //clear the remaining queue
-        processLeftOvers(member,true);
-        super.memberDisappeared(member);
-    }
-    
-    public int incCounter(Member mbr) { 
-        Counter cnt = getOutCounter(mbr);
-        return cnt.inc();
-    }
-    
-    public synchronized Counter getInCounter(Member mbr) {
-        Counter cnt = (Counter)incounter.get(mbr);
-        if ( cnt == null ) {
-            cnt = new Counter();
-            cnt.inc(); //always start at 1 for incoming
-            incounter.put(mbr,cnt);
-        }
-        return cnt;
-    }
-
-    public synchronized Counter getOutCounter(Member mbr) {
-        Counter cnt = (Counter)outcounter.get(mbr);
-        if ( cnt == null ) {
-            cnt = new Counter();
-            outcounter.put(mbr,cnt);
-        }
-        return cnt;
-    }
-
-    public static class Counter {
-        private int value = 0;
-        
-        public int getCounter() {
-            return value;
-        }
-        
-        public synchronized void setCounter(int counter) {
-            this.value = counter;
-        }
-        
-        public synchronized int inc() {
-            return ++value;
-        }
-    }
-    
-    public static class MessageOrder {
-        private long received = System.currentTimeMillis();
-        private MessageOrder next;
-        private int msgNr;
-        private ChannelMessage msg = null;
-        public MessageOrder(int msgNr,ChannelMessage msg) {
-            this.msgNr = msgNr;
-            this.msg = msg;
-        }
-        
-        public boolean isExpired(long expireTime) {
-            return (System.currentTimeMillis()-received) > expireTime;
-        }
-        
-        public ChannelMessage getMessage() {
-            return msg;
-        }
-        
-        public void setMessage(ChannelMessage msg) {
-            this.msg = msg;
-        }
-        
-        public void setNext(MessageOrder order) {
-            this.next = order;
-        }
-        public MessageOrder getNext() {
-            return next;
-        }
-        
-        public int getCount() {
-            int counter = 1;
-            MessageOrder tmp = next;
-            while ( tmp != null ) {
-                counter++;
-                tmp = tmp.next;
-            }
-            return counter;
-        }
-        
-        public static MessageOrder add(MessageOrder head, MessageOrder add) {
-            if ( head == null ) return add;
-            if ( add == null ) return head;
-            if ( head == add ) return add;
-
-            if ( head.getMsgNr() > add.getMsgNr() ) {
-                add.next = head;
-                return add;
-            }
-            
-            MessageOrder iter = head;
-            MessageOrder prev = null;
-            while ( iter.getMsgNr() < add.getMsgNr() && (iter.next !=null ) ) {
-                prev = iter;
-                iter = iter.next;
-            }
-            if ( iter.getMsgNr() < add.getMsgNr() ) {
-                //add after
-                add.next = iter.next;
-                iter.next = add;
-            } else if (iter.getMsgNr() > add.getMsgNr()) {
-                //add before
-                prev.next = add;
-                add.next = iter;
-                
-            } else {
-                throw new ArithmeticException("Message added has the same counter, synchronization bug. Disable the order interceptor");
-            }
-            
-            return head;
-        }
-        
-        public int getMsgNr() {
-            return msgNr;
-        }
-        
-        
-        
-    }
-
-    public void setExpire(long expire) {
-        this.expire = expire;
-    }
-
-    public void setForwardExpired(boolean forwardExpired) {
-        this.forwardExpired = forwardExpired;
-    }
-
-    public void setMaxQueue(int maxQueue) {
-        this.maxQueue = maxQueue;
-    }
-
-    public long getExpire() {
-        return expire;
-    }
-
-    public boolean getForwardExpired() {
-        return forwardExpired;
-    }
-
-    public int getMaxQueue() {
-        return maxQueue;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ */
+
+package org.apache.catalina.tribes.group.interceptors;
+
+import java.util.HashMap;
+
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.group.ChannelInterceptorBase;
+import org.apache.catalina.tribes.group.InterceptorPayload;
+import org.apache.catalina.tribes.io.XByteBuffer;
+
+
+
+/**
+ *
+ * The order interceptor guarantees that messages are received in the same order they were 
+ * sent.
+ * This interceptor works best with the ack=true setting. <br>
+ * There is no point in 
+ * using this with the replicationMode="fastasynchqueue" as this mode guarantees ordering.<BR>
+ * If you are using the mode ack=false replicationMode=pooled, and have a lot of concurrent threads,
+ * this interceptor can really slow you down, as many messages will be completely out of order
+ * and the queue might become rather large. If this is the case, then you might want to set 
+ * the value OrderInterceptor.maxQueue = 25 (meaning that we will never keep more than 25 messages in our queue)
+ * <br><b>Configuration Options</b><br>
+ * OrderInteceptor.expire=<milliseconds> - if a message arrives out of order, how long before we act on it <b>default=3000ms</b><br>
+ * OrderInteceptor.maxQueue=<max queue size> - how much can the queue grow to ensure ordering. 
+ *   This setting is useful to avoid OutOfMemoryErrors<b>default=Integer.MAX_VALUE</b><br>
+ * OrderInterceptor.forwardExpired=<boolean> - this flag tells the interceptor what to 
+ * do when a message has expired or the queue has grown larger than the maxQueue value.
+ * true means that the message is sent up the stack to the receiver that will receive and out of order message
+ * false means, forget the message and reset the message counter. <b>default=true</b>
+ * 
+ * 
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class OrderInterceptor extends ChannelInterceptorBase {
+    private HashMap outcounter = new HashMap();
+    private HashMap incounter = new HashMap();
+    private HashMap incoming = new HashMap();
+    private long expire = 3000;
+    private boolean forwardExpired = true;
+    private int maxQueue = Integer.MAX_VALUE;
+
+    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
+        for ( int i=0; i<destination.length; i++ ) {
+            int nr = incCounter(destination[i]);
+            //reduce byte copy
+            msg.getMessage().append(nr);
+            try {
+                getNext().sendMessage(new Member[] {destination[i]}, msg, payload);
+            }finally {
+                msg.getMessage().trim(4);
+            }
+        }
+    }
+
+    public void messageReceived(ChannelMessage msg) {
+        int msgnr = XByteBuffer.toInt(msg.getMessage().getBytesDirect(),msg.getMessage().getLength()-4);
+        msg.getMessage().trim(4);
+        MessageOrder order = new MessageOrder(msgnr,(ChannelMessage)msg.deepclone());
+        if ( processIncoming(order) ) processLeftOvers(msg.getAddress(),false);
+    }
+    
+    public synchronized void processLeftOvers(Member member, boolean force) {
+        MessageOrder tmp = (MessageOrder)incoming.get(member);
+        if ( force ) {
+            Counter cnt = getInCounter(member);
+            cnt.setCounter(Integer.MAX_VALUE);
+        }
+        if ( tmp!= null ) processIncoming(tmp);
+    }
+    /**
+     * 
+     * @param order MessageOrder
+     * @return boolean - true if a message expired and was processed
+     */
+    public synchronized boolean processIncoming(MessageOrder order) {
+        boolean result = false;
+        Member member = order.getMessage().getAddress();
+        Counter cnt = getInCounter(member);
+        
+        MessageOrder tmp = (MessageOrder)incoming.get(member);
+        if ( tmp != null ) {
+            order = MessageOrder.add(tmp,order);
+        }
+        
+        
+        while ( (order!=null) && (order.getMsgNr() <= cnt.getCounter())  ) {
+            //we are right on target. process orders
+            if ( order.getMsgNr() == cnt.getCounter() ) cnt.inc();
+            else if ( order.getMsgNr() > cnt.getCounter() ) cnt.setCounter(order.getMsgNr());
+            super.messageReceived(order.getMessage());
+            order.setMessage(null);
+            order = order.next;
+        }
+        MessageOrder head = order;
+        MessageOrder prev = null;
+        tmp = order;
+        //flag to empty out the queue when it larger than maxQueue
+        boolean empty = order!=null?order.getCount()>=maxQueue:false;
+        while ( tmp != null ) {
+            //process expired messages or empty out the queue
+            if ( tmp.isExpired(expire) || empty ) {
+                //reset the head
+                if ( tmp == head ) head = tmp.next;
+                cnt.setCounter(tmp.getMsgNr()+1);
+                if ( getForwardExpired() ) super.messageReceived(tmp.getMessage());
+                tmp.setMessage(null);
+                tmp = tmp.next;
+                if ( prev != null ) prev.next = tmp;  
+                result = true;
+            } else {
+                prev = tmp;
+                tmp = tmp.next;
+            }
+        }
+        if ( head == null ) incoming.remove(member);
+        else incoming.put(member, head);
+        return result;
+    }
+    
+    public void memberAdded(Member member) {
+        //notify upwards
+        getInCounter(member);
+        getOutCounter(member);
+        super.memberAdded(member);
+    }
+
+    public void memberDisappeared(Member member) {
+        //notify upwards
+        outcounter.remove(member);
+        incounter.remove(member);
+        //clear the remaining queue
+        processLeftOvers(member,true);
+        super.memberDisappeared(member);
+    }
+    
+    public int incCounter(Member mbr) { 
+        Counter cnt = getOutCounter(mbr);
+        return cnt.inc();
+    }
+    
+    public synchronized Counter getInCounter(Member mbr) {
+        Counter cnt = (Counter)incounter.get(mbr);
+        if ( cnt == null ) {
+            cnt = new Counter();
+            cnt.inc(); //always start at 1 for incoming
+            incounter.put(mbr,cnt);
+        }
+        return cnt;
+    }
+
+    public synchronized Counter getOutCounter(Member mbr) {
+        Counter cnt = (Counter)outcounter.get(mbr);
+        if ( cnt == null ) {
+            cnt = new Counter();
+            outcounter.put(mbr,cnt);
+        }
+        return cnt;
+    }
+
+    public static class Counter {
+        private int value = 0;
+        
+        public int getCounter() {
+            return value;
+        }
+        
+        public synchronized void setCounter(int counter) {
+            this.value = counter;
+        }
+        
+        public synchronized int inc() {
+            return ++value;
+        }
+    }
+    
+    public static class MessageOrder {
+        private long received = System.currentTimeMillis();
+        private MessageOrder next;
+        private int msgNr;
+        private ChannelMessage msg = null;
+        public MessageOrder(int msgNr,ChannelMessage msg) {
+            this.msgNr = msgNr;
+            this.msg = msg;
+        }
+        
+        public boolean isExpired(long expireTime) {
+            return (System.currentTimeMillis()-received) > expireTime;
+        }
+        
+        public ChannelMessage getMessage() {
+            return msg;
+        }
+        
+        public void setMessage(ChannelMessage msg) {
+            this.msg = msg;
+        }
+        
+        public void setNext(MessageOrder order) {
+            this.next = order;
+        }
+        public MessageOrder getNext() {
+            return next;
+        }
+        
+        public int getCount() {
+            int counter = 1;
+            MessageOrder tmp = next;
+            while ( tmp != null ) {
+                counter++;
+                tmp = tmp.next;
+            }
+            return counter;
+        }
+        
+        public static MessageOrder add(MessageOrder head, MessageOrder add) {
+            if ( head == null ) return add;
+            if ( add == null ) return head;
+            if ( head == add ) return add;
+
+            if ( head.getMsgNr() > add.getMsgNr() ) {
+                add.next = head;
+                return add;
+            }
+            
+            MessageOrder iter = head;
+            MessageOrder prev = null;
+            while ( iter.getMsgNr() < add.getMsgNr() && (iter.next !=null ) ) {
+                prev = iter;
+                iter = iter.next;
+            }
+            if ( iter.getMsgNr() < add.getMsgNr() ) {
+                //add after
+                add.next = iter.next;
+                iter.next = add;
+            } else if (iter.getMsgNr() > add.getMsgNr()) {
+                //add before
+                prev.next = add;
+                add.next = iter;
+                
+            } else {
+                throw new ArithmeticException("Message added has the same counter, synchronization bug. Disable the order interceptor");
+            }
+            
+            return head;
+        }
+        
+        public int getMsgNr() {
+            return msgNr;
+        }
+        
+        
+        
+    }
+
+    public void setExpire(long expire) {
+        this.expire = expire;
+    }
+
+    public void setForwardExpired(boolean forwardExpired) {
+        this.forwardExpired = forwardExpired;
+    }
+
+    public void setMaxQueue(int maxQueue) {
+        this.maxQueue = maxQueue;
+    }
+
+    public long getExpire() {
+        return expire;
+    }
+
+    public boolean getForwardExpired() {
+        return forwardExpired;
+    }
+
+    public int getMaxQueue() {
+        return maxQueue;
+    }
+
+}

==================================================
ThroughputInterceptor.java
index f9da96f9a1..2169c51d3b 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java
@@ -1,288 +1,289 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- */
-package org.apache.catalina.tribes.group.interceptors;
-
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Socket;
-import java.net.SocketTimeoutException;
-import java.util.Arrays;
-import java.util.HashMap;
-
-import org.apache.catalina.tribes.Channel;
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelException.FaultyMember;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.RemoteProcessException;
-import org.apache.catalina.tribes.group.ChannelInterceptorBase;
-import org.apache.catalina.tribes.group.InterceptorPayload;
-import org.apache.catalina.tribes.io.ChannelData;
-import org.apache.catalina.tribes.io.XByteBuffer;
-import org.apache.catalina.tribes.membership.MemberImpl;
-import org.apache.catalina.tribes.membership.Membership;
-import java.net.ConnectException;
-
-/**
- * <p>Title: A perfect failure detector </p>
- *
- * <p>Description: The TcpFailureDetector is a useful interceptor
- * that adds reliability to the membership layer.</p>
- * <p>
- * If the network is busy, or the system is busy so that the membership receiver thread
- * is not getting enough time to update its table, members can be &quot;timed out&quot;
- * This failure detector will intercept the memberDisappeared message(unless its a true shutdown message)
- * and connect to the member using TCP.
- * </p>
- * <p>
- * The TcpFailureDetector works in two ways. <br>
- * 1. It intercepts memberDisappeared events
- * 2. It catches send errors 
- * </p>
- *
- * @author Filip Hanik
- * @version 1.0
- */
-public class TcpFailureDetector extends ChannelInterceptorBase {
-    
-    private static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( TcpFailureDetector.class );
-    
-    protected static byte[] TCP_FAIL_DETECT = new byte[] {
-        79, -89, 115, 72, 121, -126, 67, -55, -97, 111, -119, -128, -95, 91, 7, 20,
-        125, -39, 82, 91, -21, -15, 67, -102, -73, 126, -66, -113, -127, 103, 30, -74,
-        55, 21, -66, -121, 69, 126, 76, -88, -65, 10, 77, 19, 83, 56, 21, 50,
-        85, -10, -108, -73, 58, -6, 64, 120, -111, 4, 125, -41, 114, -124, -64, -43};      
-    
-    protected boolean performConnectTest = true;
-
-    protected long connectTimeout = 1000;//1 second default
-    
-    protected boolean performSendTest = true;
-
-    protected boolean performReadTest = false;
-    
-    protected long readTestTimeout = 5000;//5 seconds
-    
-    protected Membership membership = null;
-    
-    protected HashMap removeSuspects = new HashMap();
-    
-    protected HashMap addSuspects = new HashMap();
-    
-    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
-        try {
-            super.sendMessage(destination, msg, payload);
-        }catch ( ChannelException cx ) {
-            FaultyMember[] mbrs = cx.getFaultyMembers();
-            for ( int i=0; i<mbrs.length; i++ ) {
-                if ( mbrs[i].getCause()!=null &&  
-                     (!(mbrs[i].getCause() instanceof RemoteProcessException)) ) {//RemoteProcessException's are ok
-                    this.memberDisappeared(mbrs[i].getMember());
-                }//end if
-            }//for
-            throw cx;
-        }
-    }
-
-    public void messageReceived(ChannelMessage msg) {
-        //catch incoming 
-        boolean process = true;
-        if ( okToProcess(msg.getOptions()) ) {
-            //check to see if it is a testMessage, if so, process = false
-            process = ( (msg.getMessage().getLength() != TCP_FAIL_DETECT.length) ||
-                        (!Arrays.equals(TCP_FAIL_DETECT,msg.getMessage().getBytes()) ) );
-        }//end if
-            
-        //ignore the message, it doesnt have the flag set
-        if ( process ) super.messageReceived(msg);
-        else if ( log.isDebugEnabled() ) log.debug("Received a failure detector packet:"+msg);
-    }//messageReceived
-    
-    
-    public void memberAdded(Member member) {
-        if ( membership == null ) setupMembership();
-        boolean notify = false;
-        synchronized (membership) {
-            if (removeSuspects.containsKey(member)) {
-                //previously marked suspect, system below picked up the member again
-                removeSuspects.remove(member);
-            } else if (membership.getMember( (MemberImpl) member) == null){
-                //if we add it here, then add it upwards too
-                //check to see if it is alive
-                if (memberAlive(member)) {
-                    membership.memberAlive( (MemberImpl) member);
-                    notify = true;
-                } else {
-                    addSuspects.put(member, new Long(System.currentTimeMillis()));
-                }
-            }
-        }
-        if ( notify ) super.memberAdded(member);
-    }
-
-    public void memberDisappeared(Member member) {
-        if ( membership == null ) setupMembership();
-        boolean notify = false;
-        boolean shutdown = Arrays.equals(member.getCommand(),Member.SHUTDOWN_PAYLOAD);
-        if ( !shutdown ) log.info("Received memberDisappeared["+member+"] message. Will verify.");
-        synchronized (membership) {
-            //check to see if the member really is gone
-            //if the payload is not a shutdown message
-            if (shutdown || !memberAlive(member)) {
-                //not correct, we need to maintain the map
-                membership.removeMember( (MemberImpl) member);
-                removeSuspects.remove(member);
-                notify = true;
-            } else {
-                //add the member as suspect
-                removeSuspects.put(member, new Long(System.currentTimeMillis()));
-            }
-        }
-        if ( notify ) {
-            log.info("Verification complete. Member disappeared["+member+"]");
-            super.memberDisappeared(member);
-        } else {
-            log.info("Verification complete. Member still alive["+member+"]");
-
-        }
-    }
-    
-    public boolean hasMembers() {
-        if ( membership == null ) setupMembership();
-        return membership.hasMembers();
-    }
-
-    public Member[] getMembers() {
-        if ( membership == null ) setupMembership();
-        return membership.getMembers();
-    }
-
-    public Member getMember(Member mbr) {
-        if ( membership == null ) setupMembership();
-        return membership.getMember(mbr);
-    }
-
-    public Member getLocalMember(boolean incAlive) {
-        return super.getLocalMember(incAlive);
-    }
-    
-    public void heartbeat() {
-        try {
-            if (membership == null) setupMembership();
-            synchronized (membership) {
-                //update all alive times
-                Member[] members = super.getMembers();
-                for (int i = 0; members != null && i < members.length; i++) {
-                    if (membership.memberAlive( (MemberImpl) members[i])) {
-                        //we don't have this one in our membership, check to see if he/she is alive
-                        if (memberAlive(members[i])) {
-                            log.warn("Member added, even though we werent notified:" + members[i]);
-                            super.memberAdded(members[i]);
-                        } else {
-                            membership.removeMember( (MemberImpl) members[i]);
-                        } //end if
-                    } //end if
-                } //for
-
-                //check suspect members if they are still alive,
-                //if not, simply issue the memberDisappeared message
-                MemberImpl[] keys = (MemberImpl[]) removeSuspects.keySet().toArray(new MemberImpl[removeSuspects.size()]);
-                for (int i = 0; i < keys.length; i++) {
-                    MemberImpl m = (MemberImpl) keys[i];
-                    if (membership.getMember(m) != null && (!memberAlive(m))) {
-                        membership.removeMember(m);
-                        super.memberDisappeared(m);
-                        removeSuspects.remove(m);
-                        log.info("Suspect member, confirmed dead.["+m+"]");
-                    } //end if
-                }
-
-                //check add suspects members if they are alive now,
-                //if they are, simply issue the memberAdded message
-                keys = (MemberImpl[]) addSuspects.keySet().toArray(new MemberImpl[addSuspects.size()]);
-                for (int i = 0; i < keys.length; i++) {
-                    MemberImpl m = (MemberImpl) keys[i];
-                    if ( membership.getMember(m) == null && (memberAlive(m))) {
-                        membership.memberAlive(m);
-                        super.memberAdded(m);
-                        addSuspects.remove(m);
-                        log.info("Suspect member, confirmed alive.["+m+"]");
-                    } //end if
-                }
-            }
-        }catch ( Exception x ) {
-            log.warn("Unable to perform heartbeat on the TcpFailureDetector.",x);
-        } finally {
-            super.heartbeat();
-        }
-    }
-    
-    protected synchronized void setupMembership() {
-        if ( membership == null ) {
-            membership = new Membership((MemberImpl)super.getLocalMember(true));
-        }
-        
-    }
-    
-    protected boolean memberAlive(Member mbr) {
-        return memberAlive(mbr,TCP_FAIL_DETECT,performSendTest,performReadTest,readTestTimeout,connectTimeout,getOptionFlag());
-    }
-    
-    protected static boolean memberAlive(Member mbr, byte[] msgData, 
-                                         boolean sendTest, boolean readTest,
-                                         long readTimeout, long conTimeout,
-                                         int optionFlag) {
-        //could be a shutdown notification
-        if ( Arrays.equals(mbr.getCommand(),Member.SHUTDOWN_PAYLOAD) ) return false;
-        
-        Socket socket = new Socket();        
-        try {
-            InetAddress ia = InetAddress.getByAddress(mbr.getHost());
-            InetSocketAddress addr = new InetSocketAddress(ia, mbr.getPort());
-            socket.setSoTimeout((int)readTimeout);
-            socket.connect(addr, (int) conTimeout);
-            if ( sendTest ) {
-                ChannelData data = new ChannelData(true);
-                data.setAddress(mbr);
-                data.setMessage(new XByteBuffer(msgData,false));
-                data.setTimestamp(System.currentTimeMillis());
-                int options = optionFlag | Channel.SEND_OPTIONS_BYTE_MESSAGE;
-                if ( readTest ) options = (options | Channel.SEND_OPTIONS_USE_ACK);
-                else options = (options & (~Channel.SEND_OPTIONS_USE_ACK));
-                data.setOptions(options);
-                byte[] message = XByteBuffer.createDataPackage(data);
-                socket.getOutputStream().write(message);
-                if ( readTest ) {
-                    int length = socket.getInputStream().read(message);
-                    return length > 0;
-                }
-            }//end if
-            return true;
-        } catch ( SocketTimeoutException sx) {
-            //do nothing, we couldn't connect
-        } catch ( ConnectException cx) {
-            //do nothing, we couldn't connect
-        }catch (Exception x ) {
-            log.error("Unable to perform failure detection check, assuming member down.",x);
-        } finally {
-            try {socket.close(); } catch ( Exception ignore ){}
-        }
-        return false;
-    }
-
-
-
-    
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ */
+package org.apache.catalina.tribes.group.interceptors;
+
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Socket;
+import java.net.SocketTimeoutException;
+import java.util.Arrays;
+import java.util.HashMap;
+
+import org.apache.catalina.tribes.Channel;
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelException.FaultyMember;
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.RemoteProcessException;
+import org.apache.catalina.tribes.group.ChannelInterceptorBase;
+import org.apache.catalina.tribes.group.InterceptorPayload;
+import org.apache.catalina.tribes.io.ChannelData;
+import org.apache.catalina.tribes.io.XByteBuffer;
+import org.apache.catalina.tribes.membership.MemberImpl;
+import org.apache.catalina.tribes.membership.Membership;
+import java.net.ConnectException;
+
+/**
+ * <p>Title: A perfect failure detector </p>
+ *
+ * <p>Description: The TcpFailureDetector is a useful interceptor
+ * that adds reliability to the membership layer.</p>
+ * <p>
+ * If the network is busy, or the system is busy so that the membership receiver thread
+ * is not getting enough time to update its table, members can be &quot;timed out&quot;
+ * This failure detector will intercept the memberDisappeared message(unless its a true shutdown message)
+ * and connect to the member using TCP.
+ * </p>
+ * <p>
+ * The TcpFailureDetector works in two ways. <br>
+ * 1. It intercepts memberDisappeared events
+ * 2. It catches send errors 
+ * </p>
+ *
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class TcpFailureDetector extends ChannelInterceptorBase {
+    
+    private static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( TcpFailureDetector.class );
+    
+    protected static byte[] TCP_FAIL_DETECT = new byte[] {
+        79, -89, 115, 72, 121, -126, 67, -55, -97, 111, -119, -128, -95, 91, 7, 20,
+        125, -39, 82, 91, -21, -15, 67, -102, -73, 126, -66, -113, -127, 103, 30, -74,
+        55, 21, -66, -121, 69, 126, 76, -88, -65, 10, 77, 19, 83, 56, 21, 50,
+        85, -10, -108, -73, 58, -6, 64, 120, -111, 4, 125, -41, 114, -124, -64, -43};      
+    
+    protected boolean performConnectTest = true;
+
+    protected long connectTimeout = 1000;//1 second default
+    
+    protected boolean performSendTest = true;
+
+    protected boolean performReadTest = false;
+    
+    protected long readTestTimeout = 5000;//5 seconds
+    
+    protected Membership membership = null;
+    
+    protected HashMap removeSuspects = new HashMap();
+    
+    protected HashMap addSuspects = new HashMap();
+    
+    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
+        try {
+            super.sendMessage(destination, msg, payload);
+        }catch ( ChannelException cx ) {
+            FaultyMember[] mbrs = cx.getFaultyMembers();
+            for ( int i=0; i<mbrs.length; i++ ) {
+                if ( mbrs[i].getCause()!=null &&  
+                     (!(mbrs[i].getCause() instanceof RemoteProcessException)) ) {//RemoteProcessException's are ok
+                    this.memberDisappeared(mbrs[i].getMember());
+                }//end if
+            }//for
+            throw cx;
+        }
+    }
+
+    public void messageReceived(ChannelMessage msg) {
+        //catch incoming 
+        boolean process = true;
+        if ( okToProcess(msg.getOptions()) ) {
+            //check to see if it is a testMessage, if so, process = false
+            process = ( (msg.getMessage().getLength() != TCP_FAIL_DETECT.length) ||
+                        (!Arrays.equals(TCP_FAIL_DETECT,msg.getMessage().getBytes()) ) );
+        }//end if
+            
+        //ignore the message, it doesnt have the flag set
+        if ( process ) super.messageReceived(msg);
+        else if ( log.isDebugEnabled() ) log.debug("Received a failure detector packet:"+msg);
+    }//messageReceived
+    
+    
+    public void memberAdded(Member member) {
+        if ( membership == null ) setupMembership();
+        boolean notify = false;
+        synchronized (membership) {
+            if (removeSuspects.containsKey(member)) {
+                //previously marked suspect, system below picked up the member again
+                removeSuspects.remove(member);
+            } else if (membership.getMember( (MemberImpl) member) == null){
+                //if we add it here, then add it upwards too
+                //check to see if it is alive
+                if (memberAlive(member)) {
+                    membership.memberAlive( (MemberImpl) member);
+                    notify = true;
+                } else {
+                    addSuspects.put(member, new Long(System.currentTimeMillis()));
+                }
+            }
+        }
+        if ( notify ) super.memberAdded(member);
+    }
+
+    public void memberDisappeared(Member member) {
+        if ( membership == null ) setupMembership();
+        boolean notify = false;
+        boolean shutdown = Arrays.equals(member.getCommand(),Member.SHUTDOWN_PAYLOAD);
+        if ( !shutdown ) log.info("Received memberDisappeared["+member+"] message. Will verify.");
+        synchronized (membership) {
+            //check to see if the member really is gone
+            //if the payload is not a shutdown message
+            if (shutdown || !memberAlive(member)) {
+                //not correct, we need to maintain the map
+                membership.removeMember( (MemberImpl) member);
+                removeSuspects.remove(member);
+                notify = true;
+            } else {
+                //add the member as suspect
+                removeSuspects.put(member, new Long(System.currentTimeMillis()));
+            }
+        }
+        if ( notify ) {
+            log.info("Verification complete. Member disappeared["+member+"]");
+            super.memberDisappeared(member);
+        } else {
+            log.info("Verification complete. Member still alive["+member+"]");
+
+        }
+    }
+    
+    public boolean hasMembers() {
+        if ( membership == null ) setupMembership();
+        return membership.hasMembers();
+    }
+
+    public Member[] getMembers() {
+        if ( membership == null ) setupMembership();
+        return membership.getMembers();
+    }
+
+    public Member getMember(Member mbr) {
+        if ( membership == null ) setupMembership();
+        return membership.getMember(mbr);
+    }
+
+    public Member getLocalMember(boolean incAlive) {
+        return super.getLocalMember(incAlive);
+    }
+    
+    public void heartbeat() {
+        try {
+            if (membership == null) setupMembership();
+            synchronized (membership) {
+                //update all alive times
+                Member[] members = super.getMembers();
+                for (int i = 0; members != null && i < members.length; i++) {
+                    if (membership.memberAlive( (MemberImpl) members[i])) {
+                        //we don't have this one in our membership, check to see if he/she is alive
+                        if (memberAlive(members[i])) {
+                            log.warn("Member added, even though we werent notified:" + members[i]);
+                            super.memberAdded(members[i]);
+                        } else {
+                            membership.removeMember( (MemberImpl) members[i]);
+                        } //end if
+                    } //end if
+                } //for
+
+                //check suspect members if they are still alive,
+                //if not, simply issue the memberDisappeared message
+                MemberImpl[] keys = (MemberImpl[]) removeSuspects.keySet().toArray(new MemberImpl[removeSuspects.size()]);
+                for (int i = 0; i < keys.length; i++) {
+                    MemberImpl m = (MemberImpl) keys[i];
+                    if (membership.getMember(m) != null && (!memberAlive(m))) {
+                        membership.removeMember(m);
+                        super.memberDisappeared(m);
+                        removeSuspects.remove(m);
+                        log.info("Suspect member, confirmed dead.["+m+"]");
+                    } //end if
+                }
+
+                //check add suspects members if they are alive now,
+                //if they are, simply issue the memberAdded message
+                keys = (MemberImpl[]) addSuspects.keySet().toArray(new MemberImpl[addSuspects.size()]);
+                for (int i = 0; i < keys.length; i++) {
+                    MemberImpl m = (MemberImpl) keys[i];
+                    if ( membership.getMember(m) == null && (memberAlive(m))) {
+                        membership.memberAlive(m);
+                        super.memberAdded(m);
+                        addSuspects.remove(m);
+                        log.info("Suspect member, confirmed alive.["+m+"]");
+                    } //end if
+                }
+            }
+        }catch ( Exception x ) {
+            log.warn("Unable to perform heartbeat on the TcpFailureDetector.",x);
+        } finally {
+            super.heartbeat();
+        }
+    }
+    
+    protected synchronized void setupMembership() {
+        if ( membership == null ) {
+            membership = new Membership((MemberImpl)super.getLocalMember(true));
+        }
+        
+    }
+    
+    protected boolean memberAlive(Member mbr) {
+        return memberAlive(mbr,TCP_FAIL_DETECT,performSendTest,performReadTest,readTestTimeout,connectTimeout,getOptionFlag());
+    }
+    
+    protected static boolean memberAlive(Member mbr, byte[] msgData, 
+                                         boolean sendTest, boolean readTest,
+                                         long readTimeout, long conTimeout,
+                                         int optionFlag) {
+        //could be a shutdown notification
+        if ( Arrays.equals(mbr.getCommand(),Member.SHUTDOWN_PAYLOAD) ) return false;
+        
+        Socket socket = new Socket();        
+        try {
+            InetAddress ia = InetAddress.getByAddress(mbr.getHost());
+            InetSocketAddress addr = new InetSocketAddress(ia, mbr.getPort());
+            socket.setSoTimeout((int)readTimeout);
+            socket.connect(addr, (int) conTimeout);
+            if ( sendTest ) {
+                ChannelData data = new ChannelData(true);
+                data.setAddress(mbr);
+                data.setMessage(new XByteBuffer(msgData,false));
+                data.setTimestamp(System.currentTimeMillis());
+                int options = optionFlag | Channel.SEND_OPTIONS_BYTE_MESSAGE;
+                if ( readTest ) options = (options | Channel.SEND_OPTIONS_USE_ACK);
+                else options = (options & (~Channel.SEND_OPTIONS_USE_ACK));
+                data.setOptions(options);
+                byte[] message = XByteBuffer.createDataPackage(data);
+                socket.getOutputStream().write(message);
+                if ( readTest ) {
+                    int length = socket.getInputStream().read(message);
+                    return length > 0;
+                }
+            }//end if
+            return true;
+        } catch ( SocketTimeoutException sx) {
+            //do nothing, we couldn't connect
+        } catch ( ConnectException cx) {
+            //do nothing, we couldn't connect
+        }catch (Exception x ) {
+            log.error("Unable to perform failure detection check, assuming member down.",x);
+        } finally {
+            try {socket.close(); } catch ( Exception ignore ){}
+        }
+        return false;
+    }
+
+
+
+    
 }
\ No newline at end of file

==================================================
TwoPhaseCommitInterceptor.java
index fe99d49961..537cf55d43 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/ThroughputInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/ThroughputInterceptor.java
@@ -1,119 +1,120 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- */
-
-package org.apache.catalina.tribes.group.interceptors;
-
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.group.ChannelInterceptorBase;
-import org.apache.catalina.tribes.group.InterceptorPayload;
-import org.apache.catalina.tribes.io.ChannelData;
-import org.apache.catalina.tribes.io.XByteBuffer;
-import java.text.DecimalFormat;
-import org.apache.catalina.tribes.membership.MemberImpl;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicLong;
-
-
-
-/**
- *
- *
- * @author Filip Hanik
- * @version 1.0
- */
-public class ThroughputInterceptor extends ChannelInterceptorBase {
-    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(ThroughputInterceptor.class);
-
-    double mbTx = 0;
-    double mbAppTx = 0;
-    double mbRx = 0;
-    double timeTx = 0;
-    double lastCnt = 0;
-    AtomicLong msgTxCnt = new AtomicLong(1);
-    AtomicLong msgRxCnt = new AtomicLong(0);
-    AtomicLong msgTxErr = new AtomicLong(0);
-    int interval = 10000;
-    AtomicInteger access = new AtomicInteger(0);
-    long txStart = 0;
-    long rxStart = 0;
-    DecimalFormat df = new DecimalFormat("#0.00");
-
-
-    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
-        if ( access.addAndGet(1) == 1 ) txStart = System.currentTimeMillis();
-        long bytes = XByteBuffer.getDataPackageLength(((ChannelData)msg).getDataPackageLength());
-        try {
-            super.sendMessage(destination, msg, payload);
-        }catch ( ChannelException x ) {
-            msgTxErr.addAndGet(1);
-            access.addAndGet(-1);
-            throw x;
-        } 
-        mbTx += ((double)(bytes*destination.length))/(1024d*1024d);
-        mbAppTx += ((double)(bytes))/(1024d*1024d);
-        if ( access.addAndGet(-1) == 0 ) {
-            long stop = System.currentTimeMillis();
-            timeTx += ( (double) (stop - txStart)) / 1000d;
-            if ((msgTxCnt.get() / interval) >= lastCnt) {
-                lastCnt++;
-                report(timeTx);
-            }
-        }
-        msgTxCnt.addAndGet(1);
-    }
-
-    public void messageReceived(ChannelMessage msg) {
-        if ( rxStart == 0 ) rxStart = System.currentTimeMillis();
-        long bytes = XByteBuffer.getDataPackageLength(((ChannelData)msg).getDataPackageLength());
-        mbRx += ((double)bytes)/(1024d*1024d);
-        msgRxCnt.addAndGet(1);
-        if ( msgRxCnt.get() % interval == 0 ) report(timeTx);
-        super.messageReceived(msg);
-        
-    }
-    
-    public void report(double timeTx) {
-        StringBuffer buf = new StringBuffer("ThroughputInterceptor Report[\n\tTx Msg:");
-        buf.append(msgTxCnt).append(" messages\n\tSent:");
-        buf.append(df.format(mbTx));
-        buf.append(" MB (total)\n\tSent:");
-        buf.append(df.format(mbAppTx));
-        buf.append(" MB (application)\n\tTime:");
-        buf.append(df.format(timeTx));
-        buf.append(" seconds\n\tTx Speed:");
-        buf.append(df.format(mbTx/timeTx));
-        buf.append(" MB/sec (total)\n\tTxSpeed:");
-        buf.append(df.format(mbAppTx/timeTx));
-        buf.append(" MB/sec (application)\n\tError Msg:");
-        buf.append(msgTxErr).append("\n\tRx Msg:");
-        buf.append(msgRxCnt);
-        buf.append(" messages\n\tRx Speed:");
-        buf.append(df.format(mbRx/((double)((System.currentTimeMillis()-rxStart)/1000))));
-        buf.append(" MB/sec (since 1st msg)\n\tReceived:");
-        buf.append(df.format(mbRx)).append(" MB]\n");
-        if ( log.isInfoEnabled() ) log.info(buf);
-    }
-    
-    public void setInterval(int interval) {
-        this.interval = interval;
-    }
-
-    public int getInterval() {
-        return interval;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ */
+
+package org.apache.catalina.tribes.group.interceptors;
+
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.group.ChannelInterceptorBase;
+import org.apache.catalina.tribes.group.InterceptorPayload;
+import org.apache.catalina.tribes.io.ChannelData;
+import org.apache.catalina.tribes.io.XByteBuffer;
+import java.text.DecimalFormat;
+import org.apache.catalina.tribes.membership.MemberImpl;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
+
+
+
+/**
+ *
+ *
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class ThroughputInterceptor extends ChannelInterceptorBase {
+    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(ThroughputInterceptor.class);
+
+    double mbTx = 0;
+    double mbAppTx = 0;
+    double mbRx = 0;
+    double timeTx = 0;
+    double lastCnt = 0;
+    AtomicLong msgTxCnt = new AtomicLong(1);
+    AtomicLong msgRxCnt = new AtomicLong(0);
+    AtomicLong msgTxErr = new AtomicLong(0);
+    int interval = 10000;
+    AtomicInteger access = new AtomicInteger(0);
+    long txStart = 0;
+    long rxStart = 0;
+    DecimalFormat df = new DecimalFormat("#0.00");
+
+
+    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
+        if ( access.addAndGet(1) == 1 ) txStart = System.currentTimeMillis();
+        long bytes = XByteBuffer.getDataPackageLength(((ChannelData)msg).getDataPackageLength());
+        try {
+            super.sendMessage(destination, msg, payload);
+        }catch ( ChannelException x ) {
+            msgTxErr.addAndGet(1);
+            access.addAndGet(-1);
+            throw x;
+        } 
+        mbTx += ((double)(bytes*destination.length))/(1024d*1024d);
+        mbAppTx += ((double)(bytes))/(1024d*1024d);
+        if ( access.addAndGet(-1) == 0 ) {
+            long stop = System.currentTimeMillis();
+            timeTx += ( (double) (stop - txStart)) / 1000d;
+            if ((msgTxCnt.get() / interval) >= lastCnt) {
+                lastCnt++;
+                report(timeTx);
+            }
+        }
+        msgTxCnt.addAndGet(1);
+    }
+
+    public void messageReceived(ChannelMessage msg) {
+        if ( rxStart == 0 ) rxStart = System.currentTimeMillis();
+        long bytes = XByteBuffer.getDataPackageLength(((ChannelData)msg).getDataPackageLength());
+        mbRx += ((double)bytes)/(1024d*1024d);
+        msgRxCnt.addAndGet(1);
+        if ( msgRxCnt.get() % interval == 0 ) report(timeTx);
+        super.messageReceived(msg);
+        
+    }
+    
+    public void report(double timeTx) {
+        StringBuffer buf = new StringBuffer("ThroughputInterceptor Report[\n\tTx Msg:");
+        buf.append(msgTxCnt).append(" messages\n\tSent:");
+        buf.append(df.format(mbTx));
+        buf.append(" MB (total)\n\tSent:");
+        buf.append(df.format(mbAppTx));
+        buf.append(" MB (application)\n\tTime:");
+        buf.append(df.format(timeTx));
+        buf.append(" seconds\n\tTx Speed:");
+        buf.append(df.format(mbTx/timeTx));
+        buf.append(" MB/sec (total)\n\tTxSpeed:");
+        buf.append(df.format(mbAppTx/timeTx));
+        buf.append(" MB/sec (application)\n\tError Msg:");
+        buf.append(msgTxErr).append("\n\tRx Msg:");
+        buf.append(msgRxCnt);
+        buf.append(" messages\n\tRx Speed:");
+        buf.append(df.format(mbRx/((double)((System.currentTimeMillis()-rxStart)/1000))));
+        buf.append(" MB/sec (since 1st msg)\n\tReceived:");
+        buf.append(df.format(mbRx)).append(" MB]\n");
+        if ( log.isInfoEnabled() ) log.info(buf);
+    }
+    
+    public void setInterval(int interval) {
+        this.interval = interval;
+    }
+
+    public int getInterval() {
+        return interval;
+    }
+
+}

==================================================
BufferPool.java
index 5d2b9f4e15..dd5d224c63 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/TwoPhaseCommitInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/TwoPhaseCommitInterceptor.java
@@ -1,148 +1,149 @@
-/*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.group.interceptors;
-
-import java.util.HashMap;
-
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.group.ChannelInterceptorBase;
-import org.apache.catalina.tribes.group.InterceptorPayload;
-import org.apache.catalina.tribes.util.UUIDGenerator;
-import org.apache.catalina.tribes.util.Arrays;
-import org.apache.catalina.tribes.UniqueId;
-import java.util.Map;
-
-/**
- * <p>Title: </p>
- *
- * <p>Description: </p>
- *
- * <p>Copyright: Copyright (c) 2005</p>
- *
- * <p>Company: </p>
- *
- * @author not attributable
- * @version 1.0
- */
-public class TwoPhaseCommitInterceptor extends ChannelInterceptorBase {
-
-    public static final byte[] START_DATA = new byte[] {113, 1, -58, 2, -34, -60, 75, -78, -101, -12, 32, -29, 32, 111, -40, 4};
-    public static final byte[] END_DATA = new byte[] {54, -13, 90, 110, 47, -31, 75, -24, -81, -29, 36, 52, -58, 77, -110, 56};
-    private static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(TwoPhaseCommitInterceptor.class);
-
-    protected HashMap messages = new HashMap();
-    protected long expire = 1000 * 60; //one minute expiration
-    protected boolean deepclone = true;
-
-    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws
-        ChannelException {
-        //todo, optimize, if destination.length==1, then we can do
-        //msg.setOptions(msg.getOptions() & (~getOptionFlag())
-        //and just send one message
-        if (okToProcess(msg.getOptions()) ) {
-            super.sendMessage(destination, msg, null);
-            ChannelMessage confirmation = null;
-            if ( deepclone ) confirmation = (ChannelMessage)msg.deepclone();
-            else confirmation = (ChannelMessage)msg.clone();
-            confirmation.getMessage().reset();
-            UUIDGenerator.randomUUID(false,confirmation.getUniqueId(),0);
-            confirmation.getMessage().append(START_DATA,0,START_DATA.length);
-            confirmation.getMessage().append(msg.getUniqueId(),0,msg.getUniqueId().length);
-            confirmation.getMessage().append(END_DATA,0,END_DATA.length);
-            super.sendMessage(destination,confirmation,payload);
-        } else {
-            //turn off two phase commit
-            //this wont work if the interceptor has 0 as a flag
-            //since there is no flag to turn off
-            //msg.setOptions(msg.getOptions() & (~getOptionFlag()));
-            super.sendMessage(destination, msg, payload);
-        }
-    }
-
-    public void messageReceived(ChannelMessage msg) {
-        if (okToProcess(msg.getOptions())) {
-            if ( msg.getMessage().getLength() == (START_DATA.length+msg.getUniqueId().length+END_DATA.length) &&
-                 Arrays.contains(msg.getMessage().getBytesDirect(),0,START_DATA,0,START_DATA.length) &&
-                 Arrays.contains(msg.getMessage().getBytesDirect(),START_DATA.length+msg.getUniqueId().length,END_DATA,0,END_DATA.length) ) {
-                UniqueId id = new UniqueId(msg.getMessage().getBytesDirect(),START_DATA.length,msg.getUniqueId().length);
-                MapEntry original = (MapEntry)messages.get(id);
-                if ( original != null ) {
-                    super.messageReceived(original.msg);
-                    messages.remove(id);
-                } else log.warn("Received a confirmation, but original message is missing. Id:"+Arrays.toString(id.getBytes()));
-            } else {
-                UniqueId id = new UniqueId(msg.getUniqueId());
-                MapEntry entry = new MapEntry((ChannelMessage)msg.deepclone(),id,System.currentTimeMillis());
-                messages.put(id,entry);
-            }
-        } else {
-            super.messageReceived(msg);
-        }
-    }
-
-    public boolean getDeepclone() {
-        return deepclone;
-    }
-
-    public long getExpire() {
-        return expire;
-    }
-
-    public void setDeepclone(boolean deepclone) {
-        this.deepclone = deepclone;
-    }
-
-    public void setExpire(long expire) {
-        this.expire = expire;
-    }
-    
-    public void heartbeat() {
-        try {
-            long now = System.currentTimeMillis();
-            Map.Entry[] entries = (Map.Entry[])messages.entrySet().toArray(new Map.Entry[messages.size()]);
-            for (int i=0; i<entries.length; i++ ) {
-                MapEntry entry = (MapEntry)entries[i].getValue();
-                if ( entry.expired(now,expire) ) {
-                    log.info("Message ["+entry.id+"] has expired. Removing.");
-                    messages.remove(entry.id);
-                }//end if
-            }
-        } catch ( Exception x ) {
-            log.warn("Unable to perform heartbeat on the TwoPhaseCommit interceptor.",x);
-        } finally {
-            super.heartbeat();
-        }
-    }
-    
-    public static class MapEntry {
-        public ChannelMessage msg;
-        public UniqueId id;
-        public long timestamp;
-        
-        public MapEntry(ChannelMessage msg, UniqueId id, long timestamp) {
-            this.msg = msg;
-            this.id = id;
-            this.timestamp = timestamp;
-        }
-        public boolean expired(long now, long expiration) {
-            return (now - timestamp ) > expiration;
-        }
-
-    }
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.group.interceptors;
+
+import java.util.HashMap;
+
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.group.ChannelInterceptorBase;
+import org.apache.catalina.tribes.group.InterceptorPayload;
+import org.apache.catalina.tribes.util.UUIDGenerator;
+import org.apache.catalina.tribes.util.Arrays;
+import org.apache.catalina.tribes.UniqueId;
+import java.util.Map;
+
+/**
+ * <p>Title: </p>
+ *
+ * <p>Description: </p>
+ *
+ * <p>Copyright: Copyright (c) 2005</p>
+ *
+ * <p>Company: </p>
+ *
+ * @author not attributable
+ * @version 1.0
+ */
+public class TwoPhaseCommitInterceptor extends ChannelInterceptorBase {
+
+    public static final byte[] START_DATA = new byte[] {113, 1, -58, 2, -34, -60, 75, -78, -101, -12, 32, -29, 32, 111, -40, 4};
+    public static final byte[] END_DATA = new byte[] {54, -13, 90, 110, 47, -31, 75, -24, -81, -29, 36, 52, -58, 77, -110, 56};
+    private static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(TwoPhaseCommitInterceptor.class);
+
+    protected HashMap messages = new HashMap();
+    protected long expire = 1000 * 60; //one minute expiration
+    protected boolean deepclone = true;
+
+    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws
+        ChannelException {
+        //todo, optimize, if destination.length==1, then we can do
+        //msg.setOptions(msg.getOptions() & (~getOptionFlag())
+        //and just send one message
+        if (okToProcess(msg.getOptions()) ) {
+            super.sendMessage(destination, msg, null);
+            ChannelMessage confirmation = null;
+            if ( deepclone ) confirmation = (ChannelMessage)msg.deepclone();
+            else confirmation = (ChannelMessage)msg.clone();
+            confirmation.getMessage().reset();
+            UUIDGenerator.randomUUID(false,confirmation.getUniqueId(),0);
+            confirmation.getMessage().append(START_DATA,0,START_DATA.length);
+            confirmation.getMessage().append(msg.getUniqueId(),0,msg.getUniqueId().length);
+            confirmation.getMessage().append(END_DATA,0,END_DATA.length);
+            super.sendMessage(destination,confirmation,payload);
+        } else {
+            //turn off two phase commit
+            //this wont work if the interceptor has 0 as a flag
+            //since there is no flag to turn off
+            //msg.setOptions(msg.getOptions() & (~getOptionFlag()));
+            super.sendMessage(destination, msg, payload);
+        }
+    }
+
+    public void messageReceived(ChannelMessage msg) {
+        if (okToProcess(msg.getOptions())) {
+            if ( msg.getMessage().getLength() == (START_DATA.length+msg.getUniqueId().length+END_DATA.length) &&
+                 Arrays.contains(msg.getMessage().getBytesDirect(),0,START_DATA,0,START_DATA.length) &&
+                 Arrays.contains(msg.getMessage().getBytesDirect(),START_DATA.length+msg.getUniqueId().length,END_DATA,0,END_DATA.length) ) {
+                UniqueId id = new UniqueId(msg.getMessage().getBytesDirect(),START_DATA.length,msg.getUniqueId().length);
+                MapEntry original = (MapEntry)messages.get(id);
+                if ( original != null ) {
+                    super.messageReceived(original.msg);
+                    messages.remove(id);
+                } else log.warn("Received a confirmation, but original message is missing. Id:"+Arrays.toString(id.getBytes()));
+            } else {
+                UniqueId id = new UniqueId(msg.getUniqueId());
+                MapEntry entry = new MapEntry((ChannelMessage)msg.deepclone(),id,System.currentTimeMillis());
+                messages.put(id,entry);
+            }
+        } else {
+            super.messageReceived(msg);
+        }
+    }
+
+    public boolean getDeepclone() {
+        return deepclone;
+    }
+
+    public long getExpire() {
+        return expire;
+    }
+
+    public void setDeepclone(boolean deepclone) {
+        this.deepclone = deepclone;
+    }
+
+    public void setExpire(long expire) {
+        this.expire = expire;
+    }
+    
+    public void heartbeat() {
+        try {
+            long now = System.currentTimeMillis();
+            Map.Entry[] entries = (Map.Entry[])messages.entrySet().toArray(new Map.Entry[messages.size()]);
+            for (int i=0; i<entries.length; i++ ) {
+                MapEntry entry = (MapEntry)entries[i].getValue();
+                if ( entry.expired(now,expire) ) {
+                    log.info("Message ["+entry.id+"] has expired. Removing.");
+                    messages.remove(entry.id);
+                }//end if
+            }
+        } catch ( Exception x ) {
+            log.warn("Unable to perform heartbeat on the TwoPhaseCommit interceptor.",x);
+        } finally {
+            super.heartbeat();
+        }
+    }
+    
+    public static class MapEntry {
+        public ChannelMessage msg;
+        public UniqueId id;
+        public long timestamp;
+        
+        public MapEntry(ChannelMessage msg, UniqueId id, long timestamp) {
+            this.msg = msg;
+            this.id = id;
+            this.timestamp = timestamp;
+        }
+        public boolean expired(long now, long expiration) {
+            return (now - timestamp ) > expiration;
+        }
+
+    }
+
 }
\ No newline at end of file

==================================================
BufferPool14Impl.java
index b3dc19290e..62b9160c9c 100644
--- a/java/org/apache/catalina/tribes/io/BufferPool.java
+++ b/java/org/apache/catalina/tribes/io/BufferPool.java
@@ -1,93 +1,94 @@
-/*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.io;
-
-
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-
-/**
- *
- * @author Filip Hanik
- * 
- * @version 1.0
- */
-public class BufferPool {
-    protected static Log log = LogFactory.getLog(BufferPool.class);
-
-    public static int DEFAULT_POOL_SIZE = 100*1024*1024; //100MB
-
-
-
-    protected static BufferPool instance = null;
-    protected BufferPoolAPI pool = null;
-
-    private BufferPool(BufferPoolAPI pool) {
-        this.pool = pool;
-    }
-
-    public XByteBuffer getBuffer(int minSize, boolean discard) {
-        if ( pool != null ) return pool.getBuffer(minSize, discard);
-        else return new XByteBuffer(minSize,discard);
-    }
-
-    public void returnBuffer(XByteBuffer buffer) {
-        if ( pool != null ) pool.returnBuffer(buffer);
-    }
-
-    public void clear() {
-        if ( pool != null ) pool.clear();
-    }
-
-
-    public static BufferPool getBufferPool() {
-        if (  (instance == null) ) {
-            synchronized (BufferPool.class) {
-                if ( instance == null ) {
-                   BufferPoolAPI pool = null;
-                   Class clazz = null;
-                   try {
-                       clazz = Class.forName("org.apache.catalina.tribes.io.BufferPool15Impl");
-                       pool = (BufferPoolAPI)clazz.newInstance();
-                   } catch ( Throwable x ) {
-                       try {
-                           clazz = Class.forName("org.apache.catalina.tribes.io.BufferPool14Impl");
-                           pool = (BufferPoolAPI)clazz.newInstance();
-                       } catch ( Throwable e ) {
-                           log.warn("Unable to initilize BufferPool, not pooling XByteBuffer objects:"+x.getMessage());
-                           if ( log.isDebugEnabled() ) log.debug("Unable to initilize BufferPool, not pooling XByteBuffer objects:",x);
-                       }
-                   }
-                   pool.setMaxSize(DEFAULT_POOL_SIZE);
-                   log.info("Created a buffer pool with max size:"+DEFAULT_POOL_SIZE+" bytes of type:"+(clazz!=null?clazz.getName():"null"));
-                   instance = new BufferPool(pool);
-                }//end if
-            }//sync
-        }//end if
-        return instance;
-    }
-
-
-    public static interface BufferPoolAPI {
-        public void setMaxSize(int bytes);
-
-        public XByteBuffer getBuffer(int minSize, boolean discard);
-
-        public void returnBuffer(XByteBuffer buffer);
-
-        public void clear();
-    }    
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.io;
+
+
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+
+/**
+ *
+ * @author Filip Hanik
+ * 
+ * @version 1.0
+ */
+public class BufferPool {
+    protected static Log log = LogFactory.getLog(BufferPool.class);
+
+    public static int DEFAULT_POOL_SIZE = 100*1024*1024; //100MB
+
+
+
+    protected static BufferPool instance = null;
+    protected BufferPoolAPI pool = null;
+
+    private BufferPool(BufferPoolAPI pool) {
+        this.pool = pool;
+    }
+
+    public XByteBuffer getBuffer(int minSize, boolean discard) {
+        if ( pool != null ) return pool.getBuffer(minSize, discard);
+        else return new XByteBuffer(minSize,discard);
+    }
+
+    public void returnBuffer(XByteBuffer buffer) {
+        if ( pool != null ) pool.returnBuffer(buffer);
+    }
+
+    public void clear() {
+        if ( pool != null ) pool.clear();
+    }
+
+
+    public static BufferPool getBufferPool() {
+        if (  (instance == null) ) {
+            synchronized (BufferPool.class) {
+                if ( instance == null ) {
+                   BufferPoolAPI pool = null;
+                   Class clazz = null;
+                   try {
+                       clazz = Class.forName("org.apache.catalina.tribes.io.BufferPool15Impl");
+                       pool = (BufferPoolAPI)clazz.newInstance();
+                   } catch ( Throwable x ) {
+                       try {
+                           clazz = Class.forName("org.apache.catalina.tribes.io.BufferPool14Impl");
+                           pool = (BufferPoolAPI)clazz.newInstance();
+                       } catch ( Throwable e ) {
+                           log.warn("Unable to initilize BufferPool, not pooling XByteBuffer objects:"+x.getMessage());
+                           if ( log.isDebugEnabled() ) log.debug("Unable to initilize BufferPool, not pooling XByteBuffer objects:",x);
+                       }
+                   }
+                   pool.setMaxSize(DEFAULT_POOL_SIZE);
+                   log.info("Created a buffer pool with max size:"+DEFAULT_POOL_SIZE+" bytes of type:"+(clazz!=null?clazz.getName():"null"));
+                   instance = new BufferPool(pool);
+                }//end if
+            }//sync
+        }//end if
+        return instance;
+    }
+
+
+    public static interface BufferPoolAPI {
+        public void setMaxSize(int bytes);
+
+        public XByteBuffer getBuffer(int minSize, boolean discard);
+
+        public void returnBuffer(XByteBuffer buffer);
+
+        public void clear();
+    }    
+}

==================================================
BufferPool15Impl.java
index f2b875077c..95de910952 100644
--- a/java/org/apache/catalina/tribes/io/BufferPool14Impl.java
+++ b/java/org/apache/catalina/tribes/io/BufferPool14Impl.java
@@ -1,69 +1,70 @@
-/*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.io;
-
-import java.util.Queue;
-import java.util.LinkedList;
-
-
-/**
- *
- * @author Filip Hanik
- * @version 1.0
- */
-class BufferPool14Impl implements BufferPool.BufferPoolAPI {
-    protected int maxSize;
-    protected int size = 0;
-    protected LinkedList queue = new LinkedList();
-
-    public void setMaxSize(int bytes) {
-        this.maxSize = bytes;
-    }
-    
-    public synchronized int addAndGet(int val) {
-        size = size + (val);
-        return size;
-    }
-    
-    
-
-    public synchronized XByteBuffer getBuffer(int minSize, boolean discard) {
-        XByteBuffer buffer = (XByteBuffer)(queue.size()>0?queue.remove(0):null);
-        if ( buffer != null ) addAndGet(-buffer.getCapacity());
-        if ( buffer == null ) buffer = new XByteBuffer(minSize,discard);
-        else if ( buffer.getCapacity() <= minSize ) buffer.expand(minSize);
-        buffer.setDiscard(discard);
-        buffer.reset();
-        return buffer;
-    }
-
-    public synchronized void returnBuffer(XByteBuffer buffer) {
-        if ( (size + buffer.getCapacity()) <= maxSize ) {
-            addAndGet(buffer.getCapacity());
-            queue.add(buffer);
-        }
-    }
-
-    public synchronized void clear() {
-        queue.clear();
-        size = 0;
-    }
-
-    public int getMaxSize() {
-        return maxSize;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.io;
+
+import java.util.Queue;
+import java.util.LinkedList;
+
+
+/**
+ *
+ * @author Filip Hanik
+ * @version 1.0
+ */
+class BufferPool14Impl implements BufferPool.BufferPoolAPI {
+    protected int maxSize;
+    protected int size = 0;
+    protected LinkedList queue = new LinkedList();
+
+    public void setMaxSize(int bytes) {
+        this.maxSize = bytes;
+    }
+    
+    public synchronized int addAndGet(int val) {
+        size = size + (val);
+        return size;
+    }
+    
+    
+
+    public synchronized XByteBuffer getBuffer(int minSize, boolean discard) {
+        XByteBuffer buffer = (XByteBuffer)(queue.size()>0?queue.remove(0):null);
+        if ( buffer != null ) addAndGet(-buffer.getCapacity());
+        if ( buffer == null ) buffer = new XByteBuffer(minSize,discard);
+        else if ( buffer.getCapacity() <= minSize ) buffer.expand(minSize);
+        buffer.setDiscard(discard);
+        buffer.reset();
+        return buffer;
+    }
+
+    public synchronized void returnBuffer(XByteBuffer buffer) {
+        if ( (size + buffer.getCapacity()) <= maxSize ) {
+            addAndGet(buffer.getCapacity());
+            queue.add(buffer);
+        }
+    }
+
+    public synchronized void clear() {
+        queue.clear();
+        size = 0;
+    }
+
+    public int getMaxSize() {
+        return maxSize;
+    }
+
+}

==================================================
ChannelData.java
index 7cf5e5f060..6cd29745a2 100644
--- a/java/org/apache/catalina/tribes/io/BufferPool15Impl.java
+++ b/java/org/apache/catalina/tribes/io/BufferPool15Impl.java
@@ -1,62 +1,63 @@
-/*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.io;
-
-import java.util.concurrent.ConcurrentLinkedQueue;
-import java.util.concurrent.atomic.AtomicInteger;
-
-/**
- *
- * @author Filip Hanik
- * @version 1.0
- */
-class BufferPool15Impl implements BufferPool.BufferPoolAPI {
-    protected int maxSize;
-    protected AtomicInteger size = new AtomicInteger(0);
-    protected ConcurrentLinkedQueue queue = new ConcurrentLinkedQueue();
-
-    public void setMaxSize(int bytes) {
-        this.maxSize = bytes;
-    }
-
-
-    public XByteBuffer getBuffer(int minSize, boolean discard) {
-        XByteBuffer buffer = (XByteBuffer)queue.poll();
-        if ( buffer != null ) size.addAndGet(-buffer.getCapacity());
-        if ( buffer == null ) buffer = new XByteBuffer(minSize,discard);
-        else if ( buffer.getCapacity() <= minSize ) buffer.expand(minSize);
-        buffer.setDiscard(discard);
-        buffer.reset();
-        return buffer;
-    }
-
-    public void returnBuffer(XByteBuffer buffer) {
-        if ( (size.get() + buffer.getCapacity()) <= maxSize ) {
-            size.addAndGet(buffer.getCapacity());
-            queue.offer(buffer);
-        }
-    }
-
-    public void clear() {
-        queue.clear();
-        size.set(0);
-    }
-
-    public int getMaxSize() {
-        return maxSize;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.io;
+
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ *
+ * @author Filip Hanik
+ * @version 1.0
+ */
+class BufferPool15Impl implements BufferPool.BufferPoolAPI {
+    protected int maxSize;
+    protected AtomicInteger size = new AtomicInteger(0);
+    protected ConcurrentLinkedQueue queue = new ConcurrentLinkedQueue();
+
+    public void setMaxSize(int bytes) {
+        this.maxSize = bytes;
+    }
+
+
+    public XByteBuffer getBuffer(int minSize, boolean discard) {
+        XByteBuffer buffer = (XByteBuffer)queue.poll();
+        if ( buffer != null ) size.addAndGet(-buffer.getCapacity());
+        if ( buffer == null ) buffer = new XByteBuffer(minSize,discard);
+        else if ( buffer.getCapacity() <= minSize ) buffer.expand(minSize);
+        buffer.setDiscard(discard);
+        buffer.reset();
+        return buffer;
+    }
+
+    public void returnBuffer(XByteBuffer buffer) {
+        if ( (size.get() + buffer.getCapacity()) <= maxSize ) {
+            size.addAndGet(buffer.getCapacity());
+            queue.offer(buffer);
+        }
+    }
+
+    public void clear() {
+        queue.clear();
+        size.set(0);
+    }
+
+    public int getMaxSize() {
+        return maxSize;
+    }
+
+}

==================================================
DirectByteArrayOutputStream.java
index 42bdb83f5f..ba63b87c83 100644
--- a/java/org/apache/catalina/tribes/io/ChannelData.java
+++ b/java/org/apache/catalina/tribes/io/ChannelData.java
@@ -1,356 +1,357 @@
-/*
- * Copyright 1999,2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.io;
-
-import java.util.Arrays;
-
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.membership.MemberImpl;
-import org.apache.catalina.tribes.util.UUIDGenerator;
-import org.apache.catalina.tribes.Channel;
-import java.sql.Timestamp;
-
-/**
- * The <code>ChannelData</code> object is used to transfer a message through the 
- * channel interceptor stack and eventually out on a transport to be sent 
- * to another node. While the message is being processed by the different 
- * interceptors, the message data can be manipulated as each interceptor seems appropriate.
- * @author Peter Rossbach
- * @author Filip Hanik
- * @version $Revision: 377484 $ $Date: 2006-02-13 15:00:05 -0600 (Mon, 13 Feb 2006) $
- * 
- */
-public class ChannelData implements ChannelMessage {
-    public static ChannelData[] EMPTY_DATA_ARRAY = new ChannelData[0];
-    
-    public static boolean USE_SECURE_RANDOM_FOR_UUID = false;
-    
-    /**
-     * The options this message was sent with
-     */
-    private int options = 0 ;
-    /**
-     * The message data, stored in a dynamic buffer
-     */
-    private XByteBuffer message ;
-    /**
-     * The timestamp that goes with this message
-     */
-    private long timestamp ;
-    /**
-     * A unique message id
-     */
-    private byte[] uniqueId ;
-    /**
-     * The source or reply-to address for this message
-     */
-    private Member address;
-
-    /**
-     * Creates an empty channel data with a new unique Id
-     * @see #ChannelData(boolean)
-     */
-    public ChannelData() {
-        this(true);
-    }
-    
-    /**
-     * Create an empty channel data object
-     * @param generateUUID boolean - if true, a unique Id will be generated
-     */
-    public ChannelData(boolean generateUUID) {
-        if ( generateUUID ) generateUUID();
-    }
-    
-    
-    
-    /**
-     * Creates a new channel data object with data
-     * @param uniqueId - unique message id
-     * @param message - message data
-     * @param timestamp - message timestamp
-     */
-    public ChannelData(byte[] uniqueId, XByteBuffer message, long timestamp) {
-        this.uniqueId = uniqueId;
-        this.message = message;
-        this.timestamp = timestamp;
-    }
-    
-    /**
-     * @return Returns the message byte buffer
-     */
-    public XByteBuffer getMessage() {
-        return message;
-    }
-    /**
-     * @param message The message to send.
-     */
-    public void setMessage(XByteBuffer message) {
-        this.message = message;
-    }
-    /**
-     * @return Returns the timestamp.
-     */
-    public long getTimestamp() {
-        return timestamp;
-    }
-    /**
-     * @param timestamp The timestamp to send
-     */
-    public void setTimestamp(long timestamp) {
-        this.timestamp = timestamp;
-    }
-    /**
-     * @return Returns the uniqueId.
-     */
-    public byte[] getUniqueId() {
-        return uniqueId;
-    }
-    /**
-     * @param uniqueId The uniqueId to send.
-     */
-    public void setUniqueId(byte[] uniqueId) {
-        this.uniqueId = uniqueId;
-    }
-    /**
-     * @return returns the message options 
-     * see org.apache.catalina.tribes.Channel#sendMessage(org.apache.catalina.tribes.Member[], java.io.Serializable, int)
-     *                                                 
-     */
-    public int getOptions() {
-        return options;
-    }
-    /**
-     * @param sets the message options
-     */
-    public void setOptions(int options) {
-        this.options = options;
-    }
-    
-    /**
-     * Returns the source or reply-to address
-     * @return Member
-     */
-    public Member getAddress() {
-        return address;
-    }
-
-    /**
-     * Sets the source or reply-to address
-     * @param address Member
-     */
-    public void setAddress(Member address) {
-        this.address = address;
-    }
-    
-    /**
-     * Generates a UUID and invokes setUniqueId
-     */
-    public void generateUUID() {
-        byte[] data = new byte[16];
-        UUIDGenerator.randomUUID(USE_SECURE_RANDOM_FOR_UUID,data,0);
-        setUniqueId(data);
-    }
-
-    public int getDataPackageLength() {
-        int length = 
-            4 + //options
-            8 + //timestamp  off=4
-            4 + //unique id length off=12
-            uniqueId.length+ //id data off=12+uniqueId.length
-            4 + //addr length off=12+uniqueId.length+4
-            ((MemberImpl)address).getDataLength()+ //member data off=12+uniqueId.length+4+add.length
-            4 + //message length off=12+uniqueId.length+4+add.length+4
-            message.getLength();
-        return length;
-
-    }
-    
-    /**
-     * Serializes the ChannelData object into a byte[] array
-     * @return byte[]
-     */
-    public byte[] getDataPackage()  {
-        int length = getDataPackageLength();
-        byte[] data = new byte[length];
-        int offset = 0;
-        return getDataPackage(data,offset);
-    }
-
-    public byte[] getDataPackage(byte[] data, int offset)  {
-        byte[] addr = ((MemberImpl)address).getData(false);
-        XByteBuffer.toBytes(options,data,offset);
-        offset += 4; //options
-        XByteBuffer.toBytes(timestamp,data,offset);
-        offset += 8; //timestamp
-        XByteBuffer.toBytes(uniqueId.length,data,offset);
-        offset += 4; //uniqueId.length
-        System.arraycopy(uniqueId,0,data,offset,uniqueId.length);
-        offset += uniqueId.length; //uniqueId data
-        XByteBuffer.toBytes(addr.length,data,offset);
-        offset += 4; //addr.length
-        System.arraycopy(addr,0,data,offset,addr.length);
-        offset += addr.length; //addr data
-        XByteBuffer.toBytes(message.getLength(),data,offset);
-        offset += 4; //message.length
-        System.arraycopy(message.getBytesDirect(),0,data,offset,message.getLength());
-        offset += message.getLength(); //message data
-        return data;
-    }
-    
-    /**
-     * Deserializes a ChannelData object from a byte array
-     * @param b byte[]
-     * @return ChannelData
-     */
-    public static ChannelData getDataFromPackage(XByteBuffer xbuf)  {
-        ChannelData data = new ChannelData(false);
-        int offset = 0;
-        data.setOptions(XByteBuffer.toInt(xbuf.getBytesDirect(),offset));
-        offset += 4; //options
-        data.setTimestamp(XByteBuffer.toLong(xbuf.getBytesDirect(),offset));
-        offset += 8; //timestamp
-        data.uniqueId = new byte[XByteBuffer.toInt(xbuf.getBytesDirect(),offset)];
-        offset += 4; //uniqueId length
-        System.arraycopy(xbuf.getBytesDirect(),offset,data.uniqueId,0,data.uniqueId.length);
-        offset += data.uniqueId.length; //uniqueId data
-        byte[] addr = new byte[XByteBuffer.toInt(xbuf.getBytesDirect(),offset)];
-        offset += 4; //addr length
-        System.arraycopy(xbuf.getBytesDirect(),offset,addr,0,addr.length);
-        data.setAddress(MemberImpl.getMember(addr));
-        offset += addr.length; //addr data
-        int xsize = XByteBuffer.toInt(xbuf.getBytesDirect(),offset);
-        offset += 4; //xsize length
-        System.arraycopy(xbuf.getBytesDirect(),offset,xbuf.getBytesDirect(),0,xsize);
-        xbuf.setLength(xsize);
-        data.message = xbuf;
-        return data;
-
-    }
-
-    public static ChannelData getDataFromPackage(byte[] b)  {
-        ChannelData data = new ChannelData(false);
-        int offset = 0;
-        data.setOptions(XByteBuffer.toInt(b,offset));
-        offset += 4; //options
-        data.setTimestamp(XByteBuffer.toLong(b,offset));
-        offset += 8; //timestamp
-        data.uniqueId = new byte[XByteBuffer.toInt(b,offset)];
-        offset += 4; //uniqueId length
-        System.arraycopy(b,offset,data.uniqueId,0,data.uniqueId.length);
-        offset += data.uniqueId.length; //uniqueId data
-        byte[] addr = new byte[XByteBuffer.toInt(b,offset)];
-        offset += 4; //addr length
-        System.arraycopy(b,offset,addr,0,addr.length);
-        data.setAddress(MemberImpl.getMember(addr));
-        offset += addr.length; //addr data
-        int xsize = XByteBuffer.toInt(b,offset);
-        //data.message = new XByteBuffer(new byte[xsize],false);
-        data.message = BufferPool.getBufferPool().getBuffer(xsize,false);
-        offset += 4; //message length
-        System.arraycopy(b,offset,data.message.getBytesDirect(),0,xsize);
-        data.message.append(b,offset,xsize);
-        offset += xsize; //message data
-        return data;
-    }
-    
-    public int hashCode() {
-        return XByteBuffer.toInt(getUniqueId(),0);
-    }
-    
-    /**
-     * Compares to ChannelData objects, only compares on getUniqueId().equals(o.getUniqueId())
-     * @param o Object
-     * @return boolean
-     */
-    public boolean equals(Object o) {
-        if ( o instanceof ChannelData ) {
-            return Arrays.equals(getUniqueId(),((ChannelData)o).getUniqueId());
-        } else return false;
-    }
-    
-    /**
-     * Create a shallow clone, only the data gets recreated
-     * @return ClusterData
-     */
-    public Object clone() {
-//        byte[] d = this.getDataPackage();
-//        return ClusterData.getDataFromPackage(d);
-        ChannelData clone = new ChannelData(false);
-        clone.options = this.options;
-        clone.message = new XByteBuffer(this.message.getBytesDirect(),false);
-        clone.timestamp = this.timestamp;
-        clone.uniqueId = this.uniqueId;
-        clone.address = this.address;
-        return clone;
-    }
-    
-    /**
-     * Complete clone
-     * @return ClusterData
-     */
-    public Object deepclone() {
-        byte[] d = this.getDataPackage();
-        return ChannelData.getDataFromPackage(d);
-    }
-    
-    /**
-     * Utility method, returns true if the options flag indicates that an ack
-     * is to be sent after the message has been received and processed
-     * @param options int - the options for the message
-     * @return boolean 
-     * @see org.apache.catalina.tribes.Channel#SEND_OPTIONS_USE_ACK
-     * @see org.apache.catalina.tribes.Channel#SEND_OPTIONS_SYNCHRONIZED_ACK
-     */
-    public static boolean sendAckSync(int options) {
-        return ( (Channel.SEND_OPTIONS_USE_ACK & options) == Channel.SEND_OPTIONS_USE_ACK) &&
-            ( (Channel.SEND_OPTIONS_SYNCHRONIZED_ACK & options) == Channel.SEND_OPTIONS_SYNCHRONIZED_ACK);
-    }
-
-
-    /**
-     * Utility method, returns true if the options flag indicates that an ack
-     * is to be sent after the message has been received but not yet processed
-     * @param options int - the options for the message
-     * @return boolean 
-     * @see org.apache.catalina.tribes.Channel#SEND_OPTIONS_USE_ACK
-     * @see org.apache.catalina.tribes.Channel#SEND_OPTIONS_SYNCHRONIZED_ACK
-     */
-    public static boolean sendAckAsync(int options) {
-        return ( (Channel.SEND_OPTIONS_USE_ACK & options) == Channel.SEND_OPTIONS_USE_ACK) &&
-            ( (Channel.SEND_OPTIONS_SYNCHRONIZED_ACK & options) != Channel.SEND_OPTIONS_SYNCHRONIZED_ACK);
-    }
-    
-    public String toString() {
-        StringBuffer buf = new StringBuffer();
-        buf.append("ClusterData[src=");
-        buf.append(getAddress()).append("; id=");
-        buf.append(bToS(getUniqueId())).append("; sent=");
-        buf.append(new Timestamp(this.getTimestamp()).toString()).append("]");
-        return buf.toString();
-    }
-    
-    public static String bToS(byte[] data) {
-        StringBuffer buf = new StringBuffer(4*16);
-        buf.append("{");
-        for (int i=0; data!=null && i<data.length; i++ ) buf.append(String.valueOf(data[i])).append(" ");
-        buf.append("}");
-        return buf.toString();
-    }
-
-    
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.io;
+
+import java.util.Arrays;
+
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.membership.MemberImpl;
+import org.apache.catalina.tribes.util.UUIDGenerator;
+import org.apache.catalina.tribes.Channel;
+import java.sql.Timestamp;
+
+/**
+ * The <code>ChannelData</code> object is used to transfer a message through the 
+ * channel interceptor stack and eventually out on a transport to be sent 
+ * to another node. While the message is being processed by the different 
+ * interceptors, the message data can be manipulated as each interceptor seems appropriate.
+ * @author Peter Rossbach
+ * @author Filip Hanik
+ * @version $Revision: 377484 $ $Date: 2006-02-13 15:00:05 -0600 (Mon, 13 Feb 2006) $
+ * 
+ */
+public class ChannelData implements ChannelMessage {
+    public static ChannelData[] EMPTY_DATA_ARRAY = new ChannelData[0];
+    
+    public static boolean USE_SECURE_RANDOM_FOR_UUID = false;
+    
+    /**
+     * The options this message was sent with
+     */
+    private int options = 0 ;
+    /**
+     * The message data, stored in a dynamic buffer
+     */
+    private XByteBuffer message ;
+    /**
+     * The timestamp that goes with this message
+     */
+    private long timestamp ;
+    /**
+     * A unique message id
+     */
+    private byte[] uniqueId ;
+    /**
+     * The source or reply-to address for this message
+     */
+    private Member address;
+
+    /**
+     * Creates an empty channel data with a new unique Id
+     * @see #ChannelData(boolean)
+     */
+    public ChannelData() {
+        this(true);
+    }
+    
+    /**
+     * Create an empty channel data object
+     * @param generateUUID boolean - if true, a unique Id will be generated
+     */
+    public ChannelData(boolean generateUUID) {
+        if ( generateUUID ) generateUUID();
+    }
+    
+    
+    
+    /**
+     * Creates a new channel data object with data
+     * @param uniqueId - unique message id
+     * @param message - message data
+     * @param timestamp - message timestamp
+     */
+    public ChannelData(byte[] uniqueId, XByteBuffer message, long timestamp) {
+        this.uniqueId = uniqueId;
+        this.message = message;
+        this.timestamp = timestamp;
+    }
+    
+    /**
+     * @return Returns the message byte buffer
+     */
+    public XByteBuffer getMessage() {
+        return message;
+    }
+    /**
+     * @param message The message to send.
+     */
+    public void setMessage(XByteBuffer message) {
+        this.message = message;
+    }
+    /**
+     * @return Returns the timestamp.
+     */
+    public long getTimestamp() {
+        return timestamp;
+    }
+    /**
+     * @param timestamp The timestamp to send
+     */
+    public void setTimestamp(long timestamp) {
+        this.timestamp = timestamp;
+    }
+    /**
+     * @return Returns the uniqueId.
+     */
+    public byte[] getUniqueId() {
+        return uniqueId;
+    }
+    /**
+     * @param uniqueId The uniqueId to send.
+     */
+    public void setUniqueId(byte[] uniqueId) {
+        this.uniqueId = uniqueId;
+    }
+    /**
+     * @return returns the message options 
+     * see org.apache.catalina.tribes.Channel#sendMessage(org.apache.catalina.tribes.Member[], java.io.Serializable, int)
+     *                                                 
+     */
+    public int getOptions() {
+        return options;
+    }
+    /**
+     * @param sets the message options
+     */
+    public void setOptions(int options) {
+        this.options = options;
+    }
+    
+    /**
+     * Returns the source or reply-to address
+     * @return Member
+     */
+    public Member getAddress() {
+        return address;
+    }
+
+    /**
+     * Sets the source or reply-to address
+     * @param address Member
+     */
+    public void setAddress(Member address) {
+        this.address = address;
+    }
+    
+    /**
+     * Generates a UUID and invokes setUniqueId
+     */
+    public void generateUUID() {
+        byte[] data = new byte[16];
+        UUIDGenerator.randomUUID(USE_SECURE_RANDOM_FOR_UUID,data,0);
+        setUniqueId(data);
+    }
+
+    public int getDataPackageLength() {
+        int length = 
+            4 + //options
+            8 + //timestamp  off=4
+            4 + //unique id length off=12
+            uniqueId.length+ //id data off=12+uniqueId.length
+            4 + //addr length off=12+uniqueId.length+4
+            ((MemberImpl)address).getDataLength()+ //member data off=12+uniqueId.length+4+add.length
+            4 + //message length off=12+uniqueId.length+4+add.length+4
+            message.getLength();
+        return length;
+
+    }
+    
+    /**
+     * Serializes the ChannelData object into a byte[] array
+     * @return byte[]
+     */
+    public byte[] getDataPackage()  {
+        int length = getDataPackageLength();
+        byte[] data = new byte[length];
+        int offset = 0;
+        return getDataPackage(data,offset);
+    }
+
+    public byte[] getDataPackage(byte[] data, int offset)  {
+        byte[] addr = ((MemberImpl)address).getData(false);
+        XByteBuffer.toBytes(options,data,offset);
+        offset += 4; //options
+        XByteBuffer.toBytes(timestamp,data,offset);
+        offset += 8; //timestamp
+        XByteBuffer.toBytes(uniqueId.length,data,offset);
+        offset += 4; //uniqueId.length
+        System.arraycopy(uniqueId,0,data,offset,uniqueId.length);
+        offset += uniqueId.length; //uniqueId data
+        XByteBuffer.toBytes(addr.length,data,offset);
+        offset += 4; //addr.length
+        System.arraycopy(addr,0,data,offset,addr.length);
+        offset += addr.length; //addr data
+        XByteBuffer.toBytes(message.getLength(),data,offset);
+        offset += 4; //message.length
+        System.arraycopy(message.getBytesDirect(),0,data,offset,message.getLength());
+        offset += message.getLength(); //message data
+        return data;
+    }
+    
+    /**
+     * Deserializes a ChannelData object from a byte array
+     * @param b byte[]
+     * @return ChannelData
+     */
+    public static ChannelData getDataFromPackage(XByteBuffer xbuf)  {
+        ChannelData data = new ChannelData(false);
+        int offset = 0;
+        data.setOptions(XByteBuffer.toInt(xbuf.getBytesDirect(),offset));
+        offset += 4; //options
+        data.setTimestamp(XByteBuffer.toLong(xbuf.getBytesDirect(),offset));
+        offset += 8; //timestamp
+        data.uniqueId = new byte[XByteBuffer.toInt(xbuf.getBytesDirect(),offset)];
+        offset += 4; //uniqueId length
+        System.arraycopy(xbuf.getBytesDirect(),offset,data.uniqueId,0,data.uniqueId.length);
+        offset += data.uniqueId.length; //uniqueId data
+        byte[] addr = new byte[XByteBuffer.toInt(xbuf.getBytesDirect(),offset)];
+        offset += 4; //addr length
+        System.arraycopy(xbuf.getBytesDirect(),offset,addr,0,addr.length);
+        data.setAddress(MemberImpl.getMember(addr));
+        offset += addr.length; //addr data
+        int xsize = XByteBuffer.toInt(xbuf.getBytesDirect(),offset);
+        offset += 4; //xsize length
+        System.arraycopy(xbuf.getBytesDirect(),offset,xbuf.getBytesDirect(),0,xsize);
+        xbuf.setLength(xsize);
+        data.message = xbuf;
+        return data;
+
+    }
+
+    public static ChannelData getDataFromPackage(byte[] b)  {
+        ChannelData data = new ChannelData(false);
+        int offset = 0;
+        data.setOptions(XByteBuffer.toInt(b,offset));
+        offset += 4; //options
+        data.setTimestamp(XByteBuffer.toLong(b,offset));
+        offset += 8; //timestamp
+        data.uniqueId = new byte[XByteBuffer.toInt(b,offset)];
+        offset += 4; //uniqueId length
+        System.arraycopy(b,offset,data.uniqueId,0,data.uniqueId.length);
+        offset += data.uniqueId.length; //uniqueId data
+        byte[] addr = new byte[XByteBuffer.toInt(b,offset)];
+        offset += 4; //addr length
+        System.arraycopy(b,offset,addr,0,addr.length);
+        data.setAddress(MemberImpl.getMember(addr));
+        offset += addr.length; //addr data
+        int xsize = XByteBuffer.toInt(b,offset);
+        //data.message = new XByteBuffer(new byte[xsize],false);
+        data.message = BufferPool.getBufferPool().getBuffer(xsize,false);
+        offset += 4; //message length
+        System.arraycopy(b,offset,data.message.getBytesDirect(),0,xsize);
+        data.message.append(b,offset,xsize);
+        offset += xsize; //message data
+        return data;
+    }
+    
+    public int hashCode() {
+        return XByteBuffer.toInt(getUniqueId(),0);
+    }
+    
+    /**
+     * Compares to ChannelData objects, only compares on getUniqueId().equals(o.getUniqueId())
+     * @param o Object
+     * @return boolean
+     */
+    public boolean equals(Object o) {
+        if ( o instanceof ChannelData ) {
+            return Arrays.equals(getUniqueId(),((ChannelData)o).getUniqueId());
+        } else return false;
+    }
+    
+    /**
+     * Create a shallow clone, only the data gets recreated
+     * @return ClusterData
+     */
+    public Object clone() {
+//        byte[] d = this.getDataPackage();
+//        return ClusterData.getDataFromPackage(d);
+        ChannelData clone = new ChannelData(false);
+        clone.options = this.options;
+        clone.message = new XByteBuffer(this.message.getBytesDirect(),false);
+        clone.timestamp = this.timestamp;
+        clone.uniqueId = this.uniqueId;
+        clone.address = this.address;
+        return clone;
+    }
+    
+    /**
+     * Complete clone
+     * @return ClusterData
+     */
+    public Object deepclone() {
+        byte[] d = this.getDataPackage();
+        return ChannelData.getDataFromPackage(d);
+    }
+    
+    /**
+     * Utility method, returns true if the options flag indicates that an ack
+     * is to be sent after the message has been received and processed
+     * @param options int - the options for the message
+     * @return boolean 
+     * @see org.apache.catalina.tribes.Channel#SEND_OPTIONS_USE_ACK
+     * @see org.apache.catalina.tribes.Channel#SEND_OPTIONS_SYNCHRONIZED_ACK
+     */
+    public static boolean sendAckSync(int options) {
+        return ( (Channel.SEND_OPTIONS_USE_ACK & options) == Channel.SEND_OPTIONS_USE_ACK) &&
+            ( (Channel.SEND_OPTIONS_SYNCHRONIZED_ACK & options) == Channel.SEND_OPTIONS_SYNCHRONIZED_ACK);
+    }
+
+
+    /**
+     * Utility method, returns true if the options flag indicates that an ack
+     * is to be sent after the message has been received but not yet processed
+     * @param options int - the options for the message
+     * @return boolean 
+     * @see org.apache.catalina.tribes.Channel#SEND_OPTIONS_USE_ACK
+     * @see org.apache.catalina.tribes.Channel#SEND_OPTIONS_SYNCHRONIZED_ACK
+     */
+    public static boolean sendAckAsync(int options) {
+        return ( (Channel.SEND_OPTIONS_USE_ACK & options) == Channel.SEND_OPTIONS_USE_ACK) &&
+            ( (Channel.SEND_OPTIONS_SYNCHRONIZED_ACK & options) != Channel.SEND_OPTIONS_SYNCHRONIZED_ACK);
+    }
+    
+    public String toString() {
+        StringBuffer buf = new StringBuffer();
+        buf.append("ClusterData[src=");
+        buf.append(getAddress()).append("; id=");
+        buf.append(bToS(getUniqueId())).append("; sent=");
+        buf.append(new Timestamp(this.getTimestamp()).toString()).append("]");
+        return buf.toString();
+    }
+    
+    public static String bToS(byte[] data) {
+        StringBuffer buf = new StringBuffer(4*16);
+        buf.append("{");
+        for (int i=0; data!=null && i<data.length; i++ ) buf.append(String.valueOf(data[i])).append(" ");
+        buf.append("}");
+        return buf.toString();
+    }
+
+    
+}

==================================================
ListenCallback.java
index 946e084b8f..bf3ab37420 100644
--- a/java/org/apache/catalina/tribes/io/DirectByteArrayOutputStream.java
+++ b/java/org/apache/catalina/tribes/io/DirectByteArrayOutputStream.java
@@ -1,62 +1,63 @@
-/*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.io;
-
-import java.io.IOException;
-import java.io.OutputStream;
-
-/**
- * Byte array output stream that exposes the byte array directly
- *
- * @author not attributable
- * @version 1.0
- */
-public class DirectByteArrayOutputStream extends OutputStream {
-    
-    private XByteBuffer buffer;
-    
-    public DirectByteArrayOutputStream(int size) {
-        buffer = new XByteBuffer(size,false);
-    }
-
-    /**
-     * Writes the specified byte to this output stream.
-     *
-     * @param b the <code>byte</code>.
-     * @throws IOException if an I/O error occurs. In particular, an
-     *   <code>IOException</code> may be thrown if the output stream has
-     *   been closed.
-     * @todo Implement this java.io.OutputStream method
-     */
-    public void write(int b) throws IOException {
-        buffer.append((byte)b);
-    }
-    
-    public int size() {
-        return buffer.getLength();
-    }
-    
-    public byte[] getArrayDirect() {
-        return buffer.getBytesDirect();
-    }
-    
-    public byte[] getArray() {
-        return buffer.getBytes();
-    }
-
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.io;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * Byte array output stream that exposes the byte array directly
+ *
+ * @author not attributable
+ * @version 1.0
+ */
+public class DirectByteArrayOutputStream extends OutputStream {
+    
+    private XByteBuffer buffer;
+    
+    public DirectByteArrayOutputStream(int size) {
+        buffer = new XByteBuffer(size,false);
+    }
+
+    /**
+     * Writes the specified byte to this output stream.
+     *
+     * @param b the <code>byte</code>.
+     * @throws IOException if an I/O error occurs. In particular, an
+     *   <code>IOException</code> may be thrown if the output stream has
+     *   been closed.
+     * @todo Implement this java.io.OutputStream method
+     */
+    public void write(int b) throws IOException {
+        buffer.append((byte)b);
+    }
+    
+    public int size() {
+        return buffer.getLength();
+    }
+    
+    public byte[] getArrayDirect() {
+        return buffer.getBytesDirect();
+    }
+    
+    public byte[] getArray() {
+        return buffer.getBytes();
+    }
+
+
 }
\ No newline at end of file

==================================================
ObjectReader.java
index c0cc9a099c..3812ec2318 100644
--- a/java/org/apache/catalina/tribes/io/ListenCallback.java
+++ b/java/org/apache/catalina/tribes/io/ListenCallback.java
@@ -1,41 +1,42 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.io;
-
-import org.apache.catalina.tribes.ChannelMessage;
-
-
-
-/**
- * Internal interface, similar to the MessageListener but used 
- * at the IO base
- * The listen callback interface is used by the replication system
- * when data has been received. The interface does not care about
- * objects and marshalling and just passes the bytes straight through.
- * @author Filip Hanik
- * @version $Revision: 303987 $, $Date: 2005-07-08 15:50:30 -0500 (Fri, 08 Jul 2005) $
- */
-public interface ListenCallback
-{
-    /**
-     * This method is invoked on the callback object to notify it that new data has
-     * been received from one of the cluster nodes.
-     * @param data - the message bytes received from the cluster/replication system
-     */
-     public void messageDataReceived(ChannelMessage data);
-     
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.io;
+
+import org.apache.catalina.tribes.ChannelMessage;
+
+
+
+/**
+ * Internal interface, similar to the MessageListener but used 
+ * at the IO base
+ * The listen callback interface is used by the replication system
+ * when data has been received. The interface does not care about
+ * objects and marshalling and just passes the bytes straight through.
+ * @author Filip Hanik
+ * @version $Revision: 303987 $, $Date: 2005-07-08 15:50:30 -0500 (Fri, 08 Jul 2005) $
+ */
+public interface ListenCallback
+{
+    /**
+     * This method is invoked on the callback object to notify it that new data has
+     * been received from one of the cluster nodes.
+     * @param data - the message bytes received from the cluster/replication system
+     */
+     public void messageDataReceived(ChannelMessage data);
+     
 }
\ No newline at end of file

==================================================
ReplicationStream.java
index fd6dbc0603..62f337d288 100644
--- a/java/org/apache/catalina/tribes/io/ObjectReader.java
+++ b/java/org/apache/catalina/tribes/io/ObjectReader.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
XByteBuffer.java
index a08a27ac81..1827decc32 100644
--- a/java/org/apache/catalina/tribes/io/ReplicationStream.java
+++ b/java/org/apache/catalina/tribes/io/ReplicationStream.java
@@ -1,116 +1,117 @@
-/*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina.tribes.io;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.ObjectInputStream;
-import java.io.ObjectStreamClass;
-
-/**
- * Custom subclass of <code>ObjectInputStream</code> that loads from the
- * class loader for this web application.  This allows classes defined only
- * with the web application to be found correctly.
- *
- * @author Craig R. McClanahan
- * @author Bip Thelin
- * @author Filip Hanik
- * @version $Revision: 377484 $, $Date: 2006-02-13 15:00:05 -0600 (Mon, 13 Feb 2006) $
- */
-
-public final class ReplicationStream extends ObjectInputStream {
-
-    
-    /**
-     * The class loader we will use to resolve classes.
-     */
-    private ClassLoader[] classLoaders = null;
-    
-
-    /**
-     * Construct a new instance of CustomObjectInputStream
-     *
-     * @param stream The input stream we will read from
-     * @param classLoader The class loader used to instantiate objects
-     *
-     * @exception IOException if an input/output error occurs
-     */
-    public ReplicationStream(InputStream stream,
-                             ClassLoader[] classLoaders)
-        throws IOException {
-
-        super(stream);
-        this.classLoaders = classLoaders;
-    }
-
-    /**
-     * Load the local class equivalent of the specified stream class
-     * description, by using the class loader assigned to this Context.
-     *
-     * @param classDesc Class description from the input stream
-     *
-     * @exception ClassNotFoundException if this class cannot be found
-     * @exception IOException if an input/output error occurs
-     */
-    public Class resolveClass(ObjectStreamClass classDesc)
-        throws ClassNotFoundException, IOException {
-        String name = classDesc.getName();
-        boolean tryRepFirst = name.startsWith("org.apache.catalina.tribes");
-        try {
-            try
-            {
-                if ( tryRepFirst ) return findReplicationClass(name);
-                else return findExternalClass(name);
-            }
-            catch ( Exception x )
-            {
-                if ( tryRepFirst ) return findExternalClass(name);
-                else return findReplicationClass(name);
-            }
-        } catch (ClassNotFoundException e) {
-            return super.resolveClass(classDesc);
-        }
-    }
-    
-    public Class findReplicationClass(String name)
-        throws ClassNotFoundException, IOException {
-        Class clazz = Class.forName(name, false, getClass().getClassLoader());
-        return clazz;
-    }
-
-    public Class findExternalClass(String name) throws ClassNotFoundException  {
-        ClassNotFoundException cnfe = null;
-        for (int i=0; i<classLoaders.length; i++ ) {
-            try {
-                Class clazz = Class.forName(name, false, classLoaders[i]);
-                return clazz;
-            } catch ( ClassNotFoundException x ) {
-                cnfe = x;
-            } 
-        }
-        if ( cnfe != null ) throw cnfe;
-        else throw new ClassNotFoundException(name);
-    }
-    
-    public void close() throws IOException  {
-        this.classLoaders = null;
-        super.close();
-    }
-
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.catalina.tribes.io;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.ObjectInputStream;
+import java.io.ObjectStreamClass;
+
+/**
+ * Custom subclass of <code>ObjectInputStream</code> that loads from the
+ * class loader for this web application.  This allows classes defined only
+ * with the web application to be found correctly.
+ *
+ * @author Craig R. McClanahan
+ * @author Bip Thelin
+ * @author Filip Hanik
+ * @version $Revision: 377484 $, $Date: 2006-02-13 15:00:05 -0600 (Mon, 13 Feb 2006) $
+ */
+
+public final class ReplicationStream extends ObjectInputStream {
+
+    
+    /**
+     * The class loader we will use to resolve classes.
+     */
+    private ClassLoader[] classLoaders = null;
+    
+
+    /**
+     * Construct a new instance of CustomObjectInputStream
+     *
+     * @param stream The input stream we will read from
+     * @param classLoader The class loader used to instantiate objects
+     *
+     * @exception IOException if an input/output error occurs
+     */
+    public ReplicationStream(InputStream stream,
+                             ClassLoader[] classLoaders)
+        throws IOException {
+
+        super(stream);
+        this.classLoaders = classLoaders;
+    }
+
+    /**
+     * Load the local class equivalent of the specified stream class
+     * description, by using the class loader assigned to this Context.
+     *
+     * @param classDesc Class description from the input stream
+     *
+     * @exception ClassNotFoundException if this class cannot be found
+     * @exception IOException if an input/output error occurs
+     */
+    public Class resolveClass(ObjectStreamClass classDesc)
+        throws ClassNotFoundException, IOException {
+        String name = classDesc.getName();
+        boolean tryRepFirst = name.startsWith("org.apache.catalina.tribes");
+        try {
+            try
+            {
+                if ( tryRepFirst ) return findReplicationClass(name);
+                else return findExternalClass(name);
+            }
+            catch ( Exception x )
+            {
+                if ( tryRepFirst ) return findExternalClass(name);
+                else return findReplicationClass(name);
+            }
+        } catch (ClassNotFoundException e) {
+            return super.resolveClass(classDesc);
+        }
+    }
+    
+    public Class findReplicationClass(String name)
+        throws ClassNotFoundException, IOException {
+        Class clazz = Class.forName(name, false, getClass().getClassLoader());
+        return clazz;
+    }
+
+    public Class findExternalClass(String name) throws ClassNotFoundException  {
+        ClassNotFoundException cnfe = null;
+        for (int i=0; i<classLoaders.length; i++ ) {
+            try {
+                Class clazz = Class.forName(name, false, classLoaders[i]);
+                return clazz;
+            } catch ( ClassNotFoundException x ) {
+                cnfe = x;
+            } 
+        }
+        if ( cnfe != null ) throw cnfe;
+        else throw new ClassNotFoundException(name);
+    }
+    
+    public void close() throws IOException  {
+        this.classLoaders = null;
+        super.close();
+    }
+
+
+}

==================================================
Constants.java
index 0b493fa3f1..082d2fada6 100644
--- a/java/org/apache/catalina/tribes/io/XByteBuffer.java
+++ b/java/org/apache/catalina/tribes/io/XByteBuffer.java
@@ -1,611 +1,612 @@
-/*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.io;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.io.Serializable;
-import java.nio.ByteBuffer;
-
-/**
- * The XByteBuffer provides a dual functionality.
- * One, it stores message bytes and automatically extends the byte buffer if needed.<BR>
- * Two, it can encode and decode packages so that they can be defined and identified
- * as they come in on a socket.
- * <br>
- * <b>THIS CLASS IS NOT THREAD SAFE</B><BR>
- * <br/>
- * Transfer package:
- * <ul>
- * <li><b>START_DATA/b> - 7 bytes - <i>FLT2002</i></li>
- * <li><b>SIZE</b>      - 4 bytes - size of the data package</li>
- * <li><b>DATA</b>      - should be as many bytes as the prev SIZE</li>
- * <li><b>END_DATA</b>  - 7 bytes - <i>TLF2003</i></lI>
- * </ul>
- * @author Filip Hanik
- * @version $Revision: 377484 $, $Date: 2006-02-13 15:00:05 -0600 (Mon, 13 Feb 2006) $
- */
-public class XByteBuffer
-{
-    
-    public static org.apache.juli.logging.Log log =
-        org.apache.juli.logging.LogFactory.getLog( XByteBuffer.class );
-    
-    /**
-     * This is a package header, 7 bytes (FLT2002)
-     */
-    public static final byte[] START_DATA = {70,76,84,50,48,48,50};
-    
-    /**
-     * This is the package footer, 7 bytes (TLF2003)
-     */
-    public static final byte[] END_DATA = {84,76,70,50,48,48,51};
- 
-    /**
-     * Default size on the initial byte buffer
-     */
-    private static final int DEF_SIZE = 2048;
- 
-    /**
-     * Default size to extend the buffer with
-     */
-    private static final int DEF_EXT  = 1024;
-    
-    /**
-     * Variable to hold the data
-     */
-    protected byte[] buf = null;
-    
-    /**
-     * Current length of data in the buffer
-     */
-    protected int bufSize = 0;
-    
-    /**
-     * Flag for discarding invalid packages
-     * If this flag is set to true, and append(byte[],...) is called,
-     * the data added will be inspected, and if it doesn't start with 
-     * <code>START_DATA</code> it will be thrown away.
-     * 
-     */
-    protected boolean discard = true;
-    
-    /**
-     * Constructs a new XByteBuffer
-     * @param size - the initial size of the byte buffer
-     * @todo use a pool of byte[] for performance
-     */
-    public XByteBuffer(int size, boolean discard) {
-        buf = new byte[size];
-        this.discard = discard;
-    }
-    
-    public XByteBuffer(byte[] data,boolean discard) {
-        this(data,data.length+128,discard);
-    }
-    
-    public XByteBuffer(byte[] data, int size,boolean discard) {
-        int length = Math.max(data.length,size);
-        buf = new byte[length];
-        System.arraycopy(data,0,buf,0,data.length);
-        bufSize = data.length;
-        this.discard = discard;
-    }
-    
-    public int getLength() {
-        return bufSize;
-    }
-
-    public void setLength(int size) {
-        if ( size > buf.length ) throw new ArrayIndexOutOfBoundsException("Size is larger than existing buffer.");
-        bufSize = size;
-    }
-    
-    public void trim(int length) {
-        if ( (bufSize - length) < 0 ) 
-            throw new ArrayIndexOutOfBoundsException("Can't trim more bytes than are available. length:"+bufSize+" trim:"+length);
-        bufSize -= length;
-    }
-    
-    public void reset() {
-        bufSize = 0;
-    }
-            
-    public byte[] getBytesDirect() {
-        return this.buf;
-    }
-
-    /**
-     * Returns the bytes in the buffer, in its exact length
-     */
-    public byte[] getBytes() {
-        byte[] b = new byte[bufSize];
-        System.arraycopy(buf,0,b,0,bufSize);
-        return b;
-    }
-
-    /**
-     * Resets the buffer
-     */
-    public void clear() {
-        bufSize = 0;
-    }
-
-    /**
-     * Appends the data to the buffer. If the data is incorrectly formatted, ie, the data should always start with the
-     * header, false will be returned and the data will be discarded.
-     * @param b - bytes to be appended
-     * @param off - the offset to extract data from
-     * @param len - the number of bytes to append.
-     * @return true if the data was appended correctly. Returns false if the package is incorrect, ie missing header or something, or the length of data is 0
-     */
-    public boolean append(ByteBuffer b, int len) {
-        int newcount = bufSize + len;
-        if (newcount > buf.length) {
-            expand(newcount);
-        }
-        b.get(buf,bufSize,len);
-        
-        bufSize = newcount;
-        
-        if ( discard ) {
-            if (bufSize > START_DATA.length && (firstIndexOf(buf, 0, START_DATA) == -1)) {
-                bufSize = 0;
-                log.error("Discarded the package, invalid header");
-                return false;
-            }
-        }
-        return true;
-
-    }
-    
-    public boolean append(byte i) {
-        int newcount = bufSize + 1;
-        if (newcount > buf.length) {
-            expand(newcount);
-        }
-        buf[bufSize] = i;
-        bufSize = newcount;
-        return true;
-    }
-
-
-    public boolean append(boolean i) {
-        int newcount = bufSize + 1;
-        if (newcount > buf.length) {
-            expand(newcount);
-        }
-        XByteBuffer.toBytes(i,buf,bufSize);
-        bufSize = newcount;
-        return true;
-    }
-
-    public boolean append(long i) {
-        int newcount = bufSize + 8;
-        if (newcount > buf.length) {
-            expand(newcount);
-        }
-        XByteBuffer.toBytes(i,buf,bufSize);
-        bufSize = newcount;
-        return true;
-    }
-    
-    public boolean append(int i) {
-        int newcount = bufSize + 4;
-        if (newcount > buf.length) {
-            expand(newcount);
-        }
-        XByteBuffer.toBytes(i,buf,bufSize);
-        bufSize = newcount;
-        return true;
-    }
-
-    public boolean append(byte[] b, int off, int len) {
-        if ((off < 0) || (off > b.length) || (len < 0) ||
-            ((off + len) > b.length) || ((off + len) < 0))  {
-            throw new IndexOutOfBoundsException();
-        } else if (len == 0) {
-            return false;
-        }
-
-        int newcount = bufSize + len;
-        if (newcount > buf.length) {
-            expand(newcount);
-        }
-        System.arraycopy(b, off, buf, bufSize, len);
-        bufSize = newcount;
-
-        if ( discard ) {
-            if (bufSize > START_DATA.length && (firstIndexOf(buf, 0, START_DATA) == -1)) {
-                bufSize = 0;
-                log.error("Discarded the package, invalid header");
-                return false;
-            }
-        }
-        return true;
-    }
-
-    public void expand(int newcount) {
-        //don't change the allocation strategy
-        byte newbuf[] = new byte[Math.max(buf.length << 1, newcount)];
-        System.arraycopy(buf, 0, newbuf, 0, bufSize);
-        buf = newbuf;
-    }
-    
-    public int getCapacity() {
-        return buf.length;
-    }
-
-
-    /**
-     * Internal mechanism to make a check if a complete package exists
-     * within the buffer
-     * @return - true if a complete package (header,compress,size,data,footer) exists within the buffer
-     */
-    public int countPackages() {
-        return countPackages(false);
-    }
-
-    public int countPackages(boolean first)
-    {
-        int cnt = 0;
-        int pos = START_DATA.length;
-        int start = 0;
-
-        while ( start < bufSize ) {
-            //first check start header
-            int index = XByteBuffer.firstIndexOf(buf,start,START_DATA);
-            //if the header (START_DATA) isn't the first thing or
-            //the buffer isn't even 14 bytes
-            if ( index != start || ((bufSize-start)<14) ) break;
-            //next 4 bytes are compress flag not needed for count packages
-            //then get the size 4 bytes
-            int size = toInt(buf, pos);
-            //now the total buffer has to be long enough to hold
-            //START_DATA.length+4+size+END_DATA.length
-            pos = start + START_DATA.length + 4 + size;
-            if ( (pos + END_DATA.length) > bufSize) break;
-            //and finally check the footer of the package END_DATA
-            int newpos = firstIndexOf(buf, pos, END_DATA);
-            //mismatch, there is no package
-            if (newpos != pos) break;
-            //increase the packet count
-            cnt++;
-            //reset the values
-            start = pos + END_DATA.length;
-            pos = start + START_DATA.length;
-            //we only want to verify that we have at least one package
-            if ( first ) break;
-        }
-        return cnt;
-    }
-
-    /**
-     * Method to check if a package exists in this byte buffer.
-     * @return - true if a complete package (header,options,size,data,footer) exists within the buffer
-     */
-    public boolean doesPackageExist()  {
-        return (countPackages(true)>0);
-    }
-
-    /**
-     * Extracts the message bytes from a package.
-     * If no package exists, a IllegalStateException will be thrown.
-     * @param clearFromBuffer - if true, the package will be removed from the byte buffer
-     * @return - returns the actual message bytes (header, compress,size and footer not included).
-     */
-    public XByteBuffer extractDataPackage(boolean clearFromBuffer) {
-        int psize = countPackages(true);
-        if (psize == 0) {
-            throw new java.lang.IllegalStateException("No package exists in XByteBuffer");
-        }
-        int size = toInt(buf, START_DATA.length);
-        XByteBuffer xbuf = BufferPool.getBufferPool().getBuffer(size,false);
-        xbuf.setLength(size);
-        System.arraycopy(buf, START_DATA.length + 4, xbuf.getBytesDirect(), 0, size);
-        if (clearFromBuffer) {
-            int totalsize = START_DATA.length + 4 + size + END_DATA.length;
-            bufSize = bufSize - totalsize;
-            System.arraycopy(buf, totalsize, buf, 0, bufSize);
-        }
-        return xbuf;
-
-    }
-    
-    public ChannelData extractPackage(boolean clearFromBuffer) throws java.io.IOException {
-        XByteBuffer xbuf = extractDataPackage(clearFromBuffer);
-        ChannelData cdata = ChannelData.getDataFromPackage(xbuf);
-        return cdata;
-    }
-    
-    /**
-     * Creates a complete data package
-     * @param indata - the message data to be contained within the package
-     * @param compressed - compression flag for the indata buffer
-     * @return - a full package (header,size,data,footer)
-     * 
-     */
-    public static byte[] createDataPackage(ChannelData cdata) {
-//        return createDataPackage(cdata.getDataPackage());
-        //avoid one extra byte array creation
-        int dlength = cdata.getDataPackageLength();
-        int length = getDataPackageLength(dlength);
-        byte[] data = new byte[length];
-        int offset = 0;
-        System.arraycopy(START_DATA, 0, data, offset, START_DATA.length);
-        offset += START_DATA.length;
-        toBytes(dlength,data, START_DATA.length);
-        offset += 4;
-        cdata.getDataPackage(data,offset);
-        offset += dlength;
-        System.arraycopy(END_DATA, 0, data, offset, END_DATA.length);
-        offset += END_DATA.length;
-        return data;
-    }
-    
-    public static byte[] createDataPackage(byte[] data, int doff, int dlength, byte[] buffer, int bufoff) {
-        if ( (buffer.length-bufoff) > getDataPackageLength(dlength) ) {
-            throw new ArrayIndexOutOfBoundsException("Unable to create data package, buffer is too small.");
-        }
-        System.arraycopy(START_DATA, 0, buffer, bufoff, START_DATA.length);
-        toBytes(data.length,buffer, bufoff+START_DATA.length);
-        System.arraycopy(data, doff, buffer, bufoff+START_DATA.length + 4, dlength);
-        System.arraycopy(END_DATA, 0, buffer, bufoff+START_DATA.length + 4 + data.length, END_DATA.length);
-        return buffer;
-    }
-
-    
-    public static int getDataPackageLength(int datalength) {
-        int length = 
-            START_DATA.length + //header length
-            4 + //data length indicator
-            datalength + //actual data length
-            END_DATA.length; //footer length
-        return length;
-
-    }
-    
-    public static byte[] createDataPackage(byte[] data) {
-        int length = getDataPackageLength(data.length);
-        byte[] result = new byte[length];
-        return createDataPackage(data,0,data.length,result,0);
-    }
-    
-    
-
-//    public static void fillDataPackage(byte[] data, int doff, int dlength, XByteBuffer buf) {
-//        int pkglen = getDataPackageLength(dlength);
-//        if ( buf.getCapacity() <  pkglen ) buf.expand(pkglen);
-//        createDataPackage(data,doff,dlength,buf.getBytesDirect(),buf.getLength());
-//    }
-
-    /**
-     * Convert four bytes to an int
-     * @param b - the byte array containing the four bytes
-     * @param off - the offset
-     * @return the integer value constructed from the four bytes
-     * @exception java.lang.ArrayIndexOutOfBoundsException
-     */
-    public static int toInt(byte[] b,int off){
-        return ( ( (int) b[off+3]) & 0xFF) +
-            ( ( ( (int) b[off+2]) & 0xFF) << 8) +
-            ( ( ( (int) b[off+1]) & 0xFF) << 16) +
-            ( ( ( (int) b[off+0]) & 0xFF) << 24);
-    }
-
-    /**
-     * Convert eight bytes to a long
-     * @param b - the byte array containing the four bytes
-     * @param off - the offset
-     * @return the long value constructed from the eight bytes
-     * @exception java.lang.ArrayIndexOutOfBoundsException
-     */
-    public static long toLong(byte[] b,int off){
-        return ( ( (long) b[off+7]) & 0xFF) +
-            ( ( ( (long) b[off+6]) & 0xFF) << 8) +
-            ( ( ( (long) b[off+5]) & 0xFF) << 16) +
-            ( ( ( (long) b[off+4]) & 0xFF) << 24) +
-            ( ( ( (long) b[off+3]) & 0xFF) << 32) +
-            ( ( ( (long) b[off+2]) & 0xFF) << 40) +
-            ( ( ( (long) b[off+1]) & 0xFF) << 48) +
-            ( ( ( (long) b[off+0]) & 0xFF) << 56);
-    }
-
-    
-    /**
-     * Converts an integer to four bytes
-     * @param n - the integer
-     * @return - four bytes in an array
-     * @deprecated use toBytes(boolean,byte[],int)
-     */
-    public static byte[] toBytes(boolean bool) {
-        byte[] b = new byte[1] ;
-        return toBytes(bool,b,0);
-
-    }
-    
-    public static byte[] toBytes(boolean bool, byte[] data, int offset) {
-        data[offset] = (byte)(bool?1:0);
-        return data;
-    }
-    
-    /**
-     * 
-     * @param <any> long
-     * @return use
-     */
-    public static boolean toBoolean(byte[] b, int offset) {
-        return b[offset] != 0;
-    }
-
-    
-    /**
-     * Converts an integer to four bytes
-     * @param n - the integer
-     * @return - four bytes in an array
-     * @deprecated use toBytes(int,byte[],int)
-     */
-    public static byte[] toBytes(int n) {
-        return toBytes(n,new byte[4],0);
-    }
-
-    public static byte[] toBytes(int n,byte[] b, int offset) {
-        b[offset+3] = (byte) (n);
-        n >>>= 8;
-        b[offset+2] = (byte) (n);
-        n >>>= 8;
-        b[offset+1] = (byte) (n);
-        n >>>= 8;
-        b[offset+0] = (byte) (n);
-        return b;
-    }
-
-    /**
-     * Converts an long to eight bytes
-     * @param n - the long
-     * @return - eight bytes in an array
-     * @deprecated use toBytes(long,byte[],int)
-     */
-    public static byte[] toBytes(long n) {
-        return toBytes(n,new byte[8],0);
-    }
-    public static byte[] toBytes(long n, byte[] b, int offset) {
-        b[offset+7] = (byte) (n);
-        n >>>= 8;
-        b[offset+6] = (byte) (n);
-        n >>>= 8;
-        b[offset+5] = (byte) (n);
-        n >>>= 8;
-        b[offset+4] = (byte) (n);
-        n >>>= 8;
-        b[offset+3] = (byte) (n);
-        n >>>= 8;
-        b[offset+2] = (byte) (n);
-        n >>>= 8;
-        b[offset+1] = (byte) (n);
-        n >>>= 8;
-        b[offset+0] = (byte) (n);
-        return b;
-    }
-
-    /**
-     * Similar to a String.IndexOf, but uses pure bytes
-     * @param src - the source bytes to be searched
-     * @param srcOff - offset on the source buffer
-     * @param find - the string to be found within src
-     * @return - the index of the first matching byte. -1 if the find array is not found
-     */
-    public static int firstIndexOf(byte[] src, int srcOff, byte[] find){
-        int result = -1;
-        if (find.length > src.length) return result;
-        if (find.length == 0 || src.length == 0) return result;
-        if (srcOff >= src.length ) throw new java.lang.ArrayIndexOutOfBoundsException();
-        boolean found = false;
-        int srclen = src.length;
-        int findlen = find.length;
-        byte first = find[0];
-        int pos = srcOff;
-        while (!found) {
-            //find the first byte
-            while (pos < srclen){
-                if (first == src[pos])
-                    break;
-                pos++;
-            }
-            if (pos >= srclen)
-                return -1;
-
-            //we found the first character
-            //match the rest of the bytes - they have to match
-            if ( (srclen - pos) < findlen)
-                return -1;
-            //assume it does exist
-            found = true;
-            for (int i = 1; ( (i < findlen) && found); i++)
-                found = found && (find[i] == src[pos + i]);
-            if (found)
-                result = pos;
-            else if ( (srclen - pos) < findlen)
-                return -1; //no more matches possible
-            else
-                pos++;
-        }
-        return result;
-    }
-
-    
-    public static Serializable deserialize(byte[] data) 
-        throws IOException, ClassNotFoundException, ClassCastException {
-        return deserialize(data,0,data.length);
-    }
-    
-    public static Serializable deserialize(byte[] data, int offset, int length)  
-        throws IOException, ClassNotFoundException, ClassCastException {
-        return deserialize(data,offset,length,null);     
-    }
-    public static int invokecount = 0;
-    public static Serializable deserialize(byte[] data, int offset, int length, ClassLoader[] cls) 
-        throws IOException, ClassNotFoundException, ClassCastException {
-        synchronized (XByteBuffer.class) { invokecount++;}
-        Object message = null;
-        if ( cls == null ) cls = new ClassLoader[0];
-        if (data != null) {
-            InputStream  instream = new ByteArrayInputStream(data,offset,length);
-            ObjectInputStream stream = null;
-            stream = (cls.length>0)? new ReplicationStream(instream,cls):new ObjectInputStream(instream);
-            message = stream.readObject();
-            instream.close();
-            stream.close();
-        }
-        if ( message == null ) {
-            return null;
-        } else if (message instanceof Serializable)
-            return (Serializable) message;
-        else {
-            throw new ClassCastException("Message has the wrong class. It should implement Serializable, instead it is:"+message.getClass().getName());
-        }
-    }
-
-    /**
-     * Serializes a message into cluster data
-     * @param msg ClusterMessage
-     * @param compress boolean
-     * @return 
-     * @throws IOException
-     */
-    public static byte[] serialize(Serializable msg) throws IOException {
-        ByteArrayOutputStream outs = new ByteArrayOutputStream();
-        ObjectOutputStream out = new ObjectOutputStream(outs);
-        out.writeObject(msg);
-        out.flush();
-        byte[] data = outs.toByteArray();
-        return data;
-    }
-
-    public void setDiscard(boolean discard) {
-        this.discard = discard;
-    }
-
-    public boolean getDiscard() {
-        return discard;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.io;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.Serializable;
+import java.nio.ByteBuffer;
+
+/**
+ * The XByteBuffer provides a dual functionality.
+ * One, it stores message bytes and automatically extends the byte buffer if needed.<BR>
+ * Two, it can encode and decode packages so that they can be defined and identified
+ * as they come in on a socket.
+ * <br>
+ * <b>THIS CLASS IS NOT THREAD SAFE</B><BR>
+ * <br/>
+ * Transfer package:
+ * <ul>
+ * <li><b>START_DATA/b> - 7 bytes - <i>FLT2002</i></li>
+ * <li><b>SIZE</b>      - 4 bytes - size of the data package</li>
+ * <li><b>DATA</b>      - should be as many bytes as the prev SIZE</li>
+ * <li><b>END_DATA</b>  - 7 bytes - <i>TLF2003</i></lI>
+ * </ul>
+ * @author Filip Hanik
+ * @version $Revision: 377484 $, $Date: 2006-02-13 15:00:05 -0600 (Mon, 13 Feb 2006) $
+ */
+public class XByteBuffer
+{
+    
+    public static org.apache.juli.logging.Log log =
+        org.apache.juli.logging.LogFactory.getLog( XByteBuffer.class );
+    
+    /**
+     * This is a package header, 7 bytes (FLT2002)
+     */
+    public static final byte[] START_DATA = {70,76,84,50,48,48,50};
+    
+    /**
+     * This is the package footer, 7 bytes (TLF2003)
+     */
+    public static final byte[] END_DATA = {84,76,70,50,48,48,51};
+ 
+    /**
+     * Default size on the initial byte buffer
+     */
+    private static final int DEF_SIZE = 2048;
+ 
+    /**
+     * Default size to extend the buffer with
+     */
+    private static final int DEF_EXT  = 1024;
+    
+    /**
+     * Variable to hold the data
+     */
+    protected byte[] buf = null;
+    
+    /**
+     * Current length of data in the buffer
+     */
+    protected int bufSize = 0;
+    
+    /**
+     * Flag for discarding invalid packages
+     * If this flag is set to true, and append(byte[],...) is called,
+     * the data added will be inspected, and if it doesn't start with 
+     * <code>START_DATA</code> it will be thrown away.
+     * 
+     */
+    protected boolean discard = true;
+    
+    /**
+     * Constructs a new XByteBuffer
+     * @param size - the initial size of the byte buffer
+     * @todo use a pool of byte[] for performance
+     */
+    public XByteBuffer(int size, boolean discard) {
+        buf = new byte[size];
+        this.discard = discard;
+    }
+    
+    public XByteBuffer(byte[] data,boolean discard) {
+        this(data,data.length+128,discard);
+    }
+    
+    public XByteBuffer(byte[] data, int size,boolean discard) {
+        int length = Math.max(data.length,size);
+        buf = new byte[length];
+        System.arraycopy(data,0,buf,0,data.length);
+        bufSize = data.length;
+        this.discard = discard;
+    }
+    
+    public int getLength() {
+        return bufSize;
+    }
+
+    public void setLength(int size) {
+        if ( size > buf.length ) throw new ArrayIndexOutOfBoundsException("Size is larger than existing buffer.");
+        bufSize = size;
+    }
+    
+    public void trim(int length) {
+        if ( (bufSize - length) < 0 ) 
+            throw new ArrayIndexOutOfBoundsException("Can't trim more bytes than are available. length:"+bufSize+" trim:"+length);
+        bufSize -= length;
+    }
+    
+    public void reset() {
+        bufSize = 0;
+    }
+            
+    public byte[] getBytesDirect() {
+        return this.buf;
+    }
+
+    /**
+     * Returns the bytes in the buffer, in its exact length
+     */
+    public byte[] getBytes() {
+        byte[] b = new byte[bufSize];
+        System.arraycopy(buf,0,b,0,bufSize);
+        return b;
+    }
+
+    /**
+     * Resets the buffer
+     */
+    public void clear() {
+        bufSize = 0;
+    }
+
+    /**
+     * Appends the data to the buffer. If the data is incorrectly formatted, ie, the data should always start with the
+     * header, false will be returned and the data will be discarded.
+     * @param b - bytes to be appended
+     * @param off - the offset to extract data from
+     * @param len - the number of bytes to append.
+     * @return true if the data was appended correctly. Returns false if the package is incorrect, ie missing header or something, or the length of data is 0
+     */
+    public boolean append(ByteBuffer b, int len) {
+        int newcount = bufSize + len;
+        if (newcount > buf.length) {
+            expand(newcount);
+        }
+        b.get(buf,bufSize,len);
+        
+        bufSize = newcount;
+        
+        if ( discard ) {
+            if (bufSize > START_DATA.length && (firstIndexOf(buf, 0, START_DATA) == -1)) {
+                bufSize = 0;
+                log.error("Discarded the package, invalid header");
+                return false;
+            }
+        }
+        return true;
+
+    }
+    
+    public boolean append(byte i) {
+        int newcount = bufSize + 1;
+        if (newcount > buf.length) {
+            expand(newcount);
+        }
+        buf[bufSize] = i;
+        bufSize = newcount;
+        return true;
+    }
+
+
+    public boolean append(boolean i) {
+        int newcount = bufSize + 1;
+        if (newcount > buf.length) {
+            expand(newcount);
+        }
+        XByteBuffer.toBytes(i,buf,bufSize);
+        bufSize = newcount;
+        return true;
+    }
+
+    public boolean append(long i) {
+        int newcount = bufSize + 8;
+        if (newcount > buf.length) {
+            expand(newcount);
+        }
+        XByteBuffer.toBytes(i,buf,bufSize);
+        bufSize = newcount;
+        return true;
+    }
+    
+    public boolean append(int i) {
+        int newcount = bufSize + 4;
+        if (newcount > buf.length) {
+            expand(newcount);
+        }
+        XByteBuffer.toBytes(i,buf,bufSize);
+        bufSize = newcount;
+        return true;
+    }
+
+    public boolean append(byte[] b, int off, int len) {
+        if ((off < 0) || (off > b.length) || (len < 0) ||
+            ((off + len) > b.length) || ((off + len) < 0))  {
+            throw new IndexOutOfBoundsException();
+        } else if (len == 0) {
+            return false;
+        }
+
+        int newcount = bufSize + len;
+        if (newcount > buf.length) {
+            expand(newcount);
+        }
+        System.arraycopy(b, off, buf, bufSize, len);
+        bufSize = newcount;
+
+        if ( discard ) {
+            if (bufSize > START_DATA.length && (firstIndexOf(buf, 0, START_DATA) == -1)) {
+                bufSize = 0;
+                log.error("Discarded the package, invalid header");
+                return false;
+            }
+        }
+        return true;
+    }
+
+    public void expand(int newcount) {
+        //don't change the allocation strategy
+        byte newbuf[] = new byte[Math.max(buf.length << 1, newcount)];
+        System.arraycopy(buf, 0, newbuf, 0, bufSize);
+        buf = newbuf;
+    }
+    
+    public int getCapacity() {
+        return buf.length;
+    }
+
+
+    /**
+     * Internal mechanism to make a check if a complete package exists
+     * within the buffer
+     * @return - true if a complete package (header,compress,size,data,footer) exists within the buffer
+     */
+    public int countPackages() {
+        return countPackages(false);
+    }
+
+    public int countPackages(boolean first)
+    {
+        int cnt = 0;
+        int pos = START_DATA.length;
+        int start = 0;
+
+        while ( start < bufSize ) {
+            //first check start header
+            int index = XByteBuffer.firstIndexOf(buf,start,START_DATA);
+            //if the header (START_DATA) isn't the first thing or
+            //the buffer isn't even 14 bytes
+            if ( index != start || ((bufSize-start)<14) ) break;
+            //next 4 bytes are compress flag not needed for count packages
+            //then get the size 4 bytes
+            int size = toInt(buf, pos);
+            //now the total buffer has to be long enough to hold
+            //START_DATA.length+4+size+END_DATA.length
+            pos = start + START_DATA.length + 4 + size;
+            if ( (pos + END_DATA.length) > bufSize) break;
+            //and finally check the footer of the package END_DATA
+            int newpos = firstIndexOf(buf, pos, END_DATA);
+            //mismatch, there is no package
+            if (newpos != pos) break;
+            //increase the packet count
+            cnt++;
+            //reset the values
+            start = pos + END_DATA.length;
+            pos = start + START_DATA.length;
+            //we only want to verify that we have at least one package
+            if ( first ) break;
+        }
+        return cnt;
+    }
+
+    /**
+     * Method to check if a package exists in this byte buffer.
+     * @return - true if a complete package (header,options,size,data,footer) exists within the buffer
+     */
+    public boolean doesPackageExist()  {
+        return (countPackages(true)>0);
+    }
+
+    /**
+     * Extracts the message bytes from a package.
+     * If no package exists, a IllegalStateException will be thrown.
+     * @param clearFromBuffer - if true, the package will be removed from the byte buffer
+     * @return - returns the actual message bytes (header, compress,size and footer not included).
+     */
+    public XByteBuffer extractDataPackage(boolean clearFromBuffer) {
+        int psize = countPackages(true);
+        if (psize == 0) {
+            throw new java.lang.IllegalStateException("No package exists in XByteBuffer");
+        }
+        int size = toInt(buf, START_DATA.length);
+        XByteBuffer xbuf = BufferPool.getBufferPool().getBuffer(size,false);
+        xbuf.setLength(size);
+        System.arraycopy(buf, START_DATA.length + 4, xbuf.getBytesDirect(), 0, size);
+        if (clearFromBuffer) {
+            int totalsize = START_DATA.length + 4 + size + END_DATA.length;
+            bufSize = bufSize - totalsize;
+            System.arraycopy(buf, totalsize, buf, 0, bufSize);
+        }
+        return xbuf;
+
+    }
+    
+    public ChannelData extractPackage(boolean clearFromBuffer) throws java.io.IOException {
+        XByteBuffer xbuf = extractDataPackage(clearFromBuffer);
+        ChannelData cdata = ChannelData.getDataFromPackage(xbuf);
+        return cdata;
+    }
+    
+    /**
+     * Creates a complete data package
+     * @param indata - the message data to be contained within the package
+     * @param compressed - compression flag for the indata buffer
+     * @return - a full package (header,size,data,footer)
+     * 
+     */
+    public static byte[] createDataPackage(ChannelData cdata) {
+//        return createDataPackage(cdata.getDataPackage());
+        //avoid one extra byte array creation
+        int dlength = cdata.getDataPackageLength();
+        int length = getDataPackageLength(dlength);
+        byte[] data = new byte[length];
+        int offset = 0;
+        System.arraycopy(START_DATA, 0, data, offset, START_DATA.length);
+        offset += START_DATA.length;
+        toBytes(dlength,data, START_DATA.length);
+        offset += 4;
+        cdata.getDataPackage(data,offset);
+        offset += dlength;
+        System.arraycopy(END_DATA, 0, data, offset, END_DATA.length);
+        offset += END_DATA.length;
+        return data;
+    }
+    
+    public static byte[] createDataPackage(byte[] data, int doff, int dlength, byte[] buffer, int bufoff) {
+        if ( (buffer.length-bufoff) > getDataPackageLength(dlength) ) {
+            throw new ArrayIndexOutOfBoundsException("Unable to create data package, buffer is too small.");
+        }
+        System.arraycopy(START_DATA, 0, buffer, bufoff, START_DATA.length);
+        toBytes(data.length,buffer, bufoff+START_DATA.length);
+        System.arraycopy(data, doff, buffer, bufoff+START_DATA.length + 4, dlength);
+        System.arraycopy(END_DATA, 0, buffer, bufoff+START_DATA.length + 4 + data.length, END_DATA.length);
+        return buffer;
+    }
+
+    
+    public static int getDataPackageLength(int datalength) {
+        int length = 
+            START_DATA.length + //header length
+            4 + //data length indicator
+            datalength + //actual data length
+            END_DATA.length; //footer length
+        return length;
+
+    }
+    
+    public static byte[] createDataPackage(byte[] data) {
+        int length = getDataPackageLength(data.length);
+        byte[] result = new byte[length];
+        return createDataPackage(data,0,data.length,result,0);
+    }
+    
+    
+
+//    public static void fillDataPackage(byte[] data, int doff, int dlength, XByteBuffer buf) {
+//        int pkglen = getDataPackageLength(dlength);
+//        if ( buf.getCapacity() <  pkglen ) buf.expand(pkglen);
+//        createDataPackage(data,doff,dlength,buf.getBytesDirect(),buf.getLength());
+//    }
+
+    /**
+     * Convert four bytes to an int
+     * @param b - the byte array containing the four bytes
+     * @param off - the offset
+     * @return the integer value constructed from the four bytes
+     * @exception java.lang.ArrayIndexOutOfBoundsException
+     */
+    public static int toInt(byte[] b,int off){
+        return ( ( (int) b[off+3]) & 0xFF) +
+            ( ( ( (int) b[off+2]) & 0xFF) << 8) +
+            ( ( ( (int) b[off+1]) & 0xFF) << 16) +
+            ( ( ( (int) b[off+0]) & 0xFF) << 24);
+    }
+
+    /**
+     * Convert eight bytes to a long
+     * @param b - the byte array containing the four bytes
+     * @param off - the offset
+     * @return the long value constructed from the eight bytes
+     * @exception java.lang.ArrayIndexOutOfBoundsException
+     */
+    public static long toLong(byte[] b,int off){
+        return ( ( (long) b[off+7]) & 0xFF) +
+            ( ( ( (long) b[off+6]) & 0xFF) << 8) +
+            ( ( ( (long) b[off+5]) & 0xFF) << 16) +
+            ( ( ( (long) b[off+4]) & 0xFF) << 24) +
+            ( ( ( (long) b[off+3]) & 0xFF) << 32) +
+            ( ( ( (long) b[off+2]) & 0xFF) << 40) +
+            ( ( ( (long) b[off+1]) & 0xFF) << 48) +
+            ( ( ( (long) b[off+0]) & 0xFF) << 56);
+    }
+
+    
+    /**
+     * Converts an integer to four bytes
+     * @param n - the integer
+     * @return - four bytes in an array
+     * @deprecated use toBytes(boolean,byte[],int)
+     */
+    public static byte[] toBytes(boolean bool) {
+        byte[] b = new byte[1] ;
+        return toBytes(bool,b,0);
+
+    }
+    
+    public static byte[] toBytes(boolean bool, byte[] data, int offset) {
+        data[offset] = (byte)(bool?1:0);
+        return data;
+    }
+    
+    /**
+     * 
+     * @param <any> long
+     * @return use
+     */
+    public static boolean toBoolean(byte[] b, int offset) {
+        return b[offset] != 0;
+    }
+
+    
+    /**
+     * Converts an integer to four bytes
+     * @param n - the integer
+     * @return - four bytes in an array
+     * @deprecated use toBytes(int,byte[],int)
+     */
+    public static byte[] toBytes(int n) {
+        return toBytes(n,new byte[4],0);
+    }
+
+    public static byte[] toBytes(int n,byte[] b, int offset) {
+        b[offset+3] = (byte) (n);
+        n >>>= 8;
+        b[offset+2] = (byte) (n);
+        n >>>= 8;
+        b[offset+1] = (byte) (n);
+        n >>>= 8;
+        b[offset+0] = (byte) (n);
+        return b;
+    }
+
+    /**
+     * Converts an long to eight bytes
+     * @param n - the long
+     * @return - eight bytes in an array
+     * @deprecated use toBytes(long,byte[],int)
+     */
+    public static byte[] toBytes(long n) {
+        return toBytes(n,new byte[8],0);
+    }
+    public static byte[] toBytes(long n, byte[] b, int offset) {
+        b[offset+7] = (byte) (n);
+        n >>>= 8;
+        b[offset+6] = (byte) (n);
+        n >>>= 8;
+        b[offset+5] = (byte) (n);
+        n >>>= 8;
+        b[offset+4] = (byte) (n);
+        n >>>= 8;
+        b[offset+3] = (byte) (n);
+        n >>>= 8;
+        b[offset+2] = (byte) (n);
+        n >>>= 8;
+        b[offset+1] = (byte) (n);
+        n >>>= 8;
+        b[offset+0] = (byte) (n);
+        return b;
+    }
+
+    /**
+     * Similar to a String.IndexOf, but uses pure bytes
+     * @param src - the source bytes to be searched
+     * @param srcOff - offset on the source buffer
+     * @param find - the string to be found within src
+     * @return - the index of the first matching byte. -1 if the find array is not found
+     */
+    public static int firstIndexOf(byte[] src, int srcOff, byte[] find){
+        int result = -1;
+        if (find.length > src.length) return result;
+        if (find.length == 0 || src.length == 0) return result;
+        if (srcOff >= src.length ) throw new java.lang.ArrayIndexOutOfBoundsException();
+        boolean found = false;
+        int srclen = src.length;
+        int findlen = find.length;
+        byte first = find[0];
+        int pos = srcOff;
+        while (!found) {
+            //find the first byte
+            while (pos < srclen){
+                if (first == src[pos])
+                    break;
+                pos++;
+            }
+            if (pos >= srclen)
+                return -1;
+
+            //we found the first character
+            //match the rest of the bytes - they have to match
+            if ( (srclen - pos) < findlen)
+                return -1;
+            //assume it does exist
+            found = true;
+            for (int i = 1; ( (i < findlen) && found); i++)
+                found = found && (find[i] == src[pos + i]);
+            if (found)
+                result = pos;
+            else if ( (srclen - pos) < findlen)
+                return -1; //no more matches possible
+            else
+                pos++;
+        }
+        return result;
+    }
+
+    
+    public static Serializable deserialize(byte[] data) 
+        throws IOException, ClassNotFoundException, ClassCastException {
+        return deserialize(data,0,data.length);
+    }
+    
+    public static Serializable deserialize(byte[] data, int offset, int length)  
+        throws IOException, ClassNotFoundException, ClassCastException {
+        return deserialize(data,offset,length,null);     
+    }
+    public static int invokecount = 0;
+    public static Serializable deserialize(byte[] data, int offset, int length, ClassLoader[] cls) 
+        throws IOException, ClassNotFoundException, ClassCastException {
+        synchronized (XByteBuffer.class) { invokecount++;}
+        Object message = null;
+        if ( cls == null ) cls = new ClassLoader[0];
+        if (data != null) {
+            InputStream  instream = new ByteArrayInputStream(data,offset,length);
+            ObjectInputStream stream = null;
+            stream = (cls.length>0)? new ReplicationStream(instream,cls):new ObjectInputStream(instream);
+            message = stream.readObject();
+            instream.close();
+            stream.close();
+        }
+        if ( message == null ) {
+            return null;
+        } else if (message instanceof Serializable)
+            return (Serializable) message;
+        else {
+            throw new ClassCastException("Message has the wrong class. It should implement Serializable, instead it is:"+message.getClass().getName());
+        }
+    }
+
+    /**
+     * Serializes a message into cluster data
+     * @param msg ClusterMessage
+     * @param compress boolean
+     * @return 
+     * @throws IOException
+     */
+    public static byte[] serialize(Serializable msg) throws IOException {
+        ByteArrayOutputStream outs = new ByteArrayOutputStream();
+        ObjectOutputStream out = new ObjectOutputStream(outs);
+        out.writeObject(msg);
+        out.flush();
+        byte[] data = outs.toByteArray();
+        return data;
+    }
+
+    public void setDiscard(boolean discard) {
+        this.discard = discard;
+    }
+
+    public boolean getDiscard() {
+        return discard;
+    }
+
+}

==================================================
McastService.java
index 29aaf5a46b..1197024417 100644
--- a/java/org/apache/catalina/tribes/membership/Constants.java
+++ b/java/org/apache/catalina/tribes/membership/Constants.java
@@ -1,39 +1,40 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina.tribes.membership;
-
-import org.apache.catalina.tribes.util.Arrays;
-
-
-/**
- * Manifest constants for the <code>org.apache.catalina.tribes.membership</code>
- * package.
- *
- * @author Peter Rossbach
- * @version $Revision: 303950 $ $Date: 2005-06-09 15:38:30 -0500 (Thu, 09 Jun 2005) $
- * @author Filip Hanik
- */
-
-public class Constants {
-
-    public static final String Package = "org.apache.catalina.tribes.membership";
-    public static void main(String[] args) throws Exception {
-        System.out.println(Arrays.toString("TRIBES-B".getBytes()));
-        System.out.println(Arrays.toString("TRIBES-E".getBytes()));
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.catalina.tribes.membership;
+
+import org.apache.catalina.tribes.util.Arrays;
+
+
+/**
+ * Manifest constants for the <code>org.apache.catalina.tribes.membership</code>
+ * package.
+ *
+ * @author Peter Rossbach
+ * @version $Revision: 303950 $ $Date: 2005-06-09 15:38:30 -0500 (Thu, 09 Jun 2005) $
+ * @author Filip Hanik
+ */
+
+public class Constants {
+
+    public static final String Package = "org.apache.catalina.tribes.membership";
+    public static void main(String[] args) throws Exception {
+        System.out.println(Arrays.toString("TRIBES-B".getBytes()));
+        System.out.println(Arrays.toString("TRIBES-E".getBytes()));
+    }
+}

==================================================
McastServiceImpl.java
index 7548217387..7ae1b73cf9 100644
--- a/java/org/apache/catalina/tribes/membership/McastService.java
+++ b/java/org/apache/catalina/tribes/membership/McastService.java
@@ -1,551 +1,552 @@
-/*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.membership;
-
-import java.util.Properties;
-
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.MembershipListener;
-import org.apache.catalina.tribes.MembershipService;
-import org.apache.catalina.tribes.util.StringManager;
-import org.apache.catalina.tribes.util.UUIDGenerator;
-import java.io.IOException;
-
-/**
- * A <b>membership</b> implementation using simple multicast.
- * This is the representation of a multicast membership service.
- * This class is responsible for maintaining a list of active cluster nodes in the cluster.
- * If a node fails to send out a heartbeat, the node will be dismissed.
- *
- * @author Filip Hanik
- * @version $Revision: 378093 $, $Date: 2006-02-15 15:13:45 -0600 (Wed, 15 Feb 2006) $
- */
-
-
-public class McastService implements MembershipService,MembershipListener {
-
-    private static org.apache.juli.logging.Log log =
-        org.apache.juli.logging.LogFactory.getLog( McastService.class );
-
-    /**
-     * The string manager for this package.
-     */
-    protected StringManager sm = StringManager.getManager(Constants.Package);
-
-    /**
-     * The descriptive information about this implementation.
-     */
-    private static final String info = "McastService/2.1";
-
-    /**
-     * The implementation specific properties
-     */
-    protected Properties properties = new Properties();
-    /**
-     * A handle to the actual low level implementation
-     */
-    protected McastServiceImpl impl;
-    /**
-     * A membership listener delegate (should be the cluster :)
-     */
-    protected MembershipListener listener;
-    /**
-     * The local member
-     */
-    protected MemberImpl localMember ;
-    private int mcastSoTimeout;
-    private int mcastTTL;
-    
-    protected byte[] payload;
-    
-    protected byte[] domain;
-
-    /**
-     * Create a membership service.
-     */
-    public McastService() {
-        //default values
-        properties.setProperty("mcastPort","45564");
-        properties.setProperty("mcastAddress","228.0.0.4");
-        properties.setProperty("memberDropTime","3000");
-        properties.setProperty("mcastFrequency","500");
-
-    }
-
-    /**
-     * Return descriptive information about this implementation and the
-     * corresponding version number, in the format
-     * <code>&lt;description&gt;/&lt;version&gt;</code>.
-     */
-    public String getInfo() {
-        return (info);
-    }
-    
-    /**
-     *
-     * @param properties
-     * <BR/>All are required<BR />
-     * 1. mcastPort - the port to listen to<BR>
-     * 2. mcastAddress - the mcast group address<BR>
-     * 4. bindAddress - the bind address if any - only one that can be null<BR>
-     * 5. memberDropTime - the time a member is gone before it is considered gone.<BR>
-     * 6. mcastFrequency - the frequency of sending messages<BR>
-     * 7. tcpListenPort - the port this member listens to<BR>
-     * 8. tcpListenHost - the bind address of this member<BR>
-     * @exception java.lang.IllegalArgumentException if a property is missing.
-     */
-    public void setProperties(Properties properties) {
-        hasProperty(properties,"mcastPort");
-        hasProperty(properties,"mcastAddress");
-        hasProperty(properties,"memberDropTime");
-        hasProperty(properties,"mcastFrequency");
-        hasProperty(properties,"tcpListenPort");
-        hasProperty(properties,"tcpListenHost");
-        this.properties = properties;
-    }
-
-    /**
-     * Return the properties, see setProperties
-     */
-    public Properties getProperties() {
-        return properties;
-    }
-
-    /**
-     * Return the local member name
-     */
-    public String getLocalMemberName() {
-        return localMember.toString() ;
-    }
- 
-    /**
-     * Return the local member
-     */
-    public Member getLocalMember(boolean alive) {
-        if ( alive && localMember != null && impl != null) localMember.setMemberAliveTime(System.currentTimeMillis()-impl.getServiceStartTime());
-        return localMember;
-    }
-    
-    /**
-     * Sets the local member properties for broadcasting
-     */
-    public void setLocalMemberProperties(String listenHost, int listenPort) {
-        properties.setProperty("tcpListenHost",listenHost);
-        properties.setProperty("tcpListenPort",String.valueOf(listenPort));
-        try {
-            if (localMember != null) {
-                localMember.setHostname(listenHost);
-                localMember.setPort(listenPort);
-            } else {
-                localMember = new MemberImpl(listenHost, listenPort, 0);
-                localMember.setUniqueId(UUIDGenerator.randomUUID(true));
-                localMember.setPayload(getPayload());
-                localMember.setDomain(getDomain());
-            }
-            localMember.getData(true, true);
-        }catch ( IOException x ) {
-            throw new IllegalArgumentException(x);
-        }
-    }
-    
-    public void setAddress(String addr) {
-        properties.setProperty("mcastAddress", addr);
-    }
-    
-    /**
-     * @deprecated use setAddress
-     * @param addr String
-     */
-    public void setMcastAddr(String addr) {
-        setAddress(addr);
-    }
-    
-    public String getAddress() {
-        return properties.getProperty("mcastAddress");
-    }
-    
-    /**
-     * @deprecated use getAddress
-     * @return String
-     */
-    public String getMcastAddr() {
-        return getAddress();
-    }
-
-    public void setMcastBindAddress(String bindaddr) {
-        setBind(bindaddr);
-    }
-    
-    public void setBind(String bindaddr) {
-        properties.setProperty("mcastBindAddress", bindaddr);
-    }
-    /**
-     * @deprecated use getBind
-     * @return String
-     */
-    public String getMcastBindAddress() {
-        return getBind();
-    }
-
-    public String getBind() {
-        return properties.getProperty("mcastBindAddress");
-    }
-
-    /**
-     * @deprecated use setPort
-     * @param port int
-     */
-    public void setMcastPort(int port) {
-        setPort(port);
-    }
-
-    public void setPort(int port) {
-        properties.setProperty("mcastPort", String.valueOf(port));
-    }
-
-    /**
-     * @deprecated use getPort()
-     * @return int
-     */
-    public int getMcastPort() {
-        return getPort();
-    }
-    public int getPort() {
-        String p = properties.getProperty("mcastPort");
-        return new Integer(p).intValue();
-    }
-    
-    /**
-     * @deprecated use setFrequency
-     * @param time long
-     */
-    public void setMcastFrequency(long time) {
-        setFrequency(time);
-    }
-    
-    public void setFrequency(long time) {
-        properties.setProperty("mcastFrequency", String.valueOf(time));
-    }
-
-    /**
-     * @deprecated use getFrequency
-     * @return long
-     */
-    public long getMcastFrequency() {
-        return getFrequency();
-    }
-
-    public long getFrequency() {
-        String p = properties.getProperty("mcastFrequency");
-        return new Long(p).longValue();
-    }
-
-    public void setMcastDropTime(long time) {
-        setDropTime(time);
-    }
-    public void setDropTime(long time) {
-        properties.setProperty("memberDropTime", String.valueOf(time));
-    }
-    
-    /**
-     * @deprecated use getDropTime
-     * @return long
-     */
-    public long getMcastDropTime() {
-        return getDropTime();
-    }
-
-    public long getDropTime() {
-        String p = properties.getProperty("memberDropTime");
-        return new Long(p).longValue();
-    }
-
-    /**
-     * Check if a required property is available.
-     * @param properties The set of properties
-     * @param name The property to check for
-     */
-    protected void hasProperty(Properties properties, String name){
-        if ( properties.getProperty(name)==null) throw new IllegalArgumentException("McastService:Required property \""+name+"\" is missing.");
-    }
-
-    /**
-     * Start broadcasting and listening to membership pings
-     * @throws java.lang.Exception if a IO error occurs
-     */
-    public void start() throws java.lang.Exception {
-        start(MembershipService.MBR_RX);
-        start(MembershipService.MBR_TX);
-    }
-    
-    public void start(int level) throws java.lang.Exception {
-        hasProperty(properties,"mcastPort");
-        hasProperty(properties,"mcastAddress");
-        hasProperty(properties,"memberDropTime");
-        hasProperty(properties,"mcastFrequency");
-        hasProperty(properties,"tcpListenPort");
-        hasProperty(properties,"tcpListenHost");
-
-        if ( impl != null ) {
-            impl.start(level);
-            return;
-        }
-        String host = getProperties().getProperty("tcpListenHost");
-        int port = Integer.parseInt(getProperties().getProperty("tcpListenPort"));
-        
-        if ( localMember == null ) {
-            localMember = new MemberImpl(host, port, 100);
-            localMember.setUniqueId(UUIDGenerator.randomUUID(true));
-        } else {
-            localMember.setHostname(host);
-            localMember.setPort(port);
-            localMember.setMemberAliveTime(100);
-        }
-        if ( this.payload != null ) localMember.setPayload(payload);
-        if ( this.domain != null ) localMember.setDomain(domain);
-        localMember.setServiceStartTime(System.currentTimeMillis());
-        java.net.InetAddress bind = null;
-        if ( properties.getProperty("mcastBindAddress")!= null ) {
-            bind = java.net.InetAddress.getByName(properties.getProperty("mcastBindAddress"));
-        }
-        int ttl = -1;
-        int soTimeout = -1;
-        if ( properties.getProperty("mcastTTL") != null ) {
-            try {
-                ttl = Integer.parseInt(properties.getProperty("mcastTTL"));
-            } catch ( Exception x ) {
-                log.error("Unable to parse mcastTTL="+properties.getProperty("mcastTTL"),x);
-            }
-        }
-        if ( properties.getProperty("mcastSoTimeout") != null ) {
-            try {
-                soTimeout = Integer.parseInt(properties.getProperty("mcastSoTimeout"));
-            } catch ( Exception x ) {
-                log.error("Unable to parse mcastSoTimeout="+properties.getProperty("mcastSoTimeout"),x);
-            }
-        }
-
-        impl = new McastServiceImpl((MemberImpl)localMember,Long.parseLong(properties.getProperty("mcastFrequency")),
-                                    Long.parseLong(properties.getProperty("memberDropTime")),
-                                    Integer.parseInt(properties.getProperty("mcastPort")),
-                                    bind,
-                                    java.net.InetAddress.getByName(properties.getProperty("mcastAddress")),
-                                    ttl,
-                                    soTimeout,
-                                    this);
-        
-        impl.start(level);
-		
-
-    }
-
- 
-    /**
-     * Stop broadcasting and listening to membership pings
-     */
-    public void stop(int svc) {
-        try  {
-            if ( impl != null && impl.stop(svc) ) impl = null;
-        } catch ( Exception x)  {
-            log.error("Unable to stop the mcast service, level:"+svc+".",x);
-        }
-    }
-
-
-    /**
-     * Return all the members by name
-     */
-    public String[] getMembersByName() {
-        Member[] currentMembers = getMembers();
-        String [] membernames ;
-        if(currentMembers != null) {
-            membernames = new String[currentMembers.length];
-            for (int i = 0; i < currentMembers.length; i++) {
-                membernames[i] = currentMembers[i].toString() ;
-            }
-        } else
-            membernames = new String[0] ;
-        return membernames ;
-    }
- 
-    /**
-     * Return the member by name
-     */
-    public Member findMemberByName(String name) {
-        Member[] currentMembers = getMembers();
-        for (int i = 0; i < currentMembers.length; i++) {
-            if (name.equals(currentMembers[i].toString()))
-                return currentMembers[i];
-        }
-        return null;
-    }
-
-    /**
-     * has members?
-     */
-    public boolean hasMembers() {
-       if ( impl == null || impl.membership == null ) return false;
-       return impl.membership.hasMembers();
-    }
-    
-    public Member getMember(Member mbr) {
-        if ( impl == null || impl.membership == null ) return null;
-        return impl.membership.getMember(mbr);
-    }
-
-    /**
-     * Return all the members
-     */
-    public Member[] getMembers() {
-        if ( impl == null || impl.membership == null ) return null;
-        return impl.membership.getMembers();
-    }
-    /**
-     * Add a membership listener, this version only supports one listener per service,
-     * so calling this method twice will result in only the second listener being active.
-     * @param listener The listener
-     */
-    public void setMembershipListener(MembershipListener listener) {
-        this.listener = listener;
-    }
-    /**
-     * Remove the membership listener
-     */
-    public void removeMembershipListener(){
-        listener = null;
-    }
-
-    public void memberAdded(Member member) {
-        if ( listener!=null ) listener.memberAdded(member);
-    }
-
-    /**
-     * Callback from the impl when a new member has been received
-     * @param member The member
-     */
-    public void memberDisappeared(Member member)
-    {
-        if ( listener!=null ) listener.memberDisappeared(member);
-    }
-
-    /**
-     * @deprecated use getSoTimeout
-     * @return int
-     */
-    public int getMcastSoTimeout() {
-        return getSoTimeout();
-    }
-    
-    public int getSoTimeout() {
-        return mcastSoTimeout;
-    }
-    
-    /**
-     * @deprecated use setSoTimeout
-     * @param mcastSoTimeout int
-     */
-    public void setMcastSoTimeout(int mcastSoTimeout) {
-        setSoTimeout(mcastSoTimeout);
-    }
-    
-    public void setSoTimeout(int mcastSoTimeout) {
-        this.mcastSoTimeout = mcastSoTimeout;
-        properties.setProperty("mcastSoTimeout", String.valueOf(mcastSoTimeout));
-    }
-    
-    /**
-     * @deprecated use getTtl
-     * @return int
-     */
-    public int getMcastTTL() {
-        return getTtl();
-    }
-    
-    public int getTtl() {
-        return mcastTTL;
-    }
-
-    public byte[] getPayload() {
-        return payload;
-    }
-    
-    public byte[] getDomain() {
-        return domain;
-    }
-    
-    /**
-     * @deprecated use setTtl
-     * @param mcastTTL int
-     */
-    public void setMcastTTL(int mcastTTL) {
-        setTtl(mcastTTL);
-    }
-
-    public void setTtl(int mcastTTL) {
-        this.mcastTTL = mcastTTL;
-        properties.setProperty("mcastTTL", String.valueOf(mcastTTL));
-    }
-
-    public void setPayload(byte[] payload) {
-        this.payload = payload;
-        if ( localMember != null ) {
-            localMember.setPayload(payload);
-            localMember.getData(true,true);
-            try {
-                if (impl != null) impl.send(false);
-            }catch ( Exception x ) {
-                log.error("Unable to send payload update.",x);
-            }
-        }
-    }
-    
-    public void setDomain(byte[] domain) {
-        this.domain = domain;
-        if ( localMember != null ) {
-            localMember.setDomain(domain);
-            localMember.getData(true,true);
-            try {
-                if (impl != null) impl.send(false);
-            }catch ( Exception x ) {
-                log.error("Unable to send domain update.",x);
-            }
-        }
-    }
-
-    /**
-     * Simple test program
-     * @param args Command-line arguments
-     * @throws Exception If an error occurs
-     */
-    public static void main(String args[]) throws Exception {
-		if(log.isInfoEnabled())
-            log.info("Usage McastService hostname tcpport");
-        McastService service = new McastService();
-        java.util.Properties p = new java.util.Properties();
-        p.setProperty("mcastPort","5555");
-        p.setProperty("mcastAddress","224.10.10.10");
-        p.setProperty("mcastClusterDomain","catalina");
-        p.setProperty("bindAddress","localhost");
-        p.setProperty("memberDropTime","3000");
-        p.setProperty("mcastFrequency","500");
-        p.setProperty("tcpListenPort","4000");
-        p.setProperty("tcpListenHost","127.0.0.1");
-        service.setProperties(p);
-        service.start();
-        Thread.sleep(60*1000*60);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.membership;
+
+import java.util.Properties;
+
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.MembershipListener;
+import org.apache.catalina.tribes.MembershipService;
+import org.apache.catalina.tribes.util.StringManager;
+import org.apache.catalina.tribes.util.UUIDGenerator;
+import java.io.IOException;
+
+/**
+ * A <b>membership</b> implementation using simple multicast.
+ * This is the representation of a multicast membership service.
+ * This class is responsible for maintaining a list of active cluster nodes in the cluster.
+ * If a node fails to send out a heartbeat, the node will be dismissed.
+ *
+ * @author Filip Hanik
+ * @version $Revision: 378093 $, $Date: 2006-02-15 15:13:45 -0600 (Wed, 15 Feb 2006) $
+ */
+
+
+public class McastService implements MembershipService,MembershipListener {
+
+    private static org.apache.juli.logging.Log log =
+        org.apache.juli.logging.LogFactory.getLog( McastService.class );
+
+    /**
+     * The string manager for this package.
+     */
+    protected StringManager sm = StringManager.getManager(Constants.Package);
+
+    /**
+     * The descriptive information about this implementation.
+     */
+    private static final String info = "McastService/2.1";
+
+    /**
+     * The implementation specific properties
+     */
+    protected Properties properties = new Properties();
+    /**
+     * A handle to the actual low level implementation
+     */
+    protected McastServiceImpl impl;
+    /**
+     * A membership listener delegate (should be the cluster :)
+     */
+    protected MembershipListener listener;
+    /**
+     * The local member
+     */
+    protected MemberImpl localMember ;
+    private int mcastSoTimeout;
+    private int mcastTTL;
+    
+    protected byte[] payload;
+    
+    protected byte[] domain;
+
+    /**
+     * Create a membership service.
+     */
+    public McastService() {
+        //default values
+        properties.setProperty("mcastPort","45564");
+        properties.setProperty("mcastAddress","228.0.0.4");
+        properties.setProperty("memberDropTime","3000");
+        properties.setProperty("mcastFrequency","500");
+
+    }
+
+    /**
+     * Return descriptive information about this implementation and the
+     * corresponding version number, in the format
+     * <code>&lt;description&gt;/&lt;version&gt;</code>.
+     */
+    public String getInfo() {
+        return (info);
+    }
+    
+    /**
+     *
+     * @param properties
+     * <BR/>All are required<BR />
+     * 1. mcastPort - the port to listen to<BR>
+     * 2. mcastAddress - the mcast group address<BR>
+     * 4. bindAddress - the bind address if any - only one that can be null<BR>
+     * 5. memberDropTime - the time a member is gone before it is considered gone.<BR>
+     * 6. mcastFrequency - the frequency of sending messages<BR>
+     * 7. tcpListenPort - the port this member listens to<BR>
+     * 8. tcpListenHost - the bind address of this member<BR>
+     * @exception java.lang.IllegalArgumentException if a property is missing.
+     */
+    public void setProperties(Properties properties) {
+        hasProperty(properties,"mcastPort");
+        hasProperty(properties,"mcastAddress");
+        hasProperty(properties,"memberDropTime");
+        hasProperty(properties,"mcastFrequency");
+        hasProperty(properties,"tcpListenPort");
+        hasProperty(properties,"tcpListenHost");
+        this.properties = properties;
+    }
+
+    /**
+     * Return the properties, see setProperties
+     */
+    public Properties getProperties() {
+        return properties;
+    }
+
+    /**
+     * Return the local member name
+     */
+    public String getLocalMemberName() {
+        return localMember.toString() ;
+    }
+ 
+    /**
+     * Return the local member
+     */
+    public Member getLocalMember(boolean alive) {
+        if ( alive && localMember != null && impl != null) localMember.setMemberAliveTime(System.currentTimeMillis()-impl.getServiceStartTime());
+        return localMember;
+    }
+    
+    /**
+     * Sets the local member properties for broadcasting
+     */
+    public void setLocalMemberProperties(String listenHost, int listenPort) {
+        properties.setProperty("tcpListenHost",listenHost);
+        properties.setProperty("tcpListenPort",String.valueOf(listenPort));
+        try {
+            if (localMember != null) {
+                localMember.setHostname(listenHost);
+                localMember.setPort(listenPort);
+            } else {
+                localMember = new MemberImpl(listenHost, listenPort, 0);
+                localMember.setUniqueId(UUIDGenerator.randomUUID(true));
+                localMember.setPayload(getPayload());
+                localMember.setDomain(getDomain());
+            }
+            localMember.getData(true, true);
+        }catch ( IOException x ) {
+            throw new IllegalArgumentException(x);
+        }
+    }
+    
+    public void setAddress(String addr) {
+        properties.setProperty("mcastAddress", addr);
+    }
+    
+    /**
+     * @deprecated use setAddress
+     * @param addr String
+     */
+    public void setMcastAddr(String addr) {
+        setAddress(addr);
+    }
+    
+    public String getAddress() {
+        return properties.getProperty("mcastAddress");
+    }
+    
+    /**
+     * @deprecated use getAddress
+     * @return String
+     */
+    public String getMcastAddr() {
+        return getAddress();
+    }
+
+    public void setMcastBindAddress(String bindaddr) {
+        setBind(bindaddr);
+    }
+    
+    public void setBind(String bindaddr) {
+        properties.setProperty("mcastBindAddress", bindaddr);
+    }
+    /**
+     * @deprecated use getBind
+     * @return String
+     */
+    public String getMcastBindAddress() {
+        return getBind();
+    }
+
+    public String getBind() {
+        return properties.getProperty("mcastBindAddress");
+    }
+
+    /**
+     * @deprecated use setPort
+     * @param port int
+     */
+    public void setMcastPort(int port) {
+        setPort(port);
+    }
+
+    public void setPort(int port) {
+        properties.setProperty("mcastPort", String.valueOf(port));
+    }
+
+    /**
+     * @deprecated use getPort()
+     * @return int
+     */
+    public int getMcastPort() {
+        return getPort();
+    }
+    public int getPort() {
+        String p = properties.getProperty("mcastPort");
+        return new Integer(p).intValue();
+    }
+    
+    /**
+     * @deprecated use setFrequency
+     * @param time long
+     */
+    public void setMcastFrequency(long time) {
+        setFrequency(time);
+    }
+    
+    public void setFrequency(long time) {
+        properties.setProperty("mcastFrequency", String.valueOf(time));
+    }
+
+    /**
+     * @deprecated use getFrequency
+     * @return long
+     */
+    public long getMcastFrequency() {
+        return getFrequency();
+    }
+
+    public long getFrequency() {
+        String p = properties.getProperty("mcastFrequency");
+        return new Long(p).longValue();
+    }
+
+    public void setMcastDropTime(long time) {
+        setDropTime(time);
+    }
+    public void setDropTime(long time) {
+        properties.setProperty("memberDropTime", String.valueOf(time));
+    }
+    
+    /**
+     * @deprecated use getDropTime
+     * @return long
+     */
+    public long getMcastDropTime() {
+        return getDropTime();
+    }
+
+    public long getDropTime() {
+        String p = properties.getProperty("memberDropTime");
+        return new Long(p).longValue();
+    }
+
+    /**
+     * Check if a required property is available.
+     * @param properties The set of properties
+     * @param name The property to check for
+     */
+    protected void hasProperty(Properties properties, String name){
+        if ( properties.getProperty(name)==null) throw new IllegalArgumentException("McastService:Required property \""+name+"\" is missing.");
+    }
+
+    /**
+     * Start broadcasting and listening to membership pings
+     * @throws java.lang.Exception if a IO error occurs
+     */
+    public void start() throws java.lang.Exception {
+        start(MembershipService.MBR_RX);
+        start(MembershipService.MBR_TX);
+    }
+    
+    public void start(int level) throws java.lang.Exception {
+        hasProperty(properties,"mcastPort");
+        hasProperty(properties,"mcastAddress");
+        hasProperty(properties,"memberDropTime");
+        hasProperty(properties,"mcastFrequency");
+        hasProperty(properties,"tcpListenPort");
+        hasProperty(properties,"tcpListenHost");
+
+        if ( impl != null ) {
+            impl.start(level);
+            return;
+        }
+        String host = getProperties().getProperty("tcpListenHost");
+        int port = Integer.parseInt(getProperties().getProperty("tcpListenPort"));
+        
+        if ( localMember == null ) {
+            localMember = new MemberImpl(host, port, 100);
+            localMember.setUniqueId(UUIDGenerator.randomUUID(true));
+        } else {
+            localMember.setHostname(host);
+            localMember.setPort(port);
+            localMember.setMemberAliveTime(100);
+        }
+        if ( this.payload != null ) localMember.setPayload(payload);
+        if ( this.domain != null ) localMember.setDomain(domain);
+        localMember.setServiceStartTime(System.currentTimeMillis());
+        java.net.InetAddress bind = null;
+        if ( properties.getProperty("mcastBindAddress")!= null ) {
+            bind = java.net.InetAddress.getByName(properties.getProperty("mcastBindAddress"));
+        }
+        int ttl = -1;
+        int soTimeout = -1;
+        if ( properties.getProperty("mcastTTL") != null ) {
+            try {
+                ttl = Integer.parseInt(properties.getProperty("mcastTTL"));
+            } catch ( Exception x ) {
+                log.error("Unable to parse mcastTTL="+properties.getProperty("mcastTTL"),x);
+            }
+        }
+        if ( properties.getProperty("mcastSoTimeout") != null ) {
+            try {
+                soTimeout = Integer.parseInt(properties.getProperty("mcastSoTimeout"));
+            } catch ( Exception x ) {
+                log.error("Unable to parse mcastSoTimeout="+properties.getProperty("mcastSoTimeout"),x);
+            }
+        }
+
+        impl = new McastServiceImpl((MemberImpl)localMember,Long.parseLong(properties.getProperty("mcastFrequency")),
+                                    Long.parseLong(properties.getProperty("memberDropTime")),
+                                    Integer.parseInt(properties.getProperty("mcastPort")),
+                                    bind,
+                                    java.net.InetAddress.getByName(properties.getProperty("mcastAddress")),
+                                    ttl,
+                                    soTimeout,
+                                    this);
+        
+        impl.start(level);
+		
+
+    }
+
+ 
+    /**
+     * Stop broadcasting and listening to membership pings
+     */
+    public void stop(int svc) {
+        try  {
+            if ( impl != null && impl.stop(svc) ) impl = null;
+        } catch ( Exception x)  {
+            log.error("Unable to stop the mcast service, level:"+svc+".",x);
+        }
+    }
+
+
+    /**
+     * Return all the members by name
+     */
+    public String[] getMembersByName() {
+        Member[] currentMembers = getMembers();
+        String [] membernames ;
+        if(currentMembers != null) {
+            membernames = new String[currentMembers.length];
+            for (int i = 0; i < currentMembers.length; i++) {
+                membernames[i] = currentMembers[i].toString() ;
+            }
+        } else
+            membernames = new String[0] ;
+        return membernames ;
+    }
+ 
+    /**
+     * Return the member by name
+     */
+    public Member findMemberByName(String name) {
+        Member[] currentMembers = getMembers();
+        for (int i = 0; i < currentMembers.length; i++) {
+            if (name.equals(currentMembers[i].toString()))
+                return currentMembers[i];
+        }
+        return null;
+    }
+
+    /**
+     * has members?
+     */
+    public boolean hasMembers() {
+       if ( impl == null || impl.membership == null ) return false;
+       return impl.membership.hasMembers();
+    }
+    
+    public Member getMember(Member mbr) {
+        if ( impl == null || impl.membership == null ) return null;
+        return impl.membership.getMember(mbr);
+    }
+
+    /**
+     * Return all the members
+     */
+    public Member[] getMembers() {
+        if ( impl == null || impl.membership == null ) return null;
+        return impl.membership.getMembers();
+    }
+    /**
+     * Add a membership listener, this version only supports one listener per service,
+     * so calling this method twice will result in only the second listener being active.
+     * @param listener The listener
+     */
+    public void setMembershipListener(MembershipListener listener) {
+        this.listener = listener;
+    }
+    /**
+     * Remove the membership listener
+     */
+    public void removeMembershipListener(){
+        listener = null;
+    }
+
+    public void memberAdded(Member member) {
+        if ( listener!=null ) listener.memberAdded(member);
+    }
+
+    /**
+     * Callback from the impl when a new member has been received
+     * @param member The member
+     */
+    public void memberDisappeared(Member member)
+    {
+        if ( listener!=null ) listener.memberDisappeared(member);
+    }
+
+    /**
+     * @deprecated use getSoTimeout
+     * @return int
+     */
+    public int getMcastSoTimeout() {
+        return getSoTimeout();
+    }
+    
+    public int getSoTimeout() {
+        return mcastSoTimeout;
+    }
+    
+    /**
+     * @deprecated use setSoTimeout
+     * @param mcastSoTimeout int
+     */
+    public void setMcastSoTimeout(int mcastSoTimeout) {
+        setSoTimeout(mcastSoTimeout);
+    }
+    
+    public void setSoTimeout(int mcastSoTimeout) {
+        this.mcastSoTimeout = mcastSoTimeout;
+        properties.setProperty("mcastSoTimeout", String.valueOf(mcastSoTimeout));
+    }
+    
+    /**
+     * @deprecated use getTtl
+     * @return int
+     */
+    public int getMcastTTL() {
+        return getTtl();
+    }
+    
+    public int getTtl() {
+        return mcastTTL;
+    }
+
+    public byte[] getPayload() {
+        return payload;
+    }
+    
+    public byte[] getDomain() {
+        return domain;
+    }
+    
+    /**
+     * @deprecated use setTtl
+     * @param mcastTTL int
+     */
+    public void setMcastTTL(int mcastTTL) {
+        setTtl(mcastTTL);
+    }
+
+    public void setTtl(int mcastTTL) {
+        this.mcastTTL = mcastTTL;
+        properties.setProperty("mcastTTL", String.valueOf(mcastTTL));
+    }
+
+    public void setPayload(byte[] payload) {
+        this.payload = payload;
+        if ( localMember != null ) {
+            localMember.setPayload(payload);
+            localMember.getData(true,true);
+            try {
+                if (impl != null) impl.send(false);
+            }catch ( Exception x ) {
+                log.error("Unable to send payload update.",x);
+            }
+        }
+    }
+    
+    public void setDomain(byte[] domain) {
+        this.domain = domain;
+        if ( localMember != null ) {
+            localMember.setDomain(domain);
+            localMember.getData(true,true);
+            try {
+                if (impl != null) impl.send(false);
+            }catch ( Exception x ) {
+                log.error("Unable to send domain update.",x);
+            }
+        }
+    }
+
+    /**
+     * Simple test program
+     * @param args Command-line arguments
+     * @throws Exception If an error occurs
+     */
+    public static void main(String args[]) throws Exception {
+		if(log.isInfoEnabled())
+            log.info("Usage McastService hostname tcpport");
+        McastService service = new McastService();
+        java.util.Properties p = new java.util.Properties();
+        p.setProperty("mcastPort","5555");
+        p.setProperty("mcastAddress","224.10.10.10");
+        p.setProperty("mcastClusterDomain","catalina");
+        p.setProperty("bindAddress","localhost");
+        p.setProperty("memberDropTime","3000");
+        p.setProperty("mcastFrequency","500");
+        p.setProperty("tcpListenPort","4000");
+        p.setProperty("tcpListenHost","127.0.0.1");
+        service.setProperties(p);
+        service.start();
+        Thread.sleep(60*1000*60);
+    }
+}

==================================================
MemberImpl.java
index 12134fc0de..c35234af31 100644
--- a/java/org/apache/catalina/tribes/membership/McastServiceImpl.java
+++ b/java/org/apache/catalina/tribes/membership/McastServiceImpl.java
@@ -1,398 +1,399 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.membership;
-
-
-import java.io.IOException;
-import java.net.DatagramPacket;
-import java.net.InetAddress;
-import java.net.MulticastSocket;
-
-import org.apache.catalina.tribes.MembershipListener;
-import java.util.Arrays;
-import java.net.SocketTimeoutException;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.Channel;
-import java.net.InetSocketAddress;
-
-/**
- * A <b>membership</b> implementation using simple multicast.
- * This is the representation of a multicast membership service.
- * This class is responsible for maintaining a list of active cluster nodes in the cluster.
- * If a node fails to send out a heartbeat, the node will be dismissed.
- * This is the low level implementation that handles the multicasting sockets.
- * Need to fix this, could use java.nio and only need one thread to send and receive, or
- * just use a timeout on the receive
- * @author Filip Hanik
- * @version $Revision: 356540 $, $Date: 2005-12-13 10:53:40 -0600 (Tue, 13 Dec 2005) $
- */
-public class McastServiceImpl
-{
-    private static org.apache.juli.logging.Log log =
-        org.apache.juli.logging.LogFactory.getLog( McastService.class );
-    
-    protected static int MAX_PACKET_SIZE = 65535;
-    /**
-     * Internal flag used for the listen thread that listens to the multicasting socket.
-     */
-    protected boolean doRunSender = false;
-    protected boolean doRunReceiver = false;
-    protected int startLevel = 0;
-    /**
-     * Socket that we intend to listen to
-     */
-    protected MulticastSocket socket;
-    /**
-     * The local member that we intend to broad cast over and over again
-     */
-    protected MemberImpl member;
-    /**
-     * The multicast address
-     */
-    protected InetAddress address;
-    /**
-     * The multicast port
-     */
-    protected int port;
-    /**
-     * The time it takes for a member to expire.
-     */
-    protected long timeToExpiration;
-    /**
-     * How often to we send out a broadcast saying we are alive, must be smaller than timeToExpiration
-     */
-    protected long sendFrequency;
-    /**
-     * Reuse the sendPacket, no need to create a new one everytime
-     */
-    protected DatagramPacket sendPacket;
-    /**
-     * Reuse the receivePacket, no need to create a new one everytime
-     */
-    protected DatagramPacket receivePacket;
-    /**
-     * The membership, used so that we calculate memberships when they arrive or don't arrive
-     */
-    protected Membership membership;
-    /**
-     * The actual listener, for callback when shits goes down
-     */
-    protected MembershipListener service;
-    /**
-     * Thread to listen for pings
-     */
-    protected ReceiverThread receiver;
-    /**
-     * Thread to send pings
-     */
-    protected SenderThread sender;
-
-    /**
-     * When was the service started
-     */
-    protected long serviceStartTime = System.currentTimeMillis();
-    
-    /**
-     * Time to live for the multicast packets that are being sent out
-     */
-    protected int mcastTTL = -1;
-    /**
-     * Read timeout on the mcast socket
-     */
-    protected int mcastSoTimeout = -1;
-    /**
-     * bind address
-     */
-    protected InetAddress mcastBindAddress = null;
-    
-    /**
-     * Create a new mcast service impl
-     * @param member - the local member
-     * @param sendFrequency - the time (ms) in between pings sent out
-     * @param expireTime - the time (ms) for a member to expire
-     * @param port - the mcast port
-     * @param bind - the bind address (not sure this is used yet)
-     * @param mcastAddress - the mcast address
-     * @param service - the callback service
-     * @throws IOException
-     */
-    public McastServiceImpl(
-        MemberImpl member,
-        long sendFrequency,
-        long expireTime,
-        int port,
-        InetAddress bind,
-        InetAddress mcastAddress,
-        int ttl,
-        int soTimeout,
-        MembershipListener service)
-    throws IOException {
-        this.member = member;
-        this.address = mcastAddress;
-        this.port = port;
-        this.mcastSoTimeout = soTimeout;
-        this.mcastTTL = ttl;
-        this.mcastBindAddress = bind;
-        this.timeToExpiration = expireTime;
-        this.service = service;
-        this.sendFrequency = sendFrequency;
-        setupSocket();
-        sendPacket = new DatagramPacket(new byte[MAX_PACKET_SIZE],MAX_PACKET_SIZE);
-        sendPacket.setAddress(address);
-        sendPacket.setPort(port);
-        receivePacket = new DatagramPacket(new byte[MAX_PACKET_SIZE],MAX_PACKET_SIZE);
-        receivePacket.setAddress(address);
-        receivePacket.setPort(port);
-        membership = new Membership(member);
-    }
-    
-    protected void setupSocket() throws IOException {
-        if (mcastBindAddress != null) socket = new MulticastSocket(new InetSocketAddress(mcastBindAddress, port));
-        else socket = new MulticastSocket(port);
-        socket.setLoopbackMode(false); //hint that we don't need loop back messages
-        if (mcastBindAddress != null) {
-			if(log.isInfoEnabled())
-                log.info("Setting multihome multicast interface to:" +mcastBindAddress);
-            socket.setInterface(mcastBindAddress);
-        } //end if
-        //force a so timeout so that we don't block forever
-        if ( mcastSoTimeout <= 0 ) mcastSoTimeout = (int)sendFrequency;
-        if(log.isInfoEnabled())
-            log.info("Setting cluster mcast soTimeout to "+mcastSoTimeout);
-        socket.setSoTimeout(mcastSoTimeout);
-
-        if ( mcastTTL >= 0 ) {
-			if(log.isInfoEnabled())
-                log.info("Setting cluster mcast TTL to " + mcastTTL);
-            socket.setTimeToLive(mcastTTL);
-        }
-    }
-    
-    
-
-    /**
-     * Start the service
-     * @param level 1 starts the receiver, level 2 starts the sender
-     * @throws IOException if the service fails to start
-     * @throws IllegalStateException if the service is already started
-     */
-    public synchronized void start(int level) throws IOException {
-        boolean valid = false;
-        if ( (level & Channel.MBR_RX_SEQ)==Channel.MBR_RX_SEQ ) {
-            if ( receiver != null ) throw new IllegalStateException("McastService.receive already running.");
-            if ( sender == null ) socket.joinGroup(address);
-            doRunReceiver = true;
-            receiver = new ReceiverThread();
-            receiver.setDaemon(true);
-            receiver.start();
-            valid = true;
-        } 
-        if ( (level & Channel.MBR_TX_SEQ)==Channel.MBR_TX_SEQ ) {
-            if ( sender != null ) throw new IllegalStateException("McastService.send already running.");
-            if ( receiver == null ) socket.joinGroup(address);
-            //make sure at least one packet gets out there
-            send(false);
-            doRunSender = true;
-            serviceStartTime = System.currentTimeMillis();
-            sender = new SenderThread(sendFrequency);
-            sender.setDaemon(true);
-            sender.start();
-            //we have started the receiver, but not yet waited for membership to establish
-            valid = true;
-        } 
-        if (!valid) {
-            throw new IllegalArgumentException("Invalid start level. Only acceptable levels are Channel.MBR_RX_SEQ and Channel.MBR_TX_SEQ");
-        }
-        //pause, once or twice
-        waitForMembers(level);
-        startLevel = (startLevel | level);
-    }
-
-    private void waitForMembers(int level) {
-        long memberwait = sendFrequency*2;
-        if(log.isInfoEnabled())
-            log.info("Sleeping for "+memberwait+" milliseconds to establish cluster membership, start level:"+level);
-        try {Thread.sleep(memberwait);}catch (InterruptedException ignore){}
-        if(log.isInfoEnabled())
-            log.info("Done sleeping, membership established, start level:"+level);
-    }
-
-    /**
-     * Stops the service
-     * @throws IOException if the service fails to disconnect from the sockets
-     */
-    public synchronized boolean stop(int level) throws IOException {
-        boolean valid = false;
-        
-        if ( (level & Channel.MBR_RX_SEQ)==Channel.MBR_RX_SEQ ) {
-            valid = true;
-            doRunReceiver = false;
-            if ( receiver !=null ) receiver.interrupt();
-            receiver = null;
-        } 
-        if ( (level & Channel.MBR_TX_SEQ)==Channel.MBR_TX_SEQ ) {
-            valid = true;
-            doRunSender = false;
-            if ( sender != null )sender.interrupt();
-            sender = null;
-        } 
-        
-        if (!valid) {
-            throw new IllegalArgumentException("Invalid stop level. Only acceptable levels are Channel.MBR_RX_SEQ and Channel.MBR_TX_SEQ");
-        }
-        startLevel = (startLevel & (~level));
-        //we're shutting down, send a shutdown message and close the socket
-        if ( startLevel == 0 ) {
-            //send a stop message
-            member.setCommand(Member.SHUTDOWN_PAYLOAD);
-            member.getData(true, true);
-            send(false);
-            //leave mcast group
-            try {socket.leaveGroup(address);}catch ( Exception ignore){}
-            serviceStartTime = Long.MAX_VALUE;
-        }
-        return (startLevel == 0);
-    }
-
-    /**
-     * Receive a datagram packet, locking wait
-     * @throws IOException
-     */
-    public void receive() throws IOException {
-        try {
-            socket.receive(receivePacket);
-            if(receivePacket.getLength() > MAX_PACKET_SIZE) {
-                log.error("Multicast packet received was too long, dropping package:"+receivePacket.getLength());
-            } else {
-                byte[] data = new byte[receivePacket.getLength()];
-                System.arraycopy(receivePacket.getData(), receivePacket.getOffset(), data, 0, data.length);
-                final MemberImpl m = MemberImpl.getMember(data);
-                if (log.isTraceEnabled()) log.trace("Mcast receive ping from member " + m);
-                Thread t = null;
-                if (Arrays.equals(m.getCommand(), Member.SHUTDOWN_PAYLOAD)) {
-                    if (log.isDebugEnabled()) log.debug("Member has shutdown:" + m);
-                    membership.removeMember(m);
-                    t = new Thread() {
-                        public void run() {
-                            service.memberDisappeared(m);
-                        }
-                    };
-                } else if (membership.memberAlive(m)) {
-                    if (log.isDebugEnabled()) log.debug("Mcast add member " + m);
-                    t = new Thread() {
-                        public void run() {
-                            service.memberAdded(m);
-                        }
-                    };
-                } //end if
-                if ( t != null ) t.start();
-            }
-        } catch (SocketTimeoutException x ) { 
-            //do nothing, this is normal, we don't want to block forever
-            //since the receive thread is the same thread
-            //that does membership expiration
-        }
-        checkExpired();
-    }
-    
-    protected Object expiredMutex = new Object();
-    protected void checkExpired() {
-        synchronized (expiredMutex) {
-            MemberImpl[] expired = membership.expire(timeToExpiration);
-            for (int i = 0; i < expired.length; i++) {
-                final MemberImpl member = expired[i];
-                if (log.isDebugEnabled())
-                    log.debug("Mcast exipre  member " + expired[i]);
-                try {
-                    Thread t = new Thread() {
-                        public void run() {
-                            service.memberDisappeared(member);
-                        }
-                    };
-                    t.start();
-                } catch (Exception x) {
-                    log.error("Unable to process member disappeared message.", x);
-                }
-            }
-        }
-    }
-
-    /**
-     * Send a ping
-     * @throws Exception
-     */ 
-    public void send(boolean checkexpired) throws IOException{
-        //ignore if we haven't started the sender
-        //if ( (startLevel&Channel.MBR_TX_SEQ) != Channel.MBR_TX_SEQ ) return;
-        member.inc();
-        if(log.isTraceEnabled())
-            log.trace("Mcast send ping from member " + member);
-        byte[] data = member.getData();
-        DatagramPacket p = new DatagramPacket(data,data.length);
-        p.setAddress(address);
-        p.setPort(port);
-        socket.send(p);
-        if ( checkexpired ) checkExpired();
-    }
-
-    public long getServiceStartTime() {
-       return this.serviceStartTime;
-    }
-
-
-    public class ReceiverThread extends Thread {
-        public ReceiverThread() {
-            super();
-            setName("Cluster-MembershipReceiver");
-        }
-        public void run() {
-            while ( doRunReceiver ) {
-                try {
-                    receive();
-                } catch ( ArrayIndexOutOfBoundsException ax ) {
-                    //we can ignore this, as it means we have an invalid package
-                    //but we will log it to debug
-                    if ( log.isDebugEnabled() )
-                        log.debug("Invalid member mcast package.",ax);
-                } catch ( Exception x ) {
-                    log.warn("Error receiving mcast package. Sleeping 500ms",x);
-                    try { Thread.sleep(500); } catch ( Exception ignore ){}
-                    
-                }
-            }
-        }
-    }//class ReceiverThread
-
-    public class SenderThread extends Thread {
-        long time;
-        public SenderThread(long time) {
-            this.time = time;
-            setName("Cluster-MembershipSender");
-
-        }
-        public void run() {
-            while ( doRunSender ) {
-                try {
-                    send(true);
-                } catch ( Exception x ) {
-                    log.warn("Unable to send mcast message.",x);
-                }
-                try { Thread.sleep(time); } catch ( Exception ignore ) {}
-            }
-        }
-    }//class SenderThread
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.membership;
+
+
+import java.io.IOException;
+import java.net.DatagramPacket;
+import java.net.InetAddress;
+import java.net.MulticastSocket;
+
+import org.apache.catalina.tribes.MembershipListener;
+import java.util.Arrays;
+import java.net.SocketTimeoutException;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.Channel;
+import java.net.InetSocketAddress;
+
+/**
+ * A <b>membership</b> implementation using simple multicast.
+ * This is the representation of a multicast membership service.
+ * This class is responsible for maintaining a list of active cluster nodes in the cluster.
+ * If a node fails to send out a heartbeat, the node will be dismissed.
+ * This is the low level implementation that handles the multicasting sockets.
+ * Need to fix this, could use java.nio and only need one thread to send and receive, or
+ * just use a timeout on the receive
+ * @author Filip Hanik
+ * @version $Revision: 356540 $, $Date: 2005-12-13 10:53:40 -0600 (Tue, 13 Dec 2005) $
+ */
+public class McastServiceImpl
+{
+    private static org.apache.juli.logging.Log log =
+        org.apache.juli.logging.LogFactory.getLog( McastService.class );
+    
+    protected static int MAX_PACKET_SIZE = 65535;
+    /**
+     * Internal flag used for the listen thread that listens to the multicasting socket.
+     */
+    protected boolean doRunSender = false;
+    protected boolean doRunReceiver = false;
+    protected int startLevel = 0;
+    /**
+     * Socket that we intend to listen to
+     */
+    protected MulticastSocket socket;
+    /**
+     * The local member that we intend to broad cast over and over again
+     */
+    protected MemberImpl member;
+    /**
+     * The multicast address
+     */
+    protected InetAddress address;
+    /**
+     * The multicast port
+     */
+    protected int port;
+    /**
+     * The time it takes for a member to expire.
+     */
+    protected long timeToExpiration;
+    /**
+     * How often to we send out a broadcast saying we are alive, must be smaller than timeToExpiration
+     */
+    protected long sendFrequency;
+    /**
+     * Reuse the sendPacket, no need to create a new one everytime
+     */
+    protected DatagramPacket sendPacket;
+    /**
+     * Reuse the receivePacket, no need to create a new one everytime
+     */
+    protected DatagramPacket receivePacket;
+    /**
+     * The membership, used so that we calculate memberships when they arrive or don't arrive
+     */
+    protected Membership membership;
+    /**
+     * The actual listener, for callback when shits goes down
+     */
+    protected MembershipListener service;
+    /**
+     * Thread to listen for pings
+     */
+    protected ReceiverThread receiver;
+    /**
+     * Thread to send pings
+     */
+    protected SenderThread sender;
+
+    /**
+     * When was the service started
+     */
+    protected long serviceStartTime = System.currentTimeMillis();
+    
+    /**
+     * Time to live for the multicast packets that are being sent out
+     */
+    protected int mcastTTL = -1;
+    /**
+     * Read timeout on the mcast socket
+     */
+    protected int mcastSoTimeout = -1;
+    /**
+     * bind address
+     */
+    protected InetAddress mcastBindAddress = null;
+    
+    /**
+     * Create a new mcast service impl
+     * @param member - the local member
+     * @param sendFrequency - the time (ms) in between pings sent out
+     * @param expireTime - the time (ms) for a member to expire
+     * @param port - the mcast port
+     * @param bind - the bind address (not sure this is used yet)
+     * @param mcastAddress - the mcast address
+     * @param service - the callback service
+     * @throws IOException
+     */
+    public McastServiceImpl(
+        MemberImpl member,
+        long sendFrequency,
+        long expireTime,
+        int port,
+        InetAddress bind,
+        InetAddress mcastAddress,
+        int ttl,
+        int soTimeout,
+        MembershipListener service)
+    throws IOException {
+        this.member = member;
+        this.address = mcastAddress;
+        this.port = port;
+        this.mcastSoTimeout = soTimeout;
+        this.mcastTTL = ttl;
+        this.mcastBindAddress = bind;
+        this.timeToExpiration = expireTime;
+        this.service = service;
+        this.sendFrequency = sendFrequency;
+        setupSocket();
+        sendPacket = new DatagramPacket(new byte[MAX_PACKET_SIZE],MAX_PACKET_SIZE);
+        sendPacket.setAddress(address);
+        sendPacket.setPort(port);
+        receivePacket = new DatagramPacket(new byte[MAX_PACKET_SIZE],MAX_PACKET_SIZE);
+        receivePacket.setAddress(address);
+        receivePacket.setPort(port);
+        membership = new Membership(member);
+    }
+    
+    protected void setupSocket() throws IOException {
+        if (mcastBindAddress != null) socket = new MulticastSocket(new InetSocketAddress(mcastBindAddress, port));
+        else socket = new MulticastSocket(port);
+        socket.setLoopbackMode(false); //hint that we don't need loop back messages
+        if (mcastBindAddress != null) {
+			if(log.isInfoEnabled())
+                log.info("Setting multihome multicast interface to:" +mcastBindAddress);
+            socket.setInterface(mcastBindAddress);
+        } //end if
+        //force a so timeout so that we don't block forever
+        if ( mcastSoTimeout <= 0 ) mcastSoTimeout = (int)sendFrequency;
+        if(log.isInfoEnabled())
+            log.info("Setting cluster mcast soTimeout to "+mcastSoTimeout);
+        socket.setSoTimeout(mcastSoTimeout);
+
+        if ( mcastTTL >= 0 ) {
+			if(log.isInfoEnabled())
+                log.info("Setting cluster mcast TTL to " + mcastTTL);
+            socket.setTimeToLive(mcastTTL);
+        }
+    }
+    
+    
+
+    /**
+     * Start the service
+     * @param level 1 starts the receiver, level 2 starts the sender
+     * @throws IOException if the service fails to start
+     * @throws IllegalStateException if the service is already started
+     */
+    public synchronized void start(int level) throws IOException {
+        boolean valid = false;
+        if ( (level & Channel.MBR_RX_SEQ)==Channel.MBR_RX_SEQ ) {
+            if ( receiver != null ) throw new IllegalStateException("McastService.receive already running.");
+            if ( sender == null ) socket.joinGroup(address);
+            doRunReceiver = true;
+            receiver = new ReceiverThread();
+            receiver.setDaemon(true);
+            receiver.start();
+            valid = true;
+        } 
+        if ( (level & Channel.MBR_TX_SEQ)==Channel.MBR_TX_SEQ ) {
+            if ( sender != null ) throw new IllegalStateException("McastService.send already running.");
+            if ( receiver == null ) socket.joinGroup(address);
+            //make sure at least one packet gets out there
+            send(false);
+            doRunSender = true;
+            serviceStartTime = System.currentTimeMillis();
+            sender = new SenderThread(sendFrequency);
+            sender.setDaemon(true);
+            sender.start();
+            //we have started the receiver, but not yet waited for membership to establish
+            valid = true;
+        } 
+        if (!valid) {
+            throw new IllegalArgumentException("Invalid start level. Only acceptable levels are Channel.MBR_RX_SEQ and Channel.MBR_TX_SEQ");
+        }
+        //pause, once or twice
+        waitForMembers(level);
+        startLevel = (startLevel | level);
+    }
+
+    private void waitForMembers(int level) {
+        long memberwait = sendFrequency*2;
+        if(log.isInfoEnabled())
+            log.info("Sleeping for "+memberwait+" milliseconds to establish cluster membership, start level:"+level);
+        try {Thread.sleep(memberwait);}catch (InterruptedException ignore){}
+        if(log.isInfoEnabled())
+            log.info("Done sleeping, membership established, start level:"+level);
+    }
+
+    /**
+     * Stops the service
+     * @throws IOException if the service fails to disconnect from the sockets
+     */
+    public synchronized boolean stop(int level) throws IOException {
+        boolean valid = false;
+        
+        if ( (level & Channel.MBR_RX_SEQ)==Channel.MBR_RX_SEQ ) {
+            valid = true;
+            doRunReceiver = false;
+            if ( receiver !=null ) receiver.interrupt();
+            receiver = null;
+        } 
+        if ( (level & Channel.MBR_TX_SEQ)==Channel.MBR_TX_SEQ ) {
+            valid = true;
+            doRunSender = false;
+            if ( sender != null )sender.interrupt();
+            sender = null;
+        } 
+        
+        if (!valid) {
+            throw new IllegalArgumentException("Invalid stop level. Only acceptable levels are Channel.MBR_RX_SEQ and Channel.MBR_TX_SEQ");
+        }
+        startLevel = (startLevel & (~level));
+        //we're shutting down, send a shutdown message and close the socket
+        if ( startLevel == 0 ) {
+            //send a stop message
+            member.setCommand(Member.SHUTDOWN_PAYLOAD);
+            member.getData(true, true);
+            send(false);
+            //leave mcast group
+            try {socket.leaveGroup(address);}catch ( Exception ignore){}
+            serviceStartTime = Long.MAX_VALUE;
+        }
+        return (startLevel == 0);
+    }
+
+    /**
+     * Receive a datagram packet, locking wait
+     * @throws IOException
+     */
+    public void receive() throws IOException {
+        try {
+            socket.receive(receivePacket);
+            if(receivePacket.getLength() > MAX_PACKET_SIZE) {
+                log.error("Multicast packet received was too long, dropping package:"+receivePacket.getLength());
+            } else {
+                byte[] data = new byte[receivePacket.getLength()];
+                System.arraycopy(receivePacket.getData(), receivePacket.getOffset(), data, 0, data.length);
+                final MemberImpl m = MemberImpl.getMember(data);
+                if (log.isTraceEnabled()) log.trace("Mcast receive ping from member " + m);
+                Thread t = null;
+                if (Arrays.equals(m.getCommand(), Member.SHUTDOWN_PAYLOAD)) {
+                    if (log.isDebugEnabled()) log.debug("Member has shutdown:" + m);
+                    membership.removeMember(m);
+                    t = new Thread() {
+                        public void run() {
+                            service.memberDisappeared(m);
+                        }
+                    };
+                } else if (membership.memberAlive(m)) {
+                    if (log.isDebugEnabled()) log.debug("Mcast add member " + m);
+                    t = new Thread() {
+                        public void run() {
+                            service.memberAdded(m);
+                        }
+                    };
+                } //end if
+                if ( t != null ) t.start();
+            }
+        } catch (SocketTimeoutException x ) { 
+            //do nothing, this is normal, we don't want to block forever
+            //since the receive thread is the same thread
+            //that does membership expiration
+        }
+        checkExpired();
+    }
+    
+    protected Object expiredMutex = new Object();
+    protected void checkExpired() {
+        synchronized (expiredMutex) {
+            MemberImpl[] expired = membership.expire(timeToExpiration);
+            for (int i = 0; i < expired.length; i++) {
+                final MemberImpl member = expired[i];
+                if (log.isDebugEnabled())
+                    log.debug("Mcast exipre  member " + expired[i]);
+                try {
+                    Thread t = new Thread() {
+                        public void run() {
+                            service.memberDisappeared(member);
+                        }
+                    };
+                    t.start();
+                } catch (Exception x) {
+                    log.error("Unable to process member disappeared message.", x);
+                }
+            }
+        }
+    }
+
+    /**
+     * Send a ping
+     * @throws Exception
+     */ 
+    public void send(boolean checkexpired) throws IOException{
+        //ignore if we haven't started the sender
+        //if ( (startLevel&Channel.MBR_TX_SEQ) != Channel.MBR_TX_SEQ ) return;
+        member.inc();
+        if(log.isTraceEnabled())
+            log.trace("Mcast send ping from member " + member);
+        byte[] data = member.getData();
+        DatagramPacket p = new DatagramPacket(data,data.length);
+        p.setAddress(address);
+        p.setPort(port);
+        socket.send(p);
+        if ( checkexpired ) checkExpired();
+    }
+
+    public long getServiceStartTime() {
+       return this.serviceStartTime;
+    }
+
+
+    public class ReceiverThread extends Thread {
+        public ReceiverThread() {
+            super();
+            setName("Cluster-MembershipReceiver");
+        }
+        public void run() {
+            while ( doRunReceiver ) {
+                try {
+                    receive();
+                } catch ( ArrayIndexOutOfBoundsException ax ) {
+                    //we can ignore this, as it means we have an invalid package
+                    //but we will log it to debug
+                    if ( log.isDebugEnabled() )
+                        log.debug("Invalid member mcast package.",ax);
+                } catch ( Exception x ) {
+                    log.warn("Error receiving mcast package. Sleeping 500ms",x);
+                    try { Thread.sleep(500); } catch ( Exception ignore ){}
+                    
+                }
+            }
+        }
+    }//class ReceiverThread
+
+    public class SenderThread extends Thread {
+        long time;
+        public SenderThread(long time) {
+            this.time = time;
+            setName("Cluster-MembershipSender");
+
+        }
+        public void run() {
+            while ( doRunSender ) {
+                try {
+                    send(true);
+                } catch ( Exception x ) {
+                    log.warn("Unable to send mcast message.",x);
+                }
+                try { Thread.sleep(time); } catch ( Exception ignore ) {}
+            }
+        }
+    }//class SenderThread
+}

==================================================
Membership.java
index eeae000405..7728fcd80f 100644
--- a/java/org/apache/catalina/tribes/membership/MemberImpl.java
+++ b/java/org/apache/catalina/tribes/membership/MemberImpl.java
@@ -1,596 +1,597 @@
-/*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.membership;
-
-import java.io.IOException;
-import java.io.ObjectInput;
-import java.io.ObjectOutput;
-import java.util.Arrays;
-
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.io.XByteBuffer;
-import org.apache.catalina.tribes.transport.SenderState;
-
-/**
- * A <b>membership</b> implementation using simple multicast.
- * This is the representation of a multicast member.
- * Carries the host, and port of the this or other cluster nodes.
- *
- * @author Filip Hanik
- * @version $Revision: 304032 $, $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
- */
-public class MemberImpl implements Member, java.io.Externalizable {
-
-    /**
-     * Public properties specific to this implementation
-     */
-    public static final transient String TCP_LISTEN_PORT = "tcpListenPort";
-    public static final transient String TCP_LISTEN_HOST = "tcpListenHost";
-    public static final transient String MEMBER_NAME = "memberName";
-    
-    public static final transient byte[] TRIBES_MBR_BEGIN = new byte[] {84, 82, 73, 66, 69, 83, 45, 66};
-    public static final transient byte[] TRIBES_MBR_END   = new byte[] {84, 82, 73, 66, 69, 83, 45, 69};
-    
-    /**
-     * The listen host for this member
-     */
-    protected byte[] host;
-    protected transient String hostname;
-    /**
-     * The tcp listen port for this member
-     */
-    protected int port;
-    
-    /**
-     * The tcp/SSL listen port for this member
-     */
-    protected int securePort = -1;
-
-    /**
-     * Counter for how many broadcast messages have been sent from this member
-     */
-    protected int msgCount = 0;
-    /**
-     * The number of milliseconds since this members was
-     * created, is kept track of using the start time
-     */
-    protected long memberAliveTime = 0;
-    
-    /**
-     * For the local member only
-     */
-    protected transient long serviceStartTime;
-    
-    /**
-     * To avoid serialization over and over again, once the local dataPkg
-     * has been set, we use that to transmit data
-     */
-    protected transient byte[] dataPkg = null;
-
-    /**
-     * Unique session Id for this member
-     */
-    protected byte[] uniqueId = new byte[16];
-    
-    /**
-     * Custom payload that an app framework can broadcast
-     * Also used to transport stop command.
-     */
-    protected byte[] payload = new byte[0];
-    
-    /**
-     * Command, so that the custom payload doesn't have to be used
-     * This is for internal tribes use, such as SHUTDOWN_COMMAND
-     */
-    protected byte[] command = new byte[0];
-
-    /**
-     * Domain if we want to filter based on domain.
-     */
-    protected byte[] domain = new byte[0];
-    
-    /**
-     * Empty constructor for serialization
-     */
-    public MemberImpl() {
-        
-    }
-
-    /**
-     * Construct a new member object
-     * @param name - the name of this member, cluster unique
-     * @param domain - the cluster domain name of this member
-     * @param host - the tcp listen host
-     * @param port - the tcp listen port
-     */
-    public MemberImpl(String host,
-                      int port,
-                      long aliveTime) throws IOException {
-        setHostname(host);
-        this.port = port;
-        this.memberAliveTime=aliveTime;
-    }
-    
-    public MemberImpl(String host,
-                      int port,
-                      long aliveTime,
-                      byte[] payload) throws IOException {
-        this(host,port,aliveTime);
-        setPayload(payload);
-    }
-    
-    public boolean isReady() {
-        return SenderState.getSenderState(this).isReady();
-    }
-    public boolean isSuspect() {
-        return SenderState.getSenderState(this).isSuspect();
-    }
-    public boolean isFailing() {
-        return SenderState.getSenderState(this).isFailing();
-    }
-
-    /**
-     * Increment the message count.
-     */
-    protected void inc() {
-        msgCount++;
-    }
-
-    /**
-     * Create a data package to send over the wire representing this member.
-     * This is faster than serialization.
-     * @return - the bytes for this member deserialized
-     * @throws Exception
-     */
-    public byte[] getData()  {
-        return getData(true);
-    }
-    /**
-     * Highly optimized version of serializing a member into a byte array
-     * Returns a cached byte[] reference, do not modify this data
-     * @param getalive boolean
-     * @return byte[]
-     */
-    public byte[] getData(boolean getalive)  {
-        return getData(getalive,false);
-    }
-    
-    
-    public int getDataLength() {
-        return TRIBES_MBR_BEGIN.length+ //start pkg
-               4+ //data length
-               8+ //alive time
-               4+ //port
-               4+ //secure port
-               1+ //host length
-               host.length+ //host
-               4+ //command length
-               command.length+ //command
-               4+ //domain length
-               domain.length+ //domain
-               16+ //unique id
-               4+ //payload length
-               payload.length+ //payload
-               TRIBES_MBR_END.length; //end pkg
-    }
-    
-    /**
-     * 
-     * @param getalive boolean - calculate memberAlive time
-     * @param reset boolean - reset the cached data package, and create a new one
-     * @return byte[]
-     */
-    public byte[] getData(boolean getalive, boolean reset)  {
-        if ( reset ) dataPkg = null;
-        //look in cache first
-        if ( dataPkg!=null ) {
-            if ( getalive ) {
-                //you'd be surprised, but System.currentTimeMillis
-                //shows up on the profiler
-                long alive=System.currentTimeMillis()-getServiceStartTime();
-                XByteBuffer.toBytes( (long) alive, dataPkg, TRIBES_MBR_BEGIN.length+4);
-            }
-            return dataPkg;
-        }
-        
-        //package looks like
-        //start package TRIBES_MBR_BEGIN.length
-        //package length - 4 bytes
-        //alive - 8 bytes
-        //port - 4 bytes
-        //secure port - 4 bytes
-        //host length - 1 byte
-        //host - hl bytes
-        //clen - 4 bytes
-        //command - clen bytes
-        //dlen - 4 bytes
-        //domain - dlen bytes
-        //uniqueId - 16 bytes
-        //payload length - 4 bytes
-        //payload plen bytes
-        //end package TRIBES_MBR_END.length
-        byte[] addr = host;
-        long alive=System.currentTimeMillis()-getServiceStartTime();
-        byte hl = (byte)addr.length;
-        byte[] data = new byte[getDataLength()];
-        
-        int bodylength = (getDataLength() - TRIBES_MBR_BEGIN.length - TRIBES_MBR_END.length - 4);
-        
-        int pos = 0;
-        
-        //TRIBES_MBR_BEGIN
-        System.arraycopy(TRIBES_MBR_BEGIN,0,data,pos,TRIBES_MBR_BEGIN.length);
-        pos += TRIBES_MBR_BEGIN.length;
-        
-        //body length
-        XByteBuffer.toBytes(bodylength,data,pos);
-        pos += 4;
-        
-        //alive data
-        XByteBuffer.toBytes((long)alive,data,pos);
-        pos += 8;
-        //port
-        XByteBuffer.toBytes(port,data,pos);
-        pos += 4;
-        //secure port
-        XByteBuffer.toBytes(securePort,data,pos);
-        pos += 4;
-        //host length
-        data[pos++] = hl;
-        //host
-        System.arraycopy(addr,0,data,pos,addr.length);
-        pos+=addr.length;
-        //clen - 4 bytes
-        XByteBuffer.toBytes(command.length,data,pos);
-        pos+=4;
-        //command - clen bytes
-        System.arraycopy(command,0,data,pos,command.length);
-        pos+=command.length;
-        //dlen - 4 bytes
-        XByteBuffer.toBytes(domain.length,data,pos);
-        pos+=4;
-        //domain - dlen bytes
-        System.arraycopy(domain,0,data,pos,domain.length);
-        pos+=domain.length;
-        //unique Id
-        System.arraycopy(uniqueId,0,data,pos,uniqueId.length);
-        pos+=uniqueId.length;
-        //payload
-        XByteBuffer.toBytes(payload.length,data,pos);
-        pos+=4;
-        System.arraycopy(payload,0,data,pos,payload.length);
-        pos+=payload.length;
-        
-        //TRIBES_MBR_END
-        System.arraycopy(TRIBES_MBR_END,0,data,pos,TRIBES_MBR_END.length);
-        pos += TRIBES_MBR_END.length;
-
-        //create local data
-        dataPkg = data;
-        return data;
-    }
-    /**
-     * Deserializes a member from data sent over the wire
-     * @param data - the bytes received
-     * @return a member object.
-     */
-    public static MemberImpl getMember(byte[] data, MemberImpl member) {
-        return getMember(data,0,data.length,member);
-    }
-
-    public static MemberImpl getMember(byte[] data, int offset, int length, MemberImpl member) {
-        //package looks like
-        //start package TRIBES_MBR_BEGIN.length
-        //package length - 4 bytes
-        //alive - 8 bytes
-        //port - 4 bytes
-        //secure port - 4 bytes
-        //host length - 1 byte
-        //host - hl bytes
-        //clen - 4 bytes
-        //command - clen bytes
-        //dlen - 4 bytes
-        //domain - dlen bytes
-        //uniqueId - 16 bytes
-        //payload length - 4 bytes
-        //payload plen bytes
-        //end package TRIBES_MBR_END.length
-
-        int pos = offset;
-        
-        if (XByteBuffer.firstIndexOf(data,offset,TRIBES_MBR_BEGIN)!=pos) {
-            throw new IllegalArgumentException("Invalid package, should start with:"+org.apache.catalina.tribes.util.Arrays.toString(TRIBES_MBR_BEGIN));
-        }
-
-        if ( length < (TRIBES_MBR_BEGIN.length+4) ) {
-            throw new ArrayIndexOutOfBoundsException("Member package to small to validate.");
-        }
-        
-        pos += TRIBES_MBR_BEGIN.length;
-        
-        int bodylength = XByteBuffer.toInt(data,pos);
-        pos += 4;
-        
-        if ( length < (bodylength+4+TRIBES_MBR_BEGIN.length+TRIBES_MBR_END.length) ) {
-            throw new ArrayIndexOutOfBoundsException("Not enough bytes in member package.");
-        }
-        
-        int endpos = pos+bodylength;
-        if (XByteBuffer.firstIndexOf(data,endpos,TRIBES_MBR_END)!=endpos) {
-            throw new IllegalArgumentException("Invalid package, should end with:"+org.apache.catalina.tribes.util.Arrays.toString(TRIBES_MBR_END));
-        }
-
-
-        byte[] alived = new byte[8];
-        System.arraycopy(data, pos, alived, 0, 8);
-        pos += 8;
-        byte[] portd = new byte[4];
-        System.arraycopy(data, pos, portd, 0, 4);
-        pos += 4;
-        
-        byte[] sportd = new byte[4];
-        System.arraycopy(data, pos, sportd, 0, 4);
-        pos += 4;
-
-
-    
-        byte hl = data[pos++];
-        byte[] addr = new byte[hl];
-        System.arraycopy(data, pos, addr, 0, hl);
-        pos += hl;
-    
-        int cl = XByteBuffer.toInt(data, pos);
-        pos += 4;
-    
-        byte[] command = new byte[cl];
-        System.arraycopy(data, pos, command, 0, command.length);
-        pos += command.length;
-    
-        int dl = XByteBuffer.toInt(data, pos);
-        pos += 4;
-    
-        byte[] domain = new byte[dl];
-        System.arraycopy(data, pos, domain, 0, domain.length);
-        pos += domain.length;
-    
-        byte[] uniqueId = new byte[16];
-        System.arraycopy(data, pos, uniqueId, 0, 16);
-        pos += 16;
-    
-        int pl = XByteBuffer.toInt(data, pos);
-        pos += 4;
-    
-        byte[] payload = new byte[pl];
-        System.arraycopy(data, pos, payload, 0, payload.length);
-        pos += payload.length;
-    
-        member.setHost(addr);
-        member.setPort(XByteBuffer.toInt(portd, 0));
-        member.setSecurePort(XByteBuffer.toInt(sportd, 0));
-        member.setMemberAliveTime(XByteBuffer.toLong(alived, 0));
-        member.setUniqueId(uniqueId);
-        member.payload = payload;
-        member.domain = domain;
-        member.command = command;
-    
-        member.dataPkg = new byte[length];
-        System.arraycopy(data, offset, member.dataPkg, 0, length);
-    
-        return member;
-    }
-
-    public static MemberImpl getMember(byte[] data) {
-       return getMember(data,new MemberImpl());
-    }
-
-    /**
-     * Return the name of this object
-     * @return a unique name to the cluster
-     */
-    public String getName() {
-        return "tcp://"+getHostname()+":"+getPort();
-    }
-    
-    /**
-     * Return the listen port of this member
-     * @return - tcp listen port
-     */
-    public int getPort()  {
-        return this.port;
-    }
-
-    /**
-     * Return the TCP listen host for this member
-     * @return IP address or host name
-     */
-    public byte[] getHost()  {
-        return host;
-    }
-    
-    public String getHostname() {
-        if ( this.hostname != null ) return hostname;
-        else {
-            try {
-                this.hostname = java.net.InetAddress.getByAddress(host).getHostName();
-                return this.hostname;
-            }catch ( IOException x ) {
-                throw new RuntimeException("Unable to parse hostname.",x);
-            }
-        }
-    }
-
-    /**
-     * Contains information on how long this member has been online.
-     * The result is the number of milli seconds this member has been
-     * broadcasting its membership to the cluster.
-     * @return nr of milliseconds since this member started.
-     */
-    public long getMemberAliveTime() {
-       return memberAliveTime;
-    }
-
-    public long getServiceStartTime() {
-        return serviceStartTime;
-    }
-
-    public byte[] getUniqueId() {
-        return uniqueId;
-    }
-
-    public byte[] getPayload() {
-        return payload;
-    }
-
-    public byte[] getCommand() {
-        return command;
-    }
-
-    public byte[] getDomain() {
-        return domain;
-    }
-
-    public int getSecurePort() {
-        return securePort;
-    }
-
-    public void setMemberAliveTime(long time) {
-       memberAliveTime=time;
-    }
-
-
-
-    /**
-     * String representation of this object
-     */
-    public String toString()  {
-        StringBuffer buf = new StringBuffer("org.apache.catalina.tribes.membership.MemberImpl[");
-        buf.append(getName()).append(",");
-        buf.append(getHostname()).append(",");
-        buf.append(port).append(", alive=");
-        buf.append(memberAliveTime).append(",");
-        buf.append("id=").append(bToS(this.uniqueId)).append(", ");
-        buf.append("payload=").append(bToS(this.payload,8)).append(", ");
-        buf.append("command=").append(bToS(this.command,8)).append(", ");
-        buf.append("domain=").append(bToS(this.domain,8)).append(", ");
-        buf.append("]");
-        return buf.toString();
-    }
-    public static String bToS(byte[] data) {
-        return bToS(data,data.length);
-    }
-    public static String bToS(byte[] data, int max) {
-        StringBuffer buf = new StringBuffer(4*16);
-        buf.append("{");
-        for (int i=0; data!=null && i<data.length; i++ ) {
-            buf.append(String.valueOf(data[i])).append(" ");
-            if ( i==max ) {
-                buf.append("...("+data.length+")");
-                break;
-            }
-        }
-        buf.append("}");
-        return buf.toString();
-    }
-
-    /**
-     * @see java.lang.Object#hashCode()
-     * @return The hash code
-     */
-    public int hashCode() {
-        return getHost()[0]+getHost()[1]+getHost()[2]+getHost()[3];
-    }
-
-    /**
-     * Returns true if the param o is a McastMember with the same name
-     * @param o
-     */
-    public boolean equals(Object o) {
-        if ( o instanceof MemberImpl )    {
-            return Arrays.equals(this.getHost(),((MemberImpl)o).getHost()) &&
-                   this.getPort() == ((MemberImpl)o).getPort() &&
-                   Arrays.equals(this.getUniqueId(),((MemberImpl)o).getUniqueId());
-        }
-        else
-            return false;
-    }
-    
-    public void setHost(byte[] host) {
-        this.host = host;
-    }
-    
-    public void setHostname(String host) throws IOException {
-        hostname = host;
-        this.host = java.net.InetAddress.getByName(host).getAddress();
-    }
-    
-    public void setMsgCount(int msgCount) {
-        this.msgCount = msgCount;
-    }
-
-    public void setPort(int port) {
-        this.port = port;
-        this.dataPkg = null;
-    }
-
-    public void setServiceStartTime(long serviceStartTime) {
-        this.serviceStartTime = serviceStartTime;
-    }
-
-    public void setUniqueId(byte[] uniqueId) {
-        this.uniqueId = uniqueId!=null?uniqueId:new byte[16];
-        getData(true,true);
-    }
-
-    public void setPayload(byte[] payload) {
-        byte[] oldpayload = this.payload;
-        this.payload = payload!=null?payload:new byte[0];
-        if ( this.getData(true,true).length > McastServiceImpl.MAX_PACKET_SIZE ) {
-            this.payload = oldpayload;
-            throw new IllegalArgumentException("Payload is to large for tribes to handle.");
-        }
-        
-    }
-
-    public void setCommand(byte[] command) {
-        this.command = command!=null?command:new byte[0];
-        getData(true,true);
-    }
-
-    public void setDomain(byte[] domain) {
-        this.domain = domain!=null?domain:new byte[0];
-        getData(true,true);
-    }
-
-    public void setSecurePort(int securePort) {
-        this.securePort = securePort;
-    }
-
-    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
-        int length = in.readInt();
-        byte[] message = new byte[length];
-        in.read(message);
-        getMember(message,this);
-        
-    }
-
-    public void writeExternal(ObjectOutput out) throws IOException {
-        byte[] data = this.getData();
-        out.writeInt(data.length);
-        out.write(data);
-    }
-    
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.membership;
+
+import java.io.IOException;
+import java.io.ObjectInput;
+import java.io.ObjectOutput;
+import java.util.Arrays;
+
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.io.XByteBuffer;
+import org.apache.catalina.tribes.transport.SenderState;
+
+/**
+ * A <b>membership</b> implementation using simple multicast.
+ * This is the representation of a multicast member.
+ * Carries the host, and port of the this or other cluster nodes.
+ *
+ * @author Filip Hanik
+ * @version $Revision: 304032 $, $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
+ */
+public class MemberImpl implements Member, java.io.Externalizable {
+
+    /**
+     * Public properties specific to this implementation
+     */
+    public static final transient String TCP_LISTEN_PORT = "tcpListenPort";
+    public static final transient String TCP_LISTEN_HOST = "tcpListenHost";
+    public static final transient String MEMBER_NAME = "memberName";
+    
+    public static final transient byte[] TRIBES_MBR_BEGIN = new byte[] {84, 82, 73, 66, 69, 83, 45, 66};
+    public static final transient byte[] TRIBES_MBR_END   = new byte[] {84, 82, 73, 66, 69, 83, 45, 69};
+    
+    /**
+     * The listen host for this member
+     */
+    protected byte[] host;
+    protected transient String hostname;
+    /**
+     * The tcp listen port for this member
+     */
+    protected int port;
+    
+    /**
+     * The tcp/SSL listen port for this member
+     */
+    protected int securePort = -1;
+
+    /**
+     * Counter for how many broadcast messages have been sent from this member
+     */
+    protected int msgCount = 0;
+    /**
+     * The number of milliseconds since this members was
+     * created, is kept track of using the start time
+     */
+    protected long memberAliveTime = 0;
+    
+    /**
+     * For the local member only
+     */
+    protected transient long serviceStartTime;
+    
+    /**
+     * To avoid serialization over and over again, once the local dataPkg
+     * has been set, we use that to transmit data
+     */
+    protected transient byte[] dataPkg = null;
+
+    /**
+     * Unique session Id for this member
+     */
+    protected byte[] uniqueId = new byte[16];
+    
+    /**
+     * Custom payload that an app framework can broadcast
+     * Also used to transport stop command.
+     */
+    protected byte[] payload = new byte[0];
+    
+    /**
+     * Command, so that the custom payload doesn't have to be used
+     * This is for internal tribes use, such as SHUTDOWN_COMMAND
+     */
+    protected byte[] command = new byte[0];
+
+    /**
+     * Domain if we want to filter based on domain.
+     */
+    protected byte[] domain = new byte[0];
+    
+    /**
+     * Empty constructor for serialization
+     */
+    public MemberImpl() {
+        
+    }
+
+    /**
+     * Construct a new member object
+     * @param name - the name of this member, cluster unique
+     * @param domain - the cluster domain name of this member
+     * @param host - the tcp listen host
+     * @param port - the tcp listen port
+     */
+    public MemberImpl(String host,
+                      int port,
+                      long aliveTime) throws IOException {
+        setHostname(host);
+        this.port = port;
+        this.memberAliveTime=aliveTime;
+    }
+    
+    public MemberImpl(String host,
+                      int port,
+                      long aliveTime,
+                      byte[] payload) throws IOException {
+        this(host,port,aliveTime);
+        setPayload(payload);
+    }
+    
+    public boolean isReady() {
+        return SenderState.getSenderState(this).isReady();
+    }
+    public boolean isSuspect() {
+        return SenderState.getSenderState(this).isSuspect();
+    }
+    public boolean isFailing() {
+        return SenderState.getSenderState(this).isFailing();
+    }
+
+    /**
+     * Increment the message count.
+     */
+    protected void inc() {
+        msgCount++;
+    }
+
+    /**
+     * Create a data package to send over the wire representing this member.
+     * This is faster than serialization.
+     * @return - the bytes for this member deserialized
+     * @throws Exception
+     */
+    public byte[] getData()  {
+        return getData(true);
+    }
+    /**
+     * Highly optimized version of serializing a member into a byte array
+     * Returns a cached byte[] reference, do not modify this data
+     * @param getalive boolean
+     * @return byte[]
+     */
+    public byte[] getData(boolean getalive)  {
+        return getData(getalive,false);
+    }
+    
+    
+    public int getDataLength() {
+        return TRIBES_MBR_BEGIN.length+ //start pkg
+               4+ //data length
+               8+ //alive time
+               4+ //port
+               4+ //secure port
+               1+ //host length
+               host.length+ //host
+               4+ //command length
+               command.length+ //command
+               4+ //domain length
+               domain.length+ //domain
+               16+ //unique id
+               4+ //payload length
+               payload.length+ //payload
+               TRIBES_MBR_END.length; //end pkg
+    }
+    
+    /**
+     * 
+     * @param getalive boolean - calculate memberAlive time
+     * @param reset boolean - reset the cached data package, and create a new one
+     * @return byte[]
+     */
+    public byte[] getData(boolean getalive, boolean reset)  {
+        if ( reset ) dataPkg = null;
+        //look in cache first
+        if ( dataPkg!=null ) {
+            if ( getalive ) {
+                //you'd be surprised, but System.currentTimeMillis
+                //shows up on the profiler
+                long alive=System.currentTimeMillis()-getServiceStartTime();
+                XByteBuffer.toBytes( (long) alive, dataPkg, TRIBES_MBR_BEGIN.length+4);
+            }
+            return dataPkg;
+        }
+        
+        //package looks like
+        //start package TRIBES_MBR_BEGIN.length
+        //package length - 4 bytes
+        //alive - 8 bytes
+        //port - 4 bytes
+        //secure port - 4 bytes
+        //host length - 1 byte
+        //host - hl bytes
+        //clen - 4 bytes
+        //command - clen bytes
+        //dlen - 4 bytes
+        //domain - dlen bytes
+        //uniqueId - 16 bytes
+        //payload length - 4 bytes
+        //payload plen bytes
+        //end package TRIBES_MBR_END.length
+        byte[] addr = host;
+        long alive=System.currentTimeMillis()-getServiceStartTime();
+        byte hl = (byte)addr.length;
+        byte[] data = new byte[getDataLength()];
+        
+        int bodylength = (getDataLength() - TRIBES_MBR_BEGIN.length - TRIBES_MBR_END.length - 4);
+        
+        int pos = 0;
+        
+        //TRIBES_MBR_BEGIN
+        System.arraycopy(TRIBES_MBR_BEGIN,0,data,pos,TRIBES_MBR_BEGIN.length);
+        pos += TRIBES_MBR_BEGIN.length;
+        
+        //body length
+        XByteBuffer.toBytes(bodylength,data,pos);
+        pos += 4;
+        
+        //alive data
+        XByteBuffer.toBytes((long)alive,data,pos);
+        pos += 8;
+        //port
+        XByteBuffer.toBytes(port,data,pos);
+        pos += 4;
+        //secure port
+        XByteBuffer.toBytes(securePort,data,pos);
+        pos += 4;
+        //host length
+        data[pos++] = hl;
+        //host
+        System.arraycopy(addr,0,data,pos,addr.length);
+        pos+=addr.length;
+        //clen - 4 bytes
+        XByteBuffer.toBytes(command.length,data,pos);
+        pos+=4;
+        //command - clen bytes
+        System.arraycopy(command,0,data,pos,command.length);
+        pos+=command.length;
+        //dlen - 4 bytes
+        XByteBuffer.toBytes(domain.length,data,pos);
+        pos+=4;
+        //domain - dlen bytes
+        System.arraycopy(domain,0,data,pos,domain.length);
+        pos+=domain.length;
+        //unique Id
+        System.arraycopy(uniqueId,0,data,pos,uniqueId.length);
+        pos+=uniqueId.length;
+        //payload
+        XByteBuffer.toBytes(payload.length,data,pos);
+        pos+=4;
+        System.arraycopy(payload,0,data,pos,payload.length);
+        pos+=payload.length;
+        
+        //TRIBES_MBR_END
+        System.arraycopy(TRIBES_MBR_END,0,data,pos,TRIBES_MBR_END.length);
+        pos += TRIBES_MBR_END.length;
+
+        //create local data
+        dataPkg = data;
+        return data;
+    }
+    /**
+     * Deserializes a member from data sent over the wire
+     * @param data - the bytes received
+     * @return a member object.
+     */
+    public static MemberImpl getMember(byte[] data, MemberImpl member) {
+        return getMember(data,0,data.length,member);
+    }
+
+    public static MemberImpl getMember(byte[] data, int offset, int length, MemberImpl member) {
+        //package looks like
+        //start package TRIBES_MBR_BEGIN.length
+        //package length - 4 bytes
+        //alive - 8 bytes
+        //port - 4 bytes
+        //secure port - 4 bytes
+        //host length - 1 byte
+        //host - hl bytes
+        //clen - 4 bytes
+        //command - clen bytes
+        //dlen - 4 bytes
+        //domain - dlen bytes
+        //uniqueId - 16 bytes
+        //payload length - 4 bytes
+        //payload plen bytes
+        //end package TRIBES_MBR_END.length
+
+        int pos = offset;
+        
+        if (XByteBuffer.firstIndexOf(data,offset,TRIBES_MBR_BEGIN)!=pos) {
+            throw new IllegalArgumentException("Invalid package, should start with:"+org.apache.catalina.tribes.util.Arrays.toString(TRIBES_MBR_BEGIN));
+        }
+
+        if ( length < (TRIBES_MBR_BEGIN.length+4) ) {
+            throw new ArrayIndexOutOfBoundsException("Member package to small to validate.");
+        }
+        
+        pos += TRIBES_MBR_BEGIN.length;
+        
+        int bodylength = XByteBuffer.toInt(data,pos);
+        pos += 4;
+        
+        if ( length < (bodylength+4+TRIBES_MBR_BEGIN.length+TRIBES_MBR_END.length) ) {
+            throw new ArrayIndexOutOfBoundsException("Not enough bytes in member package.");
+        }
+        
+        int endpos = pos+bodylength;
+        if (XByteBuffer.firstIndexOf(data,endpos,TRIBES_MBR_END)!=endpos) {
+            throw new IllegalArgumentException("Invalid package, should end with:"+org.apache.catalina.tribes.util.Arrays.toString(TRIBES_MBR_END));
+        }
+
+
+        byte[] alived = new byte[8];
+        System.arraycopy(data, pos, alived, 0, 8);
+        pos += 8;
+        byte[] portd = new byte[4];
+        System.arraycopy(data, pos, portd, 0, 4);
+        pos += 4;
+        
+        byte[] sportd = new byte[4];
+        System.arraycopy(data, pos, sportd, 0, 4);
+        pos += 4;
+
+
+    
+        byte hl = data[pos++];
+        byte[] addr = new byte[hl];
+        System.arraycopy(data, pos, addr, 0, hl);
+        pos += hl;
+    
+        int cl = XByteBuffer.toInt(data, pos);
+        pos += 4;
+    
+        byte[] command = new byte[cl];
+        System.arraycopy(data, pos, command, 0, command.length);
+        pos += command.length;
+    
+        int dl = XByteBuffer.toInt(data, pos);
+        pos += 4;
+    
+        byte[] domain = new byte[dl];
+        System.arraycopy(data, pos, domain, 0, domain.length);
+        pos += domain.length;
+    
+        byte[] uniqueId = new byte[16];
+        System.arraycopy(data, pos, uniqueId, 0, 16);
+        pos += 16;
+    
+        int pl = XByteBuffer.toInt(data, pos);
+        pos += 4;
+    
+        byte[] payload = new byte[pl];
+        System.arraycopy(data, pos, payload, 0, payload.length);
+        pos += payload.length;
+    
+        member.setHost(addr);
+        member.setPort(XByteBuffer.toInt(portd, 0));
+        member.setSecurePort(XByteBuffer.toInt(sportd, 0));
+        member.setMemberAliveTime(XByteBuffer.toLong(alived, 0));
+        member.setUniqueId(uniqueId);
+        member.payload = payload;
+        member.domain = domain;
+        member.command = command;
+    
+        member.dataPkg = new byte[length];
+        System.arraycopy(data, offset, member.dataPkg, 0, length);
+    
+        return member;
+    }
+
+    public static MemberImpl getMember(byte[] data) {
+       return getMember(data,new MemberImpl());
+    }
+
+    /**
+     * Return the name of this object
+     * @return a unique name to the cluster
+     */
+    public String getName() {
+        return "tcp://"+getHostname()+":"+getPort();
+    }
+    
+    /**
+     * Return the listen port of this member
+     * @return - tcp listen port
+     */
+    public int getPort()  {
+        return this.port;
+    }
+
+    /**
+     * Return the TCP listen host for this member
+     * @return IP address or host name
+     */
+    public byte[] getHost()  {
+        return host;
+    }
+    
+    public String getHostname() {
+        if ( this.hostname != null ) return hostname;
+        else {
+            try {
+                this.hostname = java.net.InetAddress.getByAddress(host).getHostName();
+                return this.hostname;
+            }catch ( IOException x ) {
+                throw new RuntimeException("Unable to parse hostname.",x);
+            }
+        }
+    }
+
+    /**
+     * Contains information on how long this member has been online.
+     * The result is the number of milli seconds this member has been
+     * broadcasting its membership to the cluster.
+     * @return nr of milliseconds since this member started.
+     */
+    public long getMemberAliveTime() {
+       return memberAliveTime;
+    }
+
+    public long getServiceStartTime() {
+        return serviceStartTime;
+    }
+
+    public byte[] getUniqueId() {
+        return uniqueId;
+    }
+
+    public byte[] getPayload() {
+        return payload;
+    }
+
+    public byte[] getCommand() {
+        return command;
+    }
+
+    public byte[] getDomain() {
+        return domain;
+    }
+
+    public int getSecurePort() {
+        return securePort;
+    }
+
+    public void setMemberAliveTime(long time) {
+       memberAliveTime=time;
+    }
+
+
+
+    /**
+     * String representation of this object
+     */
+    public String toString()  {
+        StringBuffer buf = new StringBuffer("org.apache.catalina.tribes.membership.MemberImpl[");
+        buf.append(getName()).append(",");
+        buf.append(getHostname()).append(",");
+        buf.append(port).append(", alive=");
+        buf.append(memberAliveTime).append(",");
+        buf.append("id=").append(bToS(this.uniqueId)).append(", ");
+        buf.append("payload=").append(bToS(this.payload,8)).append(", ");
+        buf.append("command=").append(bToS(this.command,8)).append(", ");
+        buf.append("domain=").append(bToS(this.domain,8)).append(", ");
+        buf.append("]");
+        return buf.toString();
+    }
+    public static String bToS(byte[] data) {
+        return bToS(data,data.length);
+    }
+    public static String bToS(byte[] data, int max) {
+        StringBuffer buf = new StringBuffer(4*16);
+        buf.append("{");
+        for (int i=0; data!=null && i<data.length; i++ ) {
+            buf.append(String.valueOf(data[i])).append(" ");
+            if ( i==max ) {
+                buf.append("...("+data.length+")");
+                break;
+            }
+        }
+        buf.append("}");
+        return buf.toString();
+    }
+
+    /**
+     * @see java.lang.Object#hashCode()
+     * @return The hash code
+     */
+    public int hashCode() {
+        return getHost()[0]+getHost()[1]+getHost()[2]+getHost()[3];
+    }
+
+    /**
+     * Returns true if the param o is a McastMember with the same name
+     * @param o
+     */
+    public boolean equals(Object o) {
+        if ( o instanceof MemberImpl )    {
+            return Arrays.equals(this.getHost(),((MemberImpl)o).getHost()) &&
+                   this.getPort() == ((MemberImpl)o).getPort() &&
+                   Arrays.equals(this.getUniqueId(),((MemberImpl)o).getUniqueId());
+        }
+        else
+            return false;
+    }
+    
+    public void setHost(byte[] host) {
+        this.host = host;
+    }
+    
+    public void setHostname(String host) throws IOException {
+        hostname = host;
+        this.host = java.net.InetAddress.getByName(host).getAddress();
+    }
+    
+    public void setMsgCount(int msgCount) {
+        this.msgCount = msgCount;
+    }
+
+    public void setPort(int port) {
+        this.port = port;
+        this.dataPkg = null;
+    }
+
+    public void setServiceStartTime(long serviceStartTime) {
+        this.serviceStartTime = serviceStartTime;
+    }
+
+    public void setUniqueId(byte[] uniqueId) {
+        this.uniqueId = uniqueId!=null?uniqueId:new byte[16];
+        getData(true,true);
+    }
+
+    public void setPayload(byte[] payload) {
+        byte[] oldpayload = this.payload;
+        this.payload = payload!=null?payload:new byte[0];
+        if ( this.getData(true,true).length > McastServiceImpl.MAX_PACKET_SIZE ) {
+            this.payload = oldpayload;
+            throw new IllegalArgumentException("Payload is to large for tribes to handle.");
+        }
+        
+    }
+
+    public void setCommand(byte[] command) {
+        this.command = command!=null?command:new byte[0];
+        getData(true,true);
+    }
+
+    public void setDomain(byte[] domain) {
+        this.domain = domain!=null?domain:new byte[0];
+        getData(true,true);
+    }
+
+    public void setSecurePort(int securePort) {
+        this.securePort = securePort;
+    }
+
+    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
+        int length = in.readInt();
+        byte[] message = new byte[length];
+        in.read(message);
+        getMember(message,this);
+        
+    }
+
+    public void writeExternal(ObjectOutput out) throws IOException {
+        byte[] data = this.getData();
+        out.writeInt(data.length);
+        out.write(data);
+    }
+    
+}

==================================================
StaticMember.java
index c4cabdead3..869df340ff 100644
--- a/java/org/apache/catalina/tribes/membership/Membership.java
+++ b/java/org/apache/catalina/tribes/membership/Membership.java
@@ -1,324 +1,325 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.membership;
-
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
-
-import org.apache.catalina.tribes.Member;
-import java.util.Comparator;
-
-/**
- * A <b>membership</b> implementation using simple multicast.
- * This is the representation of a multicast membership.
- * This class is responsible for maintaining a list of active cluster nodes in the cluster.
- * If a node fails to send out a heartbeat, the node will be dismissed.
- *
- * @author Filip Hanik
- * @author Peter Rossbach
- * @version $Revision: 356540 $, $Date: 2005-12-13 10:53:40 -0600 (Tue, 13 Dec 2005) $
- */
-public class Membership
-{
-    protected static final MemberImpl[] EMPTY_MEMBERS = new MemberImpl[0];
-    
-    /**
-     * The name of this membership, has to be the same as the name for the local
-     * member
-     */
-    protected MemberImpl local;
-    
-    /**
-     * A map of all the members in the cluster.
-     */
-    protected HashMap map = new HashMap();
-    
-    /**
-     * A list of all the members in the cluster.
-     */
-    protected MemberImpl[] members = EMPTY_MEMBERS;
-    
-    /**
-      * sort members by alive time
-      */
-    protected Comparator memberComparator = new MemberComparator();
-
-    public Object clone() {
-        synchronized (members) {
-            Membership clone = new Membership(local, memberComparator);
-            clone.map = (HashMap) map.clone();
-            clone.members = new MemberImpl[members.length];
-            System.arraycopy(members,0,clone.members,0,members.length);
-            return clone;
-        }
-    }
-
-    /**
-     * Constructs a new membership
-     * @param name - has to be the name of the local member. Used to filter the local member from the cluster membership
-     */
-    public Membership(MemberImpl local, boolean includeLocal) {
-        this.local = local;
-        if ( includeLocal ) addMember(local);
-    }
-
-    public Membership(MemberImpl local) {
-        this(local,false);
-    }
-
-    public Membership(MemberImpl local, Comparator comp) {
-        this(local,comp,false);
-    }
-
-    public Membership(MemberImpl local, Comparator comp, boolean includeLocal) {
-        this(local,includeLocal);
-        this.memberComparator = comp;
-    }
-    /**
-     * Reset the membership and start over fresh.
-     * Ie, delete all the members and wait for them to ping again and join this membership
-     */
-    public synchronized void reset() {
-        map.clear();
-        members = EMPTY_MEMBERS ;
-    }
-
-    /**
-     * Notify the membership that this member has announced itself.
-     *
-     * @param member - the member that just pinged us
-     * @return - true if this member is new to the cluster, false otherwise.
-     * @return - false if this member is the local member or updated.
-     */
-    public synchronized boolean memberAlive(MemberImpl member) {
-        boolean result = false;
-        //ignore ourselves
-        if (  member.equals(local) ) return result;
-
-        //return true if the membership has changed
-        MbrEntry entry = (MbrEntry)map.get(member);
-        if ( entry == null ) {
-            entry = addMember(member);
-            result = true;
-       } else {
-            //update the member alive time
-            MemberImpl updateMember = entry.getMember() ;
-            if(updateMember.getMemberAliveTime() != member.getMemberAliveTime()) {
-                //update fields that can change
-                updateMember.setMemberAliveTime(member.getMemberAliveTime());
-                updateMember.setPayload(member.getPayload());
-                updateMember.setCommand(member.getCommand());
-                Arrays.sort(members, memberComparator);
-            }
-        }
-        entry.accessed();
-        return result;
-    }
-
-    /**
-     * Add a member to this component and sort array with memberComparator
-     * @param member The member to add
-     */
-    public synchronized MbrEntry addMember(MemberImpl member) {
-      synchronized (members) {
-          MbrEntry entry = new MbrEntry(member);
-          if (!map.containsKey(member) ) {
-              map.put(member, entry);
-              MemberImpl results[] = new MemberImpl[members.length + 1];
-              for (int i = 0; i < members.length; i++) results[i] = members[i];
-              results[members.length] = member;
-              members = results;
-              Arrays.sort(members, memberComparator);
-          }
-          return entry;
-      }
-    }
-    
-    /**
-     * Remove a member from this component.
-     * 
-     * @param member The member to remove
-     */
-    public void removeMember(MemberImpl member) {
-        map.remove(member);
-        synchronized (members) {
-            int n = -1;
-            for (int i = 0; i < members.length; i++) {
-                if (members[i] == member || members[i].equals(member)) {
-                    n = i;
-                    break;
-                }
-            }
-            if (n < 0) return;
-            MemberImpl results[] = new MemberImpl[members.length - 1];
-            int j = 0;
-            for (int i = 0; i < members.length; i++) {
-                if (i != n)
-                    results[j++] = members[i];
-            }
-            members = results;
-        }
-    }
-    
-    /**
-     * Runs a refresh cycle and returns a list of members that has expired.
-     * This also removes the members from the membership, in such a way that
-     * getMembers() = getMembers() - expire()
-     * @param maxtime - the max time a member can remain unannounced before it is considered dead.
-     * @return the list of expired members
-     */
-    public synchronized MemberImpl[] expire(long maxtime) {
-        if(!hasMembers() )
-           return EMPTY_MEMBERS;
-       
-        ArrayList list = null;
-        Iterator i = map.values().iterator();
-        while(i.hasNext()) {
-            MbrEntry entry = (MbrEntry)i.next();
-            if( entry.hasExpired(maxtime) ) {
-                if(list == null) // only need a list when members are expired (smaller gc)
-                    list = new java.util.ArrayList();
-                list.add(entry.getMember());
-            }
-        }
-        
-        if(list != null) {
-            MemberImpl[] result = new MemberImpl[list.size()];
-            list.toArray(result);
-            for( int j=0; j<result.length; j++) {
-                removeMember(result[j]);
-            }
-            return result;
-        } else {
-            return EMPTY_MEMBERS ;
-        }
-    }
-
-    /**
-     * Returning that service has members or not
-     */
-    public boolean hasMembers() {
-        return members.length > 0 ;
-    }
-    
-    
-    public MemberImpl getMember(Member mbr) {
-        if(hasMembers()) {
-            MemberImpl result = null;
-            for ( int i=0; i<this.members.length && result==null; i++ ) {
-                if ( members[i].equals(mbr) ) result = members[i];
-            }//for
-            return result;
-        } else {
-            return null;
-        }
-    }
-    
-    public boolean contains(Member mbr) { 
-        return getMember(mbr)!=null;
-    }
- 
-    /**
-     * Returning a list of all the members in the membership
-     * We not need a copy: add and remove generate new arrays.
-     */
-    public MemberImpl[] getMembers() {
-        if(hasMembers()) {
-            return members;
-        } else {
-            return EMPTY_MEMBERS;
-        }
-    }
-
-    /**
-     * get a copy from all member entries
-     */
-    protected synchronized MbrEntry[] getMemberEntries()
-    {
-        MbrEntry[] result = new MbrEntry[map.size()];
-        java.util.Iterator i = map.entrySet().iterator();
-        int pos = 0;
-        while ( i.hasNext() )
-            result[pos++] = ((MbrEntry)((java.util.Map.Entry)i.next()).getValue());
-        return result;
-    }
-    
-    // --------------------------------------------- Inner Class
-
-    private class MemberComparator implements java.util.Comparator {
-
-        public int compare(Object o1, Object o2) {
-            try {
-                return compare((MemberImpl) o1, (MemberImpl) o2);
-            } catch (ClassCastException x) {
-                return 0;
-            }
-        }
-
-        public int compare(MemberImpl m1, MemberImpl m2) {
-            //longer alive time, means sort first
-            long result = m2.getMemberAliveTime() - m1.getMemberAliveTime();
-            if (result < 0)
-                return -1;
-            else if (result == 0)
-                return 0;
-            else
-                return 1;
-        }
-    }
-    
-    /**
-     * Inner class that represents a member entry
-     */
-    protected static class MbrEntry
-    {
-
-        protected MemberImpl mbr;
-        protected long lastHeardFrom;
-
-        public MbrEntry(MemberImpl mbr) {
-           this.mbr = mbr;
-        }
-
-        /**
-         * Indicate that this member has been accessed.
-         */
-        public void accessed(){
-           lastHeardFrom = System.currentTimeMillis();
-        }
-
-        /**
-         * Return the actual Member object
-         */
-        public MemberImpl getMember() {
-            return mbr;
-        }
-
-        /**
-         * Check if this dude has expired
-         * @param maxtime The time threshold
-         */
-        public boolean hasExpired(long maxtime) {
-            long delta = System.currentTimeMillis() - lastHeardFrom;
-            return delta > maxtime;
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.membership;
+
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+import org.apache.catalina.tribes.Member;
+import java.util.Comparator;
+
+/**
+ * A <b>membership</b> implementation using simple multicast.
+ * This is the representation of a multicast membership.
+ * This class is responsible for maintaining a list of active cluster nodes in the cluster.
+ * If a node fails to send out a heartbeat, the node will be dismissed.
+ *
+ * @author Filip Hanik
+ * @author Peter Rossbach
+ * @version $Revision: 356540 $, $Date: 2005-12-13 10:53:40 -0600 (Tue, 13 Dec 2005) $
+ */
+public class Membership
+{
+    protected static final MemberImpl[] EMPTY_MEMBERS = new MemberImpl[0];
+    
+    /**
+     * The name of this membership, has to be the same as the name for the local
+     * member
+     */
+    protected MemberImpl local;
+    
+    /**
+     * A map of all the members in the cluster.
+     */
+    protected HashMap map = new HashMap();
+    
+    /**
+     * A list of all the members in the cluster.
+     */
+    protected MemberImpl[] members = EMPTY_MEMBERS;
+    
+    /**
+      * sort members by alive time
+      */
+    protected Comparator memberComparator = new MemberComparator();
+
+    public Object clone() {
+        synchronized (members) {
+            Membership clone = new Membership(local, memberComparator);
+            clone.map = (HashMap) map.clone();
+            clone.members = new MemberImpl[members.length];
+            System.arraycopy(members,0,clone.members,0,members.length);
+            return clone;
+        }
+    }
+
+    /**
+     * Constructs a new membership
+     * @param name - has to be the name of the local member. Used to filter the local member from the cluster membership
+     */
+    public Membership(MemberImpl local, boolean includeLocal) {
+        this.local = local;
+        if ( includeLocal ) addMember(local);
+    }
+
+    public Membership(MemberImpl local) {
+        this(local,false);
+    }
+
+    public Membership(MemberImpl local, Comparator comp) {
+        this(local,comp,false);
+    }
+
+    public Membership(MemberImpl local, Comparator comp, boolean includeLocal) {
+        this(local,includeLocal);
+        this.memberComparator = comp;
+    }
+    /**
+     * Reset the membership and start over fresh.
+     * Ie, delete all the members and wait for them to ping again and join this membership
+     */
+    public synchronized void reset() {
+        map.clear();
+        members = EMPTY_MEMBERS ;
+    }
+
+    /**
+     * Notify the membership that this member has announced itself.
+     *
+     * @param member - the member that just pinged us
+     * @return - true if this member is new to the cluster, false otherwise.
+     * @return - false if this member is the local member or updated.
+     */
+    public synchronized boolean memberAlive(MemberImpl member) {
+        boolean result = false;
+        //ignore ourselves
+        if (  member.equals(local) ) return result;
+
+        //return true if the membership has changed
+        MbrEntry entry = (MbrEntry)map.get(member);
+        if ( entry == null ) {
+            entry = addMember(member);
+            result = true;
+       } else {
+            //update the member alive time
+            MemberImpl updateMember = entry.getMember() ;
+            if(updateMember.getMemberAliveTime() != member.getMemberAliveTime()) {
+                //update fields that can change
+                updateMember.setMemberAliveTime(member.getMemberAliveTime());
+                updateMember.setPayload(member.getPayload());
+                updateMember.setCommand(member.getCommand());
+                Arrays.sort(members, memberComparator);
+            }
+        }
+        entry.accessed();
+        return result;
+    }
+
+    /**
+     * Add a member to this component and sort array with memberComparator
+     * @param member The member to add
+     */
+    public synchronized MbrEntry addMember(MemberImpl member) {
+      synchronized (members) {
+          MbrEntry entry = new MbrEntry(member);
+          if (!map.containsKey(member) ) {
+              map.put(member, entry);
+              MemberImpl results[] = new MemberImpl[members.length + 1];
+              for (int i = 0; i < members.length; i++) results[i] = members[i];
+              results[members.length] = member;
+              members = results;
+              Arrays.sort(members, memberComparator);
+          }
+          return entry;
+      }
+    }
+    
+    /**
+     * Remove a member from this component.
+     * 
+     * @param member The member to remove
+     */
+    public void removeMember(MemberImpl member) {
+        map.remove(member);
+        synchronized (members) {
+            int n = -1;
+            for (int i = 0; i < members.length; i++) {
+                if (members[i] == member || members[i].equals(member)) {
+                    n = i;
+                    break;
+                }
+            }
+            if (n < 0) return;
+            MemberImpl results[] = new MemberImpl[members.length - 1];
+            int j = 0;
+            for (int i = 0; i < members.length; i++) {
+                if (i != n)
+                    results[j++] = members[i];
+            }
+            members = results;
+        }
+    }
+    
+    /**
+     * Runs a refresh cycle and returns a list of members that has expired.
+     * This also removes the members from the membership, in such a way that
+     * getMembers() = getMembers() - expire()
+     * @param maxtime - the max time a member can remain unannounced before it is considered dead.
+     * @return the list of expired members
+     */
+    public synchronized MemberImpl[] expire(long maxtime) {
+        if(!hasMembers() )
+           return EMPTY_MEMBERS;
+       
+        ArrayList list = null;
+        Iterator i = map.values().iterator();
+        while(i.hasNext()) {
+            MbrEntry entry = (MbrEntry)i.next();
+            if( entry.hasExpired(maxtime) ) {
+                if(list == null) // only need a list when members are expired (smaller gc)
+                    list = new java.util.ArrayList();
+                list.add(entry.getMember());
+            }
+        }
+        
+        if(list != null) {
+            MemberImpl[] result = new MemberImpl[list.size()];
+            list.toArray(result);
+            for( int j=0; j<result.length; j++) {
+                removeMember(result[j]);
+            }
+            return result;
+        } else {
+            return EMPTY_MEMBERS ;
+        }
+    }
+
+    /**
+     * Returning that service has members or not
+     */
+    public boolean hasMembers() {
+        return members.length > 0 ;
+    }
+    
+    
+    public MemberImpl getMember(Member mbr) {
+        if(hasMembers()) {
+            MemberImpl result = null;
+            for ( int i=0; i<this.members.length && result==null; i++ ) {
+                if ( members[i].equals(mbr) ) result = members[i];
+            }//for
+            return result;
+        } else {
+            return null;
+        }
+    }
+    
+    public boolean contains(Member mbr) { 
+        return getMember(mbr)!=null;
+    }
+ 
+    /**
+     * Returning a list of all the members in the membership
+     * We not need a copy: add and remove generate new arrays.
+     */
+    public MemberImpl[] getMembers() {
+        if(hasMembers()) {
+            return members;
+        } else {
+            return EMPTY_MEMBERS;
+        }
+    }
+
+    /**
+     * get a copy from all member entries
+     */
+    protected synchronized MbrEntry[] getMemberEntries()
+    {
+        MbrEntry[] result = new MbrEntry[map.size()];
+        java.util.Iterator i = map.entrySet().iterator();
+        int pos = 0;
+        while ( i.hasNext() )
+            result[pos++] = ((MbrEntry)((java.util.Map.Entry)i.next()).getValue());
+        return result;
+    }
+    
+    // --------------------------------------------- Inner Class
+
+    private class MemberComparator implements java.util.Comparator {
+
+        public int compare(Object o1, Object o2) {
+            try {
+                return compare((MemberImpl) o1, (MemberImpl) o2);
+            } catch (ClassCastException x) {
+                return 0;
+            }
+        }
+
+        public int compare(MemberImpl m1, MemberImpl m2) {
+            //longer alive time, means sort first
+            long result = m2.getMemberAliveTime() - m1.getMemberAliveTime();
+            if (result < 0)
+                return -1;
+            else if (result == 0)
+                return 0;
+            else
+                return 1;
+        }
+    }
+    
+    /**
+     * Inner class that represents a member entry
+     */
+    protected static class MbrEntry
+    {
+
+        protected MemberImpl mbr;
+        protected long lastHeardFrom;
+
+        public MbrEntry(MemberImpl mbr) {
+           this.mbr = mbr;
+        }
+
+        /**
+         * Indicate that this member has been accessed.
+         */
+        public void accessed(){
+           lastHeardFrom = System.currentTimeMillis();
+        }
+
+        /**
+         * Return the actual Member object
+         */
+        public MemberImpl getMember() {
+            return mbr;
+        }
+
+        /**
+         * Check if this dude has expired
+         * @param maxtime The time threshold
+         */
+        public boolean hasExpired(long maxtime) {
+            long delta = System.currentTimeMillis() - lastHeardFrom;
+            return delta > maxtime;
+        }
+    }
+}

==================================================
AbstractReplicatedMap.java
index a208f3322d..4d51b9f7ee 100644
--- a/java/org/apache/catalina/tribes/membership/StaticMember.java
+++ b/java/org/apache/catalina/tribes/membership/StaticMember.java
@@ -1,79 +1,80 @@
-/*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.membership;
-
-import java.io.IOException;
-import org.apache.catalina.tribes.util.UUIDGenerator;
-import org.apache.catalina.tribes.util.Arrays;
-
-/**
- * <p>Title: </p>
- *
- * <p>Description: </p>
- *
- * <p>Copyright: Copyright (c) 2006</p>
- *
- * <p>Company: </p>
- *
- * @author not attributable
- * @version 1.0
- */
-public class StaticMember extends MemberImpl {
-    public StaticMember() {
-        super();
-    }
-
-    public StaticMember(String host, int port, long aliveTime) throws IOException {
-        super(host, port, aliveTime);
-    }
-
-    public StaticMember(String host, int port, long aliveTime, byte[] payload) throws IOException {
-        super(host, port, aliveTime, payload);
-    }
-     
-    /**
-     * @param host String, either in byte array string format, like {214,116,1,3}
-     * or as a regular hostname, 127.0.0.1 or tomcat01.mydomain.com
-     */
-    public void setHost(String host) {
-        if ( host == null ) return;
-        if ( host.startsWith("{") ) setHost(Arrays.fromString(host));
-        else try { setHostname(host); }catch (IOException x) { throw new RuntimeException(x);}
-        
-    }
-    
-    /**
-     * @param domain String, either in byte array string format, like {214,116,1,3}
-     * or as a regular string value like 'mydomain'. The latter will be converted using ISO-8859-1 encoding
-     */
-    public void setDomain(String domain) {
-        if ( domain == null ) return;
-        if ( domain.startsWith("{") ) setDomain(Arrays.fromString(domain));
-        else setDomain(Arrays.convert(domain));
-    }
-    
-    /**
-     * @param id String, must be in byte array string format, like {214,116,1,3} and exactly 16 bytes long
-     */
-    public void setUniqueId(String id) {
-        byte[] uuid = Arrays.fromString(id);
-        if ( uuid==null || uuid.length != 16 ) throw new RuntimeException("UUID must be exactly 16 bytes, not:"+id);
-        setUniqueId(uuid);
-    }
-    
-    
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.membership;
+
+import java.io.IOException;
+import org.apache.catalina.tribes.util.UUIDGenerator;
+import org.apache.catalina.tribes.util.Arrays;
+
+/**
+ * <p>Title: </p>
+ *
+ * <p>Description: </p>
+ *
+ * <p>Copyright: Copyright (c) 2006</p>
+ *
+ * <p>Company: </p>
+ *
+ * @author not attributable
+ * @version 1.0
+ */
+public class StaticMember extends MemberImpl {
+    public StaticMember() {
+        super();
+    }
+
+    public StaticMember(String host, int port, long aliveTime) throws IOException {
+        super(host, port, aliveTime);
+    }
+
+    public StaticMember(String host, int port, long aliveTime, byte[] payload) throws IOException {
+        super(host, port, aliveTime, payload);
+    }
+     
+    /**
+     * @param host String, either in byte array string format, like {214,116,1,3}
+     * or as a regular hostname, 127.0.0.1 or tomcat01.mydomain.com
+     */
+    public void setHost(String host) {
+        if ( host == null ) return;
+        if ( host.startsWith("{") ) setHost(Arrays.fromString(host));
+        else try { setHostname(host); }catch (IOException x) { throw new RuntimeException(x);}
+        
+    }
+    
+    /**
+     * @param domain String, either in byte array string format, like {214,116,1,3}
+     * or as a regular string value like 'mydomain'. The latter will be converted using ISO-8859-1 encoding
+     */
+    public void setDomain(String domain) {
+        if ( domain == null ) return;
+        if ( domain.startsWith("{") ) setDomain(Arrays.fromString(domain));
+        else setDomain(Arrays.convert(domain));
+    }
+    
+    /**
+     * @param id String, must be in byte array string format, like {214,116,1,3} and exactly 16 bytes long
+     */
+    public void setUniqueId(String id) {
+        byte[] uuid = Arrays.fromString(id);
+        if ( uuid==null || uuid.length != 16 ) throw new RuntimeException("UUID must be exactly 16 bytes, not:"+id);
+        setUniqueId(uuid);
+    }
+    
+    
 }
\ No newline at end of file

==================================================
LazyReplicatedMap.java
index 47ee646d7f..53382e591d 100644
--- a/java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java
+++ b/java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java
@@ -1,1367 +1,1368 @@
-/*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.tipis;
-
-import java.io.IOException;
-import java.io.ObjectInput;
-import java.io.ObjectOutput;
-import java.io.Serializable;
-import java.io.UnsupportedEncodingException;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Set;
-
-import org.apache.catalina.tribes.Channel;
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelListener;
-import org.apache.catalina.tribes.Heartbeat;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.MembershipListener;
-import org.apache.catalina.tribes.group.Response;
-import org.apache.catalina.tribes.group.RpcCallback;
-import org.apache.catalina.tribes.group.RpcChannel;
-import org.apache.catalina.tribes.io.XByteBuffer;
-import org.apache.catalina.tribes.membership.MemberImpl;
-import org.apache.catalina.tribes.util.Arrays;
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-import java.util.ConcurrentModificationException;
-
-/**
- *
- * @author Filip Hanik
- * @version 1.0
- */
-public abstract class AbstractReplicatedMap extends LinkedHashMap implements RpcCallback, ChannelListener, MembershipListener, Heartbeat {
-    protected static Log log = LogFactory.getLog(AbstractReplicatedMap.class);
-
-    /**
-     * The default initial capacity - MUST be a power of two.
-     */
-    public static final int DEFAULT_INITIAL_CAPACITY = 16;
-
-    /**
-     * The load factor used when none specified in constructor.
-     **/
-    public static final float DEFAULT_LOAD_FACTOR = 0.75f;
-    
-    /**
-     * Used to identify the map
-     */
-    final String chset = "ISO-8859-1";
-
-//------------------------------------------------------------------------------
-//              INSTANCE VARIABLES
-//------------------------------------------------------------------------------
-    
-    /**
-     * Timeout for RPC messages, how long we will wait for a reply
-     */
-    protected transient long rpcTimeout = 5000;
-    /**
-     * Reference to the channel for sending messages
-     */
-    protected transient Channel channel;
-    /**
-     * The RpcChannel to send RPC messages through
-     */
-    protected transient RpcChannel rpcChannel;
-    /**
-     * The Map context name makes this map unique, this
-     * allows us to have more than one map shared
-     * through one channel
-     */
-    protected transient byte[] mapContextName;
-    /**
-     * Has the state been transferred
-     */
-    protected transient boolean stateTransferred = false;
-    /**
-     * Simple lock object for transfers
-     */
-    protected transient Object stateMutex = new Object();
-    /**
-     * A list of members in our map
-     */
-    protected transient HashMap mapMembers = new HashMap();
-    /**
-     * Our default send options
-     */
-    protected transient int channelSendOptions = Channel.SEND_OPTIONS_DEFAULT;
-    /**
-     * The owner of this map, ala a SessionManager for example
-     */
-    protected transient Object mapOwner;
-    /**
-     * External class loaders if serialization and deserialization is to be performed successfully.
-     */
-    protected transient ClassLoader[] externalLoaders;
-    
-    /**
-     * The node we are currently backing up data to, this index will rotate
-     * on a round robin basis
-     */
-    protected transient int currentNode = 0;
-    
-    /**
-     * Since the map keeps internal membership
-     * this is the timeout for a ping message to be responded to
-     * If a remote map doesn't respond within this timeframe, 
-     * its considered dead.
-     */
-    protected transient long accessTimeout = 5000;
-    
-    /**
-     * Readable string of the mapContextName value
-     */
-    protected transient String mapname = "";
-    
-
-//------------------------------------------------------------------------------
-//              CONSTRUCTORS
-//------------------------------------------------------------------------------
-
-    /**
-     * Creates a new map
-     * @param channel The channel to use for communication
-     * @param timeout long - timeout for RPC messags
-     * @param mapContextName String - unique name for this map, to allow multiple maps per channel
-     * @param initialCapacity int - the size of this map, see HashMap
-     * @param loadFactor float - load factor, see HashMap
-     * @param cls - a list of classloaders to be used for deserialization of objects.
-     */
-    public AbstractReplicatedMap(Object owner,
-                                 Channel channel, 
-                                 long timeout, 
-                                 String mapContextName, 
-                                 int initialCapacity,
-                                 float loadFactor,
-                                 int channelSendOptions,
-                                 ClassLoader[] cls) {
-        super(initialCapacity, loadFactor);
-        init(owner, channel, mapContextName, timeout, channelSendOptions, cls);
-        
-    }
-
-    /**
-     * Helper methods, wraps a single member in an array
-     * @param m Member
-     * @return Member[]
-     */
-    protected Member[] wrap(Member m) {
-        if ( m == null ) return new Member[0];
-        else return new Member[] {m};
-    }
-
-    /**
-     * Initializes the map by creating the RPC channel, registering itself as a channel listener
-     * This method is also responsible for initiating the state transfer
-     * @param owner Object
-     * @param channel Channel
-     * @param mapContextName String
-     * @param timeout long
-     * @param channelSendOptions int
-     * @param cls ClassLoader[]
-     */
-    protected void init(Object owner, Channel channel, String mapContextName, long timeout, int channelSendOptions,ClassLoader[] cls) {
-        log.info("Initializing AbstractReplicatedMap with context name:"+mapContextName);
-        this.mapOwner = owner;
-        this.externalLoaders = cls;
-        this.channelSendOptions = channelSendOptions;
-        this.channel = channel;
-        this.rpcTimeout = timeout;
-
-        try {
-            this.mapname = mapContextName;
-            //unique context is more efficient if it is stored as bytes
-            this.mapContextName = mapContextName.getBytes(chset);
-        } catch (UnsupportedEncodingException x) {
-            log.warn("Unable to encode mapContextName[" + mapContextName + "] using getBytes(" + chset +") using default getBytes()", x);
-            this.mapContextName = mapContextName.getBytes();
-        }
-        if ( log.isTraceEnabled() ) log.trace("Created Lazy Map with name:"+mapContextName+", bytes:"+Arrays.toString(this.mapContextName));
-
-        //create an rpc channel and add the map as a listener
-        this.rpcChannel = new RpcChannel(this.mapContextName, channel, this);
-        //add this map as a message listener
-        this.channel.addChannelListener(this);
-        //listen for membership notifications
-        this.channel.addMembershipListener(this);
-        
-        
-        try {
-            //broadcast our map, this just notifies other members of our existence
-            broadcast(MapMessage.MSG_INIT, true);
-            //transfer state from another map
-            transferState();
-            //state is transferred, we are ready for messaging
-            broadcast(MapMessage.MSG_START, true);
-        } catch (ChannelException x) {
-            log.warn("Unable to send map start message.");
-            throw new RuntimeException("Unable to start replicated map.",x);
-        }
-    }
-    
-    
-    /**
-     * Sends a ping out to all the members in the cluster, not just map members
-     * that this map is alive.
-     * @param timeout long
-     * @throws ChannelException
-     */
-    protected void ping(long timeout) throws ChannelException {
-        //send out a map membership message, only wait for the first reply
-        MapMessage msg = new MapMessage(this.mapContextName, 
-                                        MapMessage.MSG_INIT,
-                                        false, 
-                                        null, 
-                                        null, 
-                                        null, 
-                                        wrap(channel.getLocalMember(false)));
-        if ( channel.getMembers().length > 0 ) {
-            //send a ping, wait for all nodes to reply
-            Response[] resp = rpcChannel.send(channel.getMembers(), 
-                                              msg, rpcChannel.ALL_REPLY, 
-                                              (channelSendOptions),
-                                              (int) accessTimeout);
-            for (int i = 0; i < resp.length; i++) {
-                memberAlive(resp[i].getSource());
-            } //for
-        }
-        //update our map of members, expire some if we didn't receive a ping back
-        synchronized (mapMembers) {
-            Iterator it = mapMembers.entrySet().iterator();
-            long now = System.currentTimeMillis();
-            while ( it.hasNext() ) {
-                Map.Entry entry = (Map.Entry)it.next();
-                long access = ((Long)entry.getValue()).longValue(); 
-                if ( (now - access) > timeout ) memberDisappeared((Member)entry.getKey());
-            }
-        }//synch
-    }
-
-    /**
-     * We have received a member alive notification
-     * @param member Member
-     */
-    protected void memberAlive(Member member) {
-        synchronized (mapMembers) {
-            if (!mapMembers.containsKey(member)) {
-                mapMemberAdded(member);
-            } //end if
-            mapMembers.put(member, new Long(System.currentTimeMillis()));
-        }
-    }
-    
-    /**
-     * Helper method to broadcast a message to all members in a channel
-     * @param msgtype int
-     * @param rpc boolean
-     * @throws ChannelException
-     */
-    protected void broadcast(int msgtype, boolean rpc) throws ChannelException {
-        //send out a map membership message, only wait for the first reply
-        MapMessage msg = new MapMessage(this.mapContextName, msgtype,
-                                        false, null, null, null, wrap(channel.getLocalMember(false)));
-        if ( rpc) {
-            Response[] resp = rpcChannel.send(channel.getMembers(), msg, rpcChannel.FIRST_REPLY, (channelSendOptions),rpcTimeout);
-            for (int i = 0; i < resp.length; i++) {
-                mapMemberAdded(resp[i].getSource());
-                messageReceived(resp[i].getMessage(), resp[i].getSource());
-            }
-        } else {
-            channel.send(channel.getMembers(),msg,channelSendOptions);
-        }
-    }
-
-    public void breakdown() {
-        finalize();
-    }
-
-    public void finalize() {
-        try {broadcast(MapMessage.MSG_STOP,false); }catch ( Exception ignore){}
-        //cleanup
-        if (this.rpcChannel != null) {
-            this.rpcChannel.breakdown();
-        }
-        if (this.channel != null) {
-            this.channel.removeChannelListener(this);
-            this.channel.removeMembershipListener(this);
-        }
-        this.rpcChannel = null;
-        this.channel = null;
-        this.mapMembers.clear();
-        super.clear();
-        this.stateTransferred = false;
-        this.externalLoaders = null;
-    }
-    
-    public int hashCode() {
-        return Arrays.hashCode(this.mapContextName);
-    }
-    
-    public boolean equals(Object o) {
-        if ( o == null ) return false;
-        if ( !(o instanceof AbstractReplicatedMap)) return false;
-        if ( !(o.getClass().equals(this.getClass())) ) return false;
-        AbstractReplicatedMap other = (AbstractReplicatedMap)o;
-        return Arrays.equals(mapContextName,other.mapContextName);
-    }
-
-//------------------------------------------------------------------------------
-//              GROUP COM INTERFACES
-//------------------------------------------------------------------------------
-    public Member[] getMapMembers(HashMap members) {
-        synchronized (members) {
-            Member[] result = new Member[members.size()];
-            members.keySet().toArray(result);
-            return result;
-        }
-    }
-    public Member[] getMapMembers() {
-        return getMapMembers(this.mapMembers);
-    }
-    
-    public Member[] getMapMembersExcl(Member[] exclude) {
-        synchronized (mapMembers) {
-            HashMap list = (HashMap)mapMembers.clone();
-            for (int i=0; i<exclude.length;i++) list.remove(exclude[i]);
-            return getMapMembers(list);
-        }
-    }
-
-
-    /**
-     * Replicates any changes to the object since the last time
-     * The object has to be primary, ie, if the object is a proxy or a backup, it will not be replicated<br>
-     * @param complete - if set to true, the object is replicated to its backup
-     * if set to false, only objects that implement ReplicatedMapEntry and the isDirty() returns true will
-     * be replicated
-     */
-    public void replicate(Object key, boolean complete) {
-        if ( log.isTraceEnabled() )
-            log.trace("Replicate invoked on key:"+key);
-        MapEntry entry = (MapEntry)super.get(key);
-        if ( entry == null ) return;
-        if ( !entry.isSerializable() ) return;
-        if (entry != null && entry.isPrimary() && entry.getBackupNodes()!= null && entry.getBackupNodes().length > 0) {
-            Object value = entry.getValue();
-            //check to see if we need to replicate this object isDirty()||complete
-            boolean repl = complete || ( (value instanceof ReplicatedMapEntry) && ( (ReplicatedMapEntry) value).isDirty());
-            
-            if (!repl) {
-                if ( log.isTraceEnabled() )
-                    log.trace("Not replicating:"+key+", no change made");
-                
-                return;
-            }
-            //check to see if the message is diffable
-            boolean diff = ( (value instanceof ReplicatedMapEntry) && ( (ReplicatedMapEntry) value).isDiffable());
-            MapMessage msg = null;
-            if (diff) {
-                ReplicatedMapEntry rentry = (ReplicatedMapEntry)entry.getValue();
-                try {
-                    rentry.lock();
-                    //construct a diff message
-                    msg = new MapMessage(mapContextName, MapMessage.MSG_BACKUP,
-                                         true, (Serializable) entry.getKey(), null,
-                                         rentry.getDiff(),
-                                         entry.getBackupNodes());
-                } catch (IOException x) {
-                    log.error("Unable to diff object. Will replicate the entire object instead.", x);
-                } finally {
-                    rentry.unlock();
-                }
-                
-            }
-            if (msg == null) {
-                //construct a complete
-                msg = new MapMessage(mapContextName, MapMessage.MSG_BACKUP,
-                                     false, (Serializable) entry.getKey(),
-                                     (Serializable) entry.getValue(),
-                                     null, entry.getBackupNodes());
-
-            }
-            try {
-                if ( channel!=null && entry.getBackupNodes()!= null && entry.getBackupNodes().length > 0 ) {
-                    channel.send(entry.getBackupNodes(), msg, channelSendOptions);
-                }
-            } catch (ChannelException x) {
-                log.error("Unable to replicate data.", x);
-            }
-        } //end if
-
-    }
-
-    /**
-     * This can be invoked by a periodic thread to replicate out any changes.
-     * For maps that don't store objects that implement ReplicatedMapEntry, this
-     * method should be used infrequently to avoid large amounts of data transfer
-     * @param complete boolean
-     */
-    public void replicate(boolean complete) {
-        Iterator i = super.entrySet().iterator();
-        while (i.hasNext()) {
-            Map.Entry e = (Map.Entry) i.next();
-            replicate(e.getKey(), complete);
-        } //while
-
-    }
-
-    public void transferState() {
-        try {
-            Member[] members = getMapMembers();
-            Member backup = members.length > 0 ? (Member) members[0] : null;
-            if (backup != null) {
-                MapMessage msg = new MapMessage(mapContextName, MapMessage.MSG_STATE, false,
-                                                null, null, null, null);
-                Response[] resp = rpcChannel.send(new Member[] {backup}, msg, rpcChannel.FIRST_REPLY, channelSendOptions, rpcTimeout);
-                if (resp.length > 0) {
-                    synchronized (stateMutex) {
-                        msg = (MapMessage) resp[0].getMessage();
-                        msg.deserialize(getExternalLoaders());
-                        ArrayList list = (ArrayList) msg.getValue();
-                        for (int i = 0; i < list.size(); i++) {
-                            messageReceived( (Serializable) list.get(i), resp[0].getSource());
-                        } //for
-                    }
-                } else {
-                    log.warn("Transfer state, 0 replies, probably a timeout.");
-                }
-            }
-        } catch (ChannelException x) {
-            log.error("Unable to transfer LazyReplicatedMap state.", x);
-        } catch (IOException x) {
-            log.error("Unable to transfer LazyReplicatedMap state.", x);
-        } catch (ClassNotFoundException x) {
-            log.error("Unable to transfer LazyReplicatedMap state.", x);
-        }
-        stateTransferred = true;
-    }
-
-    /**
-     * @todo implement state transfer
-     * @param msg Serializable
-     * @return Serializable - null if no reply should be sent
-     */
-    public Serializable replyRequest(Serializable msg, final Member sender) {
-        if (! (msg instanceof MapMessage))return null;
-        MapMessage mapmsg = (MapMessage) msg;
-
-        //map init request
-        if (mapmsg.getMsgType() == mapmsg.MSG_INIT) {
-            mapmsg.setBackUpNodes(wrap(channel.getLocalMember(false)));
-            return mapmsg;
-        }
-        
-        //map start request
-        if (mapmsg.getMsgType() == mapmsg.MSG_START) {
-            mapmsg.setBackUpNodes(wrap(channel.getLocalMember(false)));
-            mapMemberAdded(sender);
-            return mapmsg;
-        }
-
-        //backup request
-        if (mapmsg.getMsgType() == mapmsg.MSG_RETRIEVE_BACKUP) {
-            MapEntry entry = (MapEntry)super.get(mapmsg.getKey());
-            if (entry == null || (!entry.isSerializable()) )return null;
-            mapmsg.setValue( (Serializable) entry.getValue());
-            return mapmsg;
-        }
-
-        //state transfer request
-        if (mapmsg.getMsgType() == mapmsg.MSG_STATE) {
-            synchronized (stateMutex) { //make sure we dont do two things at the same time
-                ArrayList list = new ArrayList();
-                Iterator i = super.entrySet().iterator();
-                while (i.hasNext()) {
-                    Map.Entry e = (Map.Entry) i.next();
-                    MapEntry entry = (MapEntry) e.getValue();
-                    if ( entry.isSerializable() ) {
-                        MapMessage me = new MapMessage(mapContextName, MapMessage.MSG_PROXY,
-                            false, (Serializable) entry.getKey(), null, null, entry.getBackupNodes());
-                        list.add(me);
-                    }
-                }
-                mapmsg.setValue(list);
-                return mapmsg;
-                
-            } //synchronized
-        }
-
-        return null;
-
-    }
-
-    /**
-     * If the reply has already been sent to the requesting thread,
-     * the rpc callback can handle any data that comes in after the fact.
-     * @param msg Serializable
-     * @param sender Member
-     */
-    public void leftOver(Serializable msg, Member sender) {
-        //left over membership messages
-        if (! (msg instanceof MapMessage))return;
-
-        MapMessage mapmsg = (MapMessage) msg;
-        try {
-            mapmsg.deserialize(getExternalLoaders());
-            if (mapmsg.getMsgType() == MapMessage.MSG_START) {
-                mapMemberAdded(mapmsg.getBackupNodes()[0]);
-            } else if (mapmsg.getMsgType() == MapMessage.MSG_INIT) {
-                memberAlive(mapmsg.getBackupNodes()[0]);
-            }
-        } catch (IOException x ) {
-            log.error("Unable to deserialize MapMessage.",x);
-        } catch (ClassNotFoundException x ) {
-            log.error("Unable to deserialize MapMessage.",x);
-        }
-    }
-
-    public void messageReceived(Serializable msg, Member sender) {
-        if (! (msg instanceof MapMessage)) return;
-
-        MapMessage mapmsg = (MapMessage) msg;
-        if ( log.isTraceEnabled() ) {
-            log.trace("Map["+mapname+"] received message:"+mapmsg);
-        }
-        
-        try {
-            mapmsg.deserialize(getExternalLoaders());
-        } catch (IOException x) {
-            log.error("Unable to deserialize MapMessage.", x);
-            return;
-        } catch (ClassNotFoundException x) {
-            log.error("Unable to deserialize MapMessage.", x);
-            return;
-        }
-        if ( log.isTraceEnabled() ) 
-            log.trace("Map message received from:"+sender.getName()+" msg:"+mapmsg);
-        if (mapmsg.getMsgType() == MapMessage.MSG_START) {
-            mapMemberAdded(mapmsg.getBackupNodes()[0]);
-        }
-
-        if (mapmsg.getMsgType() == MapMessage.MSG_STOP) {
-            memberDisappeared(mapmsg.getBackupNodes()[0]);
-        }
-
-        if (mapmsg.getMsgType() == MapMessage.MSG_PROXY) {
-            MapEntry entry = (MapEntry)super.get(mapmsg.getKey());
-            if ( entry==null ) {
-                entry = new MapEntry(mapmsg.getKey(), mapmsg.getValue());
-                entry.setBackup(false);
-                entry.setProxy(true);
-                entry.setBackupNodes(mapmsg.getBackupNodes());
-                super.put(entry.getKey(), entry);
-            } else {
-                entry.setProxy(true);
-                entry.setBackup(false);
-                entry.setBackupNodes(mapmsg.getBackupNodes());
-            }
-        }
-
-        if (mapmsg.getMsgType() == MapMessage.MSG_REMOVE) {
-            super.remove(mapmsg.getKey());
-        }
-
-        if (mapmsg.getMsgType() == MapMessage.MSG_BACKUP) {
-            MapEntry entry = (MapEntry)super.get(mapmsg.getKey());
-            if (entry == null) {
-                entry = new MapEntry(mapmsg.getKey(), mapmsg.getValue());
-                entry.setBackup(true);
-                entry.setProxy(false);
-                entry.setBackupNodes(mapmsg.getBackupNodes());
-                if (mapmsg.getValue()!=null && mapmsg.getValue() instanceof ReplicatedMapEntry ) {
-                    ((ReplicatedMapEntry)mapmsg.getValue()).setOwner(getMapOwner());
-                }
-            } else {
-                entry.setBackup(true);
-                entry.setProxy(false);
-                entry.setBackupNodes(mapmsg.getBackupNodes());
-                if (entry.getValue() instanceof ReplicatedMapEntry) {
-                    ReplicatedMapEntry diff = (ReplicatedMapEntry) entry.getValue();
-                    if (mapmsg.isDiff()) {
-                        try {
-                            diff.lock();
-                            diff.applyDiff(mapmsg.getDiffValue(), 0, mapmsg.getDiffValue().length);
-                        } catch (Exception x) {
-                            log.error("Unable to apply diff to key:" + entry.getKey(), x);
-                        } finally {
-                            diff.unlock();
-                        }
-                    } else {
-                        if ( mapmsg.getValue()!=null ) entry.setValue(mapmsg.getValue());
-                        ((ReplicatedMapEntry)entry.getValue()).setOwner(getMapOwner());
-                    } //end if
-                } else if  (mapmsg.getValue() instanceof ReplicatedMapEntry) {
-                    ReplicatedMapEntry re = (ReplicatedMapEntry)mapmsg.getValue();
-                    re.setOwner(getMapOwner());
-                    entry.setValue(re);
-                } else {
-                    if ( mapmsg.getValue()!=null ) entry.setValue(mapmsg.getValue());
-                } //end if
-            } //end if
-            super.put(entry.getKey(), entry);
-        } //end if
-    }
-
-    public boolean accept(Serializable msg, Member sender) {
-        boolean result = false;
-        if (msg instanceof MapMessage) {
-            if ( log.isTraceEnabled() ) log.trace("Map["+mapname+"] accepting...."+msg);
-            result = Arrays.equals(mapContextName, ( (MapMessage) msg).getMapId());
-            if ( log.isTraceEnabled() ) log.trace("Msg["+mapname+"] accepted["+result+"]...."+msg);
-        }
-        return result;
-    }
-
-    public void mapMemberAdded(Member member) {
-        if ( member.equals(getChannel().getLocalMember(false)) ) return;
-        boolean memberAdded = false;
-        //select a backup node if we don't have one
-        synchronized (mapMembers) {
-            if (!mapMembers.containsKey(member) ) {
-                mapMembers.put(member, new Long(System.currentTimeMillis()));
-                memberAdded = true;
-            }
-        }
-        if ( memberAdded ) {
-            synchronized (stateMutex) {
-                Iterator i = super.entrySet().iterator();
-                while (i.hasNext()) {
-                    Map.Entry e = (Map.Entry) i.next();
-                    MapEntry entry = (MapEntry) e.getValue();
-                    if ( entry == null ) continue;
-                    if (entry.isPrimary() && (entry.getBackupNodes() == null || entry.getBackupNodes().length == 0)) {
-                        try {
-                            Member[] backup = publishEntryInfo(entry.getKey(), entry.getValue());
-                            entry.setBackupNodes(backup);
-                        } catch (ChannelException x) {
-                            log.error("Unable to select backup node.", x);
-                        } //catch
-                    } //end if
-                } //while
-            } //synchronized
-        }//end if
-    }
-    
-    public boolean inSet(Member m, Member[] set) {
-        if ( set == null ) return false;
-        boolean result = false;
-        for (int i=0; i<set.length && (!result); i++ )
-            if ( m.equals(set[i]) ) result = true;
-        return result;
-    }
-
-    public Member[] excludeFromSet(Member[] mbrs, Member[] set) {
-        ArrayList result = new ArrayList();
-        for (int i=0; i<set.length; i++ ) {
-            boolean include = true;
-            for (int j=0; j<mbrs.length; j++ ) 
-                if ( mbrs[j].equals(set[i]) ) include = false;
-            if ( include ) result.add(set[i]);
-        }
-        return (Member[])result.toArray(new Member[result.size()]);
-    }
-
-    public void memberAdded(Member member) {
-        //do nothing
-    }
-
-    public void memberDisappeared(Member member) {
-        boolean removed = false;
-        synchronized (mapMembers) {
-            removed = (mapMembers.remove(member) != null );
-        }
-        Iterator i = super.entrySet().iterator();
-        while (i.hasNext()) {
-            Map.Entry e = (Map.Entry) i.next();
-            MapEntry entry = (MapEntry) e.getValue();
-            if (entry.isPrimary() && inSet(member,entry.getBackupNodes())) {
-                try {
-                    Member[] backup = publishEntryInfo(entry.getKey(), entry.getValue());
-                    entry.setBackupNodes(backup);
-                } catch (ChannelException x) {
-                    log.error("Unable to relocate[" + entry.getKey() + "] to a new backup node", x);
-                }
-            } //end if
-        } //while
-    }
-
-    public int getNextBackupIndex() {
-        int size = mapMembers.size();
-        if (mapMembers.size() == 0)return -1;
-        int node = currentNode++;
-        if (node >= size) {
-            node = 0;
-            currentNode = 0;
-        }
-        return node;
-    }
-    public Member getNextBackupNode() {
-        Member[] members = getMapMembers();
-        int node = getNextBackupIndex();
-        if ( members.length == 0 || node==-1) return null;
-        if ( node >= members.length ) node = 0;
-        return members[node];
-    }
-
-    protected abstract Member[] publishEntryInfo(Object key, Object value) throws ChannelException;
-    
-    public void heartbeat() {
-        try {
-            ping(accessTimeout);
-        }catch ( Exception x ) {
-            log.error("Unable to send AbstractReplicatedMap.ping message",x);
-        }
-    }
-
-//------------------------------------------------------------------------------    
-//              METHODS TO OVERRIDE    
-//------------------------------------------------------------------------------
-  
-    /**
-     * Removes an object from this map, it will also remove it from 
-     * 
-     * @param key Object
-     * @return Object
-     */
-    public Object remove(Object key) {
-        MapEntry entry = (MapEntry)super.remove(key);
-
-        try {
-            if (getMapMembers().length > 0 ) {
-                MapMessage msg = new MapMessage(getMapContextName(), MapMessage.MSG_REMOVE, false, (Serializable) key, null, null, null);
-                getChannel().send(getMapMembers(), msg, getChannelSendOptions());
-            }
-        } catch ( ChannelException x ) {
-            log.error("Unable to replicate out data for a LazyReplicatedMap.remove operation",x);
-        }
-        return entry!=null?entry.getValue():null;
-    }
-    
-    public Object get(Object key) {
-        MapEntry entry = (MapEntry)super.get(key);
-        if (log.isTraceEnabled()) log.trace("Requesting id:"+key+" entry:"+entry);
-        if ( entry == null ) return null;
-        if ( !entry.isPrimary() ) {
-            //if the message is not primary, we need to retrieve the latest value
-            try {
-                Member[] backup = null;
-                MapMessage msg = null;
-                if ( !entry.isBackup() ) {
-                    //make sure we don't retrieve from ourselves
-                    msg = new MapMessage(getMapContextName(), MapMessage.MSG_RETRIEVE_BACKUP, false,
-                                         (Serializable) key, null, null, null);
-                    Response[] resp = getRpcChannel().send(entry.getBackupNodes(),msg, this.getRpcChannel().FIRST_REPLY, Channel.SEND_OPTIONS_DEFAULT, getRpcTimeout());
-                    if (resp == null || resp.length == 0) {
-                        //no responses
-                        log.warn("Unable to retrieve remote object for key:" + key);
-                        return null;
-                    }
-                    msg = (MapMessage) resp[0].getMessage();
-                    msg.deserialize(getExternalLoaders());
-                    backup = entry.getBackupNodes();
-                    if ( entry.getValue() instanceof ReplicatedMapEntry ) {
-                        ReplicatedMapEntry val = (ReplicatedMapEntry)entry.getValue();
-                        val.setOwner(getMapOwner());
-                    }
-                    if ( msg.getValue()!=null ) entry.setValue(msg.getValue());
-                }
-                if (entry.isBackup()) {
-                    //select a new backup node
-                    backup = publishEntryInfo(key, entry.getValue());
-                } else if ( entry.isProxy() ) {
-                    //invalidate the previous primary
-                    msg = new MapMessage(getMapContextName(),MapMessage.MSG_PROXY,false,(Serializable)key,null,null,backup);
-                    Member[] dest = getMapMembersExcl(backup);
-                    if ( dest!=null && dest.length >0) {
-                        getChannel().send(dest, msg, getChannelSendOptions());
-                    }
-                }
-
-                entry.setBackupNodes(backup);
-                entry.setBackup(false);
-                entry.setProxy(false);
-
-
-            } catch (Exception x) {
-                log.error("Unable to replicate out data for a LazyReplicatedMap.get operation", x);
-                return null;
-            }
-        }
-        if (log.isTraceEnabled()) log.trace("Requesting id:"+key+" result:"+entry.getValue());
-        if ( entry.getValue() != null && entry.getValue() instanceof ReplicatedMapEntry ) {
-            ReplicatedMapEntry val = (ReplicatedMapEntry)entry.getValue();
-            //hack, somehow this is not being set above
-            val.setOwner(getMapOwner());
-            
-        }
-        return entry.getValue();
-    }    
-
-    
-    protected void printMap(String header) {
-        try {
-            System.out.println("\nDEBUG MAP:"+header);
-            System.out.println("Map["+ new String(mapContextName, chset) + ", Map Size:" + super.size());
-            Member[] mbrs = getMapMembers();
-            for ( int i=0; i<mbrs.length;i++ ) {
-                System.out.println("Mbr["+(i+1)+"="+mbrs[i].getName());
-            }
-            Iterator i = super.entrySet().iterator();
-            int cnt = 0;
-
-            while (i.hasNext()) {
-                Map.Entry e = (Map.Entry) i.next();
-                System.out.println( (++cnt) + ". " + e.getValue());
-            }
-            System.out.println("EndMap]\n\n");
-        }catch ( Exception ignore) {
-            ignore.printStackTrace();
-        }
-    }
-    
-    /**
-         * Returns true if the key has an entry in the map.
-         * The entry can be a proxy or a backup entry, invoking <code>get(key)</code>
-         * will make this entry primary for the group
-         * @param key Object
-         * @return boolean
-         */
-        public boolean containsKey(Object key) {
-            return super.containsKey(key);
-        }
-    
-    
-        public Object put(Object key, Object value) {
-            MapEntry entry = new MapEntry(key,value);
-            entry.setBackup(false);
-            entry.setProxy(false);
-    
-            Object old = null;
-    
-            //make sure that any old values get removed
-            if ( containsKey(key) ) old = remove(key);
-            try {
-                Member[] backup = publishEntryInfo(key, value);
-                entry.setBackupNodes(backup);
-            } catch (ChannelException x) {
-                log.error("Unable to replicate out data for a LazyReplicatedMap.put operation", x);
-            }
-            super.put(key,entry);
-            return old;
-        }
-    
-    
-        /**
-         * Copies all values from one map to this instance
-         * @param m Map
-         */
-        public void putAll(Map m) {
-            Iterator i = m.entrySet().iterator();
-            while ( i.hasNext() ) {
-                Map.Entry entry = (Map.Entry)i.next();
-                put(entry.getKey(),entry.getValue());
-            }
-        }
-    
-        public void clear() {
-            //only delete active keys
-            Iterator keys = keySet().iterator();
-            while ( keys.hasNext() ) remove(keys.next());
-        }
-    
-        public boolean containsValue(Object value) {
-            if ( value == null ) {
-                return super.containsValue(value);
-            } else {
-                Iterator i = super.entrySet().iterator();
-                while (i.hasNext()) {
-                    Map.Entry e = (Map.Entry) i.next();
-                    MapEntry entry = (MapEntry) e.getValue();
-                    if (entry.isPrimary() && value.equals(entry.getValue())) return true;
-                }//while
-                return false;
-            }//end if
-        }
-    
-        public Object clone() {
-            throw new UnsupportedOperationException("This operation is not valid on a replicated map");
-        }
-    
-        /**
-         * Returns the entire contents of the map
-         * Map.Entry.getValue() will return a LazyReplicatedMap.MapEntry object containing all the information 
-         * about the object.
-         * @return Set
-         */
-        public Set entrySetFull() {
-            return super.entrySet();
-        }
-    
-        public Set keySetFull() {
-            return super.keySet();
-        }
-    
-        public int sizeFull() {
-            return super.size();
-        }
-    
-        public Set entrySet() {
-            LinkedHashSet set = new LinkedHashSet(super.size());
-            Iterator i = super.entrySet().iterator();
-            while ( i.hasNext() ) {
-                Map.Entry e = (Map.Entry)i.next();
-                MapEntry entry = (MapEntry)e.getValue();
-                if ( entry.isPrimary() ) set.add(entry);
-            }
-            return Collections.unmodifiableSet(set);
-        }
-    
-        public Set keySet() {
-            //todo implement
-            //should only return keys where this is active.
-            LinkedHashSet set = new LinkedHashSet(super.size());
-            Iterator i = super.entrySet().iterator();
-            while ( i.hasNext() ) {
-                Map.Entry e = (Map.Entry)i.next();
-                MapEntry entry = (MapEntry)e.getValue();
-                if ( entry.isPrimary() ) set.add(entry.getKey());
-            }
-            return Collections.unmodifiableSet(set);
-        }
-    
-    
-        public int size() {
-            //todo, implement a counter variable instead
-            //only count active members in this node
-            int counter = 0;
-            Iterator it = Collections.unmodifiableSet(super.entrySet()).iterator();
-            while (it.hasNext() ) {
-                Map.Entry e = (Map.Entry) it.next();
-                if ( e != null ) {
-                    MapEntry entry = (MapEntry) e.getValue();
-                    if (entry.isPrimary() && entry.getValue() != null) counter++;
-                }
-            }
-            return counter;
-        }
-    
-        protected boolean removeEldestEntry(Map.Entry eldest) {
-            return false;
-        }
-    
-        public boolean isEmpty() {
-            return size()==0;
-        }
-    
-        public Collection values() {
-            ArrayList values = new ArrayList();
-            Iterator i = super.entrySet().iterator();
-            while ( i.hasNext() ) {
-                Map.Entry e = (Map.Entry)i.next();
-                MapEntry entry = (MapEntry)e.getValue();
-                if ( entry.isPrimary() && entry.getValue()!=null) values.add(entry.getValue());
-            }
-            return Collections.unmodifiableCollection(values);
-        }
-        
-
-//------------------------------------------------------------------------------
-//                Map Entry class
-//------------------------------------------------------------------------------
-    public static class MapEntry implements Map.Entry {
-        private boolean backup;
-        private boolean proxy;
-        private Member[] backupNodes;
-
-        private Object key;
-        private Object value;
-
-        public MapEntry(Object key, Object value) {
-            setKey(key);
-            setValue(value);
-            
-        }
-        
-        public boolean isKeySerializable() {
-            return (key == null) || (key instanceof Serializable);
-        }
-        
-        public boolean isValueSerializable() {
-            return (value==null) || (value instanceof Serializable);
-        }
-        
-        public boolean isSerializable() {
-            return isKeySerializable() && isValueSerializable();
-        }
-        
-        public boolean isBackup() {
-            return backup;
-        }
-
-        public void setBackup(boolean backup) {
-            this.backup = backup;
-        }
-
-        public boolean isProxy() {
-            return proxy;
-        }
-
-        public boolean isPrimary() {
-            return ( (!proxy) && (!backup));
-        }
-
-        public void setProxy(boolean proxy) {
-            this.proxy = proxy;
-        }
-
-        public boolean isDiffable() {
-            return (value instanceof ReplicatedMapEntry) &&
-                   ((ReplicatedMapEntry)value).isDiffable();
-        }
-
-        public void setBackupNodes(Member[] nodes) {
-            this.backupNodes = nodes;
-        }
-
-        public Member[] getBackupNodes() {
-            return backupNodes;
-        }
-
-        public Object getValue() {
-            return value;
-        }
-
-        public Object setValue(Object value) {
-            Object old = this.value;
-            this.value = (Serializable) value;
-            return old;
-        }
-
-        public Object getKey() {
-            return key;
-        }
-        
-        public Object setKey(Object key) {
-            Object old = this.key;
-            this.key = (Serializable)key;
-            return old;
-        }
-
-        public int hashCode() {
-            return key.hashCode();
-        }
-
-        public boolean equals(Object o) {
-            return key.equals(o);
-        }
-
-        /**
-         * apply a diff, or an entire object
-         * @param data byte[]
-         * @param offset int
-         * @param length int
-         * @param diff boolean
-         * @throws IOException
-         * @throws ClassNotFoundException
-         */
-        public void apply(byte[] data, int offset, int length, boolean diff) throws IOException, ClassNotFoundException {
-            if (isDiffable() && diff) {
-                ReplicatedMapEntry rentry = (ReplicatedMapEntry) value;
-                try {
-                    rentry.lock();
-                    rentry.applyDiff(data, offset, length);
-                } finally {
-                    rentry.unlock();
-                }
-            } else if (length == 0) {
-                value = null;
-                proxy = true;
-            } else {
-                value = XByteBuffer.deserialize(data, offset, length);
-            }
-        }
-        
-        public String toString() {
-            StringBuffer buf = new StringBuffer("MapEntry[key:");
-            buf.append(getKey()).append("; ");
-            buf.append("value:").append(getValue()).append("; ");
-            buf.append("primary:").append(isPrimary()).append("; ");
-            buf.append("backup:").append(isBackup()).append("; ");
-            buf.append("proxy:").append(isProxy()).append(";]");
-            return buf.toString();
-        }
-
-    }
-
-//------------------------------------------------------------------------------
-//                map message to send to and from other maps
-//------------------------------------------------------------------------------
-
-    public static class MapMessage implements Serializable {
-        public static final int MSG_BACKUP = 1;
-        public static final int MSG_RETRIEVE_BACKUP = 2;
-        public static final int MSG_PROXY = 3;
-        public static final int MSG_REMOVE = 4;
-        public static final int MSG_STATE = 5;
-        public static final int MSG_START = 6;
-        public static final int MSG_STOP = 7;
-        public static final int MSG_INIT = 8;
-
-        private byte[] mapId;
-        private int msgtype;
-        private boolean diff;
-        private transient Serializable key;
-        private transient Serializable value;
-        private byte[] valuedata;
-        private byte[] keydata;
-        private byte[] diffvalue;
-        private Member[] nodes;
-        
-        public String toString() {
-            StringBuffer buf = new StringBuffer("MapMessage[context=");
-            buf.append(new String(mapId));
-            buf.append("; type=");
-            buf.append(getTypeDesc());
-            buf.append("; key=");
-            buf.append(key);
-            buf.append("; value=");
-            buf.append(value);
-            return buf.toString();
-        }
-        
-        public String getTypeDesc() {
-            switch (msgtype) {
-                case MSG_BACKUP: return "MSG_BACKUP";
-                case MSG_RETRIEVE_BACKUP: return "MSG_RETRIEVE_BACKUP";
-                case MSG_PROXY: return "MSG_PROXY";
-                case MSG_REMOVE: return "MSG_REMOVE";
-                case MSG_STATE: return "MSG_STATE";
-                case MSG_START: return "MSG_START";
-                case MSG_STOP: return "MSG_STOP";
-                case MSG_INIT: return "MSG_INIT";
-                default : return "UNKNOWN";
-            }
-        }
-
-        public MapMessage() {}
-
-        public MapMessage(byte[] mapId,int msgtype, boolean diff,
-                          Serializable key, Serializable value,
-                          byte[] diffvalue, Member[] nodes)  {
-            this.mapId = mapId;
-            this.msgtype = msgtype;
-            this.diff = diff;
-            this.key = key;
-            this.value = value;
-            this.diffvalue = diffvalue;
-            this.nodes = nodes;
-            setValue(value);
-            setKey(key);
-        }
-        
-        public void deserialize(ClassLoader[] cls) throws IOException, ClassNotFoundException {
-            key(cls);
-            value(cls);
-        }
-
-        public int getMsgType() {
-            return msgtype;
-        }
-
-        public boolean isDiff() {
-            return diff;
-        }
-
-        public Serializable getKey() {
-            try {
-                return key(null);
-            } catch ( Exception x ) {
-                log.error("Deserialization error of the MapMessage.key",x);
-                return null;
-            }
-        }
-
-        public Serializable key(ClassLoader[] cls) throws IOException, ClassNotFoundException {
-            if ( key!=null ) return key;
-            if ( keydata == null || keydata.length == 0 ) return null;
-            key = XByteBuffer.deserialize(keydata,0,keydata.length,cls);
-            keydata = null;
-            return key;
-        }
-        
-        public byte[] getKeyData() {
-            return keydata;
-        }
-        
-        public Serializable getValue() {
-            try {
-                return value(null);
-            } catch ( Exception x ) {
-                log.error("Deserialization error of the MapMessage.value",x);
-                return null;
-            }
-        }
-
-        public Serializable value(ClassLoader[] cls) throws IOException, ClassNotFoundException  {
-            if ( value!=null ) return value;
-            if ( valuedata == null || valuedata.length == 0 ) return null;
-            value = XByteBuffer.deserialize(valuedata,0,valuedata.length,cls);
-            valuedata = null;;
-            return value;
-        }
-        
-        public byte[] getValueData() {
-            return valuedata;
-        }
-
-        public byte[] getDiffValue() {
-            return diffvalue;
-        }
-
-        public Member[] getBackupNodes() {
-            return nodes;
-        }
-
-        private void setBackUpNodes(Member[] nodes) {
-            this.nodes = nodes;
-        }
-
-        public byte[] getMapId() {
-            return mapId;
-        }
-
-        public void setValue(Serializable value) {
-            try {
-                if ( value != null ) valuedata = XByteBuffer.serialize(value);
-                this.value = value;
-            }catch ( IOException x ) {
-                throw new RuntimeException(x);
-            }
-        }
-        
-        public void setKey(Serializable key) {
-            try {
-                if (key != null) keydata = XByteBuffer.serialize(key);
-                this.key = key;
-            } catch (IOException x) {
-                throw new RuntimeException(x);
-            }
-        }
-        
-        protected Member[] readMembers(ObjectInput in) throws IOException, ClassNotFoundException {
-            int nodecount = in.readInt();
-            Member[] members = new Member[nodecount];
-            for ( int i=0; i<members.length; i++ ) {
-                byte[] d = new byte[in.readInt()];
-                in.read(d);
-                if (d.length > 0) members[i] = MemberImpl.getMember(d);
-            }
-            return members;
-        }
-        
-        protected void writeMembers(ObjectOutput out,Member[] members) throws IOException {
-            if ( members == null ) members = new Member[0];
-            out.writeInt(members.length);
-            for (int i=0; i<members.length; i++ ) {
-                if ( members[i] != null ) {
-                    byte[] d = members[i] != null ? ( (MemberImpl)members[i]).getData(false) : new byte[0];
-                    out.writeInt(d.length);
-                    out.write(d);
-                }
-            }
-        }
-        
-        
-        /**
-         * shallow clone
-         * @return Object
-         */
-        public Object clone() {
-            MapMessage msg = new MapMessage(this.mapId, this.msgtype, this.diff, this.key, this.value, this.diffvalue, this.nodes);
-            msg.keydata = this.keydata;
-            msg.valuedata = this.valuedata;
-            return msg;
-        }
-    } //MapMessage
-
-
-    public Channel getChannel() {
-        return channel;
-    }
-
-    public byte[] getMapContextName() {
-        return mapContextName;
-    }
-
-    public RpcChannel getRpcChannel() {
-        return rpcChannel;
-    }
-
-    public long getRpcTimeout() {
-        return rpcTimeout;
-    }
-
-    public Object getStateMutex() {
-        return stateMutex;
-    }
-
-    public boolean isStateTransferred() {
-        return stateTransferred;
-    }
-
-    public Object getMapOwner() {
-        return mapOwner;
-    }
-
-    public ClassLoader[] getExternalLoaders() {
-        return externalLoaders;
-    }
-
-    public int getChannelSendOptions() {
-        return channelSendOptions;
-    }
-
-    public long getAccessTimeout() {
-        return accessTimeout;
-    }
-
-    public void setMapOwner(Object mapOwner) {
-        this.mapOwner = mapOwner;
-    }
-
-    public void setExternalLoaders(ClassLoader[] externalLoaders) {
-        this.externalLoaders = externalLoaders;
-    }
-
-    public void setChannelSendOptions(int channelSendOptions) {
-        this.channelSendOptions = channelSendOptions;
-    }
-
-    public void setAccessTimeout(long accessTimeout) {
-        this.accessTimeout = accessTimeout;
-    }
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.tipis;
+
+import java.io.IOException;
+import java.io.ObjectInput;
+import java.io.ObjectOutput;
+import java.io.Serializable;
+import java.io.UnsupportedEncodingException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.catalina.tribes.Channel;
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelListener;
+import org.apache.catalina.tribes.Heartbeat;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.MembershipListener;
+import org.apache.catalina.tribes.group.Response;
+import org.apache.catalina.tribes.group.RpcCallback;
+import org.apache.catalina.tribes.group.RpcChannel;
+import org.apache.catalina.tribes.io.XByteBuffer;
+import org.apache.catalina.tribes.membership.MemberImpl;
+import org.apache.catalina.tribes.util.Arrays;
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+import java.util.ConcurrentModificationException;
+
+/**
+ *
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public abstract class AbstractReplicatedMap extends LinkedHashMap implements RpcCallback, ChannelListener, MembershipListener, Heartbeat {
+    protected static Log log = LogFactory.getLog(AbstractReplicatedMap.class);
+
+    /**
+     * The default initial capacity - MUST be a power of two.
+     */
+    public static final int DEFAULT_INITIAL_CAPACITY = 16;
+
+    /**
+     * The load factor used when none specified in constructor.
+     **/
+    public static final float DEFAULT_LOAD_FACTOR = 0.75f;
+    
+    /**
+     * Used to identify the map
+     */
+    final String chset = "ISO-8859-1";
+
+//------------------------------------------------------------------------------
+//              INSTANCE VARIABLES
+//------------------------------------------------------------------------------
+    
+    /**
+     * Timeout for RPC messages, how long we will wait for a reply
+     */
+    protected transient long rpcTimeout = 5000;
+    /**
+     * Reference to the channel for sending messages
+     */
+    protected transient Channel channel;
+    /**
+     * The RpcChannel to send RPC messages through
+     */
+    protected transient RpcChannel rpcChannel;
+    /**
+     * The Map context name makes this map unique, this
+     * allows us to have more than one map shared
+     * through one channel
+     */
+    protected transient byte[] mapContextName;
+    /**
+     * Has the state been transferred
+     */
+    protected transient boolean stateTransferred = false;
+    /**
+     * Simple lock object for transfers
+     */
+    protected transient Object stateMutex = new Object();
+    /**
+     * A list of members in our map
+     */
+    protected transient HashMap mapMembers = new HashMap();
+    /**
+     * Our default send options
+     */
+    protected transient int channelSendOptions = Channel.SEND_OPTIONS_DEFAULT;
+    /**
+     * The owner of this map, ala a SessionManager for example
+     */
+    protected transient Object mapOwner;
+    /**
+     * External class loaders if serialization and deserialization is to be performed successfully.
+     */
+    protected transient ClassLoader[] externalLoaders;
+    
+    /**
+     * The node we are currently backing up data to, this index will rotate
+     * on a round robin basis
+     */
+    protected transient int currentNode = 0;
+    
+    /**
+     * Since the map keeps internal membership
+     * this is the timeout for a ping message to be responded to
+     * If a remote map doesn't respond within this timeframe, 
+     * its considered dead.
+     */
+    protected transient long accessTimeout = 5000;
+    
+    /**
+     * Readable string of the mapContextName value
+     */
+    protected transient String mapname = "";
+    
+
+//------------------------------------------------------------------------------
+//              CONSTRUCTORS
+//------------------------------------------------------------------------------
+
+    /**
+     * Creates a new map
+     * @param channel The channel to use for communication
+     * @param timeout long - timeout for RPC messags
+     * @param mapContextName String - unique name for this map, to allow multiple maps per channel
+     * @param initialCapacity int - the size of this map, see HashMap
+     * @param loadFactor float - load factor, see HashMap
+     * @param cls - a list of classloaders to be used for deserialization of objects.
+     */
+    public AbstractReplicatedMap(Object owner,
+                                 Channel channel, 
+                                 long timeout, 
+                                 String mapContextName, 
+                                 int initialCapacity,
+                                 float loadFactor,
+                                 int channelSendOptions,
+                                 ClassLoader[] cls) {
+        super(initialCapacity, loadFactor);
+        init(owner, channel, mapContextName, timeout, channelSendOptions, cls);
+        
+    }
+
+    /**
+     * Helper methods, wraps a single member in an array
+     * @param m Member
+     * @return Member[]
+     */
+    protected Member[] wrap(Member m) {
+        if ( m == null ) return new Member[0];
+        else return new Member[] {m};
+    }
+
+    /**
+     * Initializes the map by creating the RPC channel, registering itself as a channel listener
+     * This method is also responsible for initiating the state transfer
+     * @param owner Object
+     * @param channel Channel
+     * @param mapContextName String
+     * @param timeout long
+     * @param channelSendOptions int
+     * @param cls ClassLoader[]
+     */
+    protected void init(Object owner, Channel channel, String mapContextName, long timeout, int channelSendOptions,ClassLoader[] cls) {
+        log.info("Initializing AbstractReplicatedMap with context name:"+mapContextName);
+        this.mapOwner = owner;
+        this.externalLoaders = cls;
+        this.channelSendOptions = channelSendOptions;
+        this.channel = channel;
+        this.rpcTimeout = timeout;
+
+        try {
+            this.mapname = mapContextName;
+            //unique context is more efficient if it is stored as bytes
+            this.mapContextName = mapContextName.getBytes(chset);
+        } catch (UnsupportedEncodingException x) {
+            log.warn("Unable to encode mapContextName[" + mapContextName + "] using getBytes(" + chset +") using default getBytes()", x);
+            this.mapContextName = mapContextName.getBytes();
+        }
+        if ( log.isTraceEnabled() ) log.trace("Created Lazy Map with name:"+mapContextName+", bytes:"+Arrays.toString(this.mapContextName));
+
+        //create an rpc channel and add the map as a listener
+        this.rpcChannel = new RpcChannel(this.mapContextName, channel, this);
+        //add this map as a message listener
+        this.channel.addChannelListener(this);
+        //listen for membership notifications
+        this.channel.addMembershipListener(this);
+        
+        
+        try {
+            //broadcast our map, this just notifies other members of our existence
+            broadcast(MapMessage.MSG_INIT, true);
+            //transfer state from another map
+            transferState();
+            //state is transferred, we are ready for messaging
+            broadcast(MapMessage.MSG_START, true);
+        } catch (ChannelException x) {
+            log.warn("Unable to send map start message.");
+            throw new RuntimeException("Unable to start replicated map.",x);
+        }
+    }
+    
+    
+    /**
+     * Sends a ping out to all the members in the cluster, not just map members
+     * that this map is alive.
+     * @param timeout long
+     * @throws ChannelException
+     */
+    protected void ping(long timeout) throws ChannelException {
+        //send out a map membership message, only wait for the first reply
+        MapMessage msg = new MapMessage(this.mapContextName, 
+                                        MapMessage.MSG_INIT,
+                                        false, 
+                                        null, 
+                                        null, 
+                                        null, 
+                                        wrap(channel.getLocalMember(false)));
+        if ( channel.getMembers().length > 0 ) {
+            //send a ping, wait for all nodes to reply
+            Response[] resp = rpcChannel.send(channel.getMembers(), 
+                                              msg, rpcChannel.ALL_REPLY, 
+                                              (channelSendOptions),
+                                              (int) accessTimeout);
+            for (int i = 0; i < resp.length; i++) {
+                memberAlive(resp[i].getSource());
+            } //for
+        }
+        //update our map of members, expire some if we didn't receive a ping back
+        synchronized (mapMembers) {
+            Iterator it = mapMembers.entrySet().iterator();
+            long now = System.currentTimeMillis();
+            while ( it.hasNext() ) {
+                Map.Entry entry = (Map.Entry)it.next();
+                long access = ((Long)entry.getValue()).longValue(); 
+                if ( (now - access) > timeout ) memberDisappeared((Member)entry.getKey());
+            }
+        }//synch
+    }
+
+    /**
+     * We have received a member alive notification
+     * @param member Member
+     */
+    protected void memberAlive(Member member) {
+        synchronized (mapMembers) {
+            if (!mapMembers.containsKey(member)) {
+                mapMemberAdded(member);
+            } //end if
+            mapMembers.put(member, new Long(System.currentTimeMillis()));
+        }
+    }
+    
+    /**
+     * Helper method to broadcast a message to all members in a channel
+     * @param msgtype int
+     * @param rpc boolean
+     * @throws ChannelException
+     */
+    protected void broadcast(int msgtype, boolean rpc) throws ChannelException {
+        //send out a map membership message, only wait for the first reply
+        MapMessage msg = new MapMessage(this.mapContextName, msgtype,
+                                        false, null, null, null, wrap(channel.getLocalMember(false)));
+        if ( rpc) {
+            Response[] resp = rpcChannel.send(channel.getMembers(), msg, rpcChannel.FIRST_REPLY, (channelSendOptions),rpcTimeout);
+            for (int i = 0; i < resp.length; i++) {
+                mapMemberAdded(resp[i].getSource());
+                messageReceived(resp[i].getMessage(), resp[i].getSource());
+            }
+        } else {
+            channel.send(channel.getMembers(),msg,channelSendOptions);
+        }
+    }
+
+    public void breakdown() {
+        finalize();
+    }
+
+    public void finalize() {
+        try {broadcast(MapMessage.MSG_STOP,false); }catch ( Exception ignore){}
+        //cleanup
+        if (this.rpcChannel != null) {
+            this.rpcChannel.breakdown();
+        }
+        if (this.channel != null) {
+            this.channel.removeChannelListener(this);
+            this.channel.removeMembershipListener(this);
+        }
+        this.rpcChannel = null;
+        this.channel = null;
+        this.mapMembers.clear();
+        super.clear();
+        this.stateTransferred = false;
+        this.externalLoaders = null;
+    }
+    
+    public int hashCode() {
+        return Arrays.hashCode(this.mapContextName);
+    }
+    
+    public boolean equals(Object o) {
+        if ( o == null ) return false;
+        if ( !(o instanceof AbstractReplicatedMap)) return false;
+        if ( !(o.getClass().equals(this.getClass())) ) return false;
+        AbstractReplicatedMap other = (AbstractReplicatedMap)o;
+        return Arrays.equals(mapContextName,other.mapContextName);
+    }
+
+//------------------------------------------------------------------------------
+//              GROUP COM INTERFACES
+//------------------------------------------------------------------------------
+    public Member[] getMapMembers(HashMap members) {
+        synchronized (members) {
+            Member[] result = new Member[members.size()];
+            members.keySet().toArray(result);
+            return result;
+        }
+    }
+    public Member[] getMapMembers() {
+        return getMapMembers(this.mapMembers);
+    }
+    
+    public Member[] getMapMembersExcl(Member[] exclude) {
+        synchronized (mapMembers) {
+            HashMap list = (HashMap)mapMembers.clone();
+            for (int i=0; i<exclude.length;i++) list.remove(exclude[i]);
+            return getMapMembers(list);
+        }
+    }
+
+
+    /**
+     * Replicates any changes to the object since the last time
+     * The object has to be primary, ie, if the object is a proxy or a backup, it will not be replicated<br>
+     * @param complete - if set to true, the object is replicated to its backup
+     * if set to false, only objects that implement ReplicatedMapEntry and the isDirty() returns true will
+     * be replicated
+     */
+    public void replicate(Object key, boolean complete) {
+        if ( log.isTraceEnabled() )
+            log.trace("Replicate invoked on key:"+key);
+        MapEntry entry = (MapEntry)super.get(key);
+        if ( entry == null ) return;
+        if ( !entry.isSerializable() ) return;
+        if (entry != null && entry.isPrimary() && entry.getBackupNodes()!= null && entry.getBackupNodes().length > 0) {
+            Object value = entry.getValue();
+            //check to see if we need to replicate this object isDirty()||complete
+            boolean repl = complete || ( (value instanceof ReplicatedMapEntry) && ( (ReplicatedMapEntry) value).isDirty());
+            
+            if (!repl) {
+                if ( log.isTraceEnabled() )
+                    log.trace("Not replicating:"+key+", no change made");
+                
+                return;
+            }
+            //check to see if the message is diffable
+            boolean diff = ( (value instanceof ReplicatedMapEntry) && ( (ReplicatedMapEntry) value).isDiffable());
+            MapMessage msg = null;
+            if (diff) {
+                ReplicatedMapEntry rentry = (ReplicatedMapEntry)entry.getValue();
+                try {
+                    rentry.lock();
+                    //construct a diff message
+                    msg = new MapMessage(mapContextName, MapMessage.MSG_BACKUP,
+                                         true, (Serializable) entry.getKey(), null,
+                                         rentry.getDiff(),
+                                         entry.getBackupNodes());
+                } catch (IOException x) {
+                    log.error("Unable to diff object. Will replicate the entire object instead.", x);
+                } finally {
+                    rentry.unlock();
+                }
+                
+            }
+            if (msg == null) {
+                //construct a complete
+                msg = new MapMessage(mapContextName, MapMessage.MSG_BACKUP,
+                                     false, (Serializable) entry.getKey(),
+                                     (Serializable) entry.getValue(),
+                                     null, entry.getBackupNodes());
+
+            }
+            try {
+                if ( channel!=null && entry.getBackupNodes()!= null && entry.getBackupNodes().length > 0 ) {
+                    channel.send(entry.getBackupNodes(), msg, channelSendOptions);
+                }
+            } catch (ChannelException x) {
+                log.error("Unable to replicate data.", x);
+            }
+        } //end if
+
+    }
+
+    /**
+     * This can be invoked by a periodic thread to replicate out any changes.
+     * For maps that don't store objects that implement ReplicatedMapEntry, this
+     * method should be used infrequently to avoid large amounts of data transfer
+     * @param complete boolean
+     */
+    public void replicate(boolean complete) {
+        Iterator i = super.entrySet().iterator();
+        while (i.hasNext()) {
+            Map.Entry e = (Map.Entry) i.next();
+            replicate(e.getKey(), complete);
+        } //while
+
+    }
+
+    public void transferState() {
+        try {
+            Member[] members = getMapMembers();
+            Member backup = members.length > 0 ? (Member) members[0] : null;
+            if (backup != null) {
+                MapMessage msg = new MapMessage(mapContextName, MapMessage.MSG_STATE, false,
+                                                null, null, null, null);
+                Response[] resp = rpcChannel.send(new Member[] {backup}, msg, rpcChannel.FIRST_REPLY, channelSendOptions, rpcTimeout);
+                if (resp.length > 0) {
+                    synchronized (stateMutex) {
+                        msg = (MapMessage) resp[0].getMessage();
+                        msg.deserialize(getExternalLoaders());
+                        ArrayList list = (ArrayList) msg.getValue();
+                        for (int i = 0; i < list.size(); i++) {
+                            messageReceived( (Serializable) list.get(i), resp[0].getSource());
+                        } //for
+                    }
+                } else {
+                    log.warn("Transfer state, 0 replies, probably a timeout.");
+                }
+            }
+        } catch (ChannelException x) {
+            log.error("Unable to transfer LazyReplicatedMap state.", x);
+        } catch (IOException x) {
+            log.error("Unable to transfer LazyReplicatedMap state.", x);
+        } catch (ClassNotFoundException x) {
+            log.error("Unable to transfer LazyReplicatedMap state.", x);
+        }
+        stateTransferred = true;
+    }
+
+    /**
+     * @todo implement state transfer
+     * @param msg Serializable
+     * @return Serializable - null if no reply should be sent
+     */
+    public Serializable replyRequest(Serializable msg, final Member sender) {
+        if (! (msg instanceof MapMessage))return null;
+        MapMessage mapmsg = (MapMessage) msg;
+
+        //map init request
+        if (mapmsg.getMsgType() == mapmsg.MSG_INIT) {
+            mapmsg.setBackUpNodes(wrap(channel.getLocalMember(false)));
+            return mapmsg;
+        }
+        
+        //map start request
+        if (mapmsg.getMsgType() == mapmsg.MSG_START) {
+            mapmsg.setBackUpNodes(wrap(channel.getLocalMember(false)));
+            mapMemberAdded(sender);
+            return mapmsg;
+        }
+
+        //backup request
+        if (mapmsg.getMsgType() == mapmsg.MSG_RETRIEVE_BACKUP) {
+            MapEntry entry = (MapEntry)super.get(mapmsg.getKey());
+            if (entry == null || (!entry.isSerializable()) )return null;
+            mapmsg.setValue( (Serializable) entry.getValue());
+            return mapmsg;
+        }
+
+        //state transfer request
+        if (mapmsg.getMsgType() == mapmsg.MSG_STATE) {
+            synchronized (stateMutex) { //make sure we dont do two things at the same time
+                ArrayList list = new ArrayList();
+                Iterator i = super.entrySet().iterator();
+                while (i.hasNext()) {
+                    Map.Entry e = (Map.Entry) i.next();
+                    MapEntry entry = (MapEntry) e.getValue();
+                    if ( entry.isSerializable() ) {
+                        MapMessage me = new MapMessage(mapContextName, MapMessage.MSG_PROXY,
+                            false, (Serializable) entry.getKey(), null, null, entry.getBackupNodes());
+                        list.add(me);
+                    }
+                }
+                mapmsg.setValue(list);
+                return mapmsg;
+                
+            } //synchronized
+        }
+
+        return null;
+
+    }
+
+    /**
+     * If the reply has already been sent to the requesting thread,
+     * the rpc callback can handle any data that comes in after the fact.
+     * @param msg Serializable
+     * @param sender Member
+     */
+    public void leftOver(Serializable msg, Member sender) {
+        //left over membership messages
+        if (! (msg instanceof MapMessage))return;
+
+        MapMessage mapmsg = (MapMessage) msg;
+        try {
+            mapmsg.deserialize(getExternalLoaders());
+            if (mapmsg.getMsgType() == MapMessage.MSG_START) {
+                mapMemberAdded(mapmsg.getBackupNodes()[0]);
+            } else if (mapmsg.getMsgType() == MapMessage.MSG_INIT) {
+                memberAlive(mapmsg.getBackupNodes()[0]);
+            }
+        } catch (IOException x ) {
+            log.error("Unable to deserialize MapMessage.",x);
+        } catch (ClassNotFoundException x ) {
+            log.error("Unable to deserialize MapMessage.",x);
+        }
+    }
+
+    public void messageReceived(Serializable msg, Member sender) {
+        if (! (msg instanceof MapMessage)) return;
+
+        MapMessage mapmsg = (MapMessage) msg;
+        if ( log.isTraceEnabled() ) {
+            log.trace("Map["+mapname+"] received message:"+mapmsg);
+        }
+        
+        try {
+            mapmsg.deserialize(getExternalLoaders());
+        } catch (IOException x) {
+            log.error("Unable to deserialize MapMessage.", x);
+            return;
+        } catch (ClassNotFoundException x) {
+            log.error("Unable to deserialize MapMessage.", x);
+            return;
+        }
+        if ( log.isTraceEnabled() ) 
+            log.trace("Map message received from:"+sender.getName()+" msg:"+mapmsg);
+        if (mapmsg.getMsgType() == MapMessage.MSG_START) {
+            mapMemberAdded(mapmsg.getBackupNodes()[0]);
+        }
+
+        if (mapmsg.getMsgType() == MapMessage.MSG_STOP) {
+            memberDisappeared(mapmsg.getBackupNodes()[0]);
+        }
+
+        if (mapmsg.getMsgType() == MapMessage.MSG_PROXY) {
+            MapEntry entry = (MapEntry)super.get(mapmsg.getKey());
+            if ( entry==null ) {
+                entry = new MapEntry(mapmsg.getKey(), mapmsg.getValue());
+                entry.setBackup(false);
+                entry.setProxy(true);
+                entry.setBackupNodes(mapmsg.getBackupNodes());
+                super.put(entry.getKey(), entry);
+            } else {
+                entry.setProxy(true);
+                entry.setBackup(false);
+                entry.setBackupNodes(mapmsg.getBackupNodes());
+            }
+        }
+
+        if (mapmsg.getMsgType() == MapMessage.MSG_REMOVE) {
+            super.remove(mapmsg.getKey());
+        }
+
+        if (mapmsg.getMsgType() == MapMessage.MSG_BACKUP) {
+            MapEntry entry = (MapEntry)super.get(mapmsg.getKey());
+            if (entry == null) {
+                entry = new MapEntry(mapmsg.getKey(), mapmsg.getValue());
+                entry.setBackup(true);
+                entry.setProxy(false);
+                entry.setBackupNodes(mapmsg.getBackupNodes());
+                if (mapmsg.getValue()!=null && mapmsg.getValue() instanceof ReplicatedMapEntry ) {
+                    ((ReplicatedMapEntry)mapmsg.getValue()).setOwner(getMapOwner());
+                }
+            } else {
+                entry.setBackup(true);
+                entry.setProxy(false);
+                entry.setBackupNodes(mapmsg.getBackupNodes());
+                if (entry.getValue() instanceof ReplicatedMapEntry) {
+                    ReplicatedMapEntry diff = (ReplicatedMapEntry) entry.getValue();
+                    if (mapmsg.isDiff()) {
+                        try {
+                            diff.lock();
+                            diff.applyDiff(mapmsg.getDiffValue(), 0, mapmsg.getDiffValue().length);
+                        } catch (Exception x) {
+                            log.error("Unable to apply diff to key:" + entry.getKey(), x);
+                        } finally {
+                            diff.unlock();
+                        }
+                    } else {
+                        if ( mapmsg.getValue()!=null ) entry.setValue(mapmsg.getValue());
+                        ((ReplicatedMapEntry)entry.getValue()).setOwner(getMapOwner());
+                    } //end if
+                } else if  (mapmsg.getValue() instanceof ReplicatedMapEntry) {
+                    ReplicatedMapEntry re = (ReplicatedMapEntry)mapmsg.getValue();
+                    re.setOwner(getMapOwner());
+                    entry.setValue(re);
+                } else {
+                    if ( mapmsg.getValue()!=null ) entry.setValue(mapmsg.getValue());
+                } //end if
+            } //end if
+            super.put(entry.getKey(), entry);
+        } //end if
+    }
+
+    public boolean accept(Serializable msg, Member sender) {
+        boolean result = false;
+        if (msg instanceof MapMessage) {
+            if ( log.isTraceEnabled() ) log.trace("Map["+mapname+"] accepting...."+msg);
+            result = Arrays.equals(mapContextName, ( (MapMessage) msg).getMapId());
+            if ( log.isTraceEnabled() ) log.trace("Msg["+mapname+"] accepted["+result+"]...."+msg);
+        }
+        return result;
+    }
+
+    public void mapMemberAdded(Member member) {
+        if ( member.equals(getChannel().getLocalMember(false)) ) return;
+        boolean memberAdded = false;
+        //select a backup node if we don't have one
+        synchronized (mapMembers) {
+            if (!mapMembers.containsKey(member) ) {
+                mapMembers.put(member, new Long(System.currentTimeMillis()));
+                memberAdded = true;
+            }
+        }
+        if ( memberAdded ) {
+            synchronized (stateMutex) {
+                Iterator i = super.entrySet().iterator();
+                while (i.hasNext()) {
+                    Map.Entry e = (Map.Entry) i.next();
+                    MapEntry entry = (MapEntry) e.getValue();
+                    if ( entry == null ) continue;
+                    if (entry.isPrimary() && (entry.getBackupNodes() == null || entry.getBackupNodes().length == 0)) {
+                        try {
+                            Member[] backup = publishEntryInfo(entry.getKey(), entry.getValue());
+                            entry.setBackupNodes(backup);
+                        } catch (ChannelException x) {
+                            log.error("Unable to select backup node.", x);
+                        } //catch
+                    } //end if
+                } //while
+            } //synchronized
+        }//end if
+    }
+    
+    public boolean inSet(Member m, Member[] set) {
+        if ( set == null ) return false;
+        boolean result = false;
+        for (int i=0; i<set.length && (!result); i++ )
+            if ( m.equals(set[i]) ) result = true;
+        return result;
+    }
+
+    public Member[] excludeFromSet(Member[] mbrs, Member[] set) {
+        ArrayList result = new ArrayList();
+        for (int i=0; i<set.length; i++ ) {
+            boolean include = true;
+            for (int j=0; j<mbrs.length; j++ ) 
+                if ( mbrs[j].equals(set[i]) ) include = false;
+            if ( include ) result.add(set[i]);
+        }
+        return (Member[])result.toArray(new Member[result.size()]);
+    }
+
+    public void memberAdded(Member member) {
+        //do nothing
+    }
+
+    public void memberDisappeared(Member member) {
+        boolean removed = false;
+        synchronized (mapMembers) {
+            removed = (mapMembers.remove(member) != null );
+        }
+        Iterator i = super.entrySet().iterator();
+        while (i.hasNext()) {
+            Map.Entry e = (Map.Entry) i.next();
+            MapEntry entry = (MapEntry) e.getValue();
+            if (entry.isPrimary() && inSet(member,entry.getBackupNodes())) {
+                try {
+                    Member[] backup = publishEntryInfo(entry.getKey(), entry.getValue());
+                    entry.setBackupNodes(backup);
+                } catch (ChannelException x) {
+                    log.error("Unable to relocate[" + entry.getKey() + "] to a new backup node", x);
+                }
+            } //end if
+        } //while
+    }
+
+    public int getNextBackupIndex() {
+        int size = mapMembers.size();
+        if (mapMembers.size() == 0)return -1;
+        int node = currentNode++;
+        if (node >= size) {
+            node = 0;
+            currentNode = 0;
+        }
+        return node;
+    }
+    public Member getNextBackupNode() {
+        Member[] members = getMapMembers();
+        int node = getNextBackupIndex();
+        if ( members.length == 0 || node==-1) return null;
+        if ( node >= members.length ) node = 0;
+        return members[node];
+    }
+
+    protected abstract Member[] publishEntryInfo(Object key, Object value) throws ChannelException;
+    
+    public void heartbeat() {
+        try {
+            ping(accessTimeout);
+        }catch ( Exception x ) {
+            log.error("Unable to send AbstractReplicatedMap.ping message",x);
+        }
+    }
+
+//------------------------------------------------------------------------------    
+//              METHODS TO OVERRIDE    
+//------------------------------------------------------------------------------
+  
+    /**
+     * Removes an object from this map, it will also remove it from 
+     * 
+     * @param key Object
+     * @return Object
+     */
+    public Object remove(Object key) {
+        MapEntry entry = (MapEntry)super.remove(key);
+
+        try {
+            if (getMapMembers().length > 0 ) {
+                MapMessage msg = new MapMessage(getMapContextName(), MapMessage.MSG_REMOVE, false, (Serializable) key, null, null, null);
+                getChannel().send(getMapMembers(), msg, getChannelSendOptions());
+            }
+        } catch ( ChannelException x ) {
+            log.error("Unable to replicate out data for a LazyReplicatedMap.remove operation",x);
+        }
+        return entry!=null?entry.getValue():null;
+    }
+    
+    public Object get(Object key) {
+        MapEntry entry = (MapEntry)super.get(key);
+        if (log.isTraceEnabled()) log.trace("Requesting id:"+key+" entry:"+entry);
+        if ( entry == null ) return null;
+        if ( !entry.isPrimary() ) {
+            //if the message is not primary, we need to retrieve the latest value
+            try {
+                Member[] backup = null;
+                MapMessage msg = null;
+                if ( !entry.isBackup() ) {
+                    //make sure we don't retrieve from ourselves
+                    msg = new MapMessage(getMapContextName(), MapMessage.MSG_RETRIEVE_BACKUP, false,
+                                         (Serializable) key, null, null, null);
+                    Response[] resp = getRpcChannel().send(entry.getBackupNodes(),msg, this.getRpcChannel().FIRST_REPLY, Channel.SEND_OPTIONS_DEFAULT, getRpcTimeout());
+                    if (resp == null || resp.length == 0) {
+                        //no responses
+                        log.warn("Unable to retrieve remote object for key:" + key);
+                        return null;
+                    }
+                    msg = (MapMessage) resp[0].getMessage();
+                    msg.deserialize(getExternalLoaders());
+                    backup = entry.getBackupNodes();
+                    if ( entry.getValue() instanceof ReplicatedMapEntry ) {
+                        ReplicatedMapEntry val = (ReplicatedMapEntry)entry.getValue();
+                        val.setOwner(getMapOwner());
+                    }
+                    if ( msg.getValue()!=null ) entry.setValue(msg.getValue());
+                }
+                if (entry.isBackup()) {
+                    //select a new backup node
+                    backup = publishEntryInfo(key, entry.getValue());
+                } else if ( entry.isProxy() ) {
+                    //invalidate the previous primary
+                    msg = new MapMessage(getMapContextName(),MapMessage.MSG_PROXY,false,(Serializable)key,null,null,backup);
+                    Member[] dest = getMapMembersExcl(backup);
+                    if ( dest!=null && dest.length >0) {
+                        getChannel().send(dest, msg, getChannelSendOptions());
+                    }
+                }
+
+                entry.setBackupNodes(backup);
+                entry.setBackup(false);
+                entry.setProxy(false);
+
+
+            } catch (Exception x) {
+                log.error("Unable to replicate out data for a LazyReplicatedMap.get operation", x);
+                return null;
+            }
+        }
+        if (log.isTraceEnabled()) log.trace("Requesting id:"+key+" result:"+entry.getValue());
+        if ( entry.getValue() != null && entry.getValue() instanceof ReplicatedMapEntry ) {
+            ReplicatedMapEntry val = (ReplicatedMapEntry)entry.getValue();
+            //hack, somehow this is not being set above
+            val.setOwner(getMapOwner());
+            
+        }
+        return entry.getValue();
+    }    
+
+    
+    protected void printMap(String header) {
+        try {
+            System.out.println("\nDEBUG MAP:"+header);
+            System.out.println("Map["+ new String(mapContextName, chset) + ", Map Size:" + super.size());
+            Member[] mbrs = getMapMembers();
+            for ( int i=0; i<mbrs.length;i++ ) {
+                System.out.println("Mbr["+(i+1)+"="+mbrs[i].getName());
+            }
+            Iterator i = super.entrySet().iterator();
+            int cnt = 0;
+
+            while (i.hasNext()) {
+                Map.Entry e = (Map.Entry) i.next();
+                System.out.println( (++cnt) + ". " + e.getValue());
+            }
+            System.out.println("EndMap]\n\n");
+        }catch ( Exception ignore) {
+            ignore.printStackTrace();
+        }
+    }
+    
+    /**
+         * Returns true if the key has an entry in the map.
+         * The entry can be a proxy or a backup entry, invoking <code>get(key)</code>
+         * will make this entry primary for the group
+         * @param key Object
+         * @return boolean
+         */
+        public boolean containsKey(Object key) {
+            return super.containsKey(key);
+        }
+    
+    
+        public Object put(Object key, Object value) {
+            MapEntry entry = new MapEntry(key,value);
+            entry.setBackup(false);
+            entry.setProxy(false);
+    
+            Object old = null;
+    
+            //make sure that any old values get removed
+            if ( containsKey(key) ) old = remove(key);
+            try {
+                Member[] backup = publishEntryInfo(key, value);
+                entry.setBackupNodes(backup);
+            } catch (ChannelException x) {
+                log.error("Unable to replicate out data for a LazyReplicatedMap.put operation", x);
+            }
+            super.put(key,entry);
+            return old;
+        }
+    
+    
+        /**
+         * Copies all values from one map to this instance
+         * @param m Map
+         */
+        public void putAll(Map m) {
+            Iterator i = m.entrySet().iterator();
+            while ( i.hasNext() ) {
+                Map.Entry entry = (Map.Entry)i.next();
+                put(entry.getKey(),entry.getValue());
+            }
+        }
+    
+        public void clear() {
+            //only delete active keys
+            Iterator keys = keySet().iterator();
+            while ( keys.hasNext() ) remove(keys.next());
+        }
+    
+        public boolean containsValue(Object value) {
+            if ( value == null ) {
+                return super.containsValue(value);
+            } else {
+                Iterator i = super.entrySet().iterator();
+                while (i.hasNext()) {
+                    Map.Entry e = (Map.Entry) i.next();
+                    MapEntry entry = (MapEntry) e.getValue();
+                    if (entry.isPrimary() && value.equals(entry.getValue())) return true;
+                }//while
+                return false;
+            }//end if
+        }
+    
+        public Object clone() {
+            throw new UnsupportedOperationException("This operation is not valid on a replicated map");
+        }
+    
+        /**
+         * Returns the entire contents of the map
+         * Map.Entry.getValue() will return a LazyReplicatedMap.MapEntry object containing all the information 
+         * about the object.
+         * @return Set
+         */
+        public Set entrySetFull() {
+            return super.entrySet();
+        }
+    
+        public Set keySetFull() {
+            return super.keySet();
+        }
+    
+        public int sizeFull() {
+            return super.size();
+        }
+    
+        public Set entrySet() {
+            LinkedHashSet set = new LinkedHashSet(super.size());
+            Iterator i = super.entrySet().iterator();
+            while ( i.hasNext() ) {
+                Map.Entry e = (Map.Entry)i.next();
+                MapEntry entry = (MapEntry)e.getValue();
+                if ( entry.isPrimary() ) set.add(entry);
+            }
+            return Collections.unmodifiableSet(set);
+        }
+    
+        public Set keySet() {
+            //todo implement
+            //should only return keys where this is active.
+            LinkedHashSet set = new LinkedHashSet(super.size());
+            Iterator i = super.entrySet().iterator();
+            while ( i.hasNext() ) {
+                Map.Entry e = (Map.Entry)i.next();
+                MapEntry entry = (MapEntry)e.getValue();
+                if ( entry.isPrimary() ) set.add(entry.getKey());
+            }
+            return Collections.unmodifiableSet(set);
+        }
+    
+    
+        public int size() {
+            //todo, implement a counter variable instead
+            //only count active members in this node
+            int counter = 0;
+            Iterator it = Collections.unmodifiableSet(super.entrySet()).iterator();
+            while (it.hasNext() ) {
+                Map.Entry e = (Map.Entry) it.next();
+                if ( e != null ) {
+                    MapEntry entry = (MapEntry) e.getValue();
+                    if (entry.isPrimary() && entry.getValue() != null) counter++;
+                }
+            }
+            return counter;
+        }
+    
+        protected boolean removeEldestEntry(Map.Entry eldest) {
+            return false;
+        }
+    
+        public boolean isEmpty() {
+            return size()==0;
+        }
+    
+        public Collection values() {
+            ArrayList values = new ArrayList();
+            Iterator i = super.entrySet().iterator();
+            while ( i.hasNext() ) {
+                Map.Entry e = (Map.Entry)i.next();
+                MapEntry entry = (MapEntry)e.getValue();
+                if ( entry.isPrimary() && entry.getValue()!=null) values.add(entry.getValue());
+            }
+            return Collections.unmodifiableCollection(values);
+        }
+        
+
+//------------------------------------------------------------------------------
+//                Map Entry class
+//------------------------------------------------------------------------------
+    public static class MapEntry implements Map.Entry {
+        private boolean backup;
+        private boolean proxy;
+        private Member[] backupNodes;
+
+        private Object key;
+        private Object value;
+
+        public MapEntry(Object key, Object value) {
+            setKey(key);
+            setValue(value);
+            
+        }
+        
+        public boolean isKeySerializable() {
+            return (key == null) || (key instanceof Serializable);
+        }
+        
+        public boolean isValueSerializable() {
+            return (value==null) || (value instanceof Serializable);
+        }
+        
+        public boolean isSerializable() {
+            return isKeySerializable() && isValueSerializable();
+        }
+        
+        public boolean isBackup() {
+            return backup;
+        }
+
+        public void setBackup(boolean backup) {
+            this.backup = backup;
+        }
+
+        public boolean isProxy() {
+            return proxy;
+        }
+
+        public boolean isPrimary() {
+            return ( (!proxy) && (!backup));
+        }
+
+        public void setProxy(boolean proxy) {
+            this.proxy = proxy;
+        }
+
+        public boolean isDiffable() {
+            return (value instanceof ReplicatedMapEntry) &&
+                   ((ReplicatedMapEntry)value).isDiffable();
+        }
+
+        public void setBackupNodes(Member[] nodes) {
+            this.backupNodes = nodes;
+        }
+
+        public Member[] getBackupNodes() {
+            return backupNodes;
+        }
+
+        public Object getValue() {
+            return value;
+        }
+
+        public Object setValue(Object value) {
+            Object old = this.value;
+            this.value = (Serializable) value;
+            return old;
+        }
+
+        public Object getKey() {
+            return key;
+        }
+        
+        public Object setKey(Object key) {
+            Object old = this.key;
+            this.key = (Serializable)key;
+            return old;
+        }
+
+        public int hashCode() {
+            return key.hashCode();
+        }
+
+        public boolean equals(Object o) {
+            return key.equals(o);
+        }
+
+        /**
+         * apply a diff, or an entire object
+         * @param data byte[]
+         * @param offset int
+         * @param length int
+         * @param diff boolean
+         * @throws IOException
+         * @throws ClassNotFoundException
+         */
+        public void apply(byte[] data, int offset, int length, boolean diff) throws IOException, ClassNotFoundException {
+            if (isDiffable() && diff) {
+                ReplicatedMapEntry rentry = (ReplicatedMapEntry) value;
+                try {
+                    rentry.lock();
+                    rentry.applyDiff(data, offset, length);
+                } finally {
+                    rentry.unlock();
+                }
+            } else if (length == 0) {
+                value = null;
+                proxy = true;
+            } else {
+                value = XByteBuffer.deserialize(data, offset, length);
+            }
+        }
+        
+        public String toString() {
+            StringBuffer buf = new StringBuffer("MapEntry[key:");
+            buf.append(getKey()).append("; ");
+            buf.append("value:").append(getValue()).append("; ");
+            buf.append("primary:").append(isPrimary()).append("; ");
+            buf.append("backup:").append(isBackup()).append("; ");
+            buf.append("proxy:").append(isProxy()).append(";]");
+            return buf.toString();
+        }
+
+    }
+
+//------------------------------------------------------------------------------
+//                map message to send to and from other maps
+//------------------------------------------------------------------------------
+
+    public static class MapMessage implements Serializable {
+        public static final int MSG_BACKUP = 1;
+        public static final int MSG_RETRIEVE_BACKUP = 2;
+        public static final int MSG_PROXY = 3;
+        public static final int MSG_REMOVE = 4;
+        public static final int MSG_STATE = 5;
+        public static final int MSG_START = 6;
+        public static final int MSG_STOP = 7;
+        public static final int MSG_INIT = 8;
+
+        private byte[] mapId;
+        private int msgtype;
+        private boolean diff;
+        private transient Serializable key;
+        private transient Serializable value;
+        private byte[] valuedata;
+        private byte[] keydata;
+        private byte[] diffvalue;
+        private Member[] nodes;
+        
+        public String toString() {
+            StringBuffer buf = new StringBuffer("MapMessage[context=");
+            buf.append(new String(mapId));
+            buf.append("; type=");
+            buf.append(getTypeDesc());
+            buf.append("; key=");
+            buf.append(key);
+            buf.append("; value=");
+            buf.append(value);
+            return buf.toString();
+        }
+        
+        public String getTypeDesc() {
+            switch (msgtype) {
+                case MSG_BACKUP: return "MSG_BACKUP";
+                case MSG_RETRIEVE_BACKUP: return "MSG_RETRIEVE_BACKUP";
+                case MSG_PROXY: return "MSG_PROXY";
+                case MSG_REMOVE: return "MSG_REMOVE";
+                case MSG_STATE: return "MSG_STATE";
+                case MSG_START: return "MSG_START";
+                case MSG_STOP: return "MSG_STOP";
+                case MSG_INIT: return "MSG_INIT";
+                default : return "UNKNOWN";
+            }
+        }
+
+        public MapMessage() {}
+
+        public MapMessage(byte[] mapId,int msgtype, boolean diff,
+                          Serializable key, Serializable value,
+                          byte[] diffvalue, Member[] nodes)  {
+            this.mapId = mapId;
+            this.msgtype = msgtype;
+            this.diff = diff;
+            this.key = key;
+            this.value = value;
+            this.diffvalue = diffvalue;
+            this.nodes = nodes;
+            setValue(value);
+            setKey(key);
+        }
+        
+        public void deserialize(ClassLoader[] cls) throws IOException, ClassNotFoundException {
+            key(cls);
+            value(cls);
+        }
+
+        public int getMsgType() {
+            return msgtype;
+        }
+
+        public boolean isDiff() {
+            return diff;
+        }
+
+        public Serializable getKey() {
+            try {
+                return key(null);
+            } catch ( Exception x ) {
+                log.error("Deserialization error of the MapMessage.key",x);
+                return null;
+            }
+        }
+
+        public Serializable key(ClassLoader[] cls) throws IOException, ClassNotFoundException {
+            if ( key!=null ) return key;
+            if ( keydata == null || keydata.length == 0 ) return null;
+            key = XByteBuffer.deserialize(keydata,0,keydata.length,cls);
+            keydata = null;
+            return key;
+        }
+        
+        public byte[] getKeyData() {
+            return keydata;
+        }
+        
+        public Serializable getValue() {
+            try {
+                return value(null);
+            } catch ( Exception x ) {
+                log.error("Deserialization error of the MapMessage.value",x);
+                return null;
+            }
+        }
+
+        public Serializable value(ClassLoader[] cls) throws IOException, ClassNotFoundException  {
+            if ( value!=null ) return value;
+            if ( valuedata == null || valuedata.length == 0 ) return null;
+            value = XByteBuffer.deserialize(valuedata,0,valuedata.length,cls);
+            valuedata = null;;
+            return value;
+        }
+        
+        public byte[] getValueData() {
+            return valuedata;
+        }
+
+        public byte[] getDiffValue() {
+            return diffvalue;
+        }
+
+        public Member[] getBackupNodes() {
+            return nodes;
+        }
+
+        private void setBackUpNodes(Member[] nodes) {
+            this.nodes = nodes;
+        }
+
+        public byte[] getMapId() {
+            return mapId;
+        }
+
+        public void setValue(Serializable value) {
+            try {
+                if ( value != null ) valuedata = XByteBuffer.serialize(value);
+                this.value = value;
+            }catch ( IOException x ) {
+                throw new RuntimeException(x);
+            }
+        }
+        
+        public void setKey(Serializable key) {
+            try {
+                if (key != null) keydata = XByteBuffer.serialize(key);
+                this.key = key;
+            } catch (IOException x) {
+                throw new RuntimeException(x);
+            }
+        }
+        
+        protected Member[] readMembers(ObjectInput in) throws IOException, ClassNotFoundException {
+            int nodecount = in.readInt();
+            Member[] members = new Member[nodecount];
+            for ( int i=0; i<members.length; i++ ) {
+                byte[] d = new byte[in.readInt()];
+                in.read(d);
+                if (d.length > 0) members[i] = MemberImpl.getMember(d);
+            }
+            return members;
+        }
+        
+        protected void writeMembers(ObjectOutput out,Member[] members) throws IOException {
+            if ( members == null ) members = new Member[0];
+            out.writeInt(members.length);
+            for (int i=0; i<members.length; i++ ) {
+                if ( members[i] != null ) {
+                    byte[] d = members[i] != null ? ( (MemberImpl)members[i]).getData(false) : new byte[0];
+                    out.writeInt(d.length);
+                    out.write(d);
+                }
+            }
+        }
+        
+        
+        /**
+         * shallow clone
+         * @return Object
+         */
+        public Object clone() {
+            MapMessage msg = new MapMessage(this.mapId, this.msgtype, this.diff, this.key, this.value, this.diffvalue, this.nodes);
+            msg.keydata = this.keydata;
+            msg.valuedata = this.valuedata;
+            return msg;
+        }
+    } //MapMessage
+
+
+    public Channel getChannel() {
+        return channel;
+    }
+
+    public byte[] getMapContextName() {
+        return mapContextName;
+    }
+
+    public RpcChannel getRpcChannel() {
+        return rpcChannel;
+    }
+
+    public long getRpcTimeout() {
+        return rpcTimeout;
+    }
+
+    public Object getStateMutex() {
+        return stateMutex;
+    }
+
+    public boolean isStateTransferred() {
+        return stateTransferred;
+    }
+
+    public Object getMapOwner() {
+        return mapOwner;
+    }
+
+    public ClassLoader[] getExternalLoaders() {
+        return externalLoaders;
+    }
+
+    public int getChannelSendOptions() {
+        return channelSendOptions;
+    }
+
+    public long getAccessTimeout() {
+        return accessTimeout;
+    }
+
+    public void setMapOwner(Object mapOwner) {
+        this.mapOwner = mapOwner;
+    }
+
+    public void setExternalLoaders(ClassLoader[] externalLoaders) {
+        this.externalLoaders = externalLoaders;
+    }
+
+    public void setChannelSendOptions(int channelSendOptions) {
+        this.channelSendOptions = channelSendOptions;
+    }
+
+    public void setAccessTimeout(long accessTimeout) {
+        this.accessTimeout = accessTimeout;
+    }
+
 }
\ No newline at end of file

==================================================
ReplicatedMap.java
index badd99cd9b..64dbfeb9eb 100644
--- a/java/org/apache/catalina/tribes/tipis/LazyReplicatedMap.java
+++ b/java/org/apache/catalina/tribes/tipis/LazyReplicatedMap.java
@@ -1,184 +1,185 @@
-/*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.tipis;
-
-import java.io.Serializable;
-
-import org.apache.catalina.tribes.Channel;
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelListener;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.MembershipListener;
-import org.apache.catalina.tribes.group.RpcCallback;
-import org.apache.catalina.tribes.util.Arrays;
-import org.apache.catalina.tribes.UniqueId;
-
-/**
- * A smart implementation of a stateful replicated map. uses primary/secondary backup strategy. 
- * One node is always the primary and one node is always the backup.
- * This map is synchronized across a cluster, and only has one backup member.<br/>
- * A perfect usage for this map would be a session map for a session manager in a clustered environment.<br/>
- * The only way to modify this list is to use the <code>put, putAll, remove</code> methods.
- * entrySet, entrySetFull, keySet, keySetFull, returns all non modifiable sets.<br><br>
- * If objects (values) in the map change without invoking <code>put()</code> or <code>remove()</code>
- * the data can be distributed using two different methods:<br>
- * <code>replicate(boolean)</code> and <code>replicate(Object, boolean)</code><br>
- * These two methods are very important two understand. The map can work with two set of value objects:<br>
- * 1. Serializable - the entire object gets serialized each time it is replicated<br>
- * 2. ReplicatedMapEntry - this interface allows for a isDirty() flag and to replicate diffs if desired.<br>
- * Implementing the <code>ReplicatedMapEntry</code> interface allows you to decide what objects 
- * get replicated and how much data gets replicated each time.<br>
- * If you implement a smart AOP mechanism to detect changes in underlying objects, you can replicate
- * only those changes by implementing the ReplicatedMapEntry interface, and return true when isDiffable()
- * is invoked.<br><br>
- * 
- * This map implementation doesn't have a background thread running to replicate changes.
- * If you do have changes without invoking put/remove then you need to invoke one of the following methods:
- * <ul>
- * <li><code>replicate(Object,boolean)</code> - replicates only the object that belongs to the key</li>
- * <li><code>replicate(boolean)</code> - Scans the entire map for changes and replicates data</li>
- *  </ul>
- * the <code>boolean</code> value in the <code>replicate</code> method used to decide 
- * whether to only replicate objects that implement the <code>ReplicatedMapEntry</code> interface
- * or to replicate all objects. If an object doesn't implement the <code>ReplicatedMapEntry</code> interface
- * each time the object gets replicated the entire object gets serialized, hence a call to <code>replicate(true)</code>
- * will replicate all objects in this map that are using this node as primary.
- * 
- * <br><br><b>REMBER TO CALL <code>breakdown()</code> or <code>finalize()</code> when you are done with the map to 
- * avoid memory leaks.<br><br>
- * @todo implement periodic sync/transfer thread
- * @author Filip Hanik
- * @version 1.0
- */
-public class LazyReplicatedMap extends AbstractReplicatedMap 
-    implements RpcCallback, ChannelListener, MembershipListener {
-    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(LazyReplicatedMap.class);
-    
-    
-    
-//------------------------------------------------------------------------------    
-//              CONSTRUCTORS / DESTRUCTORS
-//------------------------------------------------------------------------------   
-    /**
-         * Creates a new map
-         * @param channel The channel to use for communication
-         * @param timeout long - timeout for RPC messags
-         * @param mapContextName String - unique name for this map, to allow multiple maps per channel
-         * @param initialCapacity int - the size of this map, see HashMap
-         * @param loadFactor float - load factor, see HashMap
-         */
-        public LazyReplicatedMap(Object owner, Channel channel, long timeout, String mapContextName, int initialCapacity, float loadFactor, ClassLoader[] cls) {
-            super(owner,channel,timeout,mapContextName,initialCapacity,loadFactor, Channel.SEND_OPTIONS_DEFAULT,cls);
-        }
-
-        /**
-         * Creates a new map
-         * @param channel The channel to use for communication
-         * @param timeout long - timeout for RPC messags
-         * @param mapContextName String - unique name for this map, to allow multiple maps per channel
-         * @param initialCapacity int - the size of this map, see HashMap
-         */
-        public LazyReplicatedMap(Object owner, Channel channel, long timeout, String mapContextName, int initialCapacity, ClassLoader[] cls) {
-            super(owner, channel,timeout,mapContextName,initialCapacity, LazyReplicatedMap.DEFAULT_LOAD_FACTOR, Channel.SEND_OPTIONS_DEFAULT, cls);
-        }
-
-        /**
-         * Creates a new map
-         * @param channel The channel to use for communication
-         * @param timeout long - timeout for RPC messags
-         * @param mapContextName String - unique name for this map, to allow multiple maps per channel
-         */
-        public LazyReplicatedMap(Object owner, Channel channel, long timeout, String mapContextName, ClassLoader[] cls) {
-            super(owner, channel,timeout,mapContextName, LazyReplicatedMap.DEFAULT_INITIAL_CAPACITY,LazyReplicatedMap.DEFAULT_LOAD_FACTOR,Channel.SEND_OPTIONS_DEFAULT, cls);
-        }
-
-
-
-
-    
-//------------------------------------------------------------------------------    
-//              METHODS TO OVERRIDE    
-//------------------------------------------------------------------------------
-    /**
-     * publish info about a map pair (key/value) to other nodes in the cluster
-     * @param key Object
-     * @param value Object
-     * @return Member - the backup node
-     * @throws ChannelException
-     */
-    protected Member[] publishEntryInfo(Object key, Object value) throws ChannelException {
-        if  (! (key instanceof Serializable && value instanceof Serializable)  ) return new Member[0];
-        Member[] members = getMapMembers();
-        int firstIdx = getNextBackupIndex();
-        int nextIdx = firstIdx;
-        Member[] backup = new Member[0];
-        
-        //there are no backups
-        if ( members.length == 0 || firstIdx == -1 ) return backup;
-        
-        boolean success = false;
-        do {
-            //select a backup node
-            Member next = members[firstIdx];
-            
-            //increment for the next round of back up selection
-            nextIdx = firstIdx + 1;
-            if ( nextIdx >= members.length ) nextIdx = 0;
-            
-            if (next == null) {
-                continue;
-            }
-            MapMessage msg = null;
-            try {
-                backup = wrap(next);
-                //publish the backup data to one node
-                msg = new MapMessage(getMapContextName(), MapMessage.MSG_BACKUP, false,
-                                     (Serializable) key, (Serializable) value, null, backup);
-                if ( log.isTraceEnabled() ) 
-                    log.trace("Publishing backup data:"+msg+" to: "+next.getName());
-                UniqueId id = getChannel().send(backup, msg, getChannelSendOptions());
-                if ( log.isTraceEnabled() )
-                    log.trace("Data published:"+msg+" msg Id:"+id);
-                //we published out to a backup, mark the test success
-                success = true;
-            }catch ( ChannelException x ) {
-                log.error("Unable to replicate backup key:"+key+" to backup:"+next+". Reason:"+x.getMessage(),x);
-            }
-            try {
-                //publish the data out to all nodes
-                Member[] proxies = excludeFromSet(backup, getMapMembers());
-                if (success && proxies.length > 0 ) {
-                    msg = new MapMessage(getMapContextName(), MapMessage.MSG_PROXY, false,
-                                         (Serializable) key, null, null, backup);
-                    if ( log.isTraceEnabled() ) 
-                    log.trace("Publishing proxy data:"+msg+" to: "+Arrays.toNameString(proxies));
-                    getChannel().send(proxies, msg, getChannelSendOptions());
-                }
-            }catch  ( ChannelException x ) {
-                //log the error, but proceed, this should only happen if a node went down,
-                //and if the node went down, then it can't receive the message, the others
-                //should still get it.
-                log.error("Unable to replicate proxy key:"+key+" to backup:"+next+". Reason:"+x.getMessage(),x);
-            }
-        } while ( !success && (firstIdx!=nextIdx));
-        return backup;
-    }
-    
-    
-
-
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.tipis;
+
+import java.io.Serializable;
+
+import org.apache.catalina.tribes.Channel;
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelListener;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.MembershipListener;
+import org.apache.catalina.tribes.group.RpcCallback;
+import org.apache.catalina.tribes.util.Arrays;
+import org.apache.catalina.tribes.UniqueId;
+
+/**
+ * A smart implementation of a stateful replicated map. uses primary/secondary backup strategy. 
+ * One node is always the primary and one node is always the backup.
+ * This map is synchronized across a cluster, and only has one backup member.<br/>
+ * A perfect usage for this map would be a session map for a session manager in a clustered environment.<br/>
+ * The only way to modify this list is to use the <code>put, putAll, remove</code> methods.
+ * entrySet, entrySetFull, keySet, keySetFull, returns all non modifiable sets.<br><br>
+ * If objects (values) in the map change without invoking <code>put()</code> or <code>remove()</code>
+ * the data can be distributed using two different methods:<br>
+ * <code>replicate(boolean)</code> and <code>replicate(Object, boolean)</code><br>
+ * These two methods are very important two understand. The map can work with two set of value objects:<br>
+ * 1. Serializable - the entire object gets serialized each time it is replicated<br>
+ * 2. ReplicatedMapEntry - this interface allows for a isDirty() flag and to replicate diffs if desired.<br>
+ * Implementing the <code>ReplicatedMapEntry</code> interface allows you to decide what objects 
+ * get replicated and how much data gets replicated each time.<br>
+ * If you implement a smart AOP mechanism to detect changes in underlying objects, you can replicate
+ * only those changes by implementing the ReplicatedMapEntry interface, and return true when isDiffable()
+ * is invoked.<br><br>
+ * 
+ * This map implementation doesn't have a background thread running to replicate changes.
+ * If you do have changes without invoking put/remove then you need to invoke one of the following methods:
+ * <ul>
+ * <li><code>replicate(Object,boolean)</code> - replicates only the object that belongs to the key</li>
+ * <li><code>replicate(boolean)</code> - Scans the entire map for changes and replicates data</li>
+ *  </ul>
+ * the <code>boolean</code> value in the <code>replicate</code> method used to decide 
+ * whether to only replicate objects that implement the <code>ReplicatedMapEntry</code> interface
+ * or to replicate all objects. If an object doesn't implement the <code>ReplicatedMapEntry</code> interface
+ * each time the object gets replicated the entire object gets serialized, hence a call to <code>replicate(true)</code>
+ * will replicate all objects in this map that are using this node as primary.
+ * 
+ * <br><br><b>REMBER TO CALL <code>breakdown()</code> or <code>finalize()</code> when you are done with the map to 
+ * avoid memory leaks.<br><br>
+ * @todo implement periodic sync/transfer thread
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class LazyReplicatedMap extends AbstractReplicatedMap 
+    implements RpcCallback, ChannelListener, MembershipListener {
+    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(LazyReplicatedMap.class);
+    
+    
+    
+//------------------------------------------------------------------------------    
+//              CONSTRUCTORS / DESTRUCTORS
+//------------------------------------------------------------------------------   
+    /**
+         * Creates a new map
+         * @param channel The channel to use for communication
+         * @param timeout long - timeout for RPC messags
+         * @param mapContextName String - unique name for this map, to allow multiple maps per channel
+         * @param initialCapacity int - the size of this map, see HashMap
+         * @param loadFactor float - load factor, see HashMap
+         */
+        public LazyReplicatedMap(Object owner, Channel channel, long timeout, String mapContextName, int initialCapacity, float loadFactor, ClassLoader[] cls) {
+            super(owner,channel,timeout,mapContextName,initialCapacity,loadFactor, Channel.SEND_OPTIONS_DEFAULT,cls);
+        }
+
+        /**
+         * Creates a new map
+         * @param channel The channel to use for communication
+         * @param timeout long - timeout for RPC messags
+         * @param mapContextName String - unique name for this map, to allow multiple maps per channel
+         * @param initialCapacity int - the size of this map, see HashMap
+         */
+        public LazyReplicatedMap(Object owner, Channel channel, long timeout, String mapContextName, int initialCapacity, ClassLoader[] cls) {
+            super(owner, channel,timeout,mapContextName,initialCapacity, LazyReplicatedMap.DEFAULT_LOAD_FACTOR, Channel.SEND_OPTIONS_DEFAULT, cls);
+        }
+
+        /**
+         * Creates a new map
+         * @param channel The channel to use for communication
+         * @param timeout long - timeout for RPC messags
+         * @param mapContextName String - unique name for this map, to allow multiple maps per channel
+         */
+        public LazyReplicatedMap(Object owner, Channel channel, long timeout, String mapContextName, ClassLoader[] cls) {
+            super(owner, channel,timeout,mapContextName, LazyReplicatedMap.DEFAULT_INITIAL_CAPACITY,LazyReplicatedMap.DEFAULT_LOAD_FACTOR,Channel.SEND_OPTIONS_DEFAULT, cls);
+        }
+
+
+
+
+    
+//------------------------------------------------------------------------------    
+//              METHODS TO OVERRIDE    
+//------------------------------------------------------------------------------
+    /**
+     * publish info about a map pair (key/value) to other nodes in the cluster
+     * @param key Object
+     * @param value Object
+     * @return Member - the backup node
+     * @throws ChannelException
+     */
+    protected Member[] publishEntryInfo(Object key, Object value) throws ChannelException {
+        if  (! (key instanceof Serializable && value instanceof Serializable)  ) return new Member[0];
+        Member[] members = getMapMembers();
+        int firstIdx = getNextBackupIndex();
+        int nextIdx = firstIdx;
+        Member[] backup = new Member[0];
+        
+        //there are no backups
+        if ( members.length == 0 || firstIdx == -1 ) return backup;
+        
+        boolean success = false;
+        do {
+            //select a backup node
+            Member next = members[firstIdx];
+            
+            //increment for the next round of back up selection
+            nextIdx = firstIdx + 1;
+            if ( nextIdx >= members.length ) nextIdx = 0;
+            
+            if (next == null) {
+                continue;
+            }
+            MapMessage msg = null;
+            try {
+                backup = wrap(next);
+                //publish the backup data to one node
+                msg = new MapMessage(getMapContextName(), MapMessage.MSG_BACKUP, false,
+                                     (Serializable) key, (Serializable) value, null, backup);
+                if ( log.isTraceEnabled() ) 
+                    log.trace("Publishing backup data:"+msg+" to: "+next.getName());
+                UniqueId id = getChannel().send(backup, msg, getChannelSendOptions());
+                if ( log.isTraceEnabled() )
+                    log.trace("Data published:"+msg+" msg Id:"+id);
+                //we published out to a backup, mark the test success
+                success = true;
+            }catch ( ChannelException x ) {
+                log.error("Unable to replicate backup key:"+key+" to backup:"+next+". Reason:"+x.getMessage(),x);
+            }
+            try {
+                //publish the data out to all nodes
+                Member[] proxies = excludeFromSet(backup, getMapMembers());
+                if (success && proxies.length > 0 ) {
+                    msg = new MapMessage(getMapContextName(), MapMessage.MSG_PROXY, false,
+                                         (Serializable) key, null, null, backup);
+                    if ( log.isTraceEnabled() ) 
+                    log.trace("Publishing proxy data:"+msg+" to: "+Arrays.toNameString(proxies));
+                    getChannel().send(proxies, msg, getChannelSendOptions());
+                }
+            }catch  ( ChannelException x ) {
+                //log the error, but proceed, this should only happen if a node went down,
+                //and if the node went down, then it can't receive the message, the others
+                //should still get it.
+                log.error("Unable to replicate proxy key:"+key+" to backup:"+next+". Reason:"+x.getMessage(),x);
+            }
+        } while ( !success && (firstIdx!=nextIdx));
+        return backup;
+    }
+    
+    
+
+
+
 }
\ No newline at end of file

==================================================
ReplicatedMapEntry.java
index c0cfbb9553..7879d81470 100644
--- a/java/org/apache/catalina/tribes/tipis/ReplicatedMap.java
+++ b/java/org/apache/catalina/tribes/tipis/ReplicatedMap.java
@@ -1,117 +1,118 @@
-/*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.tipis;
-
-import java.io.Serializable;
-
-import org.apache.catalina.tribes.Channel;
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelListener;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.MembershipListener;
-import org.apache.catalina.tribes.group.RpcCallback;
-
-/**
- * All-to-all replication for a hash map implementation. Each node in the cluster will carry an identical 
- * copy of the map.<br><br>
- * This map implementation doesn't have a background thread running to replicate changes.
- * If you do have changes without invoking put/remove then you need to invoke one of the following methods:
- * <ul>
- * <li><code>replicate(Object,boolean)</code> - replicates only the object that belongs to the key</li>
- * <li><code>replicate(boolean)</code> - Scans the entire map for changes and replicates data</li>
- *  </ul>
- * the <code>boolean</code> value in the <code>replicate</code> method used to decide
- * whether to only replicate objects that implement the <code>ReplicatedMapEntry</code> interface
- * or to replicate all objects. If an object doesn't implement the <code>ReplicatedMapEntry</code> interface
- * each time the object gets replicated the entire object gets serialized, hence a call to <code>replicate(true)</code>
- * will replicate all objects in this map that are using this node as primary.
- *
- * <br><br><b>REMBER TO CALL <code>breakdown()</code> or <code>finalize()</code> when you are done with the map to
- * avoid memory leaks.<br><br>
- * @todo implement periodic sync/transfer thread
- * @author Filip Hanik
- * @version 1.0
- * 
- * @todo memberDisappeared, should do nothing except change map membership
- *       by default it relocates the primary objects
- */
-public class ReplicatedMap extends AbstractReplicatedMap implements RpcCallback, ChannelListener, MembershipListener {
-
-    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(ReplicatedMap.class);
-
-//------------------------------------------------------------------------------
-//              CONSTRUCTORS / DESTRUCTORS
-//------------------------------------------------------------------------------
-    /**
-     * Creates a new map
-     * @param channel The channel to use for communication
-     * @param timeout long - timeout for RPC messags
-     * @param mapContextName String - unique name for this map, to allow multiple maps per channel
-     * @param initialCapacity int - the size of this map, see HashMap
-     * @param loadFactor float - load factor, see HashMap
-     */
-    public ReplicatedMap(Object owner, Channel channel, long timeout, String mapContextName, int initialCapacity,float loadFactor, ClassLoader[] cls) {
-        super(owner,channel, timeout, mapContextName, initialCapacity, loadFactor, Channel.SEND_OPTIONS_DEFAULT, cls);
-    }
-
-    /**
-     * Creates a new map
-     * @param channel The channel to use for communication
-     * @param timeout long - timeout for RPC messags
-     * @param mapContextName String - unique name for this map, to allow multiple maps per channel
-     * @param initialCapacity int - the size of this map, see HashMap
-     */
-    public ReplicatedMap(Object owner, Channel channel, long timeout, String mapContextName, int initialCapacity, ClassLoader[] cls) {
-        super(owner,channel, timeout, mapContextName, initialCapacity, AbstractReplicatedMap.DEFAULT_LOAD_FACTOR,Channel.SEND_OPTIONS_DEFAULT, cls);
-    }
-
-    /**
-     * Creates a new map
-     * @param channel The channel to use for communication
-     * @param timeout long - timeout for RPC messags
-     * @param mapContextName String - unique name for this map, to allow multiple maps per channel
-     */
-    public ReplicatedMap(Object owner, Channel channel, long timeout, String mapContextName, ClassLoader[] cls) {
-        super(owner, channel, timeout, mapContextName,AbstractReplicatedMap.DEFAULT_INITIAL_CAPACITY, AbstractReplicatedMap.DEFAULT_LOAD_FACTOR, Channel.SEND_OPTIONS_DEFAULT, cls);
-    }
-
-//------------------------------------------------------------------------------
-//              METHODS TO OVERRIDE
-//------------------------------------------------------------------------------
-    /**
-     * publish info about a map pair (key/value) to other nodes in the cluster
-     * @param key Object
-     * @param value Object
-     * @return Member - the backup node
-     * @throws ChannelException
-     */
-    protected Member[] publishEntryInfo(Object key, Object value) throws ChannelException {
-        if  (! (key instanceof Serializable && value instanceof Serializable)  ) return new Member[0];
-        //select a backup node
-        Member[] backup = getMapMembers();
-
-        if (backup == null || backup.length == 0) return null;
-
-        //publish the data out to all nodes
-        MapMessage msg = new MapMessage(getMapContextName(), MapMessage.MSG_BACKUP, false,
-                                        (Serializable) key, null, null, backup);
-
-        getChannel().send(getMapMembers(), msg, getChannelSendOptions());
-
-        return backup;
-    }
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.tipis;
+
+import java.io.Serializable;
+
+import org.apache.catalina.tribes.Channel;
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelListener;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.MembershipListener;
+import org.apache.catalina.tribes.group.RpcCallback;
+
+/**
+ * All-to-all replication for a hash map implementation. Each node in the cluster will carry an identical 
+ * copy of the map.<br><br>
+ * This map implementation doesn't have a background thread running to replicate changes.
+ * If you do have changes without invoking put/remove then you need to invoke one of the following methods:
+ * <ul>
+ * <li><code>replicate(Object,boolean)</code> - replicates only the object that belongs to the key</li>
+ * <li><code>replicate(boolean)</code> - Scans the entire map for changes and replicates data</li>
+ *  </ul>
+ * the <code>boolean</code> value in the <code>replicate</code> method used to decide
+ * whether to only replicate objects that implement the <code>ReplicatedMapEntry</code> interface
+ * or to replicate all objects. If an object doesn't implement the <code>ReplicatedMapEntry</code> interface
+ * each time the object gets replicated the entire object gets serialized, hence a call to <code>replicate(true)</code>
+ * will replicate all objects in this map that are using this node as primary.
+ *
+ * <br><br><b>REMBER TO CALL <code>breakdown()</code> or <code>finalize()</code> when you are done with the map to
+ * avoid memory leaks.<br><br>
+ * @todo implement periodic sync/transfer thread
+ * @author Filip Hanik
+ * @version 1.0
+ * 
+ * @todo memberDisappeared, should do nothing except change map membership
+ *       by default it relocates the primary objects
+ */
+public class ReplicatedMap extends AbstractReplicatedMap implements RpcCallback, ChannelListener, MembershipListener {
+
+    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(ReplicatedMap.class);
+
+//------------------------------------------------------------------------------
+//              CONSTRUCTORS / DESTRUCTORS
+//------------------------------------------------------------------------------
+    /**
+     * Creates a new map
+     * @param channel The channel to use for communication
+     * @param timeout long - timeout for RPC messags
+     * @param mapContextName String - unique name for this map, to allow multiple maps per channel
+     * @param initialCapacity int - the size of this map, see HashMap
+     * @param loadFactor float - load factor, see HashMap
+     */
+    public ReplicatedMap(Object owner, Channel channel, long timeout, String mapContextName, int initialCapacity,float loadFactor, ClassLoader[] cls) {
+        super(owner,channel, timeout, mapContextName, initialCapacity, loadFactor, Channel.SEND_OPTIONS_DEFAULT, cls);
+    }
+
+    /**
+     * Creates a new map
+     * @param channel The channel to use for communication
+     * @param timeout long - timeout for RPC messags
+     * @param mapContextName String - unique name for this map, to allow multiple maps per channel
+     * @param initialCapacity int - the size of this map, see HashMap
+     */
+    public ReplicatedMap(Object owner, Channel channel, long timeout, String mapContextName, int initialCapacity, ClassLoader[] cls) {
+        super(owner,channel, timeout, mapContextName, initialCapacity, AbstractReplicatedMap.DEFAULT_LOAD_FACTOR,Channel.SEND_OPTIONS_DEFAULT, cls);
+    }
+
+    /**
+     * Creates a new map
+     * @param channel The channel to use for communication
+     * @param timeout long - timeout for RPC messags
+     * @param mapContextName String - unique name for this map, to allow multiple maps per channel
+     */
+    public ReplicatedMap(Object owner, Channel channel, long timeout, String mapContextName, ClassLoader[] cls) {
+        super(owner, channel, timeout, mapContextName,AbstractReplicatedMap.DEFAULT_INITIAL_CAPACITY, AbstractReplicatedMap.DEFAULT_LOAD_FACTOR, Channel.SEND_OPTIONS_DEFAULT, cls);
+    }
+
+//------------------------------------------------------------------------------
+//              METHODS TO OVERRIDE
+//------------------------------------------------------------------------------
+    /**
+     * publish info about a map pair (key/value) to other nodes in the cluster
+     * @param key Object
+     * @param value Object
+     * @return Member - the backup node
+     * @throws ChannelException
+     */
+    protected Member[] publishEntryInfo(Object key, Object value) throws ChannelException {
+        if  (! (key instanceof Serializable && value instanceof Serializable)  ) return new Member[0];
+        //select a backup node
+        Member[] backup = getMapMembers();
+
+        if (backup == null || backup.length == 0) return null;
+
+        //publish the data out to all nodes
+        MapMessage msg = new MapMessage(getMapContextName(), MapMessage.MSG_BACKUP, false,
+                                        (Serializable) key, null, null, backup);
+
+        getChannel().send(getMapMembers(), msg, getChannelSendOptions());
+
+        return backup;
+    }
+
 }
\ No newline at end of file

==================================================
Streamable.java
index bc5b4045a1..78bcb85d56 100644
--- a/java/org/apache/catalina/tribes/tipis/ReplicatedMapEntry.java
+++ b/java/org/apache/catalina/tribes/tipis/ReplicatedMapEntry.java
@@ -1,123 +1,124 @@
-/*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.tipis;
-
-import java.io.IOException;
-import java.io.Serializable;
-
-/**
- * 
- * For smarter replication, an object can implement this interface to replicate diffs<br>
- * The replication logic will call the methods in the following order:<br>
- * <code>
- * 1. if ( entry.isDirty() ) <br>
- *      try {
- * 2.     entry.lock();<br>
- * 3.     byte[] diff = entry.getDiff();<br>
- * 4.     entry.reset();<br>
- *      } finally {<br>
- * 5.     entry.unlock();<br>
- *      }<br>
- *    }<br>
- * </code>
- * <br>
- * <br>
- * When the data is deserialized the logic is called in the following order<br>
- * <code>
- * 1. ReplicatedMapEntry entry = (ReplicatedMapEntry)objectIn.readObject();<br>
- * 2. if ( isBackup(entry)||isPrimary(entry) ) entry.setOwner(owner); <br>
- * </code>
- * <br>
- * 
- * 
- * @author Filip Hanik
- * @version 1.0
- */
-public interface ReplicatedMapEntry extends Serializable {
-    
-    /**
-     * Has the object changed since last replication
-     * and is not in a locked state
-     * @return boolean
-     */
-    public boolean isDirty();
-    
-    /**
-     * If this returns true, the map will extract the diff using getDiff()
-     * Otherwise it will serialize the entire object.
-     * @return boolean
-     */
-    public boolean isDiffable();
-    
-    /**
-     * Returns a diff and sets the dirty map to false
-     * @return byte[]
-     * @throws IOException
-     */
-    public byte[] getDiff() throws IOException;
-    
-    
-    /**
-     * Applies a diff to an existing object.
-     * @param diff byte[]
-     * @param offset int
-     * @param length int
-     * @throws IOException
-     */
-    public void applyDiff(byte[] diff, int offset, int length) throws IOException, ClassNotFoundException;
-    
-    /**
-     * Resets the current diff state and resets the dirty flag
-     */
-    public void resetDiff();
-    
-    /**
-     * Lock during serialization
-     */
-    public void lock();
-    
-    /**
-     * Unlock after serialization
-     */
-    public void unlock();
-    
-    /**
-     * This method is called after the object has been 
-     * created on a remote map. On this method,
-     * the object can initialize itself for any data that wasn't 
-     * 
-     * @param owner Object
-     */
-    public void setOwner(Object owner);
-    
-    /**
-     * For accuracy checking, a serialized attribute can contain a version number
-     * This number increases as modifications are made to the data.
-     * The replicated map can use this to ensure accuracy on a periodic basis
-     * @return long - the version number or -1 if the data is not versioned
-     */
-    public long getVersion();
-    
-    /**
-     * Forces a certain version to a replicated map entry<br>
-     * @param version long
-     */
-    public void setVersion(long version);
-    
-    
-    
-    
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.tipis;
+
+import java.io.IOException;
+import java.io.Serializable;
+
+/**
+ * 
+ * For smarter replication, an object can implement this interface to replicate diffs<br>
+ * The replication logic will call the methods in the following order:<br>
+ * <code>
+ * 1. if ( entry.isDirty() ) <br>
+ *      try {
+ * 2.     entry.lock();<br>
+ * 3.     byte[] diff = entry.getDiff();<br>
+ * 4.     entry.reset();<br>
+ *      } finally {<br>
+ * 5.     entry.unlock();<br>
+ *      }<br>
+ *    }<br>
+ * </code>
+ * <br>
+ * <br>
+ * When the data is deserialized the logic is called in the following order<br>
+ * <code>
+ * 1. ReplicatedMapEntry entry = (ReplicatedMapEntry)objectIn.readObject();<br>
+ * 2. if ( isBackup(entry)||isPrimary(entry) ) entry.setOwner(owner); <br>
+ * </code>
+ * <br>
+ * 
+ * 
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public interface ReplicatedMapEntry extends Serializable {
+    
+    /**
+     * Has the object changed since last replication
+     * and is not in a locked state
+     * @return boolean
+     */
+    public boolean isDirty();
+    
+    /**
+     * If this returns true, the map will extract the diff using getDiff()
+     * Otherwise it will serialize the entire object.
+     * @return boolean
+     */
+    public boolean isDiffable();
+    
+    /**
+     * Returns a diff and sets the dirty map to false
+     * @return byte[]
+     * @throws IOException
+     */
+    public byte[] getDiff() throws IOException;
+    
+    
+    /**
+     * Applies a diff to an existing object.
+     * @param diff byte[]
+     * @param offset int
+     * @param length int
+     * @throws IOException
+     */
+    public void applyDiff(byte[] diff, int offset, int length) throws IOException, ClassNotFoundException;
+    
+    /**
+     * Resets the current diff state and resets the dirty flag
+     */
+    public void resetDiff();
+    
+    /**
+     * Lock during serialization
+     */
+    public void lock();
+    
+    /**
+     * Unlock after serialization
+     */
+    public void unlock();
+    
+    /**
+     * This method is called after the object has been 
+     * created on a remote map. On this method,
+     * the object can initialize itself for any data that wasn't 
+     * 
+     * @param owner Object
+     */
+    public void setOwner(Object owner);
+    
+    /**
+     * For accuracy checking, a serialized attribute can contain a version number
+     * This number increases as modifications are made to the data.
+     * The replicated map can use this to ensure accuracy on a periodic basis
+     * @return long - the version number or -1 if the data is not versioned
+     */
+    public long getVersion();
+    
+    /**
+     * Forces a certain version to a replicated map entry<br>
+     * @param version long
+     */
+    public void setVersion(long version);
+    
+    
+    
+    
 }
\ No newline at end of file

==================================================
Constants.java
index e1e7c9b75a..a38adb28a6 100644
--- a/java/org/apache/catalina/tribes/tipis/Streamable.java
+++ b/java/org/apache/catalina/tribes/tipis/Streamable.java
@@ -1,60 +1,61 @@
-/*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.tipis;
-
-import java.io.IOException;
-
-/**
- * Example usage:
- * <code><pre>
- * byte[] data = new byte[1024];
- * Streamable st = ....;
- * while ( !st.eof() ) {
- * &nbsp;&nbsp;int length = st.read(data,0,data.length);
- * &nbsp;&nbsp;String s = new String(data,0,length);
- * &nbsp;&nbsp;System.out.println(s);
- * }
- * </pre></code>
- * @author Filip Hanik
- * @version 1.0
- */
-public interface Streamable {
-    
-    /**
-     * returns true if the stream has reached its end
-     * @return boolean
-     */
-    public boolean eof();
-   
-    /**
-     * write data into the byte array starting at offset, maximum bytes read are (data.length-offset)
-     * @param data byte[] - the array to read data into
-     * @param offset int - start position for writing data
-     * @return int - the number of bytes written into the data buffer
-     */
-    public int write(byte[] data, int offset, int length) throws IOException;
-    
-    /**
-     * read data into the byte array starting at offset
-     * @param data byte[] - the array to read data into
-     * @param offset int - start position for writing data
-     * @param length - the desired read length
-     * @return int - the number of bytes read from the data buffer
-     */
-    public int read(byte[] data, int offset, int length) throws IOException;
-
-   
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.tipis;
+
+import java.io.IOException;
+
+/**
+ * Example usage:
+ * <code><pre>
+ * byte[] data = new byte[1024];
+ * Streamable st = ....;
+ * while ( !st.eof() ) {
+ * &nbsp;&nbsp;int length = st.read(data,0,data.length);
+ * &nbsp;&nbsp;String s = new String(data,0,length);
+ * &nbsp;&nbsp;System.out.println(s);
+ * }
+ * </pre></code>
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public interface Streamable {
+    
+    /**
+     * returns true if the stream has reached its end
+     * @return boolean
+     */
+    public boolean eof();
+   
+    /**
+     * write data into the byte array starting at offset, maximum bytes read are (data.length-offset)
+     * @param data byte[] - the array to read data into
+     * @param offset int - start position for writing data
+     * @return int - the number of bytes written into the data buffer
+     */
+    public int write(byte[] data, int offset, int length) throws IOException;
+    
+    /**
+     * read data into the byte array starting at offset
+     * @param data byte[] - the array to read data into
+     * @param offset int - start position for writing data
+     * @param length - the desired read length
+     * @return int - the number of bytes read from the data buffer
+     */
+    public int read(byte[] data, int offset, int length) throws IOException;
+
+   
 }
\ No newline at end of file

==================================================
DataSender.java
index c738adb3c9..42b6477ba4 100644
--- a/java/org/apache/catalina/tribes/transport/Constants.java
+++ b/java/org/apache/catalina/tribes/transport/Constants.java
@@ -1,42 +1,43 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina.tribes.transport;
-
-import org.apache.catalina.tribes.io.XByteBuffer;
-
-/**
- * Manifest constants for the <code>org.apache.catalina.tribes.transport</code>
- * package.
- * @author Filip Hanik
- * @author Peter Rossbach
- * @version $Revision: 303753 $ $Date: 2005-03-14 15:24:30 -0600 (Mon, 14 Mar 2005) $
- */
-
-public class Constants {
-
-    public static final String Package = "org.apache.catalina.tribes.transport";
-    
-    /*
-     * Do not change any of these values!
-     */
-    public static final byte[] ACK_DATA = new byte[] {6, 2, 3};
-    public static final byte[] FAIL_ACK_DATA = new byte[] {11, 0, 5};
-    public static final byte[] ACK_COMMAND = XByteBuffer.createDataPackage(ACK_DATA);
-    public static final byte[] FAIL_ACK_COMMAND = XByteBuffer.createDataPackage(FAIL_ACK_DATA);
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.catalina.tribes.transport;
+
+import org.apache.catalina.tribes.io.XByteBuffer;
+
+/**
+ * Manifest constants for the <code>org.apache.catalina.tribes.transport</code>
+ * package.
+ * @author Filip Hanik
+ * @author Peter Rossbach
+ * @version $Revision: 303753 $ $Date: 2005-03-14 15:24:30 -0600 (Mon, 14 Mar 2005) $
+ */
+
+public class Constants {
+
+    public static final String Package = "org.apache.catalina.tribes.transport";
+    
+    /*
+     * Do not change any of these values!
+     */
+    public static final byte[] ACK_DATA = new byte[] {6, 2, 3};
+    public static final byte[] FAIL_ACK_DATA = new byte[] {11, 0, 5};
+    public static final byte[] ACK_COMMAND = XByteBuffer.createDataPackage(ACK_DATA);
+    public static final byte[] FAIL_ACK_COMMAND = XByteBuffer.createDataPackage(FAIL_ACK_DATA);
+
+}

==================================================
MultiPointSender.java
index 51cd3fc901..e9c98c7072 100644
--- a/java/org/apache/catalina/tribes/transport/DataSender.java
+++ b/java/org/apache/catalina/tribes/transport/DataSender.java
@@ -1,46 +1,47 @@
-/*
- * Copyright 1999,2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.transport;
-
-import java.io.IOException;
-
-/**
- * <p>Title: </p>
- *
- * <p>Description: </p>
- *
- * <p>Copyright: Copyright (c) 2005</p>
- *
- * <p>Company: </p>
- *
- * @author not attributable
- * @version 1.0
- */
-public interface DataSender {
-    public void connect() throws IOException;
-    public void disconnect();
-    public boolean isConnected();
-    public void setRxBufSize(int size);
-    public void setTxBufSize(int size);
-    public boolean keepalive();
-    public void setTimeout(long timeout);
-    public void setKeepAliveCount(int maxRequests);
-    public void setKeepAliveTime(long keepAliveTimeInMs);
-    public int getRequestCount();
-    public long getConnectTime();
-    
-    
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.transport;
+
+import java.io.IOException;
+
+/**
+ * <p>Title: </p>
+ *
+ * <p>Description: </p>
+ *
+ * <p>Copyright: Copyright (c) 2005</p>
+ *
+ * <p>Company: </p>
+ *
+ * @author not attributable
+ * @version 1.0
+ */
+public interface DataSender {
+    public void connect() throws IOException;
+    public void disconnect();
+    public boolean isConnected();
+    public void setRxBufSize(int size);
+    public void setTxBufSize(int size);
+    public boolean keepalive();
+    public void setTimeout(long timeout);
+    public void setKeepAliveCount(int maxRequests);
+    public void setKeepAliveTime(long keepAliveTimeInMs);
+    public int getRequestCount();
+    public long getConnectTime();
+    
+    
 }
\ No newline at end of file

==================================================
PooledSender.java
index 51722da4f0..a20b587f79 100644
--- a/java/org/apache/catalina/tribes/transport/MultiPointSender.java
+++ b/java/org/apache/catalina/tribes/transport/MultiPointSender.java
@@ -1,37 +1,38 @@
-/*
- * Copyright 1999,2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.transport;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.Member;
-
-/**
- * @author Filip Hanik
- * @version $Revision: 303993 $ $Date: 2005-07-16 16:05:54 -0500 (Sat, 16 Jul 2005) $
- * @since 5.5.16
- */
-
-public interface MultiPointSender extends DataSender
-{
-    public void sendMessage(Member[] destination, ChannelMessage data) throws ChannelException;
-    public void setRxBufSize(int size);
-    public void setTxBufSize(int size);
-    public void setMaxRetryAttempts(int attempts);
-    public void setDirectBuffer(boolean directBuf);
-    public void memberAdded(Member member);
-    public void memberDisappeared(Member member);
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.transport;
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.Member;
+
+/**
+ * @author Filip Hanik
+ * @version $Revision: 303993 $ $Date: 2005-07-16 16:05:54 -0500 (Sat, 16 Jul 2005) $
+ * @since 5.5.16
+ */
+
+public interface MultiPointSender extends DataSender
+{
+    public void sendMessage(Member[] destination, ChannelMessage data) throws ChannelException;
+    public void setRxBufSize(int size);
+    public void setTxBufSize(int size);
+    public void setMaxRetryAttempts(int attempts);
+    public void setDirectBuffer(boolean directBuf);
+    public void memberAdded(Member member);
+    public void memberDisappeared(Member member);
+}

==================================================
SenderState.java
index 221a92368d..d7d558d511 100644
--- a/java/org/apache/catalina/tribes/transport/PooledSender.java
+++ b/java/org/apache/catalina/tribes/transport/PooledSender.java
@@ -1,197 +1,198 @@
-/*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.transport;
-
-import java.io.IOException;
-import java.util.List;
-
-/**
- * <p>Title: </p>
- *
- * <p>Description: </p>
- *
- * <p>Copyright: Copyright (c) 2005</p>
- *
- * <p>Company: </p>
- *
- * @author not attributable
- * @version 1.0
- */
-public abstract class PooledSender extends AbstractSender implements MultiPointSender {
-    
-    private SenderQueue queue = null;
-    private int poolSize = 25;
-    public PooledSender() {
-        queue = new SenderQueue(this,poolSize);
-    }
-    
-    public abstract DataSender getNewDataSender();
-    
-    public DataSender getSender() {
-        return queue.getSender(getTimeout());
-    }
-    
-    public void returnSender(DataSender sender) {
-        sender.keepalive();
-        queue.returnSender(sender);
-    }
-    
-    public synchronized void connect() throws IOException {
-        //do nothing, happens in the socket sender itself
-        queue.open();
-        setConnected(true);
-    }
-    
-    public synchronized void disconnect() {
-        queue.close();
-        setConnected(false);
-    }
-    
-    
-    public int getInPoolSize() {
-        return queue.getInPoolSize();
-    }
-
-    public int getInUsePoolSize() {
-        return queue.getInUsePoolSize();
-    }
-
-
-    public void setPoolSize(int poolSize) {
-        this.poolSize = poolSize;
-        queue.setLimit(poolSize);
-    }
-
-    public int getPoolSize() {
-        return poolSize;
-    }
-
-    public boolean keepalive() {
-        //do nothing, the pool checks on every return
-        return false;
-    }
-
-    
-
-    //  ----------------------------------------------------- Inner Class
-
-    private class SenderQueue {
-        private int limit = 25;
-
-        PooledSender parent = null;
-
-        private List notinuse = null;
-
-        private List inuse = null;
-
-        private boolean isOpen = true;
-
-        public SenderQueue(PooledSender parent, int limit) {
-            this.limit = limit;
-            this.parent = parent;
-            notinuse = new java.util.LinkedList();
-            inuse = new java.util.LinkedList();
-        }
-
-        /**
-         * @return Returns the limit.
-         */
-        public int getLimit() {
-            return limit;
-        }
-        /**
-         * @param limit The limit to set.
-         */
-        public void setLimit(int limit) {
-            this.limit = limit;
-        }
-        /**
-         * @return
-         */
-        public int getInUsePoolSize() {
-            return inuse.size();
-        }
-
-        /**
-         * @return
-         */
-        public int getInPoolSize() {
-            return notinuse.size();
-        }
-
-        public synchronized DataSender getSender(long timeout) {
-            long start = System.currentTimeMillis();
-            while ( true ) {
-                if (!isOpen)throw new IllegalStateException("Queue is closed");
-                DataSender sender = null;
-                if (notinuse.size() == 0 && inuse.size() < limit) {
-                    sender = parent.getNewDataSender();
-                } else if (notinuse.size() > 0) {
-                    sender = (DataSender) notinuse.remove(0);
-                }
-                if (sender != null) {
-                    inuse.add(sender);
-                    return sender;
-                }//end if
-                long delta = System.currentTimeMillis() - start;
-                if ( delta > timeout && timeout>0) return null;
-                else {
-                    try {
-                        wait(Math.max(timeout - delta,1));
-                    }catch (InterruptedException x){}
-                }//end if
-            }
-        }
-
-        public synchronized void returnSender(DataSender sender) {
-            if ( !isOpen) {
-                sender.disconnect();
-                return;
-            }
-            //to do
-            inuse.remove(sender);
-            //just in case the limit has changed
-            if ( notinuse.size() < this.getLimit() ) notinuse.add(sender);
-            else try {sender.disconnect(); } catch ( Exception ignore){}
-            notify();
-        }
-
-        public synchronized void close() {
-            isOpen = false;
-            Object[] unused = notinuse.toArray();
-            Object[] used = inuse.toArray();
-            for (int i = 0; i < unused.length; i++) {
-                DataSender sender = (DataSender) unused[i];
-                sender.disconnect();
-            }//for
-            for (int i = 0; i < used.length; i++) {
-                DataSender sender = (DataSender) used[i];
-                sender.disconnect();
-            }//for
-            notinuse.clear();
-            inuse.clear();
-            notify();
-            
-
-
-        }
-
-        public synchronized void open() {
-            isOpen = true;
-            notify();
-        }
-    }
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.transport;
+
+import java.io.IOException;
+import java.util.List;
+
+/**
+ * <p>Title: </p>
+ *
+ * <p>Description: </p>
+ *
+ * <p>Copyright: Copyright (c) 2005</p>
+ *
+ * <p>Company: </p>
+ *
+ * @author not attributable
+ * @version 1.0
+ */
+public abstract class PooledSender extends AbstractSender implements MultiPointSender {
+    
+    private SenderQueue queue = null;
+    private int poolSize = 25;
+    public PooledSender() {
+        queue = new SenderQueue(this,poolSize);
+    }
+    
+    public abstract DataSender getNewDataSender();
+    
+    public DataSender getSender() {
+        return queue.getSender(getTimeout());
+    }
+    
+    public void returnSender(DataSender sender) {
+        sender.keepalive();
+        queue.returnSender(sender);
+    }
+    
+    public synchronized void connect() throws IOException {
+        //do nothing, happens in the socket sender itself
+        queue.open();
+        setConnected(true);
+    }
+    
+    public synchronized void disconnect() {
+        queue.close();
+        setConnected(false);
+    }
+    
+    
+    public int getInPoolSize() {
+        return queue.getInPoolSize();
+    }
+
+    public int getInUsePoolSize() {
+        return queue.getInUsePoolSize();
+    }
+
+
+    public void setPoolSize(int poolSize) {
+        this.poolSize = poolSize;
+        queue.setLimit(poolSize);
+    }
+
+    public int getPoolSize() {
+        return poolSize;
+    }
+
+    public boolean keepalive() {
+        //do nothing, the pool checks on every return
+        return false;
+    }
+
+    
+
+    //  ----------------------------------------------------- Inner Class
+
+    private class SenderQueue {
+        private int limit = 25;
+
+        PooledSender parent = null;
+
+        private List notinuse = null;
+
+        private List inuse = null;
+
+        private boolean isOpen = true;
+
+        public SenderQueue(PooledSender parent, int limit) {
+            this.limit = limit;
+            this.parent = parent;
+            notinuse = new java.util.LinkedList();
+            inuse = new java.util.LinkedList();
+        }
+
+        /**
+         * @return Returns the limit.
+         */
+        public int getLimit() {
+            return limit;
+        }
+        /**
+         * @param limit The limit to set.
+         */
+        public void setLimit(int limit) {
+            this.limit = limit;
+        }
+        /**
+         * @return
+         */
+        public int getInUsePoolSize() {
+            return inuse.size();
+        }
+
+        /**
+         * @return
+         */
+        public int getInPoolSize() {
+            return notinuse.size();
+        }
+
+        public synchronized DataSender getSender(long timeout) {
+            long start = System.currentTimeMillis();
+            while ( true ) {
+                if (!isOpen)throw new IllegalStateException("Queue is closed");
+                DataSender sender = null;
+                if (notinuse.size() == 0 && inuse.size() < limit) {
+                    sender = parent.getNewDataSender();
+                } else if (notinuse.size() > 0) {
+                    sender = (DataSender) notinuse.remove(0);
+                }
+                if (sender != null) {
+                    inuse.add(sender);
+                    return sender;
+                }//end if
+                long delta = System.currentTimeMillis() - start;
+                if ( delta > timeout && timeout>0) return null;
+                else {
+                    try {
+                        wait(Math.max(timeout - delta,1));
+                    }catch (InterruptedException x){}
+                }//end if
+            }
+        }
+
+        public synchronized void returnSender(DataSender sender) {
+            if ( !isOpen) {
+                sender.disconnect();
+                return;
+            }
+            //to do
+            inuse.remove(sender);
+            //just in case the limit has changed
+            if ( notinuse.size() < this.getLimit() ) notinuse.add(sender);
+            else try {sender.disconnect(); } catch ( Exception ignore){}
+            notify();
+        }
+
+        public synchronized void close() {
+            isOpen = false;
+            Object[] unused = notinuse.toArray();
+            Object[] used = inuse.toArray();
+            for (int i = 0; i < unused.length; i++) {
+                DataSender sender = (DataSender) unused[i];
+                sender.disconnect();
+            }//for
+            for (int i = 0; i < used.length; i++) {
+                DataSender sender = (DataSender) used[i];
+                sender.disconnect();
+            }//for
+            notinuse.clear();
+            inuse.clear();
+            notify();
+            
+
+
+        }
+
+        public synchronized void open() {
+            isOpen = true;
+            notify();
+        }
+    }
 }
\ No newline at end of file

==================================================
ThreadPool.java
index be7152305e..07131477e1 100644
--- a/java/org/apache/catalina/tribes/transport/SenderState.java
+++ b/java/org/apache/catalina/tribes/transport/SenderState.java
@@ -1,114 +1,115 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.transport;
-
-import org.apache.catalina.tribes.Member;
-import java.util.HashMap;
-
-
-/**
- * 
- * @author Filip Hanik
- * @version 1.0
- * @since 5.5.16
- */
-
-public class SenderState {
-    
-    public static final int READY = 0;
-    public static final int SUSPECT = 1;
-    public static final int FAILING = 2;
-    /**
-     * The descriptive information about this implementation.
-     */
-    private static final String info = "SenderState/1.0";
-    
-    
-    protected static HashMap memberStates = new HashMap();
-    
-    public static SenderState getSenderState(Member member) {
-        return getSenderState(member,true);
-    }
-
-    public static SenderState getSenderState(Member member, boolean create) {
-        SenderState state = (SenderState)memberStates.get(member);
-        if ( state == null && create) {
-            synchronized ( memberStates ) {
-                state = (SenderState)memberStates.get(member);
-                if ( state == null ) {
-                    state = new SenderState();
-                    memberStates.put(member,state);
-                }
-            }
-        }
-        return state;
-    }
-    
-    public static void removeSenderState(Member member) {
-        synchronized ( memberStates ) {
-            memberStates.remove(member);
-        }
-    }
-    
-
-    // ----------------------------------------------------- Instance Variables
-
-    private int state = READY;
-
-    //  ----------------------------------------------------- Constructor
-
-    
-    private SenderState() {
-        this(READY);
-    }
-
-    private SenderState(int state) {
-        this.state = state;
-    }
-    
-    /**
-     * 
-     * @return boolean
-     */
-    public boolean isSuspect() {
-        return (state == SUSPECT) || (state == FAILING);
-    }
-
-    public void setSuspect() {
-        state = SUSPECT;
-    }
-    
-    public boolean isReady() {
-        return state == READY;
-    }
-    
-    public void setReady() {
-        state = READY;
-    }
-    
-    public boolean isFailing() {
-        return state == FAILING;
-    }
-    
-    public void setFailing() {
-        state = FAILING;
-    }
-    
-
-    //  ----------------------------------------------------- Public Properties
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.transport;
+
+import org.apache.catalina.tribes.Member;
+import java.util.HashMap;
+
+
+/**
+ * 
+ * @author Filip Hanik
+ * @version 1.0
+ * @since 5.5.16
+ */
+
+public class SenderState {
+    
+    public static final int READY = 0;
+    public static final int SUSPECT = 1;
+    public static final int FAILING = 2;
+    /**
+     * The descriptive information about this implementation.
+     */
+    private static final String info = "SenderState/1.0";
+    
+    
+    protected static HashMap memberStates = new HashMap();
+    
+    public static SenderState getSenderState(Member member) {
+        return getSenderState(member,true);
+    }
+
+    public static SenderState getSenderState(Member member, boolean create) {
+        SenderState state = (SenderState)memberStates.get(member);
+        if ( state == null && create) {
+            synchronized ( memberStates ) {
+                state = (SenderState)memberStates.get(member);
+                if ( state == null ) {
+                    state = new SenderState();
+                    memberStates.put(member,state);
+                }
+            }
+        }
+        return state;
+    }
+    
+    public static void removeSenderState(Member member) {
+        synchronized ( memberStates ) {
+            memberStates.remove(member);
+        }
+    }
+    
+
+    // ----------------------------------------------------- Instance Variables
+
+    private int state = READY;
+
+    //  ----------------------------------------------------- Constructor
+
+    
+    private SenderState() {
+        this(READY);
+    }
+
+    private SenderState(int state) {
+        this.state = state;
+    }
+    
+    /**
+     * 
+     * @return boolean
+     */
+    public boolean isSuspect() {
+        return (state == SUSPECT) || (state == FAILING);
+    }
+
+    public void setSuspect() {
+        state = SUSPECT;
+    }
+    
+    public boolean isReady() {
+        return state == READY;
+    }
+    
+    public void setReady() {
+        state = READY;
+    }
+    
+    public boolean isFailing() {
+        return state == FAILING;
+    }
+    
+    public void setFailing() {
+        state = FAILING;
+    }
+    
+
+    //  ----------------------------------------------------- Public Properties
+
+}

==================================================
WorkerThread.java
index 32f3dd3360..fbe1e3e47d 100644
--- a/java/org/apache/catalina/tribes/transport/ThreadPool.java
+++ b/java/org/apache/catalina/tribes/transport/ThreadPool.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
BioReplicationThread.java
index 70d9512501..d5e3051249 100644
--- a/java/org/apache/catalina/tribes/transport/WorkerThread.java
+++ b/java/org/apache/catalina/tribes/transport/WorkerThread.java
@@ -1,88 +1,89 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.transport;
-
-import org.apache.catalina.tribes.io.ListenCallback;
-
-
-
-
-/**
- * @author Filip Hanik
- * @version $Revision: 366253 $ $Date: 2006-01-05 13:30:42 -0600 (Thu, 05 Jan 2006) $
- */
-public abstract class WorkerThread extends Thread 
-{
-    
-    public static final int OPTION_DIRECT_BUFFER = ReceiverBase.OPTION_DIRECT_BUFFER;
-    
-    private ListenCallback callback;
-    private ThreadPool pool;
-    private boolean doRun = true;
-    private int options;
-    protected boolean useBufferPool = true;
-
-    public WorkerThread(ListenCallback callback) {
-        this.callback = callback;
-    }
-
-    public void setPool(ThreadPool pool) {
-        this.pool = pool;
-    }
-
-    public void setOptions(int options) {
-        this.options = options;
-    }
-
-    public void setCallback(ListenCallback callback) {
-        this.callback = callback;
-    }
-
-    public void setDoRun(boolean doRun) {
-        this.doRun = doRun;
-    }
-
-    public ThreadPool getPool() {
-        return pool;
-    }
-
-    public int getOptions() {
-        return options;
-    }
-
-    public ListenCallback getCallback() {
-        return callback;
-    }
-
-    public boolean isDoRun() {
-        return doRun;
-    }
-
-    public void close()
-    {
-        doRun = false;
-        notify();
-    }
-    
-    public void setUseBufferPool(boolean usebufpool) {
-        useBufferPool = usebufpool;
-    }
-    
-    public boolean getUseBufferPool() {
-        return useBufferPool;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.transport;
+
+import org.apache.catalina.tribes.io.ListenCallback;
+
+
+
+
+/**
+ * @author Filip Hanik
+ * @version $Revision: 366253 $ $Date: 2006-01-05 13:30:42 -0600 (Thu, 05 Jan 2006) $
+ */
+public abstract class WorkerThread extends Thread 
+{
+    
+    public static final int OPTION_DIRECT_BUFFER = ReceiverBase.OPTION_DIRECT_BUFFER;
+    
+    private ListenCallback callback;
+    private ThreadPool pool;
+    private boolean doRun = true;
+    private int options;
+    protected boolean useBufferPool = true;
+
+    public WorkerThread(ListenCallback callback) {
+        this.callback = callback;
+    }
+
+    public void setPool(ThreadPool pool) {
+        this.pool = pool;
+    }
+
+    public void setOptions(int options) {
+        this.options = options;
+    }
+
+    public void setCallback(ListenCallback callback) {
+        this.callback = callback;
+    }
+
+    public void setDoRun(boolean doRun) {
+        this.doRun = doRun;
+    }
+
+    public ThreadPool getPool() {
+        return pool;
+    }
+
+    public int getOptions() {
+        return options;
+    }
+
+    public ListenCallback getCallback() {
+        return callback;
+    }
+
+    public boolean isDoRun() {
+        return doRun;
+    }
+
+    public void close()
+    {
+        doRun = false;
+        notify();
+    }
+    
+    public void setUseBufferPool(boolean usebufpool) {
+        useBufferPool = usebufpool;
+    }
+    
+    public boolean getUseBufferPool() {
+        return useBufferPool;
+    }
+}

==================================================
FastQueue.java
index 80c8fff470..4edc9ee6b7 100644
--- a/java/org/apache/catalina/tribes/transport/bio/BioReplicationThread.java
+++ b/java/org/apache/catalina/tribes/transport/bio/BioReplicationThread.java
@@ -1,180 +1,181 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.transport.bio;
-import java.io.IOException;
-
-import org.apache.catalina.tribes.io.ObjectReader;
-import org.apache.catalina.tribes.transport.Constants;
-import org.apache.catalina.tribes.transport.WorkerThread;
-import java.net.Socket;
-import java.io.InputStream;
-import org.apache.catalina.tribes.transport.ReceiverBase;
-import java.io.OutputStream;
-import org.apache.catalina.tribes.io.ListenCallback;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.io.ChannelData;
-import org.apache.catalina.tribes.io.BufferPool;
-
-/**
- * A worker thread class which can drain channels and echo-back the input. Each
- * instance is constructed with a reference to the owning thread pool object.
- * When started, the thread loops forever waiting to be awakened to service the
- * channel associated with a SelectionKey object. The worker is tasked by
- * calling its serviceChannel() method with a SelectionKey object. The
- * serviceChannel() method stores the key reference in the thread object then
- * calls notify() to wake it up. When the channel has been drained, the worker
- * thread returns itself to its parent pool.
- * 
- * @author Filip Hanik
- * 
- * @version $Revision: 378050 $, $Date: 2006-02-15 12:30:02 -0600 (Wed, 15 Feb 2006) $
- */
-public class BioReplicationThread extends WorkerThread {
-
-
-    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( BioReplicationThread.class );
-    
-    protected Socket socket;
-    protected ObjectReader reader;
-    
-    public BioReplicationThread (ListenCallback callback) {
-        super(callback);
-    }
-
-    // loop forever waiting for work to do
-    public synchronized void run()
-    {
-        this.notify();
-        while (isDoRun()) {
-            try {
-                // sleep and release object lock
-                this.wait();
-            } catch (InterruptedException e) {
-                if(log.isInfoEnabled())
-                    log.info("TCP worker thread interrupted in cluster",e);
-                // clear interrupt status
-                Thread.interrupted();
-            }
-            if ( socket == null ) continue;
-            try {
-                drainSocket();
-            } catch ( Exception x ) {
-                log.error("Unable to service bio socket");
-            }finally {
-                try {socket.close();}catch ( Exception ignore){}
-                try {reader.close();}catch ( Exception ignore){}
-                reader = null;
-                socket = null;
-            }
-            // done, ready for more, return to pool
-            if ( getPool() != null ) getPool().returnWorker (this);
-            else setDoRun(false);
-        }
-    }
-
-    
-    public synchronized void serviceSocket(Socket socket, ObjectReader reader) {
-        this.socket = socket;
-        this.reader = reader;
-        this.notify();		// awaken the thread
-    }
-    
-    protected void execute(ObjectReader reader) throws Exception{
-        int pkgcnt = reader.count();
-
-        if ( pkgcnt > 0 ) {
-            ChannelMessage[] msgs = reader.execute();
-            for ( int i=0; i<msgs.length; i++ ) {
-                /**
-                 * Use send ack here if you want to ack the request to the remote 
-                 * server before completing the request
-                 * This is considered an asynchronized request
-                 */
-                if (ChannelData.sendAckAsync(msgs[i].getOptions())) sendAck(Constants.ACK_COMMAND);
-                try {
-                    //process the message
-                    getCallback().messageDataReceived(msgs[i]);
-                    /**
-                     * Use send ack here if you want the request to complete on this
-                     * server before sending the ack to the remote server
-                     * This is considered a synchronized request
-                     */
-                    if (ChannelData.sendAckSync(msgs[i].getOptions())) sendAck(Constants.ACK_COMMAND);
-                }catch  ( Exception x ) {
-                    if (ChannelData.sendAckSync(msgs[i].getOptions())) sendAck(Constants.FAIL_ACK_COMMAND);
-                    log.error("Error thrown from messageDataReceived.",x);
-                }
-                if ( getUseBufferPool() ) {
-                    BufferPool.getBufferPool().returnBuffer(msgs[i].getMessage());
-                    msgs[i].setMessage(null);
-                }
-            }                       
-        }
-
-       
-    }
-
-    /**
-     * The actual code which drains the channel associated with
-     * the given key.  This method assumes the key has been
-     * modified prior to invocation to turn off selection
-     * interest in OP_READ.  When this method completes it
-     * re-enables OP_READ and calls wakeup() on the selector
-     * so the selector will resume watching this channel.
-     */
-    protected void drainSocket () throws Exception {
-        InputStream in = socket.getInputStream();
-        // loop while data available, channel is non-blocking
-        byte[] buf = new byte[1024];
-        int length = in.read(buf);
-        while ( length >= 0 ) {
-            int count = reader.append(buf,0,length,true);
-            if ( count > 0 ) execute(reader);
-            length = in.read(buf);
-        }
-    }
-
-
-
-
-    /**
-     * send a reply-acknowledgement (6,2,3)
-     * @param key
-     * @param channel
-     */
-    protected void sendAck(byte[] command) {
-        try {
-            OutputStream out = socket.getOutputStream();
-            out.write(command);
-            out.flush();
-            if (log.isTraceEnabled()) {
-                log.trace("ACK sent to " + socket.getPort());
-            }
-        } catch ( java.io.IOException x ) {
-            log.warn("Unable to send ACK back through channel, channel disconnected?: "+x.getMessage());
-        }
-    }
-    
-    public void close() {
-        setDoRun(false);
-        try {socket.close();}catch ( Exception ignore){}
-        try {reader.close();}catch ( Exception ignore){}
-        reader = null;
-        socket = null;
-        super.close();
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.transport.bio;
+import java.io.IOException;
+
+import org.apache.catalina.tribes.io.ObjectReader;
+import org.apache.catalina.tribes.transport.Constants;
+import org.apache.catalina.tribes.transport.WorkerThread;
+import java.net.Socket;
+import java.io.InputStream;
+import org.apache.catalina.tribes.transport.ReceiverBase;
+import java.io.OutputStream;
+import org.apache.catalina.tribes.io.ListenCallback;
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.io.ChannelData;
+import org.apache.catalina.tribes.io.BufferPool;
+
+/**
+ * A worker thread class which can drain channels and echo-back the input. Each
+ * instance is constructed with a reference to the owning thread pool object.
+ * When started, the thread loops forever waiting to be awakened to service the
+ * channel associated with a SelectionKey object. The worker is tasked by
+ * calling its serviceChannel() method with a SelectionKey object. The
+ * serviceChannel() method stores the key reference in the thread object then
+ * calls notify() to wake it up. When the channel has been drained, the worker
+ * thread returns itself to its parent pool.
+ * 
+ * @author Filip Hanik
+ * 
+ * @version $Revision: 378050 $, $Date: 2006-02-15 12:30:02 -0600 (Wed, 15 Feb 2006) $
+ */
+public class BioReplicationThread extends WorkerThread {
+
+
+    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( BioReplicationThread.class );
+    
+    protected Socket socket;
+    protected ObjectReader reader;
+    
+    public BioReplicationThread (ListenCallback callback) {
+        super(callback);
+    }
+
+    // loop forever waiting for work to do
+    public synchronized void run()
+    {
+        this.notify();
+        while (isDoRun()) {
+            try {
+                // sleep and release object lock
+                this.wait();
+            } catch (InterruptedException e) {
+                if(log.isInfoEnabled())
+                    log.info("TCP worker thread interrupted in cluster",e);
+                // clear interrupt status
+                Thread.interrupted();
+            }
+            if ( socket == null ) continue;
+            try {
+                drainSocket();
+            } catch ( Exception x ) {
+                log.error("Unable to service bio socket");
+            }finally {
+                try {socket.close();}catch ( Exception ignore){}
+                try {reader.close();}catch ( Exception ignore){}
+                reader = null;
+                socket = null;
+            }
+            // done, ready for more, return to pool
+            if ( getPool() != null ) getPool().returnWorker (this);
+            else setDoRun(false);
+        }
+    }
+
+    
+    public synchronized void serviceSocket(Socket socket, ObjectReader reader) {
+        this.socket = socket;
+        this.reader = reader;
+        this.notify();		// awaken the thread
+    }
+    
+    protected void execute(ObjectReader reader) throws Exception{
+        int pkgcnt = reader.count();
+
+        if ( pkgcnt > 0 ) {
+            ChannelMessage[] msgs = reader.execute();
+            for ( int i=0; i<msgs.length; i++ ) {
+                /**
+                 * Use send ack here if you want to ack the request to the remote 
+                 * server before completing the request
+                 * This is considered an asynchronized request
+                 */
+                if (ChannelData.sendAckAsync(msgs[i].getOptions())) sendAck(Constants.ACK_COMMAND);
+                try {
+                    //process the message
+                    getCallback().messageDataReceived(msgs[i]);
+                    /**
+                     * Use send ack here if you want the request to complete on this
+                     * server before sending the ack to the remote server
+                     * This is considered a synchronized request
+                     */
+                    if (ChannelData.sendAckSync(msgs[i].getOptions())) sendAck(Constants.ACK_COMMAND);
+                }catch  ( Exception x ) {
+                    if (ChannelData.sendAckSync(msgs[i].getOptions())) sendAck(Constants.FAIL_ACK_COMMAND);
+                    log.error("Error thrown from messageDataReceived.",x);
+                }
+                if ( getUseBufferPool() ) {
+                    BufferPool.getBufferPool().returnBuffer(msgs[i].getMessage());
+                    msgs[i].setMessage(null);
+                }
+            }                       
+        }
+
+       
+    }
+
+    /**
+     * The actual code which drains the channel associated with
+     * the given key.  This method assumes the key has been
+     * modified prior to invocation to turn off selection
+     * interest in OP_READ.  When this method completes it
+     * re-enables OP_READ and calls wakeup() on the selector
+     * so the selector will resume watching this channel.
+     */
+    protected void drainSocket () throws Exception {
+        InputStream in = socket.getInputStream();
+        // loop while data available, channel is non-blocking
+        byte[] buf = new byte[1024];
+        int length = in.read(buf);
+        while ( length >= 0 ) {
+            int count = reader.append(buf,0,length,true);
+            if ( count > 0 ) execute(reader);
+            length = in.read(buf);
+        }
+    }
+
+
+
+
+    /**
+     * send a reply-acknowledgement (6,2,3)
+     * @param key
+     * @param channel
+     */
+    protected void sendAck(byte[] command) {
+        try {
+            OutputStream out = socket.getOutputStream();
+            out.write(command);
+            out.flush();
+            if (log.isTraceEnabled()) {
+                log.trace("ACK sent to " + socket.getPort());
+            }
+        } catch ( java.io.IOException x ) {
+            log.warn("Unable to send ACK back through channel, channel disconnected?: "+x.getMessage());
+        }
+    }
+    
+    public void close() {
+        setDoRun(false);
+        try {socket.close();}catch ( Exception ignore){}
+        try {reader.close();}catch ( Exception ignore){}
+        reader = null;
+        socket = null;
+        super.close();
+    }
+}

==================================================
LinkObject.java
index 439c530c26..064a0f0446 100644
--- a/java/org/apache/catalina/tribes/transport/bio/util/FastQueue.java
+++ b/java/org/apache/catalina/tribes/transport/bio/util/FastQueue.java
@@ -1,393 +1,394 @@
-/*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.transport.bio.util;
-
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.ErrorHandler;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.group.InterceptorPayload;
-
-
-
-/**
- * A fast queue that remover thread lock the adder thread. <br/>Limit the queue
- * length when you have strange producer thread problemes.
- * 
- * FIXME add i18n support to log messages
- * @author Rainer Jung
- * @author Peter Rossbach
- * @version $Revision: 345567 $ $Date: 2005-11-18 15:07:23 -0600 (Fri, 18 Nov 2005) $
- */
-public class FastQueue {
-
-    private static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(FastQueue.class);
-
-    /**
-     * This is the actual queue
-     */
-    private SingleRemoveSynchronizedAddLock lock = null;
-
-    /**
-     * First Object at queue (consumer message)
-     */
-    private LinkObject first = null;
-
-    /**
-     * Last object in queue (producer Object)
-     */
-    private LinkObject last = null;
-
-    /**
-     * Current Queue elements size
-     */
-    private int size = 0;
-
-    /**
-     * check lock to detect strange threadings things
-     */
-    private boolean checkLock = false;
-
-    /**
-     * protocol the thread wait times
-     */
-    private boolean timeWait = false;
-
-    private boolean inAdd = false;
-
-    private boolean inRemove = false;
-
-    private boolean inMutex = false;
-
-    /**
-     * limit the queue legnth ( default is unlimited)
-     */
-    private int maxQueueLength = 0;
-
-    /**
-     * addWaitTimeout for producer
-     */
-    private long addWaitTimeout = 10000L;
-
-    
-    /**
-     * removeWaitTimeout for consumer
-     */
-    private long removeWaitTimeout = 30000L;
-
-    /**
-     * enabled the queue
-     */
-    private boolean enabled = true;
-
-    /**
-     *  max queue size
-     */
-    private int maxSize = 0;
-
-    /**
-     *  avg size sample interval
-     */
-    private int sampleInterval = 100;
-
-    /**
-     * Generate Queue SingleRemoveSynchronizedAddLock and set add and wait
-     * Timeouts
-     */
-    public FastQueue() {
-        lock = new SingleRemoveSynchronizedAddLock();
-        lock.setAddWaitTimeout(addWaitTimeout);
-        lock.setRemoveWaitTimeout(removeWaitTimeout);
-    }
-
-    /**
-     * get current add wait timeout
-     * 
-     * @return current wait timeout
-     */
-    public long getAddWaitTimeout() {
-        addWaitTimeout = lock.getAddWaitTimeout();
-        return addWaitTimeout;
-    }
-
-    /**
-     * Set add wait timeout (default 10000 msec)
-     * 
-     * @param timeout
-     */
-    public void setAddWaitTimeout(long timeout) {
-        addWaitTimeout = timeout;
-        lock.setAddWaitTimeout(addWaitTimeout);
-    }
-
-    /**
-     * get current remove wait timeout
-     * 
-     * @return The timeout
-     */
-    public long getRemoveWaitTimeout() {
-        removeWaitTimeout = lock.getRemoveWaitTimeout();
-        return removeWaitTimeout;
-    }
-
-    /**
-     * set remove wait timeout ( default 30000 msec)
-     * 
-     * @param timeout
-     */
-    public void setRemoveWaitTimeout(long timeout) {
-        removeWaitTimeout = timeout;
-        lock.setRemoveWaitTimeout(removeWaitTimeout);
-    }
-
-    /**
-     * get Max Queue length
-     * 
-     * @see org.apache.catalina.tribes.util.IQueue#getMaxQueueLength()
-     */
-    public int getMaxQueueLength() {
-        return maxQueueLength;
-    }
-
-    public void setMaxQueueLength(int length) {
-        maxQueueLength = length;
-    }
-
-    public boolean isEnabled() {
-        return enabled;
-    }
-
-    public void setEnabled(boolean enable) {
-        enabled = enable;
-        if (!enabled) {
-            lock.abortRemove();
-            last = first = null;
-        }
-    }
-
-    /**
-     * @return Returns the checkLock.
-     */
-    public boolean isCheckLock() {
-        return checkLock;
-    }
-
-    /**
-     * @param checkLock The checkLock to set.
-     */
-    public void setCheckLock(boolean checkLock) {
-        this.checkLock = checkLock;
-    }
-
-    
-    /**
-     * @return The max size
-     */
-    public int getMaxSize() {
-        return maxSize;
-    }
-
-    /**
-     * @param size
-     */
-    public void setMaxSize(int size) {
-        maxSize = size;
-    }
-
-    
-    /**
-     * unlock queue for next add 
-     */
-    public void unlockAdd() {
-        lock.unlockAdd(size > 0 ? true : false);
-    }
-
-    /**
-     * unlock queue for next remove 
-     */
-    public void unlockRemove() {
-        lock.unlockRemove();
-    }
-
-    /**
-     * start queuing
-     */
-    public void start() {
-        setEnabled(true);
-    }
-
-    /**
-     * start queuing
-     */
-    public void stop() {
-        setEnabled(false);
-    }
-
-    public int getSize() {
-        return size;
-    }
-
-    public SingleRemoveSynchronizedAddLock getLock() {
-        return lock;
-    }
-
-    /**
-     * Add new data to the queue
-     * @see org.apache.catalina.tribes.util.IQueue#add(java.lang.String, java.lang.Object)
-     * FIXME extract some method
-     */
-    public boolean add(ChannelMessage msg, Member[] destination, InterceptorPayload payload) {
-        boolean ok = true;
-        long time = 0;
-
-        if (!enabled) {
-            if (log.isInfoEnabled())
-                log.info("FastQueue.add: queue disabled, add aborted");
-            return false;
-        }
-
-        if (timeWait) {
-            time = System.currentTimeMillis();
-        }
-        lock.lockAdd();
-        try {
-            if (log.isTraceEnabled()) {
-                log.trace("FastQueue.add: starting with size " + size);
-            }
-            if (checkLock) {
-                if (inAdd)
-                    log.warn("FastQueue.add: Detected other add");
-                inAdd = true;
-                if (inMutex)
-                    log.warn("FastQueue.add: Detected other mutex in add");
-                inMutex = true;
-            }
-
-            if ((maxQueueLength > 0) && (size >= maxQueueLength)) {
-                ok = false;
-                if (log.isTraceEnabled()) {
-                    log.trace("FastQueue.add: Could not add, since queue is full (" + size + ">=" + maxQueueLength + ")");
-                }
-            } else {
-                LinkObject element = new LinkObject(msg,destination, payload);
-                if (size == 0) {
-                    first = last = element;
-                    size = 1;
-                } else {
-                    if (last == null) {
-                        ok = false;
-                        log.error("FastQueue.add: Could not add, since last is null although size is "+ size + " (>0)");
-                    } else {
-                        last.append(element);
-                        last = element;
-                        size++;
-                    }
-                }
-            }
-
-            if (first == null) {
-                log.error("FastQueue.add: first is null, size is " + size + " at end of add");
-            }
-            if (last == null) {
-                log.error("FastQueue.add: last is null, size is " + size+ " at end of add");
-            }
-
-            if (checkLock) {
-                if (!inMutex) log.warn("FastQueue.add: Cancelled by other mutex in add");
-                inMutex = false;
-                if (!inAdd) log.warn("FastQueue.add: Cancelled by other add");
-                inAdd = false;
-            }
-            if (log.isTraceEnabled()) log.trace("FastQueue.add: add ending with size " + size);
-
-        } finally {
-            lock.unlockAdd(true);
-        }
-        return ok;
-    }
-
-    /**
-     * remove the complete queued object list
-     * @see org.apache.catalina.tribes.util.IQueue#remove()
-     * FIXME extract some method
-     */
-    public LinkObject remove() {
-        LinkObject element;
-        boolean gotLock;
-        long time = 0;
-
-        if (!enabled) {
-            if (log.isInfoEnabled())
-                log.info("FastQueue.remove: queue disabled, remove aborted");
-            return null;
-        }
-
-        if (timeWait) {
-            time = System.currentTimeMillis();
-        }
-        gotLock = lock.lockRemove();
-        try {
-
-            if (!gotLock) {
-                if (enabled) {
-                    if (log.isInfoEnabled())
-                        log.info("FastQueue.remove: Remove aborted although queue enabled");
-                } else {
-                    if (log.isInfoEnabled())
-                        log.info("FastQueue.remove: queue disabled, remove aborted");
-                }
-                return null;
-            }
-
-            if (log.isTraceEnabled()) {
-                log.trace("FastQueue.remove: remove starting with size " + size);
-            }
-            if (checkLock) {
-                if (inRemove)
-                    log.warn("FastQueue.remove: Detected other remove");
-                inRemove = true;
-                if (inMutex)
-                    log.warn("FastQueue.remove: Detected other mutex in remove");
-                inMutex = true;
-            }
-
-            element = first;
-
-            first = last = null;
-            size = 0;
-
-            if (checkLock) {
-                if (!inMutex)
-                    log.warn("FastQueue.remove: Cancelled by other mutex in remove");
-                inMutex = false;
-                if (!inRemove)
-                    log.warn("FastQueue.remove: Cancelled by other remove");
-                inRemove = false;
-            }
-            if (log.isTraceEnabled()) {
-                log.trace("FastQueue.remove: remove ending with size " + size);
-            }
-
-            if (timeWait) {
-                time = System.currentTimeMillis();
-            }
-        } finally {
-            lock.unlockRemove();
-        }
-        return element;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.transport.bio.util;
+
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.ErrorHandler;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.group.InterceptorPayload;
+
+
+
+/**
+ * A fast queue that remover thread lock the adder thread. <br/>Limit the queue
+ * length when you have strange producer thread problemes.
+ * 
+ * FIXME add i18n support to log messages
+ * @author Rainer Jung
+ * @author Peter Rossbach
+ * @version $Revision: 345567 $ $Date: 2005-11-18 15:07:23 -0600 (Fri, 18 Nov 2005) $
+ */
+public class FastQueue {
+
+    private static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(FastQueue.class);
+
+    /**
+     * This is the actual queue
+     */
+    private SingleRemoveSynchronizedAddLock lock = null;
+
+    /**
+     * First Object at queue (consumer message)
+     */
+    private LinkObject first = null;
+
+    /**
+     * Last object in queue (producer Object)
+     */
+    private LinkObject last = null;
+
+    /**
+     * Current Queue elements size
+     */
+    private int size = 0;
+
+    /**
+     * check lock to detect strange threadings things
+     */
+    private boolean checkLock = false;
+
+    /**
+     * protocol the thread wait times
+     */
+    private boolean timeWait = false;
+
+    private boolean inAdd = false;
+
+    private boolean inRemove = false;
+
+    private boolean inMutex = false;
+
+    /**
+     * limit the queue legnth ( default is unlimited)
+     */
+    private int maxQueueLength = 0;
+
+    /**
+     * addWaitTimeout for producer
+     */
+    private long addWaitTimeout = 10000L;
+
+    
+    /**
+     * removeWaitTimeout for consumer
+     */
+    private long removeWaitTimeout = 30000L;
+
+    /**
+     * enabled the queue
+     */
+    private boolean enabled = true;
+
+    /**
+     *  max queue size
+     */
+    private int maxSize = 0;
+
+    /**
+     *  avg size sample interval
+     */
+    private int sampleInterval = 100;
+
+    /**
+     * Generate Queue SingleRemoveSynchronizedAddLock and set add and wait
+     * Timeouts
+     */
+    public FastQueue() {
+        lock = new SingleRemoveSynchronizedAddLock();
+        lock.setAddWaitTimeout(addWaitTimeout);
+        lock.setRemoveWaitTimeout(removeWaitTimeout);
+    }
+
+    /**
+     * get current add wait timeout
+     * 
+     * @return current wait timeout
+     */
+    public long getAddWaitTimeout() {
+        addWaitTimeout = lock.getAddWaitTimeout();
+        return addWaitTimeout;
+    }
+
+    /**
+     * Set add wait timeout (default 10000 msec)
+     * 
+     * @param timeout
+     */
+    public void setAddWaitTimeout(long timeout) {
+        addWaitTimeout = timeout;
+        lock.setAddWaitTimeout(addWaitTimeout);
+    }
+
+    /**
+     * get current remove wait timeout
+     * 
+     * @return The timeout
+     */
+    public long getRemoveWaitTimeout() {
+        removeWaitTimeout = lock.getRemoveWaitTimeout();
+        return removeWaitTimeout;
+    }
+
+    /**
+     * set remove wait timeout ( default 30000 msec)
+     * 
+     * @param timeout
+     */
+    public void setRemoveWaitTimeout(long timeout) {
+        removeWaitTimeout = timeout;
+        lock.setRemoveWaitTimeout(removeWaitTimeout);
+    }
+
+    /**
+     * get Max Queue length
+     * 
+     * @see org.apache.catalina.tribes.util.IQueue#getMaxQueueLength()
+     */
+    public int getMaxQueueLength() {
+        return maxQueueLength;
+    }
+
+    public void setMaxQueueLength(int length) {
+        maxQueueLength = length;
+    }
+
+    public boolean isEnabled() {
+        return enabled;
+    }
+
+    public void setEnabled(boolean enable) {
+        enabled = enable;
+        if (!enabled) {
+            lock.abortRemove();
+            last = first = null;
+        }
+    }
+
+    /**
+     * @return Returns the checkLock.
+     */
+    public boolean isCheckLock() {
+        return checkLock;
+    }
+
+    /**
+     * @param checkLock The checkLock to set.
+     */
+    public void setCheckLock(boolean checkLock) {
+        this.checkLock = checkLock;
+    }
+
+    
+    /**
+     * @return The max size
+     */
+    public int getMaxSize() {
+        return maxSize;
+    }
+
+    /**
+     * @param size
+     */
+    public void setMaxSize(int size) {
+        maxSize = size;
+    }
+
+    
+    /**
+     * unlock queue for next add 
+     */
+    public void unlockAdd() {
+        lock.unlockAdd(size > 0 ? true : false);
+    }
+
+    /**
+     * unlock queue for next remove 
+     */
+    public void unlockRemove() {
+        lock.unlockRemove();
+    }
+
+    /**
+     * start queuing
+     */
+    public void start() {
+        setEnabled(true);
+    }
+
+    /**
+     * start queuing
+     */
+    public void stop() {
+        setEnabled(false);
+    }
+
+    public int getSize() {
+        return size;
+    }
+
+    public SingleRemoveSynchronizedAddLock getLock() {
+        return lock;
+    }
+
+    /**
+     * Add new data to the queue
+     * @see org.apache.catalina.tribes.util.IQueue#add(java.lang.String, java.lang.Object)
+     * FIXME extract some method
+     */
+    public boolean add(ChannelMessage msg, Member[] destination, InterceptorPayload payload) {
+        boolean ok = true;
+        long time = 0;
+
+        if (!enabled) {
+            if (log.isInfoEnabled())
+                log.info("FastQueue.add: queue disabled, add aborted");
+            return false;
+        }
+
+        if (timeWait) {
+            time = System.currentTimeMillis();
+        }
+        lock.lockAdd();
+        try {
+            if (log.isTraceEnabled()) {
+                log.trace("FastQueue.add: starting with size " + size);
+            }
+            if (checkLock) {
+                if (inAdd)
+                    log.warn("FastQueue.add: Detected other add");
+                inAdd = true;
+                if (inMutex)
+                    log.warn("FastQueue.add: Detected other mutex in add");
+                inMutex = true;
+            }
+
+            if ((maxQueueLength > 0) && (size >= maxQueueLength)) {
+                ok = false;
+                if (log.isTraceEnabled()) {
+                    log.trace("FastQueue.add: Could not add, since queue is full (" + size + ">=" + maxQueueLength + ")");
+                }
+            } else {
+                LinkObject element = new LinkObject(msg,destination, payload);
+                if (size == 0) {
+                    first = last = element;
+                    size = 1;
+                } else {
+                    if (last == null) {
+                        ok = false;
+                        log.error("FastQueue.add: Could not add, since last is null although size is "+ size + " (>0)");
+                    } else {
+                        last.append(element);
+                        last = element;
+                        size++;
+                    }
+                }
+            }
+
+            if (first == null) {
+                log.error("FastQueue.add: first is null, size is " + size + " at end of add");
+            }
+            if (last == null) {
+                log.error("FastQueue.add: last is null, size is " + size+ " at end of add");
+            }
+
+            if (checkLock) {
+                if (!inMutex) log.warn("FastQueue.add: Cancelled by other mutex in add");
+                inMutex = false;
+                if (!inAdd) log.warn("FastQueue.add: Cancelled by other add");
+                inAdd = false;
+            }
+            if (log.isTraceEnabled()) log.trace("FastQueue.add: add ending with size " + size);
+
+        } finally {
+            lock.unlockAdd(true);
+        }
+        return ok;
+    }
+
+    /**
+     * remove the complete queued object list
+     * @see org.apache.catalina.tribes.util.IQueue#remove()
+     * FIXME extract some method
+     */
+    public LinkObject remove() {
+        LinkObject element;
+        boolean gotLock;
+        long time = 0;
+
+        if (!enabled) {
+            if (log.isInfoEnabled())
+                log.info("FastQueue.remove: queue disabled, remove aborted");
+            return null;
+        }
+
+        if (timeWait) {
+            time = System.currentTimeMillis();
+        }
+        gotLock = lock.lockRemove();
+        try {
+
+            if (!gotLock) {
+                if (enabled) {
+                    if (log.isInfoEnabled())
+                        log.info("FastQueue.remove: Remove aborted although queue enabled");
+                } else {
+                    if (log.isInfoEnabled())
+                        log.info("FastQueue.remove: queue disabled, remove aborted");
+                }
+                return null;
+            }
+
+            if (log.isTraceEnabled()) {
+                log.trace("FastQueue.remove: remove starting with size " + size);
+            }
+            if (checkLock) {
+                if (inRemove)
+                    log.warn("FastQueue.remove: Detected other remove");
+                inRemove = true;
+                if (inMutex)
+                    log.warn("FastQueue.remove: Detected other mutex in remove");
+                inMutex = true;
+            }
+
+            element = first;
+
+            first = last = null;
+            size = 0;
+
+            if (checkLock) {
+                if (!inMutex)
+                    log.warn("FastQueue.remove: Cancelled by other mutex in remove");
+                inMutex = false;
+                if (!inRemove)
+                    log.warn("FastQueue.remove: Cancelled by other remove");
+                inRemove = false;
+            }
+            if (log.isTraceEnabled()) {
+                log.trace("FastQueue.remove: remove ending with size " + size);
+            }
+
+            if (timeWait) {
+                time = System.currentTimeMillis();
+            }
+        } finally {
+            lock.unlockRemove();
+        }
+        return element;
+    }
+
+}

==================================================
SingleRemoveSynchronizedAddLock.java
index 9000f9c66c..f6497675be 100644
--- a/java/org/apache/catalina/tribes/transport/bio/util/LinkObject.java
+++ b/java/org/apache/catalina/tribes/transport/bio/util/LinkObject.java
@@ -1,107 +1,108 @@
-/*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.transport.bio.util;
-
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.ErrorHandler;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.group.InterceptorPayload;
-
-/**
- * The class <b>LinkObject</b> implements an element
- * for a linked list, consisting of a general
- * data object and a pointer to the next element.
- *
- * @author Rainer Jung
- * @author Peter Rossbach
- * @author Filip Hanik
- * @version $Revision: 304032 $ $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
-
- */
-
-public class LinkObject {
-
-    private ChannelMessage msg;
-    private LinkObject next;
-    private byte[] key ;
-    private Member[] destination;
-    private InterceptorPayload payload;
-
-    /**
-     * Construct a new element from the data object.
-     * Sets the pointer to null.
-     *
-     * @param key The key
-     * @param payload The data object.
-     */
-    public LinkObject(ChannelMessage msg, Member[] destination, InterceptorPayload payload) {
-        this.msg = msg;
-        this.next = null;
-        this.key = msg.getUniqueId();
-        this.payload = payload;
-        this.destination = destination;
-    }
-
-    /**
-     * Set the next element.
-     * @param next The next element.
-     */
-    public void append(LinkObject next) {
-        this.next = next;
-    }
-
-    /**
-     * Get the next element.
-     * @return The next element.
-     */
-    public LinkObject next() {
-        return next;
-    }
-    
-    public void setNext(LinkObject next) {
-        this.next = next;
-    }
-
-    /**
-     * Get the data object from the element.
-     * @return The data object from the element.
-     */
-    public ChannelMessage data() {
-        return msg;
-    }
-
-    /**
-     * Get the unique message id
-     * @return the unique message id
-     */
-    public byte[] getKey() {
-        return key;
-    }
-
-    public ErrorHandler getHandler() {
-        return payload!=null?payload.getErrorHandler():null;
-    }
-
-    public InterceptorPayload getPayload() {
-        return payload;
-    }
-
-    public Member[] getDestination() {
-        return destination;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.transport.bio.util;
+
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.ErrorHandler;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.group.InterceptorPayload;
+
+/**
+ * The class <b>LinkObject</b> implements an element
+ * for a linked list, consisting of a general
+ * data object and a pointer to the next element.
+ *
+ * @author Rainer Jung
+ * @author Peter Rossbach
+ * @author Filip Hanik
+ * @version $Revision: 304032 $ $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
+
+ */
+
+public class LinkObject {
+
+    private ChannelMessage msg;
+    private LinkObject next;
+    private byte[] key ;
+    private Member[] destination;
+    private InterceptorPayload payload;
+
+    /**
+     * Construct a new element from the data object.
+     * Sets the pointer to null.
+     *
+     * @param key The key
+     * @param payload The data object.
+     */
+    public LinkObject(ChannelMessage msg, Member[] destination, InterceptorPayload payload) {
+        this.msg = msg;
+        this.next = null;
+        this.key = msg.getUniqueId();
+        this.payload = payload;
+        this.destination = destination;
+    }
+
+    /**
+     * Set the next element.
+     * @param next The next element.
+     */
+    public void append(LinkObject next) {
+        this.next = next;
+    }
+
+    /**
+     * Get the next element.
+     * @return The next element.
+     */
+    public LinkObject next() {
+        return next;
+    }
+    
+    public void setNext(LinkObject next) {
+        this.next = next;
+    }
+
+    /**
+     * Get the data object from the element.
+     * @return The data object from the element.
+     */
+    public ChannelMessage data() {
+        return msg;
+    }
+
+    /**
+     * Get the unique message id
+     * @return the unique message id
+     */
+    public byte[] getKey() {
+        return key;
+    }
+
+    public ErrorHandler getHandler() {
+        return payload!=null?payload.getErrorHandler():null;
+    }
+
+    public InterceptorPayload getPayload() {
+        return payload;
+    }
+
+    public Member[] getDestination() {
+        return destination;
+    }
+
+}

==================================================
NioReceiver.java
index fe030db691..dd008c39f7 100644
--- a/java/org/apache/catalina/tribes/transport/bio/util/SingleRemoveSynchronizedAddLock.java
+++ b/java/org/apache/catalina/tribes/transport/bio/util/SingleRemoveSynchronizedAddLock.java
@@ -1,253 +1,254 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.transport.bio.util;
-
-/**
- * The class <b>SingleRemoveSynchronizedAddLock</b> implement locking for accessing the queue
- * by a single remove thread and multiple add threads.
- *
- * A thread is only allowed to be either the remove or
- * an add thread.
- *
- * The lock can either be owned by the remove thread
- * or by a single add thread.
- *
- * If the remove thread tries to get the lock,
- * but the queue is empty, it will block (poll)
- * until an add threads adds an entry to the queue and
- * releases the lock.
- * 
- * If the remove thread and add threads compete for
- * the lock and an add thread releases the lock, then
- * the remove thread will get the lock first.
- *
- * The remove thread removes all entries in the queue
- * at once and proceeses them without further
- * polling the queue.
- *
- * The lock is not reentrant, in the sense, that all
- * threads must release an owned lock before competing
- * for the lock again!
- *
- * @author Rainer Jung
- * @author Peter Rossbach
- * @version 1.1
- */
- 
-public class SingleRemoveSynchronizedAddLock {
-    
-    public SingleRemoveSynchronizedAddLock() {
-    }
-    
-    public SingleRemoveSynchronizedAddLock(boolean dataAvailable) {
-        this.dataAvailable=dataAvailable;
-    }
-    
-    /**
-     * Time in milliseconds after which threads
-     * waiting for an add lock are woken up.
-     * This is used as a safety measure in case
-     * thread notification via the unlock methods
-     * has a bug.
-     */
-    private long addWaitTimeout = 10000L;
-
-    /**
-     * Time in milliseconds after which threads
-     * waiting for a remove lock are woken up.
-     * This is used as a safety measure in case
-     * thread notification via the unlock methods
-     * has a bug.
-     */
-    private long removeWaitTimeout = 30000L;
-
-    /**
-     * The current remove thread.
-     * It is set to the remove thread polling for entries.
-     * It is reset to null when the remove thread
-     * releases the lock and proceeds processing
-     * the removed entries.
-     */
-    private Thread remover = null;
-
-    /**
-     * A flag indicating, if an add thread owns the lock.
-     */
-    private boolean addLocked = false;
-
-    /**
-     * A flag indicating, if the remove thread owns the lock.
-     */
-    private boolean removeLocked = false;
-
-    /**
-     * A flag indicating, if the remove thread is allowed
-     * to wait for the lock. The flag is set to false, when aborting.
-     */
-    private boolean removeEnabled = true;
-
-    /**
-     * A flag indicating, if the remover needs polling.
-     * It indicates, if the locked object has data available
-     * to be removed.
-     */
-    private boolean dataAvailable = false;
-
-    /**
-     * @return Value of addWaitTimeout
-     */
-    public synchronized long getAddWaitTimeout() {
-        return addWaitTimeout;
-    }
-
-    /**
-     * Set value of addWaitTimeout
-     */
-    public synchronized void setAddWaitTimeout(long timeout) {
-        addWaitTimeout = timeout;
-    }
-
-    /**
-     * @return Value of removeWaitTimeout
-     */
-    public synchronized long getRemoveWaitTimeout() {
-        return removeWaitTimeout;
-    }
-
-    /**
-     * Set value of removeWaitTimeout
-     */
-    public synchronized void setRemoveWaitTimeout(long timeout) {
-        removeWaitTimeout = timeout;
-    }
-
-    /**
-     * Check if the locked object has data available
-     * i.e. the remover can stop poling and get the lock.
-     * @return True iff the lock Object has data available.
-     */
-    public synchronized boolean isDataAvailable() {
-        return dataAvailable;
-    }
-
-    /**
-     * Check if an add thread owns the lock.
-     * @return True iff an add thread owns the lock.
-     */
-    public synchronized boolean isAddLocked() {
-        return addLocked;
-    }
-
-    /**
-     * Check if the remove thread owns the lock.
-     * @return True iff the remove thread owns the lock.
-     */
-    public synchronized boolean isRemoveLocked() {
-        return removeLocked;
-    }
-
-    /**
-     * Check if the remove thread is polling.
-     * @return True iff the remove thread is polling.
-     */
-    public synchronized boolean isRemovePolling() {
-        if ( remover != null ) {
-            return true;
-        }
-        return false;
-    }
-
-    /**
-     * Acquires the lock by an add thread and sets the add flag.
-     * If any add thread or the remove thread already acquired the lock
-     * this add thread will block until the lock is released.
-     */
-    public synchronized void lockAdd() {
-        if ( addLocked || removeLocked ) {
-            do {
-                try {
-                    wait(addWaitTimeout);
-                } catch ( InterruptedException e ) {
-                    Thread.currentThread().interrupted();
-                }
-            } while ( addLocked || removeLocked );
-        }
-        addLocked=true;
-    }
-
-    /**
-     * Acquires the lock by the remove thread and sets the remove flag.
-     * If any add thread already acquired the lock or the queue is
-     * empty, the remove thread will block until the lock is released
-     * and the queue is not empty.
-     */
-    public synchronized boolean lockRemove() {
-        removeLocked=false;
-        removeEnabled=true;
-        if ( ( addLocked || ! dataAvailable ) && removeEnabled ) {
-            remover=Thread.currentThread();
-            do {
-                try {
-                    wait(removeWaitTimeout);
-                } catch ( InterruptedException e ) {
-                    Thread.currentThread().interrupted();
-                }
-            } while ( ( addLocked || ! dataAvailable ) && removeEnabled );
-            remover=null;
-        }
-        if ( removeEnabled ) {
-            removeLocked=true;
-        } 
-        return removeLocked;
-    }
-
-    /**
-     * Releases the lock by an add thread and reset the remove flag.
-     * If the reader thread is polling, notify it.
-     */
-    public synchronized void unlockAdd(boolean dataAvailable) {
-        addLocked=false;
-        this.dataAvailable=dataAvailable;
-        if ( ( remover != null ) && ( dataAvailable || ! removeEnabled ) ) {
-            remover.interrupt();
-        } else {
-            notifyAll();
-        }
-    }
-
-    /**
-     * Releases the lock by the remove thread and reset the add flag.
-     * Notify all waiting add threads,
-     * that the lock has been released by the remove thread.
-     */
-    public synchronized void unlockRemove() {
-        removeLocked=false;
-        dataAvailable=false;
-        notifyAll();
-    }
-
-    /**
-     * Abort any polling remover thread
-     */
-    public synchronized void abortRemove() {
-        removeEnabled=false;
-        if ( remover != null ) {
-            remover.interrupt();
-        }
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.transport.bio.util;
+
+/**
+ * The class <b>SingleRemoveSynchronizedAddLock</b> implement locking for accessing the queue
+ * by a single remove thread and multiple add threads.
+ *
+ * A thread is only allowed to be either the remove or
+ * an add thread.
+ *
+ * The lock can either be owned by the remove thread
+ * or by a single add thread.
+ *
+ * If the remove thread tries to get the lock,
+ * but the queue is empty, it will block (poll)
+ * until an add threads adds an entry to the queue and
+ * releases the lock.
+ * 
+ * If the remove thread and add threads compete for
+ * the lock and an add thread releases the lock, then
+ * the remove thread will get the lock first.
+ *
+ * The remove thread removes all entries in the queue
+ * at once and proceeses them without further
+ * polling the queue.
+ *
+ * The lock is not reentrant, in the sense, that all
+ * threads must release an owned lock before competing
+ * for the lock again!
+ *
+ * @author Rainer Jung
+ * @author Peter Rossbach
+ * @version 1.1
+ */
+ 
+public class SingleRemoveSynchronizedAddLock {
+    
+    public SingleRemoveSynchronizedAddLock() {
+    }
+    
+    public SingleRemoveSynchronizedAddLock(boolean dataAvailable) {
+        this.dataAvailable=dataAvailable;
+    }
+    
+    /**
+     * Time in milliseconds after which threads
+     * waiting for an add lock are woken up.
+     * This is used as a safety measure in case
+     * thread notification via the unlock methods
+     * has a bug.
+     */
+    private long addWaitTimeout = 10000L;
+
+    /**
+     * Time in milliseconds after which threads
+     * waiting for a remove lock are woken up.
+     * This is used as a safety measure in case
+     * thread notification via the unlock methods
+     * has a bug.
+     */
+    private long removeWaitTimeout = 30000L;
+
+    /**
+     * The current remove thread.
+     * It is set to the remove thread polling for entries.
+     * It is reset to null when the remove thread
+     * releases the lock and proceeds processing
+     * the removed entries.
+     */
+    private Thread remover = null;
+
+    /**
+     * A flag indicating, if an add thread owns the lock.
+     */
+    private boolean addLocked = false;
+
+    /**
+     * A flag indicating, if the remove thread owns the lock.
+     */
+    private boolean removeLocked = false;
+
+    /**
+     * A flag indicating, if the remove thread is allowed
+     * to wait for the lock. The flag is set to false, when aborting.
+     */
+    private boolean removeEnabled = true;
+
+    /**
+     * A flag indicating, if the remover needs polling.
+     * It indicates, if the locked object has data available
+     * to be removed.
+     */
+    private boolean dataAvailable = false;
+
+    /**
+     * @return Value of addWaitTimeout
+     */
+    public synchronized long getAddWaitTimeout() {
+        return addWaitTimeout;
+    }
+
+    /**
+     * Set value of addWaitTimeout
+     */
+    public synchronized void setAddWaitTimeout(long timeout) {
+        addWaitTimeout = timeout;
+    }
+
+    /**
+     * @return Value of removeWaitTimeout
+     */
+    public synchronized long getRemoveWaitTimeout() {
+        return removeWaitTimeout;
+    }
+
+    /**
+     * Set value of removeWaitTimeout
+     */
+    public synchronized void setRemoveWaitTimeout(long timeout) {
+        removeWaitTimeout = timeout;
+    }
+
+    /**
+     * Check if the locked object has data available
+     * i.e. the remover can stop poling and get the lock.
+     * @return True iff the lock Object has data available.
+     */
+    public synchronized boolean isDataAvailable() {
+        return dataAvailable;
+    }
+
+    /**
+     * Check if an add thread owns the lock.
+     * @return True iff an add thread owns the lock.
+     */
+    public synchronized boolean isAddLocked() {
+        return addLocked;
+    }
+
+    /**
+     * Check if the remove thread owns the lock.
+     * @return True iff the remove thread owns the lock.
+     */
+    public synchronized boolean isRemoveLocked() {
+        return removeLocked;
+    }
+
+    /**
+     * Check if the remove thread is polling.
+     * @return True iff the remove thread is polling.
+     */
+    public synchronized boolean isRemovePolling() {
+        if ( remover != null ) {
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Acquires the lock by an add thread and sets the add flag.
+     * If any add thread or the remove thread already acquired the lock
+     * this add thread will block until the lock is released.
+     */
+    public synchronized void lockAdd() {
+        if ( addLocked || removeLocked ) {
+            do {
+                try {
+                    wait(addWaitTimeout);
+                } catch ( InterruptedException e ) {
+                    Thread.currentThread().interrupted();
+                }
+            } while ( addLocked || removeLocked );
+        }
+        addLocked=true;
+    }
+
+    /**
+     * Acquires the lock by the remove thread and sets the remove flag.
+     * If any add thread already acquired the lock or the queue is
+     * empty, the remove thread will block until the lock is released
+     * and the queue is not empty.
+     */
+    public synchronized boolean lockRemove() {
+        removeLocked=false;
+        removeEnabled=true;
+        if ( ( addLocked || ! dataAvailable ) && removeEnabled ) {
+            remover=Thread.currentThread();
+            do {
+                try {
+                    wait(removeWaitTimeout);
+                } catch ( InterruptedException e ) {
+                    Thread.currentThread().interrupted();
+                }
+            } while ( ( addLocked || ! dataAvailable ) && removeEnabled );
+            remover=null;
+        }
+        if ( removeEnabled ) {
+            removeLocked=true;
+        } 
+        return removeLocked;
+    }
+
+    /**
+     * Releases the lock by an add thread and reset the remove flag.
+     * If the reader thread is polling, notify it.
+     */
+    public synchronized void unlockAdd(boolean dataAvailable) {
+        addLocked=false;
+        this.dataAvailable=dataAvailable;
+        if ( ( remover != null ) && ( dataAvailable || ! removeEnabled ) ) {
+            remover.interrupt();
+        } else {
+            notifyAll();
+        }
+    }
+
+    /**
+     * Releases the lock by the remove thread and reset the add flag.
+     * Notify all waiting add threads,
+     * that the lock has been released by the remove thread.
+     */
+    public synchronized void unlockRemove() {
+        removeLocked=false;
+        dataAvailable=false;
+        notifyAll();
+    }
+
+    /**
+     * Abort any polling remover thread
+     */
+    public synchronized void abortRemove() {
+        removeEnabled=false;
+        if ( remover != null ) {
+            remover.interrupt();
+        }
+    }
+
+}

==================================================
NioReplicationThread.java
index 6b391665ce..5d916ff0ed 100644
--- a/java/org/apache/catalina/tribes/transport/nio/NioReceiver.java
+++ b/java/org/apache/catalina/tribes/transport/nio/NioReceiver.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
NioSender.java
index 49bcc35740..44308e9e5b 100644
--- a/java/org/apache/catalina/tribes/transport/nio/NioReplicationThread.java
+++ b/java/org/apache/catalina/tribes/transport/nio/NioReplicationThread.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ParallelNioSender.java
index c133fe6e66..8fdbd94b94 100644
--- a/java/org/apache/catalina/tribes/transport/nio/NioSender.java
+++ b/java/org/apache/catalina/tribes/transport/nio/NioSender.java
@@ -1,330 +1,331 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.transport.nio;
-
-import java.io.IOException;
-import java.net.InetSocketAddress;
-import java.net.UnknownHostException;
-import java.nio.ByteBuffer;
-import java.nio.channels.SelectionKey;
-import java.nio.channels.Selector;
-import java.nio.channels.SocketChannel;
-import java.util.Arrays;
-
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.io.XByteBuffer;
-import org.apache.catalina.tribes.transport.AbstractSender;
-import org.apache.catalina.tribes.transport.DataSender;
-import org.apache.catalina.tribes.RemoteProcessException;
-
-/**
- * This class is NOT thread safe and should never be used with more than one thread at a time
- * 
- * This is a state machine, handled by the process method
- * States are:
- * - NOT_CONNECTED -> connect() -> CONNECTED
- * - CONNECTED -> setMessage() -> READY TO WRITE
- * - READY_TO_WRITE -> write() -> READY TO WRITE | READY TO READ
- * - READY_TO_READ -> read() -> READY_TO_READ | TRANSFER_COMPLETE
- * - TRANSFER_COMPLETE -> CONNECTED
- * 
- * @author Filip Hanik
- * @version 1.0
- */
-public class NioSender extends AbstractSender implements DataSender{
-
-    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(NioSender.class);
-
-    
-    
-    protected Selector selector;    
-    protected SocketChannel socketChannel;
-
-    /*
-     * STATE VARIABLES *
-     */
-    protected ByteBuffer readbuf = null;
-    protected ByteBuffer writebuf = null;
-    protected byte[] current = null;
-    protected XByteBuffer ackbuf = new XByteBuffer(128,true);
-    protected int remaining = 0;
-    protected boolean complete;
-    
-    protected boolean connecting = false;
-    
-    public NioSender() {
-        super();
-        
-    }
-    
-    /**
-     * State machine to send data
-     * @param key SelectionKey
-     * @return boolean
-     * @throws IOException
-     */
-    public boolean process(SelectionKey key, boolean waitForAck) throws IOException {
-        int ops = key.readyOps();
-        key.interestOps(key.interestOps() & ~ops);
-        //in case disconnect has been called
-        if ((!isConnected()) && (!connecting)) throw new IOException("Sender has been disconnected, can't selection key.");
-        if ( !key.isValid() ) throw new IOException("Key is not valid, it must have been cancelled.");
-        if ( key.isConnectable() ) {
-            if ( socketChannel.finishConnect() ) {
-                //we connected, register ourselves for writing
-                setConnected(true);
-                connecting = false;
-                setRequestCount(0);
-                setConnectTime(System.currentTimeMillis());
-                socketChannel.socket().setSendBufferSize(getTxBufSize());
-                socketChannel.socket().setReceiveBufferSize(getRxBufSize());
-                socketChannel.socket().setSoTimeout((int)getTimeout());
-                socketChannel.socket().setSoLinger(false,0);
-                socketChannel.socket().setTcpNoDelay(getTcpNoDelay());
-                socketChannel.socket().setKeepAlive(getSoKeepAlive());
-                socketChannel.socket().setReuseAddress(getSoReuseAddress());
-                socketChannel.socket().setOOBInline(getOoBInline());
-                socketChannel.socket().setSoLinger(getSoLingerOn(),getSoLingerTime());
-                socketChannel.socket().setTrafficClass(getSoTrafficClass());
-                if ( current != null ) key.interestOps(key.interestOps() | SelectionKey.OP_WRITE);
-                return false;
-            } else  { 
-                //wait for the connection to finish
-                key.interestOps(key.interestOps() | SelectionKey.OP_CONNECT);
-                return false;
-            }//end if
-        } else if ( key.isWritable() ) {
-            boolean writecomplete = write(key);
-            if ( writecomplete ) {
-                //we are completed, should we read an ack?
-                if ( waitForAck ) {
-                    //register to read the ack
-                    key.interestOps(key.interestOps() | SelectionKey.OP_READ);
-                } else {
-                    //if not, we are ready, setMessage will reregister us for another write interest
-                    //do a health check, we have no way of verify a disconnected
-                    //socket since we don't register for OP_READ on waitForAck=false
-                    read(key);//this causes overhead
-                    setRequestCount(getRequestCount()+1);
-                    return true;
-                }
-            } else {
-                //we are not complete, lets write some more
-                key.interestOps(key.interestOps()|SelectionKey.OP_WRITE);
-            }//end if
-        } else if ( key.isReadable() ) {
-            boolean readcomplete = read(key);
-            if ( readcomplete ) {
-                setRequestCount(getRequestCount()+1);
-                return true;
-            } else {
-                key.interestOps(key.interestOps() | SelectionKey.OP_READ);
-            }//end if
-        } else {
-            //unknown state, should never happen
-            log.warn("Data is in unknown state. readyOps="+ops);
-            throw new IOException("Data is in unknown state. readyOps="+ops);
-        }//end if
-        return false;
-    }
-    
-    
-
-    protected boolean read(SelectionKey key) throws IOException {
-        //if there is no message here, we are done
-        if ( current == null ) return true;
-        int read = socketChannel.read(readbuf);
-        //end of stream
-        if ( read == -1 ) throw new IOException("Unable to receive an ack message. EOF on socket channel has been reached.");
-        //no data read
-        else if ( read == 0 ) return false;
-        readbuf.flip();
-        ackbuf.append(readbuf,read);
-        readbuf.clear();
-        if (ackbuf.doesPackageExist() ) {
-            byte[] ackcmd = ackbuf.extractDataPackage(true).getBytes();
-            boolean ack = Arrays.equals(ackcmd,org.apache.catalina.tribes.transport.Constants.ACK_DATA);
-            boolean fack = Arrays.equals(ackcmd,org.apache.catalina.tribes.transport.Constants.FAIL_ACK_DATA);
-            if ( fack && getThrowOnFailedAck() ) throw new RemoteProcessException("Received a failed ack:org.apache.catalina.tribes.transport.Constants.FAIL_ACK_DATA");
-            return ack || fack;
-        } else {
-            return false;
-        }
-    }
-
-    
-    protected boolean write(SelectionKey key) throws IOException {
-        if ( (!isConnected()) || (this.socketChannel==null)) {
-            throw new IOException("NioSender is not connected, this should not occur.");
-        }
-        if ( current != null ) {
-            if ( remaining > 0 ) {
-                //weve written everything, or we are starting a new package
-                //protect against buffer overwrite
-                int byteswritten = socketChannel.write(writebuf);
-                remaining -= byteswritten;
-                //if the entire message was written from the buffer
-                //reset the position counter
-                if ( remaining < 0 ) {
-                    remaining = 0;
-                }
-            }
-            return (remaining==0);
-        }
-        //no message to send, we can consider that complete
-        return true;
-    }
-
-    /**
-     * connect - blocking in this operation
-     *
-     * @throws IOException
-     * @todo Implement this org.apache.catalina.tribes.transport.IDataSender method
-     */
-    public synchronized void connect() throws IOException {
-        if ( connecting ) return;
-        connecting = true;
-        if ( isConnected() ) throw new IOException("NioSender is already in connected state.");
-        if ( readbuf == null ) {
-            readbuf = getReadBuffer();
-        } else {
-            readbuf.clear();
-        }
-        if ( writebuf == null ) {
-            writebuf = getWriteBuffer();
-        } else {
-            writebuf.clear();
-        }
-        
-        InetSocketAddress addr = new InetSocketAddress(getAddress(),getPort());
-        if ( socketChannel != null ) throw new IOException("Socket channel has already been established. Connection might be in progress.");
-        socketChannel = SocketChannel.open();
-        socketChannel.configureBlocking(false);
-        socketChannel.connect(addr);
-        socketChannel.register(getSelector(),SelectionKey.OP_CONNECT,this);
-    }
-    
-
-    /**
-     * disconnect
-     *
-     * @todo Implement this org.apache.catalina.tribes.transport.IDataSender method
-     */
-    public void disconnect() {
-        try {
-            connecting = false;
-            setConnected(false);
-            if ( socketChannel != null ) {
-                try {
-                    try {socketChannel.socket().close();}catch ( Exception x){}
-                    //error free close, all the way
-                    //try {socket.shutdownOutput();}catch ( Exception x){}
-                    //try {socket.shutdownInput();}catch ( Exception x){}
-                    //try {socket.close();}catch ( Exception x){}
-                    try {socketChannel.close();}catch ( Exception x){}
-                }finally {
-                    socketChannel = null;
-                }
-            }
-        } catch ( Exception x ) {
-            log.error("Unable to disconnect NioSender. msg="+x.getMessage());
-            if ( log.isDebugEnabled() ) log.debug("Unable to disconnect NioSender. msg="+x.getMessage(),x);
-        } finally {
-        }
-
-    }
-    
-    public void reset() {
-        if ( isConnected() && readbuf == null) {
-            readbuf = getReadBuffer();
-        }
-        if ( readbuf != null ) readbuf.clear();
-        if ( writebuf != null ) writebuf.clear();
-        current = null;
-        ackbuf.clear();
-        remaining = 0;
-        complete = false;
-        setAttempt(0);
-        setRequestCount(0);
-        setConnectTime(-1);
-    }
-
-    private ByteBuffer getReadBuffer() { 
-        return getBuffer(getRxBufSize());
-    }
-    
-    private ByteBuffer getWriteBuffer() {
-        return getBuffer(getTxBufSize());
-    }
-
-    private ByteBuffer getBuffer(int size) {
-        return (getDirectBuffer()?ByteBuffer.allocateDirect(size):ByteBuffer.allocate(size));
-    }
-    
-    /**
-    * sendMessage
-    *
-    * @param data ChannelMessage
-    * @throws IOException
-    * @todo Implement this org.apache.catalina.tribes.transport.IDataSender method
-    */
-   public synchronized void setMessage(byte[] data) throws IOException {
-       setMessage(data,0,data.length);
-   }
-
-   public synchronized void setMessage(byte[] data,int offset, int length) throws IOException {
-       if ( data != null ) {
-           current = data;
-           remaining = length;
-           ackbuf.clear();
-           if ( writebuf != null ) writebuf.clear();
-           else writebuf = getBuffer(length);
-           if ( writebuf.capacity() < length ) writebuf = getBuffer(length);
-           writebuf.put(data,offset,length);
-           //writebuf.rewind();
-           //set the limit so that we don't write non wanted data
-           //writebuf.limit(length);
-           writebuf.flip();
-           if (isConnected()) {
-               socketChannel.register(getSelector(), SelectionKey.OP_WRITE, this);
-           }
-       } 
-   }
-   
-   public byte[] getMessage() {
-       return current;
-   }
-
-
-
-    public boolean isComplete() {
-        return complete;
-    }
-
-    public Selector getSelector() {
-        return selector;
-    }
-
-    public void setSelector(Selector selector) {
-        this.selector = selector;
-    }
-
-
-    public void setComplete(boolean complete) {
-        this.complete = complete;
-    }
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.transport.nio;
+
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.net.UnknownHostException;
+import java.nio.ByteBuffer;
+import java.nio.channels.SelectionKey;
+import java.nio.channels.Selector;
+import java.nio.channels.SocketChannel;
+import java.util.Arrays;
+
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.io.XByteBuffer;
+import org.apache.catalina.tribes.transport.AbstractSender;
+import org.apache.catalina.tribes.transport.DataSender;
+import org.apache.catalina.tribes.RemoteProcessException;
+
+/**
+ * This class is NOT thread safe and should never be used with more than one thread at a time
+ * 
+ * This is a state machine, handled by the process method
+ * States are:
+ * - NOT_CONNECTED -> connect() -> CONNECTED
+ * - CONNECTED -> setMessage() -> READY TO WRITE
+ * - READY_TO_WRITE -> write() -> READY TO WRITE | READY TO READ
+ * - READY_TO_READ -> read() -> READY_TO_READ | TRANSFER_COMPLETE
+ * - TRANSFER_COMPLETE -> CONNECTED
+ * 
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class NioSender extends AbstractSender implements DataSender{
+
+    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(NioSender.class);
+
+    
+    
+    protected Selector selector;    
+    protected SocketChannel socketChannel;
+
+    /*
+     * STATE VARIABLES *
+     */
+    protected ByteBuffer readbuf = null;
+    protected ByteBuffer writebuf = null;
+    protected byte[] current = null;
+    protected XByteBuffer ackbuf = new XByteBuffer(128,true);
+    protected int remaining = 0;
+    protected boolean complete;
+    
+    protected boolean connecting = false;
+    
+    public NioSender() {
+        super();
+        
+    }
+    
+    /**
+     * State machine to send data
+     * @param key SelectionKey
+     * @return boolean
+     * @throws IOException
+     */
+    public boolean process(SelectionKey key, boolean waitForAck) throws IOException {
+        int ops = key.readyOps();
+        key.interestOps(key.interestOps() & ~ops);
+        //in case disconnect has been called
+        if ((!isConnected()) && (!connecting)) throw new IOException("Sender has been disconnected, can't selection key.");
+        if ( !key.isValid() ) throw new IOException("Key is not valid, it must have been cancelled.");
+        if ( key.isConnectable() ) {
+            if ( socketChannel.finishConnect() ) {
+                //we connected, register ourselves for writing
+                setConnected(true);
+                connecting = false;
+                setRequestCount(0);
+                setConnectTime(System.currentTimeMillis());
+                socketChannel.socket().setSendBufferSize(getTxBufSize());
+                socketChannel.socket().setReceiveBufferSize(getRxBufSize());
+                socketChannel.socket().setSoTimeout((int)getTimeout());
+                socketChannel.socket().setSoLinger(false,0);
+                socketChannel.socket().setTcpNoDelay(getTcpNoDelay());
+                socketChannel.socket().setKeepAlive(getSoKeepAlive());
+                socketChannel.socket().setReuseAddress(getSoReuseAddress());
+                socketChannel.socket().setOOBInline(getOoBInline());
+                socketChannel.socket().setSoLinger(getSoLingerOn(),getSoLingerTime());
+                socketChannel.socket().setTrafficClass(getSoTrafficClass());
+                if ( current != null ) key.interestOps(key.interestOps() | SelectionKey.OP_WRITE);
+                return false;
+            } else  { 
+                //wait for the connection to finish
+                key.interestOps(key.interestOps() | SelectionKey.OP_CONNECT);
+                return false;
+            }//end if
+        } else if ( key.isWritable() ) {
+            boolean writecomplete = write(key);
+            if ( writecomplete ) {
+                //we are completed, should we read an ack?
+                if ( waitForAck ) {
+                    //register to read the ack
+                    key.interestOps(key.interestOps() | SelectionKey.OP_READ);
+                } else {
+                    //if not, we are ready, setMessage will reregister us for another write interest
+                    //do a health check, we have no way of verify a disconnected
+                    //socket since we don't register for OP_READ on waitForAck=false
+                    read(key);//this causes overhead
+                    setRequestCount(getRequestCount()+1);
+                    return true;
+                }
+            } else {
+                //we are not complete, lets write some more
+                key.interestOps(key.interestOps()|SelectionKey.OP_WRITE);
+            }//end if
+        } else if ( key.isReadable() ) {
+            boolean readcomplete = read(key);
+            if ( readcomplete ) {
+                setRequestCount(getRequestCount()+1);
+                return true;
+            } else {
+                key.interestOps(key.interestOps() | SelectionKey.OP_READ);
+            }//end if
+        } else {
+            //unknown state, should never happen
+            log.warn("Data is in unknown state. readyOps="+ops);
+            throw new IOException("Data is in unknown state. readyOps="+ops);
+        }//end if
+        return false;
+    }
+    
+    
+
+    protected boolean read(SelectionKey key) throws IOException {
+        //if there is no message here, we are done
+        if ( current == null ) return true;
+        int read = socketChannel.read(readbuf);
+        //end of stream
+        if ( read == -1 ) throw new IOException("Unable to receive an ack message. EOF on socket channel has been reached.");
+        //no data read
+        else if ( read == 0 ) return false;
+        readbuf.flip();
+        ackbuf.append(readbuf,read);
+        readbuf.clear();
+        if (ackbuf.doesPackageExist() ) {
+            byte[] ackcmd = ackbuf.extractDataPackage(true).getBytes();
+            boolean ack = Arrays.equals(ackcmd,org.apache.catalina.tribes.transport.Constants.ACK_DATA);
+            boolean fack = Arrays.equals(ackcmd,org.apache.catalina.tribes.transport.Constants.FAIL_ACK_DATA);
+            if ( fack && getThrowOnFailedAck() ) throw new RemoteProcessException("Received a failed ack:org.apache.catalina.tribes.transport.Constants.FAIL_ACK_DATA");
+            return ack || fack;
+        } else {
+            return false;
+        }
+    }
+
+    
+    protected boolean write(SelectionKey key) throws IOException {
+        if ( (!isConnected()) || (this.socketChannel==null)) {
+            throw new IOException("NioSender is not connected, this should not occur.");
+        }
+        if ( current != null ) {
+            if ( remaining > 0 ) {
+                //weve written everything, or we are starting a new package
+                //protect against buffer overwrite
+                int byteswritten = socketChannel.write(writebuf);
+                remaining -= byteswritten;
+                //if the entire message was written from the buffer
+                //reset the position counter
+                if ( remaining < 0 ) {
+                    remaining = 0;
+                }
+            }
+            return (remaining==0);
+        }
+        //no message to send, we can consider that complete
+        return true;
+    }
+
+    /**
+     * connect - blocking in this operation
+     *
+     * @throws IOException
+     * @todo Implement this org.apache.catalina.tribes.transport.IDataSender method
+     */
+    public synchronized void connect() throws IOException {
+        if ( connecting ) return;
+        connecting = true;
+        if ( isConnected() ) throw new IOException("NioSender is already in connected state.");
+        if ( readbuf == null ) {
+            readbuf = getReadBuffer();
+        } else {
+            readbuf.clear();
+        }
+        if ( writebuf == null ) {
+            writebuf = getWriteBuffer();
+        } else {
+            writebuf.clear();
+        }
+        
+        InetSocketAddress addr = new InetSocketAddress(getAddress(),getPort());
+        if ( socketChannel != null ) throw new IOException("Socket channel has already been established. Connection might be in progress.");
+        socketChannel = SocketChannel.open();
+        socketChannel.configureBlocking(false);
+        socketChannel.connect(addr);
+        socketChannel.register(getSelector(),SelectionKey.OP_CONNECT,this);
+    }
+    
+
+    /**
+     * disconnect
+     *
+     * @todo Implement this org.apache.catalina.tribes.transport.IDataSender method
+     */
+    public void disconnect() {
+        try {
+            connecting = false;
+            setConnected(false);
+            if ( socketChannel != null ) {
+                try {
+                    try {socketChannel.socket().close();}catch ( Exception x){}
+                    //error free close, all the way
+                    //try {socket.shutdownOutput();}catch ( Exception x){}
+                    //try {socket.shutdownInput();}catch ( Exception x){}
+                    //try {socket.close();}catch ( Exception x){}
+                    try {socketChannel.close();}catch ( Exception x){}
+                }finally {
+                    socketChannel = null;
+                }
+            }
+        } catch ( Exception x ) {
+            log.error("Unable to disconnect NioSender. msg="+x.getMessage());
+            if ( log.isDebugEnabled() ) log.debug("Unable to disconnect NioSender. msg="+x.getMessage(),x);
+        } finally {
+        }
+
+    }
+    
+    public void reset() {
+        if ( isConnected() && readbuf == null) {
+            readbuf = getReadBuffer();
+        }
+        if ( readbuf != null ) readbuf.clear();
+        if ( writebuf != null ) writebuf.clear();
+        current = null;
+        ackbuf.clear();
+        remaining = 0;
+        complete = false;
+        setAttempt(0);
+        setRequestCount(0);
+        setConnectTime(-1);
+    }
+
+    private ByteBuffer getReadBuffer() { 
+        return getBuffer(getRxBufSize());
+    }
+    
+    private ByteBuffer getWriteBuffer() {
+        return getBuffer(getTxBufSize());
+    }
+
+    private ByteBuffer getBuffer(int size) {
+        return (getDirectBuffer()?ByteBuffer.allocateDirect(size):ByteBuffer.allocate(size));
+    }
+    
+    /**
+    * sendMessage
+    *
+    * @param data ChannelMessage
+    * @throws IOException
+    * @todo Implement this org.apache.catalina.tribes.transport.IDataSender method
+    */
+   public synchronized void setMessage(byte[] data) throws IOException {
+       setMessage(data,0,data.length);
+   }
+
+   public synchronized void setMessage(byte[] data,int offset, int length) throws IOException {
+       if ( data != null ) {
+           current = data;
+           remaining = length;
+           ackbuf.clear();
+           if ( writebuf != null ) writebuf.clear();
+           else writebuf = getBuffer(length);
+           if ( writebuf.capacity() < length ) writebuf = getBuffer(length);
+           writebuf.put(data,offset,length);
+           //writebuf.rewind();
+           //set the limit so that we don't write non wanted data
+           //writebuf.limit(length);
+           writebuf.flip();
+           if (isConnected()) {
+               socketChannel.register(getSelector(), SelectionKey.OP_WRITE, this);
+           }
+       } 
+   }
+   
+   public byte[] getMessage() {
+       return current;
+   }
+
+
+
+    public boolean isComplete() {
+        return complete;
+    }
+
+    public Selector getSelector() {
+        return selector;
+    }
+
+    public void setSelector(Selector selector) {
+        this.selector = selector;
+    }
+
+
+    public void setComplete(boolean complete) {
+        this.complete = complete;
+    }
 }
\ No newline at end of file

==================================================
PooledParallelSender.java
index b444451ddc..12d6316ece 100644
--- a/java/org/apache/catalina/tribes/transport/nio/ParallelNioSender.java
+++ b/java/org/apache/catalina/tribes/transport/nio/ParallelNioSender.java
@@ -1,288 +1,289 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.transport.nio;
-
-
-import java.io.IOException;
-import java.nio.channels.SelectionKey;
-import java.nio.channels.Selector;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
-
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.io.ChannelData;
-import org.apache.catalina.tribes.io.XByteBuffer;
-import org.apache.catalina.tribes.transport.MultiPointSender;
-import org.apache.catalina.tribes.transport.SenderState;
-import org.apache.catalina.tribes.transport.AbstractSender;
-import java.net.UnknownHostException;
-import org.apache.catalina.tribes.Channel;
-import org.apache.catalina.tribes.group.RpcChannel;
-import org.apache.catalina.tribes.util.Logs;
-import org.apache.catalina.tribes.UniqueId;
-
-/**
- * <p>Title: </p>
- *
- * <p>Description: </p>
- *
- * <p>Copyright: Copyright (c) 2005</p>
- *
- * <p>Company: </p>
- *
- * @author not attributable
- * @version 1.0
- */
-public class ParallelNioSender extends AbstractSender implements MultiPointSender {
-    
-    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(ParallelNioSender.class);
-    protected long selectTimeout = 5000; //default 5 seconds, same as send timeout
-    protected Selector selector;
-    protected HashMap nioSenders = new HashMap();
-
-    public ParallelNioSender() throws IOException {
-        selector = Selector.open();
-        setConnected(true);
-    }
-    
-    
-    public synchronized void sendMessage(Member[] destination, ChannelMessage msg) throws ChannelException {
-        long start = System.currentTimeMillis();
-        byte[] data = XByteBuffer.createDataPackage((ChannelData)msg);
-        NioSender[] senders = setupForSend(destination);
-        connect(senders);
-        setData(senders,data);
-        
-        int remaining = senders.length;
-        ChannelException cx = null;
-        try {
-            //loop until complete, an error happens, or we timeout
-            long delta = System.currentTimeMillis() - start;
-            boolean waitForAck = (Channel.SEND_OPTIONS_USE_ACK & msg.getOptions()) == Channel.SEND_OPTIONS_USE_ACK;
-            while ( (remaining>0) && (delta<getTimeout()) ) {
-                try {
-                    remaining -= doLoop(selectTimeout, getMaxRetryAttempts(),waitForAck,msg);
-                } catch (Exception x ) {
-                    if ( cx == null ) {
-                        if ( x instanceof ChannelException ) cx = (ChannelException)x;
-                        else cx = new ChannelException("Parallel NIO send failed.", x);
-                    } else {
-                        if (x instanceof ChannelException) cx.addFaultyMember( ( (ChannelException) x).getFaultyMembers());
-                    }
-                }
-                //bail out if all remaining senders are failing
-                if ( cx != null && cx.getFaultyMembers().length == remaining ) throw cx;
-                delta = System.currentTimeMillis() - start;
-            }
-            if ( remaining > 0 ) {
-                //timeout has occured
-                cx = new ChannelException("Operation has timed out("+getTimeout()+" ms.).");
-                for (int i=0; i<senders.length; i++ ) {
-                    if (!senders[i].isComplete() ) cx.addFaultyMember(senders[i].getDestination(),null);
-                }
-                throw cx;
-            }
-        } catch (Exception x ) {
-            try { this.disconnect(); } catch (Exception ignore) {}
-            if ( x instanceof ChannelException ) throw (ChannelException)x;
-            else throw new ChannelException(x);
-        }
-        
-    }
-    
-    private int doLoop(long selectTimeOut, int maxAttempts, boolean waitForAck, ChannelMessage msg) throws IOException, ChannelException {
-        int completed = 0;
-        int selectedKeys = selector.select(selectTimeOut);
-        
-        if (selectedKeys == 0) {
-            return 0;
-        }
-        
-        Iterator it = selector.selectedKeys().iterator();
-        while (it.hasNext()) {
-            SelectionKey sk = (SelectionKey) it.next();
-            it.remove();
-            int readyOps = sk.readyOps();
-            sk.interestOps(sk.interestOps() & ~readyOps);
-            NioSender sender = (NioSender) sk.attachment();
-            try {
-                if (sender.process(sk,waitForAck)) {
-                    completed++;
-                    sender.setComplete(true);
-                    if ( Logs.MESSAGES.isTraceEnabled() ) {
-                        Logs.MESSAGES.trace("ParallelNioSender - Sent msg:" + new UniqueId(msg.getUniqueId()) + " at " +new java.sql.Timestamp(System.currentTimeMillis())+ " to "+sender.getDestination().getName());
-                    }
-                    SenderState.getSenderState(sender.getDestination()).setReady();
-                }//end if
-            } catch (Exception x) {
-                SenderState state = SenderState.getSenderState(sender.getDestination());
-                int attempt = sender.getAttempt()+1;
-                boolean retry = (sender.getAttempt() <= maxAttempts && maxAttempts>0);
-                synchronized (state) {
-                
-                    //sk.cancel();
-                    if (state.isSuspect()) state.setFailing();
-                    if (state.isReady()) {
-                        state.setSuspect();
-                        if ( retry ) 
-                            log.warn("Member send is failing for:" + sender.getDestination().getName() +" ; Setting to suspect and retrying.");
-                        else 
-                            log.warn("Member send is failing for:" + sender.getDestination().getName() +" ; Setting to suspect.", x);
-                    }                    
-                }
-                if ( !isConnected() ) {
-                    log.warn("Not retrying send for:" + sender.getDestination().getName() + "; Sender is disconnected.");
-                    ChannelException cx = new ChannelException("Send failed, and sender is disconnected. Not retrying.",x);
-                    cx.addFaultyMember(sender.getDestination(),x);
-                    throw cx;
-                }
-                
-                byte[] data = sender.getMessage();
-                if ( retry ) {
-                    try { 
-                        sender.disconnect(); 
-                        sender.connect();
-                        sender.setAttempt(attempt);
-                        sender.setMessage(data);
-                    }catch ( Exception ignore){
-                        state.setFailing();
-                    }
-                } else {
-                    ChannelException cx = new ChannelException("Send failed, attempt:"+sender.getAttempt()+" max:"+maxAttempts,x);
-                    cx.addFaultyMember(sender.getDestination(),x);
-                    throw cx;
-                }//end if
-            }
-        }
-        return completed;
-
-    }
-    
-    private void connect(NioSender[] senders) throws ChannelException {
-        ChannelException x = null;
-        for (int i=0; i<senders.length; i++ ) {
-            try {
-                if (!senders[i].isConnected()) senders[i].connect();
-            }catch ( IOException io ) {
-                if ( x==null ) x = new ChannelException(io);
-                x.addFaultyMember(senders[i].getDestination(),io);
-            }
-        }
-        if ( x != null ) throw x;
-    }
-    
-    private void setData(NioSender[] senders, byte[] data) throws ChannelException {
-        ChannelException x = null;
-        for (int i=0; i<senders.length; i++ ) {
-            try {
-                senders[i].setMessage(data);
-            }catch ( IOException io ) {
-                if ( x==null ) x = new ChannelException(io);
-                x.addFaultyMember(senders[i].getDestination(),io);
-            }
-        }
-        if ( x != null ) throw x;
-    }
-    
-    
-    private NioSender[] setupForSend(Member[] destination) throws ChannelException {
-        ChannelException cx = null;
-        NioSender[] result = new NioSender[destination.length];
-        for ( int i=0; i<destination.length; i++ ) {
-            NioSender sender = (NioSender)nioSenders.get(destination[i]);
-            try {
-
-                if (sender == null) {
-                    sender = new NioSender();
-                    sender.transferProperties(this, sender);
-                    nioSenders.put(destination[i], sender);
-                }
-                if (sender != null) {
-                    sender.reset();
-                    sender.setDestination(destination[i]);
-                    sender.setSelector(selector);
-                    result[i] = sender;
-                }
-            }catch ( UnknownHostException x ) {
-                if (cx == null) cx = new ChannelException("Unable to setup NioSender.", x);
-                cx.addFaultyMember(destination[i], x);
-            }
-        }
-        if ( cx != null ) throw cx;
-        else return result;
-    }
-    
-    public void connect() {
-        //do nothing, we connect on demand
-        setConnected(true);
-    }
-    
-    
-    private synchronized void close() throws ChannelException  {
-        ChannelException x = null;
-        Object[] members = nioSenders.keySet().toArray();
-        for (int i=0; i<members.length; i++ ) {
-            Member mbr = (Member)members[i];
-            try {
-                NioSender sender = (NioSender)nioSenders.get(mbr);
-                sender.disconnect();
-            }catch ( Exception e ) {
-                if ( x == null ) x = new ChannelException(e);
-                x.addFaultyMember(mbr,e);
-            }
-            nioSenders.remove(mbr);
-        }
-        if ( x != null ) throw x;
-    }
-    
-    public void memberAdded(Member member) {
-        
-    }
-    
-    public void memberDisappeared(Member member) {
-        //disconnect senders
-        NioSender sender = (NioSender)nioSenders.remove(member);
-        if ( sender != null ) sender.disconnect();
-    }
-
-    
-    public synchronized void disconnect() {
-        setConnected(false);
-        try {close(); }catch (Exception x){}
-        
-    }
-    
-    public void finalize() {
-        try {disconnect(); }catch ( Exception ignore){}
-    }
-
-    public boolean keepalive() {
-        //throw new UnsupportedOperationException("Method ParallelNioSender.checkKeepAlive() not implemented");
-        boolean result = false;
-        for ( Iterator i = nioSenders.entrySet().iterator(); i.hasNext();  ) {
-            Map.Entry entry = (Map.Entry)i.next();
-            NioSender sender = (NioSender)entry.getValue();
-            if ( sender.keepalive() ) {
-                nioSenders.remove(entry.getKey());
-            }
-        }
-        return result;
-    }
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.transport.nio;
+
+
+import java.io.IOException;
+import java.nio.channels.SelectionKey;
+import java.nio.channels.Selector;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.io.ChannelData;
+import org.apache.catalina.tribes.io.XByteBuffer;
+import org.apache.catalina.tribes.transport.MultiPointSender;
+import org.apache.catalina.tribes.transport.SenderState;
+import org.apache.catalina.tribes.transport.AbstractSender;
+import java.net.UnknownHostException;
+import org.apache.catalina.tribes.Channel;
+import org.apache.catalina.tribes.group.RpcChannel;
+import org.apache.catalina.tribes.util.Logs;
+import org.apache.catalina.tribes.UniqueId;
+
+/**
+ * <p>Title: </p>
+ *
+ * <p>Description: </p>
+ *
+ * <p>Copyright: Copyright (c) 2005</p>
+ *
+ * <p>Company: </p>
+ *
+ * @author not attributable
+ * @version 1.0
+ */
+public class ParallelNioSender extends AbstractSender implements MultiPointSender {
+    
+    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(ParallelNioSender.class);
+    protected long selectTimeout = 5000; //default 5 seconds, same as send timeout
+    protected Selector selector;
+    protected HashMap nioSenders = new HashMap();
+
+    public ParallelNioSender() throws IOException {
+        selector = Selector.open();
+        setConnected(true);
+    }
+    
+    
+    public synchronized void sendMessage(Member[] destination, ChannelMessage msg) throws ChannelException {
+        long start = System.currentTimeMillis();
+        byte[] data = XByteBuffer.createDataPackage((ChannelData)msg);
+        NioSender[] senders = setupForSend(destination);
+        connect(senders);
+        setData(senders,data);
+        
+        int remaining = senders.length;
+        ChannelException cx = null;
+        try {
+            //loop until complete, an error happens, or we timeout
+            long delta = System.currentTimeMillis() - start;
+            boolean waitForAck = (Channel.SEND_OPTIONS_USE_ACK & msg.getOptions()) == Channel.SEND_OPTIONS_USE_ACK;
+            while ( (remaining>0) && (delta<getTimeout()) ) {
+                try {
+                    remaining -= doLoop(selectTimeout, getMaxRetryAttempts(),waitForAck,msg);
+                } catch (Exception x ) {
+                    if ( cx == null ) {
+                        if ( x instanceof ChannelException ) cx = (ChannelException)x;
+                        else cx = new ChannelException("Parallel NIO send failed.", x);
+                    } else {
+                        if (x instanceof ChannelException) cx.addFaultyMember( ( (ChannelException) x).getFaultyMembers());
+                    }
+                }
+                //bail out if all remaining senders are failing
+                if ( cx != null && cx.getFaultyMembers().length == remaining ) throw cx;
+                delta = System.currentTimeMillis() - start;
+            }
+            if ( remaining > 0 ) {
+                //timeout has occured
+                cx = new ChannelException("Operation has timed out("+getTimeout()+" ms.).");
+                for (int i=0; i<senders.length; i++ ) {
+                    if (!senders[i].isComplete() ) cx.addFaultyMember(senders[i].getDestination(),null);
+                }
+                throw cx;
+            }
+        } catch (Exception x ) {
+            try { this.disconnect(); } catch (Exception ignore) {}
+            if ( x instanceof ChannelException ) throw (ChannelException)x;
+            else throw new ChannelException(x);
+        }
+        
+    }
+    
+    private int doLoop(long selectTimeOut, int maxAttempts, boolean waitForAck, ChannelMessage msg) throws IOException, ChannelException {
+        int completed = 0;
+        int selectedKeys = selector.select(selectTimeOut);
+        
+        if (selectedKeys == 0) {
+            return 0;
+        }
+        
+        Iterator it = selector.selectedKeys().iterator();
+        while (it.hasNext()) {
+            SelectionKey sk = (SelectionKey) it.next();
+            it.remove();
+            int readyOps = sk.readyOps();
+            sk.interestOps(sk.interestOps() & ~readyOps);
+            NioSender sender = (NioSender) sk.attachment();
+            try {
+                if (sender.process(sk,waitForAck)) {
+                    completed++;
+                    sender.setComplete(true);
+                    if ( Logs.MESSAGES.isTraceEnabled() ) {
+                        Logs.MESSAGES.trace("ParallelNioSender - Sent msg:" + new UniqueId(msg.getUniqueId()) + " at " +new java.sql.Timestamp(System.currentTimeMillis())+ " to "+sender.getDestination().getName());
+                    }
+                    SenderState.getSenderState(sender.getDestination()).setReady();
+                }//end if
+            } catch (Exception x) {
+                SenderState state = SenderState.getSenderState(sender.getDestination());
+                int attempt = sender.getAttempt()+1;
+                boolean retry = (sender.getAttempt() <= maxAttempts && maxAttempts>0);
+                synchronized (state) {
+                
+                    //sk.cancel();
+                    if (state.isSuspect()) state.setFailing();
+                    if (state.isReady()) {
+                        state.setSuspect();
+                        if ( retry ) 
+                            log.warn("Member send is failing for:" + sender.getDestination().getName() +" ; Setting to suspect and retrying.");
+                        else 
+                            log.warn("Member send is failing for:" + sender.getDestination().getName() +" ; Setting to suspect.", x);
+                    }                    
+                }
+                if ( !isConnected() ) {
+                    log.warn("Not retrying send for:" + sender.getDestination().getName() + "; Sender is disconnected.");
+                    ChannelException cx = new ChannelException("Send failed, and sender is disconnected. Not retrying.",x);
+                    cx.addFaultyMember(sender.getDestination(),x);
+                    throw cx;
+                }
+                
+                byte[] data = sender.getMessage();
+                if ( retry ) {
+                    try { 
+                        sender.disconnect(); 
+                        sender.connect();
+                        sender.setAttempt(attempt);
+                        sender.setMessage(data);
+                    }catch ( Exception ignore){
+                        state.setFailing();
+                    }
+                } else {
+                    ChannelException cx = new ChannelException("Send failed, attempt:"+sender.getAttempt()+" max:"+maxAttempts,x);
+                    cx.addFaultyMember(sender.getDestination(),x);
+                    throw cx;
+                }//end if
+            }
+        }
+        return completed;
+
+    }
+    
+    private void connect(NioSender[] senders) throws ChannelException {
+        ChannelException x = null;
+        for (int i=0; i<senders.length; i++ ) {
+            try {
+                if (!senders[i].isConnected()) senders[i].connect();
+            }catch ( IOException io ) {
+                if ( x==null ) x = new ChannelException(io);
+                x.addFaultyMember(senders[i].getDestination(),io);
+            }
+        }
+        if ( x != null ) throw x;
+    }
+    
+    private void setData(NioSender[] senders, byte[] data) throws ChannelException {
+        ChannelException x = null;
+        for (int i=0; i<senders.length; i++ ) {
+            try {
+                senders[i].setMessage(data);
+            }catch ( IOException io ) {
+                if ( x==null ) x = new ChannelException(io);
+                x.addFaultyMember(senders[i].getDestination(),io);
+            }
+        }
+        if ( x != null ) throw x;
+    }
+    
+    
+    private NioSender[] setupForSend(Member[] destination) throws ChannelException {
+        ChannelException cx = null;
+        NioSender[] result = new NioSender[destination.length];
+        for ( int i=0; i<destination.length; i++ ) {
+            NioSender sender = (NioSender)nioSenders.get(destination[i]);
+            try {
+
+                if (sender == null) {
+                    sender = new NioSender();
+                    sender.transferProperties(this, sender);
+                    nioSenders.put(destination[i], sender);
+                }
+                if (sender != null) {
+                    sender.reset();
+                    sender.setDestination(destination[i]);
+                    sender.setSelector(selector);
+                    result[i] = sender;
+                }
+            }catch ( UnknownHostException x ) {
+                if (cx == null) cx = new ChannelException("Unable to setup NioSender.", x);
+                cx.addFaultyMember(destination[i], x);
+            }
+        }
+        if ( cx != null ) throw cx;
+        else return result;
+    }
+    
+    public void connect() {
+        //do nothing, we connect on demand
+        setConnected(true);
+    }
+    
+    
+    private synchronized void close() throws ChannelException  {
+        ChannelException x = null;
+        Object[] members = nioSenders.keySet().toArray();
+        for (int i=0; i<members.length; i++ ) {
+            Member mbr = (Member)members[i];
+            try {
+                NioSender sender = (NioSender)nioSenders.get(mbr);
+                sender.disconnect();
+            }catch ( Exception e ) {
+                if ( x == null ) x = new ChannelException(e);
+                x.addFaultyMember(mbr,e);
+            }
+            nioSenders.remove(mbr);
+        }
+        if ( x != null ) throw x;
+    }
+    
+    public void memberAdded(Member member) {
+        
+    }
+    
+    public void memberDisappeared(Member member) {
+        //disconnect senders
+        NioSender sender = (NioSender)nioSenders.remove(member);
+        if ( sender != null ) sender.disconnect();
+    }
+
+    
+    public synchronized void disconnect() {
+        setConnected(false);
+        try {close(); }catch (Exception x){}
+        
+    }
+    
+    public void finalize() {
+        try {disconnect(); }catch ( Exception ignore){}
+    }
+
+    public boolean keepalive() {
+        //throw new UnsupportedOperationException("Method ParallelNioSender.checkKeepAlive() not implemented");
+        boolean result = false;
+        for ( Iterator i = nioSenders.entrySet().iterator(); i.hasNext();  ) {
+            Map.Entry entry = (Map.Entry)i.next();
+            NioSender sender = (NioSender)entry.getValue();
+            if ( sender.keepalive() ) {
+                nioSenders.remove(entry.getKey());
+            }
+        }
+        return result;
+    }
+
 }
\ No newline at end of file

==================================================
Arrays.java
index c802194135..582785b788 100644
--- a/java/org/apache/catalina/tribes/transport/nio/PooledParallelSender.java
+++ b/java/org/apache/catalina/tribes/transport/nio/PooledParallelSender.java
@@ -1,84 +1,85 @@
-/*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.transport.nio;
-
-import java.io.IOException;
-
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.transport.DataSender;
-import org.apache.catalina.tribes.transport.MultiPointSender;
-import org.apache.catalina.tribes.transport.PooledSender;
-
-/**
- * <p>Title: </p>
- *
- * <p>Description: </p>
- *
- * <p>Copyright: Copyright (c) 2005</p>
- *
- * <p>Company: </p>
- *
- * @author not attributable
- * @version 1.0
- */
-public class PooledParallelSender extends PooledSender implements MultiPointSender {
-    protected boolean connected = true;
-    public PooledParallelSender() {
-        super();
-    }
-    
-    public void sendMessage(Member[] destination, ChannelMessage message) throws ChannelException {
-        if ( !connected ) throw new ChannelException("Sender not connected.");
-        ParallelNioSender sender = (ParallelNioSender)getSender();
-        try {
-            sender.sendMessage(destination, message);
-            sender.keepalive();
-        }finally {
-            if ( !connected ) disconnect();
-            returnSender(sender);
-        }
-    }
-
-    public DataSender getNewDataSender() {
-        try {
-            ParallelNioSender sender = new ParallelNioSender();
-            sender.transferProperties(this,sender);
-            return sender;
-        } catch ( IOException x ) {
-            throw new RuntimeException("Unable to open NIO selector.",x);
-        }
-    }
-    
-    public synchronized void disconnect() {
-        this.connected = false;
-        super.disconnect();
-    }
-
-    public synchronized void connect() throws IOException {
-        this.connected = true;
-        super.connect();
-    }
-
-    public void memberAdded(Member member) {
-    
-    }
-    
-    public void memberDisappeared(Member member) {
-        //disconnect senders
-    }    
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.transport.nio;
+
+import java.io.IOException;
+
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.transport.DataSender;
+import org.apache.catalina.tribes.transport.MultiPointSender;
+import org.apache.catalina.tribes.transport.PooledSender;
+
+/**
+ * <p>Title: </p>
+ *
+ * <p>Description: </p>
+ *
+ * <p>Copyright: Copyright (c) 2005</p>
+ *
+ * <p>Company: </p>
+ *
+ * @author not attributable
+ * @version 1.0
+ */
+public class PooledParallelSender extends PooledSender implements MultiPointSender {
+    protected boolean connected = true;
+    public PooledParallelSender() {
+        super();
+    }
+    
+    public void sendMessage(Member[] destination, ChannelMessage message) throws ChannelException {
+        if ( !connected ) throw new ChannelException("Sender not connected.");
+        ParallelNioSender sender = (ParallelNioSender)getSender();
+        try {
+            sender.sendMessage(destination, message);
+            sender.keepalive();
+        }finally {
+            if ( !connected ) disconnect();
+            returnSender(sender);
+        }
+    }
+
+    public DataSender getNewDataSender() {
+        try {
+            ParallelNioSender sender = new ParallelNioSender();
+            sender.transferProperties(this,sender);
+            return sender;
+        } catch ( IOException x ) {
+            throw new RuntimeException("Unable to open NIO selector.",x);
+        }
+    }
+    
+    public synchronized void disconnect() {
+        this.connected = false;
+        super.disconnect();
+    }
+
+    public synchronized void connect() throws IOException {
+        this.connected = true;
+        super.connect();
+    }
+
+    public void memberAdded(Member member) {
+    
+    }
+    
+    public void memberDisappeared(Member member) {
+        //disconnect senders
+    }    
 }
\ No newline at end of file

==================================================
Logs.java
index ce72d6548b..b7488ab5a9 100644
--- a/java/org/apache/catalina/tribes/util/Arrays.java
+++ b/java/org/apache/catalina/tribes/util/Arrays.java
@@ -1,220 +1,221 @@
-/*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.util;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.UniqueId;
-import org.apache.catalina.tribes.group.AbsoluteOrder;
-import org.apache.catalina.tribes.membership.MemberImpl;
-import org.apache.catalina.tribes.membership.Membership;
-import java.io.UnsupportedEncodingException;
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-import java.util.StringTokenizer;
-
-/**
- * @author Filip Hanik
- * @version 1.0
- */
-public class Arrays {
-    protected static Log log = LogFactory.getLog(Arrays.class);
-    
-    public static boolean contains(byte[] source, int srcoffset, byte[] key, int keyoffset, int length) {
-        if ( srcoffset < 0 || srcoffset >= source.length) throw new ArrayIndexOutOfBoundsException("srcoffset is out of bounds.");
-        if ( keyoffset < 0 || keyoffset >= key.length) throw new ArrayIndexOutOfBoundsException("keyoffset is out of bounds.");
-        if ( length > (key.length-keyoffset) ) throw new ArrayIndexOutOfBoundsException("not enough data elements in the key, length is out of bounds.");
-        //we don't have enough data to validate it
-        if ( length > (source.length-srcoffset) ) return false;
-        boolean match = true;
-        int pos = keyoffset;
-        for ( int i=srcoffset; match && i<length; i++ ) {
-            match = (source[i] == key[pos++]);
-        }
-        return match;
-    }
-    
-    public static String toString(byte[] data) {
-        return toString(data,0,data!=null?data.length:0);
-    }
-
-    public static String toString(byte[] data, int offset, int length) {
-        StringBuffer buf = new StringBuffer("{");
-        if ( data != null && length > 0 ) {
-            buf.append(data[offset++]);
-            for (int i = offset; i < length; i++) {
-                buf.append(", ").append(data[i]);
-            }
-        }
-        buf.append("}");
-        return buf.toString();
-    }
-    
-    public static String toString(Object[] data) {
-        return toString(data,0,data!=null?data.length:0);
-    }
-    
-    public static String toString(Object[] data, int offset, int length) {
-        StringBuffer buf = new StringBuffer("{");
-        if ( data != null && length > 0 ) {
-            buf.append(data[offset++]);
-            for (int i = offset; i < length; i++) {
-                buf.append(", ").append(data[i]);
-            }
-        }
-        buf.append("}");
-        return buf.toString();
-    }
-    
-    public static String toNameString(Member[] data) {
-        return toNameString(data,0,data!=null?data.length:0);
-    }
-    
-    public static String toNameString(Member[] data, int offset, int length) {
-        StringBuffer buf = new StringBuffer("{");
-        if ( data != null && length > 0 ) {
-            buf.append(data[offset++].getName());
-            for (int i = offset; i < length; i++) {
-                buf.append(", ").append(data[i].getName());
-            }
-        }
-        buf.append("}");
-        return buf.toString();
-    }
-
-    public static int add(int[] data) {
-        int result = 0;
-        for (int i=0;i<data.length; i++ ) result += data[i];
-        return result;
-    }
-    
-    public static UniqueId getUniqudId(ChannelMessage msg) {
-        return new UniqueId(msg.getUniqueId());
-    }
-
-    public static UniqueId getUniqudId(byte[] data) {
-        return new UniqueId(data);
-    }
-    
-    public static boolean equals(byte[] o1, byte[] o2) {
-        return java.util.Arrays.equals(o1,o2);
-    }
-
-    public static boolean equals(Object[] o1, Object[] o2) {
-        boolean result = o1.length == o2.length;
-        if ( result ) for (int i=0; i<o1.length && result; i++ ) result = o1[i].equals(o2[i]);
-        return result;
-    }
-    
-    public static boolean sameMembers(Member[] m1, Member[] m2) {
-        AbsoluteOrder.absoluteOrder(m1);
-        AbsoluteOrder.absoluteOrder(m2);
-        return equals(m1,m2);
-    }
-    
-    public static Member[] merge(Member[] m1, Member[] m2) {
-        AbsoluteOrder.absoluteOrder(m1);
-        AbsoluteOrder.absoluteOrder(m2);
-        ArrayList list = new ArrayList(java.util.Arrays.asList(m1));
-        for (int i=0; i<m2.length; i++) if ( !list.contains(m2[i]) ) list.add(m2[i]);
-        Member[] result = new Member[list.size()];
-        list.toArray(result);
-        AbsoluteOrder.absoluteOrder(result);
-        return result;
-    }
-    
-    public static void fill(Membership mbrship, Member[] m) {
-        for (int i=0; i<m.length; i++ ) mbrship.addMember((MemberImpl)m[i]);
-    }
-    
-    public static Member[] diff(Membership complete, Membership local, MemberImpl ignore) {
-        ArrayList result = new ArrayList();
-        MemberImpl[] comp = complete.getMembers();
-        for ( int i=0; i<comp.length; i++ ) {
-            if ( ignore!=null && ignore.equals(comp[i]) ) continue;
-            if ( local.getMember(comp[i]) == null ) result.add(comp[i]);
-        }
-        return (MemberImpl[])result.toArray(new MemberImpl[result.size()]);
-    }
-    
-    public static Member[] remove(Member[] all, Member remove) {
-        return extract(all,new Member[] {remove});
-    }
-    
-    public static Member[] extract(Member[] all, Member[] remove) {
-        List alist = java.util.Arrays.asList(all);
-        ArrayList list = new ArrayList(alist);
-        for (int i=0; i<remove.length; i++ ) list.remove(remove[i]);
-        return (Member[])list.toArray(new Member[list.size()]);
-    }
-    
-    public static int indexOf(Member member, Member[] members) {
-        int result = -1;
-        for (int i=0; (result==-1) && (i<members.length); i++ ) 
-            if ( member.equals(members[i]) ) result = i;
-        return result;
-    }
-    
-    public static int nextIndex(Member member, Member[] members) {
-        int idx = indexOf(member,members)+1;
-        if (idx >= members.length ) idx = ((members.length>0)?0:-1);
-        
-//System.out.println("Next index:"+idx);
-//System.out.println("Member:"+member.getName());
-//System.out.println("Members:"+toNameString(members));
-        return idx;
-    }
-    
-    public static int hashCode(byte a[]) {
-        if (a == null)
-            return 0;
-
-        int result = 1;
-        for (int i=0; i<a.length; i++) {
-            byte element = a[i];
-            result = 31 * result + element;
-        }
-        return result;
-    }
-    
-    public static byte[] fromString(String value) { 
-        if ( value == null ) return null;
-        if ( !value.startsWith("{") ) throw new RuntimeException("byte arrays must be represented as {1,3,4,5,6}");
-        StringTokenizer t = new StringTokenizer(value,"{,}",false);
-        byte[] result = new byte[t.countTokens()];
-        for (int i=0; i<result.length; i++ ) result[i] = Byte.parseByte(t.nextToken());
-        return result;
-    }
-
-    
- 
-    public static byte[] convert(String s) {
-        try {
-            return s.getBytes("ISO-8859-1");
-        }catch (UnsupportedEncodingException ux ) {
-            log.error("Unable to convert ["+s+"] into a byte[] using ISO-8859-1 encoding, falling back to default encoding.");
-            return s.getBytes();
-        }
-    }
-
-
-    
-    
-    
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.util;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.UniqueId;
+import org.apache.catalina.tribes.group.AbsoluteOrder;
+import org.apache.catalina.tribes.membership.MemberImpl;
+import org.apache.catalina.tribes.membership.Membership;
+import java.io.UnsupportedEncodingException;
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+import java.util.StringTokenizer;
+
+/**
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class Arrays {
+    protected static Log log = LogFactory.getLog(Arrays.class);
+    
+    public static boolean contains(byte[] source, int srcoffset, byte[] key, int keyoffset, int length) {
+        if ( srcoffset < 0 || srcoffset >= source.length) throw new ArrayIndexOutOfBoundsException("srcoffset is out of bounds.");
+        if ( keyoffset < 0 || keyoffset >= key.length) throw new ArrayIndexOutOfBoundsException("keyoffset is out of bounds.");
+        if ( length > (key.length-keyoffset) ) throw new ArrayIndexOutOfBoundsException("not enough data elements in the key, length is out of bounds.");
+        //we don't have enough data to validate it
+        if ( length > (source.length-srcoffset) ) return false;
+        boolean match = true;
+        int pos = keyoffset;
+        for ( int i=srcoffset; match && i<length; i++ ) {
+            match = (source[i] == key[pos++]);
+        }
+        return match;
+    }
+    
+    public static String toString(byte[] data) {
+        return toString(data,0,data!=null?data.length:0);
+    }
+
+    public static String toString(byte[] data, int offset, int length) {
+        StringBuffer buf = new StringBuffer("{");
+        if ( data != null && length > 0 ) {
+            buf.append(data[offset++]);
+            for (int i = offset; i < length; i++) {
+                buf.append(", ").append(data[i]);
+            }
+        }
+        buf.append("}");
+        return buf.toString();
+    }
+    
+    public static String toString(Object[] data) {
+        return toString(data,0,data!=null?data.length:0);
+    }
+    
+    public static String toString(Object[] data, int offset, int length) {
+        StringBuffer buf = new StringBuffer("{");
+        if ( data != null && length > 0 ) {
+            buf.append(data[offset++]);
+            for (int i = offset; i < length; i++) {
+                buf.append(", ").append(data[i]);
+            }
+        }
+        buf.append("}");
+        return buf.toString();
+    }
+    
+    public static String toNameString(Member[] data) {
+        return toNameString(data,0,data!=null?data.length:0);
+    }
+    
+    public static String toNameString(Member[] data, int offset, int length) {
+        StringBuffer buf = new StringBuffer("{");
+        if ( data != null && length > 0 ) {
+            buf.append(data[offset++].getName());
+            for (int i = offset; i < length; i++) {
+                buf.append(", ").append(data[i].getName());
+            }
+        }
+        buf.append("}");
+        return buf.toString();
+    }
+
+    public static int add(int[] data) {
+        int result = 0;
+        for (int i=0;i<data.length; i++ ) result += data[i];
+        return result;
+    }
+    
+    public static UniqueId getUniqudId(ChannelMessage msg) {
+        return new UniqueId(msg.getUniqueId());
+    }
+
+    public static UniqueId getUniqudId(byte[] data) {
+        return new UniqueId(data);
+    }
+    
+    public static boolean equals(byte[] o1, byte[] o2) {
+        return java.util.Arrays.equals(o1,o2);
+    }
+
+    public static boolean equals(Object[] o1, Object[] o2) {
+        boolean result = o1.length == o2.length;
+        if ( result ) for (int i=0; i<o1.length && result; i++ ) result = o1[i].equals(o2[i]);
+        return result;
+    }
+    
+    public static boolean sameMembers(Member[] m1, Member[] m2) {
+        AbsoluteOrder.absoluteOrder(m1);
+        AbsoluteOrder.absoluteOrder(m2);
+        return equals(m1,m2);
+    }
+    
+    public static Member[] merge(Member[] m1, Member[] m2) {
+        AbsoluteOrder.absoluteOrder(m1);
+        AbsoluteOrder.absoluteOrder(m2);
+        ArrayList list = new ArrayList(java.util.Arrays.asList(m1));
+        for (int i=0; i<m2.length; i++) if ( !list.contains(m2[i]) ) list.add(m2[i]);
+        Member[] result = new Member[list.size()];
+        list.toArray(result);
+        AbsoluteOrder.absoluteOrder(result);
+        return result;
+    }
+    
+    public static void fill(Membership mbrship, Member[] m) {
+        for (int i=0; i<m.length; i++ ) mbrship.addMember((MemberImpl)m[i]);
+    }
+    
+    public static Member[] diff(Membership complete, Membership local, MemberImpl ignore) {
+        ArrayList result = new ArrayList();
+        MemberImpl[] comp = complete.getMembers();
+        for ( int i=0; i<comp.length; i++ ) {
+            if ( ignore!=null && ignore.equals(comp[i]) ) continue;
+            if ( local.getMember(comp[i]) == null ) result.add(comp[i]);
+        }
+        return (MemberImpl[])result.toArray(new MemberImpl[result.size()]);
+    }
+    
+    public static Member[] remove(Member[] all, Member remove) {
+        return extract(all,new Member[] {remove});
+    }
+    
+    public static Member[] extract(Member[] all, Member[] remove) {
+        List alist = java.util.Arrays.asList(all);
+        ArrayList list = new ArrayList(alist);
+        for (int i=0; i<remove.length; i++ ) list.remove(remove[i]);
+        return (Member[])list.toArray(new Member[list.size()]);
+    }
+    
+    public static int indexOf(Member member, Member[] members) {
+        int result = -1;
+        for (int i=0; (result==-1) && (i<members.length); i++ ) 
+            if ( member.equals(members[i]) ) result = i;
+        return result;
+    }
+    
+    public static int nextIndex(Member member, Member[] members) {
+        int idx = indexOf(member,members)+1;
+        if (idx >= members.length ) idx = ((members.length>0)?0:-1);
+        
+//System.out.println("Next index:"+idx);
+//System.out.println("Member:"+member.getName());
+//System.out.println("Members:"+toNameString(members));
+        return idx;
+    }
+    
+    public static int hashCode(byte a[]) {
+        if (a == null)
+            return 0;
+
+        int result = 1;
+        for (int i=0; i<a.length; i++) {
+            byte element = a[i];
+            result = 31 * result + element;
+        }
+        return result;
+    }
+    
+    public static byte[] fromString(String value) { 
+        if ( value == null ) return null;
+        if ( !value.startsWith("{") ) throw new RuntimeException("byte arrays must be represented as {1,3,4,5,6}");
+        StringTokenizer t = new StringTokenizer(value,"{,}",false);
+        byte[] result = new byte[t.countTokens()];
+        for (int i=0; i<result.length; i++ ) result[i] = Byte.parseByte(t.nextToken());
+        return result;
+    }
+
+    
+ 
+    public static byte[] convert(String s) {
+        try {
+            return s.getBytes("ISO-8859-1");
+        }catch (UnsupportedEncodingException ux ) {
+            log.error("Unable to convert ["+s+"] into a byte[] using ISO-8859-1 encoding, falling back to default encoding.");
+            return s.getBytes();
+        }
+    }
+
+
+    
+    
+    
 }
\ No newline at end of file

==================================================
StringManager.java
index 05a50de22c..12e1d91aea 100644
--- a/java/org/apache/catalina/tribes/util/Logs.java
+++ b/java/org/apache/catalina/tribes/util/Logs.java
@@ -1,28 +1,29 @@
-/*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.util;
-
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-/**
- * 
- * Simple class that holds references to global loggers
- * @author Filip Hanik
- * @version 1.0
- */
-public class Logs {
-    public static Log MESSAGES = LogFactory.getLog( "org.apache.catalina.tribes.MESSAGES" );
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.util;
+
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+/**
+ * 
+ * Simple class that holds references to global loggers
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class Logs {
+    public static Log MESSAGES = LogFactory.getLog( "org.apache.catalina.tribes.MESSAGES" );
+}

==================================================
UUIDGenerator.java
index 5eb32757fd..dd4e88944b 100644
--- a/java/org/apache/catalina/tribes/util/StringManager.java
+++ b/java/org/apache/catalina/tribes/util/StringManager.java
@@ -1,252 +1,253 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina.tribes.util;
-
-import java.text.MessageFormat;
-import java.util.Hashtable;
-import java.util.Locale;
-import java.util.MissingResourceException;
-import java.util.ResourceBundle;
-import java.net.URLClassLoader;
-
-/**
- * An internationalization / localization helper class which reduces
- * the bother of handling ResourceBundles and takes care of the
- * common cases of message formating which otherwise require the
- * creation of Object arrays and such.
- *
- * <p>The StringManager operates on a package basis. One StringManager
- * per package can be created and accessed via the getManager method
- * call.
- *
- * <p>The StringManager will look for a ResourceBundle named by
- * the package name given plus the suffix of "LocalStrings". In
- * practice, this means that the localized information will be contained
- * in a LocalStrings.properties file located in the package
- * directory of the classpath.
- *
- * <p>Please see the documentation for java.util.ResourceBundle for
- * more information.
- *
- * @author James Duncan Davidson [duncan@eng.sun.com]
- * @author James Todd [gonzo@eng.sun.com]
- */
-
-public class StringManager {
-
-    /**
-     * The ResourceBundle for this StringManager.
-     */
-
-    private ResourceBundle bundle;
-
-    private static org.apache.juli.logging.Log log=
-        org.apache.juli.logging.LogFactory.getLog( StringManager.class );
-
-    /**
-     * Creates a new StringManager for a given package. This is a
-     * private method and all access to it is arbitrated by the
-     * static getManager method call so that only one StringManager
-     * per package will be created.
-     *
-     * @param packageName Name of package to create StringManager for.
-     */
-
-    private StringManager(String packageName) {
-        String bundleName = packageName + ".LocalStrings";
-        try {
-            bundle = ResourceBundle.getBundle(bundleName);
-            return;
-        } catch( MissingResourceException ex ) {
-            // Try from the current loader ( that's the case for trusted apps )
-            ClassLoader cl=Thread.currentThread().getContextClassLoader();
-            if( cl != null ) {
-                try {
-                    bundle=ResourceBundle.getBundle(bundleName, Locale.getDefault(), cl);
-                    return;
-                } catch(MissingResourceException ex2) {
-                }
-            }
-            if( cl==null )
-                cl=this.getClass().getClassLoader();
-
-            if (log.isDebugEnabled())
-                log.debug("Can't find resource " + bundleName +
-                    " " + cl);
-            if( cl instanceof URLClassLoader ) {
-                if (log.isDebugEnabled()) 
-                    log.debug( ((URLClassLoader)cl).getURLs());
-            }
-        }
-    }
-
-    /**
-     * Get a string from the underlying resource bundle.
-     *
-     * @param key The resource name
-     */
-    public String getString(String key) {
-        return MessageFormat.format(getStringInternal(key), (Object [])null);
-    }
-
-
-    protected String getStringInternal(String key) {
-        if (key == null) {
-            String msg = "key is null";
-
-            throw new NullPointerException(msg);
-        }
-
-        String str = null;
-
-        if( bundle==null )
-            return key;
-        try {
-            str = bundle.getString(key);
-        } catch (MissingResourceException mre) {
-            str = "Cannot find message associated with key '" + key + "'";
-        }
-
-        return str;
-    }
-
-    /**
-     * Get a string from the underlying resource bundle and format
-     * it with the given set of arguments.
-     *
-     * @param key The resource name
-     * @param args Formatting directives
-     */
-
-    public String getString(String key, Object[] args) {
-        String iString = null;
-        String value = getStringInternal(key);
-
-        // this check for the runtime exception is some pre 1.1.6
-        // VM's don't do an automatic toString() on the passed in
-        // objects and barf out
-
-        try {
-            // ensure the arguments are not null so pre 1.2 VM's don't barf
-            Object nonNullArgs[] = args;
-            for (int i=0; i<args.length; i++) {
-                if (args[i] == null) {
-                    if (nonNullArgs==args) nonNullArgs=(Object[])args.clone();
-                    nonNullArgs[i] = "null";
-                }
-            }
-
-            iString = MessageFormat.format(value, nonNullArgs);
-        } catch (IllegalArgumentException iae) {
-            StringBuffer buf = new StringBuffer();
-            buf.append(value);
-            for (int i = 0; i < args.length; i++) {
-                buf.append(" arg[" + i + "]=" + args[i]);
-            }
-            iString = buf.toString();
-        }
-        return iString;
-    }
-
-    /**
-     * Get a string from the underlying resource bundle and format it
-     * with the given object argument. This argument can of course be
-     * a String object.
-     *
-     * @param key The resource name
-     * @param arg Formatting directive
-     */
-
-    public String getString(String key, Object arg) {
-        Object[] args = new Object[] {arg};
-        return getString(key, args);
-    }
-
-    /**
-     * Get a string from the underlying resource bundle and format it
-     * with the given object arguments. These arguments can of course
-     * be String objects.
-     *
-     * @param key The resource name
-     * @param arg1 Formatting directive
-     * @param arg2 Formatting directive
-     */
-
-    public String getString(String key, Object arg1, Object arg2) {
-        Object[] args = new Object[] {arg1, arg2};
-        return getString(key, args);
-    }
-
-    /**
-     * Get a string from the underlying resource bundle and format it
-     * with the given object arguments. These arguments can of course
-     * be String objects.
-     *
-     * @param key The resource name
-     * @param arg1 Formatting directive
-     * @param arg2 Formatting directive
-     * @param arg3 Formatting directive
-     */
-
-    public String getString(String key, Object arg1, Object arg2,
-                            Object arg3) {
-        Object[] args = new Object[] {arg1, arg2, arg3};
-        return getString(key, args);
-    }
-
-    /**
-     * Get a string from the underlying resource bundle and format it
-     * with the given object arguments. These arguments can of course
-     * be String objects.
-     *
-     * @param key The resource name
-     * @param arg1 Formatting directive
-     * @param arg2 Formatting directive
-     * @param arg3 Formatting directive
-     * @param arg4 Formatting directive
-     */
-
-    public String getString(String key, Object arg1, Object arg2,
-                            Object arg3, Object arg4) {
-        Object[] args = new Object[] {arg1, arg2, arg3, arg4};
-        return getString(key, args);
-    }
-    // --------------------------------------------------------------
-    // STATIC SUPPORT METHODS
-    // --------------------------------------------------------------
-
-    private static Hashtable managers = new Hashtable();
-
-    /**
-     * Get the StringManager for a particular package. If a manager for
-     * a package already exists, it will be reused, else a new
-     * StringManager will be created and returned.
-     *
-     * @param packageName The package name
-     */
-
-    public synchronized static StringManager getManager(String packageName) {
-        StringManager mgr = (StringManager)managers.get(packageName);
-
-        if (mgr == null) {
-            mgr = new StringManager(packageName);
-            managers.put(packageName, mgr);
-        }
-        return mgr;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.catalina.tribes.util;
+
+import java.text.MessageFormat;
+import java.util.Hashtable;
+import java.util.Locale;
+import java.util.MissingResourceException;
+import java.util.ResourceBundle;
+import java.net.URLClassLoader;
+
+/**
+ * An internationalization / localization helper class which reduces
+ * the bother of handling ResourceBundles and takes care of the
+ * common cases of message formating which otherwise require the
+ * creation of Object arrays and such.
+ *
+ * <p>The StringManager operates on a package basis. One StringManager
+ * per package can be created and accessed via the getManager method
+ * call.
+ *
+ * <p>The StringManager will look for a ResourceBundle named by
+ * the package name given plus the suffix of "LocalStrings". In
+ * practice, this means that the localized information will be contained
+ * in a LocalStrings.properties file located in the package
+ * directory of the classpath.
+ *
+ * <p>Please see the documentation for java.util.ResourceBundle for
+ * more information.
+ *
+ * @author James Duncan Davidson [duncan@eng.sun.com]
+ * @author James Todd [gonzo@eng.sun.com]
+ */
+
+public class StringManager {
+
+    /**
+     * The ResourceBundle for this StringManager.
+     */
+
+    private ResourceBundle bundle;
+
+    private static org.apache.juli.logging.Log log=
+        org.apache.juli.logging.LogFactory.getLog( StringManager.class );
+
+    /**
+     * Creates a new StringManager for a given package. This is a
+     * private method and all access to it is arbitrated by the
+     * static getManager method call so that only one StringManager
+     * per package will be created.
+     *
+     * @param packageName Name of package to create StringManager for.
+     */
+
+    private StringManager(String packageName) {
+        String bundleName = packageName + ".LocalStrings";
+        try {
+            bundle = ResourceBundle.getBundle(bundleName);
+            return;
+        } catch( MissingResourceException ex ) {
+            // Try from the current loader ( that's the case for trusted apps )
+            ClassLoader cl=Thread.currentThread().getContextClassLoader();
+            if( cl != null ) {
+                try {
+                    bundle=ResourceBundle.getBundle(bundleName, Locale.getDefault(), cl);
+                    return;
+                } catch(MissingResourceException ex2) {
+                }
+            }
+            if( cl==null )
+                cl=this.getClass().getClassLoader();
+
+            if (log.isDebugEnabled())
+                log.debug("Can't find resource " + bundleName +
+                    " " + cl);
+            if( cl instanceof URLClassLoader ) {
+                if (log.isDebugEnabled()) 
+                    log.debug( ((URLClassLoader)cl).getURLs());
+            }
+        }
+    }
+
+    /**
+     * Get a string from the underlying resource bundle.
+     *
+     * @param key The resource name
+     */
+    public String getString(String key) {
+        return MessageFormat.format(getStringInternal(key), (Object [])null);
+    }
+
+
+    protected String getStringInternal(String key) {
+        if (key == null) {
+            String msg = "key is null";
+
+            throw new NullPointerException(msg);
+        }
+
+        String str = null;
+
+        if( bundle==null )
+            return key;
+        try {
+            str = bundle.getString(key);
+        } catch (MissingResourceException mre) {
+            str = "Cannot find message associated with key '" + key + "'";
+        }
+
+        return str;
+    }
+
+    /**
+     * Get a string from the underlying resource bundle and format
+     * it with the given set of arguments.
+     *
+     * @param key The resource name
+     * @param args Formatting directives
+     */
+
+    public String getString(String key, Object[] args) {
+        String iString = null;
+        String value = getStringInternal(key);
+
+        // this check for the runtime exception is some pre 1.1.6
+        // VM's don't do an automatic toString() on the passed in
+        // objects and barf out
+
+        try {
+            // ensure the arguments are not null so pre 1.2 VM's don't barf
+            Object nonNullArgs[] = args;
+            for (int i=0; i<args.length; i++) {
+                if (args[i] == null) {
+                    if (nonNullArgs==args) nonNullArgs=(Object[])args.clone();
+                    nonNullArgs[i] = "null";
+                }
+            }
+
+            iString = MessageFormat.format(value, nonNullArgs);
+        } catch (IllegalArgumentException iae) {
+            StringBuffer buf = new StringBuffer();
+            buf.append(value);
+            for (int i = 0; i < args.length; i++) {
+                buf.append(" arg[" + i + "]=" + args[i]);
+            }
+            iString = buf.toString();
+        }
+        return iString;
+    }
+
+    /**
+     * Get a string from the underlying resource bundle and format it
+     * with the given object argument. This argument can of course be
+     * a String object.
+     *
+     * @param key The resource name
+     * @param arg Formatting directive
+     */
+
+    public String getString(String key, Object arg) {
+        Object[] args = new Object[] {arg};
+        return getString(key, args);
+    }
+
+    /**
+     * Get a string from the underlying resource bundle and format it
+     * with the given object arguments. These arguments can of course
+     * be String objects.
+     *
+     * @param key The resource name
+     * @param arg1 Formatting directive
+     * @param arg2 Formatting directive
+     */
+
+    public String getString(String key, Object arg1, Object arg2) {
+        Object[] args = new Object[] {arg1, arg2};
+        return getString(key, args);
+    }
+
+    /**
+     * Get a string from the underlying resource bundle and format it
+     * with the given object arguments. These arguments can of course
+     * be String objects.
+     *
+     * @param key The resource name
+     * @param arg1 Formatting directive
+     * @param arg2 Formatting directive
+     * @param arg3 Formatting directive
+     */
+
+    public String getString(String key, Object arg1, Object arg2,
+                            Object arg3) {
+        Object[] args = new Object[] {arg1, arg2, arg3};
+        return getString(key, args);
+    }
+
+    /**
+     * Get a string from the underlying resource bundle and format it
+     * with the given object arguments. These arguments can of course
+     * be String objects.
+     *
+     * @param key The resource name
+     * @param arg1 Formatting directive
+     * @param arg2 Formatting directive
+     * @param arg3 Formatting directive
+     * @param arg4 Formatting directive
+     */
+
+    public String getString(String key, Object arg1, Object arg2,
+                            Object arg3, Object arg4) {
+        Object[] args = new Object[] {arg1, arg2, arg3, arg4};
+        return getString(key, args);
+    }
+    // --------------------------------------------------------------
+    // STATIC SUPPORT METHODS
+    // --------------------------------------------------------------
+
+    private static Hashtable managers = new Hashtable();
+
+    /**
+     * Get the StringManager for a particular package. If a manager for
+     * a package already exists, it will be reused, else a new
+     * StringManager will be created and returned.
+     *
+     * @param packageName The package name
+     */
+
+    public synchronized static StringManager getManager(String packageName) {
+        StringManager mgr = (StringManager)managers.get(packageName);
+
+        if (mgr == null) {
+            mgr = new StringManager(packageName);
+            managers.put(packageName, mgr);
+        }
+        return mgr;
+    }
+}

==================================================
AbstractGroup.java
index aa56370d7c..b450d352fd 100644
--- a/java/org/apache/catalina/tribes/util/UUIDGenerator.java
+++ b/java/org/apache/catalina/tribes/util/UUIDGenerator.java
@@ -1,76 +1,77 @@
-/*
- * Copyright 1999,2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.util;
-
-import java.security.SecureRandom;
-import java.util.Random;
-
-/**
- * simple generation of a UUID 
- * @author Filip Hanik
- * @version 1.0
- */
-public class UUIDGenerator {
-    public static final int UUID_LENGTH = 16;
-    public static final int UUID_VERSION = 4;
-    public static final int BYTES_PER_INT = 4;
-    public static final int BITS_PER_BYTE = 8;
-    
-    protected static SecureRandom secrand = null;
-    protected static Random rand = new Random(System.currentTimeMillis());
-    static {
-        secrand = new SecureRandom();
-        secrand.setSeed(rand.nextLong());
-    }
-    
-    public static byte[] randomUUID(boolean secure) {
-        byte[] result = new byte[UUID_LENGTH];
-        return randomUUID(secure,result,0);
-    }
-
-    public static byte[] randomUUID(boolean secure, byte[] into, int offset) {
-        if ( (offset+UUID_LENGTH)>into.length )
-            throw new ArrayIndexOutOfBoundsException("Unable to fit "+UUID_LENGTH+" bytes into the array. length:"+into.length+" required length:"+(offset+UUID_LENGTH));
-        Random r = (secure&&(secrand!=null))?secrand:rand;
-        nextBytes(into,offset,UUID_LENGTH,r);
-        into[6+offset] &= 0x0F;
-        into[6+offset] |= (UUID_VERSION << 4);
-        into[8+offset] &= 0x3F; //0011 1111
-        into[8+offset] |= 0x80; //1000 0000
-        return into;
-    }
-    
-    /**
-     * Same as java.util.Random.nextBytes except this one we dont have to allocate a new byte array
-     * @param into byte[]
-     * @param offset int
-     * @param length int
-     * @param r Random
-     */
-    public static void nextBytes(byte[] into, int offset, int length, Random r) {
-        int numRequested = length;
-        int numGot = 0, rnd = 0;
-        while (true) {
-            for (int i = 0; i < BYTES_PER_INT; i++) {
-                if (numGot == numRequested) return;
-                rnd = (i == 0 ? r.nextInt() : rnd >> BITS_PER_BYTE);
-                into[offset+numGot] = (byte) rnd;
-                numGot++;
-            }
-        }
-    }
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.util;
+
+import java.security.SecureRandom;
+import java.util.Random;
+
+/**
+ * simple generation of a UUID 
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class UUIDGenerator {
+    public static final int UUID_LENGTH = 16;
+    public static final int UUID_VERSION = 4;
+    public static final int BYTES_PER_INT = 4;
+    public static final int BITS_PER_BYTE = 8;
+    
+    protected static SecureRandom secrand = null;
+    protected static Random rand = new Random(System.currentTimeMillis());
+    static {
+        secrand = new SecureRandom();
+        secrand.setSeed(rand.nextLong());
+    }
+    
+    public static byte[] randomUUID(boolean secure) {
+        byte[] result = new byte[UUID_LENGTH];
+        return randomUUID(secure,result,0);
+    }
+
+    public static byte[] randomUUID(boolean secure, byte[] into, int offset) {
+        if ( (offset+UUID_LENGTH)>into.length )
+            throw new ArrayIndexOutOfBoundsException("Unable to fit "+UUID_LENGTH+" bytes into the array. length:"+into.length+" required length:"+(offset+UUID_LENGTH));
+        Random r = (secure&&(secrand!=null))?secrand:rand;
+        nextBytes(into,offset,UUID_LENGTH,r);
+        into[6+offset] &= 0x0F;
+        into[6+offset] |= (UUID_VERSION << 4);
+        into[8+offset] &= 0x3F; //0011 1111
+        into[8+offset] |= 0x80; //1000 0000
+        return into;
+    }
+    
+    /**
+     * Same as java.util.Random.nextBytes except this one we dont have to allocate a new byte array
+     * @param into byte[]
+     * @param offset int
+     * @param length int
+     * @param r Random
+     */
+    public static void nextBytes(byte[] into, int offset, int length, Random r) {
+        int numRequested = length;
+        int numGot = 0, rnd = 0;
+        while (true) {
+            for (int i = 0; i < BYTES_PER_INT; i++) {
+                if (numGot == numRequested) return;
+                rnd = (i == 0 ? r.nextInt() : rnd >> BITS_PER_BYTE);
+                into[offset+numGot] = (byte) rnd;
+                numGot++;
+            }
+        }
+    }
+
 }
\ No newline at end of file

==================================================
AbstractRole.java
index fbf6911bf8..1831c27ed9 100644
--- a/java/org/apache/catalina/users/AbstractGroup.java
+++ b/java/org/apache/catalina/users/AbstractGroup.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
AbstractUser.java
index c0ef28a1ae..e950dbddad 100644
--- a/java/org/apache/catalina/users/AbstractRole.java
+++ b/java/org/apache/catalina/users/AbstractRole.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Constants.java
index 9ca56a1e11..2665ff5121 100644
--- a/java/org/apache/catalina/users/AbstractUser.java
+++ b/java/org/apache/catalina/users/AbstractUser.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
MemoryGroup.java
index 157f1ea144..9cd49eb806 100644
--- a/java/org/apache/catalina/users/Constants.java
+++ b/java/org/apache/catalina/users/Constants.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
MemoryRole.java
index 74eca4a6ac..4e1a6389c1 100644
--- a/java/org/apache/catalina/users/MemoryGroup.java
+++ b/java/org/apache/catalina/users/MemoryGroup.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
MemoryUser.java
index a68670bdcc..f0f91c6c21 100644
--- a/java/org/apache/catalina/users/MemoryRole.java
+++ b/java/org/apache/catalina/users/MemoryRole.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
MemoryUserDatabase.java
index 859bca2b30..e7a413994a 100644
--- a/java/org/apache/catalina/users/MemoryUser.java
+++ b/java/org/apache/catalina/users/MemoryUser.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
MemoryUserDatabaseFactory.java
index ead544cd63..d4f26ba261 100644
--- a/java/org/apache/catalina/users/MemoryUserDatabase.java
+++ b/java/org/apache/catalina/users/MemoryUserDatabase.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Base64.java
index f23c1d4478..6a1906da00 100644
--- a/java/org/apache/catalina/users/MemoryUserDatabaseFactory.java
+++ b/java/org/apache/catalina/users/MemoryUserDatabaseFactory.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
CharsetMapper.java
index 93c410e388..c01bded7d6 100644
--- a/java/org/apache/catalina/util/Base64.java
+++ b/java/org/apache/catalina/util/Base64.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
CookieTools.java
index eb430068bd..f52395bc73 100644
--- a/java/org/apache/catalina/util/CharsetMapper.java
+++ b/java/org/apache/catalina/util/CharsetMapper.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
CustomObjectInputStream.java
index 5298d6dd1a..dc834114c0 100644
--- a/java/org/apache/catalina/util/CookieTools.java
+++ b/java/org/apache/catalina/util/CookieTools.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
DOMWriter.java
index eec386d06f..3547775caa 100644
--- a/java/org/apache/catalina/util/CustomObjectInputStream.java
+++ b/java/org/apache/catalina/util/CustomObjectInputStream.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
DateTool.java
index d350356afe..0d68481d2e 100644
--- a/java/org/apache/catalina/util/DOMWriter.java
+++ b/java/org/apache/catalina/util/DOMWriter.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
DefaultAnnotationProcessor.java
index b5b8487fef..f8b3df84ee 100644
--- a/java/org/apache/catalina/util/DateTool.java
+++ b/java/org/apache/catalina/util/DateTool.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Enumerator.java
index 001e7587e5..be2ee92043 100644
--- a/java/org/apache/catalina/util/DefaultAnnotationProcessor.java
+++ b/java/org/apache/catalina/util/DefaultAnnotationProcessor.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Extension.java
index 96aa680102..09441036e9 100644
--- a/java/org/apache/catalina/util/Enumerator.java
+++ b/java/org/apache/catalina/util/Enumerator.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ExtensionValidator.java
index 142bd5b1c8..18960bb799 100644
--- a/java/org/apache/catalina/util/Extension.java
+++ b/java/org/apache/catalina/util/Extension.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
FastDateFormat.java
index 4b01cc787a..f58318a904 100644
--- a/java/org/apache/catalina/util/ExtensionValidator.java
+++ b/java/org/apache/catalina/util/ExtensionValidator.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
HexUtils.java
index f2a2c5ce6f..3384af154b 100644
--- a/java/org/apache/catalina/util/FastDateFormat.java
+++ b/java/org/apache/catalina/util/FastDateFormat.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
IOTools.java
index a3d920f5e3..685e63babe 100644
--- a/java/org/apache/catalina/util/HexUtils.java
+++ b/java/org/apache/catalina/util/HexUtils.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
InstanceSupport.java
index 5d303f6918..23f1dbc1ab 100644
--- a/java/org/apache/catalina/util/IOTools.java
+++ b/java/org/apache/catalina/util/IOTools.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
LifecycleSupport.java
index b6a11ab0c9..6f824421a2 100644
--- a/java/org/apache/catalina/util/InstanceSupport.java
+++ b/java/org/apache/catalina/util/InstanceSupport.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
MD5Encoder.java
index f8a65f07a8..32dd06033b 100644
--- a/java/org/apache/catalina/util/LifecycleSupport.java
+++ b/java/org/apache/catalina/util/LifecycleSupport.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
MIME2Java.java
index f33b910dc0..5e1f1c982b 100644
--- a/java/org/apache/catalina/util/MD5Encoder.java
+++ b/java/org/apache/catalina/util/MD5Encoder.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ManifestResource.java
index e9bc122830..45eff4d41c 100644
--- a/java/org/apache/catalina/util/MIME2Java.java
+++ b/java/org/apache/catalina/util/MIME2Java.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ParameterMap.java
index 6ae22d0e9a..6bef95d4f9 100644
--- a/java/org/apache/catalina/util/ManifestResource.java
+++ b/java/org/apache/catalina/util/ManifestResource.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Queue.java
index 4d855b86ea..50836f7e64 100644
--- a/java/org/apache/catalina/util/ParameterMap.java
+++ b/java/org/apache/catalina/util/ParameterMap.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
RequestUtil.java
index fc4320acfb..9f69c60f61 100644
--- a/java/org/apache/catalina/util/Queue.java
+++ b/java/org/apache/catalina/util/Queue.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ResourceSet.java
index 3a91c087e1..a29adc4735 100644
--- a/java/org/apache/catalina/util/RequestUtil.java
+++ b/java/org/apache/catalina/util/RequestUtil.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SchemaResolver.java
index 1f1dcdcc62..4187aceb15 100644
--- a/java/org/apache/catalina/util/ResourceSet.java
+++ b/java/org/apache/catalina/util/ResourceSet.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ServerInfo.java
index 1a66de3200..e0a18781f2 100644
--- a/java/org/apache/catalina/util/SchemaResolver.java
+++ b/java/org/apache/catalina/util/SchemaResolver.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Strftime.java
index 71b4d7e1ce..52d4ebd02d 100644
--- a/java/org/apache/catalina/util/ServerInfo.java
+++ b/java/org/apache/catalina/util/ServerInfo.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
StringManager.java
index fc0579512e..37990625ac 100644
--- a/java/org/apache/catalina/util/Strftime.java
+++ b/java/org/apache/catalina/util/Strftime.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
StringParser.java
index c5d10d3129..b7fbb9133f 100644
--- a/java/org/apache/catalina/util/StringManager.java
+++ b/java/org/apache/catalina/util/StringManager.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
TomcatCSS.java
index 0a541f2e5b..8f2f6d9682 100644
--- a/java/org/apache/catalina/util/StringParser.java
+++ b/java/org/apache/catalina/util/StringParser.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
URL.java
index 7d66b19ccf..354878eee2 100644
--- a/java/org/apache/catalina/util/TomcatCSS.java
+++ b/java/org/apache/catalina/util/TomcatCSS.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
URLEncoder.java
index 1cf77ce393..5159ace866 100644
--- a/java/org/apache/catalina/util/URL.java
+++ b/java/org/apache/catalina/util/URL.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
XMLWriter.java
index 8d23dbf112..74426ebad1 100644
--- a/java/org/apache/catalina/util/URLEncoder.java
+++ b/java/org/apache/catalina/util/URLEncoder.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
AccessLogValve.java
index f1a71a6afe..cf3134095a 100644
--- a/java/org/apache/catalina/util/XMLWriter.java
+++ b/java/org/apache/catalina/util/XMLWriter.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
CometConnectionManagerValve.java
index c0d80959b2..08008bdf6e 100644
--- a/java/org/apache/catalina/valves/AccessLogValve.java
+++ b/java/org/apache/catalina/valves/AccessLogValve.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Constants.java
index 971439eec8..59d6716e2f 100644
--- a/java/org/apache/catalina/valves/CometConnectionManagerValve.java
+++ b/java/org/apache/catalina/valves/CometConnectionManagerValve.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2005-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ErrorReportValve.java
index 0864325460..90ef58236c 100644
--- a/java/org/apache/catalina/valves/Constants.java
+++ b/java/org/apache/catalina/valves/Constants.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ExtendedAccessLogValve.java
index e6897a26f0..6775e1d7d2 100644
--- a/java/org/apache/catalina/valves/ErrorReportValve.java
+++ b/java/org/apache/catalina/valves/ErrorReportValve.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
FastCommonAccessLogValve.java
index fd07af27ce..9388cd2a0a 100644
--- a/java/org/apache/catalina/valves/ExtendedAccessLogValve.java
+++ b/java/org/apache/catalina/valves/ExtendedAccessLogValve.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
JDBCAccessLogValve.java
index 606f77b403..3d151dabad 100644
--- a/java/org/apache/catalina/valves/FastCommonAccessLogValve.java
+++ b/java/org/apache/catalina/valves/FastCommonAccessLogValve.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
PersistentValve.java
index 7c96d20d41..b39ea1c1b2 100644
--- a/java/org/apache/catalina/valves/JDBCAccessLogValve.java
+++ b/java/org/apache/catalina/valves/JDBCAccessLogValve.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
RemoteAddrValve.java
index 8aabed2850..f3c9a7e828 100644
--- a/java/org/apache/catalina/valves/PersistentValve.java
+++ b/java/org/apache/catalina/valves/PersistentValve.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
RemoteHostValve.java
index e14a54507c..41893e9b91 100644
--- a/java/org/apache/catalina/valves/RemoteAddrValve.java
+++ b/java/org/apache/catalina/valves/RemoteAddrValve.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
RequestDumperValve.java
index 80d439d56e..ca4d7945f5 100644
--- a/java/org/apache/catalina/valves/RemoteHostValve.java
+++ b/java/org/apache/catalina/valves/RemoteHostValve.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
RequestFilterValve.java
index d1f596866e..1097ade37d 100644
--- a/java/org/apache/catalina/valves/RequestDumperValve.java
+++ b/java/org/apache/catalina/valves/RequestDumperValve.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SemaphoreValve.java
index f2417d150b..8a4004809b 100644
--- a/java/org/apache/catalina/valves/RequestFilterValve.java
+++ b/java/org/apache/catalina/valves/RequestFilterValve.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ValveBase.java
index 3c54502cf4..e8d4009604 100644
--- a/java/org/apache/catalina/valves/SemaphoreValve.java
+++ b/java/org/apache/catalina/valves/SemaphoreValve.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ActionCode.java
index 79762c8d0d..2009853ed4 100644
--- a/java/org/apache/catalina/valves/ValveBase.java
+++ b/java/org/apache/catalina/valves/ValveBase.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ActionHook.java
index e9f51338ab..41a000d958 100644
--- a/java/org/apache/coyote/ActionCode.java
+++ b/java/org/apache/coyote/ActionCode.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Adapter.java
index bc3c6dc887..72154947af 100644
--- a/java/org/apache/coyote/ActionHook.java
+++ b/java/org/apache/coyote/ActionHook.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Constants.java
index c5de355d39..420be0283b 100644
--- a/java/org/apache/coyote/Adapter.java
+++ b/java/org/apache/coyote/Adapter.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
InputBuffer.java
index 9a7715e03c..6f7e9707f4 100644
--- a/java/org/apache/coyote/Constants.java
+++ b/java/org/apache/coyote/Constants.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
OutputBuffer.java
index acc590c878..56e1eccdd0 100644
--- a/java/org/apache/coyote/InputBuffer.java
+++ b/java/org/apache/coyote/InputBuffer.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Processor.java
index 1e2fa66b84..4f6c647510 100644
--- a/java/org/apache/coyote/OutputBuffer.java
+++ b/java/org/apache/coyote/OutputBuffer.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
ProtocolHandler.java
index 19d3051c97..9258f57a9d 100644
--- a/java/org/apache/coyote/Processor.java
+++ b/java/org/apache/coyote/Processor.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Request.java
index 121cd5372c..0e81135995 100644
--- a/java/org/apache/coyote/ProtocolHandler.java
+++ b/java/org/apache/coyote/ProtocolHandler.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
RequestGroupInfo.java
index f4f3c4ca76..21562754c6 100644
--- a/java/org/apache/coyote/Request.java
+++ b/java/org/apache/coyote/Request.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
RequestInfo.java
index b8810b6da9..41fa3fefcb 100644
--- a/java/org/apache/coyote/RequestGroupInfo.java
+++ b/java/org/apache/coyote/RequestGroupInfo.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Response.java
index 5728842d12..94cbf51240 100644
--- a/java/org/apache/coyote/RequestInfo.java
+++ b/java/org/apache/coyote/RequestInfo.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
AjpAprProcessor.java
index 267720a1c4..dd3e3b9580 100644
--- a/java/org/apache/coyote/Response.java
+++ b/java/org/apache/coyote/Response.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
AjpAprProtocol.java
index 21ea657eda..c684ef9749 100644
--- a/java/org/apache/coyote/ajp/AjpAprProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpAprProcessor.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
AjpMessage.java
index 48c47771b3..75e7d4b538 100644
--- a/java/org/apache/coyote/ajp/AjpAprProtocol.java
+++ b/java/org/apache/coyote/ajp/AjpAprProtocol.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
AjpProcessor.java
index 7b3bfd22bb..4b4318117b 100644
--- a/java/org/apache/coyote/ajp/AjpMessage.java
+++ b/java/org/apache/coyote/ajp/AjpMessage.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
AjpProtocol.java
index 5d2a672746..487e2aa633 100644
--- a/java/org/apache/coyote/ajp/AjpProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpProcessor.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Constants.java
index bbb28318df..03a5bb89d3 100644
--- a/java/org/apache/coyote/ajp/AjpProtocol.java
+++ b/java/org/apache/coyote/ajp/AjpProtocol.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Constants.java
index 077ee372a2..73489b2814 100644
--- a/java/org/apache/coyote/ajp/Constants.java
+++ b/java/org/apache/coyote/ajp/Constants.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Http11AprProcessor.java
index 46dde8332c..ff07a60d10 100644
--- a/java/org/apache/coyote/http11/Constants.java
+++ b/java/org/apache/coyote/http11/Constants.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Http11AprProtocol.java
index 3469bb3d2c..1227718f30 100644
--- a/java/org/apache/coyote/http11/Http11AprProcessor.java
+++ b/java/org/apache/coyote/http11/Http11AprProcessor.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Http11NioProcessor.java
index 1975807c2f..bcfefce293 100644
--- a/java/org/apache/coyote/http11/Http11AprProtocol.java
+++ b/java/org/apache/coyote/http11/Http11AprProtocol.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Http11NioProtocol.java
index e87f5f46c1..b753e60921 100644
--- a/java/org/apache/coyote/http11/Http11NioProcessor.java
+++ b/java/org/apache/coyote/http11/Http11NioProcessor.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Http11Processor.java
index 0804a68634..b8d610356a 100644
--- a/java/org/apache/coyote/http11/Http11NioProtocol.java
+++ b/java/org/apache/coyote/http11/Http11NioProtocol.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Http11Protocol.java
index f90212be4a..22ca60ddab 100644
--- a/java/org/apache/coyote/http11/Http11Processor.java
+++ b/java/org/apache/coyote/http11/Http11Processor.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2006 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
InputFilter.java
index 7cebed4727..a9dcaa5d90 100644
--- a/java/org/apache/coyote/http11/Http11Protocol.java
+++ b/java/org/apache/coyote/http11/Http11Protocol.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2006 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
InternalAprInputBuffer.java
index a734c6047e..661290fd80 100644
--- a/java/org/apache/coyote/http11/InputFilter.java
+++ b/java/org/apache/coyote/http11/InputFilter.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
InternalAprOutputBuffer.java
index 74de37ceeb..b4ff05674f 100644
--- a/java/org/apache/coyote/http11/InternalAprInputBuffer.java
+++ b/java/org/apache/coyote/http11/InternalAprInputBuffer.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
InternalInputBuffer.java
index 518db74c92..b217578b49 100644
--- a/java/org/apache/coyote/http11/InternalAprOutputBuffer.java
+++ b/java/org/apache/coyote/http11/InternalAprOutputBuffer.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
InternalNioInputBuffer.java
index a4a41d30d4..67a9ca7d0d 100644
--- a/java/org/apache/coyote/http11/InternalInputBuffer.java
+++ b/java/org/apache/coyote/http11/InternalInputBuffer.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
InternalNioOutputBuffer.java
index 43da6c71ae..43019e92f8 100644
--- a/java/org/apache/coyote/http11/InternalNioInputBuffer.java
+++ b/java/org/apache/coyote/http11/InternalNioInputBuffer.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
InternalOutputBuffer.java
index 9b2ee1ffa4..b3c3ae70f4 100644
--- a/java/org/apache/coyote/http11/InternalNioOutputBuffer.java
+++ b/java/org/apache/coyote/http11/InternalNioOutputBuffer.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
OutputFilter.java
index 0c5073934c..4acce12a59 100644
--- a/java/org/apache/coyote/http11/InternalOutputBuffer.java
+++ b/java/org/apache/coyote/http11/InternalOutputBuffer.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
BufferedInputFilter.java
index bd073c5238..c4efb61ce8 100644
--- a/java/org/apache/coyote/http11/OutputFilter.java
+++ b/java/org/apache/coyote/http11/OutputFilter.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
ChunkedInputFilter.java
index 411cd53c6b..768eebbb54 100644
--- a/java/org/apache/coyote/http11/filters/BufferedInputFilter.java
+++ b/java/org/apache/coyote/http11/filters/BufferedInputFilter.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
ChunkedOutputFilter.java
index fbc0050a99..01eba2b07d 100644
--- a/java/org/apache/coyote/http11/filters/ChunkedInputFilter.java
+++ b/java/org/apache/coyote/http11/filters/ChunkedInputFilter.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
GzipOutputFilter.java
index 9b01e3bc8a..526c5a75bc 100644
--- a/java/org/apache/coyote/http11/filters/ChunkedOutputFilter.java
+++ b/java/org/apache/coyote/http11/filters/ChunkedOutputFilter.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
IdentityInputFilter.java
index dbd19d74a5..f430b08c7f 100644
--- a/java/org/apache/coyote/http11/filters/GzipOutputFilter.java
+++ b/java/org/apache/coyote/http11/filters/GzipOutputFilter.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
IdentityOutputFilter.java
index 2545fbc9c5..332ac150d0 100644
--- a/java/org/apache/coyote/http11/filters/IdentityInputFilter.java
+++ b/java/org/apache/coyote/http11/filters/IdentityInputFilter.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
SavedRequestInputFilter.java
index 2f09598ee6..6366201c2b 100644
--- a/java/org/apache/coyote/http11/filters/IdentityOutputFilter.java
+++ b/java/org/apache/coyote/http11/filters/IdentityOutputFilter.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
VoidInputFilter.java
index 3b1517d461..b49fbe5f9a 100644
--- a/java/org/apache/coyote/http11/filters/SavedRequestInputFilter.java
+++ b/java/org/apache/coyote/http11/filters/SavedRequestInputFilter.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
VoidOutputFilter.java
index e8551b03e0..1b527e4531 100644
--- a/java/org/apache/coyote/http11/filters/VoidInputFilter.java
+++ b/java/org/apache/coyote/http11/filters/VoidInputFilter.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
MemoryProtocolHandler.java
index efe6fafe5a..72569c5988 100644
--- a/java/org/apache/coyote/http11/filters/VoidOutputFilter.java
+++ b/java/org/apache/coyote/http11/filters/VoidOutputFilter.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
ExpressionFactoryImpl.java
index 7d399c97da..bbb8fe9104 100644
--- a/java/org/apache/coyote/memory/MemoryProtocolHandler.java
+++ b/java/org/apache/coyote/memory/MemoryProtocolHandler.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
MethodExpressionImpl.java
index 108375e8f2..8b30e9289e 100644
--- a/java/org/apache/el/ExpressionFactoryImpl.java
+++ b/java/org/apache/el/ExpressionFactoryImpl.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
MethodExpressionLiteral.java
index bb7eadf5c7..338139002d 100644
--- a/java/org/apache/el/MethodExpressionImpl.java
+++ b/java/org/apache/el/MethodExpressionImpl.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ValueExpressionImpl.java
index 5cdafad492..652a3e823d 100644
--- a/java/org/apache/el/MethodExpressionLiteral.java
+++ b/java/org/apache/el/MethodExpressionLiteral.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ValueExpressionLiteral.java
index 807e4e0daa..31f38d1248 100644
--- a/java/org/apache/el/ValueExpressionImpl.java
+++ b/java/org/apache/el/ValueExpressionImpl.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ELArithmetic.java
index 1557e4338d..2221b88669 100644
--- a/java/org/apache/el/ValueExpressionLiteral.java
+++ b/java/org/apache/el/ValueExpressionLiteral.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ELSupport.java
index 94ceaddb86..c248f75e7e 100644
--- a/java/org/apache/el/lang/ELArithmetic.java
+++ b/java/org/apache/el/lang/ELArithmetic.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
EvaluationContext.java
index 9ec8e6d419..793ce2a331 100644
--- a/java/org/apache/el/lang/ELSupport.java
+++ b/java/org/apache/el/lang/ELSupport.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ExpressionBuilder.java
index eeb93e9dd8..721cc49de1 100644
--- a/java/org/apache/el/lang/EvaluationContext.java
+++ b/java/org/apache/el/lang/EvaluationContext.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
FunctionMapperFactory.java
index 4e1b44ff3b..994bf26081 100644
--- a/java/org/apache/el/lang/ExpressionBuilder.java
+++ b/java/org/apache/el/lang/ExpressionBuilder.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
FunctionMapperImpl.java
index 0c47dd4597..7745cee8be 100644
--- a/java/org/apache/el/lang/FunctionMapperFactory.java
+++ b/java/org/apache/el/lang/FunctionMapperFactory.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
VariableMapperFactory.java
index dc02e28f20..012ffd4f58 100644
--- a/java/org/apache/el/lang/FunctionMapperImpl.java
+++ b/java/org/apache/el/lang/FunctionMapperImpl.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
VariableMapperImpl.java
index f74f4e7d56..30c386e904 100644
--- a/java/org/apache/el/lang/VariableMapperFactory.java
+++ b/java/org/apache/el/lang/VariableMapperFactory.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ArithmeticNode.java
index c1cf437061..effad41cda 100644
--- a/java/org/apache/el/lang/VariableMapperImpl.java
+++ b/java/org/apache/el/lang/VariableMapperImpl.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
BooleanNode.java
index e831ee72f6..2e8694e442 100644
--- a/java/org/apache/el/parser/ArithmeticNode.java
+++ b/java/org/apache/el/parser/ArithmeticNode.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Node.java
index 649a018ce6..ae6fe61695 100644
--- a/java/org/apache/el/parser/ELParser.jjt
+++ b/java/org/apache/el/parser/ELParser.jjt
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
NodeVisitor.java
index 008d6880e6..b72814b1f0 100644
--- a/java/org/apache/el/parser/Node.java
+++ b/java/org/apache/el/parser/Node.java
@@ -1,11 +1,12 @@
 /* Generated By:JJTree: Do not edit this line. Node.java */
 
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
MessageFactory.java
index 5ce72ee767..405883626d 100644
--- a/java/org/apache/el/parser/NodeVisitor.java
+++ b/java/org/apache/el/parser/NodeVisitor.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ReflectionUtil.java
index 27c249e7d0..cca3ede351 100644
--- a/java/org/apache/el/util/MessageFactory.java
+++ b/java/org/apache/el/util/MessageFactory.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Constants.java
index b825f418b3..ead44f450d 100644
--- a/java/org/apache/el/util/ReflectionUtil.java
+++ b/java/org/apache/el/util/ReflectionUtil.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
EmbeddedServletOptions.java
index 80dc69085a..dff908bf10 100644
--- a/java/org/apache/jasper/Constants.java
+++ b/java/org/apache/jasper/Constants.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JasperException.java
index e4f2da1fc3..b6a1c4c775 100644
--- a/java/org/apache/jasper/EmbeddedServletOptions.java
+++ b/java/org/apache/jasper/EmbeddedServletOptions.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JspC.java
index 3135a51177..cc06a2bf21 100644
--- a/java/org/apache/jasper/JasperException.java
+++ b/java/org/apache/jasper/JasperException.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JspCompilationContext.java
index 1a22a240df..a4d74c7eaa 100644
--- a/java/org/apache/jasper/JspC.java
+++ b/java/org/apache/jasper/JspC.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Options.java
index 49ec375004..3409040a9f 100644
--- a/java/org/apache/jasper/JspCompilationContext.java
+++ b/java/org/apache/jasper/JspCompilationContext.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
AntCompiler.java
index 30437685e1..3148255cbc 100644
--- a/java/org/apache/jasper/Options.java
+++ b/java/org/apache/jasper/Options.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
BeanRepository.java
index 4d60fcce72..d490b40bcd 100644
--- a/java/org/apache/jasper/compiler/AntCompiler.java
+++ b/java/org/apache/jasper/compiler/AntCompiler.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Collector.java
index 8fcc21d1d2..cd32b7fa43 100644
--- a/java/org/apache/jasper/compiler/BeanRepository.java
+++ b/java/org/apache/jasper/compiler/BeanRepository.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Compiler.java
index 3f720c8541..50b2b9de43 100644
--- a/java/org/apache/jasper/compiler/Collector.java
+++ b/java/org/apache/jasper/compiler/Collector.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
DefaultErrorHandler.java
index 66cd1e61ba..fbe95a051c 100644
--- a/java/org/apache/jasper/compiler/Compiler.java
+++ b/java/org/apache/jasper/compiler/Compiler.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Dumper.java
index c1b47b5519..761b6b6f34 100644
--- a/java/org/apache/jasper/compiler/DefaultErrorHandler.java
+++ b/java/org/apache/jasper/compiler/DefaultErrorHandler.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ELFunctionMapper.java
index ac4ad7f3b1..1925f55d37 100644
--- a/java/org/apache/jasper/compiler/Dumper.java
+++ b/java/org/apache/jasper/compiler/Dumper.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ELNode.java
index 173adb0c99..6c57efc43f 100644
--- a/java/org/apache/jasper/compiler/ELFunctionMapper.java
+++ b/java/org/apache/jasper/compiler/ELFunctionMapper.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ELParser.java
index 97fdc106e0..84399fa3b9 100644
--- a/java/org/apache/jasper/compiler/ELNode.java
+++ b/java/org/apache/jasper/compiler/ELNode.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ErrorDispatcher.java
index 7f148e3075..c93d9adf4c 100644
--- a/java/org/apache/jasper/compiler/ELParser.java
+++ b/java/org/apache/jasper/compiler/ELParser.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ErrorHandler.java
index 6a1015b9b5..b484ccb397 100644
--- a/java/org/apache/jasper/compiler/ErrorDispatcher.java
+++ b/java/org/apache/jasper/compiler/ErrorDispatcher.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Generator.java
index 212d442795..a998edaf07 100644
--- a/java/org/apache/jasper/compiler/ErrorHandler.java
+++ b/java/org/apache/jasper/compiler/ErrorHandler.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ImplicitTagLibraryInfo.java
index 0feeda120f..10fccf1fb1 100644
--- a/java/org/apache/jasper/compiler/Generator.java
+++ b/java/org/apache/jasper/compiler/Generator.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
JDTCompiler.java
index 31c61048ae..6a59a246a0 100644
--- a/java/org/apache/jasper/compiler/ImplicitTagLibraryInfo.java
+++ b/java/org/apache/jasper/compiler/ImplicitTagLibraryInfo.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JasperTagInfo.java
index ce5f0ff961..4e43207482 100644
--- a/java/org/apache/jasper/compiler/JDTCompiler.java
+++ b/java/org/apache/jasper/compiler/JDTCompiler.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JavacErrorDetail.java
index 6a671526c4..8586d5e603 100644
--- a/java/org/apache/jasper/compiler/JasperTagInfo.java
+++ b/java/org/apache/jasper/compiler/JasperTagInfo.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JspConfig.java
index bc7bef3884..26e5427014 100644
--- a/java/org/apache/jasper/compiler/JavacErrorDetail.java
+++ b/java/org/apache/jasper/compiler/JavacErrorDetail.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JspDocumentParser.java
index e501ebc4b8..36ca2b68d3 100644
--- a/java/org/apache/jasper/compiler/JspConfig.java
+++ b/java/org/apache/jasper/compiler/JspConfig.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JspReader.java
index 26bec82301..5715b7f4d7 100644
--- a/java/org/apache/jasper/compiler/JspDocumentParser.java
+++ b/java/org/apache/jasper/compiler/JspDocumentParser.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JspRuntimeContext.java
index cb42855792..4df569f91c 100644
--- a/java/org/apache/jasper/compiler/JspReader.java
+++ b/java/org/apache/jasper/compiler/JspReader.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JspUtil.java
index 4d6a08083c..a90e3a715f 100644
--- a/java/org/apache/jasper/compiler/JspRuntimeContext.java
+++ b/java/org/apache/jasper/compiler/JspRuntimeContext.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Localizer.java
index 83d0da08bd..e1d5471a4f 100644
--- a/java/org/apache/jasper/compiler/JspUtil.java
+++ b/java/org/apache/jasper/compiler/JspUtil.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Mark.java
index 3645561b78..260ac51be4 100644
--- a/java/org/apache/jasper/compiler/Localizer.java
+++ b/java/org/apache/jasper/compiler/Localizer.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Node.java
index 81ea18671a..85c942bfe5 100644
--- a/java/org/apache/jasper/compiler/Mark.java
+++ b/java/org/apache/jasper/compiler/Mark.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
PageDataImpl.java
index 5ece8562ef..f80a271e05 100644
--- a/java/org/apache/jasper/compiler/Node.java
+++ b/java/org/apache/jasper/compiler/Node.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
PageInfo.java
index af51b03123..deb4adfe26 100644
--- a/java/org/apache/jasper/compiler/PageDataImpl.java
+++ b/java/org/apache/jasper/compiler/PageDataImpl.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Parser.java
index 3d78db18ff..5a016fc395 100644
--- a/java/org/apache/jasper/compiler/PageInfo.java
+++ b/java/org/apache/jasper/compiler/PageInfo.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
ParserController.java
index fb4d88207c..3afb49fbb2 100644
--- a/java/org/apache/jasper/compiler/Parser.java
+++ b/java/org/apache/jasper/compiler/Parser.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ScriptingVariabler.java
index 1795225d54..ecec053656 100644
--- a/java/org/apache/jasper/compiler/ParserController.java
+++ b/java/org/apache/jasper/compiler/ParserController.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ServletWriter.java
index 5c91dbfa15..7110356c94 100644
--- a/java/org/apache/jasper/compiler/ScriptingVariabler.java
+++ b/java/org/apache/jasper/compiler/ScriptingVariabler.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SmapGenerator.java
index 7e37dbaa7f..a407f77db4 100644
--- a/java/org/apache/jasper/compiler/ServletWriter.java
+++ b/java/org/apache/jasper/compiler/ServletWriter.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SmapStratum.java
index 217b67e4bc..67374478c7 100644
--- a/java/org/apache/jasper/compiler/SmapGenerator.java
+++ b/java/org/apache/jasper/compiler/SmapGenerator.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SmapUtil.java
index 91f9d33a02..d0c506e1aa 100644
--- a/java/org/apache/jasper/compiler/SmapStratum.java
+++ b/java/org/apache/jasper/compiler/SmapStratum.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
TagConstants.java
index 789d58e4b3..c9e08ec088 100644
--- a/java/org/apache/jasper/compiler/SmapUtil.java
+++ b/java/org/apache/jasper/compiler/SmapUtil.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
TagFileProcessor.java
index ce118af2b4..373eb0e9de 100644
--- a/java/org/apache/jasper/compiler/TagConstants.java
+++ b/java/org/apache/jasper/compiler/TagConstants.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
TagLibraryInfoImpl.java
index 8d06640ff2..86f83c81a9 100644
--- a/java/org/apache/jasper/compiler/TagFileProcessor.java
+++ b/java/org/apache/jasper/compiler/TagFileProcessor.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
TagPluginManager.java
index e4f91af7ee..a2782e3688 100644
--- a/java/org/apache/jasper/compiler/TagLibraryInfoImpl.java
+++ b/java/org/apache/jasper/compiler/TagLibraryInfoImpl.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
TextOptimizer.java
index a918f00524..e72f9b3350 100644
--- a/java/org/apache/jasper/compiler/TagPluginManager.java
+++ b/java/org/apache/jasper/compiler/TagPluginManager.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
TldLocationsCache.java
index e4f209c90e..a53866ea39 100644
--- a/java/org/apache/jasper/compiler/TextOptimizer.java
+++ b/java/org/apache/jasper/compiler/TextOptimizer.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Validator.java
index e3b86e2048..b75a892ef4 100644
--- a/java/org/apache/jasper/compiler/TldLocationsCache.java
+++ b/java/org/apache/jasper/compiler/TldLocationsCache.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
TagPlugin.java
index 54095a6a20..15f3b3596c 100644
--- a/java/org/apache/jasper/compiler/Validator.java
+++ b/java/org/apache/jasper/compiler/Validator.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
TagPluginContext.java
index 34af677ed6..49cbc7c0f5 100644
--- a/java/org/apache/jasper/compiler/tagplugin/TagPlugin.java
+++ b/java/org/apache/jasper/compiler/tagplugin/TagPlugin.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ELContextImpl.java
index 40490deff1..8d1c558d1e 100644
--- a/java/org/apache/jasper/compiler/tagplugin/TagPluginContext.java
+++ b/java/org/apache/jasper/compiler/tagplugin/TagPluginContext.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ELContextWrapper.java
index 56b8786c12..34e550c893 100644
--- a/java/org/apache/jasper/el/ELContextImpl.java
+++ b/java/org/apache/jasper/el/ELContextImpl.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ELResolverImpl.java
index 7accf49873..a0754c3ef3 100644
--- a/java/org/apache/jasper/el/ELContextWrapper.java
+++ b/java/org/apache/jasper/el/ELContextWrapper.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ExpressionEvaluatorImpl.java
index d230503f9e..0c1309502c 100644
--- a/java/org/apache/jasper/el/ELResolverImpl.java
+++ b/java/org/apache/jasper/el/ELResolverImpl.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ExpressionImpl.java
index 4b37e7d761..21dbefce34 100644
--- a/java/org/apache/jasper/el/ExpressionEvaluatorImpl.java
+++ b/java/org/apache/jasper/el/ExpressionEvaluatorImpl.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
FunctionMapperImpl.java
index 5b4cef1fd7..3def627f5b 100644
--- a/java/org/apache/jasper/el/ExpressionImpl.java
+++ b/java/org/apache/jasper/el/ExpressionImpl.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JspELException.java
index 3ff29eb94d..0cf84ecde0 100644
--- a/java/org/apache/jasper/el/FunctionMapperImpl.java
+++ b/java/org/apache/jasper/el/FunctionMapperImpl.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JspMethodExpression.java
index dcd1c73534..c9cf3022f6 100644
--- a/java/org/apache/jasper/el/JspELException.java
+++ b/java/org/apache/jasper/el/JspELException.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JspMethodNotFoundException.java
index 5589b9b64a..b48e003429 100644
--- a/java/org/apache/jasper/el/JspMethodExpression.java
+++ b/java/org/apache/jasper/el/JspMethodExpression.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JspPropertyNotFoundException.java
index cc7b9099ca..abb9d30ffa 100644
--- a/java/org/apache/jasper/el/JspMethodNotFoundException.java
+++ b/java/org/apache/jasper/el/JspMethodNotFoundException.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JspPropertyNotWritableException.java
index 3dcca4f095..89ac40b4a9 100644
--- a/java/org/apache/jasper/el/JspPropertyNotFoundException.java
+++ b/java/org/apache/jasper/el/JspPropertyNotFoundException.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JspValueExpression.java
index b8bda22132..70507a4a59 100644
--- a/java/org/apache/jasper/el/JspPropertyNotWritableException.java
+++ b/java/org/apache/jasper/el/JspPropertyNotWritableException.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
VariableResolverImpl.java
index 7f6b80fec4..d8c32a0724 100644
--- a/java/org/apache/jasper/el/JspValueExpression.java
+++ b/java/org/apache/jasper/el/JspValueExpression.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
AnnotationHelper.java
index 81b0f8befa..7808e0f5ed 100644
--- a/java/org/apache/jasper/el/VariableResolverImpl.java
+++ b/java/org/apache/jasper/el/VariableResolverImpl.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
BodyContentImpl.java
index 286a994940..63b47617e7 100644
--- a/java/org/apache/jasper/runtime/AnnotationHelper.java
+++ b/java/org/apache/jasper/runtime/AnnotationHelper.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
HttpJspBase.java
index ee7633b6a2..2a3a48f91d 100644
--- a/java/org/apache/jasper/runtime/BodyContentImpl.java
+++ b/java/org/apache/jasper/runtime/BodyContentImpl.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JspApplicationContextImpl.java
index ce9803c1cf..ac03096c7b 100644
--- a/java/org/apache/jasper/runtime/HttpJspBase.java
+++ b/java/org/apache/jasper/runtime/HttpJspBase.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JspContextWrapper.java
index 86e582cd7d..1ea649aa62 100644
--- a/java/org/apache/jasper/runtime/JspApplicationContextImpl.java
+++ b/java/org/apache/jasper/runtime/JspApplicationContextImpl.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JspFactoryImpl.java
index a42fb4e05a..fa2d92c609 100644
--- a/java/org/apache/jasper/runtime/JspContextWrapper.java
+++ b/java/org/apache/jasper/runtime/JspContextWrapper.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JspFragmentHelper.java
index 92891b4d45..a3fec19a7a 100644
--- a/java/org/apache/jasper/runtime/JspFactoryImpl.java
+++ b/java/org/apache/jasper/runtime/JspFactoryImpl.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JspRuntimeLibrary.java
index 3e73f52c8a..38d26d34be 100644
--- a/java/org/apache/jasper/runtime/JspFragmentHelper.java
+++ b/java/org/apache/jasper/runtime/JspFragmentHelper.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JspSourceDependent.java
index 9392204b44..aec6453f5f 100644
--- a/java/org/apache/jasper/runtime/JspRuntimeLibrary.java
+++ b/java/org/apache/jasper/runtime/JspRuntimeLibrary.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JspWriterImpl.java
index 880cba16dc..2ba9364a6e 100644
--- a/java/org/apache/jasper/runtime/JspSourceDependent.java
+++ b/java/org/apache/jasper/runtime/JspSourceDependent.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
PageContextImpl.java
index 617b46b615..cf7a443834 100644
--- a/java/org/apache/jasper/runtime/JspWriterImpl.java
+++ b/java/org/apache/jasper/runtime/JspWriterImpl.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
PerThreadTagHandlerPool.java
index 722345d884..936d35c708 100644
--- a/java/org/apache/jasper/runtime/PageContextImpl.java
+++ b/java/org/apache/jasper/runtime/PageContextImpl.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ProtectedFunctionMapper.java
index 94b7a5c3c4..58640efcff 100644
--- a/java/org/apache/jasper/runtime/PerThreadTagHandlerPool.java
+++ b/java/org/apache/jasper/runtime/PerThreadTagHandlerPool.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ServletResponseWrapperInclude.java
index 515679c80c..309e211352 100644
--- a/java/org/apache/jasper/runtime/ProtectedFunctionMapper.java
+++ b/java/org/apache/jasper/runtime/ProtectedFunctionMapper.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
TagHandlerPool.java
index 25ad3ce754..098e7038d1 100644
--- a/java/org/apache/jasper/runtime/ServletResponseWrapperInclude.java
+++ b/java/org/apache/jasper/runtime/ServletResponseWrapperInclude.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SecurityClassLoad.java
index 7003c73e46..74f2b64bcf 100644
--- a/java/org/apache/jasper/runtime/TagHandlerPool.java
+++ b/java/org/apache/jasper/runtime/TagHandlerPool.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SecurityUtil.java
index 4a70abcae7..6c7cfc347c 100644
--- a/java/org/apache/jasper/security/SecurityClassLoad.java
+++ b/java/org/apache/jasper/security/SecurityClassLoad.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JasperLoader.java
index 32ca26b5df..6462a93051 100644
--- a/java/org/apache/jasper/security/SecurityUtil.java
+++ b/java/org/apache/jasper/security/SecurityUtil.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2002,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JspCServletContext.java
index 1acfd10d3d..c526e24a0b 100644
--- a/java/org/apache/jasper/servlet/JasperLoader.java
+++ b/java/org/apache/jasper/servlet/JasperLoader.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JspServlet.java
index d59b16543d..d0f3249114 100644
--- a/java/org/apache/jasper/servlet/JspCServletContext.java
+++ b/java/org/apache/jasper/servlet/JspCServletContext.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JspServletWrapper.java
index 15d6f584db..eb141ac9b6 100644
--- a/java/org/apache/jasper/servlet/JspServlet.java
+++ b/java/org/apache/jasper/servlet/JspServlet.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Util.java
index b0d9d6430c..d5ccfa2d34 100644
--- a/java/org/apache/jasper/servlet/JspServletWrapper.java
+++ b/java/org/apache/jasper/servlet/JspServletWrapper.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Catch.java
index 99175f9ca2..5815a2addc 100644
--- a/java/org/apache/jasper/tagplugins/jstl/Util.java
+++ b/java/org/apache/jasper/tagplugins/jstl/Util.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Choose.java
index 136fd29491..c7d154aa42 100644
--- a/java/org/apache/jasper/tagplugins/jstl/core/Catch.java
+++ b/java/org/apache/jasper/tagplugins/jstl/core/Catch.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ForEach.java
index f65354d4aa..7622ceea21 100644
--- a/java/org/apache/jasper/tagplugins/jstl/core/Choose.java
+++ b/java/org/apache/jasper/tagplugins/jstl/core/Choose.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ForTokens.java
index 4d58e845af..49c9a3fcda 100644
--- a/java/org/apache/jasper/tagplugins/jstl/core/ForEach.java
+++ b/java/org/apache/jasper/tagplugins/jstl/core/ForEach.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
If.java
index e0ac2f6f96..c72f0ad213 100644
--- a/java/org/apache/jasper/tagplugins/jstl/core/ForTokens.java
+++ b/java/org/apache/jasper/tagplugins/jstl/core/ForTokens.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Import.java
index 06dd61bda6..5f5a6df44c 100644
--- a/java/org/apache/jasper/tagplugins/jstl/core/If.java
+++ b/java/org/apache/jasper/tagplugins/jstl/core/If.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Otherwise.java
index 88f155b4ed..0803429322 100644
--- a/java/org/apache/jasper/tagplugins/jstl/core/Import.java
+++ b/java/org/apache/jasper/tagplugins/jstl/core/Import.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Out.java
index bde0e5b8a2..3119d30272 100644
--- a/java/org/apache/jasper/tagplugins/jstl/core/Otherwise.java
+++ b/java/org/apache/jasper/tagplugins/jstl/core/Otherwise.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Param.java
index 134b4c2c60..92ac1fe03f 100644
--- a/java/org/apache/jasper/tagplugins/jstl/core/Out.java
+++ b/java/org/apache/jasper/tagplugins/jstl/core/Out.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Redirect.java
index 3dfae37410..42256b8693 100644
--- a/java/org/apache/jasper/tagplugins/jstl/core/Param.java
+++ b/java/org/apache/jasper/tagplugins/jstl/core/Param.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Remove.java
index 641cff9711..6a5813fb8e 100644
--- a/java/org/apache/jasper/tagplugins/jstl/core/Redirect.java
+++ b/java/org/apache/jasper/tagplugins/jstl/core/Redirect.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Set.java
index 957aac3139..f21fa8f493 100644
--- a/java/org/apache/jasper/tagplugins/jstl/core/Remove.java
+++ b/java/org/apache/jasper/tagplugins/jstl/core/Remove.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Url.java
index c57b0ba74f..bfb2c8bf94 100644
--- a/java/org/apache/jasper/tagplugins/jstl/core/Set.java
+++ b/java/org/apache/jasper/tagplugins/jstl/core/Set.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
When.java
index c848fe458c..9db64f64a0 100644
--- a/java/org/apache/jasper/tagplugins/jstl/core/Url.java
+++ b/java/org/apache/jasper/tagplugins/jstl/core/Url.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Enumerator.java
index 7c3bce3dd7..10aefc8f13 100644
--- a/java/org/apache/jasper/tagplugins/jstl/core/When.java
+++ b/java/org/apache/jasper/tagplugins/jstl/core/When.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
FastDateFormat.java
index ba79b2882f..254467c8ff 100644
--- a/java/org/apache/jasper/util/Enumerator.java
+++ b/java/org/apache/jasper/util/Enumerator.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Queue.java
index 95d1f2f83d..c24ba19a85 100644
--- a/java/org/apache/jasper/util/FastDateFormat.java
+++ b/java/org/apache/jasper/util/FastDateFormat.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SimplePool.java
index c17bc819d7..9d51b787e7 100644
--- a/java/org/apache/jasper/util/Queue.java
+++ b/java/org/apache/jasper/util/Queue.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SystemLogHandler.java
index 22cd14fcdc..aba574ed63 100644
--- a/java/org/apache/jasper/util/SimplePool.java
+++ b/java/org/apache/jasper/util/SimplePool.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ASCIIReader.java
index 19847ea099..b2b1e74632 100644
--- a/java/org/apache/jasper/util/SystemLogHandler.java
+++ b/java/org/apache/jasper/util/SystemLogHandler.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
EncodingMap.java
index c313e322ac..279b58a6f1 100644
--- a/java/org/apache/jasper/xmlparser/ASCIIReader.java
+++ b/java/org/apache/jasper/xmlparser/ASCIIReader.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ParserUtils.java
index 35e6559474..ffdc73cc8b 100644
--- a/java/org/apache/jasper/xmlparser/EncodingMap.java
+++ b/java/org/apache/jasper/xmlparser/EncodingMap.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SymbolTable.java
index f7ca0aaf4d..1e3a11517d 100644
--- a/java/org/apache/jasper/xmlparser/ParserUtils.java
+++ b/java/org/apache/jasper/xmlparser/ParserUtils.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
TreeNode.java
index 8537a94713..5edbde79d9 100644
--- a/java/org/apache/jasper/xmlparser/SymbolTable.java
+++ b/java/org/apache/jasper/xmlparser/SymbolTable.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
UCSReader.java
index d63d61725d..6a76ffe240 100644
--- a/java/org/apache/jasper/xmlparser/TreeNode.java
+++ b/java/org/apache/jasper/xmlparser/TreeNode.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
UTF8Reader.java
index e2c702320d..f2005fae9c 100644
--- a/java/org/apache/jasper/xmlparser/UCSReader.java
+++ b/java/org/apache/jasper/xmlparser/UCSReader.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
XMLChar.java
index 83477529ba..cd3f7a6a8e 100644
--- a/java/org/apache/jasper/xmlparser/UTF8Reader.java
+++ b/java/org/apache/jasper/xmlparser/UTF8Reader.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
XMLEncodingDetector.java
index 121117fdc8..858cd8e7c1 100644
--- a/java/org/apache/jasper/xmlparser/XMLChar.java
+++ b/java/org/apache/jasper/xmlparser/XMLChar.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
XMLString.java
index a0f050c82b..e5f21d4837 100644
--- a/java/org/apache/jasper/xmlparser/XMLEncodingDetector.java
+++ b/java/org/apache/jasper/xmlparser/XMLEncodingDetector.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
XMLStringBuffer.java
index 54ee60e710..66919fa1ca 100644
--- a/java/org/apache/jasper/xmlparser/XMLString.java
+++ b/java/org/apache/jasper/xmlparser/XMLString.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
AprImpl.java
index c51aff8002..f96cb4917e 100644
--- a/java/org/apache/jasper/xmlparser/XMLStringBuffer.java
+++ b/java/org/apache/jasper/xmlparser/XMLStringBuffer.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
TomcatStarter.java
index 74b7f7571d..271e73a319 100644
--- a/java/org/apache/jk/apr/AprImpl.java
+++ b/java/org/apache/jk/apr/AprImpl.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
AjpConstants.java
index c9e2a6bab0..7efa319ddf 100644
--- a/java/org/apache/jk/apr/TomcatStarter.java
+++ b/java/org/apache/jk/apr/TomcatStarter.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
ChannelJni.java
index 71bdd1ef10..155c93f573 100644
--- a/java/org/apache/jk/common/AjpConstants.java
+++ b/java/org/apache/jk/common/AjpConstants.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
ChannelNioSocket.java
index 1a05afe647..673643a91c 100644
--- a/java/org/apache/jk/common/ChannelJni.java
+++ b/java/org/apache/jk/common/ChannelJni.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
ChannelShm.java
index ac620d4e4a..59af910c02 100644
--- a/java/org/apache/jk/common/ChannelNioSocket.java
+++ b/java/org/apache/jk/common/ChannelNioSocket.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
ChannelSocket.java
index ceaaf9a6a5..bebb3fa4d2 100644
--- a/java/org/apache/jk/common/ChannelShm.java
+++ b/java/org/apache/jk/common/ChannelShm.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
ChannelUn.java
index 331c740c89..fe4255bd48 100644
--- a/java/org/apache/jk/common/ChannelSocket.java
+++ b/java/org/apache/jk/common/ChannelSocket.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
HandlerDispatch.java
index 9232fcd79a..1da79bd9f5 100644
--- a/java/org/apache/jk/common/ChannelUn.java
+++ b/java/org/apache/jk/common/ChannelUn.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
HandlerRequest.java
index c50b31d80b..52538caf64 100644
--- a/java/org/apache/jk/common/HandlerDispatch.java
+++ b/java/org/apache/jk/common/HandlerDispatch.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
JkInputStream.java
index 88a81072ef..828bd99c8c 100644
--- a/java/org/apache/jk/common/HandlerRequest.java
+++ b/java/org/apache/jk/common/HandlerRequest.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
JkMX.java
index 1b619e203b..f56e26c170 100644
--- a/java/org/apache/jk/common/JkInputStream.java
+++ b/java/org/apache/jk/common/JkInputStream.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
JniHandler.java
index 07c3ee2bce..dd341c4f6b 100644
--- a/java/org/apache/jk/common/JkMX.java
+++ b/java/org/apache/jk/common/JkMX.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
MsgAjp.java
index eb7859cbb9..8d9d76694a 100644
--- a/java/org/apache/jk/common/JniHandler.java
+++ b/java/org/apache/jk/common/JniHandler.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Shm.java
index 86baac3f5c..30114fbdc2 100644
--- a/java/org/apache/jk/common/MsgAjp.java
+++ b/java/org/apache/jk/common/MsgAjp.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Shm14.java
index dcc0fac356..4d5130f24d 100644
--- a/java/org/apache/jk/common/Shm.java
+++ b/java/org/apache/jk/common/Shm.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
WorkerDummy.java
index 21f757efdb..2c21a01e13 100644
--- a/java/org/apache/jk/common/Shm14.java
+++ b/java/org/apache/jk/common/Shm14.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
ApacheConfig.java
index 9f7914d516..3767850706 100644
--- a/java/org/apache/jk/common/WorkerDummy.java
+++ b/java/org/apache/jk/common/WorkerDummy.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
BaseJkConfig.java
index d8aaa32fe7..6683b073fc 100644
--- a/java/org/apache/jk/config/ApacheConfig.java
+++ b/java/org/apache/jk/config/ApacheConfig.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
GeneratorApache2.java
index 6552de2b5b..29c977157a 100644
--- a/java/org/apache/jk/config/BaseJkConfig.java
+++ b/java/org/apache/jk/config/BaseJkConfig.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
GeneratorJk1.java
index c2b2f4c871..c66a8ce738 100644
--- a/java/org/apache/jk/config/GeneratorApache2.java
+++ b/java/org/apache/jk/config/GeneratorApache2.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
GeneratorJk2.java
index ade15efed5..7f9c237fd0 100644
--- a/java/org/apache/jk/config/GeneratorJk1.java
+++ b/java/org/apache/jk/config/GeneratorJk1.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
IISConfig.java
index 450526d11f..f06c6e8ee4 100644
--- a/java/org/apache/jk/config/GeneratorJk2.java
+++ b/java/org/apache/jk/config/GeneratorJk2.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
NSConfig.java
index e737a2b874..b29553398f 100644
--- a/java/org/apache/jk/config/IISConfig.java
+++ b/java/org/apache/jk/config/IISConfig.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
WebXml2Jk.java
index 9c0c8eb9cc..6b9105d439 100644
--- a/java/org/apache/jk/config/NSConfig.java
+++ b/java/org/apache/jk/config/NSConfig.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
JkChannel.java
index 835f41f574..c03030fd32 100644
--- a/java/org/apache/jk/config/WebXml2Jk.java
+++ b/java/org/apache/jk/config/WebXml2Jk.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
JkHandler.java
index d69510662e..76cb9301fa 100644
--- a/java/org/apache/jk/core/JkChannel.java
+++ b/java/org/apache/jk/core/JkChannel.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Msg.java
index 3fbdaad52a..1cadbc64d5 100644
--- a/java/org/apache/jk/core/JkHandler.java
+++ b/java/org/apache/jk/core/JkHandler.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
MsgContext.java
index 8176dc0146..da66ba7726 100644
--- a/java/org/apache/jk/core/Msg.java
+++ b/java/org/apache/jk/core/Msg.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
WorkerEnv.java
index 1a4bc315a6..bd9e8d4b23 100644
--- a/java/org/apache/jk/core/MsgContext.java
+++ b/java/org/apache/jk/core/MsgContext.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
JkCoyoteHandler.java
index 5392460e59..18145ebe63 100644
--- a/java/org/apache/jk/core/WorkerEnv.java
+++ b/java/org/apache/jk/core/WorkerEnv.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
JkMain.java
index cf22609ddb..23691e2d18 100644
--- a/java/org/apache/jk/server/JkCoyoteHandler.java
+++ b/java/org/apache/jk/server/JkCoyoteHandler.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
ClassLoaderLogManager.java
index 7a21947a6f..fae6eeee05 100644
--- a/java/org/apache/jk/server/JkMain.java
+++ b/java/org/apache/jk/server/JkMain.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
FileHandler.java
index ebc5cb5953..ee3af37372 100644
--- a/java/org/apache/juli/ClassLoaderLogManager.java
+++ b/java/org/apache/juli/ClassLoaderLogManager.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Log.java
index a058f99d64..447789a9e5 100644
--- a/java/org/apache/juli/FileHandler.java
+++ b/java/org/apache/juli/FileHandler.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
LogConfigurationException.java
index 4ba99ac6a1..b00c6d7085 100644
--- a/java/org/apache/juli/logging/Log.java
+++ b/java/org/apache/juli/logging/Log.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
LogFactory.java
index 70dff41600..b0e0029493 100644
--- a/java/org/apache/juli/logging/LogConfigurationException.java
+++ b/java/org/apache/juli/logging/LogConfigurationException.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Constants.java
index d42b2728f2..bc9d6222b3 100644
--- a/java/org/apache/juli/logging/LogFactory.java
+++ b/java/org/apache/juli/logging/LogFactory.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ContextAccessController.java
index 127c8e6f60..740977f24f 100644
--- a/java/org/apache/naming/Constants.java
+++ b/java/org/apache/naming/Constants.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ContextBindings.java
index fa47e5d73a..c8e44348c2 100644
--- a/java/org/apache/naming/ContextAccessController.java
+++ b/java/org/apache/naming/ContextAccessController.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
EjbRef.java
index 90ba59c116..25935d32f2 100644
--- a/java/org/apache/naming/ContextBindings.java
+++ b/java/org/apache/naming/ContextBindings.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
JndiPermission.java
index c42f5b75d7..0486af4d67 100644
--- a/java/org/apache/naming/EjbRef.java
+++ b/java/org/apache/naming/EjbRef.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
NameParserImpl.java
index b36cb31e66..98ee945969 100644
--- a/java/org/apache/naming/JndiPermission.java
+++ b/java/org/apache/naming/JndiPermission.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
NamingContext.java
index 53f5a1c1ed..be7af2bc75 100644
--- a/java/org/apache/naming/NameParserImpl.java
+++ b/java/org/apache/naming/NameParserImpl.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
NamingContextBindingsEnumeration.java
index a9875c011c..3d600bbf25 100644
--- a/java/org/apache/naming/NamingContext.java
+++ b/java/org/apache/naming/NamingContext.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
NamingContextEnumeration.java
index 459930bb65..c8acd98027 100644
--- a/java/org/apache/naming/NamingContextBindingsEnumeration.java
+++ b/java/org/apache/naming/NamingContextBindingsEnumeration.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
NamingEntry.java
index 80f591bc22..bc893df024 100644
--- a/java/org/apache/naming/NamingContextEnumeration.java
+++ b/java/org/apache/naming/NamingContextEnumeration.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
NamingService.java
index 1aecca7680..f1d688c6a4 100644
--- a/java/org/apache/naming/NamingEntry.java
+++ b/java/org/apache/naming/NamingEntry.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
NamingServiceMBean.java
index a880d6fa88..5020c43470 100644
--- a/java/org/apache/naming/NamingService.java
+++ b/java/org/apache/naming/NamingService.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ResourceEnvRef.java
index 68e1eb94a8..f0309bb8cc 100644
--- a/java/org/apache/naming/NamingServiceMBean.java
+++ b/java/org/apache/naming/NamingServiceMBean.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ResourceLinkRef.java
index 541c8fb900..8f0153e6ac 100644
--- a/java/org/apache/naming/ResourceEnvRef.java
+++ b/java/org/apache/naming/ResourceEnvRef.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ResourceRef.java
index 1d3eaab9a2..c8e9c85dbe 100644
--- a/java/org/apache/naming/ResourceLinkRef.java
+++ b/java/org/apache/naming/ResourceLinkRef.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SelectorContext.java
index cbf7c08dd9..2e5f08cd5a 100644
--- a/java/org/apache/naming/ResourceRef.java
+++ b/java/org/apache/naming/ResourceRef.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
StringManager.java
index a417c875d9..26e51c60fb 100644
--- a/java/org/apache/naming/SelectorContext.java
+++ b/java/org/apache/naming/SelectorContext.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
TransactionRef.java
index 82da0b3085..1183d0b4d0 100644
--- a/java/org/apache/naming/StringManager.java
+++ b/java/org/apache/naming/StringManager.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
BeanFactory.java
index af70798d91..650fa40a42 100644
--- a/java/org/apache/naming/TransactionRef.java
+++ b/java/org/apache/naming/TransactionRef.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Constants.java
index 45938e3812..9bc0e4137b 100644
--- a/java/org/apache/naming/factory/BeanFactory.java
+++ b/java/org/apache/naming/factory/BeanFactory.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
EjbFactory.java
index 2ceeb0c1ee..3bb10f86c6 100644
--- a/java/org/apache/naming/factory/Constants.java
+++ b/java/org/apache/naming/factory/Constants.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
MailSessionFactory.java
index 5edae15414..e55309fad2 100644
--- a/java/org/apache/naming/factory/EjbFactory.java
+++ b/java/org/apache/naming/factory/EjbFactory.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
OpenEjbFactory.java
index 2b24e3735b..0595bdb6e1 100644
--- a/java/org/apache/naming/factory/MailSessionFactory.java
+++ b/java/org/apache/naming/factory/MailSessionFactory.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2001,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ResourceEnvFactory.java
index 7eface6ccf..270ea1d586 100644
--- a/java/org/apache/naming/factory/OpenEjbFactory.java
+++ b/java/org/apache/naming/factory/OpenEjbFactory.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ResourceFactory.java
index a42bc343ab..d10ff35908 100644
--- a/java/org/apache/naming/factory/ResourceEnvFactory.java
+++ b/java/org/apache/naming/factory/ResourceEnvFactory.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ResourceLinkFactory.java
index 3c1ea8660e..77dd4c8d48 100644
--- a/java/org/apache/naming/factory/ResourceFactory.java
+++ b/java/org/apache/naming/factory/ResourceFactory.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SendMailFactory.java
index cc3542e879..85ea9dc5e8 100644
--- a/java/org/apache/naming/factory/ResourceLinkFactory.java
+++ b/java/org/apache/naming/factory/ResourceLinkFactory.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
TransactionFactory.java
index b0fec48286..27d99096c5 100644
--- a/java/org/apache/naming/factory/SendMailFactory.java
+++ b/java/org/apache/naming/factory/SendMailFactory.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
javaURLContextFactory.java
index 2e0b3c9b1e..d2dc8c69fb 100644
--- a/java/org/apache/naming/factory/TransactionFactory.java
+++ b/java/org/apache/naming/factory/TransactionFactory.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
BaseDirContext.java
index b653c9cf7b..61519f1a28 100644
--- a/java/org/apache/naming/java/javaURLContextFactory.java
+++ b/java/org/apache/naming/java/javaURLContextFactory.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
CacheEntry.java
index 8f1321e37c..3593ecf4da 100644
--- a/java/org/apache/naming/resources/BaseDirContext.java
+++ b/java/org/apache/naming/resources/BaseDirContext.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Constants.java
index 5c4ad9c3b7..88f97cebfc 100644
--- a/java/org/apache/naming/resources/CacheEntry.java
+++ b/java/org/apache/naming/resources/CacheEntry.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
DirContextURLConnection.java
index a505a2200e..dd004e4153 100644
--- a/java/org/apache/naming/resources/Constants.java
+++ b/java/org/apache/naming/resources/Constants.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
DirContextURLStreamHandler.java
index 773dc6b092..bdae090046 100644
--- a/java/org/apache/naming/resources/DirContextURLConnection.java
+++ b/java/org/apache/naming/resources/DirContextURLConnection.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
DirContextURLStreamHandlerFactory.java
index b5e8a00c5e..c1d9dfa477 100644
--- a/java/org/apache/naming/resources/DirContextURLStreamHandler.java
+++ b/java/org/apache/naming/resources/DirContextURLStreamHandler.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
FileDirContext.java
index a7d8f8921b..64a4f2eaa6 100644
--- a/java/org/apache/naming/resources/DirContextURLStreamHandlerFactory.java
+++ b/java/org/apache/naming/resources/DirContextURLStreamHandlerFactory.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ImmutableNameNotFoundException.java
index d55aa1494d..38fa992c6e 100644
--- a/java/org/apache/naming/resources/FileDirContext.java
+++ b/java/org/apache/naming/resources/FileDirContext.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
ProxyDirContext.java
index 6d66f36c5c..af70d53483 100644
--- a/java/org/apache/naming/resources/ImmutableNameNotFoundException.java
+++ b/java/org/apache/naming/resources/ImmutableNameNotFoundException.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
RecyclableNamingEnumeration.java
index d501afbfa7..602ac27a9f 100644
--- a/java/org/apache/naming/resources/ProxyDirContext.java
+++ b/java/org/apache/naming/resources/ProxyDirContext.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Resource.java
index 3ff22255bf..e013b7118b 100644
--- a/java/org/apache/naming/resources/RecyclableNamingEnumeration.java
+++ b/java/org/apache/naming/resources/RecyclableNamingEnumeration.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ResourceAttributes.java
index a4e923fcdb..83abc8d6d3 100644
--- a/java/org/apache/naming/resources/Resource.java
+++ b/java/org/apache/naming/resources/Resource.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ResourceCache.java
index 66b24e3088..300ab6d7a1 100644
--- a/java/org/apache/naming/resources/ResourceAttributes.java
+++ b/java/org/apache/naming/resources/ResourceAttributes.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
WARDirContext.java
index 733a22a141..da14599dbe 100644
--- a/java/org/apache/naming/resources/ResourceCache.java
+++ b/java/org/apache/naming/resources/ResourceCache.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Handler.java
index 32a8f14a4e..61a24780d7 100644
--- a/java/org/apache/naming/resources/WARDirContext.java
+++ b/java/org/apache/naming/resources/WARDirContext.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Apr.java
index 4a0e6bc4ba..a308d6051b 100644
--- a/java/org/apache/naming/resources/jndi/Handler.java
+++ b/java/org/apache/naming/resources/jndi/Handler.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Address.java
index 9c2480c4af..53d5d06755 100644
--- a/java/org/apache/tomcat/Apr.java
+++ b/java/org/apache/tomcat/Apr.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2000-2005 The Apache Software Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
BIOCallback.java
index 9d9f742c36..cc7b4f8d56 100644
--- a/java/org/apache/tomcat/jni/Address.java
+++ b/java/org/apache/tomcat/jni/Address.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2000-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Directory.java
index 6928d331bd..296bc16c6b 100644
--- a/java/org/apache/tomcat/jni/BIOCallback.java
+++ b/java/org/apache/tomcat/jni/BIOCallback.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2000-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Error.java
index a6a0198090..7fddcd4eb5 100644
--- a/java/org/apache/tomcat/jni/Directory.java
+++ b/java/org/apache/tomcat/jni/Directory.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2000-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
File.java
index 97683291ea..bc76af1a4f 100644
--- a/java/org/apache/tomcat/jni/Error.java
+++ b/java/org/apache/tomcat/jni/Error.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2000-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
FileInfo.java
index 1e4213da42..b4d4c05745 100644
--- a/java/org/apache/tomcat/jni/File.java
+++ b/java/org/apache/tomcat/jni/File.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2000-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Global.java
index a4b1f32f74..0ec0d1921c 100644
--- a/java/org/apache/tomcat/jni/FileInfo.java
+++ b/java/org/apache/tomcat/jni/FileInfo.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2000-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Library.java
index a15b6e42d0..a398911487 100644
--- a/java/org/apache/tomcat/jni/Global.java
+++ b/java/org/apache/tomcat/jni/Global.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2000-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Local.java
index 1cd0aacc01..59346f2c29 100644
--- a/java/org/apache/tomcat/jni/Library.java
+++ b/java/org/apache/tomcat/jni/Library.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2000-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Lock.java
index ce7bbdeb04..37f112ac8f 100644
--- a/java/org/apache/tomcat/jni/Local.java
+++ b/java/org/apache/tomcat/jni/Local.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2000-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Mmap.java
index a74b0dcc68..b759069219 100644
--- a/java/org/apache/tomcat/jni/Lock.java
+++ b/java/org/apache/tomcat/jni/Lock.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2000-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Multicast.java
index d4211f0af0..de6b243113 100644
--- a/java/org/apache/tomcat/jni/Mmap.java
+++ b/java/org/apache/tomcat/jni/Mmap.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2000-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
OS.java
index 43b2b3a85b..88f3b4059a 100644
--- a/java/org/apache/tomcat/jni/Multicast.java
+++ b/java/org/apache/tomcat/jni/Multicast.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2000-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
PasswordCallback.java
index a184409a9e..f63dc0f6da 100644
--- a/java/org/apache/tomcat/jni/OS.java
+++ b/java/org/apache/tomcat/jni/OS.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2000-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Poll.java
index b0d6450e86..2c7609ba29 100644
--- a/java/org/apache/tomcat/jni/PasswordCallback.java
+++ b/java/org/apache/tomcat/jni/PasswordCallback.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2000-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Pool.java
index 3a903b46ad..5fff9ea25f 100644
--- a/java/org/apache/tomcat/jni/Poll.java
+++ b/java/org/apache/tomcat/jni/Poll.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2000-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
PoolCallback.java
index 3d3b43f7f1..7f79a9fc22 100644
--- a/java/org/apache/tomcat/jni/Pool.java
+++ b/java/org/apache/tomcat/jni/Pool.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2000-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Proc.java
index d88b15a240..e38e8201cb 100644
--- a/java/org/apache/tomcat/jni/PoolCallback.java
+++ b/java/org/apache/tomcat/jni/PoolCallback.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2000-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
ProcErrorCallback.java
index 38cc3b4a13..90ab1516e0 100644
--- a/java/org/apache/tomcat/jni/Proc.java
+++ b/java/org/apache/tomcat/jni/Proc.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2000-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Procattr.java
index 7ba54e8fa4..7e567c7352 100644
--- a/java/org/apache/tomcat/jni/ProcErrorCallback.java
+++ b/java/org/apache/tomcat/jni/ProcErrorCallback.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2000-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Registry.java
index 9d9e5d9368..bcd7f100c9 100644
--- a/java/org/apache/tomcat/jni/Procattr.java
+++ b/java/org/apache/tomcat/jni/Procattr.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2000-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
SSL.java
index 399b8b55c9..4fbe10f73a 100644
--- a/java/org/apache/tomcat/jni/Registry.java
+++ b/java/org/apache/tomcat/jni/Registry.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2000-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
SSLContext.java
index 966df743ba..e001e61e3d 100644
--- a/java/org/apache/tomcat/jni/SSL.java
+++ b/java/org/apache/tomcat/jni/SSL.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2000-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
SSLSocket.java
index 36903b785c..fa216a7d74 100644
--- a/java/org/apache/tomcat/jni/SSLContext.java
+++ b/java/org/apache/tomcat/jni/SSLContext.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2000-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Shm.java
index 79a8bd4958..02456148ee 100644
--- a/java/org/apache/tomcat/jni/SSLSocket.java
+++ b/java/org/apache/tomcat/jni/SSLSocket.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2000-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Sockaddr.java
index ffbdb7f282..af2e96dfb7 100644
--- a/java/org/apache/tomcat/jni/Shm.java
+++ b/java/org/apache/tomcat/jni/Shm.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2000-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Socket.java
index 105756688b..aab46ba64b 100644
--- a/java/org/apache/tomcat/jni/Sockaddr.java
+++ b/java/org/apache/tomcat/jni/Sockaddr.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2000-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Status.java
index b0c96559a7..6848f4d2d5 100644
--- a/java/org/apache/tomcat/jni/Socket.java
+++ b/java/org/apache/tomcat/jni/Socket.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2000-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Stdlib.java
index d2d2721841..caa1033e36 100644
--- a/java/org/apache/tomcat/jni/Status.java
+++ b/java/org/apache/tomcat/jni/Status.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2000-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Time.java
index d5734fbd0e..c63da45335 100644
--- a/java/org/apache/tomcat/jni/Stdlib.java
+++ b/java/org/apache/tomcat/jni/Stdlib.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2000-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
User.java
index 15999dce13..2fc271e28b 100644
--- a/java/org/apache/tomcat/jni/Time.java
+++ b/java/org/apache/tomcat/jni/Time.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2000-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
DomUtil.java
index f04fcedf6d..eb0fe14730 100644
--- a/java/org/apache/tomcat/jni/User.java
+++ b/java/org/apache/tomcat/jni/User.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2000-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
IntrospectionUtils.java
index 8b0f0a1904..876cddef42 100644
--- a/java/org/apache/tomcat/util/DomUtil.java
+++ b/java/org/apache/tomcat/util/DomUtil.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Ascii.java
index 1dd2ee3d98..6f497b85b2 100644
--- a/java/org/apache/tomcat/util/IntrospectionUtils.java
+++ b/java/org/apache/tomcat/util/IntrospectionUtils.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
B2CConverter.java
index 1c6750eef4..25bb51528e 100644
--- a/java/org/apache/tomcat/util/buf/Ascii.java
+++ b/java/org/apache/tomcat/util/buf/Ascii.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Base64.java
index 52d1caa1b5..16997380be 100644
--- a/java/org/apache/tomcat/util/buf/B2CConverter.java
+++ b/java/org/apache/tomcat/util/buf/B2CConverter.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
ByteChunk.java
index ae3b003098..173b77cec1 100644
--- a/java/org/apache/tomcat/util/buf/Base64.java
+++ b/java/org/apache/tomcat/util/buf/Base64.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
C2BConverter.java
index 71678228dd..257df24ae4 100644
--- a/java/org/apache/tomcat/util/buf/ByteChunk.java
+++ b/java/org/apache/tomcat/util/buf/ByteChunk.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
CharChunk.java
index 10daa93fba..b5d3b426eb 100644
--- a/java/org/apache/tomcat/util/buf/C2BConverter.java
+++ b/java/org/apache/tomcat/util/buf/C2BConverter.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
DateTool.java
index 6a542a92e9..4dc03fc92e 100644
--- a/java/org/apache/tomcat/util/buf/CharChunk.java
+++ b/java/org/apache/tomcat/util/buf/CharChunk.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
HexUtils.java
index 4599963bdf..03db465f02 100644
--- a/java/org/apache/tomcat/util/buf/DateTool.java
+++ b/java/org/apache/tomcat/util/buf/DateTool.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
MessageBytes.java
index 2ad9ae0f0f..192988a9a4 100644
--- a/java/org/apache/tomcat/util/buf/HexUtils.java
+++ b/java/org/apache/tomcat/util/buf/HexUtils.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
StringCache.java
index 2693147b7c..7329a4cfde 100644
--- a/java/org/apache/tomcat/util/buf/MessageBytes.java
+++ b/java/org/apache/tomcat/util/buf/MessageBytes.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
TimeStamp.java
index 0dd6b2d77b..50f5b2f04f 100644
--- a/java/org/apache/tomcat/util/buf/StringCache.java
+++ b/java/org/apache/tomcat/util/buf/StringCache.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
UDecoder.java
index 90bab825ea..a7315d79bd 100644
--- a/java/org/apache/tomcat/util/buf/TimeStamp.java
+++ b/java/org/apache/tomcat/util/buf/TimeStamp.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
UEncoder.java
index 2d4d5d4682..e805a70e25 100644
--- a/java/org/apache/tomcat/util/buf/UDecoder.java
+++ b/java/org/apache/tomcat/util/buf/UDecoder.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
UTF8Decoder.java
index b15a73a2f4..e4597d2b8e 100644
--- a/java/org/apache/tomcat/util/buf/UEncoder.java
+++ b/java/org/apache/tomcat/util/buf/UEncoder.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
EmptyEnumeration.java
index b6a1e960e2..0d2673f34a 100644
--- a/java/org/apache/tomcat/util/buf/UTF8Decoder.java
+++ b/java/org/apache/tomcat/util/buf/UTF8Decoder.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
LRUCache.java
index 7154488eaa..22eef4924a 100644
--- a/java/org/apache/tomcat/util/collections/EmptyEnumeration.java
+++ b/java/org/apache/tomcat/util/collections/EmptyEnumeration.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
MultiMap.java
index f0896dc2c0..052840fd6d 100644
--- a/java/org/apache/tomcat/util/collections/LRUCache.java
+++ b/java/org/apache/tomcat/util/collections/LRUCache.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
MultiMapNamesEnumeration.java
index 3e60dbd9fb..30449c41cb 100644
--- a/java/org/apache/tomcat/util/collections/MultiMap.java
+++ b/java/org/apache/tomcat/util/collections/MultiMap.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
MultiMapValuesEnumeration.java
index aa9620d7f1..7d9ef7dc5a 100644
--- a/java/org/apache/tomcat/util/collections/MultiMapNamesEnumeration.java
+++ b/java/org/apache/tomcat/util/collections/MultiMapNamesEnumeration.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Queue.java
index eff02f9107..8b035d73ce 100644
--- a/java/org/apache/tomcat/util/collections/MultiMapValuesEnumeration.java
+++ b/java/org/apache/tomcat/util/collections/MultiMapValuesEnumeration.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
SimpleHashtable.java
index 86a049c465..39a87a57bf 100644
--- a/java/org/apache/tomcat/util/collections/Queue.java
+++ b/java/org/apache/tomcat/util/collections/Queue.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
SimplePool.java
index c55ee298f6..4d083b006c 100644
--- a/java/org/apache/tomcat/util/collections/SimpleHashtable.java
+++ b/java/org/apache/tomcat/util/collections/SimpleHashtable.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
AbstractObjectCreationFactory.java
index 91720628ca..ea725868b3 100644
--- a/java/org/apache/tomcat/util/collections/SimplePool.java
+++ b/java/org/apache/tomcat/util/collections/SimplePool.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
AbstractRulesImpl.java
index 4cddfddd48..95444e5bd0 100644
--- a/java/org/apache/tomcat/util/digester/AbstractObjectCreationFactory.java
+++ b/java/org/apache/tomcat/util/digester/AbstractObjectCreationFactory.java
@@ -1,10 +1,11 @@
 /* $Id: AbstractObjectCreationFactory.java 299475 2004-06-26 17:41:32Z remm $
  *
- * Copyright 2001-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ArrayStack.java
index f934022b0a..3db53b6a26 100644
--- a/java/org/apache/tomcat/util/digester/AbstractRulesImpl.java
+++ b/java/org/apache/tomcat/util/digester/AbstractRulesImpl.java
@@ -1,10 +1,11 @@
 /* $Id: AbstractRulesImpl.java 299475 2004-06-26 17:41:32Z remm $
  *
- * Copyright 2001-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
CallMethodRule.java
index 3410263abf..573c71f7f4 100644
--- a/java/org/apache/tomcat/util/digester/ArrayStack.java
+++ b/java/org/apache/tomcat/util/digester/ArrayStack.java
@@ -1,10 +1,11 @@
 /* $Id: ArrayStack.java 299475 2004-06-26 17:41:32Z remm $
  *
- * Copyright 2001-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
CallParamRule.java
index 08cdd59571..e253627775 100644
--- a/java/org/apache/tomcat/util/digester/CallMethodRule.java
+++ b/java/org/apache/tomcat/util/digester/CallMethodRule.java
@@ -1,10 +1,11 @@
 /* $Id: CallMethodRule.java 299765 2004-08-31 23:52:52Z yoavs $
  *
- * Copyright 2001-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Digester.java
index 37ce5b4b8c..a307fdd86e 100644
--- a/java/org/apache/tomcat/util/digester/CallParamRule.java
+++ b/java/org/apache/tomcat/util/digester/CallParamRule.java
@@ -1,10 +1,11 @@
 /* $Id: CallParamRule.java 299475 2004-06-26 17:41:32Z remm $
  *
- * Copyright 2001-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
FactoryCreateRule.java
index 055ead376b..4ae08f5c09 100644
--- a/java/org/apache/tomcat/util/digester/Digester.java
+++ b/java/org/apache/tomcat/util/digester/Digester.java
@@ -1,10 +1,11 @@
 /* $Id: Digester.java 380645 2006-02-24 11:37:46Z remm $
  *
- * Copyright 2001-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
GenericParser.java
index 5d246cc60f..1a66d4a5f9 100644
--- a/java/org/apache/tomcat/util/digester/FactoryCreateRule.java
+++ b/java/org/apache/tomcat/util/digester/FactoryCreateRule.java
@@ -1,10 +1,11 @@
 /* $Id: FactoryCreateRule.java 299475 2004-06-26 17:41:32Z remm $
  *
- * Copyright 2001-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
NodeCreateRule.java
index 2273232061..4f7e9a7d30 100644
--- a/java/org/apache/tomcat/util/digester/GenericParser.java
+++ b/java/org/apache/tomcat/util/digester/GenericParser.java
@@ -1,10 +1,11 @@
 /* $Id: GenericParser.java 299475 2004-06-26 17:41:32Z remm $
  *
- * Copyright 2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ObjectCreateRule.java
index 33a63bedf9..4e22bb67c8 100644
--- a/java/org/apache/tomcat/util/digester/NodeCreateRule.java
+++ b/java/org/apache/tomcat/util/digester/NodeCreateRule.java
@@ -1,10 +1,11 @@
 /* $Id: NodeCreateRule.java 299765 2004-08-31 23:52:52Z yoavs $
  *
- * Copyright 2002-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ObjectCreationFactory.java
index de8d2eeaf1..ac70a327bb 100644
--- a/java/org/apache/tomcat/util/digester/ObjectCreateRule.java
+++ b/java/org/apache/tomcat/util/digester/ObjectCreateRule.java
@@ -1,10 +1,11 @@
 /* $Id: ObjectCreateRule.java 299475 2004-06-26 17:41:32Z remm $
  *
- * Copyright 2001-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ObjectParamRule.java
index 6600ab8ca6..8155efc690 100644
--- a/java/org/apache/tomcat/util/digester/ObjectCreationFactory.java
+++ b/java/org/apache/tomcat/util/digester/ObjectCreationFactory.java
@@ -1,10 +1,11 @@
 /* $Id: ObjectCreationFactory.java 299475 2004-06-26 17:41:32Z remm $
  *
- * Copyright 2001-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ParserFeatureSetterFactory.java
index a9f108cd00..5149123f06 100644
--- a/java/org/apache/tomcat/util/digester/ObjectParamRule.java
+++ b/java/org/apache/tomcat/util/digester/ObjectParamRule.java
@@ -1,10 +1,11 @@
 /* $Id: ObjectParamRule.java 299475 2004-06-26 17:41:32Z remm $
  *
- * Copyright 2002-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
PathCallParamRule.java
index ddfbbac278..bff9195151 100644
--- a/java/org/apache/tomcat/util/digester/ParserFeatureSetterFactory.java
+++ b/java/org/apache/tomcat/util/digester/ParserFeatureSetterFactory.java
@@ -1,10 +1,11 @@
 /* $Id: ParserFeatureSetterFactory.java 299475 2004-06-26 17:41:32Z remm $
  *
- * Copyright 2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Rule.java
index a29b80185d..897d1f5d2c 100644
--- a/java/org/apache/tomcat/util/digester/PathCallParamRule.java
+++ b/java/org/apache/tomcat/util/digester/PathCallParamRule.java
@@ -1,10 +1,11 @@
 /* $Id: PathCallParamRule.java 299475 2004-06-26 17:41:32Z remm $
  *
- * Copyright 2003-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
RuleSet.java
index 4e5dab0cfb..251814b56f 100644
--- a/java/org/apache/tomcat/util/digester/Rule.java
+++ b/java/org/apache/tomcat/util/digester/Rule.java
@@ -1,10 +1,11 @@
 /* $Id: Rule.java 299475 2004-06-26 17:41:32Z remm $
  *
- * Copyright 2001-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
RuleSetBase.java
index 9a024a7acb..a168cfa10e 100644
--- a/java/org/apache/tomcat/util/digester/RuleSet.java
+++ b/java/org/apache/tomcat/util/digester/RuleSet.java
@@ -1,10 +1,11 @@
 /* $Id: RuleSet.java 299475 2004-06-26 17:41:32Z remm $
  *
- * Copyright 2001-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Rules.java
index e83dab5be1..fb53692f02 100644
--- a/java/org/apache/tomcat/util/digester/RuleSetBase.java
+++ b/java/org/apache/tomcat/util/digester/RuleSetBase.java
@@ -1,10 +1,11 @@
 /* $Id: RuleSetBase.java 299475 2004-06-26 17:41:32Z remm $
  *
- * Copyright 2001-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
RulesBase.java
index 03c7701ba4..91ae6b78ef 100644
--- a/java/org/apache/tomcat/util/digester/Rules.java
+++ b/java/org/apache/tomcat/util/digester/Rules.java
@@ -1,10 +1,11 @@
 /* $Id: Rules.java 299475 2004-06-26 17:41:32Z remm $
  *
- * Copyright 2001-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SetNextRule.java
index 3bbc18d97d..b3defb48da 100644
--- a/java/org/apache/tomcat/util/digester/RulesBase.java
+++ b/java/org/apache/tomcat/util/digester/RulesBase.java
@@ -1,10 +1,11 @@
 /* $Id: RulesBase.java 299475 2004-06-26 17:41:32Z remm $
  *
- * Copyright 2001-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SetPropertiesRule.java
index cf9b8f64a3..8d6241ecb2 100644
--- a/java/org/apache/tomcat/util/digester/SetNextRule.java
+++ b/java/org/apache/tomcat/util/digester/SetNextRule.java
@@ -1,10 +1,11 @@
 /* $Id: SetNextRule.java 299475 2004-06-26 17:41:32Z remm $
  *
- * Copyright 2001-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SetPropertyRule.java
index e3b5c8e7b7..2d7b8c6c67 100644
--- a/java/org/apache/tomcat/util/digester/SetPropertiesRule.java
+++ b/java/org/apache/tomcat/util/digester/SetPropertiesRule.java
@@ -1,10 +1,11 @@
 /* $Id: SetPropertiesRule.java 299475 2004-06-26 17:41:32Z remm $
  *
- * Copyright 2001-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SetRootRule.java
index d898a8174c..1aab6c732f 100644
--- a/java/org/apache/tomcat/util/digester/SetPropertyRule.java
+++ b/java/org/apache/tomcat/util/digester/SetPropertyRule.java
@@ -1,10 +1,11 @@
 /* $Id: SetPropertyRule.java 299475 2004-06-26 17:41:32Z remm $
  *
- * Copyright 2001-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
SetTopRule.java
index 5b0441512b..2f47eae765 100644
--- a/java/org/apache/tomcat/util/digester/SetRootRule.java
+++ b/java/org/apache/tomcat/util/digester/SetRootRule.java
@@ -1,10 +1,11 @@
 /* $Id: SetRootRule.java 299475 2004-06-26 17:41:32Z remm $
  *
- * Copyright 2002-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
WithDefaultsRulesWrapper.java
index 584c59aa7a..32d169545d 100644
--- a/java/org/apache/tomcat/util/digester/SetTopRule.java
+++ b/java/org/apache/tomcat/util/digester/SetTopRule.java
@@ -1,10 +1,11 @@
 /* $Id: SetTopRule.java 299475 2004-06-26 17:41:32Z remm $
  *
- * Copyright 2001-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
XercesParser.java
index 1cc304ff2d..e8e0684ed3 100644
--- a/java/org/apache/tomcat/util/digester/WithDefaultsRulesWrapper.java
+++ b/java/org/apache/tomcat/util/digester/WithDefaultsRulesWrapper.java
@@ -1,10 +1,11 @@
 /* $Id: WithDefaultsRulesWrapper.java 299475 2004-06-26 17:41:32Z remm $
  *
- * Copyright 2003-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
AcceptLanguage.java
index 9b1efd5842..6a64ae4757 100644
--- a/java/org/apache/tomcat/util/digester/XercesParser.java
+++ b/java/org/apache/tomcat/util/digester/XercesParser.java
@@ -1,10 +1,11 @@
 /* $Id: XercesParser.java 299768 2004-09-02 00:48:12Z yoavs $
  *
- * Copyright 2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
BaseRequest.java
index 9b02439399..061f24954f 100644
--- a/java/org/apache/tomcat/util/http/AcceptLanguage.java
+++ b/java/org/apache/tomcat/util/http/AcceptLanguage.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
ContentType.java
index 86085d1249..1fc018e8f7 100644
--- a/java/org/apache/tomcat/util/http/BaseRequest.java
+++ b/java/org/apache/tomcat/util/http/BaseRequest.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Cookies.java
index b9018da952..404bbee2b8 100644
--- a/java/org/apache/tomcat/util/http/ContentType.java
+++ b/java/org/apache/tomcat/util/http/ContentType.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
FastHttpDateFormat.java
index 64a3d69584..89e58b0b50 100644
--- a/java/org/apache/tomcat/util/http/Cookies.java
+++ b/java/org/apache/tomcat/util/http/Cookies.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
HttpMessages.java
index b51f19d10a..094970d8e1 100644
--- a/java/org/apache/tomcat/util/http/FastHttpDateFormat.java
+++ b/java/org/apache/tomcat/util/http/FastHttpDateFormat.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2006 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
MimeHeaders.java
index 006a3abc79..fc519a9ab1 100644
--- a/java/org/apache/tomcat/util/http/HttpMessages.java
+++ b/java/org/apache/tomcat/util/http/HttpMessages.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
MimeMap.java
index bb0551b656..6f00d4d180 100644
--- a/java/org/apache/tomcat/util/http/MimeHeaders.java
+++ b/java/org/apache/tomcat/util/http/MimeHeaders.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
Parameters.java
index 362e1f0ecc..e377f388ad 100644
--- a/java/org/apache/tomcat/util/http/MimeMap.java
+++ b/java/org/apache/tomcat/util/http/MimeMap.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
ServerCookie.java
index f43d194ddb..91c03e8428 100644
--- a/java/org/apache/tomcat/util/http/Parameters.java
+++ b/java/org/apache/tomcat/util/http/Parameters.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
DefaultFileItem.java
index d3668e32df..26188bc26e 100644
--- a/java/org/apache/tomcat/util/http/ServerCookie.java
+++ b/java/org/apache/tomcat/util/http/ServerCookie.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
DefaultFileItemFactory.java
index 805b6d0a1e..2e492e9c23 100644
--- a/java/org/apache/tomcat/util/http/fileupload/DefaultFileItem.java
+++ b/java/org/apache/tomcat/util/http/fileupload/DefaultFileItem.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2001-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
DeferredFileOutputStream.java
index b710a0a675..75e6436291 100644
--- a/java/org/apache/tomcat/util/http/fileupload/DefaultFileItemFactory.java
+++ b/java/org/apache/tomcat/util/http/fileupload/DefaultFileItemFactory.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2001-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
DiskFileUpload.java
index 79c1fe7586..ccd97c1ac2 100644
--- a/java/org/apache/tomcat/util/http/fileupload/DeferredFileOutputStream.java
+++ b/java/org/apache/tomcat/util/http/fileupload/DeferredFileOutputStream.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2001-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
FileItem.java
index 5b1bac9d86..12288ac317 100644
--- a/java/org/apache/tomcat/util/http/fileupload/DiskFileUpload.java
+++ b/java/org/apache/tomcat/util/http/fileupload/DiskFileUpload.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2001-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
FileItemFactory.java
index 5edecda932..c0a475a912 100644
--- a/java/org/apache/tomcat/util/http/fileupload/FileItem.java
+++ b/java/org/apache/tomcat/util/http/fileupload/FileItem.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2001-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
FileUpload.java
index b85dbe8bff..030013720f 100644
--- a/java/org/apache/tomcat/util/http/fileupload/FileItemFactory.java
+++ b/java/org/apache/tomcat/util/http/fileupload/FileItemFactory.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2001-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
FileUploadBase.java
index af4dfd8b0f..7e1b082177 100644
--- a/java/org/apache/tomcat/util/http/fileupload/FileUpload.java
+++ b/java/org/apache/tomcat/util/http/fileupload/FileUpload.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2001-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
FileUploadException.java
index 1bfa3780d4..04a01761c9 100644
--- a/java/org/apache/tomcat/util/http/fileupload/FileUploadBase.java
+++ b/java/org/apache/tomcat/util/http/fileupload/FileUploadBase.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2001-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
MultipartStream.java
index bbb21db609..c8bcc00218 100644
--- a/java/org/apache/tomcat/util/http/fileupload/FileUploadException.java
+++ b/java/org/apache/tomcat/util/http/fileupload/FileUploadException.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2001-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ThresholdingOutputStream.java
index 97a22d1e3c..5562a3807c 100644
--- a/java/org/apache/tomcat/util/http/fileupload/MultipartStream.java
+++ b/java/org/apache/tomcat/util/http/fileupload/MultipartStream.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2001-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Mapper.java
index f068c89d66..e5b6d32a7e 100644
--- a/java/org/apache/tomcat/util/http/fileupload/ThresholdingOutputStream.java
+++ b/java/org/apache/tomcat/util/http/fileupload/ThresholdingOutputStream.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2001-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
MappingData.java
index 7ee3bd43ab..6bd3c7df61 100644
--- a/java/org/apache/tomcat/util/http/mapper/Mapper.java
+++ b/java/org/apache/tomcat/util/http/mapper/Mapper.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
CaptureLog.java
index 13bf7a4393..2d764857bf 100644
--- a/java/org/apache/tomcat/util/http/mapper/MappingData.java
+++ b/java/org/apache/tomcat/util/http/mapper/MappingData.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
SystemLogHandler.java
index 51dfee7dc9..5e5be43aaa 100644
--- a/java/org/apache/tomcat/util/log/CaptureLog.java
+++ b/java/org/apache/tomcat/util/log/CaptureLog.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
AttributeInfo.java
index 255aacfd9b..4464487a7c 100644
--- a/java/org/apache/tomcat/util/log/SystemLogHandler.java
+++ b/java/org/apache/tomcat/util/log/SystemLogHandler.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
BaseAttributeFilter.java
index 8bd35adb43..5819b53ea1 100644
--- a/java/org/apache/tomcat/util/modeler/AttributeInfo.java
+++ b/java/org/apache/tomcat/util/modeler/AttributeInfo.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
BaseModelMBean.java
index c23a41d4b2..b9eca5cae5 100644
--- a/java/org/apache/tomcat/util/modeler/BaseAttributeFilter.java
+++ b/java/org/apache/tomcat/util/modeler/BaseAttributeFilter.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
BaseNotificationBroadcaster.java
index 17f744cee3..3924f10404 100644
--- a/java/org/apache/tomcat/util/modeler/BaseModelMBean.java
+++ b/java/org/apache/tomcat/util/modeler/BaseModelMBean.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ConstructorInfo.java
index e475896a87..31b54a74a3 100644
--- a/java/org/apache/tomcat/util/modeler/BaseNotificationBroadcaster.java
+++ b/java/org/apache/tomcat/util/modeler/BaseNotificationBroadcaster.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
FeatureInfo.java
index 48aa3f3d53..61e472e481 100644
--- a/java/org/apache/tomcat/util/modeler/ConstructorInfo.java
+++ b/java/org/apache/tomcat/util/modeler/ConstructorInfo.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
FixedNotificationFilter.java
index 2d17ae8620..7dedc87cad 100644
--- a/java/org/apache/tomcat/util/modeler/FeatureInfo.java
+++ b/java/org/apache/tomcat/util/modeler/FeatureInfo.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ManagedBean.java
index 50c1ec41a3..a08806f24f 100644
--- a/java/org/apache/tomcat/util/modeler/FixedNotificationFilter.java
+++ b/java/org/apache/tomcat/util/modeler/FixedNotificationFilter.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
NotificationInfo.java
index 85246ad269..9d7c55b3e6 100644
--- a/java/org/apache/tomcat/util/modeler/ManagedBean.java
+++ b/java/org/apache/tomcat/util/modeler/ManagedBean.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
OperationInfo.java
index e6b026f467..c685896bfe 100644
--- a/java/org/apache/tomcat/util/modeler/NotificationInfo.java
+++ b/java/org/apache/tomcat/util/modeler/NotificationInfo.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ParameterInfo.java
index db2da015ca..cf9ec62eee 100644
--- a/java/org/apache/tomcat/util/modeler/OperationInfo.java
+++ b/java/org/apache/tomcat/util/modeler/OperationInfo.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
Registry.java
index c8e987190e..003d14173a 100644
--- a/java/org/apache/tomcat/util/modeler/ParameterInfo.java
+++ b/java/org/apache/tomcat/util/modeler/ParameterInfo.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
RegistryMBean.java
index 755f3e78d9..b02b5575b3 100644
--- a/java/org/apache/tomcat/util/modeler/Registry.java
+++ b/java/org/apache/tomcat/util/modeler/Registry.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2001-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
MbeansDescriptorsDOMSource.java
index 35c971b913..4b135c7680 100644
--- a/java/org/apache/tomcat/util/modeler/RegistryMBean.java
+++ b/java/org/apache/tomcat/util/modeler/RegistryMBean.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
MbeansDescriptorsDigesterSource.java
index de8ee7d6ac..b58e5b3ece 100644
--- a/java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsDOMSource.java
+++ b/java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsDOMSource.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
MbeansDescriptorsIntrospectionSource.java
index 05364318c8..ca103fe5d8 100644
--- a/java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsDigesterSource.java
+++ b/java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsDigesterSource.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
AprEndpoint.java
index 8d4a882bc2..f9331b9f0d 100644
--- a/java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsIntrospectionSource.java
+++ b/java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsIntrospectionSource.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
BaseEndpoint.java
index f898b92459..07fbf42e25 100644
--- a/java/org/apache/tomcat/util/net/AprEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AprEndpoint.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2005-2006 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
DefaultServerSocketFactory.java
index e19eba0815..23ccde0be9 100644
--- a/java/org/apache/tomcat/util/net/BaseEndpoint.java
+++ b/java/org/apache/tomcat/util/net/BaseEndpoint.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2005-2006 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
JIoEndpoint.java
index d6c56c1a9d..38b606d1fa 100644
--- a/java/org/apache/tomcat/util/net/DefaultServerSocketFactory.java
+++ b/java/org/apache/tomcat/util/net/DefaultServerSocketFactory.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
LeaderFollowerWorkerThread.java
index 4a5b74b83c..1e10d6cf0e 100644
--- a/java/org/apache/tomcat/util/net/JIoEndpoint.java
+++ b/java/org/apache/tomcat/util/net/JIoEndpoint.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2006 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
MasterSlaveWorkerThread.java
index 386e43fcdf..8d2f65bec6 100644
--- a/java/org/apache/tomcat/util/net/LeaderFollowerWorkerThread.java
+++ b/java/org/apache/tomcat/util/net/LeaderFollowerWorkerThread.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
NioChannel.java
index 9d35fa7cca..c1cfa10d10 100644
--- a/java/org/apache/tomcat/util/net/MasterSlaveWorkerThread.java
+++ b/java/org/apache/tomcat/util/net/MasterSlaveWorkerThread.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
NioEndpoint.java
index c7c3b8145e..e839e6b3a5 100644
--- a/java/org/apache/tomcat/util/net/NioChannel.java
+++ b/java/org/apache/tomcat/util/net/NioChannel.java
@@ -1,173 +1,174 @@
-/*
- *  Copyright 2005-2006 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.util.net;
-
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.channels.ByteChannel;
-import java.nio.channels.SocketChannel;
-
-import org.apache.tomcat.util.net.NioEndpoint.Poller;
-import org.apache.tomcat.util.net.SecureNioChannel.ApplicationBufferHandler;
-
-/**
- * 
- * Base class for a SocketChannel wrapper used by the endpoint.
- * This way, logic for a SSL socket channel remains the same as for
- * a non SSL, making sure we don't need to code for any exception cases.
- * 
- * @author Filip Hanik
- * @version 1.0
- */
-public class NioChannel implements ByteChannel{
-    
-    protected static ByteBuffer emptyBuf = ByteBuffer.allocate(0);
-
-    protected SocketChannel sc = null;
-
-    protected ApplicationBufferHandler bufHandler;
-    
-    protected Poller poller;
-
-    public NioChannel(SocketChannel channel, ApplicationBufferHandler bufHandler) throws IOException {
-        this.sc = channel;
-        this.bufHandler = bufHandler;
-    }
-    
-    public void reset() throws IOException {
-        bufHandler.getReadBuffer().clear();
-        bufHandler.getWriteBuffer().clear();
-    }
-
-    /**
-     * returns true if the network buffer has 
-     * been flushed out and is empty
-     * @return boolean
-     */
-    public boolean flush() throws IOException {
-        return true; //no network buffer in the regular channel
-    }
-
-
-    /**
-     * Closes this channel.
-     *
-     * @throws IOException If an I/O error occurs
-     * @todo Implement this java.nio.channels.Channel method
-     */
-    public void close() throws IOException {
-        getIOChannel().socket().close();
-        sc.close();
-    }
-
-    public void close(boolean force) throws IOException {
-        if (isOpen() || force ) close();
-    }
-    /**
-     * Tells whether or not this channel is open.
-     *
-     * @return <tt>true</tt> if, and only if, this channel is open
-     * @todo Implement this java.nio.channels.Channel method
-     */
-    public boolean isOpen() {
-        return sc.isOpen();
-    }
-
-    /**
-     * Writes a sequence of bytes to this channel from the given buffer.
-     *
-     * @param src The buffer from which bytes are to be retrieved
-     * @return The number of bytes written, possibly zero
-     * @throws IOException If some other I/O error occurs
-     * @todo Implement this java.nio.channels.WritableByteChannel method
-     */
-    public int write(ByteBuffer src) throws IOException {
-        return sc.write(src);
-    }
-
-    /**
-     * Reads a sequence of bytes from this channel into the given buffer.
-     *
-     * @param dst The buffer into which bytes are to be transferred
-     * @return The number of bytes read, possibly zero, or <tt>-1</tt> if the channel has reached end-of-stream
-     * @throws IOException If some other I/O error occurs
-     * @todo Implement this java.nio.channels.ReadableByteChannel method
-     */
-    public int read(ByteBuffer dst) throws IOException {
-        return sc.read(dst);
-    }
-
-
-    /**
-     * getBufHandler
-     *
-     * @return ApplicationBufferHandler
-     * @todo Implement this org.apache.tomcat.util.net.SecureNioChannel method
-     */
-    public ApplicationBufferHandler getBufHandler() {
-        return bufHandler;
-    }
-
-    public Poller getPoller() {
-        return poller;
-    }
-    /**
-     * getIOChannel
-     *
-     * @return SocketChannel
-     * @todo Implement this org.apache.tomcat.util.net.SecureNioChannel method
-     */
-    public SocketChannel getIOChannel() {
-        return sc;
-    }
-
-    /**
-     * isClosing
-     *
-     * @return boolean
-     * @todo Implement this org.apache.tomcat.util.net.SecureNioChannel method
-     */
-    public boolean isClosing() {
-        return false;
-    }
-
-    /**
-     * isInitHandshakeComplete
-     *
-     * @return boolean
-     * @todo Implement this org.apache.tomcat.util.net.SecureNioChannel method
-     */
-    public boolean isInitHandshakeComplete() {
-        return true;
-    }
-    
-    public int handshake(boolean read, boolean write) throws IOException {
-        return 0;
-    }
-
-    public void setPoller(Poller poller) {
-        this.poller = poller;
-    }
-
-    public void setIOChannel(SocketChannel IOChannel) {
-        this.sc = IOChannel;
-    }
-
-    public String toString() {
-        return super.toString()+":"+this.sc.toString();
-    }
-
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.tomcat.util.net;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.ByteChannel;
+import java.nio.channels.SocketChannel;
+
+import org.apache.tomcat.util.net.NioEndpoint.Poller;
+import org.apache.tomcat.util.net.SecureNioChannel.ApplicationBufferHandler;
+
+/**
+ * 
+ * Base class for a SocketChannel wrapper used by the endpoint.
+ * This way, logic for a SSL socket channel remains the same as for
+ * a non SSL, making sure we don't need to code for any exception cases.
+ * 
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class NioChannel implements ByteChannel{
+    
+    protected static ByteBuffer emptyBuf = ByteBuffer.allocate(0);
+
+    protected SocketChannel sc = null;
+
+    protected ApplicationBufferHandler bufHandler;
+    
+    protected Poller poller;
+
+    public NioChannel(SocketChannel channel, ApplicationBufferHandler bufHandler) throws IOException {
+        this.sc = channel;
+        this.bufHandler = bufHandler;
+    }
+    
+    public void reset() throws IOException {
+        bufHandler.getReadBuffer().clear();
+        bufHandler.getWriteBuffer().clear();
+    }
+
+    /**
+     * returns true if the network buffer has 
+     * been flushed out and is empty
+     * @return boolean
+     */
+    public boolean flush() throws IOException {
+        return true; //no network buffer in the regular channel
+    }
+
+
+    /**
+     * Closes this channel.
+     *
+     * @throws IOException If an I/O error occurs
+     * @todo Implement this java.nio.channels.Channel method
+     */
+    public void close() throws IOException {
+        getIOChannel().socket().close();
+        sc.close();
+    }
+
+    public void close(boolean force) throws IOException {
+        if (isOpen() || force ) close();
+    }
+    /**
+     * Tells whether or not this channel is open.
+     *
+     * @return <tt>true</tt> if, and only if, this channel is open
+     * @todo Implement this java.nio.channels.Channel method
+     */
+    public boolean isOpen() {
+        return sc.isOpen();
+    }
+
+    /**
+     * Writes a sequence of bytes to this channel from the given buffer.
+     *
+     * @param src The buffer from which bytes are to be retrieved
+     * @return The number of bytes written, possibly zero
+     * @throws IOException If some other I/O error occurs
+     * @todo Implement this java.nio.channels.WritableByteChannel method
+     */
+    public int write(ByteBuffer src) throws IOException {
+        return sc.write(src);
+    }
+
+    /**
+     * Reads a sequence of bytes from this channel into the given buffer.
+     *
+     * @param dst The buffer into which bytes are to be transferred
+     * @return The number of bytes read, possibly zero, or <tt>-1</tt> if the channel has reached end-of-stream
+     * @throws IOException If some other I/O error occurs
+     * @todo Implement this java.nio.channels.ReadableByteChannel method
+     */
+    public int read(ByteBuffer dst) throws IOException {
+        return sc.read(dst);
+    }
+
+
+    /**
+     * getBufHandler
+     *
+     * @return ApplicationBufferHandler
+     * @todo Implement this org.apache.tomcat.util.net.SecureNioChannel method
+     */
+    public ApplicationBufferHandler getBufHandler() {
+        return bufHandler;
+    }
+
+    public Poller getPoller() {
+        return poller;
+    }
+    /**
+     * getIOChannel
+     *
+     * @return SocketChannel
+     * @todo Implement this org.apache.tomcat.util.net.SecureNioChannel method
+     */
+    public SocketChannel getIOChannel() {
+        return sc;
+    }
+
+    /**
+     * isClosing
+     *
+     * @return boolean
+     * @todo Implement this org.apache.tomcat.util.net.SecureNioChannel method
+     */
+    public boolean isClosing() {
+        return false;
+    }
+
+    /**
+     * isInitHandshakeComplete
+     *
+     * @return boolean
+     * @todo Implement this org.apache.tomcat.util.net.SecureNioChannel method
+     */
+    public boolean isInitHandshakeComplete() {
+        return true;
+    }
+    
+    public int handshake(boolean read, boolean write) throws IOException {
+        return 0;
+    }
+
+    public void setPoller(Poller poller) {
+        this.poller = poller;
+    }
+
+    public void setIOChannel(SocketChannel IOChannel) {
+        this.sc = IOChannel;
+    }
+
+    public String toString() {
+        return super.toString()+":"+this.sc.toString();
+    }
+
 }
\ No newline at end of file

==================================================
PoolTcpEndpoint.java
index cccfbbafdd..79e2343211 100644
--- a/java/org/apache/tomcat/util/net/NioEndpoint.java
+++ b/java/org/apache/tomcat/util/net/NioEndpoint.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2005-2006 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
SSLImplementation.java
index b7084db1f1..c356b5bc93 100644
--- a/java/org/apache/tomcat/util/net/PoolTcpEndpoint.java
+++ b/java/org/apache/tomcat/util/net/PoolTcpEndpoint.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
SSLSupport.java
index 3dfb916b9e..ffc6cefc9e 100644
--- a/java/org/apache/tomcat/util/net/SSLImplementation.java
+++ b/java/org/apache/tomcat/util/net/SSLImplementation.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
ServerSocketFactory.java
index 3bfded159e..acc210cbf3 100644
--- a/java/org/apache/tomcat/util/net/SSLSupport.java
+++ b/java/org/apache/tomcat/util/net/SSLSupport.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
SocketStatus.java
index bfb5d80648..00392a58e8 100644
--- a/java/org/apache/tomcat/util/net/ServerSocketFactory.java
+++ b/java/org/apache/tomcat/util/net/ServerSocketFactory.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
TcpConnection.java
index 587c1a2bb2..58ee7f11f4 100644
--- a/java/org/apache/tomcat/util/net/SocketStatus.java
+++ b/java/org/apache/tomcat/util/net/SocketStatus.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 2006 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
TcpConnectionHandler.java
index 027e28f10e..c4b3963d6d 100644
--- a/java/org/apache/tomcat/util/net/TcpConnection.java
+++ b/java/org/apache/tomcat/util/net/TcpConnection.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
URL.java
index f2e6008b62..b9096d4ca6 100644
--- a/java/org/apache/tomcat/util/net/TcpConnectionHandler.java
+++ b/java/org/apache/tomcat/util/net/TcpConnectionHandler.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
JSSEFactory.java
index f6e6f18377..e264d6343f 100644
--- a/java/org/apache/tomcat/util/net/URL.java
+++ b/java/org/apache/tomcat/util/net/URL.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
JSSEImplementation.java
index b3a81ea89b..1a020872d0 100644
--- a/java/org/apache/tomcat/util/net/jsse/JSSEFactory.java
+++ b/java/org/apache/tomcat/util/net/jsse/JSSEFactory.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
JSSEKeyManager.java
index 2a0c8cb33c..e0598393f7 100644
--- a/java/org/apache/tomcat/util/net/jsse/JSSEImplementation.java
+++ b/java/org/apache/tomcat/util/net/jsse/JSSEImplementation.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
JSSESocketFactory.java
index 5034f593bc..7b82696ca1 100644
--- a/java/org/apache/tomcat/util/net/jsse/JSSEKeyManager.java
+++ b/java/org/apache/tomcat/util/net/jsse/JSSEKeyManager.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
JSSESupport.java
index 6566a10bb1..df13bd7283 100644
--- a/java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java
+++ b/java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
PureTLSImplementation.java
index f009a39184..3f4ab0f008 100644
--- a/java/org/apache/tomcat/util/net/jsse/JSSESupport.java
+++ b/java/org/apache/tomcat/util/net/jsse/JSSESupport.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
PureTLSSocket.java
index 2d88a2a2bf..de2ea16e70 100644
--- a/java/org/apache/tomcat/util/net/puretls/PureTLSImplementation.java
+++ b/java/org/apache/tomcat/util/net/puretls/PureTLSImplementation.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
PureTLSSocketFactory.java
index bb5d6b9d07..924f2c8fb1 100644
--- a/java/org/apache/tomcat/util/net/puretls/PureTLSSocket.java
+++ b/java/org/apache/tomcat/util/net/puretls/PureTLSSocket.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
PureTLSSupport.java
index ca503489ad..16305d2c00 100644
--- a/java/org/apache/tomcat/util/net/puretls/PureTLSSocketFactory.java
+++ b/java/org/apache/tomcat/util/net/puretls/PureTLSSocketFactory.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
StringManager.java
index 3c29e7b147..52a5129e0d 100644
--- a/java/org/apache/tomcat/util/net/puretls/PureTLSSupport.java
+++ b/java/org/apache/tomcat/util/net/puretls/PureTLSSupport.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
ThreadPool.java
index 626407e605..dba3ea2a02 100644
--- a/java/org/apache/tomcat/util/res/StringManager.java
+++ b/java/org/apache/tomcat/util/res/StringManager.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
ThreadPoolRunnable.java
index 3715dcdc02..85112034db 100644
--- a/java/org/apache/tomcat/util/threads/ThreadPool.java
+++ b/java/org/apache/tomcat/util/threads/ThreadPool.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2005 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
ThreadWithAttributes.java
index 324e13b62c..c4159882a0 100644
--- a/java/org/apache/tomcat/util/threads/ThreadPoolRunnable.java
+++ b/java/org/apache/tomcat/util/threads/ThreadPoolRunnable.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
ChannelCreator.java
index 33713fd73c..6297a20456 100644
--- a/native/connector/src/user.c
+++ b/native/connector/src/user.c
@@ -1,8 +1,9 @@
-/* Copyright 2000-2005 The Apache Software Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+/* Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
IntrospectionUtils.java
index 076505b2b0..6310e767cc 100644
--- a/test/org/apache/catalina/tribes/demos/ChannelCreator.java
+++ b/test/org/apache/catalina/tribes/demos/ChannelCreator.java
@@ -1,253 +1,254 @@
-/*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.demos;
-
-import java.util.Iterator;
-import java.util.Properties;
-
-import org.apache.catalina.tribes.Channel;
-import org.apache.catalina.tribes.ManagedChannel;
-import org.apache.catalina.tribes.group.GroupChannel;
-import org.apache.catalina.tribes.group.interceptors.FragmentationInterceptor;
-import org.apache.catalina.tribes.group.interceptors.GzipInterceptor;
-import org.apache.catalina.tribes.group.interceptors.MessageDispatchInterceptor;
-import org.apache.catalina.tribes.group.interceptors.OrderInterceptor;
-import org.apache.catalina.tribes.membership.McastService;
-import org.apache.catalina.tribes.transport.MultiPointSender;
-import org.apache.catalina.tribes.transport.ReceiverBase;
-import org.apache.catalina.tribes.transport.ReplicationTransmitter;
-import org.apache.catalina.tribes.group.interceptors.ThroughputInterceptor;
-import org.apache.catalina.tribes.group.interceptors.MessageDispatch15Interceptor;
-import org.apache.catalina.tribes.group.interceptors.TcpFailureDetector;
-import org.apache.catalina.tribes.group.interceptors.DomainFilterInterceptor;
-import java.util.ArrayList;
-import org.apache.catalina.tribes.membership.MemberImpl;
-import org.apache.catalina.tribes.group.interceptors.StaticMembershipInterceptor;
-import org.apache.catalina.tribes.Member;
-
-/**
- * <p>Title: </p>
- *
- * <p>Description: </p>
- *
- *
- * <p>Company: </p>
- *
- * @author fhanik
- * @version 1.0
- */
-public class ChannelCreator {
-    
-    org.apache.commons.logging.impl.LogFactoryImpl impl=null;
-    public static StringBuffer usage() {
-        StringBuffer buf = new StringBuffer();
-        buf.append("\n\t\t[-bind tcpbindaddress]")
-           .append("\n\t\t[-tcpselto tcpselectortimeout]") 
-           .append("\n\t\t[-tcpthreads tcpthreadcount]") 
-           .append("\n\t\t[-port tcplistenport]")
-           .append("\n\t\t[-autobind tcpbindtryrange]")
-           .append("\n\t\t[-ackto acktimeout]") 
-           .append("\n\t\t[-receiver org.apache.catalina.tribes.transport.nio.NioReceiver|org.apache.catalina.tribes.transport.bio.BioReceiver|]")
-           .append("\n\t\t[-transport org.apache.catalina.tribes.transport.nio.PooledParallelSender|org.apache.catalina.tribes.transport.bio.PooledMultiSender]")
-           .append("\n\t\t[-transport.xxx transport specific property]")
-           .append("\n\t\t[-maddr multicastaddr]")
-           .append("\n\t\t[-mport multicastport]")
-           .append("\n\t\t[-mbind multicastbindaddr]")
-           .append("\n\t\t[-mfreq multicastfrequency]")
-           .append("\n\t\t[-mdrop multicastdroptime]")
-           .append("\n\t\t[-gzip]")
-           .append("\n\t\t[-static hostname:port (-static localhost:9999 -static 127.0.0.1:8888 can be repeated)]")
-           .append("\n\t\t[-order]")
-           .append("\n\t\t[-ordersize maxorderqueuesize]")
-           .append("\n\t\t[-frag]")
-           .append("\n\t\t[-fragsize maxmsgsize]")
-           .append("\n\t\t[-throughput]")
-           .append("\n\t\t[-failuredetect]")
-           .append("\n\t\t[-async]")
-           .append("\n\t\t[-asyncsize maxqueuesizeinkilobytes]");
-       return buf;
-
-    }
-
-    public static Channel createChannel(String[] args) throws Exception {
-        String bind = "auto";
-        int port = 4001;
-        String mbind = null;
-        boolean gzip = false;
-        int tcpseltimeout = 5000;
-        int tcpthreadcount = 4;
-        int acktimeout = 15000;
-        String mcastaddr = "228.0.0.5";
-        int mcastport = 45565;
-        long mcastfreq = 500;
-        long mcastdrop = 2000;
-        boolean order = false;
-        int ordersize = Integer.MAX_VALUE;
-        boolean frag = false;
-        int fragsize = 1024;
-        int autoBind = 10;
-        ArrayList staticMembers = new ArrayList();
-        Properties transportProperties = new Properties();
-        String transport = "org.apache.catalina.tribes.transport.nio.PooledParallelSender";
-        String receiver = "org.apache.catalina.tribes.transport.nio.NioReceiver";
-        boolean async = false;
-        int asyncsize = 1024*1024*50; //50MB
-        boolean throughput = false;
-        boolean failuredetect = false;
-        
-        for (int i = 0; i < args.length; i++) {
-            if ("-bind".equals(args[i])) {
-                bind = args[++i];
-            } else if ("-port".equals(args[i])) {
-                port = Integer.parseInt(args[++i]);
-            } else if ("-autobind".equals(args[i])) {
-                autoBind = Integer.parseInt(args[++i]);
-            } else if ("-tcpselto".equals(args[i])) {
-                tcpseltimeout = Integer.parseInt(args[++i]);
-            } else if ("-tcpthreads".equals(args[i])) {
-                tcpthreadcount = Integer.parseInt(args[++i]);
-            } else if ("-gzip".equals(args[i])) {
-                gzip = true;
-            } else if ("-async".equals(args[i])) {
-                async = true;
-            } else if ("-failuredetect".equals(args[i])) {
-                failuredetect = true;
-            } else if ("-asyncsize".equals(args[i])) {
-                asyncsize = Integer.parseInt(args[++i]);
-                System.out.println("Setting MessageDispatchInterceptor.maxQueueSize="+asyncsize);
-            } else if ("-static".equals(args[i])) {
-                String d = args[++i];
-                String h = d.substring(0,d.indexOf(":"));
-                String p = d.substring(h.length()+1);
-                MemberImpl m = new MemberImpl(h,Integer.parseInt(p),2000);
-                staticMembers.add(m);
-            } else if ("-throughput".equals(args[i])) {
-                throughput = true;
-            } else if ("-order".equals(args[i])) {
-                order = true;
-            } else if ("-ordersize".equals(args[i])) {
-                ordersize = Integer.parseInt(args[++i]);
-                System.out.println("Setting OrderInterceptor.maxQueue="+ordersize);
-            } else if ("-frag".equals(args[i])) {
-                frag = true;
-            } else if ("-fragsize".equals(args[i])) {
-                fragsize = Integer.parseInt(args[++i]);
-                System.out.println("Setting FragmentationInterceptor.maxSize="+fragsize);
-            } else if ("-ackto".equals(args[i])) {
-                acktimeout = Integer.parseInt(args[++i]);
-            } else if ("-transport".equals(args[i])) {
-                transport = args[++i];
-            } else if (args[i]!=null && args[i].startsWith("transport.")) {
-                String key = args[i];
-                String val = args[++i];
-                transportProperties.setProperty(key,val);
-            } else if ("-receiver".equals(args[i])) {
-                receiver = args[++i];
-            } else if ("-maddr".equals(args[i])) {
-                mcastaddr = args[++i];
-            } else if ("-mport".equals(args[i])) {
-                mcastport = Integer.parseInt(args[++i]);
-            } else if ("-mfreq".equals(args[i])) {
-                mcastfreq = Long.parseLong(args[++i]);
-            } else if ("-mdrop".equals(args[i])) {
-                mcastdrop = Long.parseLong(args[++i]);
-            } else if ("-mbind".equals(args[i])) {
-                mbind = args[++i];
-            }
-        }
-        
-        System.out.println("Creating receiver class="+receiver);
-        Class cl = Class.forName(receiver,true,ChannelCreator.class.getClassLoader());
-        ReceiverBase rx = (ReceiverBase)cl.newInstance();
-        rx.setTcpListenAddress(bind);
-        rx.setTcpListenPort(port);
-        rx.setTcpSelectorTimeout(tcpseltimeout);
-        rx.setTcpThreadCount(tcpthreadcount);
-        rx.getBind();
-        rx.setRxBufSize(43800);
-        rx.setTxBufSize(25188);
-        rx.setAutoBind(autoBind);
-
-        
-        ReplicationTransmitter ps = new ReplicationTransmitter();
-        System.out.println("Creating transport class="+transport);
-        MultiPointSender sender = (MultiPointSender)Class.forName(transport,true,ChannelCreator.class.getClassLoader()).newInstance();
-        sender.setTimeout(acktimeout);
-        sender.setMaxRetryAttempts(2);
-        sender.setRxBufSize(43800);
-        sender.setTxBufSize(25188);
-
-        Iterator i = transportProperties.keySet().iterator();
-        while ( i.hasNext() ) {
-            String key = (String)i.next();
-            IntrospectionUtils.setProperty(sender,key,transportProperties.getProperty(key));
-        }
-        ps.setTransport(sender);
-
-        McastService service = new McastService();
-        service.setMcastAddr(mcastaddr);
-        if (mbind != null) service.setMcastBindAddress(mbind);
-        service.setMcastFrequency(mcastfreq);
-        service.setMcastDropTime(mcastdrop);
-        service.setMcastPort(mcastport);
-
-        ManagedChannel channel = new GroupChannel();
-        channel.setChannelReceiver(rx);
-        channel.setChannelSender(ps);
-        channel.setMembershipService(service);
-        
-        if ( throughput ) channel.addInterceptor(new ThroughputInterceptor());
-        if (gzip) channel.addInterceptor(new GzipInterceptor());
-        if ( frag ) {
-            FragmentationInterceptor fi = new FragmentationInterceptor();
-            fi.setMaxSize(fragsize);
-            channel.addInterceptor(fi);
-        }
-        if (order) {
-            OrderInterceptor oi = new OrderInterceptor();
-            oi.setMaxQueue(ordersize);
-            channel.addInterceptor(oi);
-        }
-        
-        if ( async ) {
-            MessageDispatchInterceptor mi = new MessageDispatch15Interceptor();
-            mi.setMaxQueueSize(asyncsize);
-            channel.addInterceptor(mi);
-            System.out.println("Added MessageDispatchInterceptor");
-        }
-        
-        if ( failuredetect ) {
-            TcpFailureDetector tcpfi = new TcpFailureDetector();
-            channel.addInterceptor(tcpfi);
-        }
-        if ( staticMembers.size() > 0 ) {
-            StaticMembershipInterceptor smi = new StaticMembershipInterceptor();
-            for (int x=0; x<staticMembers.size(); x++ ) {
-                smi.addStaticMember((Member)staticMembers.get(x));
-            }
-            channel.addInterceptor(smi);
-        }
-
-
-        byte[] domain = new byte[] {1,2,3,4,5,6,7,8,9,0};
-        ((McastService)channel.getMembershipService()).setDomain(domain);
-        DomainFilterInterceptor filter = new DomainFilterInterceptor();
-        filter.setDomain(domain);
-        channel.addInterceptor(filter);
-        return channel;
-    }
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.demos;
+
+import java.util.Iterator;
+import java.util.Properties;
+
+import org.apache.catalina.tribes.Channel;
+import org.apache.catalina.tribes.ManagedChannel;
+import org.apache.catalina.tribes.group.GroupChannel;
+import org.apache.catalina.tribes.group.interceptors.FragmentationInterceptor;
+import org.apache.catalina.tribes.group.interceptors.GzipInterceptor;
+import org.apache.catalina.tribes.group.interceptors.MessageDispatchInterceptor;
+import org.apache.catalina.tribes.group.interceptors.OrderInterceptor;
+import org.apache.catalina.tribes.membership.McastService;
+import org.apache.catalina.tribes.transport.MultiPointSender;
+import org.apache.catalina.tribes.transport.ReceiverBase;
+import org.apache.catalina.tribes.transport.ReplicationTransmitter;
+import org.apache.catalina.tribes.group.interceptors.ThroughputInterceptor;
+import org.apache.catalina.tribes.group.interceptors.MessageDispatch15Interceptor;
+import org.apache.catalina.tribes.group.interceptors.TcpFailureDetector;
+import org.apache.catalina.tribes.group.interceptors.DomainFilterInterceptor;
+import java.util.ArrayList;
+import org.apache.catalina.tribes.membership.MemberImpl;
+import org.apache.catalina.tribes.group.interceptors.StaticMembershipInterceptor;
+import org.apache.catalina.tribes.Member;
+
+/**
+ * <p>Title: </p>
+ *
+ * <p>Description: </p>
+ *
+ *
+ * <p>Company: </p>
+ *
+ * @author fhanik
+ * @version 1.0
+ */
+public class ChannelCreator {
+    
+    org.apache.commons.logging.impl.LogFactoryImpl impl=null;
+    public static StringBuffer usage() {
+        StringBuffer buf = new StringBuffer();
+        buf.append("\n\t\t[-bind tcpbindaddress]")
+           .append("\n\t\t[-tcpselto tcpselectortimeout]") 
+           .append("\n\t\t[-tcpthreads tcpthreadcount]") 
+           .append("\n\t\t[-port tcplistenport]")
+           .append("\n\t\t[-autobind tcpbindtryrange]")
+           .append("\n\t\t[-ackto acktimeout]") 
+           .append("\n\t\t[-receiver org.apache.catalina.tribes.transport.nio.NioReceiver|org.apache.catalina.tribes.transport.bio.BioReceiver|]")
+           .append("\n\t\t[-transport org.apache.catalina.tribes.transport.nio.PooledParallelSender|org.apache.catalina.tribes.transport.bio.PooledMultiSender]")
+           .append("\n\t\t[-transport.xxx transport specific property]")
+           .append("\n\t\t[-maddr multicastaddr]")
+           .append("\n\t\t[-mport multicastport]")
+           .append("\n\t\t[-mbind multicastbindaddr]")
+           .append("\n\t\t[-mfreq multicastfrequency]")
+           .append("\n\t\t[-mdrop multicastdroptime]")
+           .append("\n\t\t[-gzip]")
+           .append("\n\t\t[-static hostname:port (-static localhost:9999 -static 127.0.0.1:8888 can be repeated)]")
+           .append("\n\t\t[-order]")
+           .append("\n\t\t[-ordersize maxorderqueuesize]")
+           .append("\n\t\t[-frag]")
+           .append("\n\t\t[-fragsize maxmsgsize]")
+           .append("\n\t\t[-throughput]")
+           .append("\n\t\t[-failuredetect]")
+           .append("\n\t\t[-async]")
+           .append("\n\t\t[-asyncsize maxqueuesizeinkilobytes]");
+       return buf;
+
+    }
+
+    public static Channel createChannel(String[] args) throws Exception {
+        String bind = "auto";
+        int port = 4001;
+        String mbind = null;
+        boolean gzip = false;
+        int tcpseltimeout = 5000;
+        int tcpthreadcount = 4;
+        int acktimeout = 15000;
+        String mcastaddr = "228.0.0.5";
+        int mcastport = 45565;
+        long mcastfreq = 500;
+        long mcastdrop = 2000;
+        boolean order = false;
+        int ordersize = Integer.MAX_VALUE;
+        boolean frag = false;
+        int fragsize = 1024;
+        int autoBind = 10;
+        ArrayList staticMembers = new ArrayList();
+        Properties transportProperties = new Properties();
+        String transport = "org.apache.catalina.tribes.transport.nio.PooledParallelSender";
+        String receiver = "org.apache.catalina.tribes.transport.nio.NioReceiver";
+        boolean async = false;
+        int asyncsize = 1024*1024*50; //50MB
+        boolean throughput = false;
+        boolean failuredetect = false;
+        
+        for (int i = 0; i < args.length; i++) {
+            if ("-bind".equals(args[i])) {
+                bind = args[++i];
+            } else if ("-port".equals(args[i])) {
+                port = Integer.parseInt(args[++i]);
+            } else if ("-autobind".equals(args[i])) {
+                autoBind = Integer.parseInt(args[++i]);
+            } else if ("-tcpselto".equals(args[i])) {
+                tcpseltimeout = Integer.parseInt(args[++i]);
+            } else if ("-tcpthreads".equals(args[i])) {
+                tcpthreadcount = Integer.parseInt(args[++i]);
+            } else if ("-gzip".equals(args[i])) {
+                gzip = true;
+            } else if ("-async".equals(args[i])) {
+                async = true;
+            } else if ("-failuredetect".equals(args[i])) {
+                failuredetect = true;
+            } else if ("-asyncsize".equals(args[i])) {
+                asyncsize = Integer.parseInt(args[++i]);
+                System.out.println("Setting MessageDispatchInterceptor.maxQueueSize="+asyncsize);
+            } else if ("-static".equals(args[i])) {
+                String d = args[++i];
+                String h = d.substring(0,d.indexOf(":"));
+                String p = d.substring(h.length()+1);
+                MemberImpl m = new MemberImpl(h,Integer.parseInt(p),2000);
+                staticMembers.add(m);
+            } else if ("-throughput".equals(args[i])) {
+                throughput = true;
+            } else if ("-order".equals(args[i])) {
+                order = true;
+            } else if ("-ordersize".equals(args[i])) {
+                ordersize = Integer.parseInt(args[++i]);
+                System.out.println("Setting OrderInterceptor.maxQueue="+ordersize);
+            } else if ("-frag".equals(args[i])) {
+                frag = true;
+            } else if ("-fragsize".equals(args[i])) {
+                fragsize = Integer.parseInt(args[++i]);
+                System.out.println("Setting FragmentationInterceptor.maxSize="+fragsize);
+            } else if ("-ackto".equals(args[i])) {
+                acktimeout = Integer.parseInt(args[++i]);
+            } else if ("-transport".equals(args[i])) {
+                transport = args[++i];
+            } else if (args[i]!=null && args[i].startsWith("transport.")) {
+                String key = args[i];
+                String val = args[++i];
+                transportProperties.setProperty(key,val);
+            } else if ("-receiver".equals(args[i])) {
+                receiver = args[++i];
+            } else if ("-maddr".equals(args[i])) {
+                mcastaddr = args[++i];
+            } else if ("-mport".equals(args[i])) {
+                mcastport = Integer.parseInt(args[++i]);
+            } else if ("-mfreq".equals(args[i])) {
+                mcastfreq = Long.parseLong(args[++i]);
+            } else if ("-mdrop".equals(args[i])) {
+                mcastdrop = Long.parseLong(args[++i]);
+            } else if ("-mbind".equals(args[i])) {
+                mbind = args[++i];
+            }
+        }
+        
+        System.out.println("Creating receiver class="+receiver);
+        Class cl = Class.forName(receiver,true,ChannelCreator.class.getClassLoader());
+        ReceiverBase rx = (ReceiverBase)cl.newInstance();
+        rx.setTcpListenAddress(bind);
+        rx.setTcpListenPort(port);
+        rx.setTcpSelectorTimeout(tcpseltimeout);
+        rx.setTcpThreadCount(tcpthreadcount);
+        rx.getBind();
+        rx.setRxBufSize(43800);
+        rx.setTxBufSize(25188);
+        rx.setAutoBind(autoBind);
+
+        
+        ReplicationTransmitter ps = new ReplicationTransmitter();
+        System.out.println("Creating transport class="+transport);
+        MultiPointSender sender = (MultiPointSender)Class.forName(transport,true,ChannelCreator.class.getClassLoader()).newInstance();
+        sender.setTimeout(acktimeout);
+        sender.setMaxRetryAttempts(2);
+        sender.setRxBufSize(43800);
+        sender.setTxBufSize(25188);
+
+        Iterator i = transportProperties.keySet().iterator();
+        while ( i.hasNext() ) {
+            String key = (String)i.next();
+            IntrospectionUtils.setProperty(sender,key,transportProperties.getProperty(key));
+        }
+        ps.setTransport(sender);
+
+        McastService service = new McastService();
+        service.setMcastAddr(mcastaddr);
+        if (mbind != null) service.setMcastBindAddress(mbind);
+        service.setMcastFrequency(mcastfreq);
+        service.setMcastDropTime(mcastdrop);
+        service.setMcastPort(mcastport);
+
+        ManagedChannel channel = new GroupChannel();
+        channel.setChannelReceiver(rx);
+        channel.setChannelSender(ps);
+        channel.setMembershipService(service);
+        
+        if ( throughput ) channel.addInterceptor(new ThroughputInterceptor());
+        if (gzip) channel.addInterceptor(new GzipInterceptor());
+        if ( frag ) {
+            FragmentationInterceptor fi = new FragmentationInterceptor();
+            fi.setMaxSize(fragsize);
+            channel.addInterceptor(fi);
+        }
+        if (order) {
+            OrderInterceptor oi = new OrderInterceptor();
+            oi.setMaxQueue(ordersize);
+            channel.addInterceptor(oi);
+        }
+        
+        if ( async ) {
+            MessageDispatchInterceptor mi = new MessageDispatch15Interceptor();
+            mi.setMaxQueueSize(asyncsize);
+            channel.addInterceptor(mi);
+            System.out.println("Added MessageDispatchInterceptor");
+        }
+        
+        if ( failuredetect ) {
+            TcpFailureDetector tcpfi = new TcpFailureDetector();
+            channel.addInterceptor(tcpfi);
+        }
+        if ( staticMembers.size() > 0 ) {
+            StaticMembershipInterceptor smi = new StaticMembershipInterceptor();
+            for (int x=0; x<staticMembers.size(); x++ ) {
+                smi.addStaticMember((Member)staticMembers.get(x));
+            }
+            channel.addInterceptor(smi);
+        }
+
+
+        byte[] domain = new byte[] {1,2,3,4,5,6,7,8,9,0};
+        ((McastService)channel.getMembershipService()).setDomain(domain);
+        DomainFilterInterceptor filter = new DomainFilterInterceptor();
+        filter.setDomain(domain);
+        channel.addInterceptor(filter);
+        return channel;
+    }
+
 }
\ No newline at end of file

==================================================
LoadTest.java
index e200f28a60..1d3dd64b8a 100644
--- a/test/org/apache/catalina/tribes/demos/IntrospectionUtils.java
+++ b/test/org/apache/catalina/tribes/demos/IntrospectionUtils.java
@@ -1,9 +1,10 @@
 /*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *

==================================================
ChannelStartStop.java
index d2f7dc77ce..e9a990ed2a 100644
--- a/test/org/apache/catalina/tribes/demos/LoadTest.java
+++ b/test/org/apache/catalina/tribes/demos/LoadTest.java
@@ -1,424 +1,425 @@
-/*
- * Copyright 1999,2004-2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.demos;
-
-import java.io.Serializable;
-import java.util.Random;
-
-import org.apache.catalina.tribes.ByteMessage;
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelListener;
-import org.apache.catalina.tribes.ManagedChannel;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.MembershipListener;
-import org.apache.catalina.tribes.io.XByteBuffer;
-import org.apache.catalina.tribes.Channel;
-import java.io.Externalizable;
-
-
-/**
- * <p>Title: </p>
- *
- * <p>Description: </p>
- *
- * <p>Copyright: Copyright (c) 2005</p>
- *
- * <p>Company: </p>
- *
- * @author not attributable
- * @version 1.0
- */
-public class LoadTest implements MembershipListener,ChannelListener, Runnable {
-    protected static org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(LoadTest.class);
-    public static int size = 24000;
-    public static Object mutex = new Object();
-    public boolean doRun = true;
-    
-    public long bytesReceived = 0;
-    public float mBytesReceived = 0;
-    public int  messagesReceived = 0;
-    public boolean send = true;
-    public boolean debug = false;
-    public int msgCount = 100;
-    ManagedChannel channel=null;
-    public int statsInterval = 10000;
-    public long pause = 0;
-    public boolean breakonChannelException = false;
-    public boolean async = false;
-    public long receiveStart = 0;
-    public int channelOptions = Channel.SEND_OPTIONS_DEFAULT;
-    
-    static int messageSize = 0;
-    
-    public static long messagesSent = 0;
-    public static long messageStartSendTime = 0;
-    public static long messageEndSendTime = 0;
-    public static int  threadCount = 0;
-    
-    public static synchronized void startTest() {
-        threadCount++;
-        if ( messageStartSendTime == 0 ) messageStartSendTime = System.currentTimeMillis();
-    }
-    
-    public static synchronized void endTest() {
-        threadCount--;
-        if ( messageEndSendTime == 0 && threadCount==0 ) messageEndSendTime = System.currentTimeMillis();
-    }
-
-    
-    public static synchronized long addSendStats(long count) {
-        messagesSent+=count;
-        return 0l;
-    }    
-    
-    private static void printSendStats(long counter, int messageSize) {
-        float cnt = (float)counter;
-        float size = (float)messageSize;
-        float time = (float)(System.currentTimeMillis()-messageStartSendTime) / 1000f;
-        log.info("****SEND STATS-"+Thread.currentThread().getName()+"*****"+
-                 "\n\tMessage count:"+counter+
-                 "\n\tTotal bytes  :"+(long)(size*cnt)+
-                 "\n\tTotal seconds:"+(time)+
-                 "\n\tBytes/second :"+(size*cnt/time)+
-                 "\n\tMBytes/second:"+(size*cnt/time/1024f/1024f));
-    }
-
-    
-    
-    public LoadTest(ManagedChannel channel, 
-                    boolean send,
-                    int msgCount,
-                    boolean debug,
-                    long pause,
-                    int stats,
-                    boolean breakOnEx) {
-        this.channel = channel;
-        this.send = send;
-        this.msgCount = msgCount;
-        this.debug = debug;
-        this.pause = pause;
-        this.statsInterval = stats;
-        this.breakonChannelException = breakOnEx;
-    }
-    
-    
-    
-    public void run() {
-        
-        long counter = 0;
-        long total = 0;
-        LoadMessage msg = new LoadMessage();
-        int messageSize = LoadTest.messageSize;
-        
-        try {
-            startTest();
-            while (total < msgCount) {
-                if (channel.getMembers().length == 0 || (!send)) {
-                    synchronized (mutex) {
-                        try {
-                            mutex.wait();
-                        } catch (InterruptedException x) {
-                            log.info("Thread interrupted from wait");
-                        }
-                    }
-                } else {
-                    try {
-                        //msg.setMsgNr((int)++total);
-                        counter++;
-                        if (debug) {
-                            printArray(msg.getMessage());
-                        }
-                        channel.send(channel.getMembers(), msg, channelOptions);
-                        if ( pause > 0 ) {
-                            if ( debug) System.out.println("Pausing sender for "+pause+" ms.");
-                            Thread.sleep(pause);
-                        }
-                    } catch (ChannelException x) {
-                        if ( debug ) log.error("Unable to send message:"+x.getMessage(),x);
-                        log.error("Unable to send message:"+x.getMessage());
-                        ChannelException.FaultyMember[] faulty = x.getFaultyMembers();
-                        for (int i=0; i<faulty.length; i++ ) log.error("Faulty: "+faulty[i]);
-                        --counter;
-                        if ( this.breakonChannelException ) throw x;
-                    }
-                }
-                if ( (counter % statsInterval) == 0 && (counter > 0)) {
-                    //add to the global counter
-                    counter = addSendStats(counter);
-                    //print from the global counter
-                    //printSendStats(LoadTest.messagesSent, LoadTest.messageSize, LoadTest.messageSendTime);
-                    printSendStats(LoadTest.messagesSent, LoadTest.messageSize);
-                    
-                }
-
-            }
-        }catch ( Exception x ) {
-            log.error("Captured error while sending:"+x.getMessage());
-            if ( debug ) log.error("",x);
-            printSendStats(LoadTest.messagesSent, LoadTest.messageSize);
-        }
-        endTest();
-    }
-
-    
-
-    /**
-     * memberAdded
-     *
-     * @param member Member
-     * @todo Implement this org.apache.catalina.tribes.MembershipListener
-     *   method
-     */
-    public void memberAdded(Member member) {
-        log.info("Member added:"+member);
-        synchronized (mutex) {
-            mutex.notifyAll();
-        }
-    }
-
-    /**
-     * memberDisappeared
-     *
-     * @param member Member
-     * @todo Implement this org.apache.catalina.tribes.MembershipListener
-     *   method
-     */
-    public void memberDisappeared(Member member) {
-        log.info("Member disappeared:"+member);
-    }
-    
-    public boolean accept(Serializable msg, Member mbr){ 
-       return (msg instanceof LoadMessage) || (msg instanceof ByteMessage);
-    }
-    
-    public void messageReceived(Serializable msg, Member mbr){ 
-        if ( receiveStart == 0 ) receiveStart = System.currentTimeMillis();
-        if ( debug ) {
-            if ( msg instanceof LoadMessage ) {
-                printArray(((LoadMessage)msg).getMessage());
-            }
-        }
-        
-        if ( msg instanceof ByteMessage && !(msg instanceof LoadMessage)) {
-            LoadMessage tmp = new LoadMessage();
-            tmp.setMessage(((ByteMessage)msg).getMessage());
-            msg = tmp;
-            tmp = null;
-        }
-        
-        
-        bytesReceived+=((LoadMessage)msg).getMessage().length;
-        mBytesReceived+=((float)((LoadMessage)msg).getMessage().length)/1024f/1024f;
-        messagesReceived++;
-        if ( (messagesReceived%statsInterval)==0 || (messagesReceived==msgCount)) {
-            float bytes = (float)(((LoadMessage)msg).getMessage().length*messagesReceived);
-            float seconds = ((float)(System.currentTimeMillis()-receiveStart)) / 1000f;
-            log.info("****RECEIVE STATS-"+Thread.currentThread().getName()+"*****"+
-                     "\n\tMessage count :"+(long)messagesReceived+
-                     "\n\tTotal bytes   :"+(long)bytes+
-                     "\n\tTotal mbytes  :"+(long)mBytesReceived+
-                     "\n\tTime since 1st:"+seconds+" seconds"+
-                     "\n\tBytes/second  :"+(bytes/seconds)+
-                     "\n\tMBytes/second :"+(mBytesReceived/seconds)+"\n");
-
-        }
-    }
-    
-    
-    public static void printArray(byte[] data) {
-        System.out.print("{");
-        for (int i=0; i<data.length; i++ ) {
-            System.out.print(data[i]);
-            System.out.print(",");
-        }
-        System.out.println("} size:"+data.length);
-    }
-
-    
-    
-    //public static class LoadMessage implements Serializable  {
-    public static class LoadMessage extends ByteMessage  implements Serializable {
-        
-        public static byte[] outdata = new byte[size];
-        public static Random r = new Random(System.currentTimeMillis());
-        public static int getMessageSize (LoadMessage msg) {
-            int messageSize = msg.getMessage().length;
-            if ( ((Object)msg) instanceof ByteMessage ) return messageSize;
-            try {
-                messageSize  = XByteBuffer.serialize(new LoadMessage()).length;
-                log.info("Average message size:" + messageSize + " bytes");
-            } catch (Exception x) {
-                log.error("Unable to calculate test message size.", x);
-            }
-            return messageSize;
-        }
-        static {
-            r.nextBytes(outdata);
-        }
-        
-        protected byte[] message = getMessage();
-        
-        public LoadMessage() {
-        }
-        
-        public byte[] getMessage() {
-            if ( message == null ) {
-                message = outdata;
-            }
-            return message;
-        }
-        
-        public void setMessage(byte[] data) {
-            this.message = data;
-        }
-    }
-    
-    public static void usage() {
-        System.out.println("Tribes Load tester.");
-        System.out.println("The load tester can be used in sender or received mode or both");
-        System.out.println("Usage:\n\t"+
-                           "java LoadTest [options]\n\t"+
-                           "Options:\n\t\t"+
-                           "[-mode receive|send|both]  \n\t\t"+
-                           "[-startoptions startflags (default is Channel.DEFAULT) ]  \n\t\t"+
-                           "[-debug]  \n\t\t"+
-                           "[-count messagecount]  \n\t\t"+
-                           "[-stats statinterval]  \n\t\t"+
-                           "[-pause nrofsecondstopausebetweensends]  \n\t\t"+
-                           "[-threads numberofsenderthreads]  \n\t\t"+
-                           "[-size messagesize]  \n\t\t"+
-                           "[-sendoptions channeloptions]  \n\t\t"+
-                           "[-break (halts execution on exception)]\n"+
-                           "[-shutdown (issues a channel.stop() command after send is completed)]\n"+
-                           "\tChannel options:"+
-                           ChannelCreator.usage()+"\n\n"+
-                           "Example:\n\t"+
-                           "java LoadTest -port 4004\n\t"+
-                           "java LoadTest -bind 192.168.0.45 -port 4005\n\t"+
-                           "java LoadTest -bind 192.168.0.45 -port 4005 -mbind 192.168.0.45 -count 100 -stats 10\n");
-    }
-    
-    public static void main(String[] args) throws Exception {
-        boolean send = true;
-        boolean debug = false;
-        long pause = 0;
-        int count = 1000000;
-        int stats = 10000;
-        boolean breakOnEx = false;
-        int threads = 1;
-        boolean shutdown = false;
-        int startoptions = Channel.DEFAULT;
-        int channelOptions = Channel.SEND_OPTIONS_DEFAULT;
-        if ( args.length == 0 ) {
-            args = new String[] {"-help"};
-        }
-        for (int i = 0; i < args.length; i++) {
-            if ("-threads".equals(args[i])) {
-                threads = Integer.parseInt(args[++i]);
-            } else if ("-count".equals(args[i])) {
-                count = Integer.parseInt(args[++i]);
-                System.out.println("Sending "+count+" messages.");
-            } else if ("-pause".equals(args[i])) {
-                pause = Long.parseLong(args[++i])*1000;
-            } else if ("-break".equals(args[i])) {
-                breakOnEx = true;
-            } else if ("-shutdown".equals(args[i])) {
-                shutdown = true;
-            } else if ("-stats".equals(args[i])) {
-                stats = Integer.parseInt(args[++i]);
-                System.out.println("Stats every "+stats+" message");
-            } else if ("-sendoptions".equals(args[i])) {
-                channelOptions = Integer.parseInt(args[++i]);
-                System.out.println("Setting send options to "+channelOptions);
-            } else if ("-startoptions".equals(args[i])) {
-                startoptions = Integer.parseInt(args[++i]);
-                System.out.println("Setting start options to "+startoptions);
-            } else if ("-size".equals(args[i])) {
-                size = Integer.parseInt(args[++i])-4;
-                System.out.println("Message size will be:"+(size+4)+" bytes");
-            } else if ("-mode".equals(args[i])) {
-                if ( "receive".equals(args[++i]) ) send = false;
-            } else if ("-debug".equals(args[i])) {
-                debug = true;
-            } else if ("-help".equals(args[i])) 
-            {
-                usage();
-                System.exit(1);
-            }
-        }
-        
-        ManagedChannel channel = (ManagedChannel)ChannelCreator.createChannel(args);
-        
-        LoadTest test = new LoadTest(channel,send,count,debug,pause,stats,breakOnEx);
-        test.channelOptions = channelOptions;
-        LoadMessage msg = new LoadMessage();
-        
-        messageSize = LoadMessage.getMessageSize(msg);
-        channel.addChannelListener(test);
-        channel.addMembershipListener(test);
-        channel.start(startoptions);
-        Runtime.getRuntime().addShutdownHook(new Shutdown(channel));
-        while ( threads > 1 ) {
-            Thread t = new Thread(test);
-            t.setDaemon(true);
-            t.start();
-            threads--;
-            test = new LoadTest(channel,send,count,debug,pause,stats,breakOnEx);
-            test.channelOptions = channelOptions;
-        }
-        test.run();
-        if ( shutdown && send ) channel.stop(channel.DEFAULT);
-        System.out.println("System test complete, sleeping to let threads finish.");
-        Thread.sleep(60*1000*60);
-    } 
-    
-    public static class Shutdown extends Thread {
-        ManagedChannel channel = null;
-        public Shutdown(ManagedChannel channel) {
-            this.channel = channel;
-        }
-        
-        public void run() {
-            System.out.println("Shutting down...");
-            SystemExit exit = new SystemExit(5000);
-            exit.setDaemon(true);
-            exit.start();
-            try {
-                channel.stop(channel.DEFAULT);
-                
-            }catch ( Exception x ) {
-                x.printStackTrace();
-            }
-            System.out.println("Channel stopped.");
-        }
-    }
-    public static class SystemExit extends Thread {
-        private long delay;
-        public SystemExit(long delay) {
-            this.delay = delay;
-        }
-        public void run () {
-            try {
-                Thread.sleep(delay);
-            }catch ( Exception x ) {
-                x.printStackTrace();
-            }
-            System.exit(0);
-
-        }
-    }
-    
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.demos;
+
+import java.io.Serializable;
+import java.util.Random;
+
+import org.apache.catalina.tribes.ByteMessage;
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelListener;
+import org.apache.catalina.tribes.ManagedChannel;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.MembershipListener;
+import org.apache.catalina.tribes.io.XByteBuffer;
+import org.apache.catalina.tribes.Channel;
+import java.io.Externalizable;
+
+
+/**
+ * <p>Title: </p>
+ *
+ * <p>Description: </p>
+ *
+ * <p>Copyright: Copyright (c) 2005</p>
+ *
+ * <p>Company: </p>
+ *
+ * @author not attributable
+ * @version 1.0
+ */
+public class LoadTest implements MembershipListener,ChannelListener, Runnable {
+    protected static org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(LoadTest.class);
+    public static int size = 24000;
+    public static Object mutex = new Object();
+    public boolean doRun = true;
+    
+    public long bytesReceived = 0;
+    public float mBytesReceived = 0;
+    public int  messagesReceived = 0;
+    public boolean send = true;
+    public boolean debug = false;
+    public int msgCount = 100;
+    ManagedChannel channel=null;
+    public int statsInterval = 10000;
+    public long pause = 0;
+    public boolean breakonChannelException = false;
+    public boolean async = false;
+    public long receiveStart = 0;
+    public int channelOptions = Channel.SEND_OPTIONS_DEFAULT;
+    
+    static int messageSize = 0;
+    
+    public static long messagesSent = 0;
+    public static long messageStartSendTime = 0;
+    public static long messageEndSendTime = 0;
+    public static int  threadCount = 0;
+    
+    public static synchronized void startTest() {
+        threadCount++;
+        if ( messageStartSendTime == 0 ) messageStartSendTime = System.currentTimeMillis();
+    }
+    
+    public static synchronized void endTest() {
+        threadCount--;
+        if ( messageEndSendTime == 0 && threadCount==0 ) messageEndSendTime = System.currentTimeMillis();
+    }
+
+    
+    public static synchronized long addSendStats(long count) {
+        messagesSent+=count;
+        return 0l;
+    }    
+    
+    private static void printSendStats(long counter, int messageSize) {
+        float cnt = (float)counter;
+        float size = (float)messageSize;
+        float time = (float)(System.currentTimeMillis()-messageStartSendTime) / 1000f;
+        log.info("****SEND STATS-"+Thread.currentThread().getName()+"*****"+
+                 "\n\tMessage count:"+counter+
+                 "\n\tTotal bytes  :"+(long)(size*cnt)+
+                 "\n\tTotal seconds:"+(time)+
+                 "\n\tBytes/second :"+(size*cnt/time)+
+                 "\n\tMBytes/second:"+(size*cnt/time/1024f/1024f));
+    }
+
+    
+    
+    public LoadTest(ManagedChannel channel, 
+                    boolean send,
+                    int msgCount,
+                    boolean debug,
+                    long pause,
+                    int stats,
+                    boolean breakOnEx) {
+        this.channel = channel;
+        this.send = send;
+        this.msgCount = msgCount;
+        this.debug = debug;
+        this.pause = pause;
+        this.statsInterval = stats;
+        this.breakonChannelException = breakOnEx;
+    }
+    
+    
+    
+    public void run() {
+        
+        long counter = 0;
+        long total = 0;
+        LoadMessage msg = new LoadMessage();
+        int messageSize = LoadTest.messageSize;
+        
+        try {
+            startTest();
+            while (total < msgCount) {
+                if (channel.getMembers().length == 0 || (!send)) {
+                    synchronized (mutex) {
+                        try {
+                            mutex.wait();
+                        } catch (InterruptedException x) {
+                            log.info("Thread interrupted from wait");
+                        }
+                    }
+                } else {
+                    try {
+                        //msg.setMsgNr((int)++total);
+                        counter++;
+                        if (debug) {
+                            printArray(msg.getMessage());
+                        }
+                        channel.send(channel.getMembers(), msg, channelOptions);
+                        if ( pause > 0 ) {
+                            if ( debug) System.out.println("Pausing sender for "+pause+" ms.");
+                            Thread.sleep(pause);
+                        }
+                    } catch (ChannelException x) {
+                        if ( debug ) log.error("Unable to send message:"+x.getMessage(),x);
+                        log.error("Unable to send message:"+x.getMessage());
+                        ChannelException.FaultyMember[] faulty = x.getFaultyMembers();
+                        for (int i=0; i<faulty.length; i++ ) log.error("Faulty: "+faulty[i]);
+                        --counter;
+                        if ( this.breakonChannelException ) throw x;
+                    }
+                }
+                if ( (counter % statsInterval) == 0 && (counter > 0)) {
+                    //add to the global counter
+                    counter = addSendStats(counter);
+                    //print from the global counter
+                    //printSendStats(LoadTest.messagesSent, LoadTest.messageSize, LoadTest.messageSendTime);
+                    printSendStats(LoadTest.messagesSent, LoadTest.messageSize);
+                    
+                }
+
+            }
+        }catch ( Exception x ) {
+            log.error("Captured error while sending:"+x.getMessage());
+            if ( debug ) log.error("",x);
+            printSendStats(LoadTest.messagesSent, LoadTest.messageSize);
+        }
+        endTest();
+    }
+
+    
+
+    /**
+     * memberAdded
+     *
+     * @param member Member
+     * @todo Implement this org.apache.catalina.tribes.MembershipListener
+     *   method
+     */
+    public void memberAdded(Member member) {
+        log.info("Member added:"+member);
+        synchronized (mutex) {
+            mutex.notifyAll();
+        }
+    }
+
+    /**
+     * memberDisappeared
+     *
+     * @param member Member
+     * @todo Implement this org.apache.catalina.tribes.MembershipListener
+     *   method
+     */
+    public void memberDisappeared(Member member) {
+        log.info("Member disappeared:"+member);
+    }
+    
+    public boolean accept(Serializable msg, Member mbr){ 
+       return (msg instanceof LoadMessage) || (msg instanceof ByteMessage);
+    }
+    
+    public void messageReceived(Serializable msg, Member mbr){ 
+        if ( receiveStart == 0 ) receiveStart = System.currentTimeMillis();
+        if ( debug ) {
+            if ( msg instanceof LoadMessage ) {
+                printArray(((LoadMessage)msg).getMessage());
+            }
+        }
+        
+        if ( msg instanceof ByteMessage && !(msg instanceof LoadMessage)) {
+            LoadMessage tmp = new LoadMessage();
+            tmp.setMessage(((ByteMessage)msg).getMessage());
+            msg = tmp;
+            tmp = null;
+        }
+        
+        
+        bytesReceived+=((LoadMessage)msg).getMessage().length;
+        mBytesReceived+=((float)((LoadMessage)msg).getMessage().length)/1024f/1024f;
+        messagesReceived++;
+        if ( (messagesReceived%statsInterval)==0 || (messagesReceived==msgCount)) {
+            float bytes = (float)(((LoadMessage)msg).getMessage().length*messagesReceived);
+            float seconds = ((float)(System.currentTimeMillis()-receiveStart)) / 1000f;
+            log.info("****RECEIVE STATS-"+Thread.currentThread().getName()+"*****"+
+                     "\n\tMessage count :"+(long)messagesReceived+
+                     "\n\tTotal bytes   :"+(long)bytes+
+                     "\n\tTotal mbytes  :"+(long)mBytesReceived+
+                     "\n\tTime since 1st:"+seconds+" seconds"+
+                     "\n\tBytes/second  :"+(bytes/seconds)+
+                     "\n\tMBytes/second :"+(mBytesReceived/seconds)+"\n");
+
+        }
+    }
+    
+    
+    public static void printArray(byte[] data) {
+        System.out.print("{");
+        for (int i=0; i<data.length; i++ ) {
+            System.out.print(data[i]);
+            System.out.print(",");
+        }
+        System.out.println("} size:"+data.length);
+    }
+
+    
+    
+    //public static class LoadMessage implements Serializable  {
+    public static class LoadMessage extends ByteMessage  implements Serializable {
+        
+        public static byte[] outdata = new byte[size];
+        public static Random r = new Random(System.currentTimeMillis());
+        public static int getMessageSize (LoadMessage msg) {
+            int messageSize = msg.getMessage().length;
+            if ( ((Object)msg) instanceof ByteMessage ) return messageSize;
+            try {
+                messageSize  = XByteBuffer.serialize(new LoadMessage()).length;
+                log.info("Average message size:" + messageSize + " bytes");
+            } catch (Exception x) {
+                log.error("Unable to calculate test message size.", x);
+            }
+            return messageSize;
+        }
+        static {
+            r.nextBytes(outdata);
+        }
+        
+        protected byte[] message = getMessage();
+        
+        public LoadMessage() {
+        }
+        
+        public byte[] getMessage() {
+            if ( message == null ) {
+                message = outdata;
+            }
+            return message;
+        }
+        
+        public void setMessage(byte[] data) {
+            this.message = data;
+        }
+    }
+    
+    public static void usage() {
+        System.out.println("Tribes Load tester.");
+        System.out.println("The load tester can be used in sender or received mode or both");
+        System.out.println("Usage:\n\t"+
+                           "java LoadTest [options]\n\t"+
+                           "Options:\n\t\t"+
+                           "[-mode receive|send|both]  \n\t\t"+
+                           "[-startoptions startflags (default is Channel.DEFAULT) ]  \n\t\t"+
+                           "[-debug]  \n\t\t"+
+                           "[-count messagecount]  \n\t\t"+
+                           "[-stats statinterval]  \n\t\t"+
+                           "[-pause nrofsecondstopausebetweensends]  \n\t\t"+
+                           "[-threads numberofsenderthreads]  \n\t\t"+
+                           "[-size messagesize]  \n\t\t"+
+                           "[-sendoptions channeloptions]  \n\t\t"+
+                           "[-break (halts execution on exception)]\n"+
+                           "[-shutdown (issues a channel.stop() command after send is completed)]\n"+
+                           "\tChannel options:"+
+                           ChannelCreator.usage()+"\n\n"+
+                           "Example:\n\t"+
+                           "java LoadTest -port 4004\n\t"+
+                           "java LoadTest -bind 192.168.0.45 -port 4005\n\t"+
+                           "java LoadTest -bind 192.168.0.45 -port 4005 -mbind 192.168.0.45 -count 100 -stats 10\n");
+    }
+    
+    public static void main(String[] args) throws Exception {
+        boolean send = true;
+        boolean debug = false;
+        long pause = 0;
+        int count = 1000000;
+        int stats = 10000;
+        boolean breakOnEx = false;
+        int threads = 1;
+        boolean shutdown = false;
+        int startoptions = Channel.DEFAULT;
+        int channelOptions = Channel.SEND_OPTIONS_DEFAULT;
+        if ( args.length == 0 ) {
+            args = new String[] {"-help"};
+        }
+        for (int i = 0; i < args.length; i++) {
+            if ("-threads".equals(args[i])) {
+                threads = Integer.parseInt(args[++i]);
+            } else if ("-count".equals(args[i])) {
+                count = Integer.parseInt(args[++i]);
+                System.out.println("Sending "+count+" messages.");
+            } else if ("-pause".equals(args[i])) {
+                pause = Long.parseLong(args[++i])*1000;
+            } else if ("-break".equals(args[i])) {
+                breakOnEx = true;
+            } else if ("-shutdown".equals(args[i])) {
+                shutdown = true;
+            } else if ("-stats".equals(args[i])) {
+                stats = Integer.parseInt(args[++i]);
+                System.out.println("Stats every "+stats+" message");
+            } else if ("-sendoptions".equals(args[i])) {
+                channelOptions = Integer.parseInt(args[++i]);
+                System.out.println("Setting send options to "+channelOptions);
+            } else if ("-startoptions".equals(args[i])) {
+                startoptions = Integer.parseInt(args[++i]);
+                System.out.println("Setting start options to "+startoptions);
+            } else if ("-size".equals(args[i])) {
+                size = Integer.parseInt(args[++i])-4;
+                System.out.println("Message size will be:"+(size+4)+" bytes");
+            } else if ("-mode".equals(args[i])) {
+                if ( "receive".equals(args[++i]) ) send = false;
+            } else if ("-debug".equals(args[i])) {
+                debug = true;
+            } else if ("-help".equals(args[i])) 
+            {
+                usage();
+                System.exit(1);
+            }
+        }
+        
+        ManagedChannel channel = (ManagedChannel)ChannelCreator.createChannel(args);
+        
+        LoadTest test = new LoadTest(channel,send,count,debug,pause,stats,breakOnEx);
+        test.channelOptions = channelOptions;
+        LoadMessage msg = new LoadMessage();
+        
+        messageSize = LoadMessage.getMessageSize(msg);
+        channel.addChannelListener(test);
+        channel.addMembershipListener(test);
+        channel.start(startoptions);
+        Runtime.getRuntime().addShutdownHook(new Shutdown(channel));
+        while ( threads > 1 ) {
+            Thread t = new Thread(test);
+            t.setDaemon(true);
+            t.start();
+            threads--;
+            test = new LoadTest(channel,send,count,debug,pause,stats,breakOnEx);
+            test.channelOptions = channelOptions;
+        }
+        test.run();
+        if ( shutdown && send ) channel.stop(channel.DEFAULT);
+        System.out.println("System test complete, sleeping to let threads finish.");
+        Thread.sleep(60*1000*60);
+    } 
+    
+    public static class Shutdown extends Thread {
+        ManagedChannel channel = null;
+        public Shutdown(ManagedChannel channel) {
+            this.channel = channel;
+        }
+        
+        public void run() {
+            System.out.println("Shutting down...");
+            SystemExit exit = new SystemExit(5000);
+            exit.setDaemon(true);
+            exit.start();
+            try {
+                channel.stop(channel.DEFAULT);
+                
+            }catch ( Exception x ) {
+                x.printStackTrace();
+            }
+            System.out.println("Channel stopped.");
+        }
+    }
+    public static class SystemExit extends Thread {
+        private long delay;
+        public SystemExit(long delay) {
+            this.delay = delay;
+        }
+        public void run () {
+            try {
+                Thread.sleep(delay);
+            }catch ( Exception x ) {
+                x.printStackTrace();
+            }
+            System.exit(0);
+
+        }
+    }
+    
 }
\ No newline at end of file

==================================================
TestTwoPhaseCommit.java
index 9e65c7cd01..f47aaf690a 100644
--- a/test/org/apache/catalina/tribes/test/channel/ChannelStartStop.java
+++ b/test/org/apache/catalina/tribes/test/channel/ChannelStartStop.java
@@ -1,118 +1,119 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- */
-package org.apache.catalina.tribes.test.channel;
-
-import org.apache.catalina.tribes.group.GroupChannel;
-import junit.framework.TestCase;
-
-/**
- * @author Filip Hanik
- * @version 1.0
- */
-public class ChannelStartStop extends TestCase {
-    GroupChannel channel = null;
-    protected void setUp() throws Exception {
-        super.setUp();
-        channel = new GroupChannel();
-    }
-
-    protected void tearDown() throws Exception {
-        super.tearDown();
-        try {channel.stop(channel.DEFAULT);}catch (Exception ignore){}
-    }
-    
-    public void testDoubleFullStart() throws Exception {
-        int count = 0;
-        try {
-            channel.start(channel.DEFAULT);
-            count++;
-        } catch ( Exception x){x.printStackTrace();}
-        try {
-            channel.start(channel.DEFAULT);
-            count++;
-        } catch ( Exception x){x.printStackTrace();}
-        assertEquals(count,2);
-        channel.stop(channel.DEFAULT);
-    }
-
-    public void testDoublePartialStart() throws Exception {
-        //try to double start the RX 
-        int count = 0;
-        try {
-            channel.start(channel.SND_RX_SEQ);
-            channel.start(channel.MBR_RX_SEQ);
-            count++;
-        } catch ( Exception x){x.printStackTrace();}
-        try {
-            channel.start(channel.MBR_RX_SEQ);
-            count++;
-        } catch ( Exception x){/*expected*/}
-        assertEquals(count,1);
-        channel.stop(channel.DEFAULT);
-        //double the membership sender
-        count = 0;
-        try {
-            channel.start(channel.SND_RX_SEQ);
-            channel.start(channel.MBR_TX_SEQ);
-            count++;
-        } catch ( Exception x){x.printStackTrace();}
-        try {
-            channel.start(channel.MBR_TX_SEQ);
-            count++;
-        } catch ( Exception x){/*expected*/}
-        assertEquals(count,1);
-        channel.stop(channel.DEFAULT);
-        
-        count = 0;
-        try {
-            channel.start(channel.SND_RX_SEQ);
-            count++;
-        } catch ( Exception x){x.printStackTrace();}
-        try {
-            channel.start(channel.SND_RX_SEQ);
-            count++;
-        } catch ( Exception x){/*expected*/}
-        assertEquals(count,1);
-        channel.stop(channel.DEFAULT);
-
-        count = 0;
-        try {
-            channel.start(channel.SND_TX_SEQ);
-            count++;
-        } catch ( Exception x){x.printStackTrace();}
-        try {
-            channel.start(channel.SND_TX_SEQ);
-            count++;
-        } catch ( Exception x){/*expected*/}
-        assertEquals(count,1);
-        channel.stop(channel.DEFAULT);
-    }
-    
-    public void testFalseOption() throws Exception {
-        int flag = 0xFFF0;//should get ignored by the underlying components
-        int count = 0;
-        try {
-            channel.start(flag);
-            count++;
-        } catch ( Exception x){x.printStackTrace();}
-        try {
-            channel.start(flag);
-            count++;
-        } catch ( Exception x){/*expected*/}
-        assertEquals(count,2);
-        channel.stop(channel.DEFAULT);
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ */
+package org.apache.catalina.tribes.test.channel;
+
+import org.apache.catalina.tribes.group.GroupChannel;
+import junit.framework.TestCase;
+
+/**
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class ChannelStartStop extends TestCase {
+    GroupChannel channel = null;
+    protected void setUp() throws Exception {
+        super.setUp();
+        channel = new GroupChannel();
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+        try {channel.stop(channel.DEFAULT);}catch (Exception ignore){}
+    }
+    
+    public void testDoubleFullStart() throws Exception {
+        int count = 0;
+        try {
+            channel.start(channel.DEFAULT);
+            count++;
+        } catch ( Exception x){x.printStackTrace();}
+        try {
+            channel.start(channel.DEFAULT);
+            count++;
+        } catch ( Exception x){x.printStackTrace();}
+        assertEquals(count,2);
+        channel.stop(channel.DEFAULT);
+    }
+
+    public void testDoublePartialStart() throws Exception {
+        //try to double start the RX 
+        int count = 0;
+        try {
+            channel.start(channel.SND_RX_SEQ);
+            channel.start(channel.MBR_RX_SEQ);
+            count++;
+        } catch ( Exception x){x.printStackTrace();}
+        try {
+            channel.start(channel.MBR_RX_SEQ);
+            count++;
+        } catch ( Exception x){/*expected*/}
+        assertEquals(count,1);
+        channel.stop(channel.DEFAULT);
+        //double the membership sender
+        count = 0;
+        try {
+            channel.start(channel.SND_RX_SEQ);
+            channel.start(channel.MBR_TX_SEQ);
+            count++;
+        } catch ( Exception x){x.printStackTrace();}
+        try {
+            channel.start(channel.MBR_TX_SEQ);
+            count++;
+        } catch ( Exception x){/*expected*/}
+        assertEquals(count,1);
+        channel.stop(channel.DEFAULT);
+        
+        count = 0;
+        try {
+            channel.start(channel.SND_RX_SEQ);
+            count++;
+        } catch ( Exception x){x.printStackTrace();}
+        try {
+            channel.start(channel.SND_RX_SEQ);
+            count++;
+        } catch ( Exception x){/*expected*/}
+        assertEquals(count,1);
+        channel.stop(channel.DEFAULT);
+
+        count = 0;
+        try {
+            channel.start(channel.SND_TX_SEQ);
+            count++;
+        } catch ( Exception x){x.printStackTrace();}
+        try {
+            channel.start(channel.SND_TX_SEQ);
+            count++;
+        } catch ( Exception x){/*expected*/}
+        assertEquals(count,1);
+        channel.stop(channel.DEFAULT);
+    }
+    
+    public void testFalseOption() throws Exception {
+        int flag = 0xFFF0;//should get ignored by the underlying components
+        int count = 0;
+        try {
+            channel.start(flag);
+            count++;
+        } catch ( Exception x){x.printStackTrace();}
+        try {
+            channel.start(flag);
+            count++;
+        } catch ( Exception x){/*expected*/}
+        assertEquals(count,2);
+        channel.stop(channel.DEFAULT);
+    }
+
+}

==================================================
MemberSerialization.java
index 4183f70cb0..9f8e9830e6 100644
--- a/test/org/apache/catalina/tribes/test/interceptors/TestTwoPhaseCommit.java
+++ b/test/org/apache/catalina/tribes/test/interceptors/TestTwoPhaseCommit.java
@@ -1,42 +1,43 @@
-/*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- */
-
-package org.apache.catalina.tribes.test.interceptors;
-
-import junit.framework.TestCase;
-
-/**
- * <p>Title: </p> 
- * 
- * <p>Description: </p> 
- * 
- * <p>Copyright: Copyright (c) 2005</p> 
- * 
- * <p>Company: </p>
- * 
- * @author not attributable
- * @version 1.0
- */
-public class TestTwoPhaseCommit extends TestCase {
-
-    protected void setUp() throws Exception {
-        super.setUp();
-    }
-
-    protected void tearDown() throws Exception {
-        super.tearDown();
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ */
+
+package org.apache.catalina.tribes.test.interceptors;
+
+import junit.framework.TestCase;
+
+/**
+ * <p>Title: </p> 
+ * 
+ * <p>Description: </p> 
+ * 
+ * <p>Copyright: Copyright (c) 2005</p> 
+ * 
+ * <p>Company: </p>
+ * 
+ * @author not attributable
+ * @version 1.0
+ */
+public class TestTwoPhaseCommit extends TestCase {
+
+    protected void setUp() throws Exception {
+        super.setUp();
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+    }
+
+}

==================================================
Hello.java
index 879ec87fb6..bc1f922bbf 100644
--- a/webapps/ROOT/WEB-INF/web.xml
+++ b/webapps/ROOT/WEB-INF/web.xml
@@ -1,10 +1,11 @@
 <?xml version="1.0" encoding="ISO-8859-1"?>
 <!--
-  Copyright 2004 The Apache Software Foundation
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
+ Licensed to the Apache Software Foundation (ASF) under one or more
+  contributor license agreements.  See the NOTICE file distributed with
+  this work for additional information regarding copyright ownership.
+  The ASF licenses this file to You under the Apache License, Version 2.0
+  (the "License"); you may not use this file except in compliance with
+  the License.  You may obtain a copy of the License at
 
       http://www.apache.org/licenses/LICENSE-2.0
 

==================================================
CookieExample.java
index 5301fa86e5..5884ac39c2 100644
--- a/webapps/docs/appdev/sample/src/mypackage/Hello.java
+++ b/webapps/docs/appdev/sample/src/mypackage/Hello.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
HelloWorldExample.java
index a301ed9b26..5a6d6e1aa6 100644
--- a/webapps/examples/WEB-INF/classes/CookieExample.java
+++ b/webapps/examples/WEB-INF/classes/CookieExample.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
RequestHeaderExample.java
index 9417ed7c92..2745243799 100644
--- a/webapps/examples/WEB-INF/classes/LocalStrings_pt.properties
+++ b/webapps/examples/WEB-INF/classes/LocalStrings_pt.properties
@@ -1,8 +1,9 @@
-# Copyright 2004 The Apache Software Foundation
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
 #
 #     http://www.apache.org/licenses/LICENSE-2.0
 #

==================================================
RequestInfoExample.java
index 36e9671796..7fa03fca5e 100644
--- a/webapps/examples/WEB-INF/classes/RequestHeaderExample.java
+++ b/webapps/examples/WEB-INF/classes/RequestHeaderExample.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
RequestParamExample.java
index 966af3c9b6..1eee91a09e 100644
--- a/webapps/examples/WEB-INF/classes/RequestInfoExample.java
+++ b/webapps/examples/WEB-INF/classes/RequestInfoExample.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
SessionExample.java
index b909e62b8f..9993a35cb2 100644
--- a/webapps/examples/WEB-INF/classes/RequestParamExample.java
+++ b/webapps/examples/WEB-INF/classes/RequestParamExample.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
Entries.java
index 6d8c23ef50..803a7d5c19 100644
--- a/webapps/examples/WEB-INF/classes/SessionExample.java
+++ b/webapps/examples/WEB-INF/classes/SessionExample.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
Entry.java
index f762590282..7ef6c78c69 100644
--- a/webapps/examples/WEB-INF/classes/cal/Entries.java
+++ b/webapps/examples/WEB-INF/classes/cal/Entries.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
JspCalendar.java
index 035eda0753..10b826e52c 100644
--- a/webapps/examples/WEB-INF/classes/cal/Entry.java
+++ b/webapps/examples/WEB-INF/classes/cal/Entry.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
TableBean.java
index 14063fdba9..295ef3a87d 100644
--- a/webapps/examples/WEB-INF/classes/cal/JspCalendar.java
+++ b/webapps/examples/WEB-INF/classes/cal/JspCalendar.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
ChatServlet.java
index 75cd599473..26e3b015f0 100644
--- a/webapps/examples/WEB-INF/classes/cal/TableBean.java
+++ b/webapps/examples/WEB-INF/classes/cal/TableBean.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
CheckTest.java
index 1d849ef619..243197e125 100644
--- a/webapps/examples/WEB-INF/classes/chat/ChatServlet.java
+++ b/webapps/examples/WEB-INF/classes/chat/ChatServlet.java
@@ -1,9 +1,10 @@
 /*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 

==================================================
ColorGameBean.java
index ad6d2ed641..73070214eb 100644
--- a/webapps/examples/WEB-INF/classes/checkbox/CheckTest.java
+++ b/webapps/examples/WEB-INF/classes/checkbox/CheckTest.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
CompressionFilter.java
index 1235b98b1f..0f9e159a0a 100644
--- a/webapps/examples/WEB-INF/classes/colors/ColorGameBean.java
+++ b/webapps/examples/WEB-INF/classes/colors/ColorGameBean.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
CompressionFilterTestServlet.java
index 7188659000..159d30aa7d 100644
--- a/webapps/examples/WEB-INF/classes/compressionFilters/CompressionFilter.java
+++ b/webapps/examples/WEB-INF/classes/compressionFilters/CompressionFilter.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
CompressionResponseStream.java
index d52f58cc26..b14f83d1ab 100644
--- a/webapps/examples/WEB-INF/classes/compressionFilters/CompressionFilterTestServlet.java
+++ b/webapps/examples/WEB-INF/classes/compressionFilters/CompressionFilterTestServlet.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
CompressionServletResponseWrapper.java
index 70632f6212..d0250e2c17 100644
--- a/webapps/examples/WEB-INF/classes/compressionFilters/CompressionResponseStream.java
+++ b/webapps/examples/WEB-INF/classes/compressionFilters/CompressionResponseStream.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
JspCalendar.java
index 6dcd8d1f97..26ccf276af 100644
--- a/webapps/examples/WEB-INF/classes/compressionFilters/CompressionServletResponseWrapper.java
+++ b/webapps/examples/WEB-INF/classes/compressionFilters/CompressionServletResponseWrapper.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
Smart.java
index b0194755ac..419eea3a7e 100644
--- a/webapps/examples/WEB-INF/classes/dates/JspCalendar.java
+++ b/webapps/examples/WEB-INF/classes/dates/JspCalendar.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
ExampleTagBase.java
index e5158e7a2d..999aef3095 100644
--- a/webapps/examples/WEB-INF/classes/error/Smart.java
+++ b/webapps/examples/WEB-INF/classes/error/Smart.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
FooTag.java
index 4b64e95815..ded3a30a9c 100644
--- a/webapps/examples/WEB-INF/classes/examples/ExampleTagBase.java
+++ b/webapps/examples/WEB-INF/classes/examples/ExampleTagBase.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
FooTagExtraInfo.java
index e03dc191cd..c55f36a729 100644
--- a/webapps/examples/WEB-INF/classes/examples/FooTag.java
+++ b/webapps/examples/WEB-INF/classes/examples/FooTag.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
LogTag.java
index c32c28d1ad..6733efd243 100644
--- a/webapps/examples/WEB-INF/classes/examples/FooTagExtraInfo.java
+++ b/webapps/examples/WEB-INF/classes/examples/FooTagExtraInfo.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
ShowSource.java
index 392a3d5878..ff394b88e2 100644
--- a/webapps/examples/WEB-INF/classes/examples/LogTag.java
+++ b/webapps/examples/WEB-INF/classes/examples/LogTag.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
ExampleFilter.java
index 6daf0cff05..8fb65c557c 100644
--- a/webapps/examples/WEB-INF/classes/examples/ShowSource.java
+++ b/webapps/examples/WEB-INF/classes/examples/ShowSource.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
RequestDumperFilter.java
index 6981b8bcb4..7fc4e3ff89 100644
--- a/webapps/examples/WEB-INF/classes/filters/ExampleFilter.java
+++ b/webapps/examples/WEB-INF/classes/filters/ExampleFilter.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
SetCharacterEncodingFilter.java
index d9d2c409db..1c8d519e88 100644
--- a/webapps/examples/WEB-INF/classes/filters/RequestDumperFilter.java
+++ b/webapps/examples/WEB-INF/classes/filters/RequestDumperFilter.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
BookBean.java
index ef77c7e627..028552e7ed 100644
--- a/webapps/examples/WEB-INF/classes/filters/SetCharacterEncodingFilter.java
+++ b/webapps/examples/WEB-INF/classes/filters/SetCharacterEncodingFilter.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
FooBean.java
index 4e2f18d4d3..0f7b514cfd 100644
--- a/webapps/examples/WEB-INF/classes/jsp2/examples/BookBean.java
+++ b/webapps/examples/WEB-INF/classes/jsp2/examples/BookBean.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
Functions.java
index c0bd107231..330511f714 100644
--- a/webapps/examples/WEB-INF/classes/jsp2/examples/FooBean.java
+++ b/webapps/examples/WEB-INF/classes/jsp2/examples/FooBean.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
EchoAttributesTag.java
index 34732e2320..325c2fe77d 100644
--- a/webapps/examples/WEB-INF/classes/jsp2/examples/el/Functions.java
+++ b/webapps/examples/WEB-INF/classes/jsp2/examples/el/Functions.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
FindBookSimpleTag.java
index 8c55db9ade..982e7116e8 100644
--- a/webapps/examples/WEB-INF/classes/jsp2/examples/simpletag/EchoAttributesTag.java
+++ b/webapps/examples/WEB-INF/classes/jsp2/examples/simpletag/EchoAttributesTag.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
HelloWorldSimpleTag.java
index 52a5e15e74..998edd04c5 100644
--- a/webapps/examples/WEB-INF/classes/jsp2/examples/simpletag/FindBookSimpleTag.java
+++ b/webapps/examples/WEB-INF/classes/jsp2/examples/simpletag/FindBookSimpleTag.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
RepeatSimpleTag.java
index 7a4196c662..b8e3aa3f6b 100644
--- a/webapps/examples/WEB-INF/classes/jsp2/examples/simpletag/HelloWorldSimpleTag.java
+++ b/webapps/examples/WEB-INF/classes/jsp2/examples/simpletag/HelloWorldSimpleTag.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
ShuffleSimpleTag.java
index 0f4b1e524a..afd6952c6f 100644
--- a/webapps/examples/WEB-INF/classes/jsp2/examples/simpletag/RepeatSimpleTag.java
+++ b/webapps/examples/WEB-INF/classes/jsp2/examples/simpletag/RepeatSimpleTag.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
TileSimpleTag.java
index 0c12099313..701c023453 100644
--- a/webapps/examples/WEB-INF/classes/jsp2/examples/simpletag/ShuffleSimpleTag.java
+++ b/webapps/examples/WEB-INF/classes/jsp2/examples/simpletag/ShuffleSimpleTag.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
ContextListener.java
index 7f3348071c..8e7dd3794e 100644
--- a/webapps/examples/WEB-INF/classes/jsp2/examples/simpletag/TileSimpleTag.java
+++ b/webapps/examples/WEB-INF/classes/jsp2/examples/simpletag/TileSimpleTag.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
SessionListener.java
index 6f56363802..257cb47eee 100644
--- a/webapps/examples/WEB-INF/classes/listeners/ContextListener.java
+++ b/webapps/examples/WEB-INF/classes/listeners/ContextListener.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
NumberGuessBean.java
index 540547dcf7..4534dfcdc2 100644
--- a/webapps/examples/WEB-INF/classes/listeners/SessionListener.java
+++ b/webapps/examples/WEB-INF/classes/listeners/SessionListener.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
servletToJsp.java
index b5afeaba31..5900ad8f90 100644
--- a/webapps/examples/WEB-INF/classes/num/NumberGuessBean.java
+++ b/webapps/examples/WEB-INF/classes/num/NumberGuessBean.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
DummyCart.java
index 38a2c726b0..aadf924677 100644
--- a/webapps/examples/WEB-INF/classes/servletToJsp.java
+++ b/webapps/examples/WEB-INF/classes/servletToJsp.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
HTMLFilter.java
index 17ccd80b8d..1ba6df6864 100644
--- a/webapps/examples/WEB-INF/classes/sessions/DummyCart.java
+++ b/webapps/examples/WEB-INF/classes/sessions/DummyCart.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
DebugValidator.java
index 3b6b9276c4..c6231bf18d 100644
--- a/webapps/examples/WEB-INF/classes/util/HTMLFilter.java
+++ b/webapps/examples/WEB-INF/classes/util/HTMLFilter.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
Clock2.java
index bb55026c8c..c251910f9b 100644
--- a/webapps/examples/WEB-INF/classes/validators/DebugValidator.java
+++ b/webapps/examples/WEB-INF/classes/validators/DebugValidator.java
@@ -1,9 +1,10 @@
 /*
-* Copyright 2004 The Apache Software Foundation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *

==================================================
Clock2.java
index f1b8e02769..2461bf7de1 100644
--- a/webapps/examples/jsp/num/numguess.jsp
+++ b/webapps/examples/jsp/num/numguess.jsp
@@ -1,9 +1,10 @@
 <!--
-  Copyright 2004 The Apache Software Foundation
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
+ Licensed to the Apache Software Foundation (ASF) under one or more
+  contributor license agreements.  See the NOTICE file distributed with
+  this work for additional information regarding copyright ownership.
+  The ASF licenses this file to You under the Apache License, Version 2.0
+  (the "License"); you may not use this file except in compliance with
+  the License.  You may obtain a copy of the License at
 
       http://www.apache.org/licenses/LICENSE-2.0
 

==================================================
