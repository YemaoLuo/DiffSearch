f20929c26714f5535a17bdb94fb5d48df8458153
==================================================
- Use the classname as the servlet context attribute name for the annotation processor.
==================================================
Remy Maucherat
==================================================
Fri Aug 4 14:04:42 2006 +0000
==================================================
Globals.java
- Use the classname as the servlet context attribute name for the annotation processor.
- Fix init of the naming context used by the annotation processor.
- Jasper will now use the annotation processor from the servlet context.
- Remove the ignore annotation compile time parameter for Jasper, which was a temporary hack.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/tc6.0.x/trunk@428729 13f79535-47bb-0310-9956-ffa450edef68



==================================================
StandardContext.java
index 55b3167403..2de06db7ea 100644
--- a/java/org/apache/catalina/Globals.java
+++ b/java/org/apache/catalina/Globals.java
@@ -87,14 +87,6 @@ public final class Globals {
         "org.apache.catalina.jsp_classpath";
 
 
-    /**
-     * The servlet context attribute under which we store the annotation
-     * processor that is used by the JSP engine.
-     */
-    public static final String ANNOTATION_PROCESSOR_ATTR =
-        "org.apache.catalina.annotation_processor";
-
-
     /**
      * The request attribute under which we forward a Java exception
      * (as an object of type Throwable) to an error page.

==================================================
EmbeddedServletOptions.java
index 0fb2d4b3b4..de8e3d5a5a 100644
--- a/java/org/apache/catalina/core/StandardContext.java
+++ b/java/org/apache/catalina/core/StandardContext.java
@@ -4168,20 +4168,6 @@ public class StandardContext
             }
         }
         
-        // Initialize annotation processor
-        if (ok && !getIgnoreAnnotations()) {
-            if (annotationProcessor == null) {
-                if (isUseNaming() && namingContextListener != null) {
-                    annotationProcessor = 
-                        new DefaultAnnotationProcessor(namingContextListener.getEnvContext());
-                } else {
-                    annotationProcessor = new DefaultAnnotationProcessor(null);
-                }
-            }
-            getServletContext().setAttribute
-                (Globals.ANNOTATION_PROCESSOR_ATTR, annotationProcessor);
-        }
-
         // Standard container startup
         if (log.isDebugEnabled())
             log.debug("Processing standard container startup");
@@ -4303,11 +4289,20 @@ public class StandardContext
         // Set annotation processing parameter for Jasper (unfortunately, since
         // this can be configured in many places and not just in /WEB-INF/web.xml,
         // there are not many solutions)
-        if (ignoreAnnotations) {
-            Wrapper jspServlet = (Wrapper) findChild(Constants.JSP_SERVLET_NAME);
-            jspServlet.addInitParameter("org.apache.jasper.IGNORE_ANNOTATIONS", "true");
+        // Initialize annotation processor
+        if (ok && !getIgnoreAnnotations()) {
+            if (annotationProcessor == null) {
+                if (isUseNaming() && namingContextListener != null) {
+                    annotationProcessor = 
+                        new DefaultAnnotationProcessor(namingContextListener.getEnvContext());
+                } else {
+                    annotationProcessor = new DefaultAnnotationProcessor(null);
+                }
+            }
+            getServletContext().setAttribute
+                (AnnotationProcessor.class.getName(), annotationProcessor);
         }
-        
+
         try {
             
             // Create context attributes that will be required

==================================================
JspC.java
index b2accd6532..da7d3b4320 100644
--- a/java/org/apache/jasper/EmbeddedServletOptions.java
+++ b/java/org/apache/jasper/EmbeddedServletOptions.java
@@ -174,11 +174,6 @@ public final class EmbeddedServletOptions implements Options {
      */
     private boolean xpoweredBy;
     
-    /**
-     * Should annotations be ignored?
-     */
-    private boolean ignoreAnnotations = false;
-    
     public String getProperty(String name ) {
         return settings.getProperty( name );
     }
@@ -249,13 +244,6 @@ public final class EmbeddedServletOptions implements Options {
         return development;
     }
     
-    /**
-     * Should annotations on tags be ignored?
-     */
-    public boolean getIgnoreAnnotations() {
-        return ignoreAnnotations;
-    }
-
     /**
      * Is the generation of SMAP info for JSR45 debuggin suppressed?
      */
@@ -396,11 +384,6 @@ public final class EmbeddedServletOptions implements Options {
         String validating=config.getInitParameter( "validating");
         if( "false".equals( validating )) ParserUtils.validating=false;
         
-        String annotations = config.getInitParameter("org.apache.jasper.IGNORE_ANNOTATIONS");
-        if ("true".equals(annotations)) {
-            ignoreAnnotations = true;
-        }
-
         String keepgen = config.getInitParameter("keepgenerated");
         if (keepgen != null) {
             if (keepgen.equalsIgnoreCase("true")) {

==================================================
Options.java
index adb719ac04..c4cd4fa187 100644
--- a/java/org/apache/jasper/JspC.java
+++ b/java/org/apache/jasper/JspC.java
@@ -159,7 +159,6 @@ public class JspC implements Options {
     private boolean smapSuppressed = true;
     private boolean smapDumped = false;
     private boolean caching = true;
-    private boolean ignoreAnnotations = false;
     private Map cache = new HashMap();
 
     private String compiler = null;
@@ -591,20 +590,6 @@ public class JspC implements Options {
         compilerSourceVM = vm;
     }
 
-    /**
-     * Should annotations on tags be ignored?
-     */
-    public boolean getIgnoreAnnotations() {
-        return ignoreAnnotations;
-    }
-
-    /**
-     * Should annotations on tags be ignored?
-     */
-    public void setIgnoreAnnotations(boolean ignoreAnnotations) {
-        this.ignoreAnnotations = ignoreAnnotations;
-    }
-
     public TldLocationsCache getTldLocationsCache() {
         return tldLocationsCache;
     }

==================================================
Generator.java
index 5ffeba56ce..af47f57d43 100644
--- a/java/org/apache/jasper/Options.java
+++ b/java/org/apache/jasper/Options.java
@@ -91,11 +91,6 @@ public interface Options {
      */
     public boolean getTrimSpaces();
 
-    /**
-     * Should annotations on tags be ignored?
-     */
-    public boolean getIgnoreAnnotations();
-
     /**
      * Class ID for use in the plugin tag when the browser is IE. 
      */

==================================================
AnnotationHelper.java
index 674c63db5c..d744d1bd62 100644
--- a/java/org/apache/jasper/compiler/Generator.java
+++ b/java/org/apache/jasper/compiler/Generator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 1999,2004 The Apache Software Foundation.
+ * Copyright 1999,2004-2006 The Apache Software Foundation.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -63,6 +63,7 @@ import org.xml.sax.Attributes;
  * 
  * Tomcat 6.x
  * @author Jacob Hookom
+ * @author Remy Maucherat
  */
 
 class Generator {
@@ -70,6 +71,7 @@ class Generator {
     private static final Class[] OBJECT_CLASS = { Object.class };
 
     private static final String VAR_EXPRESSIONFACTORY = "_el_expressionfactory";
+    private static final String VAR_ANNOTATIONPROCESSOR = "_jsp_annotationprocessor";
 
     private ServletWriter out;
 
@@ -405,7 +407,16 @@ class Generator {
             out.print("getServletConfig()");
         }
         out.println(".getServletContext()).getExpressionFactory();");
-        
+
+        out.printin(VAR_ANNOTATIONPROCESSOR);
+        out.print(" = (org.apache.AnnotationProcessor) ");
+        if (ctxt.isTagFile()) {
+            out.print("config");
+        } else {
+            out.print("getServletConfig()");
+        }
+        out.println(".getServletContext().getAttribute(org.apache.AnnotationProcessor.class.getName());");
+
         out.popIndent();
         out.printil("}");
         out.println();
@@ -505,6 +516,9 @@ class Generator {
         out.printin("private javax.el.ExpressionFactory ");
         out.print(VAR_EXPRESSIONFACTORY);
         out.println(";");
+        out.printin("private org.apache.AnnotationProcessor ");
+        out.print(VAR_ANNOTATIONPROCESSOR);
+        out.println(";");
         out.println();
     }
 
@@ -2143,11 +2157,11 @@ class Generator {
                 out.print("new ");
                 out.print(tagHandlerClassName);
                 out.println("();");
-                if (!ctxt.getOptions().getIgnoreAnnotations()) {
-                    out.printin("org.apache.jasper.runtime.AnnotationProcessor.postConstruct(");
-                    out.print(tagHandlerVar);
-                    out.println(");");
-                }
+                out.printin("org.apache.jasper.runtime.AnnotationHelper.postConstruct(");
+                out.print(VAR_ANNOTATIONPROCESSOR);
+                out.print(", ");
+                out.print(tagHandlerVar);
+                out.println(");");
             }
 
             // includes setting the context
@@ -2293,21 +2307,21 @@ class Generator {
                 } else {
                     out.printin(tagHandlerVar);
                     out.println(".release();");
-                    if (!ctxt.getOptions().getIgnoreAnnotations()) {
-                        out.printil("try {");
-                        out.pushIndent();
-                        out.printin("org.apache.jasper.runtime.AnnotationProcessor.preDestroy(");
-                        out.print(tagHandlerVar);
-                        out.println(");");
-                        out.popIndent();
-                        out.printil("} catch (Exception e) {");
-                        out.pushIndent();
-                        out.printin("log(\"Error processing preDestroy on tag instance of \" +");
-                        out.print(tagHandlerVar);
-                        out.println(".getClass().getName());");
-                        out.popIndent();
-                        out.printil("}");
-                    }
+                    out.printil("try {");
+                    out.pushIndent();
+                    out.printin("org.apache.jasper.runtime.AnnotationHelper.preDestroy(");
+                    out.print(VAR_ANNOTATIONPROCESSOR);
+                    out.print(", ");
+                    out.print(tagHandlerVar);
+                    out.println(");");
+                    out.popIndent();
+                    out.printil("} catch (Exception e) {");
+                    out.pushIndent();
+                    out.printin("log(\"Error processing preDestroy on tag instance of \" +");
+                    out.print(tagHandlerVar);
+                    out.println(".getClass().getName());");
+                    out.popIndent();
+                    out.printil("}");
                 }
             }
             if (isTagFile || isFragment) {
@@ -2350,21 +2364,21 @@ class Generator {
             } else {
                 out.printin(tagHandlerVar);
                 out.println(".release();");
-                if (!ctxt.getOptions().getIgnoreAnnotations()) {
-                    out.printil("try {");
-                    out.pushIndent();
-                    out.printin("org.apache.jasper.runtime.AnnotationProcessor.preDestroy(");
-                    out.print(tagHandlerVar);
-                    out.println(");");
-                    out.popIndent();
-                    out.printil("} catch (Exception e) {");
-                    out.pushIndent();
-                    out.printin("log(\"Error processing preDestroy on tag instance of \" +");
-                    out.print(tagHandlerVar);
-                    out.println(".getClass().getName());");
-                    out.popIndent();
-                    out.printil("}");
-                }
+                out.printil("try {");
+                out.pushIndent();
+                out.printin("org.apache.jasper.runtime.AnnotationHelper.preDestroy(");
+                out.print(VAR_ANNOTATIONPROCESSOR);
+                out.print(", ");
+                out.print(tagHandlerVar);
+                out.println(");");
+                out.popIndent();
+                out.printil("} catch (Exception e) {");
+                out.pushIndent();
+                out.printin("log(\"Error processing preDestroy on tag instance of \" +");
+                out.print(tagHandlerVar);
+                out.println(".getClass().getName());");
+                out.popIndent();
+                out.printil("}");
             }
 
             if (n.implementsTryCatchFinally()) {
@@ -2405,11 +2419,11 @@ class Generator {
             out.println("();");
 
             // Resource injection
-            if (!ctxt.getOptions().getIgnoreAnnotations()) {
-                out.printin("org.apache.jasper.runtime.AnnotationProcessor.postConstruct(");
-                out.print(tagHandlerVar);
-                out.println(");");
-            }
+            out.printin("org.apache.jasper.runtime.AnnotationHelper.postConstruct(");
+            out.print(VAR_ANNOTATIONPROCESSOR);
+            out.print(", ");
+            out.print(tagHandlerVar);
+            out.println(");");
             
             generateSetters(n, tagHandlerVar, handlerInfo, true);
 
@@ -2455,11 +2469,11 @@ class Generator {
             syncScriptingVars(n, VariableInfo.AT_END);
 
             // Resource injection
-            if (!ctxt.getOptions().getIgnoreAnnotations()) {
-                out.printin("org.apache.jasper.runtime.AnnotationProcessor.preDestroy(");
-                out.print(tagHandlerVar);
-                out.println(");");
-            }
+            out.printin("org.apache.jasper.runtime.AnnotationHelper.preDestroy(");
+            out.print(VAR_ANNOTATIONPROCESSOR);
+            out.print(", ");
+            out.print(tagHandlerVar);
+            out.println(");");
 
             n.setEndJavaLine(out.getJavaLine());
         }

==================================================
AnnotationProcessor.java
new file mode 100644
index 0000000000..286a994940
--- /dev/null
+++ b/java/org/apache/jasper/runtime/AnnotationHelper.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2006 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.jasper.runtime;
+
+import java.lang.reflect.InvocationTargetException;
+
+import javax.naming.NamingException;
+
+import org.apache.AnnotationProcessor;
+
+
+/**
+ * Verify the annotation and Process it.
+ *
+ * @author Fabien Carrion
+ * @author Remy Maucherat
+ * @version $Revision: 303236 $, $Date: 2006-03-09 16:46:52 -0600 (Thu, 09 Mar 2006) $
+ */
+public class AnnotationHelper {
+
+    
+    /**
+     * Call postConstruct method on the specified instance. Note: In Jasper, this
+     * calls naming resources injection as well.
+     */
+    public static void postConstruct(AnnotationProcessor processor, Object instance)
+        throws IllegalAccessException, InvocationTargetException, NamingException {
+        if (processor != null) {
+            processor.processAnnotations(instance);
+            processor.postConstruct(instance);
+        }
+    }
+    
+    
+    /**
+     * Call preDestroy method on the specified instance.
+     */
+    public static void preDestroy(AnnotationProcessor processor, Object instance)
+        throws IllegalAccessException, InvocationTargetException {
+        if (processor != null) {
+            processor.preDestroy(instance);
+        }
+    }
+    
+
+}

==================================================
TagHandlerPool.java
deleted file mode 100644
index c9a3197b46..0000000000
--- a/java/org/apache/jasper/runtime/AnnotationProcessor.java
+++ /dev/null
@@ -1,223 +0,0 @@
-/*
- * Copyright 2006 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.jasper.runtime;
-
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-
-import javax.annotation.PostConstruct;
-import javax.annotation.PreDestroy;
-import javax.annotation.Resource;
-import javax.ejb.EJB;
-import javax.naming.Context;
-import javax.naming.InitialContext;
-import javax.naming.NamingException;
-import javax.persistence.PersistenceContext;
-import javax.persistence.PersistenceUnit;
-import javax.xml.ws.WebServiceRef;
-
-
-/**
- * Verify the annotation and Process it.
- *
- * @author Fabien Carrion
- * @author Remy Maucherat
- * @version $Revision: 303236 $, $Date: 2006-03-09 16:46:52 -0600 (Thu, 09 Mar 2006) $
- */
-public class AnnotationProcessor {
-
-    
-    /**
-     * Call postConstruct method on the specified instance. Note: In Jasper, this
-     * calls naming resources injection as well.
-     */
-    public static void postConstruct(Object instance)
-        throws IllegalAccessException, InvocationTargetException, NamingException {
-        
-        // Initialize fields annotations
-        Field[] fields = instance.getClass().getDeclaredFields();
-        for (int i = 0; i < fields.length; i++) {
-            if (fields[i].isAnnotationPresent(Resource.class)) {
-                Resource annotation = (Resource) fields[i].getAnnotation(Resource.class);
-                lookupFieldResource(instance, fields[i], annotation.name());
-            }
-            if (fields[i].isAnnotationPresent(EJB.class)) {
-                EJB annotation = (EJB) fields[i].getAnnotation(EJB.class);
-                lookupFieldResource(instance, fields[i], annotation.name());
-            }
-            if (fields[i].isAnnotationPresent(WebServiceRef.class)) {
-                WebServiceRef annotation = 
-                    (WebServiceRef) fields[i].getAnnotation(WebServiceRef.class);
-                lookupFieldResource(instance, fields[i], annotation.name());
-            }
-            if (fields[i].isAnnotationPresent(PersistenceContext.class)) {
-                PersistenceContext annotation = 
-                    (PersistenceContext) fields[i].getAnnotation(PersistenceContext.class);
-                lookupFieldResource(instance, fields[i], annotation.name());
-            }
-            if (fields[i].isAnnotationPresent(PersistenceUnit.class)) {
-                PersistenceUnit annotation = 
-                    (PersistenceUnit) fields[i].getAnnotation(PersistenceUnit.class);
-                lookupFieldResource(instance, fields[i], annotation.name());
-            }
-        }
-        
-        // Initialize methods annotations
-        Method[] methods = instance.getClass().getDeclaredMethods();
-        for (int i = 0; i < methods.length; i++) {
-            if (methods[i].isAnnotationPresent(Resource.class)) {
-                Resource annotation = (Resource) methods[i].getAnnotation(Resource.class);
-                lookupMethodResource(instance, methods[i], annotation.name());
-            }
-            if (methods[i].isAnnotationPresent(EJB.class)) {
-                EJB annotation = (EJB) methods[i].getAnnotation(EJB.class);
-                lookupMethodResource(instance, methods[i], annotation.name());
-            }
-            if (methods[i].isAnnotationPresent(WebServiceRef.class)) {
-                WebServiceRef annotation = 
-                    (WebServiceRef) methods[i].getAnnotation(WebServiceRef.class);
-                lookupMethodResource(instance, methods[i], annotation.name());
-            }
-            if (methods[i].isAnnotationPresent(PersistenceContext.class)) {
-                PersistenceContext annotation = 
-                    (PersistenceContext) methods[i].getAnnotation(PersistenceContext.class);
-                lookupMethodResource(instance, methods[i], annotation.name());
-            }
-            if (methods[i].isAnnotationPresent(PersistenceUnit.class)) {
-                PersistenceUnit annotation = 
-                    (PersistenceUnit) methods[i].getAnnotation(PersistenceUnit.class);
-                lookupMethodResource(instance, methods[i], annotation.name());
-            }
-        }
-
-        Method postConstruct = null;
-        for (int i = 0; i < methods.length; i++) {
-            if (methods[i].isAnnotationPresent(PostConstruct.class)) {
-                if ((postConstruct != null) 
-                        || (methods[i].getParameterTypes().length != 0)
-                        || (Modifier.isStatic(methods[i].getModifiers())) 
-                        || (methods[i].getExceptionTypes().length > 0)
-                        || (!methods[i].getReturnType().getName().equals("void"))) {
-                    throw new IllegalArgumentException("Invalid PostConstruct annotation");
-                }
-                postConstruct = methods[i];
-            }
-        }
-
-        // At the end the postconstruct annotated 
-        // method is invoked
-        if (postConstruct != null) {
-            boolean accessibility = postConstruct.isAccessible();
-            postConstruct.setAccessible(true);
-            postConstruct.invoke(instance);
-            postConstruct.setAccessible(accessibility);
-        }
-        
-    }
-    
-    
-    /**
-     * Call preDestroy method on the specified instance.
-     */
-    public static void preDestroy(Object instance)
-        throws IllegalAccessException, InvocationTargetException {
-        
-        Method[] methods = instance.getClass().getDeclaredMethods();
-        Method preDestroy = null;
-        for (int i = 0; i < methods.length; i++) {
-            if (methods[i].isAnnotationPresent(PreDestroy.class)) {
-                if ((preDestroy != null) 
-                        || (methods[i].getParameterTypes().length != 0)
-                        || (Modifier.isStatic(methods[i].getModifiers())) 
-                        || (methods[i].getExceptionTypes().length > 0)
-                        || (!methods[i].getReturnType().getName().equals("void"))) {
-                    throw new IllegalArgumentException("Invalid PreDestroy annotation");
-                }
-                preDestroy = methods[i];
-            }
-        }
-
-        // At the end the postconstruct annotated 
-        // method is invoked
-        if (preDestroy != null) {
-            boolean accessibility = preDestroy.isAccessible();
-            preDestroy.setAccessible(true);
-            preDestroy.invoke(instance);
-            preDestroy.setAccessible(accessibility);
-        }
-        
-    }
-    
-    
-    /**
-     * Inject resources in specified field.
-     */
-    protected static void lookupFieldResource(Object instance, Field field, String name)
-        throws NamingException, IllegalAccessException {
-    
-        Object lookedupResource = null;
-        boolean accessibility = false;
-        
-        Context context = (Context) (new InitialContext()).lookup("java:comp/env");
-        if ((name != null) &&
-                (name.length() > 0)) {
-            lookedupResource = context.lookup(name);
-        } else {
-            lookedupResource = context.lookup(instance.getClass().getName() + "/" + field.getName());
-        }
-        
-        accessibility = field.isAccessible();
-        field.setAccessible(true);
-        field.set(instance, lookedupResource);
-        field.setAccessible(accessibility);
-    }
-
-
-    /**
-     * Inject resources in specified method.
-     */
-    protected static void lookupMethodResource(Object instance, Method method, String name)
-        throws NamingException, IllegalAccessException, InvocationTargetException {
-        
-        if (!method.getName().startsWith("set") 
-                || method.getParameterTypes().length != 1
-                || !method.getReturnType().getName().equals("void")) {
-            throw new IllegalArgumentException("Invalid method resource injection annotation");
-        }
-        
-        Object lookedupResource = null;
-        boolean accessibility = false;
-        
-        Context context = (Context) (new InitialContext()).lookup("java:comp/env");
-        if ((name != null) &&
-                (name.length() > 0)) {
-            lookedupResource = context.lookup(name);
-        } else {
-            lookedupResource = 
-                context.lookup(instance.getClass().getName() + "/" + method.getName().substring(3));
-        }
-        
-        accessibility = method.isAccessible();
-        method.setAccessible(true);
-        method.invoke(instance, lookedupResource);
-        method.setAccessible(accessibility);
-    }
-    
-
-}

==================================================
