950d49999d264e7eb9cd2fed370bb2306925e1f4
==================================================
Port storeconfig functionality to trunk (with a FIXME about the new resources configuration which will need some gets to be able to be persisted).
==================================================
Remy Maucherat
==================================================
Mon Feb 4 16:11:50 2013 +0000
==================================================
MBeanUtils.java
index cdba706de7..39a75b76dd 100644
--- a/build.xml
+++ b/build.xml
@@ -94,6 +94,7 @@
   <property name="catalina-tribes.jar" value="${tomcat.build}/lib/catalina-tribes.jar"/>
   <property name="catalina-ha.jar" value="${tomcat.build}/lib/catalina-ha.jar"/>
   <property name="catalina-ant.jar" value="${tomcat.build}/lib/catalina-ant.jar"/>
+  <property name="catalina-storeconfig.jar" value="${tomcat.build}/lib/catalina-storeconfig.jar"/>
   <property name="tomcat-coyote.jar" value="${tomcat.build}/lib/tomcat-coyote.jar"/>
   <property name="tomcat-jni.jar" value="${tomcat.build}/lib/tomcat-jni.jar"/>
   <property name="tomcat-spdy.jar" value="${tomcat.build}/lib/tomcat-spdy.jar"/>
@@ -120,6 +121,7 @@
   <property name="catalina-tribes-src.jar" value="${tomcat.src.jars}/catalina-tribes-src.jar"/>
   <property name="catalina-ha-src.jar" value="${tomcat.src.jars}/catalina-ha-src.jar"/>
   <property name="catalina-ant-src.jar" value="${tomcat.src.jars}/catalina-ant-src.jar"/>
+  <property name="catalina-storeconfig-src.jar" value="${tomcat.src.jars}/catalina-storeconfig-src.jar"/>
   <property name="tomcat-jni-src.jar" value="${tomcat.src.jars}/tomcat-jni-src.jar"/>
   <property name="tomcat-spdy-src.jar" value="${tomcat.src.jars}/tomcat-spdy-src.jar"/>
   <property name="tomcat-coyote-src.jar" value="${tomcat.src.jars}/tomcat-coyote-src.jar"/>
@@ -326,6 +328,7 @@
     <exclude name="org/apache/catalina/ha/**" />
     <exclude name="org/apache/catalina/mbeans/JmxRemote*" />
     <exclude name="org/apache/catalina/tribes/**" />
+    <exclude name="org/apache/catalina/storeconfig/**" />
     <exclude name="org/apache/naming/factory/webservices/**" />
   </patternset>
 
@@ -343,6 +346,10 @@
     <include name="org/apache/catalina/util/Base64.*" />
   </patternset>
 
+  <patternset id="files.catalina-storeconfig">
+    <include name="org/apache/catalina/storeconfig/**" />
+  </patternset>
+
   <patternset id="files.tomcat-jni">
     <include name="org/apache/tomcat/jni/**" />
   </patternset>
@@ -708,6 +715,11 @@
       filesDir="${tomcat.classes}"
       filesId="files.catalina-ant" />
 
+    <!-- Catalina Storeconfig JAR File -->
+    <jarIt jarfile="${catalina-storeconfig.jar}"
+      filesDir="${tomcat.classes}"
+      filesId="files.catalina-storeconfig" />
+
     <!-- Tomcat API JAR File -->
     <jarIt jarfile="${tomcat-api.jar}"
       filesDir="${tomcat.classes}"
@@ -2329,6 +2341,11 @@ Apache Tomcat ${version} native binaries for Win64 AMD64/EMT64 platform.
       filesDir="java"
       filesId="files.catalina-ant" />
 
+    <!-- Catalina Storeconfig JAR File -->
+    <jarIt jarfile="${catalina-storeconfig-src.jar}"
+      filesDir="java"
+      filesId="files.catalina-storeconfig" />
+
     <!-- Tomcat API JAR File -->
     <jarIt jarfile="${tomcat-api-src.jar}"
       filesDir="java"

==================================================
CatalinaClusterSF.java
index d096877554..9a3ea4d871 100644
--- a/java/org/apache/catalina/mbeans/MBeanUtils.java
+++ b/java/org/apache/catalina/mbeans/MBeanUtils.java
@@ -563,6 +563,7 @@ public class MBeanUtils {
             registry.loadDescriptors("org.apache.catalina.ha", cl);
             registry.loadDescriptors("org.apache.catalina.connector", cl);
             registry.loadDescriptors("org.apache.catalina.valves",  cl);
+            registry.loadDescriptors("org.apache.catalina.storeconfig",  cl);
         }
         return (registry);
 

==================================================
ChannelSF.java
new file mode 100644
index 0000000000..309bc03e37
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/CatalinaClusterSF.java
@@ -0,0 +1,87 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.storeconfig;
+
+import java.io.PrintWriter;
+
+import org.apache.catalina.LifecycleListener;
+import org.apache.catalina.Valve;
+import org.apache.catalina.ha.CatalinaCluster;
+import org.apache.catalina.ha.ClusterDeployer;
+import org.apache.catalina.ha.ClusterListener;
+import org.apache.catalina.ha.ClusterManager;
+import org.apache.catalina.ha.tcp.SimpleTcpCluster;
+import org.apache.catalina.tribes.Channel;
+
+/**
+ * Generate Cluster Element with Membership,Sender,Receiver,Deployer and
+ * ReplicationValve
+ */
+public class CatalinaClusterSF extends StoreFactoryBase {
+
+    /**
+     * Store the specified Cluster childs.
+     * 
+     * @param aWriter
+     *            PrintWriter to which we are storing
+     * @param indent
+     *            Number of spaces to indent this element
+     * @param aCluster
+     *            Cluster whose properties are being stored
+     * 
+     * @exception Exception
+     *                if an exception occurs while storing
+     */
+    public void storeChilds(PrintWriter aWriter, int indent, Object aCluster,
+            StoreDescription parentDesc) throws Exception {
+        if (aCluster instanceof CatalinaCluster) {
+            CatalinaCluster cluster = (CatalinaCluster) aCluster;
+            if (cluster instanceof SimpleTcpCluster) {
+                SimpleTcpCluster tcpCluster = (SimpleTcpCluster) cluster;
+                // Store nested <Manager> element
+                ClusterManager manager = tcpCluster.getManagerTemplate();
+                if (manager != null) {
+                    storeElement(aWriter, indent, manager);
+                }
+            }
+            // Store nested <Channel> element
+            Channel channel = cluster.getChannel();
+            if (channel != null) {
+                storeElement(aWriter, indent, channel);
+            }
+            // Store nested <Deployer> element
+            ClusterDeployer deployer = cluster.getClusterDeployer();
+            if (deployer != null) {
+                storeElement(aWriter, indent, deployer);
+            }
+            // Store nested <Valve> element
+            // ClusterValve are not store at Hosts element, see
+            Valve valves[] = cluster.getValves();
+            storeElementArray(aWriter, indent, valves);
+ 
+            if (aCluster instanceof SimpleTcpCluster) {
+                // Store nested <Listener> elements
+                LifecycleListener listeners[] = ((SimpleTcpCluster)cluster).findLifecycleListeners();
+                storeElementArray(aWriter, indent, listeners);
+                // Store nested <ClusterListener> elements
+                ClusterListener mlisteners[] = ((SimpleTcpCluster)cluster).findClusterListeners();
+                storeElementArray(aWriter, indent, mlisteners);
+            }
+        }
+    }
+}
\ No newline at end of file

==================================================
ConnectorSF.java
new file mode 100644
index 0000000000..aaf1b71c88
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/ChannelSF.java
@@ -0,0 +1,77 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.storeconfig;
+
+import java.io.PrintWriter;
+import java.util.Iterator;
+
+import org.apache.catalina.tribes.Channel;
+import org.apache.catalina.tribes.ChannelInterceptor;
+import org.apache.catalina.tribes.ChannelReceiver;
+import org.apache.catalina.tribes.ChannelSender;
+import org.apache.catalina.tribes.ManagedChannel;
+import org.apache.catalina.tribes.MembershipService;
+
+/**
+ * Generate Channel Element
+ */
+public class ChannelSF extends StoreFactoryBase {
+
+    /**
+     * Store the specified Channel childs.
+     * 
+     * @param aWriter
+     *            PrintWriter to which we are storing
+     * @param indent
+     *            Number of spaces to indent this element
+     * @param aChannel
+     *            Channel whose properties are being stored
+     * 
+     * @exception Exception
+     *                if an exception occurs while storing
+     */
+    public void storeChilds(PrintWriter aWriter, int indent, Object aChannel,
+            StoreDescription parentDesc) throws Exception {
+        if (aChannel instanceof Channel) {
+            Channel channel = (Channel) aChannel;
+            if (channel instanceof ManagedChannel) {
+                ManagedChannel managedChannel = (ManagedChannel) channel;
+                // Store nested <Membership> element
+                MembershipService service = managedChannel.getMembershipService();
+                if (service != null) {
+                    storeElement(aWriter, indent, service);
+                }
+                // Store nested <Sender> element
+                ChannelSender sender = managedChannel.getChannelSender();
+                if (sender != null) {
+                    storeElement(aWriter, indent, sender);
+                }
+                // Store nested <Receiver> element
+                ChannelReceiver receiver = managedChannel.getChannelReceiver();
+                if (receiver != null) {
+                    storeElement(aWriter, indent, receiver);
+                }
+                Iterator<ChannelInterceptor> interceptors = managedChannel.getInterceptors();
+                while (interceptors.hasNext()) {
+                    ChannelInterceptor interceptor = interceptors.next();
+                    storeElement(aWriter, indent, interceptor);
+                }
+            }
+       }
+    }
+}
\ No newline at end of file

==================================================
ConnectorStoreAppender.java
new file mode 100644
index 0000000000..842da08491
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/ConnectorSF.java
@@ -0,0 +1,86 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.storeconfig;
+
+import java.io.PrintWriter;
+
+import org.apache.catalina.Lifecycle;
+import org.apache.catalina.LifecycleListener;
+import org.apache.catalina.connector.Connector;
+
+/**
+ * Store Connector and Listeners
+ */
+public class ConnectorSF extends StoreFactoryBase {
+
+    /**
+     * Store Connector description
+     * 
+     * @param aWriter
+     * @param indent
+     * @param aConnector
+     * @throws Exception
+     */
+    public void storeChilds(PrintWriter aWriter, int indent, Object aConnector,
+            StoreDescription parentDesc) throws Exception {
+
+        if (aConnector instanceof Connector) {
+            Connector connector = (Connector) aConnector;
+            // Store nested <Listener> elements
+            if (connector instanceof Lifecycle) {
+                LifecycleListener listeners[] = ((Lifecycle) connector)
+                        .findLifecycleListeners();
+                storeElementArray(aWriter, indent, listeners);
+            }
+        }
+    }
+
+    protected void printOpenTag(PrintWriter aWriter, int indent, Object bean,
+            StoreDescription aDesc) throws Exception {
+        aWriter.print("<");
+        aWriter.print(aDesc.getTag());
+        storeConnectorAttribtues(aWriter, indent, bean, aDesc);
+        aWriter.println(">");
+    }
+
+    protected void storeConnectorAttribtues(PrintWriter aWriter, int indent,
+            Object bean, StoreDescription aDesc) throws Exception {
+        if (aDesc.isAttributes()) {
+            getStoreAppender().printAttributes(aWriter, indent, false, bean,
+                    aDesc);
+            /*
+             * if (bean instanceof Connector) { StoreDescription elementDesc =
+             * getRegistry().findDescription( bean.getClass().getName() +
+             * ".[ProtocolHandler]"); if (elementDesc != null) { ProtocolHandler
+             * protocolHandler = ((Connector) bean) .getProtocolHandler(); if
+             * (protocolHandler != null)
+             * getStoreAppender().printAttributes(aWriter, indent, false,
+             * protocolHandler, elementDesc); } }
+             */
+        }
+    }
+
+    protected void printTag(PrintWriter aWriter, int indent, Object bean,
+            StoreDescription aDesc) throws Exception {
+        aWriter.print("<");
+        aWriter.print(aDesc.getTag());
+        storeConnectorAttribtues(aWriter, indent, bean, aDesc);
+        aWriter.println("/>");
+    }
+
+}
\ No newline at end of file

==================================================
Constants.java
new file mode 100644
index 0000000000..1ab776011c
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/ConnectorStoreAppender.java
@@ -0,0 +1,295 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.storeconfig;
+
+import java.beans.IndexedPropertyDescriptor;
+import java.beans.IntrospectionException;
+import java.beans.Introspector;
+import java.beans.PropertyDescriptor;
+import java.io.File;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.net.InetAddress;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+
+import org.apache.catalina.connector.Connector;
+import org.apache.coyote.ProtocolHandler;
+import org.apache.tomcat.util.IntrospectionUtils;
+
+/**
+ * Store the Connector attributes. Connector has really special design. A
+ * Connector is only a startup Wrapper for a ProtocolHandler. This meant that
+ * ProtocolHandler get all there attribtues from the Connector attribtue map.
+ * Strange is that some attributes change there name and the attribute
+ * sslProtocol need a sepzial handling
+ */
+public class ConnectorStoreAppender extends StoreAppender {
+
+    protected static HashMap<String, String> replacements = new HashMap<>();
+    static {
+        replacements.put("backlog", "acceptCount");
+        replacements.put("soLinger", "connectionLinger");
+        replacements.put("soTimeout", "connectionTimeout");
+        replacements.put("timeout", "connectionUploadTimeout");
+        replacements.put("clientauth", "clientAuth");
+        replacements.put("keystore", "keystoreFile");
+        replacements.put("randomfile", "randomFile");
+        replacements.put("rootfile", "rootFile");
+        replacements.put("keypass", "keystorePass");
+        replacements.put("keytype", "keystoreType");
+        replacements.put("protocol", "sslProtocol");
+        replacements.put("protocols", "sslProtocols");
+    }
+
+    /**
+     * Store the relevant attributes of the specified JavaBean.
+     * 
+     * @param writer
+     *            PrintWriter to which we are storing
+     * @param include
+     *            Should we include a <code>className</code> attribute?
+     * @param bean
+     *            Bean whose properties are to be rendered as attributes,
+     * @param desc
+     *            RegistryDescrpitor from this bean
+     * 
+     * @exception Exception
+     *                if an exception occurs while storing
+     */
+    public void printAttributes(PrintWriter writer, int indent,
+            boolean include, Object bean, StoreDescription desc)
+            throws Exception {
+
+        // Render a className attribute if requested
+        if (include && desc != null && !desc.isStandard()) {
+            writer.print(" className=\"");
+            writer.print(bean.getClass().getName());
+            writer.print("\"");
+        }
+
+        Connector connector = (Connector) bean;
+        String protocol = connector.getProtocol();
+        List<String> propertyKeys = getPropertyKeys(connector);
+        // Create blank instance
+        Object bean2 = new Connector(protocol);//defaultInstance(bean);
+        Iterator<String> propertyIterator = propertyKeys.iterator();
+        while (propertyIterator.hasNext()) {
+            String key = propertyIterator.next();
+            Object value = (Object) IntrospectionUtils.getProperty(bean, key);
+
+            if (desc.isTransientAttribute(key)) {
+                continue; // Skip the specified exceptions
+            }
+            if (value == null) {
+                continue; // Null values are not persisted
+            }
+            // Convert IP addresses to strings so they will be persisted
+            if (value instanceof InetAddress) {
+                value = ((InetAddress) value).getHostAddress();
+            }
+            if (!isPersistable(value.getClass())) {
+                continue;
+            }
+            Object value2 = IntrospectionUtils.getProperty(bean2, key);
+            if (value.equals(value2)) {
+                // The property has its default value
+                continue;
+            }
+            if (isPrintValue(bean, bean2, key, desc)) {
+                printValue(writer, indent, key, value);
+            }
+        }
+        if (protocol != null && !"HTTP/1.1".equals(protocol))
+            super.printValue(writer, indent, "protocol", protocol);
+
+    }
+
+    /**
+     * Get all properties from Connector and current ProtocolHandler
+     * 
+     * @param bean
+     * @return List of Connector Properties
+     * @throws IntrospectionException
+     */
+    protected List<String> getPropertyKeys(Connector bean)
+            throws IntrospectionException {
+        ArrayList<String> propertyKeys = new ArrayList<>();
+        // Acquire the list of properties for this bean
+        ProtocolHandler protocolHandler = bean.getProtocolHandler();
+        // Acquire the list of properties for this bean
+        PropertyDescriptor descriptors[] = Introspector.getBeanInfo(
+                bean.getClass()).getPropertyDescriptors();
+        if (descriptors == null) {
+            descriptors = new PropertyDescriptor[0];
+        }
+        for (int i = 0; i < descriptors.length; i++) {
+            if (descriptors[i] instanceof IndexedPropertyDescriptor) {
+                continue; // Indexed properties are not persisted
+            }
+            if (!isPersistable(descriptors[i].getPropertyType())
+                    || (descriptors[i].getReadMethod() == null)
+                    || (descriptors[i].getWriteMethod() == null)) {
+                continue; // Must be a read-write primitive or String
+            }
+            if ("protocol".equals(descriptors[i].getName())
+                    || "protocolHandlerClassName".equals(descriptors[i]
+                            .getName()))
+                continue;
+            propertyKeys.add(descriptors[i].getName());
+        }
+        // Add the properties of the protocol handler
+        descriptors = Introspector.getBeanInfo(
+                protocolHandler.getClass()).getPropertyDescriptors();
+        if (descriptors == null) {
+            descriptors = new PropertyDescriptor[0];
+        }
+        for (int i = 0; i < descriptors.length; i++) {
+            if (descriptors[i] instanceof IndexedPropertyDescriptor) {
+                continue; // Indexed properties are not persisted
+            }
+            if (!isPersistable(descriptors[i].getPropertyType())
+                    || (descriptors[i].getReadMethod() == null)
+                    || (descriptors[i].getWriteMethod() == null)) {
+                continue; // Must be a read-write primitive or String
+            }
+            String key = descriptors[i].getName();
+            if (replacements.get(key) != null) {
+                key = (String) replacements.get(key);
+            }
+            if (!propertyKeys.contains(key)) {
+                propertyKeys.add(key);
+            }
+        }
+        return propertyKeys;
+    }
+
+    /**
+     * print Attributes
+     * 
+     * @param aWriter
+     * @param indent
+     * @param bean
+     * @param aDesc
+     * @throws Exception
+     */
+    protected void storeConnectorAttribtues(PrintWriter aWriter, int indent,
+            Object bean, StoreDescription aDesc) throws Exception {
+        if (aDesc.isAttributes()) {
+            printAttributes(aWriter, indent, false, bean, aDesc);
+        }
+    }
+
+    /*
+     * Print the open tag for connector attributes (override)
+     * 
+     * @see org.apache.catalina.storeconfig.StoreAppender#printOpenTag(java.io.PrintWriter,
+     *      int, java.lang.Object,
+     *      org.apache.catalina.storeconfig.StoreDescription)
+     */
+    public void printOpenTag(PrintWriter aWriter, int indent, Object bean,
+            StoreDescription aDesc) throws Exception {
+        aWriter.print("<");
+        aWriter.print(aDesc.getTag());
+        storeConnectorAttribtues(aWriter, indent, bean, aDesc);
+        aWriter.println(">");
+    }
+
+    /**
+     * print a tag for connector attributes (override)
+     * 
+     * @see org.apache.catalina.storeconfig.StoreAppender#printTag(java.io.PrintWriter,
+     *      int, java.lang.Object,
+     *      org.apache.catalina.storeconfig.StoreDescription)
+     */
+    public void printTag(PrintWriter aWriter, int indent, Object bean,
+            StoreDescription aDesc) throws Exception {
+        aWriter.print("<");
+        aWriter.print(aDesc.getTag());
+        storeConnectorAttribtues(aWriter, indent, bean, aDesc);
+        aWriter.println("/>");
+    }
+
+    /**
+     * print a value but replace attribute name
+     * 
+     * @param writer
+     * @param name
+     * @param value
+     * @see org.apache.catalina.storeconfig.StoreAppender#printValue(java.io.PrintWriter,
+     *      int, java.lang.String, java.lang.Object)
+     */
+    public void printValue(PrintWriter writer, int indent, String name,
+            Object value) {
+        String repl = name;
+        if (replacements.get(name) != null) {
+            repl = (String) replacements.get(name);
+        }
+        super.printValue(writer, indent, repl, value);
+    }
+    
+    /*
+     * Print Connector Values. <ul><li> Spezial handling to default jkHome.
+     * </li><li> Don't save catalina.base path at server.xml</li><li></ul>
+     * 
+     * @see org.apache.catalina.config.StoreAppender#isPrintValue(java.lang.Object,
+     *      java.lang.Object, java.lang.String,
+     *      org.apache.catalina.config.StoreDescription)
+     */
+    public boolean isPrintValue(Object bean, Object bean2, String attrName,
+            StoreDescription desc) {
+        boolean isPrint = super.isPrintValue(bean, bean2, attrName, desc);
+        if (isPrint) {
+            if ("jkHome".equals(attrName)) {
+                Connector connector = ((Connector) bean);
+                File catalinaBase = getCatalinaBase();
+                File jkHomeBase = getJkHomeBase((String) connector
+                        .getProperty("jkHome"), catalinaBase);
+                isPrint = !catalinaBase.equals(jkHomeBase);
+
+            }
+        }
+        return isPrint;
+    }
+
+    protected File getCatalinaBase() {
+
+        File file = new File(System.getProperty("catalina.base"));
+        try {
+            file = file.getCanonicalFile();
+        } catch (IOException e) {
+        }
+        return (file);
+    }
+
+    protected File getJkHomeBase(String jkHome, File appBase) {
+
+        File jkHomeBase;
+        File file = new File(jkHome);
+        if (!file.isAbsolute())
+            file = new File(appBase, jkHome);
+        try {
+            jkHomeBase = file.getCanonicalFile();
+        } catch (IOException e) {
+            jkHomeBase = file;
+        }
+        return (jkHomeBase);
+    }
+
+}
\ No newline at end of file

==================================================
GlobalNamingResourcesSF.java
new file mode 100644
index 0000000000..1238057146
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/Constants.java
@@ -0,0 +1,24 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.storeconfig;
+
+public class Constants {
+
+    public static final String Package = "org.apache.catalina.storeconfig";
+
+}
\ No newline at end of file

==================================================
IStoreConfig.java
new file mode 100644
index 0000000000..5b444a6c8c
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/GlobalNamingResourcesSF.java
@@ -0,0 +1,75 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.storeconfig;
+
+import java.io.PrintWriter;
+
+import org.apache.catalina.deploy.NamingResources;
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+
+/**
+ * store server.xml GlobalNamingResource.
+ */
+public class GlobalNamingResourcesSF extends StoreFactoryBase {
+    private static Log log = LogFactory.getLog(GlobalNamingResourcesSF.class);
+
+    /*
+     * Store with NamingResource Factory
+     * 
+     * @see org.apache.catalina.storeconfig.IStoreFactory#store(java.io.PrintWriter,
+     *      int, java.lang.Object)
+     */
+    public void store(PrintWriter aWriter, int indent, Object aElement)
+            throws Exception {
+
+        if (aElement instanceof NamingResources) {
+
+            StoreDescription elementDesc = getRegistry().findDescription(
+                    NamingResources.class.getName()
+                            + ".[GlobalNamingResources]");
+
+            if (elementDesc != null) {
+                getStoreAppender().printIndent(aWriter, indent + 2);
+                getStoreAppender().printOpenTag(aWriter, indent + 2, aElement,
+                        elementDesc);
+                NamingResources resources = (NamingResources) aElement;
+                StoreDescription resourcesdesc = getRegistry().findDescription(
+                        NamingResources.class.getName());
+                if (resourcesdesc != null) {
+                    resourcesdesc.getStoreFactory().store(aWriter, indent + 2,
+                            resources);
+                } else {
+                    if(log.isWarnEnabled())
+                        log.warn("Can't find NamingRsources Store Factory!");
+                }
+                    
+                getStoreAppender().printIndent(aWriter, indent + 2);
+                getStoreAppender().printCloseTag(aWriter, elementDesc);
+            } else {
+                if (log.isWarnEnabled())
+                    log.warn("Descriptor for element" + aElement.getClass()
+                            + " not configured!");
+            }
+        } else {
+            if (log.isWarnEnabled())
+                log.warn("wrong element " + aElement.getClass());
+
+        }
+    }
+}
+

==================================================
IStoreFactory.java
new file mode 100644
index 0000000000..e19bc46f9f
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/IStoreConfig.java
@@ -0,0 +1,147 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.storeconfig;
+
+import java.io.PrintWriter;
+
+import org.apache.catalina.Context;
+import org.apache.catalina.Host;
+import org.apache.catalina.Server;
+import org.apache.catalina.Service;
+
+public interface IStoreConfig {
+
+    /**
+     * Get Configuration Registry
+     * 
+     * @return aRegistry that handle the store operations
+     */
+    StoreRegistry getRegistry();
+
+    /**
+     * Set Configuration Registry
+     * 
+     * @param aRegistry
+     *            aregistry that handle the store operations
+     */
+    void setRegistry(StoreRegistry aRegistry);
+
+    /**
+     * Get associated server
+     * 
+     * @return aServer the associated server
+     */
+    Server getServer();
+
+    /**
+     * Set associated server
+     * 
+     * @param aServer the associated server
+     */
+    void setServer(Server aServer);
+
+    /**
+     * Store the current StoreFactory Server.
+     * 
+     * @exception Exception
+     *                if an exception occurs while storing
+     */
+    void storeConfig() throws Exception;
+
+    /**
+     * Store the specified Server properties.
+     * 
+     * @param aServer
+     *            Object to be stored
+     * 
+     * @exception Exception
+     *                if an exception occurs while storing
+     */
+    void store(Server aServer) throws Exception;
+
+    /**
+     * Store the specified Server properties.
+     * 
+     * @param aWriter
+     *            PrintWriter to which we are storing
+     * @param indent
+     *            Number of spaces to indent this element
+     * @param aServer
+     *            Object to be stored
+     * 
+     * @exception Exception
+     *                if an exception occurs while storing
+     */
+    void store(PrintWriter aWriter, int indent, Server aServer);
+
+    /**
+     * Store the specified Service properties.
+     * 
+     * @param aWriter
+     *            PrintWriter to which we are storing
+     * @param indent
+     *            Number of spaces to indent this element
+     * @param aService
+     *            Object to be stored
+     * 
+     * @exception Exception
+     *                if an exception occurs while storing
+     */
+    void store(PrintWriter aWriter, int indent, Service aService);
+
+    /**
+     * Store the specified Host properties.
+     * 
+     * @param aWriter
+     *            PrintWriter to which we are storing
+     * @param indent
+     *            Number of spaces to indent this element
+     * @param aHost
+     *            Object to be stored
+     * 
+     * @exception Exception
+     *                if an exception occurs while storing
+     */
+    void store(PrintWriter aWriter, int indent, Host aHost);
+
+    /**
+     * Store the specified Context properties.
+     * 
+     * @param aContext
+     *            Object to be stored
+     * 
+     * @exception Exception
+     *                if an exception occurs while storing
+     */
+    void store(Context aContext);
+
+    /**
+     * Store the specified Context properties.
+     * 
+     * @param aWriter
+     *            PrintWriter to which we are storing
+     * @param indent
+     *            Number of spaces to indent this element
+     * @param aContext
+     *            Object to be stored
+     * 
+     * @exception Exception
+     *                if an exception occurs while storing
+     */
+    void store(PrintWriter aWriter, int indent, Context aContext);
+}
\ No newline at end of file

==================================================
InstanceListenerSF.java
new file mode 100644
index 0000000000..4e398a90cb
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/IStoreFactory.java
@@ -0,0 +1,34 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.storeconfig;
+
+import java.io.PrintWriter;
+
+public interface IStoreFactory {
+    StoreAppender getStoreAppender();
+
+    void setStoreAppender(StoreAppender storeWriter);
+
+    void setRegistry(StoreRegistry aRegistry);
+
+    StoreRegistry getRegistry();
+
+    void store(PrintWriter aWriter, int indent, Object aElement)
+            throws Exception;
+
+    void storeXMLHead(PrintWriter aWriter);
+}
\ No newline at end of file

==================================================
InterceptorSF.java
new file mode 100644
index 0000000000..7493d45a52
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/InstanceListenerSF.java
@@ -0,0 +1,58 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.storeconfig;
+
+import java.io.PrintWriter;
+
+import org.apache.catalina.core.StandardContext;
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+
+/**
+ * Store Context InstanceListener
+ */
+public class InstanceListenerSF extends StoreFactoryBase {
+    private static Log log = LogFactory.getLog(InstanceListenerSF.class);
+
+    /*
+     * Store nested Element Value Arrays
+     * 
+     * @see org.apache.catalina.config.IStoreFactory#store(java.io.PrintWriter,
+     *      int, java.lang.Object)
+     */
+    public void store(PrintWriter aWriter, int indent, Object aElement)
+            throws Exception {
+        if (aElement instanceof StandardContext) {
+            StoreDescription elementDesc = getRegistry().findDescription(
+                    aElement.getClass().getName() + ".[InstanceListener]");
+            String[] listeners = ((StandardContext) aElement)
+                    .findInstanceListeners();
+            if (elementDesc != null) {
+                if (log.isDebugEnabled())
+                    log.debug("store " + elementDesc.getTag() + "( " + aElement
+                            + " )");
+                getStoreAppender().printTagArray(aWriter, "InstanceListener",
+                        indent, listeners);
+            }
+        } else {
+            if (log.isWarnEnabled())
+                log.warn("Descriptor for element" + aElement.getClass()
+                        + ".[InstanceListener] not configured!");
+        }
+    }
+}
\ No newline at end of file

==================================================
LoaderSF.java
new file mode 100644
index 0000000000..be73951845
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/InterceptorSF.java
@@ -0,0 +1,50 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.storeconfig;
+
+import java.io.PrintWriter;
+
+import org.apache.catalina.tribes.ChannelInterceptor;
+
+/**
+ * Generate Interceptor Element
+ */
+public class InterceptorSF extends StoreFactoryBase {
+
+    /**
+     * Store the specified Interceptor child.
+     * 
+     * @param aWriter
+     *            PrintWriter to which we are storing
+     * @param indent
+     *            Number of spaces to indent this element
+     * @param aInterceptor
+     *            Channel whose properties are being stored
+     * 
+     * @exception Exception
+     *                if an exception occurs while storing
+     */
+    public void storeChilds(PrintWriter aWriter, int indent, Object aInterceptor,
+            StoreDescription parentDesc) throws Exception {
+        if (aInterceptor instanceof ChannelInterceptor) {
+            ChannelInterceptor interceptor = (ChannelInterceptor) aInterceptor;
+            // Store nested <Member> elements
+            storeElementArray(aWriter, indent + 2, interceptor.getMembers());
+       }
+    }
+}
\ No newline at end of file

==================================================
ManagerSF.java
new file mode 100644
index 0000000000..a0fe132b58
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/LocalStrings.properties
@@ -0,0 +1,17 @@
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+factory.storeTag=store tag {0} ( Object: {1} )
+factory.storeNoDescriptor=Descriptor for element class {0} not configured!

==================================================
NamingResourcesSF.java
new file mode 100644
index 0000000000..e0a2a750e9
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/ManagerSF.java
@@ -0,0 +1,80 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.storeconfig;
+
+import java.io.PrintWriter;
+
+import org.apache.catalina.session.StandardManager;
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+
+/**
+ * Store server.xml Manager element
+ */
+public class ManagerSF extends StoreFactoryBase {
+
+    private static Log log = LogFactory.getLog(ManagerSF.class);
+
+    /**
+     * Store the only the Manager elements
+     * 
+     * @see NamingResourcesSF#storeChilds(PrintWriter, int, Object, StoreDescription)
+     */
+    public void store(PrintWriter aWriter, int indent, Object aElement)
+            throws Exception {
+        StoreDescription elementDesc = getRegistry().findDescription(
+                aElement.getClass());
+        if (elementDesc != null) {
+            if (aElement instanceof StandardManager) {
+                StandardManager manager = (StandardManager) aElement;
+                if (!isDefaultManager(manager)) {
+                    if (log.isDebugEnabled())
+                        log.debug(sm.getString("factory.storeTag", elementDesc
+                                .getTag(), aElement));
+                    getStoreAppender().printIndent(aWriter, indent + 2);
+                    getStoreAppender().printTag(aWriter, indent + 2, manager,
+                            elementDesc);
+                }
+            } else {
+                super.store(aWriter, indent, aElement);
+            }
+        } else {
+            if (log.isWarnEnabled())
+                log.warn(sm.getString("factory.storeNoDescriptor", aElement
+                        .getClass()));
+        }
+    }
+
+    /**
+     * Is this an instance of the default <code>Manager</code> configuration,
+     * with all-default properties?
+     * 
+     * @param smanager
+     *            Manager to be tested
+     */
+    protected boolean isDefaultManager(StandardManager smanager) {
+
+        if (!"SESSIONS.ser".equals(smanager.getPathname())
+                || (smanager.getMaxActiveSessions() != -1)) {
+            return (false);
+        }
+        return (true);
+
+    }
+
+}

==================================================
PersistentManagerSF.java
new file mode 100644
index 0000000000..7ef5368429
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/NamingResourcesSF.java
@@ -0,0 +1,105 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.storeconfig;
+
+import java.io.PrintWriter;
+
+import org.apache.catalina.deploy.ContextEjb;
+import org.apache.catalina.deploy.ContextEnvironment;
+import org.apache.catalina.deploy.ContextLocalEjb;
+import org.apache.catalina.deploy.ContextResource;
+import org.apache.catalina.deploy.ContextResourceEnvRef;
+import org.apache.catalina.deploy.ContextResourceLink;
+import org.apache.catalina.deploy.NamingResources;
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+
+/**
+ * Store server.xml elements Resources at context and GlobalNamingResources
+ */
+public class NamingResourcesSF extends StoreFactoryBase {
+    private static Log log = LogFactory.getLog(NamingResourcesSF.class);
+
+    /**
+     * Store the only the NamingResources elements
+     * 
+     * @see NamingResourcesSF#storeChilds(PrintWriter, int, Object, StoreDescription)
+     */
+    public void store(PrintWriter aWriter, int indent, Object aElement)
+            throws Exception {
+        StoreDescription elementDesc = getRegistry().findDescription(
+                aElement.getClass());
+        if (elementDesc != null) {
+            if (log.isDebugEnabled())
+                log.debug("store " + elementDesc.getTag() + "( " + aElement
+                        + " )");
+            storeChilds(aWriter, indent, aElement, elementDesc);
+        } else {
+            if (log.isWarnEnabled())
+                log.warn("Descriptor for element" + aElement.getClass()
+                        + " not configured!");
+        }
+    }
+
+    /**
+     * Store the specified NamingResources properties.
+     * 
+     * @param aWriter
+     *            PrintWriter to which we are storing
+     * @param indent
+     *            Number of spaces to indent this element
+     * @param aElement
+     *            Object whose properties are being stored
+     * @param elementDesc
+     *            element descriptor
+     * 
+     * @exception Exception
+     *                if an exception occurs while storing
+     * 
+     * @see org.apache.catalina.storeconfig.StoreFactoryBase#storeChilds(java.io.PrintWriter,
+     *      int, java.lang.Object, StoreDescription)
+     */
+    public void storeChilds(PrintWriter aWriter, int indent, Object aElement,
+            StoreDescription elementDesc) throws Exception {
+
+        if (aElement instanceof NamingResources) {
+            NamingResources resources = (NamingResources) aElement;
+            // Store nested <Ejb> elements
+            ContextEjb[] ejbs = resources.findEjbs();
+            storeElementArray(aWriter, indent, ejbs);
+            // Store nested <Environment> elements
+            ContextEnvironment[] envs = resources.findEnvironments();
+            storeElementArray(aWriter, indent, envs);
+            // Store nested <LocalEjb> elements
+            ContextLocalEjb[] lejbs = resources.findLocalEjbs();
+            storeElementArray(aWriter, indent, lejbs);
+
+            // Store nested <Resource> elements
+            ContextResource[] dresources = resources.findResources();
+            storeElementArray(aWriter, indent, dresources);
+
+            // Store nested <ResourceEnvRef> elements
+            ContextResourceEnvRef[] resEnv = resources.findResourceEnvRefs();
+            storeElementArray(aWriter, indent, resEnv);
+
+            // Store nested <ResourceLink> elements
+            ContextResourceLink[] resourceLinks = resources.findResourceLinks();
+            storeElementArray(aWriter, indent, resourceLinks);
+        }
+    }
+}
+

==================================================
SenderSF.java
new file mode 100644
index 0000000000..f709c033c0
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/PersistentManagerSF.java
@@ -0,0 +1,55 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.storeconfig;
+
+import java.io.PrintWriter;
+
+import org.apache.catalina.Store;
+import org.apache.catalina.session.PersistentManager;
+
+/**
+ * store server.xml PersistentManager element with nested "Store"
+ */
+public class PersistentManagerSF extends StoreFactoryBase {
+
+    /**
+     * Store the specified PersistentManager properties.
+     * 
+     * @param aWriter
+     *            PrintWriter to which we are storing
+     * @param indent
+     *            Number of spaces to indent this element
+     * @param aManager
+     *            PersistentManager whose properties are being stored
+     * 
+     * @exception Exception
+     *                if an exception occurs while storing
+     */
+    public void storeChilds(PrintWriter aWriter, int indent, Object aManager,
+            StoreDescription parentDesc) throws Exception {
+        if (aManager instanceof PersistentManager) {
+            PersistentManager manager = (PersistentManager) aManager;
+
+            // Store nested <Manager> elements
+            Store store = manager.getStore();
+            storeElement(aWriter, indent, store);
+
+        }
+    }
+
+}
\ No newline at end of file

==================================================
StandardContextSF.java
new file mode 100644
index 0000000000..221172ad70
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/SenderSF.java
@@ -0,0 +1,54 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.storeconfig;
+
+import java.io.PrintWriter;
+
+import org.apache.catalina.tribes.transport.MultiPointSender;
+import org.apache.catalina.tribes.transport.ReplicationTransmitter;
+
+/**
+ * Generate Sender Element
+ */
+public class SenderSF extends StoreFactoryBase {
+
+    /**
+     * Store the specified Sender child.
+     * 
+     * @param aWriter
+     *            PrintWriter to which we are storing
+     * @param indent
+     *            Number of spaces to indent this element
+     * @param aSender
+     *            Channel whose properties are being stored
+     * 
+     * @exception Exception
+     *                if an exception occurs while storing
+     */
+    public void storeChilds(PrintWriter aWriter, int indent, Object aSender,
+            StoreDescription parentDesc) throws Exception {
+        if (aSender instanceof ReplicationTransmitter) {
+            ReplicationTransmitter transmitter = (ReplicationTransmitter) aSender;
+            // Store nested <Transport> element
+            MultiPointSender transport = transmitter.getTransport();
+            if (transport != null) {
+                storeElement(aWriter, indent, transport);
+            }
+       }
+    }
+}
\ No newline at end of file

==================================================
StandardEngineSF.java
new file mode 100644
index 0000000000..22b1fb4cc8
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/StandardContextSF.java
@@ -0,0 +1,377 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.storeconfig;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
+import java.io.PrintWriter;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.catalina.Container;
+import org.apache.catalina.Context;
+import org.apache.catalina.Engine;
+import org.apache.catalina.Host;
+import org.apache.catalina.Lifecycle;
+import org.apache.catalina.LifecycleListener;
+import org.apache.catalina.Loader;
+import org.apache.catalina.Manager;
+import org.apache.catalina.Realm;
+import org.apache.catalina.Valve;
+import org.apache.catalina.WebResourceRoot;
+import org.apache.catalina.core.StandardContext;
+import org.apache.catalina.deploy.ApplicationParameter;
+import org.apache.catalina.deploy.NamingResources;
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+
+/**
+ * Store server.xml Context element with all childs
+ * <ul>
+ * <li>Store all context at server.xml</li>
+ * <li>Store existing app.xml context a conf/enginename/hostname/app.xml</li>
+ * <li>Store with backup</li>
+ * </ul>
+ */
+public class StandardContextSF extends StoreFactoryBase {
+
+    private static Log log = LogFactory.getLog(StandardContextSF.class);
+
+    /*
+     * Store a Context as Separate file as configFile value from context exists.
+     * filename can be relative to catalina.base.
+     * 
+     * @see org.apache.catalina.config.IStoreFactory#store(java.io.PrintWriter,
+     *      int, java.lang.Object)
+     */
+    public void store(PrintWriter aWriter, int indent, Object aContext)
+            throws Exception {
+
+        if (aContext instanceof StandardContext) {
+            StoreDescription desc = getRegistry().findDescription(
+                    aContext.getClass());
+            if (desc.isStoreSeparate()) {
+                URL configFile = ((StandardContext) aContext)
+                        .getConfigFile();
+                if (configFile != null) {
+                    if (desc.isExternalAllowed()) {
+                        if (desc.isBackup())
+                            storeWithBackup((StandardContext) aContext);
+                        else
+                            storeContextSeparate(aWriter, indent,
+                                    (StandardContext) aContext);
+                        return;
+                    }
+                } else if (desc.isExternalOnly()) {
+                    return;
+                }
+            }
+        }
+        super.store(aWriter, indent, aContext);
+
+    }
+
+    /**
+     * Store a Context without backup add separate file or when configFile =
+     * null a aWriter.
+     * 
+     * @param aWriter
+     * @param indent
+     * @param aContext
+     * @throws Exception
+     */
+    protected void storeContextSeparate(PrintWriter aWriter, int indent,
+            StandardContext aContext) throws Exception {
+        URL configFile = aContext.getConfigFile();
+        PrintWriter writer = null;
+        if (configFile != null) {
+            File config = new File(configFile.toURI());
+            if (!config.isAbsolute()) {
+                config = new File(System.getProperty("catalina.base"),
+                        config.getPath());
+            }            
+            if( (!config.isFile()) || (!config.canWrite())) {
+                log.error("Cannot write context output file at "
+                            + configFile + ", not saving.");
+                throw new IOException("Context save file at "
+                                      + configFile
+                                      + " not a file, or not writable.");
+            }
+            if (log.isInfoEnabled())
+                log.info("Store Context " + aContext.getPath()
+                        + " separate at file " + config);
+            try {
+                writer = new PrintWriter(new OutputStreamWriter(
+                        new FileOutputStream(config), getRegistry()
+                                .getEncoding()));
+                storeXMLHead(writer);
+                super.store(writer, -2, aContext);
+            } finally {
+                if (writer != null) {
+                    try {
+                        writer.flush();
+                    } catch (Exception e) {
+                        ;
+                    }
+                    try {
+                        writer.close();
+                    } catch (Throwable t) {
+                        ;
+                    }
+                }
+            }
+        } else {
+            super.store(aWriter, indent, aContext);
+        }
+    }
+
+    /**
+     * Store the Context with a Backup
+     * 
+     * @param aContext
+     * @throws Exception
+     */
+    protected void storeWithBackup(StandardContext aContext) throws Exception {
+        StoreFileMover mover = getConfigFileWriter((Context) aContext);
+        if (mover != null) {
+            // Bugzilla 37781 Check to make sure we can write this output file
+            if ((mover.getConfigOld() == null)
+                    || (mover.getConfigOld().isDirectory())
+                    || (mover.getConfigOld().exists() &&
+                            !mover.getConfigOld().canWrite())) {
+                log.error("Cannot move orignal context output file at "
+                        + mover.getConfigOld());
+                throw new IOException("Context orginal file at "
+                        + mover.getConfigOld()
+                        + " is null, not a file or not writable.");
+            }
+            File dir = mover.getConfigSave().getParentFile();
+            if (dir != null && dir.isDirectory() && (!dir.canWrite())) {
+                log.error("Cannot save context output file at "
+                        + mover.getConfigSave());
+                throw new IOException("Context save file at "
+                        + mover.getConfigSave() + " is not writable.");
+            }
+            if (log.isInfoEnabled())
+                log.info("Store Context " + aContext.getPath()
+                        + " separate with backup (at file "
+                        + mover.getConfigSave() + " )");
+
+            PrintWriter writer = null;
+            try {
+                writer = mover.getWriter();
+                storeXMLHead(writer);
+                super.store(writer, -2, aContext);
+            } finally {
+                if (writer != null) {
+                    // Flush and close the output file
+                    try {
+                        writer.flush();
+                    } catch (Exception e) {
+                        log.error(e);
+                    }
+                    try {
+                        writer.close();
+                    } catch (Exception e) {
+                        throw (e);
+                    }
+                }
+            }
+            mover.move();
+        }
+    }
+
+    /**
+     * Get explicit writer for context (context.getConfigFile()).
+     * 
+     * @param context
+     * @return The file mover
+     * @throws IOException
+     */
+    protected StoreFileMover getConfigFileWriter(Context context)
+            throws Exception {
+        URL configFile = context.getConfigFile();
+        StoreFileMover mover = null;
+        if (configFile != null) {
+            File config = new File(configFile.toURI());
+            if (!config.isAbsolute()) {
+                config = new File(System.getProperty("catalina.base"),
+                        config.getPath());
+            }
+            // Open an output writer for the new configuration file
+            mover = new StoreFileMover("", config.getCanonicalPath(),
+                    getRegistry().getEncoding());
+        }
+        return mover;
+    }
+
+    /**
+     * Store the specified Host properties.
+     * 
+     * @param aWriter
+     *            PrintWriter to which we are storing
+     * @param indent
+     *            Number of spaces to indent this element
+     * @param aContext
+     *            Context whose properties are being stored
+     * 
+     * @exception Exception
+     *                if an exception occurs while storing
+     */
+    public void storeChilds(PrintWriter aWriter, int indent, Object aContext,
+            StoreDescription parentDesc) throws Exception {
+        if (aContext instanceof StandardContext) {
+            StandardContext context = (StandardContext) aContext;
+            // Store nested <Listener> elements
+            if (context instanceof Lifecycle) {
+                LifecycleListener listeners[] = context
+                        .findLifecycleListeners();
+                storeElementArray(aWriter, indent, listeners);
+            }
+            // Store nested <Valve> elements
+            Valve valves[] = context.getPipeline().getValves();
+            storeElementArray(aWriter, indent, valves);
+
+            // Store nested <Loader> elements
+            Loader loader = context.getLoader();
+            storeElement(aWriter, indent, loader);
+
+            // Store nested <Manager> elements
+            if (context.getCluster() == null) {
+                Manager manager = context.getManager();
+                storeElement(aWriter, indent, manager);
+            }
+
+            // Store nested <Realm> element
+            Realm realm = context.getRealm();
+            if (realm != null) {
+                Realm parentRealm = null;
+                // @TODO is this case possible?
+                if (context.getParent() != null) {
+                    parentRealm = context.getParent().getRealm();
+                }
+                if (realm != parentRealm) {
+                    storeElement(aWriter, indent, realm);
+                }
+            }
+            // Store nested resources
+            WebResourceRoot resources = context.getResources();
+            storeElement(aWriter, indent, resources);
+
+            // Store nested <InstanceListener> elements
+            String iListeners[] = context.findInstanceListeners();
+            getStoreAppender().printTagArray(aWriter, "InstanceListener",
+                    indent + 2, iListeners);
+
+            // Store nested <WrapperListener> elements
+            String wLifecycles[] = context.findWrapperLifecycles();
+            getStoreAppender().printTagArray(aWriter, "WrapperListener",
+                    indent + 2, wLifecycles);
+            // Store nested <WrapperLifecycle> elements
+            String wListeners[] = context.findWrapperListeners();
+            getStoreAppender().printTagArray(aWriter, "WrapperLifecycle",
+                    indent + 2, wListeners);
+
+            // Store nested <Parameter> elements
+            ApplicationParameter[] appParams = context
+                    .findApplicationParameters();
+            storeElementArray(aWriter, indent, appParams);
+
+            // Store nested naming resources elements (EJB,Resource,...)
+            NamingResources nresources = context.getNamingResources();
+            storeElement(aWriter, indent, nresources);
+
+            // Store nested watched resources <WatchedResource>
+            String[] wresources = context.findWatchedResources();
+            wresources = filterWatchedResources(context, wresources);
+            getStoreAppender().printTagArray(aWriter, "WatchedResource",
+                    indent + 2, wresources);
+        }
+    }
+
+    /**
+     * Return a File object representing the "configuration root" directory for
+     * our associated Host.
+     */
+    protected File configBase(Context context) {
+
+        File file = new File(System.getProperty("catalina.base"), "conf");
+        Container host = (Host) context.getParent();
+
+        if ((host != null) && (host instanceof Host)) {
+            Container engine = host.getParent();
+            if ((engine != null) && (engine instanceof Engine)) {
+                file = new File(file, engine.getName());
+            }
+            file = new File(file, host.getName());
+            try {
+                file = file.getCanonicalFile();
+            } catch (IOException e) {
+                log.error(e);
+            }
+        }
+        return (file);
+
+    }
+
+    /**
+     * filter out the default watched resources
+     * 
+     * @param context
+     * @param wresources
+     * @return The watched resources
+     * @throws IOException
+     * TODO relative watchedresource
+     * TODO absolute handling configFile
+     * TODO Filename case handling for Windows?
+     * TODO digester variable subsitution $catalina.base, $catalina.home
+     */
+    protected String[] filterWatchedResources(StandardContext context,
+            String[] wresources) throws Exception {
+        File configBase = configBase(context);
+        String confContext = new File(System.getProperty("catalina.base"),
+                "conf/context.xml").getCanonicalPath();
+        String confWeb = new File(System.getProperty("catalina.base"),
+                "conf/web.xml").getCanonicalPath();
+        String confHostDefault = new File(configBase, "context.xml.default")
+                .getCanonicalPath();
+        String configFile = new File(context.getConfigFile().toURI()).getCanonicalPath();
+        String webxml = "WEB-INF/web.xml" ;
+        
+        List<String> resource = new ArrayList<>();
+        for (int i = 0; i < wresources.length; i++) {
+
+            if (wresources[i].equals(confContext))
+                continue;
+            if (wresources[i].equals(confWeb))
+                continue;
+            if (wresources[i].equals(confHostDefault))
+                continue;
+            if (wresources[i].equals(configFile))
+                continue;
+            if (wresources[i].equals(webxml))
+                continue;
+            resource.add(wresources[i]);
+        }
+        return (String[]) resource.toArray(new String[resource.size()]);
+    }
+
+}

==================================================
StandardHostSF.java
new file mode 100644
index 0000000000..0e30dfcc68
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/StandardEngineSF.java
@@ -0,0 +1,88 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.storeconfig;
+
+import java.io.PrintWriter;
+
+import org.apache.catalina.Cluster;
+import org.apache.catalina.Container;
+import org.apache.catalina.Lifecycle;
+import org.apache.catalina.LifecycleListener;
+import org.apache.catalina.Realm;
+import org.apache.catalina.Valve;
+import org.apache.catalina.core.StandardEngine;
+
+/**
+ * Store server.xml Element Engine
+ */
+public class StandardEngineSF extends StoreFactoryBase {
+
+    /**
+     * Store the specified Engine properties.
+     * 
+     * @param aWriter
+     *            PrintWriter to which we are storing
+     * @param indent
+     *            Number of spaces to indent this element
+     * @param aEngine
+     *            Object whose properties are being stored
+     * 
+     * @exception Exception
+     *                if an exception occurs while storing
+     */
+    public void storeChilds(PrintWriter aWriter, int indent, Object aEngine,
+            StoreDescription parentDesc) throws Exception {
+        if (aEngine instanceof StandardEngine) {
+            StandardEngine engine = (StandardEngine) aEngine;
+            // Store nested <Listener> elements
+            if (engine instanceof Lifecycle) {
+                LifecycleListener listeners[] = ((Lifecycle) engine)
+                        .findLifecycleListeners();
+                storeElementArray(aWriter, indent, listeners);
+            }
+
+            // Store nested <Realm> element
+            Realm realm = engine.getRealm();
+            if (realm != null) {
+                Realm parentRealm = null;
+                // TODO is this case possible? (see it a old Server 5.0 impl)
+                if (engine.getParent() != null) {
+                    parentRealm = engine.getParent().getRealm();
+                }
+                if (realm != parentRealm) {
+                    storeElement(aWriter, indent, realm);
+
+                }
+            }
+
+            // Store nested <Valve> elements
+            Valve valves[] = engine.getPipeline().getValves();
+            storeElementArray(aWriter, indent, valves);
+
+            // store all <Cluster> elements
+            Cluster cluster = engine.getCluster();
+            if (cluster != null) {
+                storeElement(aWriter, indent, cluster);
+            }
+            // store all <Host> elements
+            Container children[] = engine.findChildren();
+            storeElementArray(aWriter, indent, children);
+
+       }
+    }
+}
\ No newline at end of file

==================================================
StandardServerSF.java
new file mode 100644
index 0000000000..c27ba78a46
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/StandardHostSF.java
@@ -0,0 +1,109 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.storeconfig;
+
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.catalina.Cluster;
+import org.apache.catalina.Container;
+import org.apache.catalina.Lifecycle;
+import org.apache.catalina.LifecycleListener;
+import org.apache.catalina.Realm;
+import org.apache.catalina.Valve;
+import org.apache.catalina.core.StandardHost;
+import org.apache.catalina.ha.ClusterValve;
+
+/**
+ * Store server.xml Element Host
+ */
+public class StandardHostSF extends StoreFactoryBase {
+
+    /**
+     * Store the specified Host properties and childs
+     * (Listener,Alias,Realm,Valve,Cluster, Context)
+     * 
+     * @param aWriter
+     *            PrintWriter to which we are storing
+     * @param indent
+     *            Number of spaces to indent this element
+     * @param aHost
+     *            Host whose properties are being stored
+     * 
+     * @exception Exception
+     *                if an exception occurs while storing
+     */
+    public void storeChilds(PrintWriter aWriter, int indent, Object aHost,
+            StoreDescription parentDesc) throws Exception {
+        if (aHost instanceof StandardHost) {
+            StandardHost host = (StandardHost) aHost;
+            // Store nested <Listener> elements
+            if (host instanceof Lifecycle) {
+                LifecycleListener listeners[] = ((Lifecycle) host)
+                        .findLifecycleListeners();
+                storeElementArray(aWriter, indent, listeners);
+            }
+
+            // Store nested <Alias> elements
+            String aliases[] = host.findAliases();
+            getStoreAppender().printTagArray(aWriter, "Alias", indent + 2,
+                    aliases);
+
+            // Store nested <Realm> element
+            Realm realm = host.getRealm();
+            if (realm != null) {
+                Realm parentRealm = null;
+                if (host.getParent() != null) {
+                    parentRealm = host.getParent().getRealm();
+                }
+                if (realm != parentRealm) {
+                    storeElement(aWriter, indent, realm);
+                }
+            }
+
+            // Store nested <Valve> elements
+            Valve valves[] = host.getPipeline().getValves();
+            if(valves != null && valves.length > 0 ) {
+                List<Valve> hostValves = new ArrayList<>() ;
+                for(int i = 0 ; i < valves.length ; i++ ) {
+                    if(!( valves[i] instanceof ClusterValve))
+                        hostValves.add(valves[i]);
+                }                
+                storeElementArray(aWriter, indent, hostValves.toArray());
+            }
+
+            // store all <Cluster> elements
+            Cluster cluster = host.getCluster();
+            if (cluster != null) {
+                Cluster parentCluster = null;
+                if (host.getParent() != null) {
+                    parentCluster = host.getParent().getCluster();
+                }
+                if (cluster != parentCluster) {
+                    storeElement(aWriter, indent, cluster);
+                }
+            }
+
+            // store all <Context> elements
+            Container children[] = host.findChildren();
+            storeElementArray(aWriter, indent, children);
+        }
+    }
+
+}
\ No newline at end of file

==================================================
StandardServiceSF.java
new file mode 100644
index 0000000000..ad48010da9
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/StandardServerSF.java
@@ -0,0 +1,104 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.storeconfig;
+
+import java.io.PrintWriter;
+
+import org.apache.catalina.Lifecycle;
+import org.apache.catalina.LifecycleListener;
+import org.apache.catalina.Service;
+import org.apache.catalina.core.StandardServer;
+import org.apache.catalina.deploy.NamingResources;
+
+/**
+ * Store server.xml Server element and childs (
+ * Listener,GlobalNamingResource,Service)
+ */
+public class StandardServerSF extends StoreFactoryBase {
+
+    /**
+     * Store the specified Server properties.
+     * 
+     * @param aWriter
+     *            PrintWriter to which we are storing
+     * @param indent
+     *            Number of spaces to indent this element
+     * @param aServer
+     *            Object to be stored
+     * 
+     * @exception Exception
+     *                if an exception occurs while storing
+     * @see org.apache.catalina.storeconfig.IStoreFactory#store(java.io.PrintWriter,
+     *      int, java.lang.Object)
+     */
+    public void store(PrintWriter aWriter, int indent, Object aServer)
+            throws Exception {
+        storeXMLHead(aWriter);
+        super.store(aWriter, indent, aServer);
+    }
+
+    /**
+     * Store Childs from this StandardServer descrition
+     * 
+     * @param aWriter
+     * @param indent
+     * @param aObject
+     * @param parentDesc
+     * @throws Exception
+     */
+    public void storeChilds(PrintWriter aWriter, int indent, Object aObject,
+            StoreDescription parentDesc) throws Exception {
+        if (aObject instanceof StandardServer) {
+            StandardServer server = (StandardServer) aObject;
+            // Store nested <Listener> elements
+            if (server instanceof Lifecycle) {
+                LifecycleListener listeners[] = ((Lifecycle) server)
+                        .findLifecycleListeners();
+                storeElementArray(aWriter, indent, listeners);
+                /*LifecycleListener listener = null;
+                for (int i = 0; listener == null && i < listeners.length; i++)
+                    if (listeners[i] instanceof ServerLifecycleListener)
+                        listener = listeners[i];
+                if (listener != null) {
+                    StoreDescription elementDesc = getRegistry()
+                            .findDescription(
+                                    StandardServer.class.getName()
+                                            + ".[ServerLifecycleListener]");
+                    if (elementDesc != null) {
+                        elementDesc.getStoreFactory().store(aWriter, indent,
+                                listener);
+                    }
+                }*/
+            }
+            // Store nested <GlobalNamingResources> element
+            NamingResources globalNamingResources = server
+                    .getGlobalNamingResources();
+            StoreDescription elementDesc = getRegistry().findDescription(
+                    NamingResources.class.getName()
+                            + ".[GlobalNamingResources]");
+            if (elementDesc != null) {
+                elementDesc.getStoreFactory().store(aWriter, indent,
+                        globalNamingResources);
+            }
+            // Store nested <Service> elements
+            Service services[] = server.findServices();
+            storeElementArray(aWriter, indent, services);
+        }
+    }
+
+}

==================================================
StoreAppender.java
new file mode 100644
index 0000000000..f11bbfeab3
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/StandardServiceSF.java
@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.storeconfig;
+
+import java.io.PrintWriter;
+
+import org.apache.catalina.Container;
+import org.apache.catalina.Executor;
+import org.apache.catalina.Lifecycle;
+import org.apache.catalina.LifecycleListener;
+import org.apache.catalina.connector.Connector;
+import org.apache.catalina.core.StandardService;
+
+/**
+ * Store server.xml Element Service and all childs 
+ */
+public class StandardServiceSF extends StoreFactoryBase {
+
+    /**
+     * Store Childs from this StandardService description
+     * 
+     * @param aWriter
+     * @param indent
+     * @param aService
+     * @throws Exception
+     */
+    public void storeChilds(PrintWriter aWriter, int indent, Object aService,
+            StoreDescription parentDesc) throws Exception {
+        if (aService instanceof StandardService) {
+            StandardService service = (StandardService) aService;
+            // Store nested <Listener> elements
+            if (service instanceof Lifecycle) {
+                LifecycleListener listeners[] = ((Lifecycle) service)
+                        .findLifecycleListeners();
+                storeElementArray(aWriter, indent, listeners);
+            }
+            // Store nested <Executor> elements
+            Executor[] executors = service.findExecutors();
+            storeElementArray(aWriter, indent, executors);
+
+            Connector connectors[] = service.findConnectors();
+            storeElementArray(aWriter, indent, connectors);
+
+            // Store nested <Engine> element (or other appropriate container)
+            Container container = service.getContainer();
+            if (container != null) {
+                StoreDescription elementDesc = getRegistry().findDescription(
+                        container.getClass());
+                if (elementDesc != null) {
+                    IStoreFactory factory = elementDesc.getStoreFactory();
+                    factory.store(aWriter, indent, container);
+                }
+            }
+        }
+
+    }
+
+}
\ No newline at end of file

==================================================
StoreConfig.java
new file mode 100644
index 0000000000..2a15be8d2c
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/StoreAppender.java
@@ -0,0 +1,387 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.storeconfig;
+
+import java.beans.IndexedPropertyDescriptor;
+import java.beans.Introspector;
+import java.beans.PropertyDescriptor;
+import java.io.PrintWriter;
+import java.util.Iterator;
+
+import org.apache.catalina.deploy.ResourceBase;
+import org.apache.tomcat.util.IntrospectionUtils;
+
+/**
+ * StoreAppends generate really the xml tag elements
+ */
+public class StoreAppender {
+
+    /**
+     * The set of classes that represent persistable properties.
+     */
+    private static Class<?> persistables[] = { String.class, Integer.class,
+            Integer.TYPE, Boolean.class, Boolean.TYPE, Byte.class, Byte.TYPE,
+            Character.class, Character.TYPE, Double.class, Double.TYPE,
+            Float.class, Float.TYPE, Long.class, Long.TYPE, Short.class,
+            Short.TYPE, };
+
+    /**
+     * print the closing tag
+     * 
+     * @param aWriter
+     * @param aDesc
+     * @throws Exception
+     */
+    public void printCloseTag(PrintWriter aWriter, StoreDescription aDesc)
+            throws Exception {
+        aWriter.print("</");
+        aWriter.print(aDesc.getTag());
+        aWriter.println(">");
+    }
+
+    /**
+     * print only the open tag with all attributes
+     * 
+     * @param aWriter
+     * @param indent
+     * @param bean
+     * @param aDesc
+     * @throws Exception
+     */
+    public void printOpenTag(PrintWriter aWriter, int indent, Object bean,
+            StoreDescription aDesc) throws Exception {
+        aWriter.print("<");
+        aWriter.print(aDesc.getTag());
+        if (aDesc.isAttributes() && bean != null)
+            printAttributes(aWriter, indent, bean, aDesc);
+        aWriter.println(">");
+    }
+
+    /**
+     * Print tag with all attributes
+     * 
+     * @param aWriter
+     * @param indent
+     * @param bean
+     * @param aDesc
+     * @throws Exception
+     */
+    public void printTag(PrintWriter aWriter, int indent, Object bean,
+            StoreDescription aDesc) throws Exception {
+        aWriter.print("<");
+        aWriter.print(aDesc.getTag());
+        if (aDesc.isAttributes() && bean != null)
+            printAttributes(aWriter, indent, bean, aDesc);
+        aWriter.println("/>");
+    }
+
+    /**
+     * print the value from tag as content
+     * 
+     * @param aWriter
+     * @param tag
+     * @param content
+     * @throws Exception
+     */
+    public void printTagContent(PrintWriter aWriter, String tag, String content)
+            throws Exception {
+        aWriter.print("<");
+        aWriter.print(tag);
+        aWriter.print(">");
+        aWriter.print(convertStr(content));
+        aWriter.print("</");
+        aWriter.print(tag);
+        aWriter.println(">");
+    }
+
+    /**
+     * print an array of values
+     * 
+     * @param aWriter
+     * @param tag
+     * @param indent
+     * @param elements
+     */
+    public void printTagValueArray(PrintWriter aWriter, String tag, int indent,
+            String[] elements) {
+        if (elements != null && elements.length > 0) {
+            printIndent(aWriter, indent + 2);
+            aWriter.print("<");
+            aWriter.print(tag);
+            aWriter.print(">");
+            for (int i = 0; i < elements.length; i++) {
+                printIndent(aWriter, indent + 4);
+                aWriter.print(elements[i]);
+                if (i + 1 < elements.length)
+                    aWriter.println(",");
+            }
+            printIndent(aWriter, indent + 2);
+            aWriter.print("</");
+            aWriter.print(tag);
+            aWriter.println(">");
+        }
+    }
+
+    /**
+     * print a array of elements
+     * 
+     * @param aWriter
+     * @param tag
+     * @param indent
+     * @param elements
+     */
+    public void printTagArray(PrintWriter aWriter, String tag, int indent,
+            String[] elements) throws Exception {
+        if (elements != null) {
+            for (int i = 0; i < elements.length; i++) {
+                printIndent(aWriter, indent);
+                printTagContent(aWriter, tag, elements[i]);
+            }
+        }
+    }
+
+    /**
+     * Print some spaces
+     * 
+     * @param aWriter
+     * @param indent
+     *            number of spaces
+     */
+    public void printIndent(PrintWriter aWriter, int indent) {
+        for (int i = 0; i < indent; i++) {
+            aWriter.print(' ');
+        }
+    }
+
+    /**
+     * Store the relevant attributes of the specified JavaBean, plus a
+     * <code>className</code> attribute defining the fully qualified Java
+     * class name of the bean.
+     * 
+     * @param writer
+     *            PrintWriter to which we are storing
+     * @param bean
+     *            Bean whose properties are to be rendered as attributes,
+     * 
+     * @exception Exception
+     *                if an exception occurs while storing
+     */
+    public void printAttributes(PrintWriter writer, int indent, Object bean,
+            StoreDescription desc) throws Exception {
+
+        printAttributes(writer, indent, true, bean, desc);
+
+    }
+
+    /**
+     * Store the relevant attributes of the specified JavaBean.
+     * 
+     * @param writer
+     *            PrintWriter to which we are storing
+     * @param include
+     *            Should we include a <code>className</code> attribute?
+     * @param bean
+     *            Bean whose properties are to be rendered as attributes,
+     * @param desc
+     *            RegistryDescrpitor from this bean
+     * 
+     * @exception Exception
+     *                if an exception occurs while storing
+     */
+    public void printAttributes(PrintWriter writer, int indent,
+            boolean include, Object bean, StoreDescription desc)
+            throws Exception {
+
+        // Render a className attribute if requested
+        if (include && desc != null && !desc.isStandard()) {
+            writer.print(" className=\"");
+            writer.print(bean.getClass().getName());
+            writer.print("\"");
+        }
+
+        // Acquire the list of properties for this bean
+        PropertyDescriptor descriptors[] = Introspector.getBeanInfo(
+                bean.getClass()).getPropertyDescriptors();
+        if (descriptors == null) {
+            descriptors = new PropertyDescriptor[0];
+        }
+
+        // Create blank instance
+        Object bean2 = defaultInstance(bean);
+        for (int i = 0; i < descriptors.length; i++) {
+            if (descriptors[i] instanceof IndexedPropertyDescriptor) {
+                continue; // Indexed properties are not persisted
+            }
+            if (!isPersistable(descriptors[i].getPropertyType())
+                    || (descriptors[i].getReadMethod() == null)
+                    || (descriptors[i].getWriteMethod() == null)) {
+                continue; // Must be a read-write primitive or String
+            }
+            if (desc.isTransientAttribute(descriptors[i].getName())) {
+                continue; // Skip the specified exceptions
+            }
+            Object value = IntrospectionUtils.getProperty(bean, descriptors[i]
+                    .getName());
+            if (value == null) {
+                continue; // Null values are not persisted
+            }
+            Object value2 = IntrospectionUtils.getProperty(bean2,
+                    descriptors[i].getName());
+            if (value.equals(value2)) {
+                // The property has its default value
+                continue;
+            }
+            printAttribute(writer, indent, bean, desc, descriptors[i].getName(), bean2, value);
+        }
+
+        if (bean instanceof ResourceBase) {
+            ResourceBase resource = (ResourceBase) bean;
+            for (Iterator<String> iter = resource.listProperties(); iter.hasNext();) {
+                String name = (String) iter.next();
+                Object value = resource.getProperty(name);
+                if (!isPersistable(value.getClass())) {
+                    continue;
+                }
+                if (desc.isTransientAttribute(name)) {
+                    continue; // Skip the specified exceptions
+                }
+                printValue(writer, indent, name, value);
+
+            }
+        }
+    }
+
+    /**
+     * @param writer
+     * @param indent
+     * @param bean
+     * @param desc
+     * @param attributeName
+     * @param bean2
+     * @param value
+     */
+    protected void printAttribute(PrintWriter writer, int indent, Object bean, StoreDescription desc, String attributeName, Object bean2, Object value) {
+        if (isPrintValue(bean, bean2, attributeName, desc))
+            printValue(writer, indent, attributeName, value);
+    }
+
+    /**
+     * print this Attribute value or not
+     * 
+     * @param bean
+     *            orginal bean
+     * @param bean2
+     *            default bean
+     * @param attrName
+     *            attribute name
+     * @param desc
+     *            StoreDescription from bean
+     * @return True if it's a printing value
+     */
+    public boolean isPrintValue(Object bean, Object bean2, String attrName,
+            StoreDescription desc) {
+        boolean printValue = false;
+
+        Object value = IntrospectionUtils.getProperty(bean, attrName);
+        if (value != null) {
+            Object value2 = IntrospectionUtils.getProperty(bean2, attrName);
+            printValue = !value.equals(value2);
+
+        }
+        return printValue;
+    }
+
+    /**
+     * generate default Instance
+     * 
+     * @param bean
+     * @return an object from same class as bean parameter
+     * @throws InstantiationException
+     * @throws IllegalAccessException
+     */
+    public Object defaultInstance(Object bean) throws InstantiationException,
+            IllegalAccessException {
+        return bean.getClass().newInstance();
+    }
+
+    /**
+     * print an attribute value
+     * 
+     * @param writer
+     * @param name
+     * @param value
+     */
+    public void printValue(PrintWriter writer, int indent, String name,
+            Object value) {
+        if (!(value instanceof String)) {
+            value = value.toString();
+        }
+        writer.println();
+        printIndent(writer, indent + 4);
+        writer.print(name);
+        writer.print("=\"");
+        String strValue = convertStr((String) value);
+        writer.print(strValue);
+        writer.print("\"");
+    }
+
+    /**
+     * Given a string, this method replaces all occurrences of ' <', '>', '&',
+     * and '"'.
+     */
+    public String convertStr(String input) {
+
+        StringBuffer filtered = new StringBuffer(input.length());
+        char c;
+        for (int i = 0; i < input.length(); i++) {
+            c = input.charAt(i);
+            if (c == '<') {
+                filtered.append("&lt;");
+            } else if (c == '>') {
+                filtered.append("&gt;");
+            } else if (c == '\'') {
+                filtered.append("&apos;");
+            } else if (c == '"') {
+                filtered.append("&quot;");
+            } else if (c == '&') {
+                filtered.append("&amp;");
+            } else {
+                filtered.append(c);
+            }
+        }
+        return (filtered.toString());
+    }
+
+    /**
+     * Is the specified property type one for which we should generate a
+     * persistence attribute?
+     * 
+     * @param clazz
+     *            Java class to be tested
+     */
+    protected boolean isPersistable(Class<?> clazz) {
+
+        for (int i = 0; i < persistables.length; i++) {
+            if (persistables[i] == clazz) {
+                return (true);
+            }
+        }
+        return (false);
+
+    }
+}

==================================================
StoreConfigLifecycleListener.java
new file mode 100644
index 0000000000..3e56f41ef9
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/StoreConfig.java
@@ -0,0 +1,356 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.storeconfig;
+
+import java.io.PrintWriter;
+import java.net.URL;
+
+import javax.management.MBeanServer;
+import javax.management.MalformedObjectNameException;
+import javax.management.ObjectName;
+
+import org.apache.catalina.Context;
+import org.apache.catalina.Host;
+import org.apache.catalina.Server;
+import org.apache.catalina.Service;
+import org.apache.catalina.core.StandardContext;
+import org.apache.catalina.mbeans.MBeanUtils;
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+
+/**
+ * Store Server/Service/Host/Context at file or PrintWriter. Default server.xml
+ * is at $catalina.base/conf/server.xml
+ */
+public class StoreConfig implements IStoreConfig {
+    private static Log log = LogFactory.getLog(StoreConfig.class);
+
+    private String serverFilename = "conf/server.xml";
+
+    private StoreRegistry registry;
+
+    private Server server;
+
+    /**
+     * get server.xml location
+     * 
+     * @return The server file name
+     */
+    public String getServerFilename() {
+        return serverFilename;
+    }
+
+    /**
+     * set new server.xml location
+     * 
+     * @param string
+     */
+    public void setServerFilename(String string) {
+        serverFilename = string;
+    }
+
+    /*
+     * Get the StoreRegistry with all factory to generate the
+     * server.xml/context.xml files
+     * 
+     * @see org.apache.catalina.config.IStoreConfig#getRegistry()
+     */
+    public StoreRegistry getRegistry() {
+        return registry;
+    }
+
+    /*
+     * set StoreRegistry
+     * 
+     * @see org.apache.catalina.config.IStoreConfig#setRegistry(org.apache.catalina.config.ConfigurationRegistry)
+     */
+    public void setServer(Server aServer) {
+        server = aServer;
+    }
+
+    public Server getServer() {
+        return server;
+    }
+
+    public void setRegistry(StoreRegistry aRegistry) {
+        registry = aRegistry;
+    }
+
+    /**
+     * Store current Server
+     * 
+     * @see org.apache.catalina.ServerFactory#getServer()
+     */
+    public synchronized void storeConfig() {
+        store(server);
+    }
+
+    /**
+     * Store Server from Object Name (Catalina:type=Server)
+     * 
+     * @param aServerName
+     *            Server ObjectName
+     * @param backup
+     * @param externalAllowed
+     *            s *
+     * @throws MalformedObjectNameException
+     */
+    public synchronized void storeServer(String aServerName, boolean backup,
+            boolean externalAllowed) throws MalformedObjectNameException {
+        if (aServerName == null || aServerName.length() == 0) {
+            if (log.isErrorEnabled())
+                log.error("Please, call with a correct server ObjectName!");
+            return;
+        }
+        MBeanServer mserver = MBeanUtils.createServer();
+        ObjectName objectName = new ObjectName(aServerName);
+        if (mserver.isRegistered(objectName)) {
+            try {
+                Server aServer = (Server) mserver.getAttribute(objectName,
+                        "managedResource");
+                StoreDescription desc = null;
+                desc = getRegistry().findDescription(StandardContext.class);
+                if (desc != null) {
+                    boolean oldSeparate = desc.isStoreSeparate();
+                    boolean oldBackup = desc.isBackup();
+                    boolean oldExternalAllowed = desc.isExternalAllowed();
+                    try {
+                        desc.setStoreSeparate(true);
+                        desc.setBackup(backup);
+                        desc.setExternalAllowed(externalAllowed);
+                        store((Server) aServer);
+                    } finally {
+                        desc.setStoreSeparate(oldSeparate);
+                        desc.setBackup(oldBackup);
+                        desc.setExternalAllowed(oldExternalAllowed);
+                    }
+                } else
+                    store((Server) aServer);
+            } catch (Exception e) {
+                if (log.isInfoEnabled())
+                    log.info("Object " + aServerName
+                            + " is no a Server instance or store exception", e);
+            }
+        } else if (log.isInfoEnabled())
+            log.info("Server " + aServerName + " not found!");
+    }
+
+    /**
+     * Store a Context from ObjectName
+     * 
+     * @param aContextName
+     *            MBean ObjectName
+     * @param backup
+     * @param externalAllowed
+     * @throws MalformedObjectNameException
+     */
+    public synchronized void storeContext(String aContextName, boolean backup,
+            boolean externalAllowed) throws MalformedObjectNameException {
+        if (aContextName == null || aContextName.length() == 0) {
+            if (log.isErrorEnabled())
+                log.error("Please, call with a correct context ObjectName!");
+            return;
+        }
+        MBeanServer mserver = MBeanUtils.createServer();
+        ObjectName objectName = new ObjectName(aContextName);
+        if (mserver.isRegistered(objectName)) {
+            try {
+                Context aContext = (Context) mserver.getAttribute(objectName,
+                        "managedResource");
+                URL configFile = aContext.getConfigFile();
+                if (configFile != null) {
+                    try {
+                        StoreDescription desc = null;
+                        desc = getRegistry().findDescription(
+                                aContext.getClass());
+                        if (desc != null) {
+                            boolean oldSeparate = desc.isStoreSeparate();
+                            boolean oldBackup = desc.isBackup();
+                            boolean oldExternalAllowed = desc
+                                    .isExternalAllowed();
+                            try {
+                                desc.setStoreSeparate(true);
+                                desc.setBackup(backup);
+                                desc.setExternalAllowed(externalAllowed);
+                                desc.getStoreFactory()
+                                        .store(null, -2, aContext);
+                            } finally {
+                                desc.setStoreSeparate(oldSeparate);
+                                desc.setBackup(oldBackup);
+                                desc.setBackup(oldExternalAllowed);
+                            }
+                        }
+                    } catch (Exception e) {
+                        log.error(e);
+                    }
+                } else
+                    log.error("Missing configFile at Context "
+                            + aContext.getPath() + " to store!");
+            } catch (Exception e) {
+                if (log.isInfoEnabled())
+                    log
+                            .info(
+                                    "Object "
+                                            + aContextName
+                                            + " is no a context instance or store exception",
+                                    e);
+            }
+        } else if (log.isInfoEnabled())
+            log.info("Context " + aContextName + " not found!");
+    }
+
+    /**
+     * Write the configuration information for this entire <code>Server</code>
+     * out to the server.xml configuration file.
+     *  
+     */
+    public synchronized void store(Server aServer) {
+
+        StoreFileMover mover = new StoreFileMover(System
+                .getProperty("catalina.base"), getServerFilename(),
+                getRegistry().getEncoding());
+        // Open an output writer for the new configuration file
+        try {
+            PrintWriter writer = null;
+            try {
+                writer = mover.getWriter();
+                store(writer, -2, aServer);
+            } finally {
+                if (writer != null) {
+                    // Flush and close the output file
+                    try {
+                        writer.flush();
+                    } catch (Exception e) {
+                        log.error(e);
+                    }
+                    try {
+                        writer.close();
+                    } catch (Exception e) {
+                        throw (e);
+                    }
+                }
+            }
+            mover.move();
+        } catch (Exception e) {
+            log.error(e);
+        }
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.apache.catalina.config.IStoreConfig#store(org.apache.catalina.Context)
+     */
+    public synchronized void store(Context aContext) {
+        URL configFile = aContext.getConfigFile();
+        if (configFile != null) {
+            try {
+                StoreDescription desc = null;
+                desc = getRegistry().findDescription(aContext.getClass());
+                if (desc != null) {
+                    boolean old = desc.isStoreSeparate();
+                    try {
+                        desc.setStoreSeparate(true);
+                        desc.getStoreFactory().store(null, -2, aContext);
+                    } finally {
+                        desc.setStoreSeparate(old);
+                    }
+                }
+            } catch (Exception e) {
+                log.error(e);
+            }
+        } else
+            log.error("Missing configFile at Context " + aContext.getPath());
+
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.apache.catalina.config.IStoreConfig#store(java.io.PrintWriter,
+     *      int, org.apache.catalina.Context)
+     */
+    public synchronized void store(PrintWriter aWriter, int indent,
+            Context aContext) {
+        boolean oldSeparate = true;
+        StoreDescription desc = null;
+        try {
+            desc = getRegistry().findDescription(aContext.getClass());
+            oldSeparate = desc.isStoreSeparate();
+            desc.setStoreSeparate(false);
+            desc.getStoreFactory().store(aWriter, indent, aContext);
+        } catch (Exception e) {
+            log.error(e);
+        } finally {
+            if (desc != null)
+                desc.setStoreSeparate(oldSeparate);
+        }
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.apache.catalina.config.IStoreConfig#store(java.io.PrintWriter,
+     *      int, org.apache.catalina.Host)
+     */
+    public synchronized void store(PrintWriter aWriter, int indent, Host aHost) {
+        try {
+            StoreDescription desc = getRegistry().findDescription(
+                    aHost.getClass());
+            desc.getStoreFactory().store(aWriter, indent, aHost);
+        } catch (Exception e) {
+            log.error(e);
+        }
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.apache.catalina.config.IStoreConfig#store(java.io.PrintWriter,
+     *      int, org.apache.catalina.Service)
+     */
+    public synchronized void store(PrintWriter aWriter, int indent,
+            Service aService) {
+        try {
+            StoreDescription desc = getRegistry().findDescription(
+                    aService.getClass());
+            desc.getStoreFactory().store(aWriter, indent, aService);
+        } catch (Exception e) {
+            log.error(e);
+        }
+    }
+
+    /**
+     * Store the state of this Server MBean (which will recursively store
+     * everything)
+     * 
+     * @param writer
+     * @param indent
+     * @param aServer
+     */
+    public synchronized void store(PrintWriter writer, int indent,
+            Server aServer) {
+        try {
+            StoreDescription desc = getRegistry().findDescription(
+                    aServer.getClass());
+            desc.getStoreFactory().store(writer, indent, aServer);
+        } catch (Exception e) {
+            log.error(e);
+        }
+    }
+
+}

==================================================
StoreContextAppender.java
new file mode 100644
index 0000000000..9d9636d80d
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/StoreConfigLifecycleListener.java
@@ -0,0 +1,168 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.storeconfig;
+
+import java.io.InputStream;
+
+import javax.management.DynamicMBean;
+import javax.management.MBeanServer;
+import javax.management.ObjectName;
+
+import org.apache.catalina.Lifecycle;
+import org.apache.catalina.LifecycleEvent;
+import org.apache.catalina.LifecycleListener;
+import org.apache.catalina.core.StandardServer;
+import org.apache.catalina.mbeans.MBeanUtils;
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+import org.apache.tomcat.util.modeler.ManagedBean;
+import org.apache.tomcat.util.modeler.Registry;
+
+/**
+ * Load and Register StoreConfig MBean <i>Catalina:type=StoreConfig,resource="url"</i>
+ */
+public class StoreConfigLifecycleListener implements LifecycleListener {
+    private static Log log = LogFactory
+            .getLog(StoreConfigLifecycleListener.class);
+
+    /**
+     * The configuration information registry for our managed beans.
+     */
+    protected final Registry registry = MBeanUtils.createRegistry();
+
+
+    IStoreConfig storeConfig;
+
+    private String storeConfigClass = "org.apache.catalina.storeconfig.StoreConfig";
+
+    private String storeRegistry = null;
+
+    /*
+     * register StoreRegistry after Start the complete Server
+     * 
+     * @see org.apache.catalina.LifecycleListener#lifecycleEvent(org.apache.catalina.LifecycleEvent)
+     */
+    public void lifecycleEvent(LifecycleEvent event) {
+        if (Lifecycle.AFTER_START_EVENT.equals(event.getType())) {
+            if (event.getSource() instanceof StandardServer) {
+                createMBean((StandardServer) event.getSource());
+            }
+        }
+    }
+
+    /**
+     * create StoreConfig MBean and load StoreRgistry MBeans name is
+     * <i>Catalina:type=StoreConfig </i>
+     */
+    protected void createMBean(StandardServer server) {
+        StoreLoader loader = new StoreLoader();
+        try {
+            Class<?> clazz = Class.forName(getStoreConfigClass(), true, this
+                    .getClass().getClassLoader());
+            storeConfig = (IStoreConfig) clazz.newInstance();
+            if (null == getStoreRegistry())
+                // default Loading
+                loader.load();
+            else
+                // load a spezial file registry (url)
+                loader.load(getStoreRegistry());
+            // use the loader Registry
+            storeConfig.setRegistry(loader.getRegistry());
+            storeConfig.setServer(server);
+        } catch (Exception e) {
+            log.error("createMBean load", e);
+            return;
+        }
+        MBeanServer mserver = MBeanUtils.createServer();
+        InputStream descriptor = null;
+        try {
+            ObjectName objectName = new ObjectName("Catalina:type=StoreConfig" );
+            if (!mserver.isRegistered(objectName)) {
+                registry.registerComponent(storeConfig, objectName, "StoreConfig");
+            }
+        } catch (Exception ex) {
+            log.error("createMBean register MBean", ex);
+
+        } finally {
+            if (descriptor != null) {
+                try {
+                    descriptor.close();
+                    descriptor = null;
+                } catch (Exception ex) {
+                    log.error("createMBean register MBean", ex);
+                }
+            }
+        }
+    }
+
+    /**
+     * Create a ManagedBean (StoreConfig)
+     * 
+     * @param object
+     * @return The bean
+     * @throws Exception
+     */
+    protected DynamicMBean getManagedBean(Object object) throws Exception {
+        ManagedBean managedBean = registry.findManagedBean("StoreConfig");
+        return managedBean.createMBean(object);
+    }
+
+    /**
+     * @return Returns the storeConfig.
+     */
+    public IStoreConfig getStoreConfig() {
+        return storeConfig;
+    }
+
+    /**
+     * @param storeConfig
+     *            The storeConfig to set.
+     */
+    public void setStoreConfig(IStoreConfig storeConfig) {
+        this.storeConfig = storeConfig;
+    }
+
+    /**
+     * @return Returns the storeConfigClass.
+     */
+    public String getStoreConfigClass() {
+        return storeConfigClass;
+    }
+
+    /**
+     * @param storeConfigClass
+     *            The storeConfigClass to set.
+     */
+    public void setStoreConfigClass(String storeConfigClass) {
+        this.storeConfigClass = storeConfigClass;
+    }
+
+    /**
+     * @return Returns the storeRegistry.
+     */
+    public String getStoreRegistry() {
+        return storeRegistry;
+    }
+
+    /**
+     * @param storeRegistry
+     *            The storeRegistry to set.
+     */
+    public void setStoreRegistry(String storeRegistry) {
+        this.storeRegistry = storeRegistry;
+    }
+}

==================================================
StoreDescription.java
new file mode 100644
index 0000000000..719c927a35
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/StoreContextAppender.java
@@ -0,0 +1,174 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.storeconfig;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.PrintWriter;
+
+import org.apache.catalina.Container;
+import org.apache.catalina.core.StandardContext;
+import org.apache.catalina.core.StandardHost;
+
+/**
+ * store StandardContext Attributes ... 
+ */
+public class StoreContextAppender extends StoreAppender {
+
+    /**
+     * @param writer
+     * @param indent
+     * @param bean
+     * @param desc
+     * @param attributeName
+     * @param bean2
+     * @param value
+     */
+    protected void printAttribute(PrintWriter writer, int indent, Object bean, StoreDescription desc, String attributeName, Object bean2, Object value) {
+        if (isPrintValue(bean, bean2, attributeName, desc)) {
+            if(attributeName.equals("docBase")) {
+                if(bean instanceof StandardContext) {
+                    String docBase = ((StandardContext)bean).getOriginalDocBase() ;
+                    if(docBase != null)
+                        value = docBase ;
+                }
+            }
+            printValue(writer, indent, attributeName, value);
+        }
+    }
+
+    /*
+     * Print Context Values. <ul><li> Spezial handling to default workDir.
+     * </li><li> Don't save path at external context.xml </li><li> Don't
+     * generate docBase for host.appBase webapps <LI></ul>
+     * 
+     * @see org.apache.catalina.config.StoreAppender#isPrintValue(java.lang.Object,
+     *      java.lang.Object, java.lang.String,
+     *      org.apache.catalina.config.StoreDescription)
+     */
+    public boolean isPrintValue(Object bean, Object bean2, String attrName,
+            StoreDescription desc) {
+        boolean isPrint = super.isPrintValue(bean, bean2, attrName, desc);
+        if (isPrint) {
+            StandardContext context = ((StandardContext) bean);
+            if ("workDir".equals(attrName)) {
+                String defaultWorkDir = getDefaultWorkDir(context);
+                isPrint = !defaultWorkDir.equals(context.getWorkDir());
+            } else if ("path".equals(attrName)) {
+                isPrint = desc.isStoreSeparate() 
+                            && desc.isExternalAllowed()
+                            && context.getConfigFile() == null;
+            } else if ("docBase".equals(attrName)) {
+                Container host = context.getParent();
+                if (host instanceof StandardHost) {
+                    File appBase = getAppBase(((StandardHost) host));
+                    File docBase = getDocBase(context,appBase);
+                    isPrint = !appBase.equals(docBase.getParentFile());
+                }
+            }
+        }
+        return isPrint;
+    }
+
+    protected File getAppBase(StandardHost host) {
+
+        File appBase;
+        File file = new File(host.getAppBase());
+        if (!file.isAbsolute())
+            file = new File(System.getProperty("catalina.base"), host
+                    .getAppBase());
+        try {
+            appBase = file.getCanonicalFile();
+        } catch (IOException e) {
+            appBase = file;
+        }
+        return (appBase);
+
+    }
+
+    protected File getDocBase(StandardContext context, File appBase) {
+
+        File docBase;
+        String contextDocBase = context.getOriginalDocBase() ;
+        if(contextDocBase == null)
+            contextDocBase = context.getDocBase() ;
+        File file = new File(contextDocBase);
+        if (!file.isAbsolute())
+            file = new File(appBase, contextDocBase);
+        try {
+            docBase = file.getCanonicalFile();
+        } catch (IOException e) {
+            docBase = file;
+        }
+        return (docBase);
+
+    }
+
+    /**
+     * Make default Work Dir.
+     * 
+     * @param context
+     * @return The default working directory for the context.
+     */
+    protected String getDefaultWorkDir(StandardContext context) {
+        String defaultWorkDir = null;
+        String contextPath = context.getPath().length() == 0 ? "_" : context
+                .getPath().substring(1);
+        Container host = context.getParent();
+        if (host instanceof StandardHost) {
+            String hostWorkDir = ((StandardHost) host).getWorkDir();
+            if (hostWorkDir != null) {
+                defaultWorkDir = hostWorkDir + File.separator + contextPath;
+            } else {
+                String engineName = context.getParent().getParent().getName();
+                String hostName = context.getParent().getName();
+                defaultWorkDir = "work" + File.separator + engineName
+                        + File.separator + hostName + File.separator
+                        + contextPath;
+            }
+        }
+        return defaultWorkDir;
+    }
+
+    /*
+     * Generate a real default StandardContext TODO read and interpret the
+     * default context.xml and context.xml.default TODO Cache a Default
+     * StandardContext ( with reloading strategy) TODO remove really all
+     * elements, but detection is hard... To Listener or Valve from same class?>
+     * 
+     * @see org.apache.catalina.storeconfig.StoreAppender#defaultInstance(java.lang.Object)
+     */
+    public Object defaultInstance(Object bean) throws InstantiationException,
+            IllegalAccessException {
+        if (bean instanceof StandardContext) {
+            StandardContext defaultContext = new StandardContext();
+            /*
+             * if (!((StandardContext) bean).getOverride()) {
+             * defaultContext.setParent(((StandardContext)bean).getParent());
+             * ContextConfig contextConfig = new ContextConfig();
+             * defaultContext.addLifecycleListener(contextConfig);
+             * contextConfig.setContext(defaultContext);
+             * contextConfig.processContextConfig(new File(contextConfig
+             * .getBaseDir(), "conf/context.xml"));
+             * contextConfig.processContextConfig(new File(contextConfig
+             * .getConfigBase(), "context.xml.default")); }
+             */
+            return defaultContext;
+        } else
+            return super.defaultInstance(bean);
+    }
+}

==================================================
StoreFactoryBase.java
new file mode 100644
index 0000000000..993ad93fdc
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/StoreDescription.java
@@ -0,0 +1,371 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.storeconfig;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Bean of a StoreDescription 
+ * 
+ * <pre>
+ * 
+ *  &lt;Description
+ *  tag=&quot;Context&quot;
+ *  standard=&quot;true&quot;
+ *  default=&quot;true&quot; 
+ *  externalAllowed=&quot;true&quot; 
+ *  storeSeparate=&quot;true&quot;
+ *  backup=&quot;true&quot; 
+ *  childs=&quot;true&quot;
+ *  tagClass=&quot;org.apache.catalina.core.StandardContext&quot;
+ *  storeFactoryClass=&quot;org.apache.catalina.storeconfig.StandardContextSF&quot;
+ *  storeAppenderClass=&quot;org.apache.catalina.storeconfig.StoreContextAppender&quot;&gt;
+ *     &lt;TransientAttribute&gt;available&lt;/TransientAttribute&gt;
+ *     &lt;TransientAttribute&gt;configFile&lt;/TransientAttribute&gt;
+ *     &lt;TransientAttribute&gt;configured&lt;/TransientAttribute&gt;
+ *     &lt;TransientAttribute&gt;displayName&lt;/TransientAttribute&gt;
+ *     &lt;TransientAttribute&gt;distributable&lt;/TransientAttribute&gt;
+ *     &lt;TransientAttribute&gt;domain&lt;/TransientAttribute&gt;
+ *     &lt;TransientAttribute&gt;engineName&lt;/TransientAttribute&gt;
+ *     &lt;TransientAttribute&gt;name&lt;/TransientAttribute&gt;
+ *     &lt;TransientAttribute&gt;publicId&lt;/TransientAttribute&gt;
+ *     &lt;TransientAttribute&gt;replaceWelcomeFiles&lt;/TransientAttribute&gt;
+ *     &lt;TransientAttribute&gt;saveConfig&lt;/TransientAttribute&gt;
+ *     &lt;TransientAttribute&gt;sessionTimeout&lt;/TransientAttribute&gt;
+ *     &lt;TransientAttribute&gt;startupTime&lt;/TransientAttribute&gt;
+ *     &lt;TransientAttribute&gt;tldScanTime&lt;/TransientAttribute&gt;
+ *  &lt;/Description&gt;
+ * 
+ *  
+ * </pre>
+ */
+public class StoreDescription {
+
+    private String id;
+
+    private String tag;
+
+    private String tagClass;
+
+    private boolean standard = false;
+
+    private boolean backup = false;
+
+    private boolean externalAllowed = false;
+
+    private boolean externalOnly = false;
+
+    private boolean myDefault = false;
+
+    private boolean attributes = true;
+
+    private String storeFactoryClass;
+
+    private IStoreFactory storeFactory;
+
+    private String storeWriterClass;
+
+    private boolean childs = false;
+
+    private List<String> transientAttributes;
+
+    private List<String> transientChilds;
+
+    private boolean storeSeparate = false;
+
+    /**
+     * @return Returns the external.
+     */
+    public boolean isExternalAllowed() {
+        return externalAllowed;
+    }
+
+    /**
+     * @param external
+     *            The external to set.
+     */
+    public void setExternalAllowed(boolean external) {
+        this.externalAllowed = external;
+    }
+
+    public boolean isExternalOnly() {
+        return externalOnly;
+    }
+
+    public void setExternalOnly(boolean external) {
+        this.externalOnly = external;
+    }
+
+    /**
+     * @return Returns the standard.
+     */
+    public boolean isStandard() {
+        return standard;
+    }
+
+    /**
+     * @param standard
+     *            The standard to set.
+     */
+    public void setStandard(boolean standard) {
+        this.standard = standard;
+    }
+
+    /**
+     * @return Returns the backup.
+     */
+    public boolean isBackup() {
+        return backup;
+    }
+
+    /**
+     * @param backup
+     *            The backup to set.
+     */
+    public void setBackup(boolean backup) {
+        this.backup = backup;
+    }
+
+    /**
+     * @return Returns the myDefault.
+     */
+    public boolean isDefault() {
+        return myDefault;
+    }
+
+    /**
+     * @param aDefault
+     *            The myDefault to set.
+     */
+    public void setDefault(boolean aDefault) {
+        this.myDefault = aDefault;
+    }
+
+    /**
+     * @return Returns the storeFactory.
+     */
+    public String getStoreFactoryClass() {
+        return storeFactoryClass;
+    }
+
+    /**
+     * @param storeFactoryClass
+     *            The storeFactory to set.
+     */
+    public void setStoreFactoryClass(String storeFactoryClass) {
+        this.storeFactoryClass = storeFactoryClass;
+    }
+
+    /**
+     * @return Returns the storeFactory.
+     */
+    public IStoreFactory getStoreFactory() {
+        return storeFactory;
+    }
+
+    /**
+     * @param storeFactory
+     *            The storeFactory to set.
+     */
+    public void setStoreFactory(IStoreFactory storeFactory) {
+        this.storeFactory = storeFactory;
+    }
+
+    /**
+     * @return Returns the storeWriterClass.
+     */
+    public String getStoreWriterClass() {
+        return storeWriterClass;
+    }
+
+    /**
+     * @param storeWriterClass
+     *            The storeWriterClass to set.
+     */
+    public void setStoreWriterClass(String storeWriterClass) {
+        this.storeWriterClass = storeWriterClass;
+    }
+
+    /**
+     * @return Returns the tagClass.
+     */
+    public String getTag() {
+        return tag;
+    }
+
+    /**
+     * @param tag
+     *            The tag to set.
+     */
+    public void setTag(String tag) {
+        this.tag = tag;
+    }
+
+    /**
+     * @return Returns the tagClass.
+     */
+    public String getTagClass() {
+        return tagClass;
+    }
+
+    /**
+     * @param tagClass
+     *            The tagClass to set.
+     */
+    public void setTagClass(String tagClass) {
+        this.tagClass = tagClass;
+    }
+
+    /**
+     * @return Returns the transientAttributes.
+     */
+    public List<String> getTransientAttributes() {
+        return transientAttributes;
+    }
+
+    /**
+     * @param transientAttributes
+     *            The transientAttributes to set.
+     */
+    public void setTransientAttributes(List<String> transientAttributes) {
+        this.transientAttributes = transientAttributes;
+    }
+
+    public void addTransientAttribute(String attribute) {
+        if (transientAttributes == null)
+            transientAttributes = new ArrayList<>();
+        transientAttributes.add(attribute);
+    }
+
+    public void removeTransientAttribute(String attribute) {
+        if (transientAttributes != null)
+            transientAttributes.remove(attribute);
+    }
+
+    /**
+     * @return Returns the transientChilds.
+     */
+    public List<String> getTransientChilds() {
+        return transientChilds;
+    }
+
+    /**
+     * @param transientChilds
+     *            The transientChilds to set.
+     */
+    public void setTransientChilds(List<String> transientChilds) {
+        this.transientChilds = transientChilds;
+    }
+
+    public void addTransientChild(String classname) {
+        if (transientChilds == null)
+            transientChilds = new ArrayList<>();
+        transientChilds.add(classname);
+    }
+
+    public void removeTransientChild(String classname) {
+        if (transientChilds != null)
+            transientChilds.remove(classname);
+    }
+
+    /**
+     * is child transient, please don't save this.
+     * 
+     * @param classname
+     * @return is classname attribute?
+     */
+    public boolean isTransientChild(String classname) {
+        if (transientChilds != null)
+            return transientChilds.contains(classname);
+        return false;
+    }
+
+    /**
+     * is attribute transient, please don't save this.
+     * 
+     * @param attribute
+     * @return is transient attribute?
+     */
+    public boolean isTransientAttribute(String attribute) {
+        if (transientAttributes != null)
+            return transientAttributes.contains(attribute);
+        return false;
+    }
+
+    /**
+     * Return the real id or TagClass
+     * 
+     * @return Returns the id.
+     */
+    public String getId() {
+        if (id != null)
+            return id;
+        else
+            return getTagClass();
+    }
+
+    /**
+     * @param id
+     *            The id to set.
+     */
+    public void setId(String id) {
+        this.id = id;
+    }
+
+    /**
+     * @return Returns the attributes.
+     */
+    public boolean isAttributes() {
+        return attributes;
+    }
+
+    /**
+     * @param attributes
+     *            The attributes to set.
+     */
+    public void setAttributes(boolean attributes) {
+        this.attributes = attributes;
+    }
+
+    /**
+     * @return True if it's a separate store
+     */
+    public boolean isStoreSeparate() {
+        return storeSeparate;
+    }
+
+    public void setStoreSeparate(boolean storeSeparate) {
+        this.storeSeparate = storeSeparate;
+    }
+
+    /**
+     * @return Returns the childs.
+     */
+    public boolean isChilds() {
+        return childs;
+    }
+
+    /**
+     * @param childs
+     *            The childs to set.
+     */
+    public void setChilds(boolean childs) {
+        this.childs = childs;
+    }
+}

==================================================
StoreFactoryRule.java
new file mode 100644
index 0000000000..86577a6fd0
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/StoreFactoryBase.java
@@ -0,0 +1,192 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.storeconfig;
+
+import java.io.IOException;
+import java.io.PrintWriter;
+
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+import org.apache.tomcat.util.res.StringManager;
+
+/**
+ * StoreFactory saves spezial elements.
+ * Output was generate with StoreAppenders.
+ */
+public class StoreFactoryBase implements IStoreFactory {
+    private static Log log = LogFactory.getLog(StoreFactoryBase.class);
+
+    private StoreRegistry registry;
+
+    private StoreAppender storeAppender = new StoreAppender();
+
+    /**
+     * The string manager for this package.
+     */
+    protected static final StringManager sm = StringManager
+            .getManager(Constants.Package);
+
+    /**
+     * The descriptive information string for this implementation.
+     */
+    private static final String info = "org.apache.catalina.config.StoreFactoryBase/1.0";
+
+    /**
+     * Return descriptive information about this Facotry implementation and the
+     * corresponding version number, in the format
+     * <code>&lt;description&gt;/&lt;version&gt;</code>.
+     */
+    public String getInfo() {
+
+        return (info);
+
+    }
+
+    /**
+     * @return Returns the storeAppender.
+     */
+    public StoreAppender getStoreAppender() {
+        return storeAppender;
+    }
+
+    /**
+     * @param storeAppender
+     *            The storeAppender to set.
+     */
+    public void setStoreAppender(StoreAppender storeAppender) {
+        this.storeAppender = storeAppender;
+    }
+
+    /*
+     * set Registry
+     * 
+     * @see org.apache.catalina.config.IStoreFactory#setRegistry(org.apache.catalina.config.ConfigurationRegistry)
+     */
+    public void setRegistry(StoreRegistry aRegistry) {
+        registry = aRegistry;
+
+    }
+
+    /*
+     * get Registry
+     * 
+     * @see org.apache.catalina.config.IStoreFactory#getRegistry()
+     */
+    public StoreRegistry getRegistry() {
+
+        return registry;
+    }
+
+    public void storeXMLHead(PrintWriter aWriter) {
+        // Store the beginning of this element
+        aWriter.print("<?xml version=\"1.0\" encoding=\"");
+        aWriter.print(getRegistry().getEncoding());
+        aWriter.println("\"?>");
+    }
+
+    /*
+     * Store a server.xml element with attributes and childs
+     * 
+     * @see org.apache.catalina.storeconfig.IStoreFactory#store(java.io.PrintWriter,
+     *      int, java.lang.Object)
+     */
+    public void store(PrintWriter aWriter, int indent, Object aElement)
+            throws Exception {
+
+        StoreDescription elementDesc = getRegistry().findDescription(
+                aElement.getClass());
+
+        if (elementDesc != null) {
+            if (log.isDebugEnabled())
+                log.debug(sm.getString("factory.storeTag",
+                        elementDesc.getTag(), aElement));
+            getStoreAppender().printIndent(aWriter, indent + 2);
+            if (!elementDesc.isChilds()) {
+                getStoreAppender().printTag(aWriter, indent, aElement,
+                        elementDesc);
+            } else {
+                getStoreAppender().printOpenTag(aWriter, indent + 2, aElement,
+                        elementDesc);
+                storeChilds(aWriter, indent + 2, aElement, elementDesc);
+                getStoreAppender().printIndent(aWriter, indent + 2);
+                getStoreAppender().printCloseTag(aWriter, elementDesc);
+            }
+        } else
+            log.warn(sm.getString("factory.storeNoDescriptor", aElement
+                    .getClass()));
+    }
+
+    /**
+     * Must Implement at subclass for sepzial store childs handling
+     * 
+     * @param aWriter
+     * @param indent
+     * @param aElement
+     * @param elementDesc
+     */
+    public void storeChilds(PrintWriter aWriter, int indent, Object aElement,
+            StoreDescription elementDesc) throws Exception {
+    }
+
+    /**
+     * Store only elements from storeChilds methods that are not a transient
+     * child.
+     * 
+     * @param aWriter current output writer
+     * @param indent indentation level
+     * @param aTagElement current tomcat element
+     * @throws Exception
+     */
+    protected void storeElement(PrintWriter aWriter, int indent,
+            Object aTagElement) throws Exception {
+        if (aTagElement != null) {
+            IStoreFactory elementFactory = getRegistry().findStoreFactory(
+                    aTagElement.getClass());
+
+            if (elementFactory != null) {
+                StoreDescription desc = getRegistry().findDescription(
+                        aTagElement.getClass());
+                if (!desc.isTransientChild(aTagElement.getClass().getName()))
+                    elementFactory.store(aWriter, indent, aTagElement);
+            } else {
+                log.warn(sm.getString("factory.storeNoDescriptor", aTagElement
+                        .getClass()));
+            }
+        }
+    }
+
+    /*
+     * Save a array of elements
+     * @param aWriter current output writer
+     * @param indent indentation level
+     * @param elements list of child elments to store!
+     */
+    protected void storeElementArray(PrintWriter aWriter, int indent,
+            Object[] elements) throws Exception {
+        if (elements != null) {
+            for (int i = 0; i < elements.length; i++) {
+                try {
+                    storeElement(aWriter, indent, elements[i]);
+                } catch (IOException ioe) {
+                    // ingore childs report error them self!
+                    // see StandartContext.storeWithBackup()
+                }
+            }
+        }
+    }
+}
\ No newline at end of file

==================================================
StoreFileMover.java
new file mode 100644
index 0000000000..dab7a51ce0
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/StoreFactoryRule.java
@@ -0,0 +1,123 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.storeconfig;
+
+import org.apache.tomcat.util.digester.Rule;
+import org.xml.sax.Attributes;
+
+/**
+ * <p>
+ * Rule that creates a new <code>IStoreFactory</code> instance, and associates
+ * it with the top object on the stack (which must implement
+ * <code>IStoreFactory</code>).
+ * </p>
+ */
+
+public class StoreFactoryRule extends Rule {
+
+    // ----------------------------------------------------------- Constructors
+
+    /**
+     * Construct a new instance of this Rule.
+     * 
+     * @param storeFactoryClass
+     *            Default name of the StoreFactory implementation class to be
+     *            created
+     * @param attributeName
+     *            Name of the attribute that optionally includes an override
+     *            name of the IStoreFactory class
+     */
+    public StoreFactoryRule(String storeFactoryClass, String attributeName,
+            String storeAppenderClass, String appenderAttributeName) {
+
+        this.storeFactoryClass = storeFactoryClass;
+        this.attributeName = attributeName;
+        this.appenderAttributeName = appenderAttributeName;
+        this.storeAppenderClass = storeAppenderClass;
+
+    }
+
+    // ----------------------------------------------------- Instance Variables
+
+    /**
+     * The attribute name of an attribute that can override the implementation
+     * class name.
+     */
+    private String attributeName;
+
+    private String appenderAttributeName;
+
+    /**
+     * The name of the <code>IStoreFactory</code> implementation class.
+     */
+    private String storeFactoryClass;
+
+    private String storeAppenderClass;
+
+    // --------------------------------------------------------- Public Methods
+
+    /**
+     * Handle the beginning of an XML element.
+     * 
+     * @param attributes
+     *            The attributes of this element
+     * 
+     * @exception Exception
+     *                if a processing error occurs
+     */
+    public void begin(String namespace, String name, Attributes attributes)
+            throws Exception {
+
+        IStoreFactory factory = (IStoreFactory) newInstance(attributeName,
+                storeFactoryClass, attributes);
+        StoreAppender storeAppender = (StoreAppender) newInstance(
+                appenderAttributeName, storeAppenderClass, attributes);
+        factory.setStoreAppender(storeAppender);
+
+        // Add this StoreFactory to our associated component
+        StoreDescription desc = (StoreDescription) digester.peek(0);
+        StoreRegistry registry = (StoreRegistry) digester.peek(1);
+        factory.setRegistry(registry);
+        desc.setStoreFactory(factory);
+
+    }
+
+    /**
+     * create new instance from attribte className!
+     * 
+     * @param attr class Name attribute
+     * @param defaultName Default Class
+     * @param attributes current digester attribute elements
+     * @return new config object instance
+     * @throws ClassNotFoundException
+     * @throws InstantiationException
+     * @throws IllegalAccessException
+     */
+    protected Object newInstance(String attr, String defaultName,
+            Attributes attributes) throws ClassNotFoundException,
+            InstantiationException, IllegalAccessException {
+        String className = defaultName;
+        if (attr != null) {
+            String value = attributes.getValue(attr);
+            if (value != null)
+                className = value;
+        }
+        Class<?> clazz = Class.forName(className);
+        return clazz.newInstance();
+    }
+}
\ No newline at end of file

==================================================
StoreLoader.java
new file mode 100644
index 0000000000..6693ff35c1
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/StoreFileMover.java
@@ -0,0 +1,208 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.storeconfig;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
+import java.io.PrintWriter;
+import java.sql.Timestamp;
+
+/**
+ * Move server.xml or context.xml as backup
+ * 
+ * TODO Get Encoding from Registry
+ */
+public class StoreFileMover {
+
+    private String filename = "conf/server.xml";
+
+    private String encoding = "UTF-8";
+
+    private String basename = System.getProperty("catalina.base");
+
+    private File configOld;
+
+    private File configNew;
+
+    private File configSave;
+
+    /**
+     * @return Returns the configNew.
+     */
+    public File getConfigNew() {
+        return configNew;
+    }
+
+    /**
+     * @return Returns the configOld.
+     */
+    public File getConfigOld() {
+        return configOld;
+    }
+
+    /**
+     * @return Returns the configSave.
+     */
+    public File getConfigSave() {
+        return configSave;
+    }
+
+    /**
+     * @return Returns the basename.
+     */
+    public String getBasename() {
+        return basename;
+    }
+
+    /**
+     * @param basename
+     *            The basename to set.
+     */
+    public void setBasename(String basename) {
+        this.basename = basename;
+    }
+
+    /**
+     * @return The file name
+     */
+    public String getFilename() {
+        return filename;
+    }
+
+    /**
+     * @param string
+     */
+    public void setFilename(String string) {
+        filename = string;
+    }
+
+    /**
+     * @return The encoding
+     */
+    public String getEncoding() {
+        return encoding;
+    }
+
+    /**
+     * @param string
+     */
+    public void setEncoding(String string) {
+        encoding = string;
+    }
+
+    /**
+     * Calculate file objects for the old and new configuration files.
+     */
+    public StoreFileMover(String basename, String filename, String encoding) {
+        setBasename(basename);
+        setEncoding(encoding);
+        setFilename(filename);
+        init();
+    }
+
+    /**
+     * Calculate file objects for the old and new configuration files.
+     */
+    public StoreFileMover() {
+        init();
+    }
+
+    /**
+     * generate the Filename to new with TimeStamp
+     */
+    public void init() {
+        String configFile = getFilename();
+        configOld = new File(configFile);
+        if (!configOld.isAbsolute()) {
+            configOld = new File(getBasename(), configFile);
+        }
+        configNew = new File(configFile + ".new");
+        if (!configNew.isAbsolute()) {
+            configNew = new File(getBasename(), configFile + ".new");
+        }
+        if (!configNew.getParentFile().exists()) {
+            configNew.getParentFile().mkdirs();
+        }
+        String sb = getTimeTag();
+        configSave = new File(configFile + sb);
+        if (!configSave.isAbsolute()) {
+            configSave = new File(getBasename(), configFile + sb);
+        }
+    }
+
+    /**
+     * Shuffle old->save and new->old
+     * 
+     * @throws IOException
+     */
+    public void move() throws IOException {
+        if (configOld.renameTo(configSave)) {
+            if (!configNew.renameTo(configOld)) {
+                configSave.renameTo(configOld);
+                throw new IOException("Cannot rename "
+                        + configNew.getAbsolutePath() + " to "
+                        + configOld.getAbsolutePath());
+            }
+        } else {
+            if (!configOld.exists()) {
+                if (!configNew.renameTo(configOld)) {
+                    throw new IOException("Cannot move "
+                            + configNew.getAbsolutePath() + " to "
+                            + configOld.getAbsolutePath());
+                }
+            } else {
+                throw new IOException("Cannot rename "
+                    + configOld.getAbsolutePath() + " to "
+                    + configSave.getAbsolutePath());
+            }
+        }
+    }
+
+    /**
+     * Open an output writer for the new configuration file
+     * 
+     * @return The writer
+     * @throws IOException
+     */
+    public PrintWriter getWriter() throws IOException {
+        return new PrintWriter(new OutputStreamWriter(
+                new FileOutputStream(configNew), getEncoding()));
+    }
+
+    /**
+     * Time value for backup yyyy-mm-dd.hh-mm-ss
+     * 
+     * @return The time
+     */
+    protected String getTimeTag() {
+        String ts = (new Timestamp(System.currentTimeMillis())).toString();
+        //        yyyy-mm-dd hh:mm:ss
+        //        0123456789012345678
+        StringBuffer sb = new StringBuffer(".");
+        sb.append(ts.substring(0, 10));
+        sb.append('.');
+        sb.append(ts.substring(11, 13));
+        sb.append('-');
+        sb.append(ts.substring(14, 16));
+        sb.append('-');
+        sb.append(ts.substring(17, 19));
+        return sb.toString();
+    }
+
+}

==================================================
StoreRegistry.java
new file mode 100644
index 0000000000..69a173d4ea
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/StoreLoader.java
@@ -0,0 +1,285 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.storeconfig;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+import org.apache.tomcat.util.digester.Digester;
+import org.xml.sax.SAXException;
+
+/**
+ * <b>XML Format </b>
+ * 
+ * <pre>
+ *    
+ *       &lt;Registry name=&quot;&quot; encoding=&quot;UTF8&quot; &gt;
+ *       &lt;Description tag=&quot;Server&quot; standard=&quot;true&quot; default=&quot;true&quot;/&gt; 
+ *          tagClass=&quot;org.apache.catalina.core.StandardServer&quot;
+ *          storeFactory=&quot;org.apache.catalina.storeconfig.StandardServerSF&quot;&gt;
+ *        &lt;TransientAttributes&gt;
+ *          &lt;Attribute&gt;&lt;/Attribute&gt;
+ *        &lt;/TransientAttributes&gt;
+ *        &lt;TransientChilds&gt;
+ *          &lt;Child&gt;&lt;/Child&gt;
+ *        &lt;/TransientChilds&gt;
+ *       &lt;/Description&gt;
+ *   ...
+ *       &lt;/Tegistry&gt;
+ *     
+ * </pre>
+ * 
+ * 
+ * Convention:
+ * <ul>
+ * <li>Factories at subpackage <i>org.apache.catalina.core.storeconfig.xxxSF
+ * </i>.</li>
+ * <li>Element name are the unique Class name</li>
+ * <li>SF for StoreFactory</li>
+ * <li>standard implementation is false</li>
+ * </ul>
+ * other things:
+ * <ul>
+ * <li>Registry XML format is a very good option</li>
+ * <li>Store format is not fix</li>
+ * <li>We hope with the parent declaration we can build recursive child store
+ * operation //dream</li>
+ * <li>Problem is to access child data from array,collections or normal detail
+ * object</li>
+ * <li>Default definitions for Listener, Valve Resource? - Based on interface
+ * type!</li>
+ * </ul>
+ */
+public class StoreLoader {
+    private static Log log = LogFactory.getLog(StoreLoader.class);
+
+    /**
+     * The <code>Digester</code> instance used to parse registry descriptors.
+     */
+    protected static Digester digester = createDigester();
+
+    private StoreRegistry registry;
+    
+    private URL registryResource ;
+
+    /**
+     * @return Returns the registry.
+     */
+    public StoreRegistry getRegistry() {
+        return registry;
+    }
+
+    /**
+     * @param registry
+     *            The registry to set.
+     */
+    public void setRegistry(StoreRegistry registry) {
+        this.registry = registry;
+    }
+
+    /**
+     * Create and configure the Digester we will be using for setup store
+     * registry.
+     */
+    protected static Digester createDigester() {
+        long t1 = System.currentTimeMillis();
+        // Initialize the digester
+        Digester digester = new Digester();
+        digester.setValidating(false);
+        digester.setClassLoader(StoreRegistry.class.getClassLoader());
+
+        // Configure the actions we will be using
+        digester.addObjectCreate("Registry",
+                "org.apache.catalina.storeconfig.StoreRegistry", "className");
+        digester.addSetProperties("Registry");
+        digester
+                .addObjectCreate("Registry/Description",
+                        "org.apache.catalina.storeconfig.StoreDescription",
+                        "className");
+        digester.addSetProperties("Registry/Description");
+        digester.addRule("Registry/Description", new StoreFactoryRule(
+                "org.apache.catalina.storeconfig.StoreFactoryBase",
+                "storeFactoryClass",
+                "org.apache.catalina.storeconfig.StoreAppender",
+                "storeAppenderClass"));
+        digester.addSetNext("Registry/Description", "registerDescription",
+                "org.apache.catalina.storeconfig.StoreDescription");
+        digester.addCallMethod("Registry/Description/TransientAttribute",
+                "addTransientAttribute", 0);
+        digester.addCallMethod("Registry/Description/TransientChild",
+                "addTransientChild", 0);
+
+        long t2 = System.currentTimeMillis();
+        if (log.isDebugEnabled())
+            log.debug("Digester for server-registry.xml created " + (t2 - t1));
+        return (digester);
+
+    }
+
+    /**
+     * 
+     * @param aFile
+     * @return The server file
+     */
+    protected File serverFile(String aFile) {
+
+        if (aFile == null || (aFile != null && aFile.length() < 1))
+            aFile = "server-registry.xml";
+        File file = new File(aFile);
+        if (!file.isAbsolute())
+            file = new File(System.getProperty("catalina.base") + "/conf",
+                    aFile);
+        try {
+            file = file.getCanonicalFile();
+        } catch (IOException e) {
+            log.error(e);
+        }
+        return (file);
+    }
+
+    /**
+     * Load Description from external source
+     * 
+     * @param aURL
+     */
+    public void load(String aURL) {
+        synchronized (digester) {
+            File aRegistryFile = serverFile(aURL);
+            try {
+                registry = (StoreRegistry) digester.parse(aRegistryFile);
+                registryResource = aRegistryFile.toURI().toURL();
+            } catch (IOException e) {
+                log.error(e);
+            } catch (SAXException e) {
+                log.error(e);
+            }
+        }
+
+    }
+
+    /**
+     * Load from defaults
+     * <ul>
+     * <li>System Property URL catalina.storeregistry</li>
+     * <li>File $catalina.base/conf/server-registry.xml</li>
+     * <li>class resource org/apache/catalina/storeconfig/server-registry.xml
+     * </li>
+     * </ul>
+     */
+    public void load() {
+
+        InputStream is = null;
+        Throwable error = null;
+        registryResource = null ;
+        try {
+            String configUrl = getConfigUrl();
+            if (configUrl != null) {
+                is = (new URL(configUrl)).openStream();
+                if (log.isInfoEnabled())
+                    log
+                            .info("Find registry server-registry.xml from system property at url "
+                                    + configUrl);
+                ;
+                registryResource = new URL(configUrl);
+            }
+        } catch (Throwable t) {
+            // Ignore
+        }
+        if (is == null) {
+            try {
+                File home = new File(getCatalinaBase());
+                File conf = new File(home, "conf");
+                File reg = new File(conf, "server-registry.xml");
+                is = new FileInputStream(reg);
+                if (log.isInfoEnabled())
+                    log.info("Find registry server-registry.xml at file "
+                            + reg.getCanonicalPath());
+                ;
+                registryResource = reg.toURI().toURL();
+            } catch (Throwable t) {
+                // Ignore
+            }
+        }
+        if (is == null) {
+            try {
+                is = StoreLoader.class
+                        .getResourceAsStream("/org/apache/catalina/storeconfig/server-registry.xml");
+                if (log.isInfoEnabled())
+                    log
+                            .info("Find registry server-registry.xml at classpath resource");
+                registryResource = StoreLoader.class
+                    .getResource("/org/apache/catalina/storeconfig/server-registry.xml");
+                
+            } catch (Throwable t) {
+                // Ignore
+            }
+        }
+        if (is != null) {
+            try {
+                synchronized (digester) {
+                    registry = (StoreRegistry) digester.parse(is);
+                }
+            } catch (Throwable t) {
+                error = t;
+            } finally {
+                try {
+                    is.close();
+                } catch (IOException e) {
+                }
+            }
+        }
+        if ((is == null) || (error != null)) {
+            log.error(error);
+        }
+    }
+
+    /**
+     * Get the value of the catalina.home environment variable.
+     */
+    private static String getCatalinaHome() {
+        return System.getProperty("catalina.home", System
+                .getProperty("user.dir"));
+    }
+
+    /**
+     * Get the value of the catalina.base environment variable.
+     */
+    private static String getCatalinaBase() {
+        return System.getProperty("catalina.base", getCatalinaHome());
+    }
+
+    /**
+     * Get the value of the configuration URL.
+     */
+    private static String getConfigUrl() {
+        return System.getProperty("catalina.storeconfig");
+    }
+    
+    
+
+    /**
+     * @return Returns the registryResource.
+     */
+    public URL getRegistryResource() {
+        return registryResource;
+    }
+}

==================================================
WatchedResourceSF.java
new file mode 100644
index 0000000000..c784ccadc1
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/StoreRegistry.java
@@ -0,0 +1,209 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.storeconfig;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.naming.directory.DirContext;
+
+import org.apache.catalina.LifecycleListener;
+import org.apache.catalina.Manager;
+import org.apache.catalina.Realm;
+import org.apache.catalina.Valve;
+import org.apache.catalina.WebResourceRoot;
+import org.apache.catalina.WebResourceSet;
+import org.apache.catalina.ha.CatalinaCluster;
+import org.apache.catalina.ha.ClusterDeployer;
+import org.apache.catalina.ha.ClusterListener;
+import org.apache.catalina.tribes.Channel;
+import org.apache.catalina.tribes.ChannelInterceptor;
+import org.apache.catalina.tribes.ChannelReceiver;
+import org.apache.catalina.tribes.ChannelSender;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.MembershipService;
+import org.apache.catalina.tribes.MessageListener;
+import org.apache.catalina.tribes.transport.DataSender;
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+
+/**
+ * Central StoreRegistry for all server.xml elements
+ */
+public class StoreRegistry {
+    private static Log log = LogFactory.getLog(StoreRegistry.class);
+
+    private Map<String, StoreDescription> descriptors = new HashMap<>();
+
+    private String encoding = "UTF-8";
+
+    private String name;
+
+    private String version;
+
+    // Access Information
+    private static Class<?> interfaces[] = { CatalinaCluster.class,
+            ChannelSender.class, ChannelReceiver.class, Channel.class,
+            MembershipService.class, ClusterDeployer.class, Realm.class,
+            Manager.class, DirContext.class, LifecycleListener.class,
+            Valve.class, ClusterListener.class, MessageListener.class,
+            DataSender.class, ChannelInterceptor.class, Member.class,
+            WebResourceRoot.class, WebResourceSet.class };
+
+    /**
+     * @return Returns the name.
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * @param name
+     *            The name to set.
+     */
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    /**
+     * @return Returns the version.
+     */
+    public String getVersion() {
+        return version;
+    }
+
+    /**
+     * @param version
+     *            The version to set.
+     */
+    public void setVersion(String version) {
+        this.version = version;
+    }
+
+    /**
+     * Find a description for id. Handle interface search when no direct match
+     * found.
+     * 
+     * @param id
+     * @return The description
+     */
+    public StoreDescription findDescription(String id) {
+        if (log.isDebugEnabled())
+            log.debug("search descriptor " + id);
+        StoreDescription desc = (StoreDescription) descriptors.get(id);
+        if (desc == null) {
+            Class<?> aClass = null;
+            try {
+                aClass = Class.forName(id, true, this.getClass()
+                        .getClassLoader());
+            } catch (ClassNotFoundException e) {
+                log.error("ClassName:" + id, e);
+            }
+            if (aClass != null) {
+                desc = (StoreDescription) descriptors.get(aClass.getName());
+                for (int i = 0; desc == null && i < interfaces.length; i++) {
+                    if (interfaces[i].isAssignableFrom(aClass)) {
+                        desc = (StoreDescription) descriptors.get(interfaces[i]
+                                .getName());
+                    }
+                }
+            }
+        }
+        if (log.isDebugEnabled())
+            if (desc != null)
+                log.debug("find descriptor " + id + "#" + desc.getTag() + "#"
+                        + desc.getStoreFactoryClass());
+            else
+                log.debug(("Can't find descriptor for key " + id));
+        return desc;
+    }
+
+    /**
+     * Find Description by class
+     * 
+     * @param aClass
+     * @return The description
+     */
+    public StoreDescription findDescription(Class<?> aClass) {
+        return findDescription(aClass.getName());
+    }
+
+    /**
+     * Find factory from classname
+     * 
+     * @param aClassName
+     * @return The factory
+     */
+    public IStoreFactory findStoreFactory(String aClassName) {
+        StoreDescription desc = findDescription(aClassName);
+        if (desc != null)
+            return desc.getStoreFactory();
+        else
+            return null;
+
+    }
+
+    /**
+     * find factory from class
+     * 
+     * @param aClass
+     * @return The factory
+     */
+    public IStoreFactory findStoreFactory(Class<?> aClass) {
+        return findStoreFactory(aClass.getName());
+    }
+
+    /**
+     * Register a new description
+     * 
+     * @param desc
+     */
+    public void registerDescription(StoreDescription desc) {
+        String key = desc.getId();
+        if (key == null || "".equals(key))
+            key = desc.getTagClass();
+        descriptors.put(key, desc);
+        if (log.isDebugEnabled())
+            log.debug("register store descriptor " + key + "#" + desc.getTag()
+                    + "#" + desc.getTagClass());
+    }
+
+    public StoreDescription unregisterDescription(StoreDescription desc) {
+        String key = desc.getId();
+        if (key == null || "".equals(key))
+            key = desc.getTagClass();
+        return (StoreDescription) descriptors.remove(key);
+    }
+
+    // Attributes
+
+    /**
+     * @return The encoding
+     */
+    public String getEncoding() {
+        return encoding;
+    }
+
+    /**
+     * @param string
+     */
+    public void setEncoding(String string) {
+        encoding = string;
+    }
+
+}

==================================================
WebResourceRootSF.java
new file mode 100644
index 0000000000..45047e1bf1
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/WatchedResourceSF.java
@@ -0,0 +1,53 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.storeconfig;
+
+import java.io.PrintWriter;
+
+import org.apache.catalina.core.StandardContext;
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+
+public class WatchedResourceSF extends StoreFactoryBase {
+    private static Log log = LogFactory.getLog(WatchedResourceSF.class);
+
+    /*
+     * Store nested Element Value Arrays WatchedResource
+     * 
+     * @see org.apache.catalina.config.IStoreFactory#store(java.io.PrintWriter,
+     *      int, java.lang.Object)
+     */
+    public void store(PrintWriter aWriter, int indent, Object aElement)
+            throws Exception {
+        if (aElement instanceof StandardContext) {
+            StoreDescription elementDesc = getRegistry().findDescription(
+                    aElement.getClass().getName() + ".[WatchedResource]");
+            String[] resources = ((StandardContext) aElement)
+                    .findWatchedResources();
+            if (elementDesc != null) {
+                if (log.isDebugEnabled())
+                    log.debug("store " + elementDesc.getTag() + "( " + aElement
+                            + " )");
+                getStoreAppender().printTagArray(aWriter, "WatchedResource",
+                        indent, resources);
+            }
+        } else
+            log.warn("Descriptor for element" + aElement.getClass()
+                    + ".[WatchedResource] not configured!");
+    }
+}
\ No newline at end of file

==================================================
WrapperLifecycleSF.java
new file mode 100644
index 0000000000..3558dd2bf3
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/WebResourceRootSF.java
@@ -0,0 +1,48 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.storeconfig;
+
+import java.io.PrintWriter;
+
+import org.apache.catalina.WebResourceRoot;
+
+/**
+ * Generate Resources element
+ */
+public class WebResourceRootSF extends StoreFactoryBase {
+
+    /**
+     * Store the specified Resources childs.
+     * 
+     * @param aWriter
+     *            PrintWriter to which we are storing
+     * @param indent
+     *            Number of spaces to indent this element
+     * @param aCluster
+     *            Cluster whose properties are being stored
+     * 
+     * @exception Exception
+     *                if an exception occurs while storing
+     */
+    public void storeChilds(PrintWriter aWriter, int indent, Object aResourceRoot,
+            StoreDescription parentDesc) throws Exception {
+        if (aResourceRoot instanceof WebResourceRoot) {
+            // FIXME: No getter to access PreResource, JarResources and PostResources
+        }
+    }
+}
\ No newline at end of file

==================================================
WrapperListenerSF.java
new file mode 100644
index 0000000000..8b1974f970
--- /dev/null
+++ b/java/org/apache/catalina/storeconfig/WrapperLifecycleSF.java
@@ -0,0 +1,53 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.storeconfig;
+
+import java.io.PrintWriter;
+
+import org.apache.catalina.core.StandardContext;
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+
+public class WrapperLifecycleSF extends StoreFactoryBase {
+    private static Log log = LogFactory.getLog(WrapperLifecycleSF.class);
+
+    /*
+     * Store nested Element Value Arrays
+     * 
+     * @see org.apache.catalina.config.IStoreFactory#store(java.io.PrintWriter,
+     *      int, java.lang.Object)
+     */
+    public void store(PrintWriter aWriter, int indent, Object aElement)
+            throws Exception {
+        if (aElement instanceof StandardContext) {
+            StoreDescription elementDesc = getRegistry().findDescription(
+                    aElement.getClass().getName() + ".[WrapperLifecycle]");
+            String[] listeners = ((StandardContext) aElement)
+                    .findWrapperLifecycles();
+            if (elementDesc != null) {
+                if (log.isDebugEnabled())
+                    log.debug("store " + elementDesc.getTag() + "( " + aElement
+                            + " )");
+                getStoreAppender().printTagArray(aWriter, "WrapperLifecycle",
+                        indent, listeners);
+            }
+        } else
+            log.warn("Descriptor for element" + aElement.getClass()
+                    + ".[WrapperLifecycle] not configured!");
+    }
+}
\ No newline at end of file

==================================================
