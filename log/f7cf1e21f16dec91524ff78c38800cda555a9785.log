f7cf1e21f16dec91524ff78c38800cda555a9785
==================================================
Simplify handling of tiemouts now that async timeout has been separated
==================================================
Mark Emlyn
==================================================
Wed Nov 12 10:49:07 2014 +0000
==================================================
AbstractAjpProcessor.java
Simplify handling of tiemouts now that async timeout has been separated
from read/write timeout.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1638749 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AjpAprProcessor.java
index 05eb144300..a8729d3028 100644
--- a/java/org/apache/coyote/ajp/AbstractAjpProcessor.java
+++ b/java/org/apache/coyote/ajp/AbstractAjpProcessor.java
@@ -678,7 +678,6 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
             if(!getAdapter().asyncDispatch(request, response, status)) {
                 setErrorState(ErrorState.CLOSE_NOW, null);
             }
-            resetTimeouts();
         } catch (InterruptedIOException e) {
             setErrorState(ErrorState.CLOSE_NOW, e);
         } catch (Throwable t) {
@@ -697,6 +696,10 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
                 return SocketState.LONG;
             }
         } else {
+            // Set keep alive timeout for next request if enabled
+            if (keepAliveTimeout > 0) {
+                socketWrapper.setTimeout(keepAliveTimeout);
+            }
             request.updateCounters();
             if (getErrorState().isError()) {
                 return SocketState.CLOSED;
@@ -841,7 +844,7 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
             request.updateCounters();
 
             rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);
-            // Set keep alive timeout if enabled
+            // Set keep alive timeout for next request if enabled
             if (keepAliveTimeout > 0) {
                 socketWrapper.setTimeout(keepAliveTimeout);
             }
@@ -919,14 +922,6 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
 
     // ------------------------------------------------------ Protected Methods
 
-    // Methods called by asyncDispatch
-    /**
-     * Provides a mechanism for those connector implementations (currently only
-     * NIO) that need to reset timeouts from Async timeouts to standard HTTP
-     * timeouts once async processing completes.
-     */
-    protected abstract void resetTimeouts();
-
     // Methods called by prepareResponse()
     protected abstract int output(byte[] src, int offset, int length,
             boolean block) throws IOException;

==================================================
AjpNio2Processor.java
index 3ae0816511..f4d25a43db 100644
--- a/java/org/apache/coyote/ajp/AjpAprProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpAprProcessor.java
@@ -79,12 +79,6 @@ public class AjpAprProcessor extends AbstractAjpProcessor<Long> {
                 socketWrapper.getSocket().longValue(), -1, read, write);
     }
 
-    @Override
-    protected void resetTimeouts() {
-        // NO-OP. The AJP APR/native connector only uses the timeout value on
-        //        time SocketWrapper for async timeouts.
-    }
-
 
     @Override
     protected void setupSocket(SocketWrapperBase<Long> socketWrapper) {

==================================================
AjpNioProcessor.java
index 0aaa9ecb80..70157f14b9 100644
--- a/java/org/apache/coyote/ajp/AjpNio2Processor.java
+++ b/java/org/apache/coyote/ajp/AjpNio2Processor.java
@@ -99,25 +99,6 @@ public class AjpNio2Processor extends AbstractAjpProcessor<Nio2Channel> {
         // already be pending
     }
 
-    @Override
-    protected void resetTimeouts() {
-        // The NIO connector uses the timeout configured on the wrapper in the
-        // poller. Therefore, it needs to be reset once asycn processing has
-        // finished.
-        if (!getErrorState().isError() && socketWrapper != null &&
-                asyncStateMachine.isAsyncDispatching()) {
-            long soTimeout = endpoint.getSoTimeout();
-
-            //reset the timeout
-            if (keepAliveTimeout > 0) {
-                socketWrapper.setTimeout(keepAliveTimeout);
-            } else {
-                socketWrapper.setTimeout(soTimeout);
-            }
-        }
-
-    }
-
 
     @Override
     protected void setupSocket(SocketWrapperBase<Nio2Channel> socketWrapper)

==================================================
