b21548f11340059b4e947f3b97540f4477b1e8dd
==================================================
Further improvements to the handling of reset streams
==================================================
Mark Thomas
==================================================
Mon May 23 12:52:06 2016 +0000
==================================================
Stream.java
Further improvements to the handling of reset streams

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1745177 13f79535-47bb-0310-9956-ffa450edef68



==================================================
TestHttp2Section_5_1.java
index 60a443b59f..2f3880e1b1 100644
--- a/java/org/apache/coyote/http2/Stream.java
+++ b/java/org/apache/coyote/http2/Stream.java
@@ -122,7 +122,16 @@ public class Stream extends AbstractStream implements HeaderEmitter {
             log.debug(sm.getString("stream.reset.debug", getConnectionId(), getIdentifier(),
                     Long.toString(errorCode)));
         }
+        // Set the new state first since read and write both check this
         state.receiveReset();
+        // Reads wait internally so need to call a method to break the wait()
+        if (inputBuffer != null) {
+            inputBuffer.receiveReset();
+        }
+        // Writes wait on Stream so we can notify directly
+        synchronized (this) {
+            this.notifyAll();
+        }
     }
 
 
@@ -603,6 +612,7 @@ public class Stream extends AbstractStream implements HeaderEmitter {
         // 'write mode'.
         private volatile ByteBuffer inBuffer;
         private volatile boolean readInterest;
+        private boolean reset = false;
 
         @Override
         public int doRead(ByteChunk chunk) throws IOException {
@@ -620,6 +630,10 @@ public class Stream extends AbstractStream implements HeaderEmitter {
                             log.debug(sm.getString("stream.inputBuffer.empty"));
                         }
                         inBuffer.wait();
+                        if (reset) {
+                            // TODO: i18n
+                            throw new IOException("HTTP/2 Stream reset");
+                        }
                     } catch (InterruptedException e) {
                         // Possible shutdown / rst or similar. Use an
                         // IOException to signal to the client that further I/O
@@ -729,5 +743,15 @@ public class Stream extends AbstractStream implements HeaderEmitter {
                 }
             }
         }
+
+
+        protected void receiveReset() {
+            if (inBuffer != null) {
+                synchronized (inBuffer) {
+                    reset = true;
+                    inBuffer.notifyAll();
+                }
+            }
+        }
     }
 }

==================================================
