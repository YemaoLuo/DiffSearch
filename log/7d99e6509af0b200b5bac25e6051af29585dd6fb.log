7d99e6509af0b200b5bac25e6051af29585dd6fb
==================================================
Remove unused code identified by Eclipse / UCDetector.
==================================================
Mark Emlyn
==================================================
Sat Dec 5 23:22:46 2009 +0000
==================================================
Constants.java
Remove unused code identified by Eclipse / UCDetector.
Not complete - still more to remove.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@887610 13f79535-47bb-0310-9956-ffa450edef68



==================================================
ExceptionConstants.java
index 5a029730d7..6a94ee35c4 100644
--- a/java/org/apache/tomcat/util/bcel/Constants.java
+++ b/java/org/apache/tomcat/util/bcel/Constants.java
@@ -34,65 +34,29 @@ public interface Constants {
    *  */
   public final static short MINOR_1_1 = 3;
 
-  /** Major version number of class files for Java 1.2.
-   *  @see #MINOR_1_2
-   *  */
-  public final static short MAJOR_1_2 = 46;
+  
 
-  /** Minor version number of class files for Java 1.2.
-   *  @see #MAJOR_1_2
-   *  */
-  public final static short MINOR_1_2 = 0;
+  
 
-  /** Major version number of class files for Java 1.2.
-   *  @see #MINOR_1_2
-   *  */
-  public final static short MAJOR_1_3 = 47;
+  
 
-  /** Minor version number of class files for Java 1.3.
-   *  @see #MAJOR_1_3
-   *  */
-  public final static short MINOR_1_3 = 0;
+  
 
-  /** Major version number of class files for Java 1.3.
-   *  @see #MINOR_1_3
-   *  */
-  public final static short MAJOR_1_4 = 48;
+  
 
-  /** Minor version number of class files for Java 1.4.
-   *  @see #MAJOR_1_4
-   *  */
-  public final static short MINOR_1_4 = 0;
+  
 
-  /** Major version number of class files for Java 1.4.
-   *  @see #MINOR_1_4
-   *  */
-  public final static short MAJOR_1_5 = 49;
+  
 
-  /** Minor version number of class files for Java 1.5.
-   *  @see #MAJOR_1_5
-   *  */
-  public final static short MINOR_1_5 = 0;
+  
 
-  /** Major version number of class files for Java 1.5.
-   *  @see #MINOR_1_5
-   *  */
-  public final static short MAJOR_1_6 = 50;
+  
 
-  /** Minor version number of class files for Java 1.6.
-   *  @see #MAJOR_1_6
-   *  */
-  public final static short MINOR_1_6 = 0;
+  
 
-  /** Default major version number.  Class file is for Java 1.1.
-   *  @see #MAJOR_1_1
-   *  */
-  public final static short MAJOR = MAJOR_1_1;
+  
 
-  /** Default major version number.  Class file is for Java 1.1.
-   *  @see #MAJOR_1_1
-   *  */
-  public final static short MINOR     = MINOR_1_1;
+  
 
   /** Maximum value for an unsigned short.
    */
@@ -102,22 +66,11 @@ public interface Constants {
    */
   public final static int MAX_BYTE  = 255; // 2^8 - 1
 
-  /** One of the access flags for fields, methods, or classes.
-   *  @see <a href='http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#2877'>Flag definitions for Fields in the Java Virtual Machine Specification (2nd edition).</a>
-   *  @see <a href='http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#1513'>Flag definitions for Methods in the Java Virtual Machine Specification (2nd edition).</a>
-   *  @see <a href='http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#88478'>Flag definitions for Classes in the Java Virtual Machine Specification (2nd edition).</a>
-   */
-  public final static short ACC_PUBLIC       = 0x0001;
+  
 
-  /** One of the access flags for fields, methods, or classes.
-   *  @see #ACC_PUBLIC
-   */
-  public final static short ACC_PRIVATE      = 0x0002;
+  
 
-  /** One of the access flags for fields, methods, or classes.
-   *  @see #ACC_PUBLIC
-   */
-  public final static short ACC_PROTECTED    = 0x0004;
+  
 
   /** One of the access flags for fields, methods, or classes.
    *  @see #ACC_PUBLIC
@@ -129,35 +82,17 @@ public interface Constants {
    */
   public final static short ACC_FINAL        = 0x0010;
 
-  /** One of the access flags for fields, methods, or classes.
-   *  @see #ACC_PUBLIC
-   */
-  public final static short ACC_SYNCHRONIZED = 0x0020;
+  
 
-  /** One of the access flags for fields, methods, or classes.
-   *  @see #ACC_PUBLIC
-   */
-  public final static short ACC_SYPER        = 0x0020;
+  
 
-  /** One of the access flags for fields, methods, or classes.
-   *  @see #ACC_PUBLIC
-   */
-  public final static short ACC_VOLATILE     = 0x0040;
+  
 
-  /** One of the access flags for fields, methods, or classes.
-   *  @see #ACC_PUBLIC
-   */
-  public final static short ACC_BRIDGE       = 0x0040;
+  
 
-  /** One of the access flags for fields, methods, or classes.
-   *  @see #ACC_PUBLIC
-   */
-  public final static short ACC_TRANSIENT    = 0x0080;
+  
 
-  /** One of the access flags for fields, methods, or classes.
-   *  @see #ACC_PUBLIC
-   */
-  public final static short ACC_VARARGS      = 0x0080;
+  
 
   /** One of the access flags for fields, methods, or classes.
    *  @see #ACC_PUBLIC
@@ -174,20 +109,11 @@ public interface Constants {
    */
   public final static short ACC_ABSTRACT     = 0x0400;
 
-  /** One of the access flags for fields, methods, or classes.
-   *  @see #ACC_PUBLIC
-   */
-  public final static short ACC_STRICT       = 0x0800;
   
-  /** One of the access flags for fields, methods, or classes.
-   *  @see #ACC_PUBLIC
-   */
-  public final static short ACC_SYNTHETIC    = 0x1000;
+  
+  
 
-  /** One of the access flags for fields, methods, or classes.
-   *  @see #ACC_PUBLIC
-   */
-  public final static short ACC_ANNOTATION   = 0x2000;
+  
 
   /** One of the access flags for fields, methods, or classes.
    *  @see #ACC_PUBLIC
@@ -253,82 +179,34 @@ public interface Constants {
     "CONSTANT_Methodref", "CONSTANT_InterfaceMethodref",
     "CONSTANT_NameAndType" };
 
-  /** The name of the static initializer, also called &quot;class
-   *  initialization method&quot; or &quot;interface initialization
-   *   method&quot;. This is &quot;&lt;clinit&gt;&quot;.
-   */
-  public final static String STATIC_INITIALIZER_NAME = "<clinit>";
+  
 
-  /** The name of every constructor method in a class, also called
-   * &quot;instance initialization method&quot;. This is &quot;&lt;init&gt;&quot;.
-   */
-  public final static String CONSTRUCTOR_NAME = "<init>";
+  
 
-  /** The names of the interfaces implemented by arrays */
-  public final static String[] INTERFACES_IMPLEMENTED_BY_ARRAYS = {"java.lang.Cloneable", "java.io.Serializable"};
+  
 
-  /**
-   * One of the limitations of the Java Virtual Machine.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#88659"> The Java Virtual Machine Specification, Second Edition, page 152, chapter 4.10.</a>
-   */
-  public static final int MAX_CP_ENTRIES     = 65535;
+  
 
-  /**
-   * One of the limitations of the Java Virtual Machine.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#88659"> The Java Virtual Machine Specification, Second Edition, page 152, chapter 4.10.</a>
-   */
-  public static final int MAX_CODE_SIZE      = 65536; //bytes
+  
 
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short NOP              = 0;
+  
 
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short ACONST_NULL      = 1;
+  
 
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short ICONST_M1        = 2;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short ICONST_0         = 3;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short ICONST_1         = 4;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short ICONST_2         = 5;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short ICONST_3         = 6;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short ICONST_4         = 7;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short ICONST_5         = 8;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short LCONST_0         = 9;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short LCONST_1         = 10;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short FCONST_0         = 11;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short FCONST_1         = 12;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short FCONST_2         = 13;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short DCONST_0         = 14;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short DCONST_1         = 15;
+  
+  
+  
+  
+  
+  
+  
+  
+  
+  
+  
+  
+  
+  
   /** Java VM opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
   public static final short BIPUSH           = 16;
@@ -542,33 +420,15 @@ public interface Constants {
   /** Java VM opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
   public static final short SASTORE          = 86;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short POP              = 87;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short POP2             = 88;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short DUP              = 89;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short DUP_X1           = 90;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short DUP_X2           = 91;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short DUP2             = 92;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short DUP2_X1          = 93;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short DUP2_X2          = 94;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short SWAP             = 95;
+  
+  
+  
+  
+  
+  
+  
+  
+  
   /** Java VM opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
   public static final short IADD             = 96;
@@ -719,36 +579,20 @@ public interface Constants {
   /** Java VM opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
   public static final short I2B              = 145;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short INT2BYTE         = 145; // Old notion
+  
   /** Java VM opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
   public static final short I2C              = 146;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short INT2CHAR         = 146; // Old notion
+  
   /** Java VM opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
   public static final short I2S              = 147;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short INT2SHORT        = 147; // Old notion
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short LCMP             = 148;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short FCMPL            = 149;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short FCMPG            = 150;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short DCMPL            = 151;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short DCMPG            = 152;
+  
+  
+  
+  
+  
+  
   /** Java VM opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
   public static final short IFEQ             = 153;
@@ -842,18 +686,14 @@ public interface Constants {
   /** Java VM opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
   public static final short INVOKESPECIAL    = 183;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short INVOKENONVIRTUAL = 183; // Old name in JDK 1.0
+  
   /** Java VM opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
   public static final short INVOKESTATIC     = 184;
   /** Java VM opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
   public static final short INVOKEINTERFACE  = 185;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short INVOKEDYNAMIC    = 186;
+  
   /** Java VM opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
   public static final short NEW              = 187;
@@ -863,24 +703,16 @@ public interface Constants {
   /** Java VM opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
   public static final short ANEWARRAY        = 189;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short ARRAYLENGTH      = 190;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short ATHROW           = 191;
+  
+  
   /** Java VM opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
   public static final short CHECKCAST        = 192;
   /** Java VM opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
   public static final short INSTANCEOF       = 193;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short MONITORENTER     = 194;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short MONITOREXIT      = 195;
+  
+  
   /** Java VM opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
   public static final short WIDE             = 196;
@@ -903,106 +735,31 @@ public interface Constants {
   /** JVM internal opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions.doc.html#60105">Reserved opcodes in the Java Virtual Machine Specification</a> */
   public static final short BREAKPOINT                = 202;
-  /** JVM internal opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/first_edition/html/Quick.doc.html#10673">Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)</a>
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ChangesAppendix.doc.html#448885">Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.</a> */
-  public static final short LDC_QUICK                 = 203;
-  /** JVM internal opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/first_edition/html/Quick.doc.html#10673">Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)</a>
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ChangesAppendix.doc.html#448885">Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.</a> */
-  public static final short LDC_W_QUICK               = 204;
-  /** JVM internal opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/first_edition/html/Quick.doc.html#10673">Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)</a>
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ChangesAppendix.doc.html#448885">Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.</a> */
-  public static final short LDC2_W_QUICK              = 205;
-  /** JVM internal opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/first_edition/html/Quick.doc.html#10673">Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)</a>
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ChangesAppendix.doc.html#448885">Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.</a> */
-  public static final short GETFIELD_QUICK            = 206;
-  /** JVM internal opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/first_edition/html/Quick.doc.html#10673">Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)</a>
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ChangesAppendix.doc.html#448885">Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.</a> */
-  public static final short PUTFIELD_QUICK            = 207;
-  /** JVM internal opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/first_edition/html/Quick.doc.html#10673">Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)</a>
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ChangesAppendix.doc.html#448885">Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.</a> */
-  public static final short GETFIELD2_QUICK           = 208;
-  /** JVM internal opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/first_edition/html/Quick.doc.html#10673">Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)</a>
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ChangesAppendix.doc.html#448885">Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.</a> */
-  public static final short PUTFIELD2_QUICK           = 209;
-  /** JVM internal opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/first_edition/html/Quick.doc.html#10673">Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)</a>
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ChangesAppendix.doc.html#448885">Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.</a> */
-  public static final short GETSTATIC_QUICK           = 210;
-  /** JVM internal opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/first_edition/html/Quick.doc.html#10673">Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)</a>
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ChangesAppendix.doc.html#448885">Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.</a> */
-  public static final short PUTSTATIC_QUICK           = 211;
-  /** JVM internal opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/first_edition/html/Quick.doc.html#10673">Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)</a>
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ChangesAppendix.doc.html#448885">Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.</a> */
-  public static final short GETSTATIC2_QUICK          = 212;
-  /** JVM internal opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/first_edition/html/Quick.doc.html#10673">Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)</a>
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ChangesAppendix.doc.html#448885">Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.</a> */
-  public static final short PUTSTATIC2_QUICK          = 213;
-  /** JVM internal opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/first_edition/html/Quick.doc.html#10673">Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)</a>
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ChangesAppendix.doc.html#448885">Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.</a> */
-  public static final short INVOKEVIRTUAL_QUICK       = 214;
-  /** JVM internal opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/first_edition/html/Quick.doc.html#10673">Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)</a>
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ChangesAppendix.doc.html#448885">Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.</a> */
-  public static final short INVOKENONVIRTUAL_QUICK    = 215;
-  /** JVM internal opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/first_edition/html/Quick.doc.html#10673">Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)</a>
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ChangesAppendix.doc.html#448885">Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.</a> */
-  public static final short INVOKESUPER_QUICK         = 216;
-  /** JVM internal opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/first_edition/html/Quick.doc.html#10673">Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)</a>
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ChangesAppendix.doc.html#448885">Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.</a> */
-  public static final short INVOKESTATIC_QUICK        = 217;
-  /** JVM internal opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/first_edition/html/Quick.doc.html#10673">Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)</a>
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ChangesAppendix.doc.html#448885">Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.</a> */
-  public static final short INVOKEINTERFACE_QUICK     = 218;
-  /** JVM internal opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/first_edition/html/Quick.doc.html#10673">Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)</a>
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ChangesAppendix.doc.html#448885">Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.</a> */
-  public static final short INVOKEVIRTUALOBJECT_QUICK = 219;
-  /** JVM internal opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/first_edition/html/Quick.doc.html#10673">Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)</a>
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ChangesAppendix.doc.html#448885">Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.</a> */
-  public static final short NEW_QUICK                 = 221;
-  /** JVM internal opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/first_edition/html/Quick.doc.html#10673">Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)</a>
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ChangesAppendix.doc.html#448885">Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.</a> */
-  public static final short ANEWARRAY_QUICK           = 222;
-  /** JVM internal opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/first_edition/html/Quick.doc.html#10673">Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)</a>
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ChangesAppendix.doc.html#448885">Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.</a> */
-  public static final short MULTIANEWARRAY_QUICK      = 223;
-  /** JVM internal opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/first_edition/html/Quick.doc.html#10673">Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)</a>
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ChangesAppendix.doc.html#448885">Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.</a> */
-  public static final short CHECKCAST_QUICK           = 224;
-  /** JVM internal opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/first_edition/html/Quick.doc.html#10673">Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)</a>
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ChangesAppendix.doc.html#448885">Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.</a> */
-  public static final short INSTANCEOF_QUICK          = 225;
-  /** JVM internal opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/first_edition/html/Quick.doc.html#10673">Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)</a>
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ChangesAppendix.doc.html#448885">Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.</a> */
-  public static final short INVOKEVIRTUAL_QUICK_W     = 226;
-  /** JVM internal opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/first_edition/html/Quick.doc.html#10673">Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)</a>
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ChangesAppendix.doc.html#448885">Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.</a> */
-  public static final short GETFIELD_QUICK_W          = 227;
-  /** JVM internal opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/first_edition/html/Quick.doc.html#10673">Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)</a>
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ChangesAppendix.doc.html#448885">Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.</a> */
-  public static final short PUTFIELD_QUICK_W          = 228;
+  
+  
+  
+  
+  
+  
+  
+  
+  
+  
+  
+  
+  
+  
+  
+  
+  
+  
+  
+  
+  
+  
+  
+  
+  
   /** JVM internal opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions.doc.html#60105">Reserved opcodes in the Java Virtual Machine Specification</a> */
   public static final short IMPDEP1                   = 254;
@@ -1010,16 +767,8 @@ public interface Constants {
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions.doc.html#60105">Reserved opcodes in the Java Virtual Machine Specification</a> */
   public static final short IMPDEP2                   = 255;
 
-  /**
-   * BCEL virtual instruction for pushing an arbitrary data type onto the stack.  Will be converted to the appropriate JVM
-   * opcode when the class is dumped.
-   */
-  public static final short PUSH             = 4711;
-  /**
-   * BCEL virtual instruction for either LOOKUPSWITCH or TABLESWITCH.  Will be converted to the appropriate JVM
-   * opcode when the class is dumped.
-   */
-  public static final short SWITCH           = 4712;
+  
+  
 
   /** Illegal opcode. */
   public static final short  UNDEFINED      = -1;
@@ -1071,16 +820,7 @@ public interface Constants {
     "void", "array", "object", "unknown", "address"
   };
 
-  /** The primitive class names corresponding to the T_XX constants,
-   * e.g., CLASS_TYPE_NAMES[T_INT] = "java.lang.Integer"
-   */
-  public static final String[] CLASS_TYPE_NAMES = {
-    ILLEGAL_TYPE, ILLEGAL_TYPE,  ILLEGAL_TYPE, ILLEGAL_TYPE,
-    "java.lang.Boolean", "java.lang.Character", "java.lang.Float",
-    "java.lang.Double", "java.lang.Byte", "java.lang.Short",
-    "java.lang.Integer", "java.lang.Long", "java.lang.Void",
-    ILLEGAL_TYPE, ILLEGAL_TYPE,  ILLEGAL_TYPE,  ILLEGAL_TYPE
-  };
+  
 
   /** The signature characters corresponding to primitive types,
    * e.g., SHORT_TYPE_NAMES[T_INT] = "I"
@@ -1430,12 +1170,12 @@ public interface Constants {
   /** Constants used in the StackMap attribute.
    */
   public static final byte ITEM_Bogus      = 0;
-  public static final byte ITEM_Integer    = 1;
-  public static final byte ITEM_Float      = 2;
-  public static final byte ITEM_Double     = 3;
-  public static final byte ITEM_Long       = 4;
-  public static final byte ITEM_Null       = 5;
-  public static final byte ITEM_InitObject = 6;
+  
+  
+  
+  
+  
+  
   public static final byte ITEM_Object     = 7;
   public static final byte ITEM_NewObject  = 8;
 

==================================================
Repository.java
deleted file mode 100644
index c39955083a..0000000000
--- a/java/org/apache/tomcat/util/bcel/ExceptionConstants.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel;
-
-/**
- * Exception constants.
- *
- * @version $Id$
- * @author  E. Haase
- */
-public interface ExceptionConstants {
-
-    /** The mother of all exceptions
-     */
-    public static final Class THROWABLE = Throwable.class;
-    /** Super class of any run-time exception
-     */
-    public static final Class RUNTIME_EXCEPTION = RuntimeException.class;
-    /** Super class of any linking exception (aka Linkage Error)
-     */
-    public static final Class LINKING_EXCEPTION = LinkageError.class;
-    /** Linking Exceptions
-     */
-    public static final Class CLASS_CIRCULARITY_ERROR = ClassCircularityError.class;
-    public static final Class CLASS_FORMAT_ERROR = ClassFormatError.class;
-    public static final Class EXCEPTION_IN_INITIALIZER_ERROR = ExceptionInInitializerError.class;
-    public static final Class INCOMPATIBLE_CLASS_CHANGE_ERROR = IncompatibleClassChangeError.class;
-    public static final Class ABSTRACT_METHOD_ERROR = AbstractMethodError.class;
-    public static final Class ILLEGAL_ACCESS_ERROR = IllegalAccessError.class;
-    public static final Class INSTANTIATION_ERROR = InstantiationError.class;
-    public static final Class NO_SUCH_FIELD_ERROR = NoSuchFieldError.class;
-    public static final Class NO_SUCH_METHOD_ERROR = NoSuchMethodError.class;
-    public static final Class NO_CLASS_DEF_FOUND_ERROR = NoClassDefFoundError.class;
-    public static final Class UNSATISFIED_LINK_ERROR = UnsatisfiedLinkError.class;
-    public static final Class VERIFY_ERROR = VerifyError.class;
-    /* UnsupportedClassVersionError is new in JDK 1.2 */
-    //public static final Class UnsupportedClassVersionError = UnsupportedClassVersionError.class;
-    /** Run-Time Exceptions 
-     */
-    public static final Class NULL_POINTER_EXCEPTION = NullPointerException.class;
-    public static final Class ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION = ArrayIndexOutOfBoundsException.class;
-    public static final Class ARITHMETIC_EXCEPTION = ArithmeticException.class;
-    public static final Class NEGATIVE_ARRAY_SIZE_EXCEPTION = NegativeArraySizeException.class;
-    public static final Class CLASS_CAST_EXCEPTION = ClassCastException.class;
-    public static final Class ILLEGAL_MONITOR_STATE = IllegalMonitorStateException.class;
-    /** Pre-defined exception arrays according to chapters 5.1-5.4 of the Java Virtual
-     * Machine Specification 
-     */
-    public static final Class[] EXCS_CLASS_AND_INTERFACE_RESOLUTION = {
-            NO_CLASS_DEF_FOUND_ERROR, CLASS_FORMAT_ERROR, VERIFY_ERROR, ABSTRACT_METHOD_ERROR,
-            EXCEPTION_IN_INITIALIZER_ERROR, ILLEGAL_ACCESS_ERROR
-    }; // Chapter 5.1
-    public static final Class[] EXCS_FIELD_AND_METHOD_RESOLUTION = {
-            NO_SUCH_FIELD_ERROR, ILLEGAL_ACCESS_ERROR, NO_SUCH_METHOD_ERROR
-    }; // Chapter 5.2
-    public static final Class[] EXCS_INTERFACE_METHOD_RESOLUTION = new Class[0]; // Chapter 5.3 (as below)
-    public static final Class[] EXCS_STRING_RESOLUTION = new Class[0];
-    // Chapter 5.4 (no errors but the ones that _always_ could happen! How stupid.)
-    public static final Class[] EXCS_ARRAY_EXCEPTION = {
-            NULL_POINTER_EXCEPTION, ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION
-    };
-}

==================================================
AccessFlags.java
index 6719a36b17..ce809c256d 100644
--- a/java/org/apache/tomcat/util/bcel/Repository.java
+++ b/java/org/apache/tomcat/util/bcel/Repository.java
@@ -16,9 +16,7 @@
  */
 package org.apache.tomcat.util.bcel;
 
-import java.io.IOException;
 import org.apache.tomcat.util.bcel.classfile.JavaClass;
-import org.apache.tomcat.util.bcel.util.ClassPath;
 import org.apache.tomcat.util.bcel.util.SyntheticRepository;
 
 /**
@@ -37,18 +35,10 @@ public abstract class Repository {
     private static org.apache.tomcat.util.bcel.util.Repository _repository = SyntheticRepository.getInstance();
 
 
-    /** @return currently used repository instance
-     */
-    public static org.apache.tomcat.util.bcel.util.Repository getRepository() {
-        return _repository;
-    }
+    
 
 
-    /** Set repository instance to be used for class loading
-     */
-    public static void setRepository( org.apache.tomcat.util.bcel.util.Repository rep ) {
-        _repository = rep;
-    }
+    
 
 
     /** Lookup class somewhere found on your CLASSPATH, or whereever the
@@ -63,114 +53,34 @@ public abstract class Repository {
     }
 
 
-    /**
-     * Try to find class source using the internal repository instance.
-     * @see Class
-     * @return JavaClass object for given runtime class
-     * @throws ClassNotFoundException if the class could not be found or
-     * parsed correctly
-     */
-    public static JavaClass lookupClass( Class clazz ) throws ClassNotFoundException {
-        return _repository.loadClass(clazz);
-    }
+    
 
 
-    /**
-     * @return class file object for given Java class by looking on the
-     *  system class path; returns null if the class file can't be
-     *  found
-     */
-    public static ClassPath.ClassFile lookupClassFile( String class_name ) {
-        try {
-            ClassPath path = _repository.getClassPath();
-            if (path == null) {
-                return null;
-            }
-            return path.getClassFile(class_name);
-        } catch (IOException e) {
-            return null;
-        }
-    }
+    
 
 
-    /** Clear the repository.
-     */
-    public static void clearCache() {
-        _repository.clear();
-    }
+    
 
 
-    /**
-     * Add clazz to repository if there isn't an equally named class already in there.
-     *
-     * @return old entry in repository
-     */
-    public static JavaClass addClass( JavaClass clazz ) {
-        JavaClass old = _repository.findClass(clazz.getClassName());
-        _repository.storeClass(clazz);
-        return old;
-    }
+    
 
 
-    /**
-     * Remove class with given (fully qualified) name from repository.
-     */
-    public static void removeClass( String clazz ) {
-        _repository.removeClass(_repository.findClass(clazz));
-    }
+    
 
 
-    /**
-     * Remove given class from repository.
-     */
-    public static void removeClass( JavaClass clazz ) {
-        _repository.removeClass(clazz);
-    }
+    
 
 
-    /**
-     * @return list of super classes of clazz in ascending order, i.e.,
-     * Object is always the last element
-     * @throws ClassNotFoundException if any of the superclasses can't be found
-     */
-    public static JavaClass[] getSuperClasses( JavaClass clazz ) throws ClassNotFoundException {
-        return clazz.getSuperClasses();
-    }
+    
 
 
-    /**
-     * @return list of super classes of clazz in ascending order, i.e.,
-     * Object is always the last element.
-     * @throws ClassNotFoundException if the named class or any of its
-     *  superclasses can't be found
-     */
-    public static JavaClass[] getSuperClasses( String class_name ) throws ClassNotFoundException {
-        JavaClass jc = lookupClass(class_name);
-        return getSuperClasses(jc);
-    }
+    
 
 
-    /**
-     * @return all interfaces implemented by class and its super
-     * classes and the interfaces that those interfaces extend, and so on.
-     * (Some people call this a transitive hull).
-     * @throws ClassNotFoundException if any of the class's
-     *  superclasses or superinterfaces can't be found
-     */
-    public static JavaClass[] getInterfaces( JavaClass clazz ) throws ClassNotFoundException {
-        return clazz.getAllInterfaces();
-    }
+    
 
 
-    /**
-     * @return all interfaces implemented by class and its super
-     * classes and the interfaces that extend those interfaces, and so on
-     * @throws ClassNotFoundException if the named class can't be found,
-     *   or if any of its superclasses or superinterfaces can't be found
-     */
-    public static JavaClass[] getInterfaces( String class_name ) throws ClassNotFoundException {
-        return getInterfaces(lookupClass(class_name));
-    }
+    
 
 
     /**
@@ -185,35 +95,13 @@ public abstract class Repository {
     }
 
 
-    /**
-     * @return true, if clazz is an instance of super_class
-     * @throws ClassNotFoundException if either clazz or super_class
-     *   can't be found
-     */
-    public static boolean instanceOf( String clazz, String super_class )
-            throws ClassNotFoundException {
-        return instanceOf(lookupClass(clazz), lookupClass(super_class));
-    }
+    
 
 
-    /**
-     * @return true, if clazz is an instance of super_class
-     * @throws ClassNotFoundException if super_class can't be found
-     */
-    public static boolean instanceOf( JavaClass clazz, String super_class )
-            throws ClassNotFoundException {
-        return instanceOf(clazz, lookupClass(super_class));
-    }
+    
 
 
-    /**
-     * @return true, if clazz is an instance of super_class
-     * @throws ClassNotFoundException if clazz can't be found
-     */
-    public static boolean instanceOf( String clazz, JavaClass super_class )
-            throws ClassNotFoundException {
-        return instanceOf(lookupClass(clazz), super_class);
-    }
+    
 
 
     /**
@@ -227,35 +115,11 @@ public abstract class Repository {
     }
 
 
-    /**
-     * @return true, if clazz is an implementation of interface inter
-     * @throws ClassNotFoundException if clazz, inter, or any superclasses
-     *   or superinterfaces of clazz can't be found
-     */
-    public static boolean implementationOf( String clazz, String inter )
-            throws ClassNotFoundException {
-        return implementationOf(lookupClass(clazz), lookupClass(inter));
-    }
+    
 
 
-    /**
-     * @return true, if clazz is an implementation of interface inter
-     * @throws ClassNotFoundException if inter or any superclasses
-     *   or superinterfaces of clazz can't be found
-     */
-    public static boolean implementationOf( JavaClass clazz, String inter )
-            throws ClassNotFoundException {
-        return implementationOf(clazz, lookupClass(inter));
-    }
+    
 
 
-    /**
-     * @return true, if clazz is an implementation of interface inter
-     * @throws ClassNotFoundException if clazz or any superclasses or
-     *   superinterfaces of clazz can't be found
-     */
-    public static boolean implementationOf( String clazz, JavaClass inter )
-            throws ClassNotFoundException {
-        return implementationOf(lookupClass(clazz), inter);
-    }
+    
 }

==================================================
AnnotationDefault.java
index 694cafedbf..2370b5594b 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/AccessFlags.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/AccessFlags.java
@@ -34,152 +34,73 @@ public abstract class AccessFlags implements java.io.Serializable {
     }
 
 
-    /**
-     * @param a inital access flags
-     */
-    public AccessFlags(int a) {
-        access_flags = a;
-    }
+    
 
 
-    /** 
-     * @return Access flags of the object aka. "modifiers".
-     */
-    public final int getAccessFlags() {
-        return access_flags;
-    }
+    
 
 
-    /** 
-     * @return Access flags of the object aka. "modifiers".
-     */
-    public final int getModifiers() {
-        return access_flags;
-    }
+    
 
 
-    /** Set access flags aka "modifiers".
-     * @param access_flags Access flags of the object. 
-     */
-    public final void setAccessFlags( int access_flags ) {
-        this.access_flags = access_flags;
-    }
+    
 
 
-    /** Set access flags aka "modifiers".
-     * @param access_flags Access flags of the object. 
-     */
-    public final void setModifiers( int access_flags ) {
-        setAccessFlags(access_flags);
-    }
+    
 
 
-    private final void setFlag( int flag, boolean set ) {
-        if ((access_flags & flag) != 0) { // Flag is set already
-            if (!set) {
-                access_flags ^= flag;
-            }
-        } else { // Flag not set
-            if (set) {
-                access_flags |= flag;
-            }
-        }
-    }
+    
 
 
-    public final void isPublic( boolean flag ) {
-        setFlag(Constants.ACC_PUBLIC, flag);
-    }
+    
 
 
-    public final boolean isPublic() {
-        return (access_flags & Constants.ACC_PUBLIC) != 0;
-    }
+    
 
 
-    public final void isPrivate( boolean flag ) {
-        setFlag(Constants.ACC_PRIVATE, flag);
-    }
+    
 
 
-    public final boolean isPrivate() {
-        return (access_flags & Constants.ACC_PRIVATE) != 0;
-    }
+    
 
 
-    public final void isProtected( boolean flag ) {
-        setFlag(Constants.ACC_PROTECTED, flag);
-    }
+    
 
 
-    public final boolean isProtected() {
-        return (access_flags & Constants.ACC_PROTECTED) != 0;
-    }
+    
 
 
-    public final void isStatic( boolean flag ) {
-        setFlag(Constants.ACC_STATIC, flag);
-    }
+    
 
 
-    public final boolean isStatic() {
-        return (access_flags & Constants.ACC_STATIC) != 0;
-    }
+    
 
 
-    public final void isFinal( boolean flag ) {
-        setFlag(Constants.ACC_FINAL, flag);
-    }
+    
 
 
-    public final boolean isFinal() {
-        return (access_flags & Constants.ACC_FINAL) != 0;
-    }
+    
 
 
-    public final void isSynchronized( boolean flag ) {
-        setFlag(Constants.ACC_SYNCHRONIZED, flag);
-    }
+    
 
 
-    public final boolean isSynchronized() {
-        return (access_flags & Constants.ACC_SYNCHRONIZED) != 0;
-    }
+    
 
 
-    public final void isVolatile( boolean flag ) {
-        setFlag(Constants.ACC_VOLATILE, flag);
-    }
+    
 
 
-    public final boolean isVolatile() {
-        return (access_flags & Constants.ACC_VOLATILE) != 0;
-    }
+    
 
 
-    public final void isTransient( boolean flag ) {
-        setFlag(Constants.ACC_TRANSIENT, flag);
-    }
-
-
-    public final boolean isTransient() {
-        return (access_flags & Constants.ACC_TRANSIENT) != 0;
-    }
-
+    
 
-    public final void isNative( boolean flag ) {
-        setFlag(Constants.ACC_NATIVE, flag);
-    }
 
+    
 
-    public final boolean isNative() {
-        return (access_flags & Constants.ACC_NATIVE) != 0;
-    }
 
-
-    public final void isInterface( boolean flag ) {
-        setFlag(Constants.ACC_INTERFACE, flag);
-    }
+    
 
 
     public final boolean isInterface() {
@@ -187,52 +108,32 @@ public abstract class AccessFlags implements java.io.Serializable {
     }
 
 
-    public final void isAbstract( boolean flag ) {
-        setFlag(Constants.ACC_ABSTRACT, flag);
-    }
+    
 
 
-    public final boolean isAbstract() {
-        return (access_flags & Constants.ACC_ABSTRACT) != 0;
-    }
+    
 
 
-    public final void isStrictfp( boolean flag ) {
-        setFlag(Constants.ACC_STRICT, flag);
-    }
+    
 
 
-    public final boolean isStrictfp() {
-        return (access_flags & Constants.ACC_STRICT) != 0;
-    }
+    
 
 
-    public final void isSynthetic( boolean flag ) {
-        setFlag(Constants.ACC_SYNTHETIC, flag);
-    }
+    
 
 
-    public final boolean isSynthetic() {
-        return (access_flags & Constants.ACC_SYNTHETIC) != 0;
-    }
+    
 
 
-    public final void isAnnotation( boolean flag ) {
-        setFlag(Constants.ACC_ANNOTATION, flag);
-    }
+    
 
 
-    public final boolean isAnnotation() {
-        return (access_flags & Constants.ACC_ANNOTATION) != 0;
-    }
+    
 
 
-    public final void isEnum( boolean flag ) {
-        setFlag(Constants.ACC_ENUM, flag);
-    }
+    
 
 
-    public final boolean isEnum() {
-        return (access_flags & Constants.ACC_ENUM) != 0;
-    }
+    
 }

==================================================
AnnotationEntry.java
index b70b78734a..2020e18ae8 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/AnnotationDefault.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/AnnotationDefault.java
@@ -94,13 +94,7 @@ public class AnnotationDefault extends Attribute
 		default_value = defaultValue;
 	}
 
-	/**
-	 * @return the default value
-	 */
-	public final ElementValue getDefaultValue()
-	{
-		return default_value;
-	}
+	
 
 	public Attribute copy(ConstantPool _constant_pool)
 	{

==================================================
Annotations.java
index 81bd934fdb..870526bf9b 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/AnnotationEntry.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/AnnotationEntry.java
@@ -64,16 +64,7 @@ public class AnnotationEntry implements Node, Constants, Serializable {
     }
 
 
-    /**
-     * Called by objects that are traversing the nodes of the tree implicitely
-     * defined by the contents of a Java class. I.e., the hierarchy of methods,
-     * fields, attributes, etc. spawns a tree of objects.
-     *
-     * @param v Visitor object
-     */
-    public void accept( Visitor v ) {
-        //	    v.visitAnnotationEntry(this);
-    }
+    
 
 
     /**
@@ -94,12 +85,7 @@ public class AnnotationEntry implements Node, Constants, Serializable {
     }
 
 
-    /**
-     * @return the number of element value pairs in this annotation entry
-     */
-    public final int getNumElementValuePairs() {
-        return num_element_value_pairs;
-    }
+    
 
 
     /**
@@ -132,21 +118,5 @@ public class AnnotationEntry implements Node, Constants, Serializable {
 		element_value_pairs.add(elementNameValuePair);
 	}
 
-	public String toShortString()
-	{
-		StringBuffer result = new StringBuffer();
-		result.append("@");
-		result.append(getAnnotationType());
-		if (getElementValuePairs().length > 0)
-		{
-			result.append("(");
-			for (int i = 0; i < getElementValuePairs().length; i++)
-			{
-				ElementValuePair element = getElementValuePairs()[i];
-				result.append(element.toShortString());
-			}
-			result.append(")");
-		}
-		return result.toString();
-	}
+	
 }

==================================================
ArrayElementValue.java
index 214ebef6df..cf3609a123 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/Annotations.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/Annotations.java
@@ -106,17 +106,9 @@ public abstract class Annotations extends Attribute {
     }
 
 
-    /**
-     * @return the number of annotation entries in this annotation
-     */
-    public final int getNumAnnotations() {
-        return annotation_table_length;
-    }
     
-    public boolean isRuntimeVisible()
-    {
-    	return isRuntimeVisible;
-    }
+    
+    
     
     protected void writeAnnotations(DataOutputStream dos) throws IOException
 	{

==================================================
Attribute.java
index 5a3e5dbaa1..961fb0ffcb 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ArrayElementValue.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ArrayElementValue.java
@@ -60,8 +60,5 @@ public class ArrayElementValue extends ElementValue
 		return evalues;
 	}
 
-	public int getElementValuesArraySize()
-	{
-		return evalues.length;
-	}
+	
 }

==================================================
ClassParser.java
index cb01223c34..85523ace05 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/Attribute.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/Attribute.java
@@ -91,31 +91,9 @@ public abstract class Attribute implements Cloneable, Node, Serializable
 
 	private static Map readers = new HashMap();
 
-	/**
-	 * Add an Attribute reader capable of parsing (user-defined) attributes
-	 * named "name". You should not add readers for the standard attributes such
-	 * as "LineNumberTable", because those are handled internally.
-	 * 
-	 * @param name
-	 *            the name of the attribute as stored in the class file
-	 * @param r
-	 *            the reader object
-	 */
-	public static void addAttributeReader(String name, AttributeReader r)
-	{
-		readers.put(name, r);
-	}
+	
 
-	/**
-	 * Remove attribute reader
-	 * 
-	 * @param name
-	 *            the name of the attribute as stored in the class file
-	 */
-	public static void removeAttributeReader(String name)
-	{
-		readers.remove(name);
-	}
+	
 
 	/*
 	 * Class method reads one attribute from the input data stream. This method
@@ -226,39 +204,13 @@ public abstract class Attribute implements Cloneable, Node, Serializable
 		return c.getBytes();
 	}
 
-	/**
-	 * @return Length of attribute field in bytes.
-	 */
-	public final int getLength()
-	{
-		return length;
-	}
+	
 
-	/**
-	 * @param length
-	 *            length in bytes.
-	 */
-	public final void setLength(int length)
-	{
-		this.length = length;
-	}
+	
 
-	/**
-	 * @param name_index
-	 *            of attribute.
-	 */
-	public final void setNameIndex(int name_index)
-	{
-		this.name_index = name_index;
-	}
+	
 
-	/**
-	 * @return Name index in constant pool of attribute name.
-	 */
-	public final int getNameIndex()
-	{
-		return name_index;
-	}
+	
 
 	/**
 	 * @return Tag of attribute, i.e., its type. Value may not be altered, thus
@@ -269,24 +221,9 @@ public abstract class Attribute implements Cloneable, Node, Serializable
 		return tag;
 	}
 
-	/**
-	 * @return Constant pool used by this object.
-	 * @see ConstantPool
-	 */
-	public final ConstantPool getConstantPool()
-	{
-		return constant_pool;
-	}
+	
 
-	/**
-	 * @param constant_pool
-	 *            Constant pool to be used for this object.
-	 * @see ConstantPool
-	 */
-	public final void setConstantPool(ConstantPool constant_pool)
-	{
-		this.constant_pool = constant_pool;
-	}
+	
 
 	/**
 	 * Use copy() if you want to have a deep copy(), i.e., with all references

==================================================
Code.java
index e24eea4824..0e6d0f9ee6 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ClassParser.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ClassParser.java
@@ -78,28 +78,10 @@ public final class ClassParser {
     }
 
 
-    /** Parse class from given .class file.
-     *
-     * @param file_name file name
-     */
-    public ClassParser(String file_name) {
-        is_zip = false;
-        this.file_name = file_name;
-        fileOwned = true;
-    }
+    
 
 
-    /** Parse class from given .class file in a ZIP-archive
-     *
-     * @param zip_file zip file name
-     * @param file_name file name
-     */
-    public ClassParser(String zip_file, String file_name) {
-        is_zip = true;
-        fileOwned = true;
-        this.zip_file = zip_file;
-        this.file_name = file_name;
-    }
+    
 
 
     /**

==================================================
CodeException.java
index af6f182b8e..d05babcc67 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/Code.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/Code.java
@@ -52,14 +52,7 @@ public final class Code extends Attribute {
     private Attribute[] attributes; // or LocalVariable
 
 
-    /**
-     * Initialize from another object. Note that both objects use the same
-     * references (shallow copy). Use copy() for a physical copy.
-     */
-    public Code(Code c) {
-        this(c.getNameIndex(), c.getLength(), c.getMaxStack(), c.getMaxLocals(), c.getCode(), c
-                .getExceptionTable(), c.getAttributes(), c.getConstantPool());
-    }
+    
 
 
     /**
@@ -156,26 +149,10 @@ public final class Code extends Attribute {
     }
 
 
-    /**
-     * @return Collection of code attributes.
-     * @see Attribute
-     */
-    public final Attribute[] getAttributes() {
-        return attributes;
-    }
+    
 
 
-    /**
-     * @return LineNumberTable of Code, if it has one
-     */
-    public LineNumberTable getLineNumberTable() {
-        for (int i = 0; i < attributes_count; i++) {
-            if (attributes[i] instanceof LineNumberTable) {
-                return (LineNumberTable) attributes[i];
-            }
-        }
-        return null;
-    }
+    
 
 
     /**
@@ -191,37 +168,16 @@ public final class Code extends Attribute {
     }
 
 
-    /**
-     * @return Actual byte code of the method.
-     */
-    public final byte[] getCode() {
-        return code;
-    }
+    
 
 
-    /**
-     * @return Table of handled exceptions.
-     * @see CodeException
-     */
-    public final CodeException[] getExceptionTable() {
-        return exception_table;
-    }
+    
 
 
-    /**
-     * @return Number of local variables.
-     */
-    public final int getMaxLocals() {
-        return max_locals;
-    }
+    
 
 
-    /**
-     * @return Maximum size of stack used by this method.
-     */
-    public final int getMaxStack() {
-        return max_stack;
-    }
+    
 
 
     /**
@@ -278,20 +234,10 @@ public final class Code extends Attribute {
     }
 
 
-    /**
-     * @param max_locals maximum number of local variables
-     */
-    public final void setMaxLocals( int max_locals ) {
-        this.max_locals = max_locals;
-    }
+    
 
 
-    /**
-     * @param max_stack maximum stack size
-     */
-    public final void setMaxStack( int max_stack ) {
-        this.max_stack = max_stack;
-    }
+    
 
 
     /**

==================================================
Constant.java
index 816f9f66b2..9d072859df 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/CodeException.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/CodeException.java
@@ -45,12 +45,7 @@ public final class CodeException implements Cloneable, Constants, Node, Serializ
      */
 
 
-    /**
-     * Initialize from another object.
-     */
-    public CodeException(CodeException c) {
-        this(c.getStartPC(), c.getEndPC(), c.getHandlerPC(), c.getCatchType());
-    }
+    
 
 
     /**
@@ -82,16 +77,7 @@ public final class CodeException implements Cloneable, Constants, Node, Serializ
     }
 
 
-    /**
-     * Called by objects that are traversing the nodes of the tree implicitely
-     * defined by the contents of a Java class. I.e., the hierarchy of methods,
-     * fields, attributes, etc. spawns a tree of objects.
-     *
-     * @param v Visitor object
-     */
-    public void accept( Visitor v ) {
-        v.visitCodeException(this);
-    }
+    
 
 
     /**
@@ -108,69 +94,28 @@ public final class CodeException implements Cloneable, Constants, Node, Serializ
     }
 
 
-    /**
-     * @return 0, if the handler catches any exception, otherwise it points to
-     * the exception class which is to be caught.
-     */
-    public final int getCatchType() {
-        return catch_type;
-    }
+    
 
 
-    /**
-     * @return Exclusive end index of the region where the handler is active.
-     */
-    public final int getEndPC() {
-        return end_pc;
-    }
+    
 
 
-    /**
-     * @return Starting address of exception handler, relative to the code.
-     */
-    public final int getHandlerPC() {
-        return handler_pc;
-    }
+    
 
 
-    /**
-     * @return Inclusive start index of the region where the handler is active.
-     */
-    public final int getStartPC() {
-        return start_pc;
-    }
+    
 
 
-    /**
-     * @param catch_type the type of exception that is caught
-     */
-    public final void setCatchType( int catch_type ) {
-        this.catch_type = catch_type;
-    }
+    
 
 
-    /**
-     * @param end_pc end of handled block
-     */
-    public final void setEndPC( int end_pc ) {
-        this.end_pc = end_pc;
-    }
+    
 
 
-    /**
-     * @param handler_pc where the actual code is
-     */
-    public final void setHandlerPC( int handler_pc ) {
-        this.handler_pc = handler_pc;
-    }
+    
 
 
-    /**
-     * @param start_pc start of handled block
-     */
-    public final void setStartPC( int start_pc ) {
-        this.start_pc = start_pc;
-    }
+    
 
 
     /**
@@ -197,9 +142,7 @@ public final class CodeException implements Cloneable, Constants, Node, Serializ
     }
 
 
-    public final String toString( ConstantPool cp ) {
-        return toString(cp, true);
-    }
+    
 
 
     /**

==================================================
ConstantCP.java
index 8cbedaab44..81d9b75aac 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/Constant.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/Constant.java
@@ -93,16 +93,7 @@ public abstract class Constant implements Cloneable, Node, Serializable {
     }
 
 
-    /**
-     * @return deep copy of this constant
-     */
-    public Constant copy() {
-        try {
-            return (Constant) super.clone();
-        } catch (CloneNotSupportedException e) {
-        }
-        return null;
-    }
+    
 
 
     public Object clone() throws CloneNotSupportedException {
@@ -148,20 +139,10 @@ public abstract class Constant implements Cloneable, Node, Serializable {
     }
 
 
-    /**
-     * @return Comparison strategy object
-     */
-    public static BCELComparator getComparator() {
-        return _cmp;
-    }
+    
 
 
-    /**
-     * @param comparator Comparison strategy object
-     */
-    public static void setComparator( BCELComparator comparator ) {
-        _cmp = comparator;
-    }
+    
 
 
     /**

==================================================
ConstantClass.java
index 907ed71b27..bdc3c4ce0e 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ConstantCP.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ConstantCP.java
@@ -20,8 +20,6 @@ import java.io.DataInput;
 import java.io.DataOutputStream;
 import java.io.IOException;
 
-import org.apache.tomcat.util.bcel.Constants;
-
 /** 
  * Abstract super class for Fieldref and Methodref constants.
  *
@@ -38,12 +36,7 @@ public abstract class ConstantCP extends Constant {
     protected int class_index, name_and_type_index;
 
 
-    /**
-     * Initialize from another object.
-     */
-    public ConstantCP(ConstantCP c) {
-        this(c.getTag(), c.getClassIndex(), c.getNameAndTypeIndex());
-    }
+    
 
 
     /**
@@ -98,28 +91,13 @@ public abstract class ConstantCP extends Constant {
     }
 
 
-    /**
-     * @param class_index points to Constant_class 
-     */
-    public final void setClassIndex( int class_index ) {
-        this.class_index = class_index;
-    }
+    
 
 
-    /**
-     * @return Class this field belongs to.
-     */
-    public String getClass( ConstantPool cp ) {
-        return cp.constantToString(class_index, Constants.CONSTANT_Class);
-    }
+    
 
 
-    /**
-     * @param name_and_type_index points to Constant_NameAndType
-     */
-    public final void setNameAndTypeIndex( int name_and_type_index ) {
-        this.name_and_type_index = name_and_type_index;
-    }
+    
 
 
     /**

==================================================
ConstantDouble.java
index 45bd8a6f50..94d945a68e 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ConstantClass.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ConstantClass.java
@@ -36,12 +36,7 @@ public final class ConstantClass extends Constant implements ConstantObject {
     private int name_index; // Identical to ConstantString except for the name
 
 
-    /**
-     * Initialize from another object.
-     */
-    public ConstantClass(ConstantClass c) {
-        this(c.getNameIndex());
-    }
+    
 
 
     /**
@@ -97,27 +92,13 @@ public final class ConstantClass extends Constant implements ConstantObject {
     }
 
 
-    /**
-     * @param name_index the name index in the constant pool of this Constant Class
-     */
-    public final void setNameIndex( int name_index ) {
-        this.name_index = name_index;
-    }
+    
 
 
-    /** @return String object
-     */
-    public Object getConstantValue( ConstantPool cp ) {
-        Constant c = cp.getConstant(name_index, Constants.CONSTANT_Utf8);
-        return ((ConstantUtf8) c).getBytes();
-    }
+    
 
 
-    /** @return dereferenced string
-     */
-    public String getBytes( ConstantPool cp ) {
-        return (String) getConstantValue(cp);
-    }
+    
 
 
     /**

==================================================
ConstantFieldref.java
index d0b0e9c84a..7a8b86b2dc 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ConstantDouble.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ConstantDouble.java
@@ -45,12 +45,7 @@ public final class ConstantDouble extends Constant implements ConstantObject {
     }
 
 
-    /**
-     * Initialize from another object.
-     */
-    public ConstantDouble(ConstantDouble c) {
-        this(c.getBytes());
-    }
+    
 
 
     /** 
@@ -96,12 +91,7 @@ public final class ConstantDouble extends Constant implements ConstantObject {
     }
 
 
-    /**
-     * @param bytes the raw bytes that represent the double value
-     */
-    public final void setBytes( double bytes ) {
-        this.bytes = bytes;
-    }
+    
 
 
     /**
@@ -112,9 +102,5 @@ public final class ConstantDouble extends Constant implements ConstantObject {
     }
 
 
-    /** @return Double object
-     */
-    public Object getConstantValue( ConstantPool cp ) {
-        return new Double(bytes);
-    }
+    
 }

==================================================
ConstantFloat.java
index b294ced434..14807e0f4a 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ConstantFieldref.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ConstantFieldref.java
@@ -28,12 +28,7 @@ import org.apache.tomcat.util.bcel.Constants;
  */
 public final class ConstantFieldref extends ConstantCP {
 
-    /**
-     * Initialize from another object.
-     */
-    public ConstantFieldref(ConstantFieldref c) {
-        super(Constants.CONSTANT_Fieldref, c.getClassIndex(), c.getNameAndTypeIndex());
-    }
+    
 
 
     /**

==================================================
ConstantInteger.java
index 8551914d4e..53b8cf4019 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ConstantFloat.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ConstantFloat.java
@@ -45,13 +45,7 @@ public final class ConstantFloat extends Constant implements ConstantObject {
     }
 
 
-    /**
-     * Initialize from another object. Note that both objects use the same
-     * references (shallow copy). Use clone() for a physical copy.
-     */
-    public ConstantFloat(ConstantFloat c) {
-        this(c.getBytes());
-    }
+    
 
 
     /** 
@@ -97,12 +91,7 @@ public final class ConstantFloat extends Constant implements ConstantObject {
     }
 
 
-    /**
-     * @param bytes the raw bytes that represent this float
-     */
-    public final void setBytes( float bytes ) {
-        this.bytes = bytes;
-    }
+    
 
 
     /**
@@ -113,9 +102,5 @@ public final class ConstantFloat extends Constant implements ConstantObject {
     }
 
 
-    /** @return Float object
-     */
-    public Object getConstantValue( ConstantPool cp ) {
-        return new Float(bytes);
-    }
+    
 }

==================================================
ConstantInterfaceMethodref.java
index d862c04426..30bf1aa274 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ConstantInteger.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ConstantInteger.java
@@ -45,12 +45,7 @@ public final class ConstantInteger extends Constant implements ConstantObject {
     }
 
 
-    /**
-     * Initialize from another object.
-     */
-    public ConstantInteger(ConstantInteger c) {
-        this(c.getBytes());
-    }
+    
 
 
     /** 
@@ -96,12 +91,7 @@ public final class ConstantInteger extends Constant implements ConstantObject {
     }
 
 
-    /**
-     * @param bytes the raw bytes that represent this integer
-     */
-    public final void setBytes( int bytes ) {
-        this.bytes = bytes;
-    }
+    
 
 
     /**
@@ -112,9 +102,5 @@ public final class ConstantInteger extends Constant implements ConstantObject {
     }
 
 
-    /** @return Integer object
-     */
-    public Object getConstantValue( ConstantPool cp ) {
-        return new Integer(bytes);
-    }
+    
 }

==================================================
ConstantLong.java
index 41da17b729..611b0194ba 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ConstantInterfaceMethodref.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ConstantInterfaceMethodref.java
@@ -28,12 +28,7 @@ import org.apache.tomcat.util.bcel.Constants;
  */
 public final class ConstantInterfaceMethodref extends ConstantCP {
 
-    /**
-     * Initialize from another object.
-     */
-    public ConstantInterfaceMethodref(ConstantInterfaceMethodref c) {
-        super(Constants.CONSTANT_InterfaceMethodref, c.getClassIndex(), c.getNameAndTypeIndex());
-    }
+    
 
 
     /**

==================================================
ConstantMethodref.java
index d8837e8f71..b648f32e45 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ConstantLong.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ConstantLong.java
@@ -45,12 +45,7 @@ public final class ConstantLong extends Constant implements ConstantObject {
     }
 
 
-    /**
-     * Initialize from another object.
-     */
-    public ConstantLong(ConstantLong c) {
-        this(c.getBytes());
-    }
+    
 
 
     /** 
@@ -96,12 +91,7 @@ public final class ConstantLong extends Constant implements ConstantObject {
     }
 
 
-    /**
-     * @param bytes thr raw bytes that represent this long
-     */
-    public final void setBytes( long bytes ) {
-        this.bytes = bytes;
-    }
+    
 
 
     /**
@@ -112,9 +102,5 @@ public final class ConstantLong extends Constant implements ConstantObject {
     }
 
 
-    /** @return Long object
-     */
-    public Object getConstantValue( ConstantPool cp ) {
-        return new Long(bytes);
-    }
+    
 }

==================================================
ConstantNameAndType.java
index c40f0aa09c..a75ee00ce4 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ConstantMethodref.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ConstantMethodref.java
@@ -28,12 +28,7 @@ import org.apache.tomcat.util.bcel.Constants;
  */
 public final class ConstantMethodref extends ConstantCP {
 
-    /**
-     * Initialize from another object.
-     */
-    public ConstantMethodref(ConstantMethodref c) {
-        super(Constants.CONSTANT_Methodref, c.getClassIndex(), c.getNameAndTypeIndex());
-    }
+    
 
 
     /**

==================================================
ConstantObject.java
index 00e46c26c3..98b8e266f8 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ConstantNameAndType.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ConstantNameAndType.java
@@ -38,12 +38,7 @@ public final class ConstantNameAndType extends Constant {
     private int signature_index; // and its signature.
 
 
-    /**
-     * Initialize from another object.
-     */
-    public ConstantNameAndType(ConstantNameAndType c) {
-        this(c.getNameIndex(), c.getSignatureIndex());
-    }
+    
 
 
     /**
@@ -101,11 +96,7 @@ public final class ConstantNameAndType extends Constant {
     }
 
 
-    /** @return name
-     */
-    public final String getName( ConstantPool cp ) {
-        return cp.constantToString(getNameIndex(), Constants.CONSTANT_Utf8);
-    }
+    
 
 
     /**
@@ -116,27 +107,13 @@ public final class ConstantNameAndType extends Constant {
     }
 
 
-    /** @return signature
-     */
-    public final String getSignature( ConstantPool cp ) {
-        return cp.constantToString(getSignatureIndex(), Constants.CONSTANT_Utf8);
-    }
+    
 
 
-    /**
-     * @param name_index the name index of this constant
-     */
-    public final void setNameIndex( int name_index ) {
-        this.name_index = name_index;
-    }
+    
 
 
-    /**
-     * @param signature_index the signature index in the constant pool of this type
-     */
-    public final void setSignatureIndex( int signature_index ) {
-        this.signature_index = signature_index;
-    }
+    
 
 
     /**

==================================================
ConstantPool.java
index 3d343940f8..8a55909921 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ConstantObject.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ConstantObject.java
@@ -26,7 +26,5 @@ package org.apache.tomcat.util.bcel.classfile;
  */
 public interface ConstantObject {
 
-    /** @return object representing the constant, e.g., Long for ConstantLong
-     */
-    public abstract Object getConstantValue( ConstantPool cp );
+    
 }

==================================================
ConstantString.java
index 612d3457e8..6f008890cf 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ConstantPool.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ConstantPool.java
@@ -17,7 +17,6 @@
 package org.apache.tomcat.util.bcel.classfile;
 
 import java.io.DataInputStream;
-import java.io.DataOutputStream;
 import java.io.IOException;
 import java.io.Serializable;
 import org.apache.tomcat.util.bcel.Constants;
@@ -80,16 +79,7 @@ public class ConstantPool implements Cloneable, Node, Serializable {
     }
 
 
-    /**
-     * Called by objects that are traversing the nodes of the tree implicitely
-     * defined by the contents of a Java class. I.e., the hierarchy of methods,
-     * fields, attributes, etc. spawns a tree of objects.
-     *
-     * @param v Visitor object
-     */
-    public void accept( Visitor v ) {
-        v.visitConstantPool(this);
-    }
+    
 
 
     /**
@@ -191,20 +181,7 @@ public class ConstantPool implements Cloneable, Node, Serializable {
     }
 
 
-    /** 
-     * Dump constant pool to file stream in binary format.
-     *
-     * @param file Output file stream
-     * @throws IOException
-     */
-    public void dump( DataOutputStream file ) throws IOException {
-        file.writeShort(constant_pool_count);
-        for (int i = 1; i < constant_pool_count; i++) {
-            if (constant_pool[i] != null) {
-                constant_pool[i].dump(file);
-            }
-        }
-    }
+    
 
 
     /**
@@ -247,13 +224,7 @@ public class ConstantPool implements Cloneable, Node, Serializable {
     }
 
 
-    /**
-     * @return Array of constants.
-     * @see    Constant
-     */
-    public Constant[] getConstantPool() {
-        return constant_pool;
-    }
+    
 
 
     /**
@@ -304,12 +275,7 @@ public class ConstantPool implements Cloneable, Node, Serializable {
     }
 
 
-    /**
-     * @param constant Constant to set
-     */
-    public void setConstant( int index, Constant constant ) {
-        constant_pool[index] = constant;
-    }
+    
 
 
     /**
@@ -333,21 +299,5 @@ public class ConstantPool implements Cloneable, Node, Serializable {
     }
 
 
-    /**
-     * @return deep copy of this constant pool
-     */
-    public ConstantPool copy() {
-        ConstantPool c = null;
-        try {
-            c = (ConstantPool) clone();
-            c.constant_pool = new Constant[constant_pool_count];
-            for (int i = 1; i < constant_pool_count; i++) {
-                if (constant_pool[i] != null) {
-                    c.constant_pool[i] = constant_pool[i].copy();
-                }
-            }
-        } catch (CloneNotSupportedException e) {
-        }
-        return c;
-    }
+    
 }

==================================================
ConstantUtf8.java
index d063a10c9a..d1ca00e83b 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ConstantString.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ConstantString.java
@@ -36,12 +36,7 @@ public final class ConstantString extends Constant implements ConstantObject {
     private int string_index; // Identical to ConstantClass except for this name
 
 
-    /**
-     * Initialize from another object.
-     */
-    public ConstantString(ConstantString c) {
-        this(c.getStringIndex());
-    }
+    
 
 
     /** 
@@ -96,12 +91,7 @@ public final class ConstantString extends Constant implements ConstantObject {
     }
 
 
-    /**
-     * @param string_index the index into the constant of the string value
-     */
-    public final void setStringIndex( int string_index ) {
-        this.string_index = string_index;
-    }
+    
 
 
     /**
@@ -112,17 +102,8 @@ public final class ConstantString extends Constant implements ConstantObject {
     }
 
 
-    /** @return String object
-     */
-    public Object getConstantValue( ConstantPool cp ) {
-        Constant c = cp.getConstant(string_index, Constants.CONSTANT_Utf8);
-        return ((ConstantUtf8) c).getBytes();
-    }
+    
 
 
-    /** @return dereferenced string
-     */
-    public String getBytes( ConstantPool cp ) {
-        return (String) getConstantValue(cp);
-    }
+    
 }

==================================================
ConstantValue.java
index ea7b1050a0..6b81d29cc5 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ConstantUtf8.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ConstantUtf8.java
@@ -36,12 +36,7 @@ public final class ConstantUtf8 extends Constant {
     private String bytes;
 
 
-    /**
-     * Initialize from another object.
-     */
-    public ConstantUtf8(ConstantUtf8 c) {
-        this(c.getBytes());
-    }
+    
 
 
     /**
@@ -100,12 +95,7 @@ public final class ConstantUtf8 extends Constant {
     }
 
 
-    /**
-     * @param bytes the raw bytes of this Utf-8
-     */
-    public final void setBytes( String bytes ) {
-        this.bytes = bytes;
-    }
+    
 
 
     /**

==================================================
Deprecated.java
index 7b488b07bb..9e1e8f2434 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ConstantValue.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ConstantValue.java
@@ -36,13 +36,7 @@ public final class ConstantValue extends Attribute {
     private int constantvalue_index;
 
 
-    /**
-     * Initialize from another object. Note that both objects use the same
-     * references (shallow copy). Use clone() for a physical copy.
-     */
-    public ConstantValue(ConstantValue c) {
-        this(c.getNameIndex(), c.getLength(), c.getConstantValueIndex(), c.getConstantPool());
-    }
+    
 
 
     /**
@@ -96,20 +90,10 @@ public final class ConstantValue extends Attribute {
     }
 
 
-    /**
-     * @return Index in constant pool of constant value.
-     */
-    public final int getConstantValueIndex() {
-        return constantvalue_index;
-    }
+    
 
 
-    /**
-     * @param constantvalue_index the index info the constant pool of this constant value
-     */
-    public final void setConstantValueIndex( int constantvalue_index ) {
-        this.constantvalue_index = constantvalue_index;
-    }
+    
 
 
     /**

==================================================
ElementValue.java
index 47833aec45..87c573a956 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/Deprecated.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/Deprecated.java
@@ -35,13 +35,7 @@ public final class Deprecated extends Attribute {
     private byte[] bytes;
 
 
-    /**
-     * Initialize from another object. Note that both objects use the same
-     * references (shallow copy). Use clone() for a physical copy.
-     */
-    public Deprecated(Deprecated c) {
-        this(c.getNameIndex(), c.getLength(), c.getBytes(), c.getConstantPool());
-    }
+    
 
 
     /**
@@ -101,20 +95,10 @@ public final class Deprecated extends Attribute {
     }
 
 
-    /**
-     * @return data bytes.
-     */
-    public final byte[] getBytes() {
-        return bytes;
-    }
+    
 
 
-    /**
-     * @param bytes the raw bytes that represents this byte array
-     */
-    public final void setBytes( byte[] bytes ) {
-        this.bytes = bytes;
-    }
+    
 
 
     /**

==================================================
ElementValuePair.java
index f16616c9e5..9a501642e8 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ElementValue.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ElementValue.java
@@ -133,10 +133,5 @@ public abstract class ElementValue
 		}
 	}
 
-	public String toShortString()
-	{
-		StringBuffer result = new StringBuffer();
-		result.append(stringifyValue());
-		return result.toString();
-	}
+	
 }

==================================================
EnclosingMethod.java
index 4c36a640eb..5018a1afb8 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ElementValuePair.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ElementValuePair.java
@@ -60,13 +60,7 @@ public class ElementValuePair
 		return elementNameIndex;
 	}
 
-	public String toShortString()
-	{
-		StringBuffer result = new StringBuffer();
-		result.append(getNameString()).append("=").append(
-				getValue().toShortString());
-		return result.toString();
-	}
+	
 	
 	protected void dump(DataOutputStream dos) throws IOException {
 		dos.writeShort(elementNameIndex); // u2 name of the element

==================================================
ExceptionTable.java
index ab08c41934..acbc4d1f7e 100755
--- a/java/org/apache/tomcat/util/bcel/classfile/EnclosingMethod.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/EnclosingMethod.java
@@ -59,25 +59,15 @@ public class EnclosingMethod extends Attribute {
 		// return (EnclosingMethod)clone();
 	}
 	
-	// Accessors
-	public final int getEnclosingClassIndex() { return classIndex; }  
-	public final int getEnclosingMethodIndex(){ return methodIndex;}
+	  
+	
+	
+	
 	
-	public final void setEnclosingClassIndex(int idx) {classIndex = idx;}
-	public final void setEnclosingMethodIndex(int idx){methodIndex= idx;}
 
-	public final ConstantClass getEnclosingClass() {
-		ConstantClass c = 
-			(ConstantClass)constant_pool.getConstant(classIndex,Constants.CONSTANT_Class);
-		return c;
-	}
 	
-	public final ConstantNameAndType getEnclosingMethod() {
-		if (methodIndex == 0) return null;
-		ConstantNameAndType nat = 
-			(ConstantNameAndType)constant_pool.getConstant(methodIndex,Constants.CONSTANT_NameAndType);
-		return nat;
-	}
+	
+	
 
     public final void dump(DataOutputStream file) throws IOException {
 	    super.dump(file);

==================================================
Field.java
index 222478a8b5..8cef8bade4 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ExceptionTable.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ExceptionTable.java
@@ -39,13 +39,7 @@ public final class ExceptionTable extends Attribute {
     private int[] exception_index_table; // constant pool
 
 
-    /**
-     * Initialize from another object. Note that both objects use the same
-     * references (shallow copy). Use copy() for a physical copy.
-     */
-    public ExceptionTable(ExceptionTable c) {
-        this(c.getNameIndex(), c.getLength(), c.getExceptionIndexTable(), c.getConstantPool());
-    }
+    
 
 
     /**
@@ -107,33 +101,13 @@ public final class ExceptionTable extends Attribute {
     }
 
 
-    /**
-     * @return Array of indices into constant pool of thrown exceptions.
-     */
-    public final int[] getExceptionIndexTable() {
-        return exception_index_table;
-    }
+    
 
 
-    /**
-     * @return Length of exception table.
-     */
-    public final int getNumberOfExceptions() {
-        return number_of_exceptions;
-    }
+    
 
 
-    /**
-     * @return class names of thrown exceptions
-     */
-    public final String[] getExceptionNames() {
-        String[] names = new String[number_of_exceptions];
-        for (int i = 0; i < number_of_exceptions; i++) {
-            names[i] = constant_pool.getConstantString(exception_index_table[i],
-                    Constants.CONSTANT_Class).replace('/', '.');
-        }
-        return names;
-    }
+    
 
 
     /**

==================================================
FieldOrMethod.java
index 3e907b8808..300ff136ad 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/Field.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/Field.java
@@ -19,7 +19,6 @@ package org.apache.tomcat.util.bcel.classfile;
 import java.io.DataInputStream;
 import java.io.IOException;
 import org.apache.tomcat.util.bcel.Constants;
-import org.apache.tomcat.util.bcel.generic.Type;
 import org.apache.tomcat.util.bcel.util.BCELComparator;
 
 /**
@@ -48,13 +47,7 @@ public final class Field extends FieldOrMethod {
     };
 
 
-    /**
-     * Initialize from another object. Note that both objects use the same
-     * references (shallow copy). Use clone() for a physical copy.
-     */
-    public Field(Field c) {
-        super(c);
-    }
+    
 
 
     /**
@@ -67,29 +60,10 @@ public final class Field extends FieldOrMethod {
     }
 
 
-    /**
-     * @param access_flags Access rights of field
-     * @param name_index Points to field name in constant pool
-     * @param signature_index Points to encoded signature
-     * @param attributes Collection of attributes
-     * @param constant_pool Array of constants
-     */
-    public Field(int access_flags, int name_index, int signature_index, Attribute[] attributes,
-            ConstantPool constant_pool) {
-        super(access_flags, name_index, signature_index, attributes, constant_pool);
-    }
+    
 
 
-    /**
-     * Called by objects that are traversing the nodes of the tree implicitely
-     * defined by the contents of a Java class. I.e., the hierarchy of methods,
-     * fields, attributes, etc. spawns a tree of objects.
-     *
-     * @param v Visitor object
-     */
-    public void accept( Visitor v ) {
-        v.visitField(this);
-    }
+    
 
 
     /**
@@ -134,36 +108,16 @@ public final class Field extends FieldOrMethod {
     }
 
 
-    /**
-     * @return deep copy of this field
-     */
-    public final Field copy( ConstantPool _constant_pool ) {
-        return (Field) copy_(_constant_pool);
-    }
+    
 
 
-    /**
-     * @return type of field
-     */
-    public Type getType() {
-        return Type.getReturnType(getSignature());
-    }
+    
 
 
-    /**
-     * @return Comparison strategy object
-     */
-    public static BCELComparator getComparator() {
-        return _cmp;
-    }
+    
 
 
-    /**
-     * @param comparator Comparison strategy object
-     */
-    public static void setComparator( BCELComparator comparator ) {
-        _cmp = comparator;
-    }
+    
 
 
     /**

==================================================
InnerClass.java
index e4f7c85952..32d48e96ed 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/FieldOrMethod.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/FieldOrMethod.java
@@ -17,13 +17,9 @@
 package org.apache.tomcat.util.bcel.classfile;
 
 import java.io.DataInputStream;
-import java.io.DataOutputStream;
 import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
 import org.apache.tomcat.util.bcel.Constants;
 import org.apache.tomcat.util.bcel.classfile.Attribute;
-import org.apache.tomcat.util.bcel.classfile.Signature;
 
 /** 
  * Abstract super class for fields and methods.
@@ -37,7 +33,7 @@ public abstract class FieldOrMethod extends AccessFlags implements Cloneable, No
     protected int signature_index; // Points to encoded signature
     protected int attributes_count; // No. of attributes
     protected Attribute[] attributes; // Collection of attributes
-    protected AnnotationEntry[] annotationEntries; // annotations defined on the field or method 
+    
     protected ConstantPool constant_pool;
 
     private String signatureAttributeString = null;
@@ -51,14 +47,7 @@ public abstract class FieldOrMethod extends AccessFlags implements Cloneable, No
     }
 
 
-    /**
-     * Initialize from another object. Note that both objects use the same
-     * references (shallow copy). Use clone() for a physical copy.
-     */
-    protected FieldOrMethod(FieldOrMethod c) {
-        this(c.getAccessFlags(), c.getNameIndex(), c.getSignatureIndex(), c.getAttributes(), c
-                .getConstantPool());
-    }
+    
 
 
     /**
@@ -96,29 +85,10 @@ public abstract class FieldOrMethod extends AccessFlags implements Cloneable, No
     }
 
 
-    /**
-     * Dump object to file stream on binary format.
-     *
-     * @param file Output file stream
-     * @throws IOException
-     */
-    public final void dump( DataOutputStream file ) throws IOException {
-        file.writeShort(access_flags);
-        file.writeShort(name_index);
-        file.writeShort(signature_index);
-        file.writeShort(attributes_count);
-        for (int i = 0; i < attributes_count; i++) {
-            attributes[i].dump(file);
-        }
-    }
+    
 
 
-    /**
-     * @return Collection of object attributes.
-     */
-    public final Attribute[] getAttributes() {
-        return attributes;
-    }
+    
 
 
     /**
@@ -130,52 +100,22 @@ public abstract class FieldOrMethod extends AccessFlags implements Cloneable, No
     }
 
 
-    /**
-     * @return Constant pool used by this object.
-     */
-    public final ConstantPool getConstantPool() {
-        return constant_pool;
-    }
+    
 
 
-    /**
-     * @param constant_pool Constant pool to be used for this object.
-     */
-    public final void setConstantPool( ConstantPool constant_pool ) {
-        this.constant_pool = constant_pool;
-    }
+    
 
 
-    /**
-     * @return Index in constant pool of object's name.
-     */
-    public final int getNameIndex() {
-        return name_index;
-    }
+    
 
 
-    /**
-     * @param name_index Index in constant pool of object's name.
-     */
-    public final void setNameIndex( int name_index ) {
-        this.name_index = name_index;
-    }
+    
 
 
-    /**
-     * @return Index in constant pool of field signature.
-     */
-    public final int getSignatureIndex() {
-        return signature_index;
-    }
+    
 
 
-    /**
-     * @param signature_index Index in constant pool of field signature.
-     */
-    public final void setSignatureIndex( int signature_index ) {
-        this.signature_index = signature_index;
-    }
+    
 
 
     /**
@@ -198,93 +138,11 @@ public abstract class FieldOrMethod extends AccessFlags implements Cloneable, No
     }
 
 
-    /**
-     * @return deep copy of this field
-     */
-    protected FieldOrMethod copy_( ConstantPool _constant_pool ) {
-    	FieldOrMethod c = null;
-
-        try {
-          c = (FieldOrMethod)clone();
-        } catch(CloneNotSupportedException e) {}
+    
 
-        c.constant_pool    = constant_pool;
-        c.attributes       = new Attribute[attributes_count];
+	
 
-        for(int i=0; i < attributes_count; i++)
-          c.attributes[i] = attributes[i].copy(constant_pool);
+	
 
-        return c;
-    }
-    
-    /**
-	 * Ensure we have unpacked any attributes that contain annotations.
-	 * We don't remove these annotation attributes from the attributes list, they
-	 * remain there.
-	 */
-	private void ensureAnnotationsUpToDate()
-	{
-		if (annotationsOutOfDate)
-		{
-			// Find attributes that contain annotation data
-			Attribute[] attrs = getAttributes();
-			List accumulatedAnnotations = new ArrayList();
-			for (int i = 0; i < attrs.length; i++)
-			{
-				Attribute attribute = attrs[i];
-				if (attribute instanceof Annotations)
-				{
-					Annotations annotations = (Annotations) attribute;
-					for (int j = 0; j < annotations.getAnnotationEntries().length; j++)
-					{
-						accumulatedAnnotations.add(annotations
-								.getAnnotationEntries()[j]);
-					}
-				}
-			}
-			annotationEntries = (AnnotationEntry[]) accumulatedAnnotations
-					.toArray(new AnnotationEntry[accumulatedAnnotations.size()]);
-			annotationsOutOfDate = false;
-		}
-	}
-
-	public AnnotationEntry[] getAnnotationEntries()
-	{
-		ensureAnnotationsUpToDate();
-		return annotationEntries;
-	}
-
-	public void addAnnotationEntry(AnnotationEntry a)
-	{
-		ensureAnnotationsUpToDate();
-		int len = annotationEntries.length;
-		AnnotationEntry[] newAnnotations = new AnnotationEntry[len + 1];
-		System.arraycopy(annotationEntries, 0, newAnnotations, 0, len);
-		newAnnotations[len] = a;
-		annotationEntries = newAnnotations;
-	}
-
-	/**
-	 * Hunts for a signature attribute on the member and returns its contents.  So where the 'regular' signature
-	 * may be (Ljava/util/Vector;)V the signature attribute may in fact say 'Ljava/lang/Vector<Ljava/lang/String>;'
-	 * Coded for performance - searches for the attribute only when requested - only searches for it once.
-	 */
-	public final String getGenericSignature()
-	{
-		if (!searchedForSignatureAttribute)
-		{
-			boolean found = false;
-			for (int i = 0; !found && i < attributes_count; i++)
-			{
-				if (attributes[i] instanceof Signature)
-				{
-					signatureAttributeString = ((Signature) attributes[i])
-							.getSignature();
-					found = true;
-				}
-			}
-			searchedForSignatureAttribute = true;
-		}
-		return signatureAttributeString;
-	}
+	
 }

==================================================
InnerClasses.java
index f64f08f133..82c25424f7 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/InnerClass.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/InnerClass.java
@@ -40,13 +40,7 @@ public final class InnerClass implements Cloneable, Node, Serializable {
     private int inner_access_flags;
 
 
-    /**
-     * Initialize from another object.
-     */
-    public InnerClass(InnerClass c) {
-        this(c.getInnerClassIndex(), c.getOuterClassIndex(), c.getInnerNameIndex(), c
-                .getInnerAccessFlags());
-    }
+    
 
 
     /**
@@ -75,16 +69,7 @@ public final class InnerClass implements Cloneable, Node, Serializable {
     }
 
 
-    /**
-     * Called by objects that are traversing the nodes of the tree implicitely
-     * defined by the contents of a Java class. I.e., the hierarchy of methods,
-     * fields, attributes, etc. spawns a tree of objects.
-     *
-     * @param v Visitor object
-     */
-    public void accept( Visitor v ) {
-        v.visitInnerClass(this);
-    }
+    
 
 
     /**
@@ -101,68 +86,28 @@ public final class InnerClass implements Cloneable, Node, Serializable {
     }
 
 
-    /**
-     * @return access flags of inner class.
-     */
-    public final int getInnerAccessFlags() {
-        return inner_access_flags;
-    }
+    
 
 
-    /**
-     * @return class index of inner class.
-     */
-    public final int getInnerClassIndex() {
-        return inner_class_index;
-    }
+    
 
 
-    /**
-     * @return name index of inner class.
-     */
-    public final int getInnerNameIndex() {
-        return inner_name_index;
-    }
+    
 
 
-    /**
-     * @return class index of outer class.
-     */
-    public final int getOuterClassIndex() {
-        return outer_class_index;
-    }
+    
 
 
-    /**
-     * @param inner_access_flags access flags for this inner class
-     */
-    public final void setInnerAccessFlags( int inner_access_flags ) {
-        this.inner_access_flags = inner_access_flags;
-    }
+    
 
 
-    /**
-     * @param inner_class_index index into the constant pool for this class
-     */
-    public final void setInnerClassIndex( int inner_class_index ) {
-        this.inner_class_index = inner_class_index;
-    }
+    
 
 
-    /**
-     * @param inner_name_index index into the constant pool for this class's name
-     */
-    public final void setInnerNameIndex( int inner_name_index ) {
-        this.inner_name_index = inner_name_index;
-    }
+    
 
 
-    /**
-     * @param outer_class_index index into the constant pool for the owning class
-     */
-    public final void setOuterClassIndex( int outer_class_index ) {
-        this.outer_class_index = outer_class_index;
-    }
+    
 
 
     /**

==================================================
JavaClass.java
index 5f46f54bc7..e41854a64a 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/InnerClasses.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/InnerClasses.java
@@ -37,13 +37,7 @@ public final class InnerClasses extends Attribute {
     private int number_of_classes;
 
 
-    /**
-     * Initialize from another object. Note that both objects use the same
-     * references (shallow copy). Use clone() for a physical copy.
-     */
-    public InnerClasses(InnerClasses c) {
-        this(c.getNameIndex(), c.getLength(), c.getInnerClasses(), c.getConstantPool());
-    }
+    
 
 
     /**
@@ -106,12 +100,7 @@ public final class InnerClasses extends Attribute {
     }
 
 
-    /**
-     * @return array of inner class "records"
-     */
-    public final InnerClass[] getInnerClasses() {
-        return inner_classes;
-    }
+    
 
 
     /**

==================================================
LineNumber.java
index 84298d0e11..6a5d196be6 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/JavaClass.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/JavaClass.java
@@ -16,19 +16,12 @@
  */
 package org.apache.tomcat.util.bcel.classfile;
 
-import java.io.ByteArrayOutputStream;
-import java.io.DataOutputStream;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;
 import java.util.StringTokenizer;
 import java.util.TreeSet;
 import org.apache.tomcat.util.bcel.Constants;
-import org.apache.tomcat.util.bcel.generic.Type;
 import org.apache.tomcat.util.bcel.util.BCELComparator;
 import org.apache.tomcat.util.bcel.util.ClassQueue;
 import org.apache.tomcat.util.bcel.util.SyntheticRepository;
@@ -69,8 +62,8 @@ public class JavaClass extends AccessFlags implements Cloneable, Node, Comparabl
     public static final byte HEAP = 1;
     public static final byte FILE = 2;
     public static final byte ZIP = 3;
-    static boolean debug = false; // Debugging on/off
-    static char sep = '/'; // directory separator
+    
+    
     
     //  Annotations are collected from certain attributes, don't do it more than necessary!
     private boolean annotationsOutOfDate = true;
@@ -179,153 +172,28 @@ public class JavaClass extends AccessFlags implements Cloneable, Node, Comparabl
     }
 
 
-    /**
-     * Constructor gets all contents as arguments.
-     *
-     * @param class_name_index Class name
-     * @param superclass_name_index Superclass name
-     * @param file_name File name
-     * @param major Major compiler version
-     * @param minor Minor compiler version
-     * @param access_flags Access rights defined by bit flags
-     * @param constant_pool Array of constants
-     * @param interfaces Implemented interfaces
-     * @param fields Class fields
-     * @param methods Class methods
-     * @param attributes Class attributes
-     */
-    public JavaClass(int class_name_index, int superclass_name_index, String file_name, int major,
-            int minor, int access_flags, ConstantPool constant_pool, int[] interfaces,
-            Field[] fields, Method[] methods, Attribute[] attributes) {
-        this(class_name_index, superclass_name_index, file_name, major, minor, access_flags,
-                constant_pool, interfaces, fields, methods, attributes, HEAP);
-    }
+    
 
 
-    /**
-     * Called by objects that are traversing the nodes of the tree implicitely
-     * defined by the contents of a Java class. I.e., the hierarchy of methods,
-     * fields, attributes, etc. spawns a tree of objects.
-     *
-     * @param v Visitor object
-     */
-    public void accept( Visitor v ) {
-        v.visitJavaClass(this);
-    }
+    
 
 
-    /* Print debug information depending on `JavaClass.debug'
-     */
-    static final void Debug( String str ) {
-        if (debug) {
-            System.out.println(str);
-        }
-    }
+    
 
 
-    /** 
-     * Dump class to a file.
-     *
-     * @param file Output file
-     * @throws IOException
-     */
-    public void dump( File file ) throws IOException {
-        String parent = file.getParent();
-        if (parent != null) {
-            File dir = new File(parent);
-            dir.mkdirs();
-        }
-        DataOutputStream dos = null;
-        try {
-            dos = new DataOutputStream(new FileOutputStream(file));
-            dump(dos);
-        } finally {
-            if (dos != null) {
-                dos.close();
-            }
-        }
-    }
+    
 
 
-    /** 
-     * Dump class to a file named file_name.
-     *
-     * @param _file_name Output file name
-     * @exception IOException
-     */
-    public void dump( String _file_name ) throws IOException {
-        dump(new File(_file_name));
-    }
+    
 
 
-    /**
-     * @return class in binary format
-     */
-    public byte[] getBytes() {
-        ByteArrayOutputStream s = new ByteArrayOutputStream();
-        DataOutputStream ds = new DataOutputStream(s);
-        try {
-            dump(ds);
-        } catch (IOException e) {
-            e.printStackTrace();
-        } finally {
-            try {
-                ds.close();
-            } catch (IOException e2) {
-                e2.printStackTrace();
-            }
-        }
-        return s.toByteArray();
-    }
+    
 
 
-    /**
-     * Dump Java class to output stream in binary format.
-     *
-     * @param file Output stream
-     * @exception IOException
-     */
-    public void dump( OutputStream file ) throws IOException {
-        dump(new DataOutputStream(file));
-    }
+    
 
 
-    /**
-     * Dump Java class to output stream in binary format.
-     *
-     * @param file Output stream
-     * @exception IOException
-     */
-    public void dump( DataOutputStream file ) throws IOException {
-        file.writeInt(0xcafebabe);
-        file.writeShort(minor);
-        file.writeShort(major);
-        constant_pool.dump(file);
-        file.writeShort(access_flags);
-        file.writeShort(class_name_index);
-        file.writeShort(superclass_name_index);
-        file.writeShort(interfaces.length);
-        for (int i = 0; i < interfaces.length; i++) {
-            file.writeShort(interfaces[i]);
-        }
-        file.writeShort(fields.length);
-        for (int i = 0; i < fields.length; i++) {
-            fields[i].dump(file);
-        }
-        file.writeShort(methods.length);
-        for (int i = 0; i < methods.length; i++) {
-            methods[i].dump(file);
-        }
-        if (attributes != null) {
-            file.writeShort(attributes.length);
-            for (int i = 0; i < attributes.length; i++) {
-                attributes[i].dump(file);
-            }
-        } else {
-            file.writeShort(0);
-        }
-        file.flush();
-    }
+    
 
 
     /**
@@ -361,46 +229,19 @@ public class JavaClass extends AccessFlags implements Cloneable, Node, Comparabl
     }
 
 
-    /**
-     * @return Package name.
-     */
-    public String getPackageName() {
-        return package_name;
-    }
+    
 
 
-    /**
-     * @return Class name index.
-     */
-    public int getClassNameIndex() {
-        return class_name_index;
-    }
+    
 
 
-    /**
-     * @return Constant pool.
-     */
-    public ConstantPool getConstantPool() {
-        return constant_pool;
-    }
+    
 
 
-    /**
-     * @return Fields, i.e., variables of the class. Like the JVM spec
-     * mandates for the classfile format, these fields are those specific to
-     * this class, and not those of the superclass or superinterfaces.
-     */
-    public Field[] getFields() {
-        return fields;
-    }
+    
 
 
-    /**
-     * @return File name of class, aka SourceFile attribute value
-     */
-    public String getFileName() {
-        return file_name;
-    }
+    
 
 
     /**
@@ -411,60 +252,22 @@ public class JavaClass extends AccessFlags implements Cloneable, Node, Comparabl
     }
 
 
-    /**
-     * @return Indices in constant pool of implemented interfaces.
-     */
-    public int[] getInterfaceIndices() {
-        return interfaces;
-    }
+    
 
 
-    /**
-     * @return Major number of class file version.
-     */
-    public int getMajor() {
-        return major;
-    }
+    
 
 
-    /**
-     * @return Methods of the class.
-     */
-    public Method[] getMethods() {
-        return methods;
-    }
+    
 
 
-    /**
-     * @return A org.apache.tomcat.util.bcel.classfile.Method corresponding to
-     * java.lang.reflect.Method if any
-     */
-    public Method getMethod( java.lang.reflect.Method m ) {
-        for (int i = 0; i < methods.length; i++) {
-            Method method = methods[i];
-            if (m.getName().equals(method.getName()) && (m.getModifiers() == method.getModifiers())
-                    && Type.getSignature(m).equals(method.getSignature())) {
-                return method;
-            }
-        }
-        return null;
-    }
+    
 
 
-    /**
-     * @return Minor number of class file version.
-     */
-    public int getMinor() {
-        return minor;
-    }
+    
 
 
-    /**
-     * @return sbsolute path to file where this class was read from
-     */
-    public String getSourceFileName() {
-        return source_file_name;
-    }
+    
 
 
     /**
@@ -475,139 +278,6 @@ public class JavaClass extends AccessFlags implements Cloneable, Node, Comparabl
     }
 
 
-    /**
-     * @return Class name index.
-     */
-    public int getSuperclassNameIndex() {
-        return superclass_name_index;
-    }
-
-    static {
-        // Debugging ... on/off
-        debug = Boolean.getBoolean("JavaClass.debug");
-        // Get path separator either / or \ usually
-        String _sep = System.getProperty("file.separator");
-        if (_sep != null) {
-            try {
-                JavaClass.sep = _sep.charAt(0);
-            } catch (StringIndexOutOfBoundsException e) {
-            } // Never reached
-        }
-    }
-
-
-    /**
-     * @param attributes .
-     */
-    public void setAttributes( Attribute[] attributes ) {
-        this.attributes = attributes;
-    }
-
-
-    /**
-     * @param class_name .
-     */
-    public void setClassName( String class_name ) {
-        this.class_name = class_name;
-    }
-
-
-    /**
-     * @param class_name_index .
-     */
-    public void setClassNameIndex( int class_name_index ) {
-        this.class_name_index = class_name_index;
-    }
-
-
-    /**
-     * @param constant_pool .
-     */
-    public void setConstantPool( ConstantPool constant_pool ) {
-        this.constant_pool = constant_pool;
-    }
-
-
-    /**
-     * @param fields .
-     */
-    public void setFields( Field[] fields ) {
-        this.fields = fields;
-    }
-
-
-    /**
-     * Set File name of class, aka SourceFile attribute value
-     */
-    public void setFileName( String file_name ) {
-        this.file_name = file_name;
-    }
-
-
-    /**
-     * @param interface_names .
-     */
-    public void setInterfaceNames( String[] interface_names ) {
-        this.interface_names = interface_names;
-    }
-
-
-    /**
-     * @param interfaces .
-     */
-    public void setInterfaces( int[] interfaces ) {
-        this.interfaces = interfaces;
-    }
-
-
-    /**
-     * @param major .
-     */
-    public void setMajor( int major ) {
-        this.major = major;
-    }
-
-
-    /**
-     * @param methods .
-     */
-    public void setMethods( Method[] methods ) {
-        this.methods = methods;
-    }
-
-
-    /**
-     * @param minor .
-     */
-    public void setMinor( int minor ) {
-        this.minor = minor;
-    }
-
-
-    /**
-     * Set absolute path to file this class was read from.
-     */
-    public void setSourceFileName( String source_file_name ) {
-        this.source_file_name = source_file_name;
-    }
-
-
-    /**
-     * @param superclass_name .
-     */
-    public void setSuperclassName( String superclass_name ) {
-        this.superclass_name = superclass_name;
-    }
-
-
-    /**
-     * @param superclass_name_index .
-     */
-    public void setSuperclassNameIndex( int superclass_name_index ) {
-        this.superclass_name_index = superclass_name_index;
-    }
-
-
     /**
      * @return String representing class contents.
      */
@@ -673,32 +343,7 @@ public class JavaClass extends AccessFlags implements Cloneable, Node, Comparabl
     }
 
 
-    /**
-     * @return deep copy of this class
-     */
-    public JavaClass copy() {
-        JavaClass c = null;
-        try {
-            c = (JavaClass) clone();
-            c.constant_pool = constant_pool.copy();
-            c.interfaces = (int[]) interfaces.clone();
-            c.interface_names = (String[]) interface_names.clone();
-            c.fields = new Field[fields.length];
-            for (int i = 0; i < fields.length; i++) {
-                c.fields[i] = fields[i].copy(c.constant_pool);
-            }
-            c.methods = new Method[methods.length];
-            for (int i = 0; i < methods.length; i++) {
-                c.methods[i] = methods[i].copy(c.constant_pool);
-            }
-            c.attributes = new Attribute[attributes.length];
-            for (int i = 0; i < attributes.length; i++) {
-                c.attributes[i] = attributes[i].copy(c.constant_pool);
-            }
-        } catch (CloneNotSupportedException e) {
-        }
-        return c;
-    }
+    
 
 
     public final boolean isSuper() {
@@ -706,63 +351,12 @@ public class JavaClass extends AccessFlags implements Cloneable, Node, Comparabl
     }
 
 
-    public final boolean isClass() {
-        return (access_flags & Constants.ACC_INTERFACE) == 0;
-    }
     
-    public final boolean isAnonymous() {
-  	  computeNestedTypeStatus();
-  	  return this.isAnonymous;
-    }
     
-    public final boolean isNested() {
-  	  computeNestedTypeStatus();
-  	  return this.isNested;
-    }
     
-    private final void computeNestedTypeStatus() {
-  	  if (computedNestedTypeStatus) return;
-  	  for (int i = 0; i < this.attributes.length; i++) {
-  			if (this.attributes[i] instanceof InnerClasses) {
-  				InnerClass[] innerClasses = ((InnerClasses) this.attributes[i]).getInnerClasses();
-  				for (int j = 0; j < innerClasses.length; j++) {
-  					boolean innerClassAttributeRefersToMe = false;
-  					String inner_class_name = constant_pool.getConstantString(innerClasses[j].getInnerClassIndex(),
-  						       Constants.CONSTANT_Class);
-  					inner_class_name = Utility.compactClassName(inner_class_name);
-  					if (inner_class_name.equals(getClassName())) {
-  						innerClassAttributeRefersToMe = true;
-  					}
-  					if (innerClassAttributeRefersToMe) {
-  						this.isNested = true;
-  						if (innerClasses[j].getInnerNameIndex() == 0) {
-  							this.isAnonymous = true;
-  						}
-  					}
-  				}
-  			}
-  	  }
-  	  this.computedNestedTypeStatus = true;
-    }
-
-
-    /** @return returns either HEAP (generated), FILE, or ZIP
-     */
-    public final byte getSource() {
-        return source;
-    }
-
-
-    /********************* New repository functionality *********************/
-    /**
-     * Gets the ClassRepository which holds its definition. By default
-     * this is the same as SyntheticRepository.getInstance();
-     */
-    public org.apache.tomcat.util.bcel.util.Repository getRepository() {
-        return repository;
-    }
-
-
+    
+    
+    
     /**
      * Sets the ClassRepository which loaded the JavaClass.
      * Should be called immediately after parsing is done.
@@ -884,20 +478,10 @@ public class JavaClass extends AccessFlags implements Cloneable, Node, Comparabl
     }
 
 
-    /**
-     * @return Comparison strategy object
-     */
-    public static BCELComparator getComparator() {
-        return _cmp;
-    }
+    
 
 
-    /**
-     * @param comparator Comparison strategy object
-     */
-    public static void setComparator( BCELComparator comparator ) {
-        _cmp = comparator;
-    }
+    
 
 
     /**

==================================================
LineNumberTable.java
index 3dfd64e240..8ac6b98d96 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/LineNumber.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/LineNumber.java
@@ -36,12 +36,7 @@ public final class LineNumber implements Cloneable, Node, Serializable {
     private int line_number; // number in source file
 
 
-    /**
-     * Initialize from another object.
-     */
-    public LineNumber(LineNumber c) {
-        this(c.getStartPC(), c.getLineNumber());
-    }
+    
 
 
     /**
@@ -64,16 +59,7 @@ public final class LineNumber implements Cloneable, Node, Serializable {
     }
 
 
-    /**
-     * Called by objects that are traversing the nodes of the tree implicitely
-     * defined by the contents of a Java class. I.e., the hierarchy of methods,
-     * fields, attributes, etc. spawns a tree of objects.
-     *
-     * @param v Visitor object
-     */
-    public void accept( Visitor v ) {
-        v.visitLineNumber(this);
-    }
+    
 
 
     /**
@@ -88,36 +74,16 @@ public final class LineNumber implements Cloneable, Node, Serializable {
     }
 
 
-    /**
-     * @return Corresponding source line
-     */
-    public final int getLineNumber() {
-        return line_number;
-    }
+    
 
 
-    /**
-     * @return PC in code
-     */
-    public final int getStartPC() {
-        return start_pc;
-    }
+    
 
 
-    /**
-     * @param line_number the source line number
-     */
-    public final void setLineNumber( int line_number ) {
-        this.line_number = line_number;
-    }
+    
 
 
-    /**
-     * @param start_pc the pc for this line number
-     */
-    public final void setStartPC( int start_pc ) {
-        this.start_pc = start_pc;
-    }
+    
 
 
     /**

==================================================
LocalVariable.java
index d0cdedf642..f1b145e26f 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/LineNumberTable.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/LineNumberTable.java
@@ -37,13 +37,7 @@ public final class LineNumberTable extends Attribute {
     private LineNumber[] line_number_table; // Table of line/numbers pairs
 
 
-    /*
-     * Initialize from another object. Note that both objects use the same
-     * references (shallow copy). Use copy() for a physical copy.
-     */
-    public LineNumberTable(LineNumberTable c) {
-        this(c.getNameIndex(), c.getLength(), c.getLineNumberTable(), c.getConstantPool());
-    }
+    
 
 
     /*
@@ -105,12 +99,7 @@ public final class LineNumberTable extends Attribute {
     }
 
 
-    /**
-     * @return Array of (pc offset, line number) pairs.
-     */
-    public final LineNumber[] getLineNumberTable() {
-        return line_number_table;
-    }
+    
 
 
     /**
@@ -145,47 +134,7 @@ public final class LineNumberTable extends Attribute {
     }
 
 
-    /**
-     * Map byte code positions to source code lines.
-     *
-     * @param pos byte code offset
-     * @return corresponding line in source code
-     */
-    public int getSourceLine( int pos ) {
-        int l = 0, r = line_number_table_length - 1;
-        if (r < 0) {
-            return -1;
-        }
-        int min_index = -1, min = -1;
-        /* Do a binary search since the array is ordered.
-         */
-        do {
-            int i = (l + r) / 2;
-            int j = line_number_table[i].getStartPC();
-            if (j == pos) {
-                return line_number_table[i].getLineNumber();
-            } else if (pos < j) {
-                r = i - 1;
-            } else {
-                l = i + 1;
-            }
-            /* If exact match can't be found (which is the most common case)
-             * return the line number that corresponds to the greatest index less
-             * than pos.
-             */
-            if (j < pos && j > min) {
-                min = j;
-                min_index = i;
-            }
-        } while (l <= r);
-        /* It's possible that we did not find any valid entry for the bytecode
-         * offset we were looking for.
-         */
-        if (min_index < 0) {
-            return -1;
-        }
-        return line_number_table[min_index].getLineNumber();
-    }
+    
 
 
     /**
@@ -202,7 +151,5 @@ public final class LineNumberTable extends Attribute {
     }
 
 
-    public final int getTableLength() {
-        return line_number_table_length;
-    }
+    
 }

==================================================
LocalVariableTable.java
index 45f5f005ff..13c78a32a7 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/LocalVariable.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/LocalVariable.java
@@ -43,14 +43,7 @@ public final class LocalVariable implements Constants, Cloneable, Node, Serializ
     private ConstantPool constant_pool;
 
 
-    /**
-     * Initialize from another object. Note that both objects use the same
-     * references (shallow copy). Use copy() for a physical copy.
-     */
-    public LocalVariable(LocalVariable c) {
-        this(c.getStartPC(), c.getLength(), c.getNameIndex(), c.getSignatureIndex(), c.getIndex(),
-                c.getConstantPool());
-    }
+    
 
 
     /**
@@ -83,16 +76,7 @@ public final class LocalVariable implements Constants, Cloneable, Node, Serializ
     }
 
 
-    /**
-     * Called by objects that are traversing the nodes of the tree implicitely
-     * defined by the contents of a Java class. I.e., the hierarchy of methods,
-     * fields, attributes, etc. spawns a tree of objects.
-     *
-     * @param v Visitor object
-     */
-    public void accept( Visitor v ) {
-        v.visitLocalVariable(this);
-    }
+    
 
 
     /**
@@ -110,20 +94,10 @@ public final class LocalVariable implements Constants, Cloneable, Node, Serializ
     }
 
 
-    /**
-     * @return Constant pool used by this object.
-     */
-    public final ConstantPool getConstantPool() {
-        return constant_pool;
-    }
+    
 
 
-    /**
-     * @return Variable is valid within getStartPC() .. getStartPC()+getLength()
-     */
-    public final int getLength() {
-        return length;
-    }
+    
 
 
     /**
@@ -136,12 +110,7 @@ public final class LocalVariable implements Constants, Cloneable, Node, Serializ
     }
 
 
-    /**
-     * @return Index in constant pool of variable name.
-     */
-    public final int getNameIndex() {
-        return name_index;
-    }
+    
 
 
     /**
@@ -154,12 +123,7 @@ public final class LocalVariable implements Constants, Cloneable, Node, Serializ
     }
 
 
-    /**
-     * @return Index in constant pool of variable signature.
-     */
-    public final int getSignatureIndex() {
-        return signature_index;
-    }
+    
 
 
     /**
@@ -170,60 +134,25 @@ public final class LocalVariable implements Constants, Cloneable, Node, Serializ
     }
 
 
-    /**
-     * @return Start of range where he variable is valid
-     */
-    public final int getStartPC() {
-        return start_pc;
-    }
+    
 
 
-    /**
-     * @param constant_pool Constant pool to be used for this object.
-     */
-    public final void setConstantPool( ConstantPool constant_pool ) {
-        this.constant_pool = constant_pool;
-    }
+    
 
 
-    /**
-     * @param length the length of this local variable
-     */
-    public final void setLength( int length ) {
-        this.length = length;
-    }
+    
 
 
-    /**
-     * @param name_index the index into the constant pool for the name of this variable
-     */
-    public final void setNameIndex( int name_index ) {
-        this.name_index = name_index;
-    }
+    
 
 
-    /**
-     * @param signature_index the index into the constant pool for the signature of this variable
-     */
-    public final void setSignatureIndex( int signature_index ) {
-        this.signature_index = signature_index;
-    }
+    
 
 
-    /**
-     * @param index the index in the local variable table of this variable
-     */
-    public final void setIndex( int index ) {
-        this.index = index;
-    }
+    
 
 
-    /**
-     * @param start_pc Specify range where the local variable is valid.
-     */
-    public final void setStartPC( int start_pc ) {
-        this.start_pc = start_pc;
-    }
+    
 
 
     /**

==================================================
LocalVariableTypeTable.java
index c6994574a6..e13ca92996 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/LocalVariableTable.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/LocalVariableTable.java
@@ -36,13 +36,7 @@ public class LocalVariableTable extends Attribute {
     private LocalVariable[] local_variable_table; // variables
 
 
-    /**
-     * Initialize from another object. Note that both objects use the same
-     * references (shallow copy). Use copy() for a physical copy.
-     */
-    public LocalVariableTable(LocalVariableTable c) {
-        this(c.getNameIndex(), c.getLength(), c.getLocalVariableTable(), c.getConstantPool());
-    }
+    
 
 
     /**
@@ -104,12 +98,7 @@ public class LocalVariableTable extends Attribute {
     }
 
 
-    /**
-     * @return Array of local variables of method.
-     */
-    public final LocalVariable[] getLocalVariableTable() {
-        return local_variable_table;
-    }
+    
 
 
     /** 
@@ -132,26 +121,7 @@ public class LocalVariableTable extends Attribute {
     }
 
 
-    /** 
-     * @return matching variable using index when variable is used at supplied pc
-     * 
-     * @param index the variable slot
-     * @param pc the current pc that this variable is alive
-     * 
-     * @return the LocalVariable that matches or null if not found
-     */
-    public final LocalVariable getLocalVariable( int index, int pc ) {
-        for (int i = 0; i < local_variable_table_length; i++) {
-            if (local_variable_table[i].getIndex() == index) {
-                int start_pc = local_variable_table[i].getStartPC();
-                int end_pc = start_pc + local_variable_table[i].getLength();
-                if ((pc >= start_pc) && (pc <= end_pc)) {
-                    return local_variable_table[i];
-                }
-            }
-        }
-        return null;
-    }
+    
 
 
     public final void setLocalVariableTable( LocalVariable[] local_variable_table ) {
@@ -191,7 +161,5 @@ public class LocalVariableTable extends Attribute {
     }
 
 
-    public final int getTableLength() {
-        return local_variable_table_length;
-    }
+    
 }

==================================================
Method.java
index eed0b5426d..7d97d2c822 100755
--- a/java/org/apache/tomcat/util/bcel/classfile/LocalVariableTypeTable.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/LocalVariableTypeTable.java
@@ -48,10 +48,7 @@ public class LocalVariableTypeTable extends Attribute {
   private int             local_variable_type_table_length; // Table of local
   private LocalVariable[] local_variable_type_table;        // variables
 
-  public LocalVariableTypeTable(LocalVariableTypeTable c) {
-    this(c.getNameIndex(), c.getLength(), c.getLocalVariableTypeTable(),
-	 c.getConstantPool());
-  }
+  
 
   public LocalVariableTypeTable(int name_index, int length,
 			    LocalVariable[] local_variable_table,
@@ -83,17 +80,9 @@ public class LocalVariableTypeTable extends Attribute {
       local_variable_type_table[i].dump(file);
   }
 
-  public final LocalVariable[] getLocalVariableTypeTable() {
-    return local_variable_type_table;
-  }    
+      
 
-  public final LocalVariable getLocalVariable(int index) {
-    for(int i=0; i < local_variable_type_table_length; i++)
-      if(local_variable_type_table[i].getIndex() == index)
-	return local_variable_type_table[i];
-
-    return null;
-  }
+  
 
   public final void setLocalVariableTable(LocalVariable[] local_variable_table)
   {
@@ -131,5 +120,5 @@ public class LocalVariableTypeTable extends Attribute {
     return c;
   }
 
-  public final int getTableLength() { return local_variable_type_table_length; }
+  
 }

==================================================
Node.java
index 91e434187c..e635fc502f 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/Method.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/Method.java
@@ -19,7 +19,6 @@ package org.apache.tomcat.util.bcel.classfile;
 import java.io.DataInputStream;
 import java.io.IOException;
 import org.apache.tomcat.util.bcel.Constants;
-import org.apache.tomcat.util.bcel.generic.Type;
 import org.apache.tomcat.util.bcel.util.BCELComparator;
 
 /**
@@ -57,13 +56,7 @@ public final class Method extends FieldOrMethod {
     }
 
 
-    /**
-     * Initialize from another object. Note that both objects use the same
-     * references (shallow copy). Use clone() for a physical copy.
-     */
-    public Method(Method c) {
-        super(c);
-    }
+    
 
 
     /**
@@ -78,29 +71,10 @@ public final class Method extends FieldOrMethod {
     }
 
 
-    /**
-     * @param access_flags Access rights of method
-     * @param name_index Points to field name in constant pool
-     * @param signature_index Points to encoded signature
-     * @param attributes Collection of attributes
-     * @param constant_pool Array of constants
-     */
-    public Method(int access_flags, int name_index, int signature_index, Attribute[] attributes,
-            ConstantPool constant_pool) {
-        super(access_flags, name_index, signature_index, attributes, constant_pool);
-    }
+    
 
 
-    /**
-     * Called by objects that are traversing the nodes of the tree implicitely
-     * defined by the contents of a Java class. I.e., the hierarchy of methods,
-     * fields, attributes, etc. spawns a tree of objects.
-     *
-     * @param v Visitor object
-     */
-    public void accept( Visitor v ) {
-        v.visitMethod(this);
-    }
+    
 
 
     /**
@@ -142,16 +116,7 @@ public final class Method extends FieldOrMethod {
     }
 
 
-    /** @return LineNumberTable of code attribute if any, i.e. the call is forwarded
-     * to the Code atribute.
-     */
-    public final LineNumberTable getLineNumberTable() {
-        Code code = getCode();
-        if (code == null) {
-            return null;
-        }
-        return code.getLineNumberTable();
-    }
+    
 
 
     /**
@@ -190,44 +155,19 @@ public final class Method extends FieldOrMethod {
     }
 
 
-    /**
-     * @return deep copy of this method
-     */
-    public final Method copy( ConstantPool _constant_pool ) {
-        return (Method) copy_(_constant_pool);
-    }
+    
 
 
-    /**
-     * @return return type of method
-     */
-    public Type getReturnType() {
-        return Type.getReturnType(getSignature());
-    }
+    
 
 
-    /**
-     * @return array of method argument types
-     */
-    public Type[] getArgumentTypes() {
-        return Type.getArgumentTypes(getSignature());
-    }
+    
 
 
-    /**
-     * @return Comparison strategy object
-     */
-    public static BCELComparator getComparator() {
-        return _cmp;
-    }
+    
 
 
-    /**
-     * @param comparator Comparison strategy object
-     */
-    public static void setComparator( BCELComparator comparator ) {
-        _cmp = comparator;
-    }
+    
 
 
     /**

==================================================
PMGClass.java
index 83e63d4ef1..f5f67e0067 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/Node.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/Node.java
@@ -24,5 +24,5 @@ package org.apache.tomcat.util.bcel.classfile;
  */
 public interface Node {
 
-    public void accept( Visitor obj );
+    
 }

==================================================
ParameterAnnotationEntry.java
index f104eea9b6..0b0ac6f600 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/PMGClass.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/PMGClass.java
@@ -35,14 +35,7 @@ public final class PMGClass extends Attribute {
     private int pmg_class_index, pmg_index;
 
 
-    /**
-     * Initialize from another object. Note that both objects use the same
-     * references (shallow copy). Use clone() for a physical copy.
-     */
-    public PMGClass(PMGClass c) {
-        this(c.getNameIndex(), c.getLength(), c.getPMGIndex(), c.getPMGClassIndex(), c
-                .getConstantPool());
-    }
+    
 
 
     /**
@@ -99,36 +92,16 @@ public final class PMGClass extends Attribute {
     }
 
 
-    /**
-     * @return Index in constant pool of source file name.
-     */
-    public final int getPMGClassIndex() {
-        return pmg_class_index;
-    }
+    
 
 
-    /**
-     * @param pmg_class_index
-     */
-    public final void setPMGClassIndex( int pmg_class_index ) {
-        this.pmg_class_index = pmg_class_index;
-    }
+    
 
 
-    /**
-     * @return Index in constant pool of source file name.
-     */
-    public final int getPMGIndex() {
-        return pmg_index;
-    }
+    
 
 
-    /**
-     * @param pmg_index
-     */
-    public final void setPMGIndex( int pmg_index ) {
-        this.pmg_index = pmg_index;
-    }
+    
 
 
     /**

==================================================
ParameterAnnotations.java
index 5005587e3d..a1c5a37e75 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ParameterAnnotationEntry.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ParameterAnnotationEntry.java
@@ -48,30 +48,11 @@ public class ParameterAnnotationEntry implements Node, Constants {
     }
 
 
-    /**
-     * Called by objects that are traversing the nodes of the tree implicitely
-     * defined by the contents of a Java class. I.e., the hierarchy of methods,
-     * fields, attributes, etc. spawns a tree of objects.
-     *
-     * @param v Visitor object
-     */
-    public void accept( Visitor v ) {
-        //	    v.visitParameterAnnotationEntry(this);
-    }
+    
 
 
-    /**
-     * @return the number of annotation entries in this parameter annotation
-     */
-    public final int getNumAnnotations() {
-        return annotation_table_length;
-    }
+    
 
 
-    /**
-     * returns the array of annotation entries in this annotation
-     */
-    public AnnotationEntry[] getAnnotationEntries() {
-        return annotation_table;
-    }
+    
 }

==================================================
Signature.java
index abfb5930d0..5c5ec9dc7b 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ParameterAnnotations.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ParameterAnnotations.java
@@ -89,26 +89,11 @@ public abstract class ParameterAnnotations extends Attribute {
     }
 
 
-    /**
-     * @return the parameter annotation entry table
-     */
-    public final ParameterAnnotationEntry[] getParameterAnnotationTable() {
-        return parameter_annotation_table;
-    }
+    
 
 
-    /**
-     * returns the array of parameter annotation entries in this parameter annotation
-     */
-    public ParameterAnnotationEntry[] getParameterAnnotationEntries() {
-        return parameter_annotation_table;
-    }
+    
 
 
-    /**
-     * @return the number of parameter annotation entries in this parameter annotation
-     */
-    public final int getNumParameterAnnotation() {
-        return num_parameters;
-    }
+    
 }

==================================================
SimpleElementValue.java
index 9748032fcf..7532ae5527 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/Signature.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/Signature.java
@@ -36,13 +36,7 @@ public final class Signature extends Attribute {
     private int signature_index;
 
 
-    /**
-     * Initialize from another object. Note that both objects use the same
-     * references (shallow copy). Use clone() for a physical copy.
-     */
-    public Signature(Signature c) {
-        this(c.getNameIndex(), c.getLength(), c.getSignatureIndex(), c.getConstantPool());
-    }
+    
 
 
     /**
@@ -96,20 +90,10 @@ public final class Signature extends Attribute {
     }
 
 
-    /**
-     * @return Index in constant pool of source file name.
-     */
-    public final int getSignatureIndex() {
-        return signature_index;
-    }
+    
 
 
-    /**
-     * @param signature_index the index info the constant pool of this signature
-     */
-    public final void setSignatureIndex( int signature_index ) {
-        this.signature_index = signature_index;
-    }
+    
 
 
     /**
@@ -129,130 +113,6 @@ public final class Signature extends Attribute {
         MyByteArrayInputStream(String data) {
             super(data.getBytes());
         }
-
-
-        final int mark() {
-            return pos;
-        }
-
-
-        final String getData() {
-            return new String(buf);
-        }
-
-
-        final void reset( int p ) {
-            pos = p;
-        }
-
-
-        final void unread() {
-            if (pos > 0) {
-                pos--;
-            }
-        }
-    }
-
-
-    private static boolean identStart( int ch ) {
-        return ch == 'T' || ch == 'L';
-    }
-
-
-    private static final void matchIdent( MyByteArrayInputStream in, StringBuffer buf ) {
-        int ch;
-        if ((ch = in.read()) == -1) {
-            throw new RuntimeException("Illegal signature: " + in.getData()
-                    + " no ident, reaching EOF");
-        }
-        //System.out.println("return from ident:" + (char)ch);
-        if (!identStart(ch)) {
-            StringBuffer buf2 = new StringBuffer();
-            int count = 1;
-            while (Character.isJavaIdentifierPart((char) ch)) {
-                buf2.append((char) ch);
-                count++;
-                ch = in.read();
-            }
-            if (ch == ':') { // Ok, formal parameter
-                in.skip("Ljava/lang/Object".length());
-                buf.append(buf2);
-                ch = in.read();
-                in.unread();
-                //System.out.println("so far:" + buf2 + ":next:" +(char)ch);
-            } else {
-                for (int i = 0; i < count; i++) {
-                    in.unread();
-                }
-            }
-            return;
-        }
-        StringBuffer buf2 = new StringBuffer();
-        ch = in.read();
-        do {
-            buf2.append((char) ch);
-            ch = in.read();
-            //System.out.println("within ident:"+ (char)ch);
-        } while ((ch != -1) && (Character.isJavaIdentifierPart((char) ch) || (ch == '/')));
-        buf.append(buf2.toString().replace('/', '.'));
-        //System.out.println("regular return ident:"+ (char)ch + ":" + buf2);
-        if (ch != -1) {
-            in.unread();
-        }
-    }
-
-
-    private static final void matchGJIdent( MyByteArrayInputStream in, StringBuffer buf ) {
-        int ch;
-        matchIdent(in, buf);
-        ch = in.read();
-        if ((ch == '<') || ch == '(') { // Parameterized or method
-            //System.out.println("Enter <");
-            buf.append((char) ch);
-            matchGJIdent(in, buf);
-            while (((ch = in.read()) != '>') && (ch != ')')) { // List of parameters
-                if (ch == -1) {
-                    throw new RuntimeException("Illegal signature: " + in.getData()
-                            + " reaching EOF");
-                }
-                //System.out.println("Still no >");
-                buf.append(", ");
-                in.unread();
-                matchGJIdent(in, buf); // Recursive call
-            }
-            //System.out.println("Exit >");
-            buf.append((char) ch);
-        } else {
-            in.unread();
-        }
-        ch = in.read();
-        if (identStart(ch)) {
-            in.unread();
-            matchGJIdent(in, buf);
-        } else if (ch == ')') {
-            in.unread();
-            return;
-        } else if (ch != ';') {
-            throw new RuntimeException("Illegal signature: " + in.getData() + " read " + (char) ch);
-        }
-    }
-
-
-    public static String translate( String s ) {
-        //System.out.println("Sig:" + s);
-        StringBuffer buf = new StringBuffer();
-        matchGJIdent(new MyByteArrayInputStream(s), buf);
-        return buf.toString();
-    }
-
-
-    public static final boolean isFormalParameterList( String s ) {
-        return s.startsWith("<") && (s.indexOf(':') > 0);
-    }
-
-
-    public static final boolean isActualParameterList( String s ) {
-        return s.startsWith("L") && s.endsWith(">;");
     }
 
 

==================================================
SourceFile.java
index 8373feecd9..e645cbb973 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/SimpleElementValue.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/SimpleElementValue.java
@@ -38,10 +38,7 @@ public class SimpleElementValue extends ElementValue
 		return index;
 	}
 
-	public void setIndex(int index)
-	{
-		this.index = index;
-	}
+	
 
 	public String getValueString()
 	{

==================================================
StackMap.java
index 61abf40e37..2be484d804 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/SourceFile.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/SourceFile.java
@@ -37,13 +37,7 @@ public final class SourceFile extends Attribute {
     private int sourcefile_index;
 
 
-    /**
-     * Initialize from another object. Note that both objects use the same
-     * references (shallow copy). Use clone() for a physical copy.
-     */
-    public SourceFile(SourceFile c) {
-        this(c.getNameIndex(), c.getLength(), c.getSourceFileIndex(), c.getConstantPool());
-    }
+    
 
 
     /**
@@ -103,20 +97,10 @@ public final class SourceFile extends Attribute {
     }
 
 
-    /**
-     * @return Index in constant pool of source file name.
-     */
-    public final int getSourceFileIndex() {
-        return sourcefile_index;
-    }
+    
 
 
-    /**
-     * @param sourcefile_index
-     */
-    public final void setSourceFileIndex( int sourcefile_index ) {
-        this.sourcefile_index = sourcefile_index;
-    }
+    
 
 
     /**

==================================================
StackMapEntry.java
index 75b2e61ac5..407e1501cb 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/StackMap.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/StackMap.java
@@ -88,12 +88,7 @@ public final class StackMap extends Attribute implements Node {
     }
 
 
-    /**
-     * @return Array of stack map entries
-     */
-    public final StackMapEntry[] getStackMap() {
-        return map;
-    }
+    
 
 
     /**
@@ -147,7 +142,5 @@ public final class StackMap extends Attribute implements Node {
     }
 
 
-    public final int getMapLength() {
-        return map_length;
-    }
+    
 }

==================================================
StackMapTable.java
index f2df59a392..d933d8ad11 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/StackMapEntry.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/StackMapEntry.java
@@ -121,54 +121,34 @@ public final class StackMapEntry implements Cloneable {
     }
 
 
-    public void setByteCodeOffset( int b ) {
-        byte_code_offset = b;
-    }
+    
 
 
-    public int getByteCodeOffset() {
-        return byte_code_offset;
-    }
+    
 
 
-    public void setNumberOfLocals( int n ) {
-        number_of_locals = n;
-    }
+    
 
 
-    public int getNumberOfLocals() {
-        return number_of_locals;
-    }
+    
 
 
-    public void setTypesOfLocals( StackMapType[] t ) {
-        types_of_locals = t;
-    }
+    
 
 
-    public StackMapType[] getTypesOfLocals() {
-        return types_of_locals;
-    }
+    
 
 
-    public void setNumberOfStackItems( int n ) {
-        number_of_stack_items = n;
-    }
+    
 
 
-    public int getNumberOfStackItems() {
-        return number_of_stack_items;
-    }
+    
 
 
-    public void setTypesOfStackItems( StackMapType[] t ) {
-        types_of_stack_items = t;
-    }
+    
 
 
-    public StackMapType[] getTypesOfStackItems() {
-        return types_of_stack_items;
-    }
+    
 
 
     /**
@@ -183,30 +163,11 @@ public final class StackMapEntry implements Cloneable {
     }
 
 
-    /**
-     * Called by objects that are traversing the nodes of the tree implicitely
-     * defined by the contents of a Java class. I.e., the hierarchy of methods,
-     * fields, attributes, etc. spawns a tree of objects.
-     *
-     * @param v Visitor object
-     */
-    public void accept( Visitor v ) {
-        v.visitStackMapEntry(this);
-    }
+    
 
 
-    /**
-     * @return Constant pool used by this object.
-     */
-    public final ConstantPool getConstantPool() {
-        return constant_pool;
-    }
+    
 
 
-    /**
-     * @param constant_pool Constant pool to be used for this object.
-     */
-    public final void setConstantPool( ConstantPool constant_pool ) {
-        this.constant_pool = constant_pool;
-    }
+    
 }

==================================================
StackMapTableEntry.java
index 63d2477bf5..cd437d961c 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/StackMapTable.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/StackMapTable.java
@@ -88,12 +88,7 @@ public final class StackMapTable extends Attribute implements Node {
     }
 
 
-    /**
-     * @return Array of stack map entries
-     */
-    public final StackMapTableEntry[] getStackMapTable() {
-        return map;
-    }
+    
 
 
     /**
@@ -147,7 +142,5 @@ public final class StackMapTable extends Attribute implements Node {
     }
 
 
-    public final int getMapLength() {
-        return map_length;
-    }
+    
 }

==================================================
StackMapType.java
index 4fd2708b4f..5a3cbf2382 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/StackMapTableEntry.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/StackMapTableEntry.java
@@ -194,54 +194,34 @@ public final class StackMapTableEntry implements Cloneable {
     }
 
 
-    public void setByteCodeOffsetDelta( int b ) {
-        byte_code_offset_delta = b;
-    }
+    
 
 
-    public int getByteCodeOffsetDelta() {
-        return byte_code_offset_delta;
-    }
+    
 
 
-    public void setNumberOfLocals( int n ) {
-        number_of_locals = n;
-    }
+    
 
 
-    public int getNumberOfLocals() {
-        return number_of_locals;
-    }
+    
 
 
-    public void setTypesOfLocals( StackMapType[] t ) {
-        types_of_locals = t;
-    }
+    
 
 
-    public StackMapType[] getTypesOfLocals() {
-        return types_of_locals;
-    }
+    
 
 
-    public void setNumberOfStackItems( int n ) {
-        number_of_stack_items = n;
-    }
+    
 
 
-    public int getNumberOfStackItems() {
-        return number_of_stack_items;
-    }
+    
 
 
-    public void setTypesOfStackItems( StackMapType[] t ) {
-        types_of_stack_items = t;
-    }
+    
 
 
-    public StackMapType[] getTypesOfStackItems() {
-        return types_of_stack_items;
-    }
+    
 
 
     /**
@@ -256,30 +236,11 @@ public final class StackMapTableEntry implements Cloneable {
     }
 
 
-    /**
-     * Called by objects that are traversing the nodes of the tree implicitely
-     * defined by the contents of a Java class. I.e., the hierarchy of methods,
-     * fields, attributes, etc. spawns a tree of objects.
-     *
-     * @param v Visitor object
-     */
-    public void accept( Visitor v ) {
-        v.visitStackMapTableEntry(this);
-    }
+    
 
 
-    /**
-     * @return Constant pool used by this object.
-     */
-    public final ConstantPool getConstantPool() {
-        return constant_pool;
-    }
+    
 
 
-    /**
-     * @param constant_pool Constant pool to be used for this object.
-     */
-    public final void setConstantPool( ConstantPool constant_pool ) {
-        this.constant_pool = constant_pool;
-    }
+    
 }

==================================================
Synthetic.java
index b923671d29..e00ebb1f33 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/StackMapType.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/StackMapType.java
@@ -72,9 +72,7 @@ public final class StackMapType implements Cloneable {
     }
 
 
-    public byte getType() {
-        return type;
-    }
+    
 
 
     public void setIndex( int t ) {
@@ -133,24 +131,10 @@ public final class StackMapType implements Cloneable {
     }
 
 
-    /**
-     * @return deep copy of this object
-     */
-    public StackMapType copy() {
-        try {
-            return (StackMapType) clone();
-        } catch (CloneNotSupportedException e) {
-        }
-        return null;
-    }
+    
 
 
-    /**
-     * @return Constant pool used by this object.
-     */
-    public final ConstantPool getConstantPool() {
-        return constant_pool;
-    }
+    
 
 
     /**

==================================================
Unknown.java
index d0cade5fc3..6805700954 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/Synthetic.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/Synthetic.java
@@ -39,13 +39,7 @@ public final class Synthetic extends Attribute {
     private byte[] bytes;
 
 
-    /**
-     * Initialize from another object. Note that both objects use the same
-     * references (shallow copy). Use copy() for a physical copy.
-     */
-    public Synthetic(Synthetic c) {
-        this(c.getNameIndex(), c.getLength(), c.getBytes(), c.getConstantPool());
-    }
+    
 
 
     /**
@@ -107,20 +101,10 @@ public final class Synthetic extends Attribute {
     }
 
 
-    /**
-     * @return data bytes.
-     */
-    public final byte[] getBytes() {
-        return bytes;
-    }
+    
 
 
-    /**
-     * @param bytes
-     */
-    public final void setBytes( byte[] bytes ) {
-        this.bytes = bytes;
-    }
+    
 
 
     /**

==================================================
Utility.java
index b699963f9f..76fc60195d 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/Unknown.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/Unknown.java
@@ -20,7 +20,6 @@ import java.io.DataInputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
 import java.util.HashMap;
-import java.util.Iterator;
 import java.util.Map;
 import org.apache.tomcat.util.bcel.Constants;
 
@@ -47,26 +46,10 @@ public final class Unknown extends Attribute {
     private static Map unknown_attributes = new HashMap();
 
 
-    /** @return array of unknown attributes, but just one for each kind.
-     */
-    static Unknown[] getUnknownAttributes() {
-        Unknown[] unknowns = new Unknown[unknown_attributes.size()];
-        Iterator entries = unknown_attributes.values().iterator();
-        for (int i = 0; entries.hasNext(); i++) {
-            unknowns[i] = (Unknown) entries.next();
-        }
-        unknown_attributes.clear();
-        return unknowns;
-    }
+    
 
 
-    /**
-     * Initialize from another object. Note that both objects use the same
-     * references (shallow copy). Use clone() for a physical copy.
-     */
-    public Unknown(Unknown c) {
-        this(c.getNameIndex(), c.getLength(), c.getBytes(), c.getConstantPool());
-    }
+    
 
 
     /**
@@ -130,12 +113,7 @@ public final class Unknown extends Attribute {
     }
 
 
-    /**
-     * @return data bytes.
-     */
-    public final byte[] getBytes() {
-        return bytes;
-    }
+    
 
 
     /**
@@ -146,12 +124,7 @@ public final class Unknown extends Attribute {
     }
 
 
-    /**
-     * @param bytes the bytes to set
-     */
-    public final void setBytes( byte[] bytes ) {
-        this.bytes = bytes;
-    }
+    
 
 
     /**

==================================================
Visitor.java
index 73ca68bbf3..12ef5bf77f 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/Utility.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/Utility.java
@@ -16,28 +16,12 @@
  */
 package org.apache.tomcat.util.bcel.classfile;
 
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.CharArrayReader;
-import java.io.CharArrayWriter;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
 import java.io.FilterReader;
 import java.io.FilterWriter;
 import java.io.IOException;
-import java.io.PrintStream;
-import java.io.PrintWriter;
 import java.io.Reader;
 import java.io.Writer;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Locale;
-import java.util.zip.GZIPInputStream;
-import java.util.zip.GZIPOutputStream;
 import org.apache.tomcat.util.bcel.Constants;
-import org.apache.tomcat.util.bcel.generic.AnnotationEntryGen;
-import org.apache.tomcat.util.bcel.generic.ConstantPoolGen;
 import org.apache.tomcat.util.bcel.util.ByteSequence;
 
 /**
@@ -168,10 +152,7 @@ public abstract class Utility {
     }
 
 
-    public static final String codeToString( byte[] code, ConstantPool constant_pool, int index,
-            int length ) {
-        return codeToString(code, constant_pool, index, length, true);
-    }
+    
 
 
     /**
@@ -427,10 +408,7 @@ public abstract class Utility {
     }
 
 
-    public static final String codeToString( ByteSequence bytes, ConstantPool constant_pool )
-            throws IOException {
-        return codeToString(bytes, constant_pool, true);
-    }
+    
 
 
     /**
@@ -484,145 +462,34 @@ public abstract class Utility {
     }
 
 
-    /**
-     * @return `flag' with bit `i' set to 1
-     */
-    public static final int setBit( int flag, int i ) {
-        return flag | pow2(i);
-    }
+    
 
 
-    /**
-     * @return `flag' with bit `i' set to 0
-     */
-    public static final int clearBit( int flag, int i ) {
-        int bit = pow2(i);
-        return (flag & bit) == 0 ? flag : flag ^ bit;
-    }
+    
 
 
-    /**
-     * @return true, if bit `i' in `flag' is set
-     */
-    public static final boolean isSet( int flag, int i ) {
-        return (flag & pow2(i)) != 0;
-    }
+    
 
 
-    /**
-     * Converts string containing the method return and argument types 
-     * to a byte code method signature.
-     *
-     * @param  ret Return type of method
-     * @param  argv Types of method arguments
-     * @return Byte code representation of method signature
-     */
-    public final static String methodTypeToSignature( String ret, String[] argv )
-            throws ClassFormatException {
-        StringBuffer buf = new StringBuffer("(");
-        String str;
-        if (argv != null) {
-            for (int i = 0; i < argv.length; i++) {
-                str = getSignature(argv[i]);
-                if (str.endsWith("V")) {
-                    throw new ClassFormatException("Invalid type: " + argv[i]);
-                }
-                buf.append(str);
-            }
-        }
-        str = getSignature(ret);
-        buf.append(")").append(str);
-        return buf.toString();
-    }
+    
 
 
-    /**
-     * @param  signature    Method signature
-     * @return Array of argument types
-     * @throws  ClassFormatException  
-     */
-    public static final String[] methodSignatureArgumentTypes( String signature )
-            throws ClassFormatException {
-        return methodSignatureArgumentTypes(signature, true);
-    }
+    
 
 
-    /**
-     * @param  signature    Method signature
-     * @param chopit Shorten class names ?
-     * @return Array of argument types
-     * @throws  ClassFormatException  
-     */
-    public static final String[] methodSignatureArgumentTypes( String signature, boolean chopit )
-            throws ClassFormatException {
-        List vec = new ArrayList();
-        int index;
-        try { // Read all declarations between for `(' and `)'
-            if (signature.charAt(0) != '(') {
-                throw new ClassFormatException("Invalid method signature: " + signature);
-            }
-            index = 1; // current string position
-            while (signature.charAt(index) != ')') {
-                vec.add(signatureToString(signature.substring(index), chopit));
-                //corrected concurrent private static field acess
-                index += unwrap(consumed_chars); // update position
-            }
-        } catch (StringIndexOutOfBoundsException e) { // Should never occur
-            throw new ClassFormatException("Invalid method signature: " + signature, e);
-        }
-        return (String[]) vec.toArray(new String[vec.size()]);
-    }
+    
 
 
-    /**
-     * @param  signature    Method signature
-     * @return return type of method
-     * @throws  ClassFormatException  
-     */
-    public static final String methodSignatureReturnType( String signature )
-            throws ClassFormatException {
-        return methodSignatureReturnType(signature, true);
-    }
+    
 
 
-    /**
-     * @param  signature    Method signature
-     * @param chopit Shorten class names ?
-     * @return return type of method
-     * @throws  ClassFormatException  
-     */
-    public static final String methodSignatureReturnType( String signature, boolean chopit )
-            throws ClassFormatException {
-        int index;
-        String type;
-        try {
-            // Read return type after `)'
-            index = signature.lastIndexOf(')') + 1;
-            type = signatureToString(signature.substring(index), chopit);
-        } catch (StringIndexOutOfBoundsException e) { // Should never occur
-            throw new ClassFormatException("Invalid method signature: " + signature, e);
-        }
-        return type;
-    }
+    
 
 
-    /**
-     * Converts method signature to string with all class names compacted.
-     *
-     * @param signature to convert
-     * @param name of method
-     * @param access flags of method
-     * @return Human readable signature
-     */
-    public static final String methodSignatureToString( String signature, String name, String access ) {
-        return methodSignatureToString(signature, name, access, true);
-    }
+    
 
 
-    public static final String methodSignatureToString( String signature, String name,
-            String access, boolean chopit ) {
-        return methodSignatureToString(signature, name, access, chopit, null);
-    }
+    
 
 
     /**
@@ -839,113 +706,7 @@ public abstract class Utility {
     }
 
 
-    /** Parse Java type such as "char", or "java.lang.String[]" and return the
-     * signature in byte code format, e.g. "C" or "[Ljava/lang/String;" respectively.
-     *
-     * @param  type Java type
-     * @return byte code signature
-     */
-    public static String getSignature( String type ) {
-        StringBuffer buf = new StringBuffer();
-        char[] chars = type.toCharArray();
-        boolean char_found = false, delim = false;
-        int index = -1;
-        loop: for (int i = 0; i < chars.length; i++) {
-            switch (chars[i]) {
-                case ' ':
-                case '\t':
-                case '\n':
-                case '\r':
-                case '\f':
-                    if (char_found) {
-                        delim = true;
-                    }
-                    break;
-                case '[':
-                    if (!char_found) {
-                        throw new RuntimeException("Illegal type: " + type);
-                    }
-                    index = i;
-                    break loop;
-                default:
-                    char_found = true;
-                    if (!delim) {
-                        buf.append(chars[i]);
-                    }
-            }
-        }
-        int brackets = 0;
-        if (index > 0) {
-            brackets = countBrackets(type.substring(index));
-        }
-        type = buf.toString();
-        buf.setLength(0);
-        for (int i = 0; i < brackets; i++) {
-            buf.append('[');
-        }
-        boolean found = false;
-        for (int i = Constants.T_BOOLEAN; (i <= Constants.T_VOID) && !found; i++) {
-            if (Constants.TYPE_NAMES[i].equals(type)) {
-                found = true;
-                buf.append(Constants.SHORT_TYPE_NAMES[i]);
-            }
-        }
-        if (!found) {
-            buf.append('L').append(type.replace('.', '/')).append(';');
-        }
-        return buf.toString();
-    }
-
-
-    private static int countBrackets( String brackets ) {
-        char[] chars = brackets.toCharArray();
-        int count = 0;
-        boolean open = false;
-        for (int i = 0; i < chars.length; i++) {
-            switch (chars[i]) {
-                case '[':
-                    if (open) {
-                        throw new RuntimeException("Illegally nested brackets:" + brackets);
-                    }
-                    open = true;
-                    break;
-                case ']':
-                    if (!open) {
-                        throw new RuntimeException("Illegally nested brackets:" + brackets);
-                    }
-                    open = false;
-                    count++;
-                    break;
-                default:
-                    // Don't care
-            }
-        }
-        if (open) {
-            throw new RuntimeException("Illegally nested brackets:" + brackets);
-        }
-        return count;
-    }
-
-
-    /**
-     * Return type of method signature as a byte value as defined in <em>Constants</em>
-     *
-     * @param  signature in format described above
-     * @return type of method signature
-     * @see    Constants
-     */
-    public static final byte typeOfMethodSignature( String signature ) throws ClassFormatException {
-        int index;
-        try {
-            if (signature.charAt(0) != '(') {
-                throw new ClassFormatException("Invalid method signature: " + signature);
-            }
-            index = signature.lastIndexOf(')') + 1;
-            return typeOfSignature(signature.substring(index));
-        } catch (StringIndexOutOfBoundsException e) {
-            throw new ClassFormatException("Invalid method signature: " + signature, e);
-        }
-    }
+    
 
 
     /**
@@ -989,17 +750,7 @@ public abstract class Utility {
     }
 
 
-    /** Map opcode names to opcode numbers. E.g., return Constants.ALOAD for "aload"
-     */
-    public static short searchOpcode( String name ) {
-        name = name.toLowerCase(Locale.ENGLISH);
-        for (short i = 0; i < Constants.OPCODE_NAMES.length; i++) {
-            if (Constants.OPCODE_NAMES[i].equals(name)) {
-                return i;
-            }
-        }
-        return -1;
-    }
+    
 
 
     /**
@@ -1069,64 +820,22 @@ public abstract class Utility {
     }
 
 
-    static final boolean equals( byte[] a, byte[] b ) {
-        int size;
-        if ((size = a.length) != b.length) {
-            return false;
-        }
-        for (int i = 0; i < size; i++) {
-            if (a[i] != b[i]) {
-                return false;
-            }
-        }
-        return true;
-    }
+    
 
 
-    public static final void printArray( PrintStream out, Object[] obj ) {
-        out.println(printArray(obj, true));
-    }
+    
 
 
-    public static final void printArray( PrintWriter out, Object[] obj ) {
-        out.println(printArray(obj, true));
-    }
+    
 
 
-    public static final String printArray( Object[] obj ) {
-        return printArray(obj, true);
-    }
+    
 
 
-    public static final String printArray( Object[] obj, boolean braces ) {
-        return printArray(obj, braces, false);
-    }
+    
 
 
-    public static final String printArray( Object[] obj, boolean braces, boolean quote ) {
-        if (obj == null) {
-            return null;
-        }
-        StringBuffer buf = new StringBuffer();
-        if (braces) {
-            buf.append('{');
-        }
-        for (int i = 0; i < obj.length; i++) {
-            if (obj[i] != null) {
-                buf.append((quote ? "\"" : "")).append(obj[i].toString()).append(
-                        (quote ? "\"" : ""));
-            } else {
-                buf.append("null");
-            }
-            if (i < obj.length - 1) {
-                buf.append(", ");
-            }
-        }
-        if (braces) {
-            buf.append('}');
-        }
-        return buf.toString();
-    }
+    
 
 
     /** @return true, if character is one of (a, ... z, A, ... Z, 0, ... 9, _)
@@ -1137,72 +846,10 @@ public abstract class Utility {
     }
 
 
-    /** Encode byte array it into Java identifier string, i.e., a string
-     * that only contains the following characters: (a, ... z, A, ... Z,
-     * 0, ... 9, _, $).  The encoding algorithm itself is not too
-     * clever: if the current byte's ASCII value already is a valid Java
-     * identifier part, leave it as it is. Otherwise it writes the
-     * escape character($) followed by <p><ul><li> the ASCII value as a
-     * hexadecimal string, if the value is not in the range
-     * 200..247</li> <li>a Java identifier char not used in a lowercase
-     * hexadecimal string, if the value is in the range
-     * 200..247</li><ul></p>
-     *
-     * <p>This operation inflates the original byte array by roughly 40-50%</p>
-     *
-     * @param bytes the byte array to convert
-     * @param compress use gzip to minimize string
-     */
-    public static String encode( byte[] bytes, boolean compress ) throws IOException {
-        if (compress) {
-            ByteArrayOutputStream baos = new ByteArrayOutputStream();
-            GZIPOutputStream gos = new GZIPOutputStream(baos);
-            gos.write(bytes, 0, bytes.length);
-            gos.close();
-            baos.close();
-            bytes = baos.toByteArray();
-        }
-        CharArrayWriter caw = new CharArrayWriter();
-        JavaWriter jw = new JavaWriter(caw);
-        for (int i = 0; i < bytes.length; i++) {
-            int in = bytes[i] & 0x000000ff; // Normalize to unsigned
-            jw.write(in);
-        }
-        return caw.toString();
-    }
+    
 
 
-    /** Decode a string back to a byte array.
-     *
-     * @param s the string to convert
-     * @param uncompress use gzip to uncompress the stream of bytes
-     */
-    public static byte[] decode( String s, boolean uncompress ) throws IOException {
-        char[] chars = s.toCharArray();
-        CharArrayReader car = new CharArrayReader(chars);
-        JavaReader jr = new JavaReader(car);
-        ByteArrayOutputStream bos = new ByteArrayOutputStream();
-        int ch;
-        while ((ch = jr.read()) >= 0) {
-            bos.write(ch);
-        }
-        bos.close();
-        car.close();
-        jr.close();
-        byte[] bytes = bos.toByteArray();
-        if (uncompress) {
-            GZIPInputStream gis = new GZIPInputStream(new ByteArrayInputStream(bytes));
-            byte[] tmp = new byte[bytes.length * 3]; // Rough estimate
-            int count = 0;
-            int b;
-            while ((b = gis.read()) >= 0) {
-                tmp[count++] = (byte) b;
-            }
-            bytes = new byte[count];
-            System.arraycopy(tmp, 0, bytes, 0, count);
-        }
-        return bytes;
-    }
+    
 
     // A-Z, g-z, _, $
     private static final int FREE_CHARS = 48;
@@ -1347,179 +994,9 @@ public abstract class Utility {
     }
 
 
-    /**
-     * Converts a list of AnnotationGen objects into a set of attributes 
-     * that can be attached to the class file.
-     *
-     * @param cp The constant pool gen where we can create the necessary name refs
-     * @param vec A list of AnnotationGen objects
-     */
-    public static Attribute[] getAnnotationAttributes(ConstantPoolGen cp,List vec) {
-    	
-    	if (vec.isEmpty()) return new Attribute[0];
-    	
-    	try {
-    		int countVisible   = 0;
-    		int countInvisible = 0;
-    	
-    		//  put the annotations in the right output stream
-    		for (int i=0; i<vec.size(); i++) {
-    			AnnotationEntryGen a = (AnnotationEntryGen)vec.get(i);
-    			if (a.isRuntimeVisible()) countVisible++;
-    			else			   countInvisible++;
-    		}
-    	
-    		ByteArrayOutputStream rvaBytes = new ByteArrayOutputStream();
-    		ByteArrayOutputStream riaBytes = new ByteArrayOutputStream();
-    		DataOutputStream rvaDos = new DataOutputStream(rvaBytes);
-    		DataOutputStream riaDos = new DataOutputStream(riaBytes);
-    	
-    		rvaDos.writeShort(countVisible);
-    		riaDos.writeShort(countInvisible);
-
-    		// put the annotations in the right output stream
-    		for (int i=0; i<vec.size(); i++) {
-    			AnnotationEntryGen a = (AnnotationEntryGen)vec.get(i);
-    			if (a.isRuntimeVisible()) a.dump(rvaDos);
-    			else			   a.dump(riaDos);
-    		}
-
-      rvaDos.close();
-      riaDos.close();
-      
-      byte[] rvaData = rvaBytes.toByteArray();
-      byte[] riaData = riaBytes.toByteArray();
-      
-      int rvaIndex = -1;
-      int riaIndex = -1;
-      
-      if (rvaData.length>2) rvaIndex = cp.addUtf8("RuntimeVisibleAnnotations");
-      if (riaData.length>2) riaIndex = cp.addUtf8("RuntimeInvisibleAnnotations");
-
-    	List newAttributes = new ArrayList();
-    	if (rvaData.length>2) {
-    		
-    		newAttributes.add(
-    		  new RuntimeVisibleAnnotations(rvaIndex,rvaData.length,new DataInputStream(new ByteArrayInputStream(rvaData)),cp.getConstantPool()));
-    	}
-    	if (riaData.length>2) {
-    		newAttributes.add(
-    		  new RuntimeInvisibleAnnotations(riaIndex,riaData.length,new DataInputStream(new ByteArrayInputStream(riaData)),cp.getConstantPool()));
-    	}
-
-    	return (Attribute[])newAttributes.toArray(new Attribute[newAttributes.size()]);
-    	} catch (IOException e) {
-    		System.err.println("IOException whilst processing annotations");
-  		e.printStackTrace();
-  	}
-    	return null;
-    }
+    
 
 
-    /**
-	 * Annotations against a class are stored in one of four attribute kinds:
-	 * - RuntimeVisibleParameterAnnotations
-	 * - RuntimeInvisibleParameterAnnotations
-	 */
-	public static Attribute[] getParameterAnnotationAttributes(
-			ConstantPoolGen cp,
-			List[] /*Array of lists, array size depends on #params */vec)
-	{
-		int visCount[] = new int[vec.length];
-		int totalVisCount = 0;
-		int invisCount[] = new int[vec.length];
-		int totalInvisCount = 0;
-		try
-		{
-			for (int i = 0; i < vec.length; i++)
-			{
-				List l = vec[i];
-				if (l != null)
-				{
-					for (Iterator iter = l.iterator(); iter.hasNext();)
-					{
-						AnnotationEntryGen element = (AnnotationEntryGen) iter.next();
-						if (element.isRuntimeVisible())
-						{
-							visCount[i]++;
-							totalVisCount++;
-						}
-						else
-						{
-							invisCount[i]++;
-							totalInvisCount++;
-						}
-					}
-				}
-			}
-			// Lets do the visible ones
-			ByteArrayOutputStream rvaBytes = new ByteArrayOutputStream();
-			DataOutputStream rvaDos = new DataOutputStream(rvaBytes);
-			rvaDos.writeByte(vec.length); // First goes number of parameters
-			for (int i = 0; i < vec.length; i++)
-			{
-				rvaDos.writeShort(visCount[i]);
-				if (visCount[i] > 0)
-				{
-					List l = vec[i];
-					for (Iterator iter = l.iterator(); iter.hasNext();)
-					{
-						AnnotationEntryGen element = (AnnotationEntryGen) iter.next();
-						if (element.isRuntimeVisible())
-							element.dump(rvaDos);
-					}
-				}
-			}
-			rvaDos.close();
-			// Lets do the invisible ones
-			ByteArrayOutputStream riaBytes = new ByteArrayOutputStream();
-			DataOutputStream riaDos = new DataOutputStream(riaBytes);
-			riaDos.writeByte(vec.length); // First goes number of parameters
-			for (int i = 0; i < vec.length; i++)
-			{
-				riaDos.writeShort(invisCount[i]);
-				if (invisCount[i] > 0)
-				{
-					List l = vec[i];
-					for (Iterator iter = l.iterator(); iter.hasNext();)
-					{
-						AnnotationEntryGen element = (AnnotationEntryGen) iter.next();
-						if (!element.isRuntimeVisible())
-							element.dump(riaDos);
-					}
-				}
-			}
-			riaDos.close();
-			byte[] rvaData = rvaBytes.toByteArray();
-			byte[] riaData = riaBytes.toByteArray();
-			int rvaIndex = -1;
-			int riaIndex = -1;
-			if (totalVisCount > 0)
-				rvaIndex = cp.addUtf8("RuntimeVisibleParameterAnnotations");
-			if (totalInvisCount > 0)
-				riaIndex = cp.addUtf8("RuntimeInvisibleParameterAnnotations");
-			List newAttributes = new ArrayList();
-			if (totalVisCount > 0)
-			{
-				newAttributes
-						.add(new RuntimeVisibleParameterAnnotations(rvaIndex,
-								rvaData.length, new DataInputStream(new ByteArrayInputStream(rvaData)), cp.getConstantPool()));
-			}
-			if (totalInvisCount > 0)
-			{
-				newAttributes
-						.add(new RuntimeInvisibleParameterAnnotations(riaIndex,
-								riaData.length, new DataInputStream(new ByteArrayInputStream(riaData)), cp.getConstantPool()));
-			}
-			return (Attribute[]) newAttributes.toArray(new Attribute[newAttributes.size()]);
-		}
-		catch (IOException e)
-		{
-			System.err
-					.println("IOException whilst processing parameter annotations");
-			e.printStackTrace();
-		}
-		return null;
-	}
+    
 
 }

==================================================
AALOAD.java
index 1d8305f11e..5849b13066 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/Visitor.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/Visitor.java
@@ -28,7 +28,7 @@ public interface Visitor
 {
 	public void visitCode(Code obj);
 
-	public void visitCodeException(CodeException obj);
+	
 
 	public void visitConstantClass(ConstantClass obj);
 
@@ -48,7 +48,7 @@ public interface Visitor
 
 	public void visitConstantNameAndType(ConstantNameAndType obj);
 
-	public void visitConstantPool(ConstantPool obj);
+	
 
 	public void visitConstantString(ConstantString obj);
 
@@ -60,23 +60,23 @@ public interface Visitor
 
 	public void visitExceptionTable(ExceptionTable obj);
 
-	public void visitField(Field obj);
+	
 
-	public void visitInnerClass(InnerClass obj);
+	
 
 	public void visitInnerClasses(InnerClasses obj);
 
-	public void visitJavaClass(JavaClass obj);
+	
 
-	public void visitLineNumber(LineNumber obj);
+	
 
 	public void visitLineNumberTable(LineNumberTable obj);
 
-	public void visitLocalVariable(LocalVariable obj);
+	
 
 	public void visitLocalVariableTable(LocalVariableTable obj);
 
-	public void visitMethod(Method obj);
+	
 
 	public void visitSignature(Signature obj);
 
@@ -88,19 +88,19 @@ public interface Visitor
 
 	public void visitStackMap(StackMap obj);
 
-	public void visitStackMapEntry(StackMapEntry obj);
+	
 
 	public void visitStackMapTable(StackMapTable obj);
 
-	public void visitStackMapTableEntry(StackMapTableEntry obj);
+	
 
 	public void visitAnnotation(Annotations obj);
 
-	public void visitParameterAnnotation(ParameterAnnotations obj);
+	
 
-	public void visitAnnotationEntry(AnnotationEntry obj);
+	
 
-	public void visitAnnotationDefault(AnnotationDefault obj);
+	
 
 	public void visitLocalVariableTypeTable(LocalVariableTypeTable obj);
 

==================================================
AASTORE.java
deleted file mode 100644
index d5910c0396..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/AALOAD.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * AALOAD - Load reference from array
- * <PRE>Stack: ..., arrayref, index -&gt; value</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class AALOAD extends ArrayInstruction implements StackProducer {
-
-    /** Load reference from array
-     */
-    public AALOAD() {
-        super(org.apache.tomcat.util.bcel.Constants.AALOAD);
-    }
-}

==================================================
ACONST_NULL.java
deleted file mode 100644
index 45b9fca2f9..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/AASTORE.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * AASTORE -  Store into reference array
- * <PRE>Stack: ..., arrayref, index, value -&gt; ...</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class AASTORE extends ArrayInstruction implements StackConsumer {
-
-    /** Store into reference array
-     */
-    public AASTORE() {
-        super(org.apache.tomcat.util.bcel.Constants.AASTORE);
-    }
-}

==================================================
ANEWARRAY.java
deleted file mode 100644
index ac8ece469a..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/ACONST_NULL.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * ACONST_NULL - Push null reference
- * <PRE>Stack: ... -&gt; ..., null</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class ACONST_NULL extends Instruction implements PushInstruction, TypedInstruction {
-
-    /** 
-     * Push null reference
-     */
-    public ACONST_NULL() {
-        super(org.apache.tomcat.util.bcel.Constants.ACONST_NULL, (short) 1);
-    }
-
-
-    /** @return Type.NULL
-     */
-    public Type getType( ConstantPoolGen cp ) {
-        return Type.NULL;
-    }
-}

==================================================
ARETURN.java
index a6c46a8147..355f1db7b8 100644
--- a/java/org/apache/tomcat/util/bcel/generic/ANEWARRAY.java
+++ b/java/org/apache/tomcat/util/bcel/generic/ANEWARRAY.java
@@ -16,8 +16,6 @@
  */
 package org.apache.tomcat.util.bcel.generic;
 
-import org.apache.tomcat.util.bcel.ExceptionConstants;
-
 /** 
  * ANEWARRAY -  Create new array of references
  * <PRE>Stack: ..., count -&gt; ..., arrayref</PRE>
@@ -36,25 +34,11 @@ public class ANEWARRAY extends CPInstruction implements LoadClass, AllocationIns
     }
 
 
-    public ANEWARRAY(int index) {
-        super(org.apache.tomcat.util.bcel.Constants.ANEWARRAY, index);
-    }
+    
 
 
-    public Class[] getExceptions() {
-        Class[] cs = new Class[1 + ExceptionConstants.EXCS_CLASS_AND_INTERFACE_RESOLUTION.length];
-        System.arraycopy(ExceptionConstants.EXCS_CLASS_AND_INTERFACE_RESOLUTION, 0, cs, 0,
-                ExceptionConstants.EXCS_CLASS_AND_INTERFACE_RESOLUTION.length);
-        cs[ExceptionConstants.EXCS_CLASS_AND_INTERFACE_RESOLUTION.length] = ExceptionConstants.NEGATIVE_ARRAY_SIZE_EXCEPTION;
-        return cs;
-    }
+    
 
 
-    public ObjectType getLoadClassType( ConstantPoolGen cpg ) {
-        Type t = getType(cpg);
-        if (t instanceof ArrayType) {
-            t = ((ArrayType) t).getBasicType();
-        }
-        return (t instanceof ObjectType) ? (ObjectType) t : null;
-    }
+    
 }

==================================================
ARRAYLENGTH.java
deleted file mode 100644
index e8c6597233..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/ARETURN.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * ARETURN -  Return reference from method
- * <PRE>Stack: ..., objectref -&gt; &lt;empty&gt;</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class ARETURN extends ReturnInstruction {
-
-    /** 
-     * Return reference from method
-     */
-    public ARETURN() {
-        super(org.apache.tomcat.util.bcel.Constants.ARETURN);
-    }
-}

==================================================
ATHROW.java
deleted file mode 100644
index fb2840c507..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/ARRAYLENGTH.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * ARRAYLENGTH -  Get length of array
- * <PRE>Stack: ..., arrayref -&gt; ..., length</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class ARRAYLENGTH extends Instruction implements ExceptionThrower, StackProducer, StackConsumer {
-
-    /** Get length of array
-     */
-    public ARRAYLENGTH() {
-        super(org.apache.tomcat.util.bcel.Constants.ARRAYLENGTH, (short) 1);
-    }
-
-
-    /** @return exceptions this instruction may cause
-     */
-    public Class[] getExceptions() {
-        return new Class[] {
-            org.apache.tomcat.util.bcel.ExceptionConstants.NULL_POINTER_EXCEPTION
-        };
-    }
-}

==================================================
AnnotationElementValueGen.java
deleted file mode 100644
index daff3dc4c8..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/ATHROW.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * ATHROW -  Throw exception
- * <PRE>Stack: ..., objectref -&gt; objectref</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class ATHROW extends Instruction implements UnconditionalBranch, ExceptionThrower {
-
-    /** 
-     *  Throw exception
-     */
-    public ATHROW() {
-        super(org.apache.tomcat.util.bcel.Constants.ATHROW, (short) 1);
-    }
-
-
-    /** @return exceptions this instruction may cause
-     */
-    public Class[] getExceptions() {
-        return new Class[] {
-            org.apache.tomcat.util.bcel.ExceptionConstants.THROWABLE
-        };
-    }
-}

==================================================
AnnotationEntryGen.java
index dc1a468eb3..c5b07ee95c 100644
--- a/java/org/apache/tomcat/util/bcel/generic/AnnotationElementValueGen.java
+++ b/java/org/apache/tomcat/util/bcel/generic/AnnotationElementValueGen.java
@@ -10,21 +10,9 @@ public class AnnotationElementValueGen extends ElementValueGen
 	// For annotation element values, this is the annotation
 	private AnnotationEntryGen a;
 
-	public AnnotationElementValueGen(AnnotationEntryGen a, ConstantPoolGen cpool)
-	{
-		super(ANNOTATION, cpool);
-		this.a = a;
-	}
+	
 
-	public AnnotationElementValueGen(int type, AnnotationEntryGen annotation,
-			ConstantPoolGen cpool)
-	{
-		super(type, cpool);
-		if (type != ANNOTATION)
-			throw new RuntimeException(
-					"Only element values of type annotation can be built with this ctor - type specified: " + type);
-		this.a = annotation;
-	}
+	
 
 	public AnnotationElementValueGen(AnnotationElementValue value,
 			ConstantPoolGen cpool, boolean copyPoolEntries)
@@ -53,8 +41,5 @@ public class AnnotationElementValueGen extends ElementValueGen
 				.getConstantPool());
 	}
 
-	public AnnotationEntryGen getAnnotation()
-	{
-		return a;
-	}
+	
 }

==================================================
ArithmeticInstruction.java
index ee0d0be402..57857c2f21 100755
--- a/java/org/apache/tomcat/util/bcel/generic/AnnotationEntryGen.java
+++ b/java/org/apache/tomcat/util/bcel/generic/AnnotationEntryGen.java
@@ -1,6 +1,5 @@
 package org.apache.tomcat.util.bcel.generic;
 
-import java.io.DataInputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
 import java.util.ArrayList;
@@ -58,11 +57,6 @@ public class AnnotationEntryGen
 		return out;
 	}
 
-	private AnnotationEntryGen(ConstantPoolGen cpool)
-	{
-		this.cpool = cpool;
-	}
-
 	/**
 	 * Retrieve an immutable version of this AnnotationGen
 	 */
@@ -79,31 +73,9 @@ public class AnnotationEntryGen
 		return a;
 	}
 
-	public AnnotationEntryGen(ObjectType type,
-			List /* ElementNameValuePairGen */elements, boolean vis,
-			ConstantPoolGen cpool)
-	{
-		this.cpool = cpool;
-		this.typeIndex = cpool.addUtf8(type.getSignature());
-		evs = elements;
-		isRuntimeVisible = vis;
-	}
+	
 
-	public static AnnotationEntryGen read(DataInputStream dis,
-			ConstantPoolGen cpool, boolean b) throws IOException
-	{
-		AnnotationEntryGen a = new AnnotationEntryGen(cpool);
-		a.typeIndex = dis.readUnsignedShort();
-		int elemValuePairCount = dis.readUnsignedShort();
-		for (int i = 0; i < elemValuePairCount; i++)
-		{
-			int nidx = dis.readUnsignedShort();
-			a.addElementNameValuePair(new ElementValuePairGen(nidx,
-					ElementValueGen.readElementValue(dis, cpool), cpool));
-		}
-		a.isRuntimeVisible(b);
-		return a;
-	}
+	
 
 	public void dump(DataOutputStream dos) throws IOException
 	{
@@ -116,17 +88,9 @@ public class AnnotationEntryGen
 		}
 	}
 
-	public void addElementNameValuePair(ElementValuePairGen evp)
-	{
-		if (evs == null)
-			evs = new ArrayList();
-		evs.add(evp);
-	}
+	
 
-	public int getTypeIndex()
-	{
-		return typeIndex;
-	}
+	
 
 	public final String getTypeSignature()
 	{
@@ -142,13 +106,7 @@ public class AnnotationEntryGen
 									// Utility.signatureToString(getTypeSignature());
 	}
 
-	/**
-	 * Returns list of ElementNameValuePair objects
-	 */
-	public List getValues()
-	{
-		return evs;
-	}
+	
 
 	public String toString()
 	{
@@ -164,27 +122,7 @@ public class AnnotationEntryGen
 		return s.toString();
 	}
 
-	public String toShortString()
-	{
-		StringBuffer s = new StringBuffer();
-		s.append("@" + getTypeName() + "(");
-		for (int i = 0; i < evs.size(); i++)
-		{
-			s.append(evs.get(i));
-			if (i + 1 < evs.size())
-				s.append(",");
-		}
-		s.append(")");
-		return s.toString();
-	}
-
-	private void isRuntimeVisible(boolean b)
-	{
-		isRuntimeVisible = b;
-	}
+	
 
-	public boolean isRuntimeVisible()
-	{
-		return isRuntimeVisible;
-	}
+	
 }

==================================================
ArrayElementValueGen.java
deleted file mode 100644
index 1337f63c50..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/ArithmeticInstruction.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-import org.apache.tomcat.util.bcel.Constants;
-
-/**
- * Super class for the family of arithmetic instructions.
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public abstract class ArithmeticInstruction extends Instruction implements TypedInstruction,
-        StackProducer, StackConsumer {
-
-    /**
-     * Empty constructor needed for the Class.newInstance() statement in
-     * Instruction.readInstruction(). Not to be used otherwise.
-     */
-    ArithmeticInstruction() {
-    }
-
-
-    /**
-     * @param opcode of instruction
-     */
-    protected ArithmeticInstruction(short opcode) {
-        super(opcode, (short) 1);
-    }
-
-
-    /** @return type associated with the instruction
-     */
-    public Type getType( ConstantPoolGen cp ) {
-        switch (opcode) {
-            case Constants.DADD:
-            case Constants.DDIV:
-            case Constants.DMUL:
-            case Constants.DNEG:
-            case Constants.DREM:
-            case Constants.DSUB:
-                return Type.DOUBLE;
-            case Constants.FADD:
-            case Constants.FDIV:
-            case Constants.FMUL:
-            case Constants.FNEG:
-            case Constants.FREM:
-            case Constants.FSUB:
-                return Type.FLOAT;
-            case Constants.IADD:
-            case Constants.IAND:
-            case Constants.IDIV:
-            case Constants.IMUL:
-            case Constants.INEG:
-            case Constants.IOR:
-            case Constants.IREM:
-            case Constants.ISHL:
-            case Constants.ISHR:
-            case Constants.ISUB:
-            case Constants.IUSHR:
-            case Constants.IXOR:
-                return Type.INT;
-            case Constants.LADD:
-            case Constants.LAND:
-            case Constants.LDIV:
-            case Constants.LMUL:
-            case Constants.LNEG:
-            case Constants.LOR:
-            case Constants.LREM:
-            case Constants.LSHL:
-            case Constants.LSHR:
-            case Constants.LSUB:
-            case Constants.LUSHR:
-            case Constants.LXOR:
-                return Type.LONG;
-            default: // Never reached
-                throw new ClassGenException("Unknown type " + opcode);
-        }
-    }
-}

==================================================
ArrayInstruction.java
index f05b149073..6fb40e213c 100644
--- a/java/org/apache/tomcat/util/bcel/generic/ArrayElementValueGen.java
+++ b/java/org/apache/tomcat/util/bcel/generic/ArrayElementValueGen.java
@@ -14,25 +14,9 @@ public class ArrayElementValueGen extends ElementValueGen
 	// modify ...
 	private List /* ElementValueGen */evalues;
 
-	public ArrayElementValueGen(ConstantPoolGen cp)
-	{
-		super(ARRAY, cp);
-		evalues = new ArrayList();
-	}
+	
 
-	public ArrayElementValueGen(int type, ElementValue[] datums,
-			ConstantPoolGen cpool)
-	{
-		super(type, cpool);
-		if (type != ARRAY)
-			throw new RuntimeException(
-					"Only element values of type array can be built with this ctor - type specified: " + type);
-		this.evalues = new ArrayList();
-		for (int i = 0; i < datums.length; i++)
-		{
-			evalues.add(datums[i]);
-		}
-	}
+	
 
 	/**
 	 * Return immutable variant of this ArrayElementValueGen
@@ -92,18 +76,9 @@ public class ArrayElementValueGen extends ElementValueGen
 		return sb.toString();
 	}
 
-	public List getElementValues()
-	{
-		return evalues;
-	}
+	
 
-	public int getElementValuesSize()
-	{
-		return evalues.size();
-	}
+	
 
-	public void addElement(ElementValueGen gen)
-	{
-		evalues.add(gen);
-	}
+	
 }

==================================================
ArrayType.java
deleted file mode 100644
index ac358d9880..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/ArrayInstruction.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * Super class for instructions dealing with array access such as IALOAD.
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public abstract class ArrayInstruction extends Instruction implements ExceptionThrower,
-        TypedInstruction {
-
-    /**
-     * Empty constructor needed for the Class.newInstance() statement in
-     * Instruction.readInstruction(). Not to be used otherwise.
-     */
-    ArrayInstruction() {
-    }
-
-
-    /**
-     * @param opcode of instruction
-     */
-    protected ArrayInstruction(short opcode) {
-        super(opcode, (short) 1);
-    }
-
-
-    public Class[] getExceptions() {
-        return org.apache.tomcat.util.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
-    }
-
-
-    /** @return type associated with the instruction
-     */
-    public Type getType( ConstantPoolGen cp ) {
-        switch (opcode) {
-            case org.apache.tomcat.util.bcel.Constants.IALOAD:
-            case org.apache.tomcat.util.bcel.Constants.IASTORE:
-                return Type.INT;
-            case org.apache.tomcat.util.bcel.Constants.CALOAD:
-            case org.apache.tomcat.util.bcel.Constants.CASTORE:
-                return Type.CHAR;
-            case org.apache.tomcat.util.bcel.Constants.BALOAD:
-            case org.apache.tomcat.util.bcel.Constants.BASTORE:
-                return Type.BYTE;
-            case org.apache.tomcat.util.bcel.Constants.SALOAD:
-            case org.apache.tomcat.util.bcel.Constants.SASTORE:
-                return Type.SHORT;
-            case org.apache.tomcat.util.bcel.Constants.LALOAD:
-            case org.apache.tomcat.util.bcel.Constants.LASTORE:
-                return Type.LONG;
-            case org.apache.tomcat.util.bcel.Constants.DALOAD:
-            case org.apache.tomcat.util.bcel.Constants.DASTORE:
-                return Type.DOUBLE;
-            case org.apache.tomcat.util.bcel.Constants.FALOAD:
-            case org.apache.tomcat.util.bcel.Constants.FASTORE:
-                return Type.FLOAT;
-            case org.apache.tomcat.util.bcel.Constants.AALOAD:
-            case org.apache.tomcat.util.bcel.Constants.AASTORE:
-                return Type.OBJECT;
-            default:
-                throw new ClassGenException("Oops: unknown case in switch" + opcode);
-        }
-    }
-}

==================================================
BALOAD.java
index 58088a40d2..36ab2ad170 100644
--- a/java/org/apache/tomcat/util/bcel/generic/ArrayType.java
+++ b/java/org/apache/tomcat/util/bcel/generic/ArrayType.java
@@ -30,24 +30,10 @@ public final class ArrayType extends ReferenceType {
     private Type basic_type;
 
 
-    /**
-     * Convenience constructor for array type, e.g. int[]
-     *
-     * @param type array type, e.g. T_INT
-     */
-    public ArrayType(byte type, int dimensions) {
-        this(BasicType.getType(type), dimensions);
-    }
+    
 
 
-    /**
-     * Convenience constructor for reference array type, e.g. Object[]
-     *
-     * @param class_name complete name of class (java.lang.String, e.g.)
-     */
-    public ArrayType(String class_name, int dimensions) {
-        this(new ObjectType(class_name), dimensions);
-    }
+    
 
 
     /**
@@ -82,30 +68,13 @@ public final class ArrayType extends ReferenceType {
     }
 
 
-    /**
-     * @return basic type of array, i.e., for int[][][] the basic type is int
-     */
-    public Type getBasicType() {
-        return basic_type;
-    }
+    
 
 
-    /**
-     * @return element type of array, i.e., for int[][][] the element type is int[][]
-     */
-    public Type getElementType() {
-        if (dimensions == 1) {
-            return basic_type;
-        }
-        return new ArrayType(basic_type, dimensions - 1);
-    }
+    
 
 
-    /** @return number of dimensions of array
-     */
-    public int getDimensions() {
-        return dimensions;
-    }
+    
 
 
     /** @return a hash code value for the object.

==================================================
BASTORE.java
deleted file mode 100644
index 5351d8f25b..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/BALOAD.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * BALOAD - Load byte or boolean from array
- * <PRE>Stack: ..., arrayref, index -&gt; ..., value</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class BALOAD extends ArrayInstruction implements StackProducer {
-
-    /** Load byte or boolean from array
-     */
-    public BALOAD() {
-        super(org.apache.tomcat.util.bcel.Constants.BALOAD);
-    }
-}

==================================================
BIPUSH.java
deleted file mode 100644
index 9b92380461..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/BASTORE.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * BASTORE -  Store into byte or boolean array
- * <PRE>Stack: ..., arrayref, index, value -&gt; ...</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class BASTORE extends ArrayInstruction implements StackConsumer {
-
-    /** Store byte or boolean into array
-     */
-    public BASTORE() {
-        super(org.apache.tomcat.util.bcel.Constants.BASTORE);
-    }
-}

==================================================
BranchHandle.java
index dce4dcddb6..125010ad5d 100644
--- a/java/org/apache/tomcat/util/bcel/generic/BIPUSH.java
+++ b/java/org/apache/tomcat/util/bcel/generic/BIPUSH.java
@@ -41,12 +41,7 @@ public class BIPUSH extends Instruction implements ConstantPushInstruction {
     }
 
 
-    /** Push byte on stack
-     */
-    public BIPUSH(byte b) {
-        super(org.apache.tomcat.util.bcel.Constants.BIPUSH, (short) 2);
-        this.b = b;
-    }
+    
 
 
     /**

==================================================
CALOAD.java
index bd436d9528..f800bb443a 100644
--- a/java/org/apache/tomcat/util/bcel/generic/BranchHandle.java
+++ b/java/org/apache/tomcat/util/bcel/generic/BranchHandle.java
@@ -83,28 +83,13 @@ public final class BranchHandle extends InstructionHandle {
     }
 
 
-    /**
-     * Pass new target to instruction.
-     */
-    public void setTarget( InstructionHandle ih ) {
-        bi.setTarget(ih);
-    }
+    
 
 
-    /**
-     * Update target of instruction.
-     */
-    public void updateTarget( InstructionHandle old_ih, InstructionHandle new_ih ) {
-        bi.updateTarget(old_ih, new_ih);
-    }
+    
 
 
-    /**
-     * @return target of instruction.
-     */
-    public InstructionHandle getTarget() {
-        return bi.getTarget();
-    }
+    
 
 
     /** 

==================================================
CASTORE.java
deleted file mode 100644
index 1152bea594..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/CALOAD.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * CALOAD - Load char from array
- * <PRE>Stack: ..., arrayref, index -&gt; ..., value</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class CALOAD extends ArrayInstruction implements StackProducer {
-
-    /** Load char from array
-     */
-    public CALOAD() {
-        super(org.apache.tomcat.util.bcel.Constants.CALOAD);
-    }
-}

==================================================
CHECKCAST.java
deleted file mode 100644
index 56b82e02c3..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/CASTORE.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * CASTORE -  Store into char array
- * <PRE>Stack: ..., arrayref, index, value -&gt; ...</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class CASTORE extends ArrayInstruction implements StackConsumer {
-
-    /** Store char into array
-     */
-    public CASTORE() {
-        super(org.apache.tomcat.util.bcel.Constants.CASTORE);
-    }
-}

==================================================
ClassElementValueGen.java
index 633c980305..b27395fbe6 100644
--- a/java/org/apache/tomcat/util/bcel/generic/CHECKCAST.java
+++ b/java/org/apache/tomcat/util/bcel/generic/CHECKCAST.java
@@ -16,8 +16,6 @@
  */
 package org.apache.tomcat.util.bcel.generic;
 
-import org.apache.tomcat.util.bcel.ExceptionConstants;
-
 /** 
  * CHECKCAST - Check whether object is of given type
  * <PRE>Stack: ..., objectref -&gt; ..., objectref</PRE>
@@ -36,30 +34,11 @@ public class CHECKCAST extends CPInstruction implements LoadClass, ExceptionThro
     }
 
 
-    /** Check whether object is of given type
-     * @param index index to class in constant pool
-     */
-    public CHECKCAST(int index) {
-        super(org.apache.tomcat.util.bcel.Constants.CHECKCAST, index);
-    }
+    
 
 
-    /** @return exceptions this instruction may cause
-     */
-    public Class[] getExceptions() {
-        Class[] cs = new Class[1 + ExceptionConstants.EXCS_CLASS_AND_INTERFACE_RESOLUTION.length];
-        System.arraycopy(ExceptionConstants.EXCS_CLASS_AND_INTERFACE_RESOLUTION, 0, cs, 0,
-                ExceptionConstants.EXCS_CLASS_AND_INTERFACE_RESOLUTION.length);
-        cs[ExceptionConstants.EXCS_CLASS_AND_INTERFACE_RESOLUTION.length] = ExceptionConstants.CLASS_CAST_EXCEPTION;
-        return cs;
-    }
+    
 
 
-    public ObjectType getLoadClassType( ConstantPoolGen cpg ) {
-        Type t = getType(cpg);
-        if (t instanceof ArrayType) {
-            t = ((ArrayType) t).getBasicType();
-        }
-        return (t instanceof ObjectType) ? (ObjectType) t : null;
-    }
+    
 }

==================================================
ClassGen.java
index 0910815a1f..58dd8eb0a2 100644
--- a/java/org/apache/tomcat/util/bcel/generic/ClassElementValueGen.java
+++ b/java/org/apache/tomcat/util/bcel/generic/ClassElementValueGen.java
@@ -6,7 +6,6 @@ import org.apache.tomcat.util.bcel.classfile.ElementValue;
 import org.apache.tomcat.util.bcel.classfile.ConstantUtf8;
 import org.apache.tomcat.util.bcel.classfile.ClassElementValue;
 import org.apache.tomcat.util.bcel.generic.ConstantPoolGen;
-import org.apache.tomcat.util.bcel.generic.ObjectType;
 import org.apache.tomcat.util.bcel.generic.ElementValueGen;
 
 public class ClassElementValueGen extends ElementValueGen
@@ -16,18 +15,9 @@ public class ClassElementValueGen extends ElementValueGen
 	// For 'class' this points to the class entry in the cpool
 	private int idx;
 
-	protected ClassElementValueGen(int typeIdx, ConstantPoolGen cpool)
-	{
-		super(ElementValueGen.CLASS, cpool);
-		this.idx = typeIdx;
-	}
+	
 
-	public ClassElementValueGen(ObjectType t, ConstantPoolGen cpool)
-	{
-		super(ElementValueGen.CLASS, cpool);
-		// this.idx = cpool.addClass(t);
-		idx = cpool.addUtf8(t.getSignature());
-	}
+	
 
 	/**
 	 * Return immutable variant of this ClassElementValueGen
@@ -52,10 +42,7 @@ public class ClassElementValueGen extends ElementValueGen
 		}
 	}
 
-	public int getIndex()
-	{
-		return idx;
-	}
+	
 
 	public String getClassString()
 	{

==================================================
ClassGenException.java
index e730ff9476..130870a23d 100644
--- a/java/org/apache/tomcat/util/bcel/generic/ClassGen.java
+++ b/java/org/apache/tomcat/util/bcel/generic/ClassGen.java
@@ -17,22 +17,11 @@
 package org.apache.tomcat.util.bcel.generic;
 
 import java.util.ArrayList;
-import java.util.Iterator;
 import java.util.List;
 
 import org.apache.tomcat.util.bcel.Constants;
 import org.apache.tomcat.util.bcel.classfile.AccessFlags;
-import org.apache.tomcat.util.bcel.classfile.AnnotationEntry;
-import org.apache.tomcat.util.bcel.classfile.Annotations;
-import org.apache.tomcat.util.bcel.classfile.Attribute;
-import org.apache.tomcat.util.bcel.classfile.ConstantPool;
-import org.apache.tomcat.util.bcel.classfile.Field;
 import org.apache.tomcat.util.bcel.classfile.JavaClass;
-import org.apache.tomcat.util.bcel.classfile.Method;
-import org.apache.tomcat.util.bcel.classfile.RuntimeInvisibleAnnotations;
-import org.apache.tomcat.util.bcel.classfile.RuntimeVisibleAnnotations;
-import org.apache.tomcat.util.bcel.classfile.SourceFile;
-import org.apache.tomcat.util.bcel.classfile.Utility;
 import org.apache.tomcat.util.bcel.util.BCELComparator;
 
 /** 
@@ -74,491 +63,84 @@ public class ClassGen extends AccessFlags implements Cloneable {
     };
 
 
-    /** Convenience constructor to set up some important values initially.
-     *
-     * @param class_name fully qualified class name
-     * @param super_class_name fully qualified superclass name
-     * @param file_name source file name
-     * @param access_flags access qualifiers
-     * @param interfaces implemented interfaces
-     * @param cp constant pool to use
-     */
-    public ClassGen(String class_name, String super_class_name, String file_name, int access_flags,
-            String[] interfaces, ConstantPoolGen cp) {
-        this.class_name = class_name;
-        this.super_class_name = super_class_name;
-        this.file_name = file_name;
-        this.access_flags = access_flags;
-        this.cp = cp;
-        // Put everything needed by default into the constant pool and the vectors
-        if (file_name != null) {
-            addAttribute(new SourceFile(cp.addUtf8("SourceFile"), 2, cp.addUtf8(file_name), cp
-                    .getConstantPool()));
-        }
-        class_name_index = cp.addClass(class_name);
-        superclass_name_index = cp.addClass(super_class_name);
-        if (interfaces != null) {
-            for (int i = 0; i < interfaces.length; i++) {
-                addInterface(interfaces[i]);
-            }
-        }
-    }
-
-
-    /** Convenience constructor to set up some important values initially.
-     *
-     * @param class_name fully qualified class name
-     * @param super_class_name fully qualified superclass name
-     * @param file_name source file name
-     * @param access_flags access qualifiers
-     * @param interfaces implemented interfaces
-     */
-    public ClassGen(String class_name, String super_class_name, String file_name, int access_flags,
-            String[] interfaces) {
-        this(class_name, super_class_name, file_name, access_flags, interfaces,
-                new ConstantPoolGen());
-    }
-
-
-    /**
-     * Initialize with existing class.
-     * @param clazz JavaClass object (e.g. read from file)
-     */
-    public ClassGen(JavaClass clazz) {
-        class_name_index = clazz.getClassNameIndex();
-        superclass_name_index = clazz.getSuperclassNameIndex();
-        class_name = clazz.getClassName();
-        super_class_name = clazz.getSuperclassName();
-        file_name = clazz.getSourceFileName();
-        access_flags = clazz.getAccessFlags();
-        cp = new ConstantPoolGen(clazz.getConstantPool());
-        major = clazz.getMajor();
-        minor = clazz.getMinor();
-        Attribute[] attributes = clazz.getAttributes();
-        // J5TODO: Could make unpacking lazy, done on first reference
-        AnnotationEntryGen[] annotations = unpackAnnotations(attributes);
-        Method[] methods = clazz.getMethods();
-        Field[] fields = clazz.getFields();
-        String[] interfaces = clazz.getInterfaceNames();
-        for (int i = 0; i < interfaces.length; i++) {
-            addInterface(interfaces[i]);
-        }
-        for (int i = 0; i < attributes.length; i++) {
-        	if (!(attributes[i] instanceof Annotations)) {
-        		addAttribute(attributes[i]);
-        	}
-        }
-        for(int i=0; i < annotations.length; i++) {
-            addAnnotationEntry(annotations[i]);
-        }
-        for (int i = 0; i < methods.length; i++) {
-            addMethod(methods[i]);
-        }
-        for (int i = 0; i < fields.length; i++) {
-            addField(fields[i]);
-        }
-    }
     
-    /**
-	 * Look for attributes representing annotations and unpack them.
-	 */
-	private AnnotationEntryGen[] unpackAnnotations(Attribute[] attrs)
-	{
-		List /* AnnotationGen */annotationGenObjs = new ArrayList();
-		for (int i = 0; i < attrs.length; i++)
-		{
-			Attribute attr = attrs[i];
-			if (attr instanceof RuntimeVisibleAnnotations)
-			{
-				RuntimeVisibleAnnotations rva = (RuntimeVisibleAnnotations) attr;
-				AnnotationEntry[] annos = rva.getAnnotationEntries();
-				for (int j = 0; j < annos.length; j++)
-				{
-					AnnotationEntry a = annos[j];
-					annotationGenObjs.add(new AnnotationEntryGen(a,
-							getConstantPool(), false));
-				}
-			}
-			else
-				if (attr instanceof RuntimeInvisibleAnnotations)
-				{
-					RuntimeInvisibleAnnotations ria = (RuntimeInvisibleAnnotations) attr;
-					AnnotationEntry[] annos = ria.getAnnotationEntries();
-					for (int j = 0; j < annos.length; j++)
-					{
-						AnnotationEntry a = annos[j];
-						annotationGenObjs.add(new AnnotationEntryGen(a,
-								getConstantPool(), false));
-					}
-				}
-		}
-		return (AnnotationEntryGen[]) annotationGenObjs
-				.toArray(new AnnotationEntryGen[annotationGenObjs.size()]);
-	}
-
-
-    /**
-     * @return the (finally) built up Java class object.
-     */
-    public JavaClass getJavaClass() {
-        int[] interfaces = getInterfaces();
-        Field[] fields = getFields();
-        Method[] methods = getMethods();
-        Attribute[] attributes = null;
-        if (annotation_vec.isEmpty()) {
-        	attributes = getAttributes();
-        } else {
-        	// TODO: Sometime later, trash any attributes called 'RuntimeVisibleAnnotations' or 'RuntimeInvisibleAnnotations'
-            Attribute[] annAttributes  = Utility.getAnnotationAttributes(cp,annotation_vec);
-            attributes = new Attribute[attribute_vec.size()+annAttributes.length];
-            attribute_vec.toArray(attributes);
-            System.arraycopy(annAttributes,0,attributes,attribute_vec.size(),annAttributes.length);       
-        }
-        // Must be last since the above calls may still add something to it
-        ConstantPool _cp = this.cp.getFinalConstantPool();
-        return new JavaClass(class_name_index, superclass_name_index, file_name, major, minor,
-                access_flags, _cp, interfaces, fields, methods, attributes);
-    }
-
-
-    /**
-     * Add an interface to this class, i.e., this class has to implement it.
-     * @param name interface to implement (fully qualified class name)
-     */
-    public void addInterface( String name ) {
-        interface_vec.add(name);
-    }
-
-
-    /**
-     * Remove an interface from this class.
-     * @param name interface to remove (fully qualified name)
-     */
-    public void removeInterface( String name ) {
-        interface_vec.remove(name);
-    }
-
-
-    /**
-     * @return major version number of class file
-     */
-    public int getMajor() {
-        return major;
-    }
-
-
-    /** Set major version number of class file, default value is 45 (JDK 1.1)
-     * @param major major version number
-     */
-    public void setMajor( int major ) {
-        this.major = major;
-    }
 
 
-    /** Set minor version number of class file, default value is 3 (JDK 1.1)
-     * @param minor minor version number
-     */
-    public void setMinor( int minor ) {
-        this.minor = minor;
-    }
-
-
-    /**
-     * @return minor version number of class file
-     */
-    public int getMinor() {
-        return minor;
-    }
-
-
-    /**
-     * Add an attribute to this class.
-     * @param a attribute to add
-     */
-    public void addAttribute( Attribute a ) {
-        attribute_vec.add(a);
-    }
     
-    public void addAnnotationEntry(AnnotationEntryGen a) { 
-    	annotation_vec.add(a); 
-    }
-
-
-    /**
-     * Add a method to this class.
-     * @param m method to add
-     */
-    public void addMethod( Method m ) {
-        method_vec.add(m);
-    }
-
-
-    /**
-     * Convenience method.
-     *
-     * Add an empty constructor to this class that does nothing but calling super().
-     * @param access_flags rights for constructor
-     */
-    public void addEmptyConstructor( int access_flags ) {
-        InstructionList il = new InstructionList();
-        il.append(InstructionConstants.THIS); // Push `this'
-        il.append(new INVOKESPECIAL(cp.addMethodref(super_class_name, "<init>", "()V")));
-        il.append(InstructionConstants.RETURN);
-        MethodGen mg = new MethodGen(access_flags, Type.VOID, Type.NO_ARGS, null, "<init>",
-                class_name, il, cp);
-        mg.setMaxStack(1);
-        addMethod(mg.getMethod());
-    }
-
-
-    /**
-     * Add a field to this class.
-     * @param f field to add
-     */
-    public void addField( Field f ) {
-        field_vec.add(f);
-    }
-
-
-    public boolean containsField( Field f ) {
-        return field_vec.contains(f);
-    }
-
-
-    /** @return field object with given name, or null
-     */
-    public Field containsField( String name ) {
-        for (Iterator e = field_vec.iterator(); e.hasNext();) {
-            Field f = (Field) e.next();
-            if (f.getName().equals(name)) {
-                return f;
-            }
-        }
-        return null;
-    }
-
-
-    /** @return method object with given name and signature, or null
-     */
-    public Method containsMethod( String name, String signature ) {
-        for (Iterator e = method_vec.iterator(); e.hasNext();) {
-            Method m = (Method) e.next();
-            if (m.getName().equals(name) && m.getSignature().equals(signature)) {
-                return m;
-            }
-        }
-        return null;
-    }
-
-
-    /**
-     * Remove an attribute from this class.
-     * @param a attribute to remove
-     */
-    public void removeAttribute( Attribute a ) {
-        attribute_vec.remove(a);
-    }
-
-
-    /**
-     * Remove a method from this class.
-     * @param m method to remove
-     */
-    public void removeMethod( Method m ) {
-        method_vec.remove(m);
-    }
-
-
-    /** Replace given method with new one. If the old one does not exist
-     * add the new_ method to the class anyway.
-     */
-    public void replaceMethod( Method old, Method new_ ) {
-        if (new_ == null) {
-            throw new ClassGenException("Replacement method must not be null");
-        }
-        int i = method_vec.indexOf(old);
-        if (i < 0) {
-            method_vec.add(new_);
-        } else {
-            method_vec.set(i, new_);
-        }
-    }
-
-
-    /** Replace given field with new one. If the old one does not exist
-     * add the new_ field to the class anyway.
-     */
-    public void replaceField( Field old, Field new_ ) {
-        if (new_ == null) {
-            throw new ClassGenException("Replacement method must not be null");
-        }
-        int i = field_vec.indexOf(old);
-        if (i < 0) {
-            field_vec.add(new_);
-        } else {
-            field_vec.set(i, new_);
-        }
-    }
-
-
-    /**
-     * Remove a field to this class.
-     * @param f field to remove
-     */
-    public void removeField( Field f ) {
-        field_vec.remove(f);
-    }
 
 
+    
+    
     public String getClassName() {
         return class_name;
     }
 
 
-    public String getSuperclassName() {
-        return super_class_name;
-    }
+    
 
 
-    public String getFileName() {
-        return file_name;
-    }
+    
 
 
-    public void setClassName( String name ) {
-        class_name = name.replace('/', '.');
-        class_name_index = cp.addClass(name);
-    }
+    
 
 
-    public void setSuperclassName( String name ) {
-        super_class_name = name.replace('/', '.');
-        superclass_name_index = cp.addClass(name);
-    }
+    
 
 
-    public Method[] getMethods() {
-        return (Method[]) method_vec.toArray(new Method[method_vec.size()]);
-    }
+    
 
 
-    public void setMethods( Method[] methods ) {
-        method_vec.clear();
-        for (int m = 0; m < methods.length; m++) {
-            addMethod(methods[m]);
-        }
-    }
+    
 
 
-    public void setMethodAt( Method method, int pos ) {
-        method_vec.set(pos, method);
-    }
+    
 
 
-    public Method getMethodAt( int pos ) {
-        return (Method) method_vec.get(pos);
-    }
+    
 
 
-    public String[] getInterfaceNames() {
-        int size = interface_vec.size();
-        String[] interfaces = new String[size];
-        interface_vec.toArray(interfaces);
-        return interfaces;
-    }
+    
 
 
-    public int[] getInterfaces() {
-        int size = interface_vec.size();
-        int[] interfaces = new int[size];
-        for (int i = 0; i < size; i++) {
-            interfaces[i] = cp.addClass((String) interface_vec.get(i));
-        }
-        return interfaces;
-    }
+    
 
 
-    public Field[] getFields() {
-        return (Field[]) field_vec.toArray(new Field[field_vec.size()]);
-    }
+    
 
 
-    public Attribute[] getAttributes() {
-        return (Attribute[]) attribute_vec.toArray(new Attribute[attribute_vec.size()]);
-    }
     
-    //  J5TODO: Should we make calling unpackAnnotations() lazy and put it in here?
-    public AnnotationEntryGen[] getAnnotationEntries() {
-    	return (AnnotationEntryGen[]) annotation_vec.toArray(new AnnotationEntryGen[annotation_vec.size()]);
-    }
+    
+    
 
 
-    public ConstantPoolGen getConstantPool() {
-        return cp;
-    }
+    
 
 
-    public void setConstantPool( ConstantPoolGen constant_pool ) {
-        cp = constant_pool;
-    }
+    
 
 
-    public void setClassNameIndex( int class_name_index ) {
-        this.class_name_index = class_name_index;
-        class_name = cp.getConstantPool().getConstantString(class_name_index,
-                Constants.CONSTANT_Class).replace('/', '.');
-    }
+    
 
 
-    public void setSuperclassNameIndex( int superclass_name_index ) {
-        this.superclass_name_index = superclass_name_index;
-        super_class_name = cp.getConstantPool().getConstantString(superclass_name_index,
-                Constants.CONSTANT_Class).replace('/', '.');
-    }
+    
 
 
-    public int getSuperclassNameIndex() {
-        return superclass_name_index;
-    }
+    
 
 
-    public int getClassNameIndex() {
-        return class_name_index;
-    }
+    
 
     private ArrayList observers;
 
 
-    /** Add observer for this object.
-     */
-    public void addObserver( ClassObserver o ) {
-        if (observers == null) {
-            observers = new ArrayList();
-        }
-        observers.add(o);
-    }
+    
 
 
-    /** Remove observer for this object.
-     */
-    public void removeObserver( ClassObserver o ) {
-        if (observers != null) {
-            observers.remove(o);
-        }
-    }
+    
 
 
-    /** Call notify() method on all observers. This method is not called
-     * automatically whenever the state has changed, but has to be
-     * called by the user after he has finished editing the object.
-     */
-    public void update() {
-        if (observers != null) {
-            for (Iterator e = observers.iterator(); e.hasNext();) {
-                ((ClassObserver) e.next()).notify(this);
-            }
-        }
-    }
+    
 
 
     public Object clone() {
@@ -571,20 +153,10 @@ public class ClassGen extends AccessFlags implements Cloneable {
     }
 
 
-    /**
-     * @return Comparison strategy object
-     */
-    public static BCELComparator getComparator() {
-        return _cmp;
-    }
+    
 
 
-    /**
-     * @param comparator Comparison strategy object
-     */
-    public static void setComparator( BCELComparator comparator ) {
-        _cmp = comparator;
-    }
+    
 
 
     /**

==================================================
ClassObserver.java
index d478259d65..b869b3274b 100644
--- a/java/org/apache/tomcat/util/bcel/generic/ClassGenException.java
+++ b/java/org/apache/tomcat/util/bcel/generic/ClassGenException.java
@@ -34,7 +34,5 @@ public class ClassGenException extends RuntimeException {
         super(s);
     }
     
-    public ClassGenException(String s, Throwable initCause) {
-    	super(s, initCause);
-    }
+    
 }

==================================================
CodeExceptionGen.java
deleted file mode 100644
index 591bbd9a7a..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/ClassObserver.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * Implement this interface if you're interested in changes to a ClassGen object
- * and register yourself with addObserver().
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public interface ClassObserver {
-
-    public void notify( ClassGen clazz );
-}

==================================================
CompoundInstruction.java
index fbb466e7b3..e5fd00a3c2 100644
--- a/java/org/apache/tomcat/util/bcel/generic/CodeExceptionGen.java
+++ b/java/org/apache/tomcat/util/bcel/generic/CodeExceptionGen.java
@@ -38,7 +38,6 @@ public final class CodeExceptionGen implements InstructionTargeter, Cloneable, j
     private InstructionHandle start_pc;
     private InstructionHandle end_pc;
     private InstructionHandle handler_pc;
-    private ObjectType catch_type;
 
 
     /**
@@ -55,24 +54,10 @@ public final class CodeExceptionGen implements InstructionTargeter, Cloneable, j
         setStartPC(start_pc);
         setEndPC(end_pc);
         setHandlerPC(handler_pc);
-        this.catch_type = catch_type;
     }
 
 
-    /**
-     * Get CodeException object.<BR>
-     *
-     * This relies on that the instruction list has already been dumped
-     * to byte code or or that the `setPositions' methods has been
-     * called for the instruction list.
-     *
-     * @param cp constant pool
-     */
-    public CodeException getCodeException( ConstantPoolGen cp ) {
-        return new CodeException(start_pc.getPosition(), end_pc.getPosition()
-                + end_pc.getInstruction().getLength(), handler_pc.getPosition(),
-                (catch_type == null) ? 0 : cp.addClass(catch_type));
-    }
+    
 
 
     /* Set start of handler 
@@ -102,70 +87,25 @@ public final class CodeExceptionGen implements InstructionTargeter, Cloneable, j
     }
 
 
-    /**
-     * @param old_ih old target, either start or end
-     * @param new_ih new target
-     */
-    public void updateTarget( InstructionHandle old_ih, InstructionHandle new_ih ) {
-        boolean targeted = false;
-        if (start_pc == old_ih) {
-            targeted = true;
-            setStartPC(new_ih);
-        }
-        if (end_pc == old_ih) {
-            targeted = true;
-            setEndPC(new_ih);
-        }
-        if (handler_pc == old_ih) {
-            targeted = true;
-            setHandlerPC(new_ih);
-        }
-        if (!targeted) {
-            throw new ClassGenException("Not targeting " + old_ih + ", but {" + start_pc + ", "
-                    + end_pc + ", " + handler_pc + "}");
-        }
-    }
+    
 
 
-    /**
-     * @return true, if ih is target of this handler
-     */
-    public boolean containsTarget( InstructionHandle ih ) {
-        return (start_pc == ih) || (end_pc == ih) || (handler_pc == ih);
-    }
+    
 
 
-    /** Sets the type of the Exception to catch. Set 'null' for ANY. */
-    public void setCatchType( ObjectType catch_type ) {
-        this.catch_type = catch_type;
-    }
+    
 
 
-    /** Gets the type of the Exception to catch, 'null' for ANY. */
-    public ObjectType getCatchType() {
-        return catch_type;
-    }
+    
 
 
-    /** @return start of handled region (inclusive)
-     */
-    public InstructionHandle getStartPC() {
-        return start_pc;
-    }
+    
 
 
-    /** @return end of handled region (inclusive)
-     */
-    public InstructionHandle getEndPC() {
-        return end_pc;
-    }
+    
 
 
-    /** @return start of handler
-     */
-    public InstructionHandle getHandlerPC() {
-        return handler_pc;
-    }
+    
 
 
     public String toString() {

==================================================
ConstantPoolGen.java
deleted file mode 100644
index 698745fb44..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/CompoundInstruction.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * Wrapper class for `compound' operations, virtual instructions that
- * don't exist as byte code, but give a useful meaning. For example,
- * the (virtual) PUSH instruction takes an arbitray argument and produces the
- * appropiate code at dump time (ICONST, LDC, BIPUSH, ...). Also you can use the
- * SWITCH instruction as a useful template for either LOOKUPSWITCH or
- * TABLESWITCH.
- *
- * The interface provides the possibilty for the user to write
- * `templates' or `macros' for such reuseable code patterns.
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- * @see PUSH
- * @see SWITCH
- */
-public interface CompoundInstruction {
-
-    public InstructionList getInstructionList();
-}

==================================================
ConversionInstruction.java
index 676794cc17..ca9a17ab90 100644
--- a/java/org/apache/tomcat/util/bcel/generic/ConstantPoolGen.java
+++ b/java/org/apache/tomcat/util/bcel/generic/ConstantPoolGen.java
@@ -18,9 +18,7 @@ package org.apache.tomcat.util.bcel.generic;
 
 import java.util.HashMap;
 import java.util.Map;
-import org.apache.tomcat.util.bcel.Constants;
 import org.apache.tomcat.util.bcel.classfile.Constant;
-import org.apache.tomcat.util.bcel.classfile.ConstantCP;
 import org.apache.tomcat.util.bcel.classfile.ConstantClass;
 import org.apache.tomcat.util.bcel.classfile.ConstantDouble;
 import org.apache.tomcat.util.bcel.classfile.ConstantFieldref;
@@ -69,98 +67,10 @@ public class ConstantPoolGen implements java.io.Serializable {
     }
 
 
-    /**
-     * Initialize with given array of constants.
-     *
-     * @param cs array of given constants, new ones will be appended
-     */
-    public ConstantPoolGen(Constant[] cs) {
-    	StringBuffer sb = new StringBuffer(256);
-        
-        size = Math.max(256, cs.length + 64);
-        constants = new Constant[size];
-        
-        System.arraycopy(cs, 0, constants, 0, cs.length);
-        if (cs.length > 0) {
-            index = cs.length;
-        }
-    	
-    	
-        for (int i = 1; i < index; i++) {
-            Constant c = constants[i];
-            if (c instanceof ConstantString) {
-                ConstantString s = (ConstantString) c;
-                ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
-                String key = u8.getBytes();
-                if (!string_table.containsKey(key)) {
-                    string_table.put(key, new Index(i));
-                }
-            } else if (c instanceof ConstantClass) {
-                ConstantClass s = (ConstantClass) c;
-                ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
-                String key = u8.getBytes();
-                if (!class_table.containsKey(key)) {
-                    class_table.put(key, new Index(i));
-                }
-            } else if (c instanceof ConstantNameAndType) {
-                ConstantNameAndType n = (ConstantNameAndType) c;
-                ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
-                ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
-                
-                sb.append(u8.getBytes());
-                sb.append(NAT_DELIM);
-                sb.append(u8_2.getBytes());
-                String key = sb.toString();
-                sb.delete(0, sb.length());
-                
-                if (!n_a_t_table.containsKey(key)) {
-                    n_a_t_table.put(key, new Index(i));
-                }
-            } else if (c instanceof ConstantUtf8) {
-                ConstantUtf8 u = (ConstantUtf8) c;
-                String key = u.getBytes();
-                if (!utf8_table.containsKey(key)) {
-                    utf8_table.put(key, new Index(i));
-                }
-            } else if (c instanceof ConstantCP) {
-                ConstantCP m = (ConstantCP) c;
-                ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
-                ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
-                ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
-                String class_name = u8.getBytes().replace('/', '.');
-                u8 = (ConstantUtf8) constants[n.getNameIndex()];
-                String method_name = u8.getBytes();
-                u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
-                String signature = u8.getBytes();
-                String delim = METHODREF_DELIM;
-                if (c instanceof ConstantInterfaceMethodref) {
-                    delim = IMETHODREF_DELIM;
-                } else if (c instanceof ConstantFieldref) {
-                    delim = FIELDREF_DELIM;
-                }
-                
-                sb.append(class_name);
-                sb.append(delim);
-                sb.append(method_name);
-                sb.append(delim);
-                sb.append(signature);
-                String key = sb.toString();
-                sb.delete(0, sb.length());
-                
-                if (!cp_table.containsKey(key)) {
-                    cp_table.put(key, new Index(i));
-                }
-            }
-        }
-    }
+    
 
 
-    /**
-     * Initialize with given constant pool.
-     */
-    public ConstantPoolGen(ConstantPool cp) {
-        this(cp.getConstantPool());
-    }
+    
 
 
     /**
@@ -273,16 +183,7 @@ public class ConstantPoolGen implements java.io.Serializable {
     }
 
 
-    /**
-     * Add a reference to an array class (e.g. String[][]) as needed by MULTIANEWARRAY
-     * instruction, e.g. to the ConstantPool.
-     *
-     * @param type type of array class
-     * @return index of entry
-     */
-    public int addArrayClass( ArrayType type ) {
-        return addClass_(type.getSignature());
-    }
+    
 
 
     /** 
@@ -531,9 +432,7 @@ public class ConstantPoolGen implements java.io.Serializable {
     }
 
 
-    public int lookupMethodref( MethodGen method ) {
-        return lookupMethodref(method.getClassName(), method.getName(), method.getSignature());
-    }
+    
 
 
     /**
@@ -563,9 +462,7 @@ public class ConstantPoolGen implements java.io.Serializable {
     }
 
 
-    public int addMethodref( MethodGen method ) {
-        return addMethodref(method.getClassName(), method.getName(), method.getSignature());
-    }
+    
 
 
     /** 
@@ -583,10 +480,7 @@ public class ConstantPoolGen implements java.io.Serializable {
     }
 
 
-    public int lookupInterfaceMethodref( MethodGen method ) {
-        return lookupInterfaceMethodref(method.getClassName(), method.getName(), method
-                .getSignature());
-    }
+    
 
 
     /**
@@ -616,9 +510,7 @@ public class ConstantPoolGen implements java.io.Serializable {
     }
 
 
-    public int addInterfaceMethodref( MethodGen method ) {
-        return addInterfaceMethodref(method.getClassName(), method.getName(), method.getSignature());
-    }
+    
 
 
     /** 
@@ -673,15 +565,7 @@ public class ConstantPoolGen implements java.io.Serializable {
     }
 
 
-    /**
-     * Use with care!
-     *
-     * @param i index in constant pool
-     * @param c new constant pool entry at index i
-     */
-    public void setConstant( int i, Constant c ) {
-        constants[i] = c;
-    }
+    
 
 
     /**
@@ -692,22 +576,10 @@ public class ConstantPoolGen implements java.io.Serializable {
     }
 
 
-    /**
-     * @return current size of constant pool
-     */
-    public int getSize() {
-        return index;
-    }
+    
 
 
-    /**
-     * @return constant pool with proper length
-     */
-    public ConstantPool getFinalConstantPool() {
-        Constant[] cs = new Constant[index];
-        System.arraycopy(constants, 0, cs, 0, index);
-        return new ConstantPool(cs);
-    }
+    
 
 
     /**
@@ -722,62 +594,5 @@ public class ConstantPoolGen implements java.io.Serializable {
     }
 
 
-    /** Import constant from another ConstantPool and return new index.
-     */
-    public int addConstant( Constant c, ConstantPoolGen cp ) {
-        Constant[] constants = cp.getConstantPool().getConstantPool();
-        switch (c.getTag()) {
-            case Constants.CONSTANT_String: {
-                ConstantString s = (ConstantString) c;
-                ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
-                return addString(u8.getBytes());
-            }
-            case Constants.CONSTANT_Class: {
-                ConstantClass s = (ConstantClass) c;
-                ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
-                return addClass(u8.getBytes());
-            }
-            case Constants.CONSTANT_NameAndType: {
-                ConstantNameAndType n = (ConstantNameAndType) c;
-                ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
-                ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
-                return addNameAndType(u8.getBytes(), u8_2.getBytes());
-            }
-            case Constants.CONSTANT_Utf8:
-                return addUtf8(((ConstantUtf8) c).getBytes());
-            case Constants.CONSTANT_Double:
-                return addDouble(((ConstantDouble) c).getBytes());
-            case Constants.CONSTANT_Float:
-                return addFloat(((ConstantFloat) c).getBytes());
-            case Constants.CONSTANT_Long:
-                return addLong(((ConstantLong) c).getBytes());
-            case Constants.CONSTANT_Integer:
-                return addInteger(((ConstantInteger) c).getBytes());
-            case Constants.CONSTANT_InterfaceMethodref:
-            case Constants.CONSTANT_Methodref:
-            case Constants.CONSTANT_Fieldref: {
-                ConstantCP m = (ConstantCP) c;
-                ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
-                ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
-                ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
-                String class_name = u8.getBytes().replace('/', '.');
-                u8 = (ConstantUtf8) constants[n.getNameIndex()];
-                String name = u8.getBytes();
-                u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
-                String signature = u8.getBytes();
-                switch (c.getTag()) {
-                    case Constants.CONSTANT_InterfaceMethodref:
-                        return addInterfaceMethodref(class_name, name, signature);
-                    case Constants.CONSTANT_Methodref:
-                        return addMethodref(class_name, name, signature);
-                    case Constants.CONSTANT_Fieldref:
-                        return addFieldref(class_name, name, signature);
-                    default: // Never reached
-                        throw new RuntimeException("Unknown constant type " + c);
-                }
-            }
-            default: // Never reached
-                throw new RuntimeException("Unknown constant type " + c);
-        }
-    }
+    
 }

==================================================
D2F.java
deleted file mode 100644
index f17b6e0450..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/ConversionInstruction.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-import org.apache.tomcat.util.bcel.Constants;
-
-/**
- * Super class for the x2y family of instructions.
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public abstract class ConversionInstruction extends Instruction implements TypedInstruction,
-        StackProducer, StackConsumer {
-
-    /**
-     * Empty constructor needed for the Class.newInstance() statement in
-     * Instruction.readInstruction(). Not to be used otherwise.
-     */
-    ConversionInstruction() {
-    }
-
-
-    /**
-     * @param opcode opcode of instruction
-     */
-    protected ConversionInstruction(short opcode) {
-        super(opcode, (short) 1);
-    }
-
-
-    /** @return type associated with the instruction
-     */
-    public Type getType( ConstantPoolGen cp ) {
-        switch (opcode) {
-            case Constants.D2I:
-            case Constants.F2I:
-            case Constants.L2I:
-                return Type.INT;
-            case Constants.D2F:
-            case Constants.I2F:
-            case Constants.L2F:
-                return Type.FLOAT;
-            case Constants.D2L:
-            case Constants.F2L:
-            case Constants.I2L:
-                return Type.LONG;
-            case Constants.F2D:
-            case Constants.I2D:
-            case Constants.L2D:
-                return Type.DOUBLE;
-            case Constants.I2B:
-                return Type.BYTE;
-            case Constants.I2C:
-                return Type.CHAR;
-            case Constants.I2S:
-                return Type.SHORT;
-            default: // Never reached
-                throw new ClassGenException("Unknown type " + opcode);
-        }
-    }
-}

==================================================
D2I.java
deleted file mode 100644
index 05ab5d0130..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/D2F.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * D2F - Convert double to float
- * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class D2F extends ConversionInstruction {
-
-    /** Convert double to float
-     */
-    public D2F() {
-        super(org.apache.tomcat.util.bcel.Constants.D2F);
-    }
-}

==================================================
D2L.java
deleted file mode 100644
index e02a82a27c..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/D2I.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * D2I - Convert double to int
- * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class D2I extends ConversionInstruction {
-
-    /** Convert double to int
-     */
-    public D2I() {
-        super(org.apache.tomcat.util.bcel.Constants.D2I);
-    }
-}

==================================================
DADD.java
deleted file mode 100644
index 74c226add6..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/D2L.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * D2L - Convert double to long
- * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result.word1, result.word2</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class D2L extends ConversionInstruction {
-
-    /** Convert double to long
-     */
-    public D2L() {
-        super(org.apache.tomcat.util.bcel.Constants.D2L);
-    }
-}

==================================================
DALOAD.java
deleted file mode 100644
index cc9d191da5..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/DADD.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * DADD - Add doubles
- * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;</PRE>
- *        ..., result.word1, result1.word2
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class DADD extends ArithmeticInstruction {
-
-    /** Add doubles
-     */
-    public DADD() {
-        super(org.apache.tomcat.util.bcel.Constants.DADD);
-    }
-}

==================================================
DASTORE.java
deleted file mode 100644
index 61f47f6099..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/DALOAD.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * DALOAD - Load double from array
- * <PRE>Stack: ..., arrayref, index -&gt; ..., result.word1, result.word2</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class DALOAD extends ArrayInstruction implements StackProducer {
-
-    /** Load double from array
-     */
-    public DALOAD() {
-        super(org.apache.tomcat.util.bcel.Constants.DALOAD);
-    }
-}

==================================================
DCMPG.java
deleted file mode 100644
index 0e28a7d0cd..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/DASTORE.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * DASTORE -  Store into double array
- * <PRE>Stack: ..., arrayref, index, value.word1, value.word2 -&gt; ...</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class DASTORE extends ArrayInstruction implements StackConsumer {
-
-    /** Store double into array
-     */
-    public DASTORE() {
-        super(org.apache.tomcat.util.bcel.Constants.DASTORE);
-    }
-}

==================================================
DCMPL.java
deleted file mode 100644
index 2463362173..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/DCMPG.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * DCMPG - Compare doubles: value1 > value2
- * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;</PRE>
- *        ..., result
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class DCMPG extends Instruction implements TypedInstruction, StackProducer, StackConsumer {
-
-    public DCMPG() {
-        super(org.apache.tomcat.util.bcel.Constants.DCMPG, (short) 1);
-    }
-
-
-    /** @return Type.DOUBLE
-     */
-    public Type getType( ConstantPoolGen cp ) {
-        return Type.DOUBLE;
-    }
-}

==================================================
DCONST.java
deleted file mode 100644
index 2d33d4c862..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/DCMPL.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * DCMPL - Compare doubles: value1 < value2
- * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;</PRE>
- *        ..., result
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class DCMPL extends Instruction implements TypedInstruction, StackProducer, StackConsumer {
-
-    public DCMPL() {
-        super(org.apache.tomcat.util.bcel.Constants.DCMPL, (short) 1);
-    }
-
-
-    /** @return Type.DOUBLE
-     */
-    public Type getType( ConstantPoolGen cp ) {
-        return Type.DOUBLE;
-    }
-}

==================================================
DDIV.java
deleted file mode 100644
index 26ac18f86d..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/DCONST.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * DCONST - Push 0.0 or 1.0, other values cause an exception
- *
- * <PRE>Stack: ... -&gt; ..., </PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class DCONST extends Instruction implements ConstantPushInstruction, TypedInstruction {
-
-    private double value;
-
-
-    /**
-     * Empty constructor needed for the Class.newInstance() statement in
-     * Instruction.readInstruction(). Not to be used otherwise.
-     */
-    DCONST() {
-    }
-
-
-    public DCONST(double f) {
-        super(org.apache.tomcat.util.bcel.Constants.DCONST_0, (short) 1);
-        if (f == 0.0) {
-            opcode = org.apache.tomcat.util.bcel.Constants.DCONST_0;
-        } else if (f == 1.0) {
-            opcode = org.apache.tomcat.util.bcel.Constants.DCONST_1;
-        } else {
-            throw new ClassGenException("DCONST can be used only for 0.0 and 1.0: " + f);
-        }
-        value = f;
-    }
-
-
-    public Number getValue() {
-        return new Double(value);
-    }
-
-
-    /** @return Type.DOUBLE
-     */
-    public Type getType( ConstantPoolGen cp ) {
-        return Type.DOUBLE;
-    }
-}

==================================================
DMUL.java
deleted file mode 100644
index 694602b396..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/DDIV.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * DDIV -  Divide doubles
- * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;</PRE>
- *        ..., result.word1, result.word2
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class DDIV extends ArithmeticInstruction {
-
-    /** Divide doubles
-     */
-    public DDIV() {
-        super(org.apache.tomcat.util.bcel.Constants.DDIV);
-    }
-}

==================================================
DNEG.java
deleted file mode 100644
index f22523e591..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/DMUL.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * DMUL - Multiply doubles
- * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;</PRE>
- *        ..., result.word1, result.word2
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class DMUL extends ArithmeticInstruction {
-
-    /** Multiply doubles
-     */
-    public DMUL() {
-        super(org.apache.tomcat.util.bcel.Constants.DMUL);
-    }
-}

==================================================
DREM.java
deleted file mode 100644
index eb59ac1570..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/DNEG.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * DNEG - Negate double
- * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result.word1, result.word2</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class DNEG extends ArithmeticInstruction {
-
-    public DNEG() {
-        super(org.apache.tomcat.util.bcel.Constants.DNEG);
-    }
-}

==================================================
DRETURN.java
deleted file mode 100644
index 8b36690fc0..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/DREM.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * DREM - Remainder of doubles
- * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;</PRE>
- *        ..., result.word1, result.word2
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class DREM extends ArithmeticInstruction {
-
-    /** Remainder of doubles
-     */
-    public DREM() {
-        super(org.apache.tomcat.util.bcel.Constants.DREM);
-    }
-}

==================================================
DSUB.java
deleted file mode 100644
index b78fe8311a..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/DRETURN.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * DRETURN -  Return double from method
- * <PRE>Stack: ..., value.word1, value.word2 -&gt; &lt;empty&gt;</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class DRETURN extends ReturnInstruction {
-
-    /** Return double from method
-     */
-    public DRETURN() {
-        super(org.apache.tomcat.util.bcel.Constants.DRETURN);
-    }
-}

==================================================
DUP.java
deleted file mode 100644
index f020f3df15..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/DSUB.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * DSUB - Substract doubles
- * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;</PRE>
- *        ..., result.word1, result.word2
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class DSUB extends ArithmeticInstruction {
-
-    /** Substract doubles
-     */
-    public DSUB() {
-        super(org.apache.tomcat.util.bcel.Constants.DSUB);
-    }
-}

==================================================
DUP2.java
deleted file mode 100644
index 10967bb1b8..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/DUP.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * DUP - Duplicate top operand stack word
- * <PRE>Stack: ..., word -&gt; ..., word, word</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class DUP extends StackInstruction implements PushInstruction {
-
-    public DUP() {
-        super(org.apache.tomcat.util.bcel.Constants.DUP);
-    }
-}

==================================================
DUP2_X1.java
deleted file mode 100644
index 16090aac88..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/DUP2.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * DUP2 - Duplicate two top operand stack words
- * <PRE>Stack: ..., word2, word1 -&gt; ..., word2, word1, word2, word1</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class DUP2 extends StackInstruction implements PushInstruction {
-
-    public DUP2() {
-        super(org.apache.tomcat.util.bcel.Constants.DUP2);
-    }
-}

==================================================
DUP2_X2.java
deleted file mode 100644
index 6309cad8cf..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/DUP2_X1.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * DUP2_X1 - Duplicate two top operand stack words and put three down
- * <PRE>Stack: ..., word3, word2, word1 -&gt; ..., word2, word1, word3, word2, word1</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class DUP2_X1 extends StackInstruction {
-
-    public DUP2_X1() {
-        super(org.apache.tomcat.util.bcel.Constants.DUP2_X1);
-    }
-}

==================================================
DUP_X1.java
deleted file mode 100644
index c528e08329..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/DUP2_X2.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * DUP2_X2 - Duplicate two top operand stack words and put four down
- * <PRE>Stack: ..., word4, word3, word2, word1 -&gt; ..., word2, word1, word4, word3, word2, word1</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class DUP2_X2 extends StackInstruction {
-
-    public DUP2_X2() {
-        super(org.apache.tomcat.util.bcel.Constants.DUP2_X2);
-    }
-}

==================================================
DUP_X2.java
deleted file mode 100644
index c33f725a56..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/DUP_X1.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * DUP_X1 - Duplicate top operand stack word and put two down
- * <PRE>Stack: ..., word2, word1 -&gt; ..., word1, word2, word1</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class DUP_X1 extends StackInstruction {
-
-    public DUP_X1() {
-        super(org.apache.tomcat.util.bcel.Constants.DUP_X1);
-    }
-}

==================================================
ElementValueGen.java
deleted file mode 100644
index 255ea26159..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/DUP_X2.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * DUP_X2 - Duplicate top operand stack word and put three down
- * <PRE>Stack: ..., word3, word2, word1 -&gt; ..., word1, word3, word2, word1</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class DUP_X2 extends StackInstruction {
-
-    public DUP_X2() {
-        super(org.apache.tomcat.util.bcel.Constants.DUP_X2);
-    }
-}

==================================================
ElementValuePairGen.java
index 63e416c65c..26979f0386 100644
--- a/java/org/apache/tomcat/util/bcel/generic/ElementValueGen.java
+++ b/java/org/apache/tomcat/util/bcel/generic/ElementValueGen.java
@@ -1,11 +1,9 @@
 package org.apache.tomcat.util.bcel.generic;
 
-import java.io.DataInputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
 
 import org.apache.tomcat.util.bcel.classfile.AnnotationElementValue;
-import org.apache.tomcat.util.bcel.classfile.AnnotationEntry;
 import org.apache.tomcat.util.bcel.classfile.ArrayElementValue;
 import org.apache.tomcat.util.bcel.classfile.ClassElementValue;
 import org.apache.tomcat.util.bcel.classfile.ElementValue;
@@ -29,10 +27,7 @@ public abstract class ElementValueGen
 	 */
 	public abstract ElementValue getElementValue();
 
-	public int getElementValueType()
-	{
-		return type;
-	}
+	
 
 	public abstract String stringifyValue();
 
@@ -64,64 +59,7 @@ public abstract class ElementValueGen
 
 	public static final int PRIMITIVE_BOOLEAN = 'Z';
 
-	public static ElementValueGen readElementValue(DataInputStream dis,
-			ConstantPoolGen cpGen) throws IOException
-	{
-		int type = dis.readUnsignedByte();
-		switch (type)
-		{
-		case 'B': // byte
-			return new SimpleElementValueGen(PRIMITIVE_BYTE, dis
-					.readUnsignedShort(), cpGen);
-		case 'C': // char
-			return new SimpleElementValueGen(PRIMITIVE_CHAR, dis
-					.readUnsignedShort(), cpGen);
-		case 'D': // double
-			return new SimpleElementValueGen(PRIMITIVE_DOUBLE, dis
-					.readUnsignedShort(), cpGen);
-		case 'F': // float
-			return new SimpleElementValueGen(PRIMITIVE_FLOAT, dis
-					.readUnsignedShort(), cpGen);
-		case 'I': // int
-			return new SimpleElementValueGen(PRIMITIVE_INT, dis
-					.readUnsignedShort(), cpGen);
-		case 'J': // long
-			return new SimpleElementValueGen(PRIMITIVE_LONG, dis
-					.readUnsignedShort(), cpGen);
-		case 'S': // short
-			return new SimpleElementValueGen(PRIMITIVE_SHORT, dis
-					.readUnsignedShort(), cpGen);
-		case 'Z': // boolean
-			return new SimpleElementValueGen(PRIMITIVE_BOOLEAN, dis
-					.readUnsignedShort(), cpGen);
-		case 's': // String
-			return new SimpleElementValueGen(STRING, dis.readUnsignedShort(),
-					cpGen);
-		case 'e': // Enum constant
-			return new EnumElementValueGen(dis.readUnsignedShort(), dis
-					.readUnsignedShort(), cpGen);
-		case 'c': // Class
-			return new ClassElementValueGen(dis.readUnsignedShort(), cpGen);
-		case '@': // Annotation
-			// TODO: isRuntimeVisible ??????????
-			// FIXME
-			return new AnnotationElementValueGen(ANNOTATION,
-					new AnnotationEntryGen(AnnotationEntry.read(dis, cpGen
-							.getConstantPool(), true), cpGen, false), cpGen);
-		case '[': // Array
-			int numArrayVals = dis.readUnsignedShort();
-			ElementValue[] evalues = new ElementValue[numArrayVals];
-			for (int j = 0; j < numArrayVals; j++)
-			{
-				evalues[j] = ElementValue.readElementValue(dis, cpGen
-						.getConstantPool());
-			}
-			return new ArrayElementValueGen(ARRAY, evalues, cpGen);
-		default:
-			throw new RuntimeException(
-					"Unexpected element value kind in annotation: " + type);
-		}
-	}
+	
 
 	protected ConstantPoolGen getConstantPool()
 	{

==================================================
EnumElementValueGen.java
index 590c10c84a..4c40c0c517 100755
--- a/java/org/apache/tomcat/util/bcel/generic/ElementValuePairGen.java
+++ b/java/org/apache/tomcat/util/bcel/generic/ElementValuePairGen.java
@@ -47,21 +47,9 @@ public class ElementValuePairGen
 				.getConstantPool());
 	}
 
-	protected ElementValuePairGen(int idx, ElementValueGen value,
-			ConstantPoolGen cpool)
-	{
-		this.nameIdx = idx;
-		this.value = value;
-		this.cpool = cpool;
-	}
+	
 
-	public ElementValuePairGen(String name, ElementValueGen value,
-			ConstantPoolGen cpool)
-	{
-		this.nameIdx = cpool.addUtf8(name);
-		this.value = value;
-		this.cpool = cpool;
-	}
+	
 
 	protected void dump(DataOutputStream dos) throws IOException
 	{
@@ -69,10 +57,7 @@ public class ElementValuePairGen
 		value.dump(dos);
 	}
 
-	public int getNameIndex()
-	{
-		return nameIdx;
-	}
+	
 
 	public final String getNameString()
 	{
@@ -80,10 +65,7 @@ public class ElementValuePairGen
 		return ((ConstantUtf8) cpool.getConstant(nameIdx)).getBytes();
 	}
 
-	public final ElementValueGen getValue()
-	{
-		return value;
-	}
+	
 
 	public String toString()
 	{

==================================================
ExceptionThrower.java
index 2e78d1e787..afeab83493 100644
--- a/java/org/apache/tomcat/util/bcel/generic/EnumElementValueGen.java
+++ b/java/org/apache/tomcat/util/bcel/generic/EnumElementValueGen.java
@@ -13,21 +13,7 @@ public class EnumElementValueGen extends ElementValueGen
 
 	private int valueIdx;
 
-	/**
-	 * This ctor assumes the constant pool already contains the right type and
-	 * value - as indicated by typeIdx and valueIdx. This ctor is used for
-	 * deserialization
-	 */
-	protected EnumElementValueGen(int typeIdx, int valueIdx,
-			ConstantPoolGen cpool)
-	{
-		super(ElementValueGen.ENUM_CONSTANT, cpool);
-		if (type != ENUM_CONSTANT)
-			throw new RuntimeException(
-					"Only element values of type enum can be built with this ctor - type specified: " + type);
-		this.typeIdx = typeIdx;
-		this.valueIdx = valueIdx;
-	}
+	
 
 	/**
 	 * Return immutable variant of this EnumElementValue
@@ -40,12 +26,7 @@ public class EnumElementValueGen extends ElementValueGen
 				.getConstantPool());
 	}
 
-	public EnumElementValueGen(ObjectType t, String value, ConstantPoolGen cpool)
-	{
-		super(ElementValueGen.ENUM_CONSTANT, cpool);
-		typeIdx = cpool.addUtf8(t.getSignature());// was addClass(t);
-		valueIdx = cpool.addUtf8(value);// was addString(value);
-	}
+	
 
 	public EnumElementValueGen(EnumElementValue value, ConstantPoolGen cpool,
 			boolean copyPoolEntries)
@@ -107,13 +88,7 @@ public class EnumElementValueGen extends ElementValueGen
 		// ((ConstantUtf8)getConstantPool().getConstant(cu8.getStringIndex())).getBytes();
 	}
 
-	public int getValueIndex()
-	{
-		return valueIdx;
-	}
+	
 
-	public int getTypeIndex()
-	{
-		return typeIdx;
-	}
+	
 }

==================================================
F2D.java
index f62cca0c14..b13ab06183 100644
--- a/java/org/apache/tomcat/util/bcel/generic/ExceptionThrower.java
+++ b/java/org/apache/tomcat/util/bcel/generic/ExceptionThrower.java
@@ -38,5 +38,5 @@ package org.apache.tomcat.util.bcel.generic;
  */
 public interface ExceptionThrower {
 
-    public java.lang.Class[] getExceptions();
+    
 }

==================================================
F2I.java
deleted file mode 100644
index 4bcaeaf030..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/F2D.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * F2D - Convert float to double
- * <PRE>Stack: ..., value -&gt; ..., result.word1, result.word2</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class F2D extends ConversionInstruction {
-
-    /** Convert float to double
-     */
-    public F2D() {
-        super(org.apache.tomcat.util.bcel.Constants.F2D);
-    }
-}

==================================================
F2L.java
deleted file mode 100644
index f3199ebe7d..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/F2I.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * F2I - Convert float to int
- * <PRE>Stack: ..., value -&gt; ..., result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class F2I extends ConversionInstruction {
-
-    /** Convert float to int
-     */
-    public F2I() {
-        super(org.apache.tomcat.util.bcel.Constants.F2I);
-    }
-}

==================================================
FADD.java
deleted file mode 100644
index c3f1ee5ea7..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/F2L.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * F2L - Convert float to long
- * <PRE>Stack: ..., value -&gt; ..., result.word1, result.word2</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class F2L extends ConversionInstruction {
-
-    /** Convert float to long
-     */
-    public F2L() {
-        super(org.apache.tomcat.util.bcel.Constants.F2L);
-    }
-}

==================================================
FALOAD.java
deleted file mode 100644
index a56fde961a..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/FADD.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * FADD - Add floats
- * <PRE>Stack: ..., value1, value2 -&gt; result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class FADD extends ArithmeticInstruction {
-
-    /** Add floats
-     */
-    public FADD() {
-        super(org.apache.tomcat.util.bcel.Constants.FADD);
-    }
-}

==================================================
FASTORE.java
deleted file mode 100644
index 45b4d64af9..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/FALOAD.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * FALOAD - Load float from array
- * <PRE>Stack: ..., arrayref, index -&gt; ..., value</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class FALOAD extends ArrayInstruction implements StackProducer {
-
-    /** Load float from array
-     */
-    public FALOAD() {
-        super(org.apache.tomcat.util.bcel.Constants.FALOAD);
-    }
-}

==================================================
FCMPG.java
deleted file mode 100644
index 7f8b330899..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/FASTORE.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * FASTORE -  Store into float array
- * <PRE>Stack: ..., arrayref, index, value -&gt; ...</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class FASTORE extends ArrayInstruction implements StackConsumer {
-
-    /** Store float into array
-     */
-    public FASTORE() {
-        super(org.apache.tomcat.util.bcel.Constants.FASTORE);
-    }
-}

==================================================
FCMPL.java
deleted file mode 100644
index 2ae4b36ca4..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/FCMPG.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * FCMPG - Compare floats: value1 > value2
- * <PRE>Stack: ..., value1, value2 -&gt; ..., result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class FCMPG extends Instruction implements TypedInstruction, StackProducer, StackConsumer {
-
-    public FCMPG() {
-        super(org.apache.tomcat.util.bcel.Constants.FCMPG, (short) 1);
-    }
-
-
-    /** @return Type.FLOAT
-     */
-    public Type getType( ConstantPoolGen cp ) {
-        return Type.FLOAT;
-    }
-}

==================================================
FCONST.java
deleted file mode 100644
index 3415236743..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/FCMPL.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * FCMPL - Compare floats: value1 < value2
- * <PRE>Stack: ..., value1, value2 -&gt; ..., result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class FCMPL extends Instruction implements TypedInstruction, StackProducer, StackConsumer {
-
-    public FCMPL() {
-        super(org.apache.tomcat.util.bcel.Constants.FCMPL, (short) 1);
-    }
-
-
-    /** @return Type.FLOAT
-     */
-    public Type getType( ConstantPoolGen cp ) {
-        return Type.FLOAT;
-    }
-}

==================================================
FDIV.java
deleted file mode 100644
index c8c08c2a17..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/FCONST.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * FCONST - Push 0.0, 1.0 or 2.0, other values cause an exception
- *
- * <PRE>Stack: ... -&gt; ..., </PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class FCONST extends Instruction implements ConstantPushInstruction, TypedInstruction {
-
-    private float value;
-
-
-    /**
-     * Empty constructor needed for the Class.newInstance() statement in
-     * Instruction.readInstruction(). Not to be used otherwise.
-     */
-    FCONST() {
-    }
-
-
-    public FCONST(float f) {
-        super(org.apache.tomcat.util.bcel.Constants.FCONST_0, (short) 1);
-        if (f == 0.0) {
-            opcode = org.apache.tomcat.util.bcel.Constants.FCONST_0;
-        } else if (f == 1.0) {
-            opcode = org.apache.tomcat.util.bcel.Constants.FCONST_1;
-        } else if (f == 2.0) {
-            opcode = org.apache.tomcat.util.bcel.Constants.FCONST_2;
-        } else {
-            throw new ClassGenException("FCONST can be used only for 0.0, 1.0 and 2.0: " + f);
-        }
-        value = f;
-    }
-
-
-    public Number getValue() {
-        return new Float(value);
-    }
-
-
-    /** @return Type.FLOAT
-     */
-    public Type getType( ConstantPoolGen cp ) {
-        return Type.FLOAT;
-    }
-}

==================================================
FMUL.java
deleted file mode 100644
index 6e05a41b55..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/FDIV.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * FDIV - Divide floats
- * <PRE>Stack: ..., value1, value2 -&gt; result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class FDIV extends ArithmeticInstruction {
-
-    /** Divide floats
-     */
-    public FDIV() {
-        super(org.apache.tomcat.util.bcel.Constants.FDIV);
-    }
-}

==================================================
FNEG.java
deleted file mode 100644
index cfef64c680..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/FMUL.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * FMUL - Multiply floats
- * <PRE>Stack: ..., value1, value2 -&gt; result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class FMUL extends ArithmeticInstruction {
-
-    /** Multiply floats
-     */
-    public FMUL() {
-        super(org.apache.tomcat.util.bcel.Constants.FMUL);
-    }
-}

==================================================
FREM.java
deleted file mode 100644
index 6ca99100f9..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/FNEG.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * FNEG - Negate float
- * <PRE>Stack: ..., value -&gt; ..., result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class FNEG extends ArithmeticInstruction {
-
-    public FNEG() {
-        super(org.apache.tomcat.util.bcel.Constants.FNEG);
-    }
-}

==================================================
FRETURN.java
deleted file mode 100644
index d13011fbc8..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/FREM.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * FREM - Remainder of floats
- * <PRE>Stack: ..., value1, value2 -&gt; result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class FREM extends ArithmeticInstruction {
-
-    /** Remainder of floats
-     */
-    public FREM() {
-        super(org.apache.tomcat.util.bcel.Constants.FREM);
-    }
-}

==================================================
FSUB.java
deleted file mode 100644
index ecbf2d5cc0..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/FRETURN.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * FRETURN -  Return float from method
- * <PRE>Stack: ..., value -&gt; &lt;empty&gt;</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class FRETURN extends ReturnInstruction {
-
-    /** Return float from method
-     */
-    public FRETURN() {
-        super(org.apache.tomcat.util.bcel.Constants.FRETURN);
-    }
-}

==================================================
FieldGen.java
deleted file mode 100644
index 3fc84c2bd3..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/FSUB.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * FSUB - Substract floats
- * <PRE>Stack: ..., value1, value2 -&gt; result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class FSUB extends ArithmeticInstruction {
-
-    /** Substract floats
-     */
-    public FSUB() {
-        super(org.apache.tomcat.util.bcel.Constants.FSUB);
-    }
-}

==================================================
FieldGenOrMethodGen.java
index 325399b704..79491c5bd0 100644
--- a/java/org/apache/tomcat/util/bcel/generic/FieldGen.java
+++ b/java/org/apache/tomcat/util/bcel/generic/FieldGen.java
@@ -16,17 +16,7 @@
  */
 package org.apache.tomcat.util.bcel.generic;
 
-import java.util.ArrayList;
-import java.util.Iterator;
 import java.util.List;
-import org.apache.tomcat.util.bcel.Constants;
-import org.apache.tomcat.util.bcel.classfile.AnnotationEntry;
-import org.apache.tomcat.util.bcel.classfile.Annotations;
-import org.apache.tomcat.util.bcel.classfile.Attribute;
-import org.apache.tomcat.util.bcel.classfile.Constant;
-import org.apache.tomcat.util.bcel.classfile.ConstantObject;
-import org.apache.tomcat.util.bcel.classfile.ConstantPool;
-import org.apache.tomcat.util.bcel.classfile.ConstantValue;
 import org.apache.tomcat.util.bcel.classfile.Field;
 import org.apache.tomcat.util.bcel.classfile.Utility;
 import org.apache.tomcat.util.bcel.util.BCELComparator;
@@ -60,199 +50,10 @@ public class FieldGen extends FieldGenOrMethodGen {
     };
 
 
-    /**
-     * Declare a field. If it is static (isStatic() == true) and has a
-     * basic type like int or String it may have an initial value
-     * associated with it as defined by setInitValue().
-     *
-     * @param access_flags access qualifiers
-     * @param type  field type
-     * @param name field name
-     * @param cp constant pool
-     */
-    public FieldGen(int access_flags, Type type, String name, ConstantPoolGen cp) {
-        setAccessFlags(access_flags);
-        setType(type);
-        setName(name);
-        setConstantPool(cp);
-    }
-
-
-    /**
-     * Instantiate from existing field.
-     *
-     * @param field Field object
-     * @param cp constant pool (must contain the same entries as the field's constant pool)
-     */
-    public FieldGen(Field field, ConstantPoolGen cp) {
-        this(field.getAccessFlags(), Type.getType(field.getSignature()), field.getName(), cp);
-        Attribute[] attrs = field.getAttributes();
-        for (int i = 0; i < attrs.length; i++) {
-            if (attrs[i] instanceof ConstantValue) {
-                setValue(((ConstantValue) attrs[i]).getConstantValueIndex());
-            } else if (attrs[i] instanceof Annotations) {
-            	Annotations runtimeAnnotations = (Annotations)attrs[i];
-        		AnnotationEntry[] annotationEntries = runtimeAnnotations.getAnnotationEntries();
-        		for (int j = 0; j < annotationEntries.length; j++) {
-        			AnnotationEntry element = annotationEntries[j];
-        			addAnnotationEntry(new AnnotationEntryGen(element,cp,false));
-        		}
-            } else {
-                addAttribute(attrs[i]);
-            }
-        }
-    }
-
-
-    private void setValue( int index ) {
-        ConstantPool cp = this.cp.getConstantPool();
-        Constant c = cp.getConstant(index);
-        value = ((ConstantObject) c).getConstantValue(cp);
-    }
-
-
-    /**
-     * Set (optional) initial value of field, otherwise it will be set to null/0/false
-     * by the JVM automatically.
-     */
-    public void setInitValue( String str ) {
-        checkType(new ObjectType("java.lang.String"));
-        if (str != null) {
-            value = str;
-        }
-    }
-
-
-    public void setInitValue( long l ) {
-        checkType(Type.LONG);
-        if (l != 0L) {
-            value = new Long(l);
-        }
-    }
-
-
-    public void setInitValue( int i ) {
-        checkType(Type.INT);
-        if (i != 0) {
-            value = new Integer(i);
-        }
-    }
-
-
-    public void setInitValue( short s ) {
-        checkType(Type.SHORT);
-        if (s != 0) {
-            value = new Integer(s);
-        }
-    }
-
-
-    public void setInitValue( char c ) {
-        checkType(Type.CHAR);
-        if (c != 0) {
-            value = new Integer(c);
-        }
-    }
-
-
-    public void setInitValue( byte b ) {
-        checkType(Type.BYTE);
-        if (b != 0) {
-            value = new Integer(b);
-        }
-    }
-
-
-    public void setInitValue( boolean b ) {
-        checkType(Type.BOOLEAN);
-        if (b) {
-            value = new Integer(1);
-        }
-    }
-
-
-    public void setInitValue( float f ) {
-        checkType(Type.FLOAT);
-        if (f != 0.0) {
-            value = new Float(f);
-        }
-    }
-
-
-    public void setInitValue( double d ) {
-        checkType(Type.DOUBLE);
-        if (d != 0.0) {
-            value = new Double(d);
-        }
-    }
-
-
-    /** Remove any initial value.
-     */
-    public void cancelInitValue() {
-        value = null;
-    }
-
-
-    private void checkType( Type atype ) {
-        if (type == null) {
-            throw new ClassGenException("You haven't defined the type of the field yet");
-        }
-        if (!isFinal()) {
-            throw new ClassGenException("Only final fields may have an initial value!");
-        }
-        if (!type.equals(atype)) {
-            throw new ClassGenException("Types are not compatible: " + type + " vs. " + atype);
-        }
-    }
+    
 
 
-    /**
-     * Get field object after having set up all necessary values.
-     */
-    public Field getField() {
-        String signature = getSignature();
-        int name_index = cp.addUtf8(name);
-        int signature_index = cp.addUtf8(signature);
-        if (value != null) {
-            checkType(type);
-            int index = addConstant();
-            addAttribute(new ConstantValue(cp.addUtf8("ConstantValue"), 2, index, cp
-                    .getConstantPool()));
-        }
-        addAnnotationsAsAttribute(cp);
-        return new Field(access_flags, name_index, signature_index, getAttributes(), cp
-                .getConstantPool());
-    }
     
-    private void addAnnotationsAsAttribute(ConstantPoolGen cp) {
-      	Attribute[] attrs = Utility.getAnnotationAttributes(cp,annotation_vec);
-        for (int i = 0; i < attrs.length; i++) {
-    		addAttribute(attrs[i]);
-    	}
-      }
-
-
-    private int addConstant() {
-        switch (type.getType()) {
-            case Constants.T_INT:
-            case Constants.T_CHAR:
-            case Constants.T_BYTE:
-            case Constants.T_BOOLEAN:
-            case Constants.T_SHORT:
-                return cp.addInteger(((Integer) value).intValue());
-            case Constants.T_FLOAT:
-                return cp.addFloat(((Float) value).floatValue());
-            case Constants.T_DOUBLE:
-                return cp.addDouble(((Double) value).doubleValue());
-            case Constants.T_LONG:
-                return cp.addLong(((Long) value).longValue());
-            case Constants.T_REFERENCE:
-                return cp.addString(((String) value));
-            default:
-                throw new RuntimeException("Oops: Unhandled : " + type.getType());
-        }
-    }
 
 
     public String getSignature() {
@@ -262,36 +63,13 @@ public class FieldGen extends FieldGenOrMethodGen {
     private List observers;
 
 
-    /** Add observer for this object.
-     */
-    public void addObserver( FieldObserver o ) {
-        if (observers == null) {
-            observers = new ArrayList();
-        }
-        observers.add(o);
-    }
+    
 
 
-    /** Remove observer for this object.
-     */
-    public void removeObserver( FieldObserver o ) {
-        if (observers != null) {
-            observers.remove(o);
-        }
-    }
+    
 
 
-    /** Call notify() method on all observers. This method is not called
-     * automatically whenever the state has changed, but has to be
-     * called by the user after he has finished editing the object.
-     */
-    public void update() {
-        if (observers != null) {
-            for (Iterator e = observers.iterator(); e.hasNext();) {
-                ((FieldObserver) e.next()).notify(this);
-            }
-        }
-    }
+    
 
 
     public String getInitValue() {
@@ -325,29 +103,13 @@ public class FieldGen extends FieldGenOrMethodGen {
     }
 
 
-    /** @return deep copy of this field
-     */
-    public FieldGen copy( ConstantPoolGen cp ) {
-        FieldGen fg = (FieldGen) clone();
-        fg.setConstantPool(cp);
-        return fg;
-    }
+    
 
 
-    /**
-     * @return Comparison strategy object
-     */
-    public static BCELComparator getComparator() {
-        return _cmp;
-    }
+    
 
 
-    /**
-     * @param comparator Comparison strategy object
-     */
-    public static void setComparator( BCELComparator comparator ) {
-        _cmp = comparator;
-    }
+    
 
 
     /**

==================================================
FieldInstruction.java
index f8c1e71c58..edf89e9974 100644
--- a/java/org/apache/tomcat/util/bcel/generic/FieldGenOrMethodGen.java
+++ b/java/org/apache/tomcat/util/bcel/generic/FieldGenOrMethodGen.java
@@ -50,9 +50,7 @@ public abstract class FieldGenOrMethodGen extends AccessFlags implements NamedAn
     }
 
 
-    public Type getType() {
-        return type;
-    }
+    
 
 
     /** @return name of method/field.
@@ -67,9 +65,7 @@ public abstract class FieldGenOrMethodGen extends AccessFlags implements NamedAn
     }
 
 
-    public ConstantPoolGen getConstantPool() {
-        return cp;
-    }
+    
 
 
     public void setConstantPool( ConstantPoolGen cp ) {
@@ -89,36 +85,17 @@ public abstract class FieldGenOrMethodGen extends AccessFlags implements NamedAn
         attribute_vec.add(a);
     }
     
-    public void addAnnotationEntry(AnnotationEntryGen ag)
-	{
-		annotation_vec.add(ag);
-	}
+    
 
 
-    /**
-     * Remove an attribute.
-     */
-    public void removeAttribute( Attribute a ) {
-        attribute_vec.remove(a);
-    }
     
-    public void removeAnnotationEntry(AnnotationEntryGen ag)
-	{
-		annotation_vec.remove(ag);
-	}
+    
+    
 
 
-    /**
-     * Remove all attributes.
-     */
-    public void removeAttributes() {
-        attribute_vec.clear();
-    }
     
-    public void removeAnnotationEntries()
-	{
-		annotation_vec.clear();
-	}
+    
+    
 
 
     /**
@@ -130,11 +107,7 @@ public abstract class FieldGenOrMethodGen extends AccessFlags implements NamedAn
         return attributes;
     }
     
-    public AnnotationEntryGen[] getAnnotationEntries() {
-    	AnnotationEntryGen[] annotations = new AnnotationEntryGen[annotation_vec.size()];
-      	annotation_vec.toArray(annotations);
-      	return annotations;
-      }
+    
 
 
     /** @return signature of method/field.

==================================================
FieldObserver.java
index b3a8707b30..f32325c4eb 100644
--- a/java/org/apache/tomcat/util/bcel/generic/FieldInstruction.java
+++ b/java/org/apache/tomcat/util/bcel/generic/FieldInstruction.java
@@ -34,12 +34,7 @@ public abstract class FieldInstruction extends FieldOrMethod implements TypedIns
     }
 
 
-    /**
-     * @param index to constant pool
-     */
-    protected FieldInstruction(short opcode, int index) {
-        super(opcode, index);
-    }
+    
 
 
     /**
@@ -72,9 +67,5 @@ public abstract class FieldInstruction extends FieldOrMethod implements TypedIns
     }
 
 
-    /** @return name of referenced field.
-     */
-    public String getFieldName( ConstantPoolGen cpg ) {
-        return getName(cpg);
-    }
+    
 }

==================================================
FieldOrMethod.java
deleted file mode 100644
index da42468e00..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/FieldObserver.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * Imnplement this interface if you're interested in changes to a FieldGen object
- * and register yourself with addObserver().
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public interface FieldObserver {
-
-    public void notify( FieldGen field );
-}

==================================================
GETFIELD.java
index 01d3b95337..8322e03753 100644
--- a/java/org/apache/tomcat/util/bcel/generic/FieldOrMethod.java
+++ b/java/org/apache/tomcat/util/bcel/generic/FieldOrMethod.java
@@ -38,12 +38,7 @@ public abstract class FieldOrMethod extends CPInstruction implements LoadClass {
     }
 
 
-    /**
-     * @param index to constant pool
-     */
-    protected FieldOrMethod(short opcode, int index) {
-        super(opcode, index);
-    }
+    
 
 
     /** @return signature of referenced method/field.
@@ -56,14 +51,7 @@ public abstract class FieldOrMethod extends CPInstruction implements LoadClass {
     }
 
 
-    /** @return name of referenced method/field.
-     */
-    public String getName( ConstantPoolGen cpg ) {
-        ConstantPool cp = cpg.getConstantPool();
-        ConstantCP cmr = (ConstantCP) cp.getConstant(index);
-        ConstantNameAndType cnat = (ConstantNameAndType) cp.getConstant(cmr.getNameAndTypeIndex());
-        return ((ConstantUtf8) cp.getConstant(cnat.getNameIndex())).getBytes();
-    }
+    
 
 
     /** @return name of the referenced class/interface
@@ -88,41 +76,11 @@ public abstract class FieldOrMethod extends CPInstruction implements LoadClass {
     }
 
 
-    /** @return type of the referenced class/interface
-     * @deprecated If the instruction references an array class,
-     *    the ObjectType returned will be invalid.  Use
-     *    getReferenceType() instead.
-     */
-    public ObjectType getClassType( ConstantPoolGen cpg ) {
-        return new ObjectType(getClassName(cpg));
-    }
+    
 
 
-    /**
-     * Return the reference type representing the class, interface,
-     * or array class referenced by the instruction.
-     * @param cpg the ConstantPoolGen used to create the instruction
-     * @return an ObjectType (if the referenced class type is a class
-     *   or interface), or an ArrayType (if the referenced class
-     *   type is an array class)
-     */
-    public ReferenceType getReferenceType( ConstantPoolGen cpg ) {
-        ConstantPool cp = cpg.getConstantPool();
-        ConstantCP cmr = (ConstantCP) cp.getConstant(index);
-        String className = cp.getConstantString(cmr.getClassIndex(),
-                org.apache.tomcat.util.bcel.Constants.CONSTANT_Class);
-        if (className.startsWith("[")) {
-            return (ArrayType) Type.getType(className);
-        } else {
-            className = className.replace('/', '.');
-            return new ObjectType(className);
-        }
-    }
+    
 
 
-    /** @return type of the referenced class/interface
-     */
-    public ObjectType getLoadClassType( ConstantPoolGen cpg ) {
-        return getClassType(cpg);
-    }
+    
 }

==================================================
GETSTATIC.java
index ae5f913844..1e69c394ed 100644
--- a/java/org/apache/tomcat/util/bcel/generic/GETFIELD.java
+++ b/java/org/apache/tomcat/util/bcel/generic/GETFIELD.java
@@ -16,9 +16,6 @@
  */
 package org.apache.tomcat.util.bcel.generic;
 
-import org.apache.tomcat.util.bcel.Constants;
-import org.apache.tomcat.util.bcel.ExceptionConstants;
-
 /** 
  * GETFIELD - Fetch field from object
  * <PRE>Stack: ..., objectref -&gt; ..., value</PRE>
@@ -39,9 +36,7 @@ public class GETFIELD extends FieldInstruction implements ExceptionThrower, Stac
     }
 
 
-    public GETFIELD(int index) {
-        super(Constants.GETFIELD, index);
-    }
+    
 
 
     public int produceStack( ConstantPoolGen cpg ) {
@@ -49,12 +44,5 @@ public class GETFIELD extends FieldInstruction implements ExceptionThrower, Stac
     }
 
 
-    public Class[] getExceptions() {
-        Class[] cs = new Class[2 + ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION.length];
-        System.arraycopy(ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION, 0, cs, 0,
-                ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION.length);
-        cs[ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION.length + 1] = ExceptionConstants.INCOMPATIBLE_CLASS_CHANGE_ERROR;
-        cs[ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION.length] = ExceptionConstants.NULL_POINTER_EXCEPTION;
-        return cs;
-    }
+    
 }

==================================================
GOTO.java
index b7738aeecb..3730797ec6 100644
--- a/java/org/apache/tomcat/util/bcel/generic/GETSTATIC.java
+++ b/java/org/apache/tomcat/util/bcel/generic/GETSTATIC.java
@@ -16,9 +16,6 @@
  */
 package org.apache.tomcat.util.bcel.generic;
 
-import org.apache.tomcat.util.bcel.Constants;
-import org.apache.tomcat.util.bcel.ExceptionConstants;
-
 /** 
  * GETSTATIC - Fetch static field from class
  * <PRE>Stack: ..., -&gt; ..., value</PRE>
@@ -38,9 +35,7 @@ public class GETSTATIC extends FieldInstruction implements PushInstruction, Exce
     }
 
 
-    public GETSTATIC(int index) {
-        super(Constants.GETSTATIC, index);
-    }
+    
 
 
     public int produceStack( ConstantPoolGen cpg ) {
@@ -48,11 +43,5 @@ public class GETSTATIC extends FieldInstruction implements PushInstruction, Exce
     }
 
 
-    public Class[] getExceptions() {
-        Class[] cs = new Class[1 + ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION.length];
-        System.arraycopy(ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION, 0, cs, 0,
-                ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION.length);
-        cs[ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION.length] = ExceptionConstants.INCOMPATIBLE_CLASS_CHANGE_ERROR;
-        return cs;
-    }
+    
 }

==================================================
GOTO_W.java
index 275a5f9401..082265f584 100644
--- a/java/org/apache/tomcat/util/bcel/generic/GOTO.java
+++ b/java/org/apache/tomcat/util/bcel/generic/GOTO.java
@@ -35,9 +35,7 @@ public class GOTO extends GotoInstruction implements VariableLengthInstruction {
     }
 
 
-    public GOTO(InstructionHandle target) {
-        super(org.apache.tomcat.util.bcel.Constants.GOTO, target);
-    }
+    
 
 
     /**

==================================================
GotoInstruction.java
index b7546cf816..c678f32ca2 100644
--- a/java/org/apache/tomcat/util/bcel/generic/GOTO_W.java
+++ b/java/org/apache/tomcat/util/bcel/generic/GOTO_W.java
@@ -36,10 +36,7 @@ public class GOTO_W extends GotoInstruction {
     }
 
 
-    public GOTO_W(InstructionHandle target) {
-        super(org.apache.tomcat.util.bcel.Constants.GOTO_W, target);
-        length = 5;
-    }
+    
 
 
     /**

==================================================
I2B.java
index cd82eab5de..53a7a76016 100644
--- a/java/org/apache/tomcat/util/bcel/generic/GotoInstruction.java
+++ b/java/org/apache/tomcat/util/bcel/generic/GotoInstruction.java
@@ -24,9 +24,7 @@ package org.apache.tomcat.util.bcel.generic;
  */
 public abstract class GotoInstruction extends BranchInstruction implements UnconditionalBranch {
 
-    GotoInstruction(short opcode, InstructionHandle target) {
-        super(opcode, target);
-    }
+    
 
 
     /**

==================================================
I2C.java
deleted file mode 100644
index e463733f91..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/I2B.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * I2B - Convert int to byte
- * <PRE>Stack: ..., value -&gt; ..., result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class I2B extends ConversionInstruction {
-
-    /** Convert int to byte
-     */
-    public I2B() {
-        super(org.apache.tomcat.util.bcel.Constants.I2B);
-    }
-}

==================================================
I2D.java
deleted file mode 100644
index 45b35b4b11..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/I2C.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * I2C - Convert int to char
- * <PRE>Stack: ..., value -&gt; ..., result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class I2C extends ConversionInstruction {
-
-    /** Convert int to char
-     */
-    public I2C() {
-        super(org.apache.tomcat.util.bcel.Constants.I2C);
-    }
-}

==================================================
I2F.java
deleted file mode 100644
index 354a9dfb44..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/I2D.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * I2D - Convert int to double
- * <PRE>Stack: ..., value -&gt; ..., result.word1, result.word2</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class I2D extends ConversionInstruction {
-
-    /** Convert int to double
-     */
-    public I2D() {
-        super(org.apache.tomcat.util.bcel.Constants.I2D);
-    }
-}

==================================================
I2L.java
deleted file mode 100644
index 08415e5186..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/I2F.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * I2F - Convert int to float
- * <PRE>Stack: ..., value -&gt; ..., result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class I2F extends ConversionInstruction {
-
-    /** Convert int to float
-     */
-    public I2F() {
-        super(org.apache.tomcat.util.bcel.Constants.I2F);
-    }
-}

==================================================
I2S.java
deleted file mode 100644
index 1f77f4e9de..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/I2L.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * I2L - Convert int to long
- * <PRE>Stack: ..., value -&gt; ..., result.word1, result.word2</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class I2L extends ConversionInstruction {
-
-    /** Convert int to long
-     */
-    public I2L() {
-        super(org.apache.tomcat.util.bcel.Constants.I2L);
-    }
-}

==================================================
IADD.java
deleted file mode 100644
index 48a4769332..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/I2S.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * I2S - Convert int to short
- * <PRE>Stack: ..., value -&gt; ..., result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class I2S extends ConversionInstruction {
-
-    public I2S() {
-        super(org.apache.tomcat.util.bcel.Constants.I2S);
-    }
-}

==================================================
IALOAD.java
deleted file mode 100644
index 1b02a92ea0..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/IADD.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * IADD - Add ints
- * <PRE>Stack: ..., value1, value2 -&gt; result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class IADD extends ArithmeticInstruction {
-
-    /** Add ints
-     */
-    public IADD() {
-        super(org.apache.tomcat.util.bcel.Constants.IADD);
-    }
-}

==================================================
IAND.java
deleted file mode 100644
index c07ad8f69a..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/IALOAD.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * IALOAD - Load int from array
- * <PRE>Stack: ..., arrayref, index -&gt; ..., value</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class IALOAD extends ArrayInstruction implements StackProducer {
-
-    /** 
-     * Load int from array
-     */
-    public IALOAD() {
-        super(org.apache.tomcat.util.bcel.Constants.IALOAD);
-    }
-}

==================================================
IASTORE.java
deleted file mode 100644
index fae85c76ba..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/IAND.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * IAND - Bitwise AND int
- * <PRE>Stack: ..., value1, value2 -&gt; ..., result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class IAND extends ArithmeticInstruction {
-
-    public IAND() {
-        super(org.apache.tomcat.util.bcel.Constants.IAND);
-    }
-}

==================================================
ICONST.java
deleted file mode 100644
index 860d7ed6a3..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/IASTORE.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * IASTORE -  Store into int array
- * <PRE>Stack: ..., arrayref, index, value -&gt; ...</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class IASTORE extends ArrayInstruction implements StackConsumer {
-
-    /** 
-     * Store into int array
-     */
-    public IASTORE() {
-        super(org.apache.tomcat.util.bcel.Constants.IASTORE);
-    }
-}

==================================================
IDIV.java
deleted file mode 100644
index ad75d294a9..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/ICONST.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * ICONST - Push value between -1, ..., 5, other values cause an exception
- *
- * <PRE>Stack: ... -&gt; ..., </PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class ICONST extends Instruction implements ConstantPushInstruction, TypedInstruction {
-
-    private int value;
-
-
-    /**
-     * Empty constructor needed for the Class.newInstance() statement in
-     * Instruction.readInstruction(). Not to be used otherwise.
-     */
-    ICONST() {
-    }
-
-
-    public ICONST(int i) {
-        super(org.apache.tomcat.util.bcel.Constants.ICONST_0, (short) 1);
-        if ((i >= -1) && (i <= 5)) {
-            opcode = (short) (org.apache.tomcat.util.bcel.Constants.ICONST_0 + i); // Even works for i == -1
-        } else {
-            throw new ClassGenException("ICONST can be used only for value between -1 and 5: " + i);
-        }
-        value = i;
-    }
-
-
-    public Number getValue() {
-        return new Integer(value);
-    }
-
-
-    /** @return Type.INT
-     */
-    public Type getType( ConstantPoolGen cp ) {
-        return Type.INT;
-    }
-}

==================================================
IINC.java
deleted file mode 100644
index 7fb1b07ea7..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/IDIV.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * IDIV - Divide ints
- * <PRE>Stack: ..., value1, value2 -&gt; result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class IDIV extends ArithmeticInstruction implements ExceptionThrower {
-
-    /** Divide ints
-     */
-    public IDIV() {
-        super(org.apache.tomcat.util.bcel.Constants.IDIV);
-    }
-
-
-    /** @return exceptions this instruction may cause
-     */
-    public Class[] getExceptions() {
-        return new Class[] {
-            org.apache.tomcat.util.bcel.ExceptionConstants.ARITHMETIC_EXCEPTION
-        };
-    }
-}

==================================================
IMUL.java
index cba2ebf4ce..b152d50be9 100644
--- a/java/org/apache/tomcat/util/bcel/generic/IINC.java
+++ b/java/org/apache/tomcat/util/bcel/generic/IINC.java
@@ -40,17 +40,7 @@ public class IINC extends LocalVariableInstruction {
     }
 
 
-    /**
-     * @param n index of local variable
-     * @param c increment factor
-     */
-    public IINC(int n, int c) {
-        super(); // Default behaviour of LocalVariableInstruction causes error
-        this.opcode = org.apache.tomcat.util.bcel.Constants.IINC;
-        this.length = (short) 3;
-        setIndex(n); // May set wide as side effect
-        setIncrement(c);
-    }
+    
 
 
     /**
@@ -119,21 +109,10 @@ public class IINC extends LocalVariableInstruction {
     }
 
 
-    /**
-     * @return increment factor
-     */
-    public final int getIncrement() {
-        return c;
-    }
+    
 
 
-    /**
-     * Set increment factor.
-     */
-    public final void setIncrement( int c ) {
-        this.c = c;
-        setWide();
-    }
+    
 
 
     /** @return int type

==================================================
INEG.java
deleted file mode 100644
index 3d0a801b29..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/IMUL.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * IMUL - Multiply ints
- * <PRE>Stack: ..., value1, value2 -&gt; result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class IMUL extends ArithmeticInstruction {
-
-    /** Multiply ints
-     */
-    public IMUL() {
-        super(org.apache.tomcat.util.bcel.Constants.IMUL);
-    }
-}

==================================================
INSTANCEOF.java
deleted file mode 100644
index 8096c0b309..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/INEG.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * INEG - Negate int
- * <PRE>Stack: ..., value -&gt; ..., result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class INEG extends ArithmeticInstruction {
-
-    public INEG() {
-        super(org.apache.tomcat.util.bcel.Constants.INEG);
-    }
-}

==================================================
INVOKEINTERFACE.java
index edda28bdf4..d09f06eb0d 100644
--- a/java/org/apache/tomcat/util/bcel/generic/INSTANCEOF.java
+++ b/java/org/apache/tomcat/util/bcel/generic/INSTANCEOF.java
@@ -34,21 +34,11 @@ public class INSTANCEOF extends CPInstruction implements LoadClass, ExceptionThr
     }
 
 
-    public INSTANCEOF(int index) {
-        super(org.apache.tomcat.util.bcel.Constants.INSTANCEOF, index);
-    }
+    
 
 
-    public Class[] getExceptions() {
-        return org.apache.tomcat.util.bcel.ExceptionConstants.EXCS_CLASS_AND_INTERFACE_RESOLUTION;
-    }
+    
 
 
-    public ObjectType getLoadClassType( ConstantPoolGen cpg ) {
-        Type t = getType(cpg);
-        if (t instanceof ArrayType) {
-            t = ((ArrayType) t).getBasicType();
-        }
-        return (t instanceof ObjectType) ? (ObjectType) t : null;
-    }
+    
 }

==================================================
INVOKESPECIAL.java
index 669dbf0052..703496bfef 100644
--- a/java/org/apache/tomcat/util/bcel/generic/INVOKEINTERFACE.java
+++ b/java/org/apache/tomcat/util/bcel/generic/INVOKEINTERFACE.java
@@ -18,8 +18,6 @@ package org.apache.tomcat.util.bcel.generic;
 
 import java.io.DataOutputStream;
 import java.io.IOException;
-import org.apache.tomcat.util.bcel.Constants;
-import org.apache.tomcat.util.bcel.ExceptionConstants;
 import org.apache.tomcat.util.bcel.classfile.ConstantPool;
 import org.apache.tomcat.util.bcel.util.ByteSequence;
 
@@ -43,14 +41,7 @@ public final class INVOKEINTERFACE extends InvokeInstruction {
     }
 
 
-    public INVOKEINTERFACE(int index, int nargs) {
-        super(Constants.INVOKEINTERFACE, index);
-        length = 5;
-        if (nargs < 1) {
-            throw new ClassGenException("Number of arguments must be > 0 " + nargs);
-        }
-        this.nargs = nargs;
-    }
+    
 
 
     /**
@@ -65,13 +56,7 @@ public final class INVOKEINTERFACE extends InvokeInstruction {
     }
 
 
-    /**
-     * The <B>count</B> argument according to the Java Language Specification,
-     * Second Edition.
-     */
-    public int getCount() {
-        return nargs;
-    }
+    
 
 
     /**
@@ -98,14 +83,5 @@ public final class INVOKEINTERFACE extends InvokeInstruction {
     }
 
 
-    public Class[] getExceptions() {
-        Class[] cs = new Class[4 + ExceptionConstants.EXCS_INTERFACE_METHOD_RESOLUTION.length];
-        System.arraycopy(ExceptionConstants.EXCS_INTERFACE_METHOD_RESOLUTION, 0, cs, 0,
-                ExceptionConstants.EXCS_INTERFACE_METHOD_RESOLUTION.length);
-        cs[ExceptionConstants.EXCS_INTERFACE_METHOD_RESOLUTION.length + 3] = ExceptionConstants.INCOMPATIBLE_CLASS_CHANGE_ERROR;
-        cs[ExceptionConstants.EXCS_INTERFACE_METHOD_RESOLUTION.length + 2] = ExceptionConstants.ILLEGAL_ACCESS_ERROR;
-        cs[ExceptionConstants.EXCS_INTERFACE_METHOD_RESOLUTION.length + 1] = ExceptionConstants.ABSTRACT_METHOD_ERROR;
-        cs[ExceptionConstants.EXCS_INTERFACE_METHOD_RESOLUTION.length] = ExceptionConstants.UNSATISFIED_LINK_ERROR;
-        return cs;
-    }
+    
 }

==================================================
INVOKESTATIC.java
index 764d371d8b..9e17157d6c 100644
--- a/java/org/apache/tomcat/util/bcel/generic/INVOKESPECIAL.java
+++ b/java/org/apache/tomcat/util/bcel/generic/INVOKESPECIAL.java
@@ -16,9 +16,6 @@
  */
 package org.apache.tomcat.util.bcel.generic;
 
-import org.apache.tomcat.util.bcel.Constants;
-import org.apache.tomcat.util.bcel.ExceptionConstants;
-
 /** 
  * INVOKESPECIAL - Invoke instance method; special handling for superclass, private
  * and instance initialization method invocations
@@ -38,19 +35,8 @@ public class INVOKESPECIAL extends InvokeInstruction {
     }
 
 
-    public INVOKESPECIAL(int index) {
-        super(Constants.INVOKESPECIAL, index);
-    }
+    
 
 
-    public Class[] getExceptions() {
-        Class[] cs = new Class[4 + ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION.length];
-        System.arraycopy(ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION, 0, cs, 0,
-                ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION.length);
-        cs[ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION.length + 3] = ExceptionConstants.UNSATISFIED_LINK_ERROR;
-        cs[ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION.length + 2] = ExceptionConstants.ABSTRACT_METHOD_ERROR;
-        cs[ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION.length + 1] = ExceptionConstants.INCOMPATIBLE_CLASS_CHANGE_ERROR;
-        cs[ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION.length] = ExceptionConstants.NULL_POINTER_EXCEPTION;
-        return cs;
-    }
+    
 }

==================================================
INVOKEVIRTUAL.java
index 78f252d7f5..09d130dd3d 100644
--- a/java/org/apache/tomcat/util/bcel/generic/INVOKESTATIC.java
+++ b/java/org/apache/tomcat/util/bcel/generic/INVOKESTATIC.java
@@ -16,9 +16,6 @@
  */
 package org.apache.tomcat.util.bcel.generic;
 
-import org.apache.tomcat.util.bcel.Constants;
-import org.apache.tomcat.util.bcel.ExceptionConstants;
-
 /** 
  * INVOKESTATIC - Invoke a class (static) method
  *
@@ -37,17 +34,8 @@ public class INVOKESTATIC extends InvokeInstruction {
     }
 
 
-    public INVOKESTATIC(int index) {
-        super(Constants.INVOKESTATIC, index);
-    }
+    
 
 
-    public Class[] getExceptions() {
-        Class[] cs = new Class[2 + ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION.length];
-        System.arraycopy(ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION, 0, cs, 0,
-                ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION.length);
-        cs[ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION.length] = ExceptionConstants.UNSATISFIED_LINK_ERROR;
-        cs[ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION.length + 1] = ExceptionConstants.INCOMPATIBLE_CLASS_CHANGE_ERROR;
-        return cs;
-    }
+    
 }

==================================================
IOR.java
index 38eccfb7c0..37e6fc1f26 100644
--- a/java/org/apache/tomcat/util/bcel/generic/INVOKEVIRTUAL.java
+++ b/java/org/apache/tomcat/util/bcel/generic/INVOKEVIRTUAL.java
@@ -16,9 +16,6 @@
  */
 package org.apache.tomcat.util.bcel.generic;
 
-import org.apache.tomcat.util.bcel.Constants;
-import org.apache.tomcat.util.bcel.ExceptionConstants;
-
 /** 
  * INVOKEVIRTUAL - Invoke instance method; dispatch based on class
  *
@@ -37,19 +34,8 @@ public class INVOKEVIRTUAL extends InvokeInstruction {
     }
 
 
-    public INVOKEVIRTUAL(int index) {
-        super(Constants.INVOKEVIRTUAL, index);
-    }
+    
 
 
-    public Class[] getExceptions() {
-        Class[] cs = new Class[4 + ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION.length];
-        System.arraycopy(ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION, 0, cs, 0,
-                ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION.length);
-        cs[ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION.length + 3] = ExceptionConstants.UNSATISFIED_LINK_ERROR;
-        cs[ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION.length + 2] = ExceptionConstants.ABSTRACT_METHOD_ERROR;
-        cs[ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION.length + 1] = ExceptionConstants.INCOMPATIBLE_CLASS_CHANGE_ERROR;
-        cs[ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION.length] = ExceptionConstants.NULL_POINTER_EXCEPTION;
-        return cs;
-    }
+    
 }

==================================================
IREM.java
deleted file mode 100644
index fb16d474b9..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/IOR.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * IOR - Bitwise OR int
- * <PRE>Stack: ..., value1, value2 -&gt; ..., result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class IOR extends ArithmeticInstruction {
-
-    public IOR() {
-        super(org.apache.tomcat.util.bcel.Constants.IOR);
-    }
-}

==================================================
IRETURN.java
deleted file mode 100644
index cc3d00c6d5..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/IREM.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * IREM - Remainder of int
- * <PRE>Stack: ..., value1, value2 -&gt; result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class IREM extends ArithmeticInstruction implements ExceptionThrower {
-
-    /** Remainder of ints
-     */
-    public IREM() {
-        super(org.apache.tomcat.util.bcel.Constants.IREM);
-    }
-
-
-    /** @return exceptions this instruction may cause
-     */
-    public Class[] getExceptions() {
-        return new Class[] {
-            org.apache.tomcat.util.bcel.ExceptionConstants.ARITHMETIC_EXCEPTION
-        };
-    }
-}

==================================================
ISHL.java
deleted file mode 100644
index 75206585d1..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/IRETURN.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * IRETURN -  Return int from method
- * <PRE>Stack: ..., value -&gt; &lt;empty&gt;</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class IRETURN extends ReturnInstruction {
-
-    /** Return int from method
-     */
-    public IRETURN() {
-        super(org.apache.tomcat.util.bcel.Constants.IRETURN);
-    }
-}

==================================================
ISHR.java
deleted file mode 100644
index 66e5194067..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/ISHL.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * ISHL - Arithmetic shift left int
- * <PRE>Stack: ..., value1, value2 -&gt; ..., result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class ISHL extends ArithmeticInstruction {
-
-    public ISHL() {
-        super(org.apache.tomcat.util.bcel.Constants.ISHL);
-    }
-}

==================================================
ISUB.java
deleted file mode 100644
index 26fa178efe..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/ISHR.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * ISHR - Arithmetic shift right int
- * <PRE>Stack: ..., value1, value2 -&gt; ..., result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class ISHR extends ArithmeticInstruction {
-
-    public ISHR() {
-        super(org.apache.tomcat.util.bcel.Constants.ISHR);
-    }
-}

==================================================
IUSHR.java
deleted file mode 100644
index c36b61ef93..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/ISUB.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * ISUB - Substract ints
- * <PRE>Stack: ..., value1, value2 -&gt; result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class ISUB extends ArithmeticInstruction {
-
-    /** Substract ints
-     */
-    public ISUB() {
-        super(org.apache.tomcat.util.bcel.Constants.ISUB);
-    }
-}

==================================================
IXOR.java
deleted file mode 100644
index 28cf19e7cf..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/IUSHR.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * IUSHR - Logical shift right int
- * <PRE>Stack: ..., value1, value2 -&gt; ..., result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class IUSHR extends ArithmeticInstruction {
-
-    public IUSHR() {
-        super(org.apache.tomcat.util.bcel.Constants.IUSHR);
-    }
-}

==================================================
Instruction.java
deleted file mode 100644
index cc58262fe8..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/IXOR.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * IXOR - Bitwise XOR int
- * <PRE>Stack: ..., value1, value2 -&gt; ..., result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class IXOR extends ArithmeticInstruction {
-
-    public IXOR() {
-        super(org.apache.tomcat.util.bcel.Constants.IXOR);
-    }
-}

==================================================
InstructionConstants.java
index ec4d52aea3..a46d0bc4cd 100644
--- a/java/org/apache/tomcat/util/bcel/generic/Instruction.java
+++ b/java/org/apache/tomcat/util/bcel/generic/Instruction.java
@@ -19,7 +19,6 @@ package org.apache.tomcat.util.bcel.generic;
 import java.io.DataOutputStream;
 import java.io.IOException;
 import java.io.Serializable;
-import java.util.Locale;
 import org.apache.tomcat.util.bcel.Constants;
 import org.apache.tomcat.util.bcel.classfile.ConstantPool;
 import org.apache.tomcat.util.bcel.util.ByteSequence;
@@ -101,28 +100,7 @@ public abstract class Instruction implements Cloneable, Serializable {
     }
 
 
-    /**
-     * Use with caution, since `BranchInstruction's have a `target' reference which
-     * is not copied correctly (only basic types are). This also applies for 
-     * `Select' instructions with their multiple branch targets.
-     *
-     * @see BranchInstruction
-     * @return (shallow) copy of an instruction
-     */
-    public Instruction copy() {
-        Instruction i = null;
-        // "Constant" instruction, no need to duplicate
-        if (InstructionConstants.INSTRUCTIONS[this.getOpcode()] != null) {
-            i = this;
-        } else {
-            try {
-                i = (Instruction) clone();
-            } catch (CloneNotSupportedException e) {
-                System.err.println(e);
-            }
-        }
-        return i;
-    }
+    
 
 
     /**
@@ -511,21 +489,10 @@ public abstract class Instruction implements Cloneable, Serializable {
     }
 
 
-    /** Get Comparator object used in the equals() method to determine
-     * equality of instructions.
-     *
-     * @return currently used comparator for equals()
-     */
-    public static InstructionComparator getComparator() {
-        return cmp;
-    }
+    
 
 
-    /** Set comparator to be used for equals().
-     */
-    public static void setComparator( InstructionComparator c ) {
-        cmp = c;
-    }
+    
 
 
     /** Check for equality, delegated to comparator

==================================================
InstructionHandle.java
index 817015a484..ba5c7be413 100644
--- a/java/org/apache/tomcat/util/bcel/generic/InstructionConstants.java
+++ b/java/org/apache/tomcat/util/bcel/generic/InstructionConstants.java
@@ -16,8 +16,6 @@
  */
 package org.apache.tomcat.util.bcel.generic;
 
-import org.apache.tomcat.util.bcel.Constants;
-
 /** 
  * This interface contains shareable instruction objects.
  *
@@ -37,250 +35,131 @@ import org.apache.tomcat.util.bcel.Constants;
  */
 public interface InstructionConstants {
 
-    /** Predefined instruction objects
-     */
-    public static final Instruction NOP = new NOP();
-    public static final Instruction ACONST_NULL = new ACONST_NULL();
-    public static final Instruction ICONST_M1 = new ICONST(-1);
-    public static final Instruction ICONST_0 = new ICONST(0);
-    public static final Instruction ICONST_1 = new ICONST(1);
-    public static final Instruction ICONST_2 = new ICONST(2);
-    public static final Instruction ICONST_3 = new ICONST(3);
-    public static final Instruction ICONST_4 = new ICONST(4);
-    public static final Instruction ICONST_5 = new ICONST(5);
-    public static final Instruction LCONST_0 = new LCONST(0);
-    public static final Instruction LCONST_1 = new LCONST(1);
-    public static final Instruction FCONST_0 = new FCONST(0);
-    public static final Instruction FCONST_1 = new FCONST(1);
-    public static final Instruction FCONST_2 = new FCONST(2);
-    public static final Instruction DCONST_0 = new DCONST(0);
-    public static final Instruction DCONST_1 = new DCONST(1);
-    public static final ArrayInstruction IALOAD = new IALOAD();
-    public static final ArrayInstruction LALOAD = new LALOAD();
-    public static final ArrayInstruction FALOAD = new FALOAD();
-    public static final ArrayInstruction DALOAD = new DALOAD();
-    public static final ArrayInstruction AALOAD = new AALOAD();
-    public static final ArrayInstruction BALOAD = new BALOAD();
-    public static final ArrayInstruction CALOAD = new CALOAD();
-    public static final ArrayInstruction SALOAD = new SALOAD();
-    public static final ArrayInstruction IASTORE = new IASTORE();
-    public static final ArrayInstruction LASTORE = new LASTORE();
-    public static final ArrayInstruction FASTORE = new FASTORE();
-    public static final ArrayInstruction DASTORE = new DASTORE();
-    public static final ArrayInstruction AASTORE = new AASTORE();
-    public static final ArrayInstruction BASTORE = new BASTORE();
-    public static final ArrayInstruction CASTORE = new CASTORE();
-    public static final ArrayInstruction SASTORE = new SASTORE();
-    public static final StackInstruction POP = new POP();
-    public static final StackInstruction POP2 = new POP2();
-    public static final StackInstruction DUP = new DUP();
-    public static final StackInstruction DUP_X1 = new DUP_X1();
-    public static final StackInstruction DUP_X2 = new DUP_X2();
-    public static final StackInstruction DUP2 = new DUP2();
-    public static final StackInstruction DUP2_X1 = new DUP2_X1();
-    public static final StackInstruction DUP2_X2 = new DUP2_X2();
-    public static final StackInstruction SWAP = new SWAP();
-    public static final ArithmeticInstruction IADD = new IADD();
-    public static final ArithmeticInstruction LADD = new LADD();
-    public static final ArithmeticInstruction FADD = new FADD();
-    public static final ArithmeticInstruction DADD = new DADD();
-    public static final ArithmeticInstruction ISUB = new ISUB();
-    public static final ArithmeticInstruction LSUB = new LSUB();
-    public static final ArithmeticInstruction FSUB = new FSUB();
-    public static final ArithmeticInstruction DSUB = new DSUB();
-    public static final ArithmeticInstruction IMUL = new IMUL();
-    public static final ArithmeticInstruction LMUL = new LMUL();
-    public static final ArithmeticInstruction FMUL = new FMUL();
-    public static final ArithmeticInstruction DMUL = new DMUL();
-    public static final ArithmeticInstruction IDIV = new IDIV();
-    public static final ArithmeticInstruction LDIV = new LDIV();
-    public static final ArithmeticInstruction FDIV = new FDIV();
-    public static final ArithmeticInstruction DDIV = new DDIV();
-    public static final ArithmeticInstruction IREM = new IREM();
-    public static final ArithmeticInstruction LREM = new LREM();
-    public static final ArithmeticInstruction FREM = new FREM();
-    public static final ArithmeticInstruction DREM = new DREM();
-    public static final ArithmeticInstruction INEG = new INEG();
-    public static final ArithmeticInstruction LNEG = new LNEG();
-    public static final ArithmeticInstruction FNEG = new FNEG();
-    public static final ArithmeticInstruction DNEG = new DNEG();
-    public static final ArithmeticInstruction ISHL = new ISHL();
-    public static final ArithmeticInstruction LSHL = new LSHL();
-    public static final ArithmeticInstruction ISHR = new ISHR();
-    public static final ArithmeticInstruction LSHR = new LSHR();
-    public static final ArithmeticInstruction IUSHR = new IUSHR();
-    public static final ArithmeticInstruction LUSHR = new LUSHR();
-    public static final ArithmeticInstruction IAND = new IAND();
-    public static final ArithmeticInstruction LAND = new LAND();
-    public static final ArithmeticInstruction IOR = new IOR();
-    public static final ArithmeticInstruction LOR = new LOR();
-    public static final ArithmeticInstruction IXOR = new IXOR();
-    public static final ArithmeticInstruction LXOR = new LXOR();
-    public static final ConversionInstruction I2L = new I2L();
-    public static final ConversionInstruction I2F = new I2F();
-    public static final ConversionInstruction I2D = new I2D();
-    public static final ConversionInstruction L2I = new L2I();
-    public static final ConversionInstruction L2F = new L2F();
-    public static final ConversionInstruction L2D = new L2D();
-    public static final ConversionInstruction F2I = new F2I();
-    public static final ConversionInstruction F2L = new F2L();
-    public static final ConversionInstruction F2D = new F2D();
-    public static final ConversionInstruction D2I = new D2I();
-    public static final ConversionInstruction D2L = new D2L();
-    public static final ConversionInstruction D2F = new D2F();
-    public static final ConversionInstruction I2B = new I2B();
-    public static final ConversionInstruction I2C = new I2C();
-    public static final ConversionInstruction I2S = new I2S();
-    public static final Instruction LCMP = new LCMP();
-    public static final Instruction FCMPL = new FCMPL();
-    public static final Instruction FCMPG = new FCMPG();
-    public static final Instruction DCMPL = new DCMPL();
-    public static final Instruction DCMPG = new DCMPG();
-    public static final ReturnInstruction IRETURN = new IRETURN();
-    public static final ReturnInstruction LRETURN = new LRETURN();
-    public static final ReturnInstruction FRETURN = new FRETURN();
-    public static final ReturnInstruction DRETURN = new DRETURN();
-    public static final ReturnInstruction ARETURN = new ARETURN();
-    public static final ReturnInstruction RETURN = new RETURN();
-    public static final Instruction ARRAYLENGTH = new ARRAYLENGTH();
-    public static final Instruction ATHROW = new ATHROW();
-    public static final Instruction MONITORENTER = new MONITORENTER();
-    public static final Instruction MONITOREXIT = new MONITOREXIT();
-    /** You can use these constants in multiple places safely, if you can guarantee
-     * that you will never alter their internal values, e.g. call setIndex().
-     */
-    public static final LocalVariableInstruction THIS = new ALOAD(0);
-    public static final LocalVariableInstruction ALOAD_0 = THIS;
-    public static final LocalVariableInstruction ALOAD_1 = new ALOAD(1);
-    public static final LocalVariableInstruction ALOAD_2 = new ALOAD(2);
-    public static final LocalVariableInstruction ILOAD_0 = new ILOAD(0);
-    public static final LocalVariableInstruction ILOAD_1 = new ILOAD(1);
-    public static final LocalVariableInstruction ILOAD_2 = new ILOAD(2);
-    public static final LocalVariableInstruction ASTORE_0 = new ASTORE(0);
-    public static final LocalVariableInstruction ASTORE_1 = new ASTORE(1);
-    public static final LocalVariableInstruction ASTORE_2 = new ASTORE(2);
-    public static final LocalVariableInstruction ISTORE_0 = new ISTORE(0);
-    public static final LocalVariableInstruction ISTORE_1 = new ISTORE(1);
-    public static final LocalVariableInstruction ISTORE_2 = new ISTORE(2);
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
     /** Get object via its opcode, for immutable instructions like
      * branch instructions entries are set to null.
      */
     public static final Instruction[] INSTRUCTIONS = new Instruction[256];
-    /** Interfaces may have no static initializers, so we simulate this
-     * with an inner class.
-     */
-    static final Clinit bla = new Clinit();
-
-    static class Clinit {
+    
 
-        Clinit() {
-            INSTRUCTIONS[Constants.NOP] = NOP;
-            INSTRUCTIONS[Constants.ACONST_NULL] = ACONST_NULL;
-            INSTRUCTIONS[Constants.ICONST_M1] = ICONST_M1;
-            INSTRUCTIONS[Constants.ICONST_0] = ICONST_0;
-            INSTRUCTIONS[Constants.ICONST_1] = ICONST_1;
-            INSTRUCTIONS[Constants.ICONST_2] = ICONST_2;
-            INSTRUCTIONS[Constants.ICONST_3] = ICONST_3;
-            INSTRUCTIONS[Constants.ICONST_4] = ICONST_4;
-            INSTRUCTIONS[Constants.ICONST_5] = ICONST_5;
-            INSTRUCTIONS[Constants.LCONST_0] = LCONST_0;
-            INSTRUCTIONS[Constants.LCONST_1] = LCONST_1;
-            INSTRUCTIONS[Constants.FCONST_0] = FCONST_0;
-            INSTRUCTIONS[Constants.FCONST_1] = FCONST_1;
-            INSTRUCTIONS[Constants.FCONST_2] = FCONST_2;
-            INSTRUCTIONS[Constants.DCONST_0] = DCONST_0;
-            INSTRUCTIONS[Constants.DCONST_1] = DCONST_1;
-            INSTRUCTIONS[Constants.IALOAD] = IALOAD;
-            INSTRUCTIONS[Constants.LALOAD] = LALOAD;
-            INSTRUCTIONS[Constants.FALOAD] = FALOAD;
-            INSTRUCTIONS[Constants.DALOAD] = DALOAD;
-            INSTRUCTIONS[Constants.AALOAD] = AALOAD;
-            INSTRUCTIONS[Constants.BALOAD] = BALOAD;
-            INSTRUCTIONS[Constants.CALOAD] = CALOAD;
-            INSTRUCTIONS[Constants.SALOAD] = SALOAD;
-            INSTRUCTIONS[Constants.IASTORE] = IASTORE;
-            INSTRUCTIONS[Constants.LASTORE] = LASTORE;
-            INSTRUCTIONS[Constants.FASTORE] = FASTORE;
-            INSTRUCTIONS[Constants.DASTORE] = DASTORE;
-            INSTRUCTIONS[Constants.AASTORE] = AASTORE;
-            INSTRUCTIONS[Constants.BASTORE] = BASTORE;
-            INSTRUCTIONS[Constants.CASTORE] = CASTORE;
-            INSTRUCTIONS[Constants.SASTORE] = SASTORE;
-            INSTRUCTIONS[Constants.POP] = POP;
-            INSTRUCTIONS[Constants.POP2] = POP2;
-            INSTRUCTIONS[Constants.DUP] = DUP;
-            INSTRUCTIONS[Constants.DUP_X1] = DUP_X1;
-            INSTRUCTIONS[Constants.DUP_X2] = DUP_X2;
-            INSTRUCTIONS[Constants.DUP2] = DUP2;
-            INSTRUCTIONS[Constants.DUP2_X1] = DUP2_X1;
-            INSTRUCTIONS[Constants.DUP2_X2] = DUP2_X2;
-            INSTRUCTIONS[Constants.SWAP] = SWAP;
-            INSTRUCTIONS[Constants.IADD] = IADD;
-            INSTRUCTIONS[Constants.LADD] = LADD;
-            INSTRUCTIONS[Constants.FADD] = FADD;
-            INSTRUCTIONS[Constants.DADD] = DADD;
-            INSTRUCTIONS[Constants.ISUB] = ISUB;
-            INSTRUCTIONS[Constants.LSUB] = LSUB;
-            INSTRUCTIONS[Constants.FSUB] = FSUB;
-            INSTRUCTIONS[Constants.DSUB] = DSUB;
-            INSTRUCTIONS[Constants.IMUL] = IMUL;
-            INSTRUCTIONS[Constants.LMUL] = LMUL;
-            INSTRUCTIONS[Constants.FMUL] = FMUL;
-            INSTRUCTIONS[Constants.DMUL] = DMUL;
-            INSTRUCTIONS[Constants.IDIV] = IDIV;
-            INSTRUCTIONS[Constants.LDIV] = LDIV;
-            INSTRUCTIONS[Constants.FDIV] = FDIV;
-            INSTRUCTIONS[Constants.DDIV] = DDIV;
-            INSTRUCTIONS[Constants.IREM] = IREM;
-            INSTRUCTIONS[Constants.LREM] = LREM;
-            INSTRUCTIONS[Constants.FREM] = FREM;
-            INSTRUCTIONS[Constants.DREM] = DREM;
-            INSTRUCTIONS[Constants.INEG] = INEG;
-            INSTRUCTIONS[Constants.LNEG] = LNEG;
-            INSTRUCTIONS[Constants.FNEG] = FNEG;
-            INSTRUCTIONS[Constants.DNEG] = DNEG;
-            INSTRUCTIONS[Constants.ISHL] = ISHL;
-            INSTRUCTIONS[Constants.LSHL] = LSHL;
-            INSTRUCTIONS[Constants.ISHR] = ISHR;
-            INSTRUCTIONS[Constants.LSHR] = LSHR;
-            INSTRUCTIONS[Constants.IUSHR] = IUSHR;
-            INSTRUCTIONS[Constants.LUSHR] = LUSHR;
-            INSTRUCTIONS[Constants.IAND] = IAND;
-            INSTRUCTIONS[Constants.LAND] = LAND;
-            INSTRUCTIONS[Constants.IOR] = IOR;
-            INSTRUCTIONS[Constants.LOR] = LOR;
-            INSTRUCTIONS[Constants.IXOR] = IXOR;
-            INSTRUCTIONS[Constants.LXOR] = LXOR;
-            INSTRUCTIONS[Constants.I2L] = I2L;
-            INSTRUCTIONS[Constants.I2F] = I2F;
-            INSTRUCTIONS[Constants.I2D] = I2D;
-            INSTRUCTIONS[Constants.L2I] = L2I;
-            INSTRUCTIONS[Constants.L2F] = L2F;
-            INSTRUCTIONS[Constants.L2D] = L2D;
-            INSTRUCTIONS[Constants.F2I] = F2I;
-            INSTRUCTIONS[Constants.F2L] = F2L;
-            INSTRUCTIONS[Constants.F2D] = F2D;
-            INSTRUCTIONS[Constants.D2I] = D2I;
-            INSTRUCTIONS[Constants.D2L] = D2L;
-            INSTRUCTIONS[Constants.D2F] = D2F;
-            INSTRUCTIONS[Constants.I2B] = I2B;
-            INSTRUCTIONS[Constants.I2C] = I2C;
-            INSTRUCTIONS[Constants.I2S] = I2S;
-            INSTRUCTIONS[Constants.LCMP] = LCMP;
-            INSTRUCTIONS[Constants.FCMPL] = FCMPL;
-            INSTRUCTIONS[Constants.FCMPG] = FCMPG;
-            INSTRUCTIONS[Constants.DCMPL] = DCMPL;
-            INSTRUCTIONS[Constants.DCMPG] = DCMPG;
-            INSTRUCTIONS[Constants.IRETURN] = IRETURN;
-            INSTRUCTIONS[Constants.LRETURN] = LRETURN;
-            INSTRUCTIONS[Constants.FRETURN] = FRETURN;
-            INSTRUCTIONS[Constants.DRETURN] = DRETURN;
-            INSTRUCTIONS[Constants.ARETURN] = ARETURN;
-            INSTRUCTIONS[Constants.RETURN] = RETURN;
-            INSTRUCTIONS[Constants.ARRAYLENGTH] = ARRAYLENGTH;
-            INSTRUCTIONS[Constants.ATHROW] = ATHROW;
-            INSTRUCTIONS[Constants.MONITORENTER] = MONITORENTER;
-            INSTRUCTIONS[Constants.MONITOREXIT] = MONITOREXIT;
-        }
-    }
+    
 }

==================================================
InstructionList.java
index 9f6dbc7139..29501ccd0b 100644
--- a/java/org/apache/tomcat/util/bcel/generic/InstructionHandle.java
+++ b/java/org/apache/tomcat/util/bcel/generic/InstructionHandle.java
@@ -16,8 +16,6 @@
  */
 package org.apache.tomcat.util.bcel.generic;
 
-import java.util.Collection;
-import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
@@ -83,16 +81,7 @@ public class InstructionHandle implements java.io.Serializable {
     }
 
 
-    /**
-     * Temporarily swap the current instruction, without disturbing
-     * anything. Meant to be used by a debugger, implementing
-     * breakpoints. Current instruction is returned.
-     */
-    public Instruction swapInstruction( Instruction i ) {
-        Instruction oldInstruction = instruction;
-        instruction = i;
-        return oldInstruction;
-    }
+    
 
 
     /*private*/protected InstructionHandle(Instruction i) {
@@ -157,27 +146,10 @@ public class InstructionHandle implements java.io.Serializable {
     }
 
 
-    /**
-     * Delete contents, i.e., remove user access and make handle reusable.
-     */
-    void dispose() {
-        next = prev = null;
-        instruction.dispose();
-        instruction = null;
-        i_position = -1;
-        attributes = null;
-        removeAllTargeters();
-        addHandle();
-    }
+    
 
 
-    /** Remove all targeters, if any.
-     */
-    public void removeAllTargeters() {
-        if (targeters != null) {
-            targeters.clear();
-        }
-    }
+    
 
 
     /**
@@ -202,22 +174,10 @@ public class InstructionHandle implements java.io.Serializable {
     }
 
 
-    public boolean hasTargeters() {
-        return (targeters != null) && (targeters.size() > 0);
-    }
+    
 
 
-    /**
-     * @return null, if there are no targeters
-     */
-    public InstructionTargeter[] getTargeters() {
-        if (!hasTargeters()) {
-            return new InstructionTargeter[0];
-        }
-        InstructionTargeter[] t = new InstructionTargeter[targeters.size()];
-        targeters.toArray(t);
-        return t;
-    }
+    
 
 
     /** @return a (verbose) string representation of the contained instruction. 
@@ -234,48 +194,14 @@ public class InstructionHandle implements java.io.Serializable {
     }
 
 
-    /** Add an attribute to an instruction handle.
-     *
-     * @param key the key object to store/retrieve the attribute
-     * @param attr the attribute to associate with this handle
-     */
-    public void addAttribute( Object key, Object attr ) {
-        if (attributes == null) {
-            attributes = new HashMap(3);
-        }
-        attributes.put(key, attr);
-    }
+    
 
 
-    /** Delete an attribute of an instruction handle.
-     *
-     * @param key the key object to retrieve the attribute
-     */
-    public void removeAttribute( Object key ) {
-        if (attributes != null) {
-            attributes.remove(key);
-        }
-    }
+    
 
 
-    /** Get attribute of an instruction handle.
-     *
-     * @param key the key object to store/retrieve the attribute
-     */
-    public Object getAttribute( Object key ) {
-        if (attributes != null) {
-            return attributes.get(key);
-        }
-        return null;
-    }
+    
 
 
-    /** @return all attributes associated with this handle
-     */
-    public Collection getAttributes() {
-        if (attributes == null) {
-            attributes = new HashMap(3);
-        }
-        return attributes.values();
-    }
+    
 }

==================================================
InstructionListObserver.java
index dff58d052d..58be38c5b6 100644
--- a/java/org/apache/tomcat/util/bcel/generic/InstructionList.java
+++ b/java/org/apache/tomcat/util/bcel/generic/InstructionList.java
@@ -16,20 +16,9 @@
  */
 package org.apache.tomcat.util.bcel.generic;
 
-import java.io.ByteArrayOutputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
 import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
 import java.util.List;
-import java.util.Map;
-import java.util.NoSuchElementException;
-
 import org.apache.tomcat.util.bcel.Constants;
-import org.apache.tomcat.util.bcel.classfile.Constant;
-import org.apache.tomcat.util.bcel.util.ByteSequence;
 
 /** 
  * This class is a container for a list of <a
@@ -64,33 +53,13 @@ public class InstructionList implements Serializable {
     }
 
 
-    /**
-     * Create instruction list containing one instruction.
-     * @param i initial instruction
-     */
-    public InstructionList(Instruction i) {
-        append(i);
-    }
+    
 
 
-    /**
-     * Create instruction list containing one instruction.
-     * @param i initial instruction
-     */
-    public InstructionList(BranchInstruction i) {
-        append(i);
-    }
+    
 
 
-    /**
-     * Initialize list with (nonnull) compound instruction. Consumes argument
-     * list, i.e., it becomes empty.
-     *
-     * @param c compound instruction (list)
-     */
-    public InstructionList(CompoundInstruction c) {
-        append(c.getInstructionList());
-    }
+    
 
 
     /**
@@ -131,94 +100,10 @@ public class InstructionList implements Serializable {
     }
 
 
-    /**
-     * Get instruction handle for instruction at byte code position pos.
-     * This only works properly, if the list is freshly initialized from a byte array or
-     * setPositions() has been called before this method.
-     *
-     * @param pos byte code position to search for
-     * @return target position's instruction handle if available
-     */
-    public InstructionHandle findHandle( int pos ) {
-    	int[] positions = byte_positions;
-        InstructionHandle ih = start;
-        for (int i = 0; i < length; i++) { 
-            if(positions[i] == pos) {
-                return ih;
-            }
-            ih = ih.next;
-        }
-        return null;
-    }
+    
 
 
-    /**
-     * Initialize instruction list from byte array.
-     *
-     * @param code byte array containing the instructions
-     */
-    public InstructionList(byte[] code) {
-        ByteSequence bytes = new ByteSequence(code);
-        InstructionHandle[] ihs = new InstructionHandle[code.length];
-        int[] pos = new int[code.length]; // Can't be more than that
-        int count = 0; // Contains actual length
-        /* Pass 1: Create an object for each byte code and append them
-         * to the list.
-         */
-        try {
-            while (bytes.available() > 0) {
-                // Remember byte offset and associate it with the instruction
-                int off = bytes.getIndex();
-                pos[count] = off;
-                /* Read one instruction from the byte stream, the byte position is set
-                 * accordingly.
-                 */
-                Instruction i = Instruction.readInstruction(bytes);
-                InstructionHandle ih;
-                if (i instanceof BranchInstruction) {
-                    ih = append((BranchInstruction) i);
-                } else {
-                    ih = append(i);
-                }
-                ih.setPosition(off);
-                ihs[count] = ih;
-                count++;
-            }
-        } catch (IOException e) {
-            throw new ClassGenException(e.toString(), e);
-        }
-        byte_positions = new int[count]; // Trim to proper size
-        System.arraycopy(pos, 0, byte_positions, 0, count);
-        /* Pass 2: Look for BranchInstruction and update their targets, i.e.,
-         * convert offsets to instruction handles.
-         */
-        for (int i = 0; i < count; i++) {
-            if (ihs[i] instanceof BranchHandle) {
-                BranchInstruction bi = (BranchInstruction) ihs[i].instruction;
-                int target = bi.position + bi.getIndex(); /* Byte code position:
-                 * relative -> absolute. */
-                // Search for target position
-                InstructionHandle ih = findHandle(ihs, pos, count, target);
-                if (ih == null) {
-                    throw new ClassGenException("Couldn't find target for branch: " + bi);
-                }
-                bi.setTarget(ih); // Update target
-                // If it is a Select instruction, update all branch targets
-                if (bi instanceof Select) { // Either LOOKUPSWITCH or TABLESWITCH
-                    Select s = (Select) bi;
-                    int[] indices = s.getIndices();
-                    for (int j = 0; j < indices.length; j++) {
-                        target = bi.position + indices[j];
-                        ih = findHandle(ihs, pos, count, target);
-                        if (ih == null) {
-                            throw new ClassGenException("Couldn't find target for switch: " + bi);
-                        }
-                        s.setTarget(j, ih); // Update target      
-                    }
-                }
-            }
-        }
-    }
+    
 
 
     /**
@@ -251,47 +136,10 @@ public class InstructionList implements Serializable {
     }
 
 
-    /**
-     * Append another list after instruction i contained in this list.
-     * Consumes argument list, i.e., it becomes empty.
-     *
-     * @param i  where to append the instruction list 
-     * @param il Instruction list to append to this one
-     * @return instruction handle pointing to the <B>first</B> appended instruction
-     */
-    public InstructionHandle append( Instruction i, InstructionList il ) {
-        InstructionHandle ih;
-        if ((ih = findInstruction2(i)) == null) {
-            throw new ClassGenException("Instruction " + i + " is not contained in this list.");
-        }
-        return append(ih, il);
-    }
+    
 
 
-    /**
-     * Append another list to this one.
-     * Consumes argument list, i.e., it becomes empty.
-     *
-     * @param il list to append to end of this list
-     * @return instruction handle of the <B>first</B> appended instruction
-     */
-    public InstructionHandle append( InstructionList il ) {
-        if (il == null) {
-            throw new ClassGenException("Appending null InstructionList");
-        }
-        if (il.isEmpty()) {
-            return null;
-        }
-        if (isEmpty()) {
-            start = il.start;
-            end = il.end;
-            length = il.length;
-            il.clear();
-            return start;
-        } else {
-            return append(end, il); // was end.instruction
-        }
-    }
+    
 
 
     /**
@@ -339,455 +187,61 @@ public class InstructionList implements Serializable {
     }
 
 
-    /**
-     * Append a single instruction j after another instruction i, which
-     * must be in this list of course!
-     *
-     * @param i Instruction in list
-     * @param j Instruction to append after i in list
-     * @return instruction handle of the first appended instruction
-     */
-    public InstructionHandle append( Instruction i, Instruction j ) {
-        return append(i, new InstructionList(j));
-    }
+    
 
 
-    /**
-     * Append a compound instruction, after instruction i.
-     *
-     * @param i Instruction in list
-     * @param c The composite instruction (containing an InstructionList)
-     * @return instruction handle of the first appended instruction
-     */
-    public InstructionHandle append( Instruction i, CompoundInstruction c ) {
-        return append(i, c.getInstructionList());
-    }
+    
 
 
-    /**
-     * Append a compound instruction.
-     *
-     * @param c The composite instruction (containing an InstructionList)
-     * @return instruction handle of the first appended instruction
-     */
-    public InstructionHandle append( CompoundInstruction c ) {
-        return append(c.getInstructionList());
-    }
+    
 
 
-    /**
-     * Append a compound instruction.
-     *
-     * @param ih where to append the instruction list 
-     * @param c The composite instruction (containing an InstructionList)
-     * @return instruction handle of the first appended instruction
-     */
-    public InstructionHandle append( InstructionHandle ih, CompoundInstruction c ) {
-        return append(ih, c.getInstructionList());
-    }
+    
 
 
-    /**
-     * Append an instruction after instruction (handle) ih contained in this list.
-     *
-     * @param ih where to append the instruction list 
-     * @param i Instruction to append
-     * @return instruction handle pointing to the <B>first</B> appended instruction
-     */
-    public InstructionHandle append( InstructionHandle ih, Instruction i ) {
-        return append(ih, new InstructionList(i));
-    }
+    
 
 
-    /**
-     * Append an instruction after instruction (handle) ih contained in this list.
-     *
-     * @param ih where to append the instruction list 
-     * @param i Instruction to append
-     * @return instruction handle pointing to the <B>first</B> appended instruction
-     */
-    public BranchHandle append( InstructionHandle ih, BranchInstruction i ) {
-        BranchHandle bh = BranchHandle.getBranchHandle(i);
-        InstructionList il = new InstructionList();
-        il.append(bh);
-        append(ih, il);
-        return bh;
-    }
+    
 
 
-    /**
-     * Insert another list before Instruction handle ih contained in this list.
-     * Consumes argument list, i.e., it becomes empty.
-     *
-     * @param ih  where to append the instruction list 
-     * @param il Instruction list to insert
-     * @return instruction handle of the first inserted instruction
-     */
-    public InstructionHandle insert( InstructionHandle ih, InstructionList il ) {
-        if (il == null) {
-            throw new ClassGenException("Inserting null InstructionList");
-        }
-        if (il.isEmpty()) {
-            return ih;
-        }
-        InstructionHandle prev = ih.prev, ret = il.start;
-        ih.prev = il.end;
-        il.end.next = ih;
-        il.start.prev = prev;
-        if (prev != null) {
-            prev.next = il.start;
-        } else {
-            start = il.start; // Update start ...
-        }
-        length += il.length; // Update length
-        il.clear();
-        return ret;
-    }
+    
 
 
-    /**
-     * Insert another list.   
-     *
-     * @param il list to insert before start of this list
-     * @return instruction handle of the first inserted instruction
-     */
-    public InstructionHandle insert( InstructionList il ) {
-        if (isEmpty()) {
-            append(il); // Code is identical for this case
-            return start;
-        } else {
-            return insert(start, il);
-        }
-    }
+    
 
 
-    /**
-     * Insert an instruction at start of this list.
-     *
-     * @param ih instruction to insert
-     */
-    private void insert( InstructionHandle ih ) {
-        if (isEmpty()) {
-            start = end = ih;
-            ih.next = ih.prev = null;
-        } else {
-            start.prev = ih;
-            ih.next = start;
-            ih.prev = null;
-            start = ih;
-        }
-        length++;
-    }
+    
 
 
-    /**
-     * Insert another list before Instruction i contained in this list.
-     * Consumes argument list, i.e., it becomes empty.
-     *
-     * @param i  where to append the instruction list 
-     * @param il Instruction list to insert
-     * @return instruction handle pointing to the first inserted instruction,
-     * i.e., il.getStart()
-     */
-    public InstructionHandle insert( Instruction i, InstructionList il ) {
-        InstructionHandle ih;
-        if ((ih = findInstruction1(i)) == null) {
-            throw new ClassGenException("Instruction " + i + " is not contained in this list.");
-        }
-        return insert(ih, il);
-    }
+    
 
 
-    /**
-     * Insert an instruction at start of this list.
-     *
-     * @param i instruction to insert
-     * @return instruction handle of the inserted instruction
-     */
-    public InstructionHandle insert( Instruction i ) {
-        InstructionHandle ih = InstructionHandle.getInstructionHandle(i);
-        insert(ih);
-        return ih;
-    }
+    
 
 
-    /**
-     * Insert a branch instruction at start of this list.
-     *
-     * @param i branch instruction to insert
-     * @return branch instruction handle of the appended instruction
-     */
-    public BranchHandle insert( BranchInstruction i ) {
-        BranchHandle ih = BranchHandle.getBranchHandle(i);
-        insert(ih);
-        return ih;
-    }
+    
 
 
-    /**
-     * Insert a single instruction j before another instruction i, which
-     * must be in this list of course!
-     *
-     * @param i Instruction in list
-     * @param j Instruction to insert before i in list
-     * @return instruction handle of the first inserted instruction
-     */
-    public InstructionHandle insert( Instruction i, Instruction j ) {
-        return insert(i, new InstructionList(j));
-    }
+    
 
 
-    /**
-     * Insert a compound instruction before instruction i.
-     *
-     * @param i Instruction in list
-     * @param c The composite instruction (containing an InstructionList)
-     * @return instruction handle of the first inserted instruction
-     */
-    public InstructionHandle insert( Instruction i, CompoundInstruction c ) {
-        return insert(i, c.getInstructionList());
-    }
+    
 
 
-    /**
-     * Insert a compound instruction.
-     *
-     * @param c The composite instruction (containing an InstructionList)
-     * @return instruction handle of the first inserted instruction
-     */
-    public InstructionHandle insert( CompoundInstruction c ) {
-        return insert(c.getInstructionList());
-    }
+    
 
 
-    /**
-     * Insert an instruction before instruction (handle) ih contained in this list.
-     *
-     * @param ih where to insert to the instruction list 
-     * @param i Instruction to insert
-     * @return instruction handle of the first inserted instruction
-     */
-    public InstructionHandle insert( InstructionHandle ih, Instruction i ) {
-        return insert(ih, new InstructionList(i));
-    }
+    
 
 
-    /**
-     * Insert a compound instruction.
-     *
-     * @param ih where to insert the instruction list 
-     * @param c The composite instruction (containing an InstructionList)
-     * @return instruction handle of the first inserted instruction
-     */
-    public InstructionHandle insert( InstructionHandle ih, CompoundInstruction c ) {
-        return insert(ih, c.getInstructionList());
-    }
+    
 
 
-    /**
-     * Insert an instruction before instruction (handle) ih contained in this list.
-     *
-     * @param ih where to insert to the instruction list 
-     * @param i Instruction to insert
-     * @return instruction handle of the first inserted instruction
-     */
-    public BranchHandle insert( InstructionHandle ih, BranchInstruction i ) {
-        BranchHandle bh = BranchHandle.getBranchHandle(i);
-        InstructionList il = new InstructionList();
-        il.append(bh);
-        insert(ih, il);
-        return bh;
-    }
+    
 
 
-    /**
-     * Take all instructions (handles) from "start" to "end" and append them after the
-     * new location "target". Of course, "end" must be after "start" and target must
-     * not be located withing this range. If you want to move something to the start of
-     * the list use null as value for target.<br>
-     * Any instruction targeters pointing to handles within the block, keep their targets.
-     *
-     * @param start  of moved block
-     * @param end    of moved block
-     * @param target of moved block
-     */
-    public void move( InstructionHandle start, InstructionHandle end, InstructionHandle target ) {
-        // Step 1: Check constraints
-        if ((start == null) || (end == null)) {
-            throw new ClassGenException("Invalid null handle: From " + start + " to " + end);
-        }
-        if ((target == start) || (target == end)) {
-            throw new ClassGenException("Invalid range: From " + start + " to " + end
-                    + " contains target " + target);
-        }
-        for (InstructionHandle ih = start; ih != end.next; ih = ih.next) {
-            if (ih == null) {
-                throw new ClassGenException("Invalid range: From " + start + " to " + end);
-            } else if (ih == target) {
-                throw new ClassGenException("Invalid range: From " + start + " to " + end
-                        + " contains target " + target);
-            }
-        }
-        // Step 2: Temporarily remove the given instructions from the list
-        InstructionHandle prev = start.prev, next = end.next;
-        if (prev != null) {
-            prev.next = next;
-        } else {
-            this.start = next;
-        }
-        if (next != null) {
-            next.prev = prev;
-        } else {
-            this.end = prev;
-        }
-        start.prev = end.next = null;
-        // Step 3: append after target
-        if (target == null) { // append to start of list
-            if (this.start != null) {
-                this.start.prev = end;
-            }
-            end.next = this.start;
-            this.start = start;
-        } else {
-            next = target.next;
-            target.next = start;
-            start.prev = target;
-            end.next = next;
-            if (next != null) {
-                next.prev = end;
-            } else {
-                this.end = end;
-            }
-        }
-    }
-
-
-    /**
-     * Move a single instruction (handle) to a new location.
-     *
-     * @param ih     moved instruction
-     * @param target new location of moved instruction
-     */
-    public void move( InstructionHandle ih, InstructionHandle target ) {
-        move(ih, ih, target);
-    }
-
-
-    /**
-     * Remove from instruction `prev' to instruction `next' both contained
-     * in this list. Throws TargetLostException when one of the removed instruction handles
-     * is still being targeted.
-     *
-     * @param prev where to start deleting (predecessor, exclusive)
-     * @param next where to end deleting (successor, exclusive)
-     */
-    private void remove( InstructionHandle prev, InstructionHandle next )
-            throws TargetLostException {
-        InstructionHandle first, last; // First and last deleted instruction
-        if ((prev == null) && (next == null)) {
-            first = start;
-            last = end;
-            start = end = null;
-        } else {
-            if (prev == null) { // At start of list
-                first = start;
-                start = next;
-            } else {
-                first = prev.next;
-                prev.next = next;
-            }
-            if (next == null) { // At end of list
-                last = end;
-                end = prev;
-            } else {
-                last = next.prev;
-                next.prev = prev;
-            }
-        }
-        first.prev = null; // Completely separated from rest of list
-        last.next = null;
-        List target_vec = new ArrayList();
-        for (InstructionHandle ih = first; ih != null; ih = ih.next) {
-            ih.getInstruction().dispose(); // e.g. BranchInstructions release their targets
-        }
-        StringBuffer buf = new StringBuffer("{ ");
-        for (InstructionHandle ih = first; ih != null; ih = next) {
-            next = ih.next;
-            length--;
-            if (ih.hasTargeters()) { // Still got targeters?
-                target_vec.add(ih);
-                buf.append(ih.toString(true) + " ");
-                ih.next = ih.prev = null;
-            } else {
-                ih.dispose();
-            }
-        }
-        buf.append("}");
-        if (!target_vec.isEmpty()) {
-            InstructionHandle[] targeted = new InstructionHandle[target_vec.size()];
-            target_vec.toArray(targeted);
-            throw new TargetLostException(targeted, buf.toString());
-        }
-    }
-
-
-    /**
-     * Remove instruction from this list. The corresponding Instruction
-     * handles must not be reused!
-     *
-     * @param ih instruction (handle) to remove 
-     */
-    public void delete( InstructionHandle ih ) throws TargetLostException {
-        remove(ih.prev, ih.next);
-    }
-
-
-    /**
-     * Remove instruction from this list. The corresponding Instruction
-     * handles must not be reused!
-     *
-     * @param i instruction to remove
-     */
-    public void delete( Instruction i ) throws TargetLostException {
-        InstructionHandle ih;
-        if ((ih = findInstruction1(i)) == null) {
-            throw new ClassGenException("Instruction " + i + " is not contained in this list.");
-        }
-        delete(ih);
-    }
-
-
-    /**
-     * Remove instructions from instruction `from' to instruction `to' contained
-     * in this list. The user must ensure that `from' is an instruction before
-     * `to', or risk havoc. The corresponding Instruction handles must not be reused!
-     *
-     * @param from where to start deleting (inclusive)
-     * @param to   where to end deleting (inclusive)
-     */
-    public void delete( InstructionHandle from, InstructionHandle to ) throws TargetLostException {
-        remove(from.prev, to.next);
-    }
-
-
-    /**
-     * Remove instructions from instruction `from' to instruction `to' contained
-     * in this list. The user must ensure that `from' is an instruction before
-     * `to', or risk havoc. The corresponding Instruction handles must not be reused!
-     *
-     * @param from where to start deleting (inclusive)
-     * @param to   where to end deleting (inclusive)
-     */
-    public void delete( Instruction from, Instruction to ) throws TargetLostException {
-        InstructionHandle from_ih, to_ih;
-        if ((from_ih = findInstruction1(from)) == null) {
-            throw new ClassGenException("Instruction " + from + " is not contained in this list.");
-        }
-        if ((to_ih = findInstruction2(to)) == null) {
-            throw new ClassGenException("Instruction " + to + " is not contained in this list.");
-        }
-        delete(from_ih, to_ih);
-    }
+    
 
 
     /**
@@ -806,35 +260,6 @@ public class InstructionList implements Serializable {
     }
 
 
-    /**
-     * Search for given Instruction reference, start at end of list
-     *
-     * @param i instruction to search for
-     * @return instruction found on success, null otherwise
-     */
-    private InstructionHandle findInstruction2( Instruction i ) {
-        for (InstructionHandle ih = end; ih != null; ih = ih.prev) {
-            if (ih.instruction == i) {
-                return ih;
-            }
-        }
-        return null;
-    }
-
-
-    public boolean contains( InstructionHandle i ) {
-        if (i == null) {
-            return false;
-        }
-        for (InstructionHandle ih = start; ih != null; ih = ih.next) {
-            if (ih == i) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-
     public boolean contains( Instruction i ) {
         return findInstruction1(i) != null;
     }
@@ -933,45 +358,10 @@ public class InstructionList implements Serializable {
     }
 
 
-    /**
-     * When everything is finished, use this method to convert the instruction
-     * list into an array of bytes.
-     *
-     * @return the byte code ready to be dumped
-     */
-    public byte[] getByteCode() {
-        // Update position indices of instructions
-        setPositions();
-        ByteArrayOutputStream b = new ByteArrayOutputStream();
-        DataOutputStream out = new DataOutputStream(b);
-        try {
-            for (InstructionHandle ih = start; ih != null; ih = ih.next) {
-                Instruction i = ih.instruction;
-                i.dump(out); // Traverse list
-            }
-        } catch (IOException e) {
-            System.err.println(e);
-            return new byte[0];
-        }
-        return b.toByteArray();
-    }
+    
 
 
-    /**
-     * @return an array of instructions without target information for branch instructions.
-     */
-    public Instruction[] getInstructions() {
-        ByteSequence bytes = new ByteSequence(getByteCode());
-        List instructions = new ArrayList();
-        try {
-            while (bytes.available() > 0) {
-                instructions.add(Instruction.readInstruction(bytes));
-            }
-        } catch (IOException e) {
-            throw new ClassGenException(e.toString(), e);
-        }
-        return (Instruction[]) instructions.toArray(new Instruction[instructions.size()]);
-    }
+    
 
 
     public String toString() {
@@ -992,122 +382,19 @@ public class InstructionList implements Serializable {
     }
 
 
-    /**
-     * @return Enumeration that lists all instructions (handles)
-     */
-    public Iterator iterator() {
-        return new Iterator() {
+    
 
-            private InstructionHandle ih = start;
 
+    
 
-            public Object next() throws NoSuchElementException {
-            	if (ih == null)
-            		throw new NoSuchElementException();
-                InstructionHandle i = ih;
-                ih = ih.next;
-                return i;
-            }
-
-
-            public void remove() {
-                throw new UnsupportedOperationException();
-            }
-
-
-            public boolean hasNext() {
-                return ih != null;
-            }
-        };
-    }
-
-
-    /**
-     * @return array containing all instructions (handles)
-     */
-    public InstructionHandle[] getInstructionHandles() {
-        InstructionHandle[] ihs = new InstructionHandle[length];
-        InstructionHandle ih = start;
-        for (int i = 0; i < length; i++) {
-            ihs[i] = ih;
-            ih = ih.next;
-        }
-        return ihs;
-    }
 
-
-    /**
-     * Get positions (offsets) of all instructions in the list. This relies on that
-     * the list has been freshly created from an byte code array, or that setPositions()
-     * has been called. Otherwise this may be inaccurate.
-     *
-     * @return array containing all instruction's offset in byte code
-     */
-    public int[] getInstructionPositions() {
-        return byte_positions;
-    }
+    
 
 
-    /**
-     * @return complete, i.e., deep copy of this list
-     */
-    public InstructionList copy() {
-        Map map = new HashMap();
-        InstructionList il = new InstructionList();
-        /* Pass 1: Make copies of all instructions, append them to the new list
-         * and associate old instruction references with the new ones, i.e.,
-         * a 1:1 mapping.
-         */
-        for (InstructionHandle ih = start; ih != null; ih = ih.next) {
-            Instruction i = ih.instruction;
-            Instruction c = i.copy(); // Use clone for shallow copy
-            if (c instanceof BranchInstruction) {
-                map.put(ih, il.append((BranchInstruction) c));
-            } else {
-                map.put(ih, il.append(c));
-            }
-        }
-        /* Pass 2: Update branch targets.
-         */
-        InstructionHandle ih = start;
-        InstructionHandle ch = il.start;
-        while (ih != null) {
-            Instruction i = ih.instruction;
-            Instruction c = ch.instruction;
-            if (i instanceof BranchInstruction) {
-                BranchInstruction bi = (BranchInstruction) i;
-                BranchInstruction bc = (BranchInstruction) c;
-                InstructionHandle itarget = bi.getTarget(); // old target
-                // New target is in hash map
-                bc.setTarget((InstructionHandle) map.get(itarget));
-                if (bi instanceof Select) { // Either LOOKUPSWITCH or TABLESWITCH
-                    InstructionHandle[] itargets = ((Select) bi).getTargets();
-                    InstructionHandle[] ctargets = ((Select) bc).getTargets();
-                    for (int j = 0; j < itargets.length; j++) { // Update all targets
-                        ctargets[j] = (InstructionHandle) map.get(itargets[j]);
-                    }
-                }
-            }
-            ih = ih.next;
-            ch = ch.next;
-        }
-        return il;
-    }
+    
 
 
-    /** Replace all references to the old constant pool with references to the new
-     *  constant pool
-     */
-    public void replaceConstantPool( ConstantPoolGen old_cp, ConstantPoolGen new_cp ) {
-        for (InstructionHandle ih = start; ih != null; ih = ih.next) {
-            Instruction i = ih.instruction;
-            if (i instanceof CPInstruction) {
-                CPInstruction ci = (CPInstruction) i;
-                Constant c = old_cp.getConstant(ci.getIndex());
-                ci.setIndex(new_cp.addConstant(c, old_cp));
-            }
-        }
-    }
+    
 
 
     private void clear() {
@@ -1116,22 +403,7 @@ public class InstructionList implements Serializable {
     }
 
 
-    /**
-     * Delete contents of list. Provides besser memory utilization,
-     * because the system then may reuse the instruction handles. This
-     * method is typically called right after
-     * <href="MethodGen.html#getMethod()">MethodGen.getMethod()</a>.
-     */
-    public void dispose() {
-        // Traverse in reverse order, because ih.next is overwritten
-        for (InstructionHandle ih = end; ih != null; ih = ih.prev) {
-            /* Causes BranchInstructions to release target and targeters, because it
-             * calls dispose() on the contained instruction.
-             */
-            ih.dispose();
-        }
-        clear();
-    }
+    
 
 
     /**
@@ -1150,128 +422,28 @@ public class InstructionList implements Serializable {
     }
 
 
-    /**
-     * @return length of list (Number of instructions, not bytes)
-     */
-    public int getLength() {
-        return length;
-    }
+    
 
 
-    /**
-     * @return length of list (Number of instructions, not bytes)
-     */
-    public int size() {
-        return length;
-    }
+    
 
 
-    /**
-     * Redirect all references from old_target to new_target, i.e., update targets 
-     * of branch instructions.
-     *
-     * @param old_target the old target instruction handle
-     * @param new_target the new target instruction handle
-     */
-    public void redirectBranches( InstructionHandle old_target, InstructionHandle new_target ) {
-        for (InstructionHandle ih = start; ih != null; ih = ih.next) {
-            Instruction i = ih.getInstruction();
-            if (i instanceof BranchInstruction) {
-                BranchInstruction b = (BranchInstruction) i;
-                InstructionHandle target = b.getTarget();
-                if (target == old_target) {
-                    b.setTarget(new_target);
-                }
-                if (b instanceof Select) { // Either LOOKUPSWITCH or TABLESWITCH
-                    InstructionHandle[] targets = ((Select) b).getTargets();
-                    for (int j = 0; j < targets.length; j++) {
-                        if (targets[j] == old_target) {
-                            ((Select) b).setTarget(j, new_target);
-                        }
-                    }
-                }
-            }
-        }
-    }
+    
 
 
-    /**
-     * Redirect all references of local variables from old_target to new_target.
-     *
-     * @param lg array of local variables
-     * @param old_target the old target instruction handle
-     * @param new_target the new target instruction handle
-     * @see MethodGen
-     */
-    public void redirectLocalVariables( LocalVariableGen[] lg, InstructionHandle old_target,
-            InstructionHandle new_target ) {
-        for (int i = 0; i < lg.length; i++) {
-            InstructionHandle start = lg[i].getStart();
-            InstructionHandle end = lg[i].getEnd();
-            if (start == old_target) {
-                lg[i].setStart(new_target);
-            }
-            if (end == old_target) {
-                lg[i].setEnd(new_target);
-            }
-        }
-    }
+    
 
 
-    /**
-     * Redirect all references of exception handlers from old_target to new_target.
-     *
-     * @param exceptions array of exception handlers
-     * @param old_target the old target instruction handle
-     * @param new_target the new target instruction handle
-     * @see MethodGen
-     */
-    public void redirectExceptionHandlers( CodeExceptionGen[] exceptions,
-            InstructionHandle old_target, InstructionHandle new_target ) {
-        for (int i = 0; i < exceptions.length; i++) {
-            if (exceptions[i].getStartPC() == old_target) {
-                exceptions[i].setStartPC(new_target);
-            }
-            if (exceptions[i].getEndPC() == old_target) {
-                exceptions[i].setEndPC(new_target);
-            }
-            if (exceptions[i].getHandlerPC() == old_target) {
-                exceptions[i].setHandlerPC(new_target);
-            }
-        }
-    }
+    
 
     private List observers;
 
 
-    /** Add observer for this object.
-     */
-    public void addObserver( InstructionListObserver o ) {
-        if (observers == null) {
-            observers = new ArrayList();
-        }
-        observers.add(o);
-    }
+    
 
 
-    /** Remove observer for this object.
-     */
-    public void removeObserver( InstructionListObserver o ) {
-        if (observers != null) {
-            observers.remove(o);
-        }
-    }
+    
 
 
-    /** Call notify() method on all observers. This method is not called
-     * automatically whenever the state has changed, but has to be
-     * called by the user after he has finished editing the object.
-     */
-    public void update() {
-        if (observers != null) {
-            for (Iterator e = observers.iterator(); e.hasNext();) {
-                ((InstructionListObserver) e.next()).notify(this);
-            }
-        }
-    }
+    
 }

==================================================
InstructionTargeter.java
deleted file mode 100644
index a2b1b94b58..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/InstructionListObserver.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * Implement this interface if you're interested in changes to an InstructionList object
- * and register yourself with addObserver().
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public interface InstructionListObserver {
-
-    public void notify( InstructionList list );
-}

==================================================
InvokeInstruction.java
index bb29cd124e..94bef35081 100644
--- a/java/org/apache/tomcat/util/bcel/generic/InstructionTargeter.java
+++ b/java/org/apache/tomcat/util/bcel/generic/InstructionTargeter.java
@@ -28,8 +28,8 @@ package org.apache.tomcat.util.bcel.generic;
  */
 public interface InstructionTargeter {
 
-    public boolean containsTarget( InstructionHandle ih );
+    
 
 
-    public void updateTarget( InstructionHandle old_ih, InstructionHandle new_ih );
+    
 }

==================================================
JSR.java
index 6e48c8f637..b4f3863ad1 100644
--- a/java/org/apache/tomcat/util/bcel/generic/InvokeInstruction.java
+++ b/java/org/apache/tomcat/util/bcel/generic/InvokeInstruction.java
@@ -38,12 +38,7 @@ public abstract class InvokeInstruction extends FieldOrMethod implements Excepti
     }
 
 
-    /**
-     * @param index to constant pool
-     */
-    protected InvokeInstruction(short opcode, int index) {
-        super(opcode, index);
-    }
+    
 
 
     /**
@@ -94,11 +89,7 @@ public abstract class InvokeInstruction extends FieldOrMethod implements Excepti
     }
 
 
-    /** @return name of referenced method.
-     */
-    public String getMethodName( ConstantPoolGen cpg ) {
-        return getName(cpg);
-    }
+    
 
 
     /** @return return type of referenced method.
@@ -108,9 +99,5 @@ public abstract class InvokeInstruction extends FieldOrMethod implements Excepti
     }
 
 
-    /** @return argument types of referenced method.
-     */
-    public Type[] getArgumentTypes( ConstantPoolGen cpg ) {
-        return Type.getArgumentTypes(getSignature(cpg));
-    }
+    
 }

==================================================
JSR_W.java
index 7f5e2a6583..cb84ee6907 100644
--- a/java/org/apache/tomcat/util/bcel/generic/JSR.java
+++ b/java/org/apache/tomcat/util/bcel/generic/JSR.java
@@ -35,9 +35,7 @@ public class JSR extends JsrInstruction implements VariableLengthInstruction {
     }
 
 
-    public JSR(InstructionHandle target) {
-        super(org.apache.tomcat.util.bcel.Constants.JSR, target);
-    }
+    
 
 
     /**

==================================================
JsrInstruction.java
index e5870bd5ab..b5faadd757 100644
--- a/java/org/apache/tomcat/util/bcel/generic/JSR_W.java
+++ b/java/org/apache/tomcat/util/bcel/generic/JSR_W.java
@@ -36,10 +36,7 @@ public class JSR_W extends JsrInstruction {
     }
 
 
-    public JSR_W(InstructionHandle target) {
-        super(org.apache.tomcat.util.bcel.Constants.JSR_W, target);
-        length = 5;
-    }
+    
 
 
     /**

==================================================
L2D.java
index b0ebb6b47f..241cf2a64f 100644
--- a/java/org/apache/tomcat/util/bcel/generic/JsrInstruction.java
+++ b/java/org/apache/tomcat/util/bcel/generic/JsrInstruction.java
@@ -25,9 +25,7 @@ package org.apache.tomcat.util.bcel.generic;
 public abstract class JsrInstruction extends BranchInstruction implements UnconditionalBranch,
         TypedInstruction, StackProducer {
 
-    JsrInstruction(short opcode, InstructionHandle target) {
-        super(opcode, target);
-    }
+    
 
 
     /**

==================================================
L2F.java
deleted file mode 100644
index da1a3a527e..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/L2D.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * L2D - Convert long to double
- * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result.word1, result.word2</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class L2D extends ConversionInstruction {
-
-    public L2D() {
-        super(org.apache.tomcat.util.bcel.Constants.L2D);
-    }
-}

==================================================
L2I.java
deleted file mode 100644
index 7952d6b525..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/L2F.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * L2F - Convert long to float
- * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class L2F extends ConversionInstruction {
-
-    public L2F() {
-        super(org.apache.tomcat.util.bcel.Constants.L2F);
-    }
-}

==================================================
LADD.java
deleted file mode 100644
index 9d5e2c1642..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/L2I.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * L2I - Convert long to int
- * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class L2I extends ConversionInstruction {
-
-    public L2I() {
-        super(org.apache.tomcat.util.bcel.Constants.L2I);
-    }
-}

==================================================
LALOAD.java
deleted file mode 100644
index c1650b4cd5..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/LADD.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * LADD - Add longs
- * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;</PRE>
- *        ..., result.word1, result.word2
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class LADD extends ArithmeticInstruction {
-
-    public LADD() {
-        super(org.apache.tomcat.util.bcel.Constants.LADD);
-    }
-}

==================================================
LAND.java
deleted file mode 100644
index 587a58f34e..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/LALOAD.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * LALOAD - Load long from array
- * <PRE>Stack: ..., arrayref, index -&gt; ..., value1, value2</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class LALOAD extends ArrayInstruction implements StackProducer {
-
-    /** Load long from array
-     */
-    public LALOAD() {
-        super(org.apache.tomcat.util.bcel.Constants.LALOAD);
-    }
-}

==================================================
LASTORE.java
deleted file mode 100644
index 4ca39322f4..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/LAND.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * LAND - Bitwise AND longs
- * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;</PRE>
- *        ..., result.word1, result.word2
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class LAND extends ArithmeticInstruction {
-
-    public LAND() {
-        super(org.apache.tomcat.util.bcel.Constants.LAND);
-    }
-}

==================================================
LCMP.java
deleted file mode 100644
index f7f9f20788..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/LASTORE.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * LASTORE -  Store into long array
- * <PRE>Stack: ..., arrayref, index, value.word1, value.word2 -&gt; ...</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class LASTORE extends ArrayInstruction implements StackConsumer {
-
-    /** Store long into array
-     */
-    public LASTORE() {
-        super(org.apache.tomcat.util.bcel.Constants.LASTORE);
-    }
-}

==================================================
LCONST.java
deleted file mode 100644
index 50947ea353..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/LCMP.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * LCMP - Compare longs:
- * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;</PRE>
- *        ..., result <= -1, 0, 1>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class LCMP extends Instruction implements TypedInstruction, StackProducer, StackConsumer {
-
-    public LCMP() {
-        super(org.apache.tomcat.util.bcel.Constants.LCMP, (short) 1);
-    }
-
-
-    /** @return Type.LONG
-     */
-    public Type getType( ConstantPoolGen cp ) {
-        return Type.LONG;
-    }
-}

==================================================
LDC.java
deleted file mode 100644
index 407da10b8e..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/LCONST.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * LCONST - Push 0 or 1, other values cause an exception
- *
- * <PRE>Stack: ... -&gt; ..., </PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class LCONST extends Instruction implements ConstantPushInstruction, TypedInstruction {
-
-    private long value;
-
-
-    /**
-     * Empty constructor needed for the Class.newInstance() statement in
-     * Instruction.readInstruction(). Not to be used otherwise.
-     */
-    LCONST() {
-    }
-
-
-    public LCONST(long l) {
-        super(org.apache.tomcat.util.bcel.Constants.LCONST_0, (short) 1);
-        if (l == 0) {
-            opcode = org.apache.tomcat.util.bcel.Constants.LCONST_0;
-        } else if (l == 1) {
-            opcode = org.apache.tomcat.util.bcel.Constants.LCONST_1;
-        } else {
-            throw new ClassGenException("LCONST can be used only for 0 and 1: " + l);
-        }
-        value = l;
-    }
-
-
-    public Number getValue() {
-        return new Long(value);
-    }
-
-
-    /** @return Type.LONG
-     */
-    public Type getType( ConstantPoolGen cp ) {
-        return Type.LONG;
-    }
-}

==================================================
LDC2_W.java
index 74c61cf6a1..c50c911188 100644
--- a/java/org/apache/tomcat/util/bcel/generic/LDC.java
+++ b/java/org/apache/tomcat/util/bcel/generic/LDC.java
@@ -39,10 +39,7 @@ public class LDC extends CPInstruction implements PushInstruction, ExceptionThro
     }
 
 
-    public LDC(int index) {
-        super(org.apache.tomcat.util.bcel.Constants.LDC_W, index);
-        setSize();
-    }
+    
 
 
     // Adjust to proper size
@@ -89,23 +86,7 @@ public class LDC extends CPInstruction implements PushInstruction, ExceptionThro
     }
 
 
-    public Object getValue( ConstantPoolGen cpg ) {
-        org.apache.tomcat.util.bcel.classfile.Constant c = cpg.getConstantPool().getConstant(index);
-        switch (c.getTag()) {
-            case org.apache.tomcat.util.bcel.Constants.CONSTANT_String:
-                int i = ((org.apache.tomcat.util.bcel.classfile.ConstantString) c).getStringIndex();
-                c = cpg.getConstantPool().getConstant(i);
-                return ((org.apache.tomcat.util.bcel.classfile.ConstantUtf8) c).getBytes();
-            case org.apache.tomcat.util.bcel.Constants.CONSTANT_Float:
-                return new Float(((org.apache.tomcat.util.bcel.classfile.ConstantFloat) c).getBytes());
-            case org.apache.tomcat.util.bcel.Constants.CONSTANT_Integer:
-                return new Integer(((org.apache.tomcat.util.bcel.classfile.ConstantInteger) c).getBytes());
-            case org.apache.tomcat.util.bcel.Constants.CONSTANT_Class:
-                return c;
-            default: // Never reached
-                throw new RuntimeException("Unknown or invalid constant type at " + index);
-        }
-    }
+    
 
 
     public Type getType( ConstantPoolGen cpg ) {
@@ -124,7 +105,5 @@ public class LDC extends CPInstruction implements PushInstruction, ExceptionThro
     }
 
 
-    public Class[] getExceptions() {
-        return org.apache.tomcat.util.bcel.ExceptionConstants.EXCS_STRING_RESOLUTION;
-    }
+    
 }

==================================================
LDC_W.java
index b55b02ff1b..3872cd34ce 100644
--- a/java/org/apache/tomcat/util/bcel/generic/LDC2_W.java
+++ b/java/org/apache/tomcat/util/bcel/generic/LDC2_W.java
@@ -34,9 +34,7 @@ public class LDC2_W extends CPInstruction implements PushInstruction, TypedInstr
     }
 
 
-    public LDC2_W(int index) {
-        super(org.apache.tomcat.util.bcel.Constants.LDC2_W, index);
-    }
+    
 
 
     public Type getType( ConstantPoolGen cpg ) {
@@ -51,15 +49,5 @@ public class LDC2_W extends CPInstruction implements PushInstruction, TypedInstr
     }
 
 
-    public Number getValue( ConstantPoolGen cpg ) {
-        org.apache.tomcat.util.bcel.classfile.Constant c = cpg.getConstantPool().getConstant(index);
-        switch (c.getTag()) {
-            case org.apache.tomcat.util.bcel.Constants.CONSTANT_Long:
-                return new Long(((org.apache.tomcat.util.bcel.classfile.ConstantLong) c).getBytes());
-            case org.apache.tomcat.util.bcel.Constants.CONSTANT_Double:
-                return new Double(((org.apache.tomcat.util.bcel.classfile.ConstantDouble) c).getBytes());
-            default: // Never reached
-                throw new RuntimeException("Unknown or invalid constant type at " + index);
-        }
-    }
+    
 }

==================================================
LDIV.java
index 6defb6347d..e48a2dbdad 100644
--- a/java/org/apache/tomcat/util/bcel/generic/LDC_W.java
+++ b/java/org/apache/tomcat/util/bcel/generic/LDC_W.java
@@ -37,9 +37,7 @@ public class LDC_W extends LDC {
     }
 
 
-    public LDC_W(int index) {
-        super(index);
-    }
+    
 
 
     /**

==================================================
LMUL.java
deleted file mode 100644
index da05f89805..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/LDIV.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * LDIV - Divide longs
- * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;</PRE>
- *        ..., result.word1, result.word2
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class LDIV extends ArithmeticInstruction implements ExceptionThrower {
-
-    public LDIV() {
-        super(org.apache.tomcat.util.bcel.Constants.LDIV);
-    }
-
-
-    public Class[] getExceptions() {
-        return new Class[] {
-            org.apache.tomcat.util.bcel.ExceptionConstants.ARITHMETIC_EXCEPTION
-        };
-    }
-}

==================================================
LNEG.java
deleted file mode 100644
index f4e48a0442..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/LMUL.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * LMUL - Multiply longs
- * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;</PRE>
- *        ..., result.word1, result.word2
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class LMUL extends ArithmeticInstruction {
-
-    public LMUL() {
-        super(org.apache.tomcat.util.bcel.Constants.LMUL);
-    }
-}

==================================================
LOOKUPSWITCH.java
deleted file mode 100644
index 29ddd5d299..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/LNEG.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * LNEG - Negate long
- * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result.word1, result.word2</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class LNEG extends ArithmeticInstruction {
-
-    public LNEG() {
-        super(org.apache.tomcat.util.bcel.Constants.LNEG);
-    }
-}

==================================================
LOR.java
index 673904a541..08ca015c6a 100644
--- a/java/org/apache/tomcat/util/bcel/generic/LOOKUPSWITCH.java
+++ b/java/org/apache/tomcat/util/bcel/generic/LOOKUPSWITCH.java
@@ -37,12 +37,7 @@ public class LOOKUPSWITCH extends Select {
     }
 
 
-    public LOOKUPSWITCH(int[] match, InstructionHandle[] targets, InstructionHandle defaultTarget) {
-        super(org.apache.tomcat.util.bcel.Constants.LOOKUPSWITCH, match, targets, defaultTarget);
-        length = (short) (9 + match_length * 8); /* alignment remainder assumed
-         * 0 here, until dump time. */
-        fixed_length = length;
-    }
+    
 
 
     /**

==================================================
LREM.java
deleted file mode 100644
index c57d11c606..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/LOR.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * LOR - Bitwise OR long
- * <PRE>Stack: ..., value1, value2 -&gt; ..., result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class LOR extends ArithmeticInstruction {
-
-    public LOR() {
-        super(org.apache.tomcat.util.bcel.Constants.LOR);
-    }
-}

==================================================
LRETURN.java
deleted file mode 100644
index 845a225dbb..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/LREM.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * LREM - Remainder of long
- * <PRE>Stack: ..., value1, value2 -&gt; result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class LREM extends ArithmeticInstruction implements ExceptionThrower {
-
-    public LREM() {
-        super(org.apache.tomcat.util.bcel.Constants.LREM);
-    }
-
-
-    public Class[] getExceptions() {
-        return new Class[] {
-            org.apache.tomcat.util.bcel.ExceptionConstants.ARITHMETIC_EXCEPTION
-        };
-    }
-}

==================================================
LSHL.java
deleted file mode 100644
index e63732245b..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/LRETURN.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * LRETURN -  Return long from method
- * <PRE>Stack: ..., value.word1, value.word2 -&gt; &lt;empty&gt;</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class LRETURN extends ReturnInstruction {
-
-    public LRETURN() {
-        super(org.apache.tomcat.util.bcel.Constants.LRETURN);
-    }
-}

==================================================
LSHR.java
deleted file mode 100644
index 21794d78b1..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/LSHL.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * LSHL - Arithmetic shift left long
- * <PRE>Stack: ..., value1.word1, value1.word2, value2 -&gt; ..., result.word1, result.word2</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class LSHL extends ArithmeticInstruction {
-
-    public LSHL() {
-        super(org.apache.tomcat.util.bcel.Constants.LSHL);
-    }
-}

==================================================
LSUB.java
deleted file mode 100644
index 8f7d62b68d..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/LSHR.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * LSHR - Arithmetic shift right long
- * <PRE>Stack: ..., value1.word1, value1.word2, value2 -&gt; ..., result.word1, result.word2</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class LSHR extends ArithmeticInstruction {
-
-    public LSHR() {
-        super(org.apache.tomcat.util.bcel.Constants.LSHR);
-    }
-}

==================================================
LUSHR.java
deleted file mode 100644
index d6c3d82eda..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/LSUB.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * LSUB - Substract longs
- * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;</PRE>
- *        ..., result.word1, result.word2
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class LSUB extends ArithmeticInstruction {
-
-    public LSUB() {
-        super(org.apache.tomcat.util.bcel.Constants.LSUB);
-    }
-}

==================================================
LXOR.java
deleted file mode 100644
index 1dd9a03699..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/LUSHR.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * LUSHR - Logical shift right long
- * <PRE>Stack: ..., value1, value2 -&gt; ..., result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class LUSHR extends ArithmeticInstruction {
-
-    public LUSHR() {
-        super(org.apache.tomcat.util.bcel.Constants.LUSHR);
-    }
-}

==================================================
LineNumberGen.java
deleted file mode 100644
index 30e72fc63e..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/LXOR.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * LXOR - Bitwise XOR long
- * <PRE>Stack: ..., value1, value2 -&gt; ..., result</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class LXOR extends ArithmeticInstruction {
-
-    public LXOR() {
-        super(org.apache.tomcat.util.bcel.Constants.LXOR);
-    }
-}

==================================================
LoadClass.java
index da624e5186..eafb2921a6 100644
--- a/java/org/apache/tomcat/util/bcel/generic/LineNumberGen.java
+++ b/java/org/apache/tomcat/util/bcel/generic/LineNumberGen.java
@@ -44,25 +44,10 @@ public class LineNumberGen implements InstructionTargeter, Cloneable, java.io.Se
     }
 
 
-    /**
-     * @return true, if ih is target of this line number
-     */
-    public boolean containsTarget( InstructionHandle ih ) {
-        return this.ih == ih;
-    }
+    
 
 
-    /**
-     * @param old_ih old target
-     * @param new_ih new target
-     */
-    public void updateTarget( InstructionHandle old_ih, InstructionHandle new_ih ) {
-        if (old_ih != ih) {
-            throw new ClassGenException("Not targeting " + old_ih + ", but " + ih + "}");
-        } else {
-            setInstruction(new_ih);
-        }
-    }
+    
 
 
     /**
@@ -92,9 +77,7 @@ public class LineNumberGen implements InstructionTargeter, Cloneable, java.io.Se
     }
 
 
-    public InstructionHandle getInstruction() {
-        return ih;
-    }
+    
 
 
     public void setSourceLine( int src_line ) {
@@ -102,7 +85,5 @@ public class LineNumberGen implements InstructionTargeter, Cloneable, java.io.Se
     }
 
 
-    public int getSourceLine() {
-        return src_line;
-    }
+    
 }

==================================================
LocalVariableGen.java
index ffbbfe74b2..f40ba91437 100644
--- a/java/org/apache/tomcat/util/bcel/generic/LoadClass.java
+++ b/java/org/apache/tomcat/util/bcel/generic/LoadClass.java
@@ -25,26 +25,8 @@ package org.apache.tomcat.util.bcel.generic;
  */
 public interface LoadClass {
 
-    /**
-     * Returns the ObjectType of the referenced class or interface
-     * that may be loaded and resolved.
-     * @return object type that may be loaded or null if a primitive is
-     * referenced
-     */
-    public ObjectType getLoadClassType( ConstantPoolGen cpg );
+    
 
 
-    /**
-     * Returns the type associated with this instruction.
-     * LoadClass instances are always typed, but this type
-     * does not always refer to the type of the class or interface
-     * that it possibly forces to load. For example, GETFIELD would
-     * return the type of the field and not the type of the class
-     * where the field is defined.
-     * If no class is forced to be loaded, <B>null</B> is returned.
-     * An example for this is an ANEWARRAY instruction that creates
-     * an int[][].
-     * @see #getLoadClassType(ConstantPoolGen)
-     */
-    public Type getType( ConstantPoolGen cpg );
+    
 }

==================================================
LocalVariableInstruction.java
index 1d7b83167a..1f478f7422 100644
--- a/java/org/apache/tomcat/util/bcel/generic/LocalVariableGen.java
+++ b/java/org/apache/tomcat/util/bcel/generic/LocalVariableGen.java
@@ -16,7 +16,6 @@
  */
 package org.apache.tomcat.util.bcel.generic;
 
-import org.apache.tomcat.util.bcel.Constants;
 import org.apache.tomcat.util.bcel.classfile.LocalVariable;
 
 /** 
@@ -39,27 +38,7 @@ public class LocalVariableGen implements InstructionTargeter, NamedAndTyped, Clo
     private InstructionHandle start, end;
 
 
-    /**
-     * Generate a local variable that with index `index'. Note that double and long
-     * variables need two indexs. Index indices have to be provided by the user.
-     *
-     * @param index index of local variable
-     * @param name its name
-     * @param type its type
-     * @param start from where the instruction is valid (null means from the start)
-     * @param end until where the instruction is valid (null means to the end)
-     */
-    public LocalVariableGen(int index, String name, Type type, InstructionHandle start,
-            InstructionHandle end) {
-        if ((index < 0) || (index > Constants.MAX_SHORT)) {
-            throw new ClassGenException("Invalid index index: " + index);
-        }
-        this.name = name;
-        this.type = type;
-        this.index = index;
-        setStart(start);
-        setEnd(end);
-    }
+    
 
 
     /**
@@ -89,9 +68,7 @@ public class LocalVariableGen implements InstructionTargeter, NamedAndTyped, Clo
     }
 
 
-    public void setIndex( int index ) {
-        this.index = index;
-    }
+    
 
 
     public int getIndex() {
@@ -114,9 +91,7 @@ public class LocalVariableGen implements InstructionTargeter, NamedAndTyped, Clo
     }
 
 
-    public Type getType() {
-        return type;
-    }
+    
 
 
     public InstructionHandle getStart() {
@@ -141,33 +116,10 @@ public class LocalVariableGen implements InstructionTargeter, NamedAndTyped, Clo
     }
 
 
-    /**
-     * @param old_ih old target, either start or end
-     * @param new_ih new target
-     */
-    public void updateTarget( InstructionHandle old_ih, InstructionHandle new_ih ) {
-        boolean targeted = false;
-        if (start == old_ih) {
-            targeted = true;
-            setStart(new_ih);
-        }
-        if (end == old_ih) {
-            targeted = true;
-            setEnd(new_ih);
-        }
-        if (!targeted) {
-            throw new ClassGenException("Not targeting " + old_ih + ", but {" + start + ", " + end
-                    + "}");
-        }
-    }
+    
 
 
-    /**
-     * @return true, if ih is target of this variable
-     */
-    public boolean containsTarget( InstructionHandle ih ) {
-        return (start == ih) || (end == ih);
-    }
+    
 
 
     /** @return a hash code value for the object.

==================================================
MONITORENTER.java
index c937337123..0f14ec653b 100644
--- a/java/org/apache/tomcat/util/bcel/generic/LocalVariableInstruction.java
+++ b/java/org/apache/tomcat/util/bcel/generic/LocalVariableInstruction.java
@@ -163,11 +163,7 @@ public abstract class LocalVariableInstruction extends Instruction implements Ty
     }
 
 
-    /** @return canonical tag for instruction, e.g., ALOAD for ALOAD_0
-     */
-    public short getCanonicalTag() {
-        return canon_tag;
-    }
+    
 
 
     /**

==================================================
MONITOREXIT.java
deleted file mode 100644
index 1f98a60581..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/MONITORENTER.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * MONITORENTER - Enter monitor for object
- * <PRE>Stack: ..., objectref -&gt; ...</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class MONITORENTER extends Instruction implements ExceptionThrower, StackConsumer {
-
-    public MONITORENTER() {
-        super(org.apache.tomcat.util.bcel.Constants.MONITORENTER, (short) 1);
-    }
-
-
-    public Class[] getExceptions() {
-        return new Class[] {
-            org.apache.tomcat.util.bcel.ExceptionConstants.NULL_POINTER_EXCEPTION
-        };
-    }
-}

==================================================
MULTIANEWARRAY.java
deleted file mode 100644
index 5560a5cc3a..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/MONITOREXIT.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * MONITOREXIT - Exit monitor for object
- * <PRE>Stack: ..., objectref -&gt; ...</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class MONITOREXIT extends Instruction implements ExceptionThrower, StackConsumer {
-
-    public MONITOREXIT() {
-        super(org.apache.tomcat.util.bcel.Constants.MONITOREXIT, (short) 1);
-    }
-
-
-    public Class[] getExceptions() {
-        return new Class[] {
-            org.apache.tomcat.util.bcel.ExceptionConstants.NULL_POINTER_EXCEPTION
-        };
-    }
-}

==================================================
MethodGen.java
index 6e68cba1ee..64ba8a611d 100644
--- a/java/org/apache/tomcat/util/bcel/generic/MULTIANEWARRAY.java
+++ b/java/org/apache/tomcat/util/bcel/generic/MULTIANEWARRAY.java
@@ -18,7 +18,6 @@ package org.apache.tomcat.util.bcel.generic;
 
 import java.io.DataOutputStream;
 import java.io.IOException;
-import org.apache.tomcat.util.bcel.ExceptionConstants;
 import org.apache.tomcat.util.bcel.classfile.ConstantPool;
 import org.apache.tomcat.util.bcel.util.ByteSequence;
 
@@ -43,14 +42,7 @@ public class MULTIANEWARRAY extends CPInstruction implements LoadClass, Allocati
     }
 
 
-    public MULTIANEWARRAY(int index, short dimensions) {
-        super(org.apache.tomcat.util.bcel.Constants.MULTIANEWARRAY, index);
-        if (dimensions < 1) {
-            throw new ClassGenException("Invalid dimensions value: " + dimensions);
-        }
-        this.dimensions = dimensions;
-        length = 4;
-    }
+    
 
 
     /**
@@ -74,12 +66,7 @@ public class MULTIANEWARRAY extends CPInstruction implements LoadClass, Allocati
     }
 
 
-    /**
-     * @return number of dimensions to be created
-     */
-    public final short getDimensions() {
-        return dimensions;
-    }
+    
 
 
     /**
@@ -108,21 +95,8 @@ public class MULTIANEWARRAY extends CPInstruction implements LoadClass, Allocati
     }
 
 
-    public Class[] getExceptions() {
-        Class[] cs = new Class[2 + ExceptionConstants.EXCS_CLASS_AND_INTERFACE_RESOLUTION.length];
-        System.arraycopy(ExceptionConstants.EXCS_CLASS_AND_INTERFACE_RESOLUTION, 0, cs, 0,
-                ExceptionConstants.EXCS_CLASS_AND_INTERFACE_RESOLUTION.length);
-        cs[ExceptionConstants.EXCS_CLASS_AND_INTERFACE_RESOLUTION.length + 1] = ExceptionConstants.NEGATIVE_ARRAY_SIZE_EXCEPTION;
-        cs[ExceptionConstants.EXCS_CLASS_AND_INTERFACE_RESOLUTION.length] = ExceptionConstants.ILLEGAL_ACCESS_ERROR;
-        return cs;
-    }
+    
 
 
-    public ObjectType getLoadClassType( ConstantPoolGen cpg ) {
-        Type t = getType(cpg);
-        if (t instanceof ArrayType) {
-            t = ((ArrayType) t).getBasicType();
-        }
-        return (t instanceof ObjectType) ? (ObjectType) t : null;
-    }
+    
 }

==================================================
MethodObserver.java
index 17846d984d..1cd16d0954 100644
--- a/java/org/apache/tomcat/util/bcel/generic/MethodGen.java
+++ b/java/org/apache/tomcat/util/bcel/generic/MethodGen.java
@@ -17,26 +17,14 @@
 package org.apache.tomcat.util.bcel.generic;
 
 import java.util.ArrayList;
-import java.util.Hashtable;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Stack;
-import org.apache.tomcat.util.bcel.Constants;
-import org.apache.tomcat.util.bcel.classfile.AnnotationEntry;
-import org.apache.tomcat.util.bcel.classfile.Annotations;
 import org.apache.tomcat.util.bcel.classfile.Attribute;
 import org.apache.tomcat.util.bcel.classfile.Code;
-import org.apache.tomcat.util.bcel.classfile.CodeException;
 import org.apache.tomcat.util.bcel.classfile.ExceptionTable;
-import org.apache.tomcat.util.bcel.classfile.LineNumber;
-import org.apache.tomcat.util.bcel.classfile.LineNumberTable;
 import org.apache.tomcat.util.bcel.classfile.LocalVariable;
 import org.apache.tomcat.util.bcel.classfile.LocalVariableTable;
-import org.apache.tomcat.util.bcel.classfile.LocalVariableTypeTable;
 import org.apache.tomcat.util.bcel.classfile.Method;
-import org.apache.tomcat.util.bcel.classfile.ParameterAnnotationEntry;
-import org.apache.tomcat.util.bcel.classfile.ParameterAnnotations;
-import org.apache.tomcat.util.bcel.classfile.RuntimeVisibleParameterAnnotations;
 import org.apache.tomcat.util.bcel.classfile.Utility;
 import org.apache.tomcat.util.bcel.util.BCELComparator;
 
@@ -92,260 +80,22 @@ public class MethodGen extends FieldGenOrMethodGen {
     };
 
 
-    /**
-     * Declare method. If the method is non-static the constructor
-     * automatically declares a local variable `$this' in slot 0. The
-     * actual code is contained in the `il' parameter, which may further
-     * manipulated by the user. But he must take care not to remove any
-     * instruction (handles) that are still referenced from this object.
-     *
-     * For example one may not add a local variable and later remove the
-     * instructions it refers to without causing havoc. It is safe
-     * however if you remove that local variable, too.
-     *
-     * @param access_flags access qualifiers
-     * @param return_type  method type
-     * @param arg_types argument types
-     * @param arg_names argument names (if this is null, default names will be provided
-     * for them)
-     * @param method_name name of method
-     * @param class_name class name containing this method (may be null, if you don't care)
-     * @param il instruction list associated with this method, may be null only for
-     * abstract or native methods
-     * @param cp constant pool
-     */
-    public MethodGen(int access_flags, Type return_type, Type[] arg_types, String[] arg_names,
-            String method_name, String class_name, InstructionList il, ConstantPoolGen cp) {
-        setAccessFlags(access_flags);
-        setType(return_type);
-        setArgumentTypes(arg_types);
-        setArgumentNames(arg_names);
-        setName(method_name);
-        setClassName(class_name);
-        setInstructionList(il);
-        setConstantPool(cp);
-        boolean abstract_ = isAbstract() || isNative();
-        InstructionHandle start = null;
-        InstructionHandle end = null;
-        if (!abstract_) {
-            start = il.getStart();
-            end = il.getEnd();
-            /* Add local variables, namely the implicit `this' and the arguments
-             */
-            if (!isStatic() && (class_name != null)) { // Instance method -> `this' is local var 0
-                addLocalVariable("this", new ObjectType(class_name), start, end);
-            }
-        }
-        if (arg_types != null) {
-            int size = arg_types.length;
-            for (int i = 0; i < size; i++) {
-                if (Type.VOID == arg_types[i]) {
-                    throw new ClassGenException("'void' is an illegal argument type for a method");
-                }
-            }
-            if (arg_names != null) { // Names for variables provided?
-                if (size != arg_names.length) {
-                    throw new ClassGenException("Mismatch in argument array lengths: " + size
-                            + " vs. " + arg_names.length);
-                }
-            } else { // Give them dummy names
-                arg_names = new String[size];
-                for (int i = 0; i < size; i++) {
-                    arg_names[i] = "arg" + i;
-                }
-                setArgumentNames(arg_names);
-            }
-            if (!abstract_) {
-                for (int i = 0; i < size; i++) {
-                    addLocalVariable(arg_names[i], arg_types[i], start, end);
-                }
-            }
-        }
-    }
+    
 
 
-    /**
-     * Instantiate from existing method.
-     *
-     * @param m method
-     * @param class_name class name containing this method
-     * @param cp constant pool
-     */
-    public MethodGen(Method m, String class_name, ConstantPoolGen cp) {
-        this(m.getAccessFlags(), Type.getReturnType(m.getSignature()), Type.getArgumentTypes(m
-                .getSignature()), null /* may be overridden anyway */
-        , m.getName(), class_name,
-                ((m.getAccessFlags() & (Constants.ACC_ABSTRACT | Constants.ACC_NATIVE)) == 0)
-                        ? new InstructionList(m.getCode().getCode())
-                        : null, cp);
-        Attribute[] attributes = m.getAttributes();
-        for (int i = 0; i < attributes.length; i++) {
-            Attribute a = attributes[i];
-            if (a instanceof Code) {
-                Code c = (Code) a;
-                setMaxStack(c.getMaxStack());
-                setMaxLocals(c.getMaxLocals());
-                CodeException[] ces = c.getExceptionTable();
-                if (ces != null) {
-                    for (int j = 0; j < ces.length; j++) {
-                        CodeException ce = ces[j];
-                        int type = ce.getCatchType();
-                        ObjectType c_type = null;
-                        if (type > 0) {
-                            String cen = m.getConstantPool().getConstantString(type,
-                                    Constants.CONSTANT_Class);
-                            c_type = new ObjectType(cen);
-                        }
-                        int end_pc = ce.getEndPC();
-                        int length = m.getCode().getCode().length;
-                        InstructionHandle end;
-                        if (length == end_pc) { // May happen, because end_pc is exclusive
-                            end = il.getEnd();
-                        } else {
-                            end = il.findHandle(end_pc);
-                            end = end.getPrev(); // Make it inclusive
-                        }
-                        addExceptionHandler(il.findHandle(ce.getStartPC()), end, il.findHandle(ce
-                                .getHandlerPC()), c_type);
-                    }
-                }
-                Attribute[] c_attributes = c.getAttributes();
-                for (int j = 0; j < c_attributes.length; j++) {
-                    a = c_attributes[j];
-                    if (a instanceof LineNumberTable) {
-                        LineNumber[] ln = ((LineNumberTable) a).getLineNumberTable();
-                        for (int k = 0; k < ln.length; k++) {
-                            LineNumber l = ln[k];
-                            InstructionHandle ih = il.findHandle(l.getStartPC());
-                            if (ih != null) {
-                                addLineNumber(ih, l.getLineNumber());
-                            }
-                        }
-                    } else if (a instanceof LocalVariableTable) {
-                        LocalVariable[] lv = ((LocalVariableTable) a).getLocalVariableTable();
-                        removeLocalVariables();
-                        for (int k = 0; k < lv.length; k++) {
-                            LocalVariable l = lv[k];
-                            InstructionHandle start = il.findHandle(l.getStartPC());
-                            InstructionHandle end = il.findHandle(l.getStartPC() + l.getLength());
-                            // Repair malformed handles
-                            if (null == start) {
-                                start = il.getStart();
-                            }
-                            if (null == end) {
-                                end = il.getEnd();
-                            }
-                            addLocalVariable(l.getName(), Type.getType(l.getSignature()), l
-                                    .getIndex(), start, end);
-                        }
-                    } else if (a instanceof LocalVariableTypeTable) {
-                        LocalVariable[] lv = ((LocalVariableTypeTable) a).getLocalVariableTypeTable();
-                        removeLocalVariables();
-                        for (int k = 0; k < lv.length; k++) {
-                            LocalVariable l = lv[k];
-                            InstructionHandle start = il.findHandle(l.getStartPC());
-                            InstructionHandle end = il.findHandle(l.getStartPC() + l.getLength());
-                            // Repair malformed handles
-                            if (null == start) {
-                                start = il.getStart();
-                            }
-                            if (null == end) {
-                                end = il.getEnd();
-                            }
-                            addLocalVariable(l.getName(), Type.getType(l.getSignature()), l
-                                    .getIndex(), start, end);
-                        }
-                    } else {
-                        addCodeAttribute(a);
-                    }
-                }
-            } else if (a instanceof ExceptionTable) {
-                String[] names = ((ExceptionTable) a).getExceptionNames();
-                for (int j = 0; j < names.length; j++) {
-                    addException(names[j]);
-                }
-            } else if (a instanceof Annotations) {
-    			Annotations runtimeAnnotations = (Annotations) a;
-    			AnnotationEntry[] aes = runtimeAnnotations.getAnnotationEntries();
-    			for (int k = 0; k < aes.length; k++) {
-    				AnnotationEntry element = aes[k];
-    				addAnnotationEntry(new AnnotationEntryGen(element, cp, false));
-    			}
-            } else {
-                addAttribute(a);
-            }
-        }
-    }
+    
 
 
-    /**
-     * Adds a local variable to this method.
-     *
-     * @param name variable name
-     * @param type variable type
-     * @param slot the index of the local variable, if type is long or double, the next available
-     * index is slot+2
-     * @param start from where the variable is valid
-     * @param end until where the variable is valid
-     * @return new local variable object
-     * @see LocalVariable
-     */
-    public LocalVariableGen addLocalVariable( String name, Type type, int slot,
-            InstructionHandle start, InstructionHandle end ) {
-        byte t = type.getType();
-        if (t != Constants.T_ADDRESS) {
-            int add = type.getSize();
-            if (slot + add > max_locals) {
-                max_locals = slot + add;
-            }
-            LocalVariableGen l = new LocalVariableGen(slot, name, type, start, end);
-            int i;
-            if ((i = variable_vec.indexOf(l)) >= 0) {
-                variable_vec.set(i, l);
-            } else {
-                variable_vec.add(l);
-            }
-            return l;
-        } else {
-            throw new IllegalArgumentException("Can not use " + type
-                    + " as type for local variable");
-        }
-    }
+    
 
 
-    /**
-     * Adds a local variable to this method and assigns an index automatically.
-     *
-     * @param name variable name
-     * @param type variable type
-     * @param start from where the variable is valid, if this is null,
-     * it is valid from the start
-     * @param end until where the variable is valid, if this is null,
-     * it is valid to the end
-     * @return new local variable object
-     * @see LocalVariable
-     */
-    public LocalVariableGen addLocalVariable( String name, Type type, InstructionHandle start,
-            InstructionHandle end ) {
-        return addLocalVariable(name, type, max_locals, start, end);
-    }
+    
 
 
-    /**
-     * Remove a local variable, its slot will not be reused, if you do not use addLocalVariable
-     * with an explicit index argument.
-     */
-    public void removeLocalVariable( LocalVariableGen l ) {
-        variable_vec.remove(l);
-    }
+    
 
 
-    /**
-     * Remove all local variables.
-     */
-    public void removeLocalVariables() {
-        variable_vec.clear();
-    }
+    
 
 
     /**
@@ -419,440 +169,119 @@ public class MethodGen extends FieldGenOrMethodGen {
     }
 
 
-    /**
-     * Give an instruction a line number corresponding to the source code line.
-     *
-     * @param ih instruction to tag
-     * @return new line number object
-     * @see LineNumber
-     */
-    public LineNumberGen addLineNumber( InstructionHandle ih, int src_line ) {
-        LineNumberGen l = new LineNumberGen(ih, src_line);
-        line_number_vec.add(l);
-        return l;
-    }
-
-
-    /**
-     * Remove a line number.
-     */
-    public void removeLineNumber( LineNumberGen l ) {
-        line_number_vec.remove(l);
-    }
-
-
-    /**
-     * Remove all line numbers.
-     */
-    public void removeLineNumbers() {
-        line_number_vec.clear();
-    }
+    
 
 
-    /*
-     * @return array of line numbers
-     */
-    public LineNumberGen[] getLineNumbers() {
-        LineNumberGen[] lg = new LineNumberGen[line_number_vec.size()];
-        line_number_vec.toArray(lg);
-        return lg;
-    }
+    
 
 
-    /**
-     * @return `LineNumberTable' attribute of all the local variables of this method.
-     */
-    public LineNumberTable getLineNumberTable( ConstantPoolGen cp ) {
-        int size = line_number_vec.size();
-        LineNumber[] ln = new LineNumber[size];
-        try {
-            for (int i = 0; i < size; i++) {
-                ln[i] = ((LineNumberGen) line_number_vec.get(i)).getLineNumber();
-            }
-        } catch (ArrayIndexOutOfBoundsException e) {
-        } // Never occurs
-        return new LineNumberTable(cp.addUtf8("LineNumberTable"), 2 + ln.length * 4, ln, cp
-                .getConstantPool());
-    }
+    
 
 
-    /**
-     * Add an exception handler, i.e., specify region where a handler is active and an
-     * instruction where the actual handling is done.
-     *
-     * @param start_pc Start of region (inclusive)
-     * @param end_pc End of region (inclusive)
-     * @param handler_pc Where handling is done
-     * @param catch_type class type of handled exception or null if any
-     * exception is handled
-     * @return new exception handler object
-     */
-    public CodeExceptionGen addExceptionHandler( InstructionHandle start_pc,
-            InstructionHandle end_pc, InstructionHandle handler_pc, ObjectType catch_type ) {
-        if ((start_pc == null) || (end_pc == null) || (handler_pc == null)) {
-            throw new ClassGenException("Exception handler target is null instruction");
-        }
-        CodeExceptionGen c = new CodeExceptionGen(start_pc, end_pc, handler_pc, catch_type);
-        exception_vec.add(c);
-        return c;
-    }
+    
 
 
-    /**
-     * Remove an exception handler.
-     */
-    public void removeExceptionHandler( CodeExceptionGen c ) {
-        exception_vec.remove(c);
-    }
+    
 
 
-    /**
-     * Remove all line numbers.
-     */
-    public void removeExceptionHandlers() {
-        exception_vec.clear();
-    }
+    
 
 
-    /*
-     * @return array of declared exception handlers
-     */
-    public CodeExceptionGen[] getExceptionHandlers() {
-        CodeExceptionGen[] cg = new CodeExceptionGen[exception_vec.size()];
-        exception_vec.toArray(cg);
-        return cg;
-    }
+    
 
 
-    /**
-     * @return code exceptions for `Code' attribute
-     */
-    private CodeException[] getCodeExceptions() {
-        int size = exception_vec.size();
-        CodeException[] c_exc = new CodeException[size];
-        try {
-            for (int i = 0; i < size; i++) {
-                CodeExceptionGen c = (CodeExceptionGen) exception_vec.get(i);
-                c_exc[i] = c.getCodeException(cp);
-            }
-        } catch (ArrayIndexOutOfBoundsException e) {
-        }
-        return c_exc;
-    }
+    
 
 
-    /**
-     * Add an exception possibly thrown by this method.
-     *
-     * @param class_name (fully qualified) name of exception
-     */
-    public void addException( String class_name ) {
-        throws_vec.add(class_name);
-    }
+    
 
 
-    /**
-     * Remove an exception.
-     */
-    public void removeException( String c ) {
-        throws_vec.remove(c);
-    }
+    
 
 
-    /**
-     * Remove all exceptions.
-     */
-    public void removeExceptions() {
-        throws_vec.clear();
-    }
+    
 
 
-    /*
-     * @return array of thrown exceptions
-     */
-    public String[] getExceptions() {
-        String[] e = new String[throws_vec.size()];
-        throws_vec.toArray(e);
-        return e;
-    }
+    
 
 
-    /**
-     * @return `Exceptions' attribute of all the exceptions thrown by this method.
-     */
-    private ExceptionTable getExceptionTable( ConstantPoolGen cp ) {
-        int size = throws_vec.size();
-        int[] ex = new int[size];
-        try {
-            for (int i = 0; i < size; i++) {
-                ex[i] = cp.addClass((String) throws_vec.get(i));
-            }
-        } catch (ArrayIndexOutOfBoundsException e) {
-        }
-        return new ExceptionTable(cp.addUtf8("Exceptions"), 2 + 2 * size, ex, cp.getConstantPool());
-    }
+    
 
 
-    /**
-     * Add an attribute to the code. Currently, the JVM knows about the
-     * LineNumberTable, LocalVariableTable and StackMap attributes,
-     * where the former two will be generated automatically and the
-     * latter is used for the MIDP only. Other attributes will be
-     * ignored by the JVM but do no harm.
-     *
-     * @param a attribute to be added
-     */
-    public void addCodeAttribute( Attribute a ) {
-        code_attrs_vec.add(a);
-    }
+    
 
 
-    /**
-     * Remove a code attribute.
-     */
-    public void removeCodeAttribute( Attribute a ) {
-        code_attrs_vec.remove(a);
-    }
+    
 
 
-    /**
-     * Remove all code attributes.
-     */
-    public void removeCodeAttributes() {
-        code_attrs_vec.clear();
-    }
+    
 
 
-    /**
-     * @return all attributes of this method.
-     */
-    public Attribute[] getCodeAttributes() {
-        Attribute[] attributes = new Attribute[code_attrs_vec.size()];
-        code_attrs_vec.toArray(attributes);
-        return attributes;
-    }
     
-    public void addAnnotationsAsAttribute(ConstantPoolGen cp) {
-      	Attribute[] attrs = Utility.getAnnotationAttributes(cp,annotation_vec);
-        for (int i = 0; i < attrs.length; i++) {
-    		addAttribute(attrs[i]);
-    	}
-      }
+    
+    
+      
       
-      public void addParameterAnnotationsAsAttribute(ConstantPoolGen cp) {
-      	if (!hasParameterAnnotations) return;
-      	Attribute[] attrs = Utility.getParameterAnnotationAttributes(cp,param_annotations);
-      	if (attrs!=null) {
-          for (int i = 0; i < attrs.length; i++) {
-    		  addAttribute(attrs[i]);
-    	  }
-      	}
-      }
 
 
-    /**
-     * Get method object. Never forget to call setMaxStack() or setMaxStack(max), respectively,
-     * before calling this method (the same applies for max locals).
-     *
-     * @return method object
-     */
-    public Method getMethod() {
-        String signature = getSignature();
-        int name_index = cp.addUtf8(name);
-        int signature_index = cp.addUtf8(signature);
-        /* Also updates positions of instructions, i.e., their indices
-         */
-        byte[] byte_code = null;
-        if (il != null) {
-            byte_code = il.getByteCode();
-        }
-        LineNumberTable lnt = null;
-        LocalVariableTable lvt = null;
-        /* Create LocalVariableTable and LineNumberTable attributes (for debuggers, e.g.)
-         */
-        if ((variable_vec.size() > 0) && !strip_attributes) {
-            addCodeAttribute(lvt = getLocalVariableTable(cp));
-        }
-        if ((line_number_vec.size() > 0) && !strip_attributes) {
-            addCodeAttribute(lnt = getLineNumberTable(cp));
-        }
-        Attribute[] code_attrs = getCodeAttributes();
-        /* Each attribute causes 6 additional header bytes
-         */
-        int attrs_len = 0;
-        for (int i = 0; i < code_attrs.length; i++) {
-            attrs_len += (code_attrs[i].getLength() + 6);
-        }
-        CodeException[] c_exc = getCodeExceptions();
-        int exc_len = c_exc.length * 8; // Every entry takes 8 bytes
-        Code code = null;
-        if ((il != null) && !isAbstract() && !isNative()) {
-            // Remove any stale code attribute
-            Attribute[] attributes = getAttributes();
-            for (int i = 0; i < attributes.length; i++) {
-                Attribute a = attributes[i];
-                if (a instanceof Code) {
-                    removeAttribute(a);
-                }
-            }
-            code = new Code(cp.addUtf8("Code"), 8 + byte_code.length + // prologue byte code
-                    2 + exc_len + // exceptions
-                    2 + attrs_len, // attributes
-                    max_stack, max_locals, byte_code, c_exc, code_attrs, cp.getConstantPool());
-            addAttribute(code);
-        }
-        addAnnotationsAsAttribute(cp);
-        addParameterAnnotationsAsAttribute(cp);
-        ExceptionTable et = null;
-        if (throws_vec.size() > 0) {
-            addAttribute(et = getExceptionTable(cp));
-            // Add `Exceptions' if there are "throws" clauses
-        }
-        Method m = new Method(access_flags, name_index, signature_index, getAttributes(), cp
-                .getConstantPool());
-        // Undo effects of adding attributes
-        if (lvt != null) {
-            removeCodeAttribute(lvt);
-        }
-        if (lnt != null) {
-            removeCodeAttribute(lnt);
-        }
-        if (code != null) {
-            removeAttribute(code);
-        }
-        if (et != null) {
-            removeAttribute(et);
-        }
-        return m;
-    }
+    
 
 
-    /**
-     * Remove all NOPs from the instruction list (if possible) and update every
-     * object refering to them, i.e., branch instructions, local variables and
-     * exception handlers.
-     */
-    public void removeNOPs() {
-        if (il != null) {
-            InstructionHandle next;
-            /* Check branch instructions.
-             */
-            for (InstructionHandle ih = il.getStart(); ih != null; ih = next) {
-                next = ih.next;
-                if ((next != null) && (ih.getInstruction() instanceof NOP)) {
-                    try {
-                        il.delete(ih);
-                    } catch (TargetLostException e) {
-                        InstructionHandle[] targets = e.getTargets();
-                        for (int i = 0; i < targets.length; i++) {
-                            InstructionTargeter[] targeters = targets[i].getTargeters();
-                            for (int j = 0; j < targeters.length; j++) {
-                                targeters[j].updateTarget(targets[i], next);
-                            }
-                        }
-                    }
-                }
-            }
-        }
-    }
+    
 
 
-    /**
-     * Set maximum number of local variables.
-     */
-    public void setMaxLocals( int m ) {
-        max_locals = m;
-    }
+    
 
 
-    public int getMaxLocals() {
-        return max_locals;
-    }
+    
 
 
-    /**
-     * Set maximum stack size for this method.
-     */
-    public void setMaxStack( int m ) {
-        max_stack = m;
-    }
+    
 
 
-    public int getMaxStack() {
-        return max_stack;
-    }
+    
 
 
-    /** @return class that contains this method
-     */
-    public String getClassName() {
-        return class_name;
-    }
+    
 
 
-    public void setClassName( String class_name ) {
-        this.class_name = class_name;
-    }
+    
 
 
-    public void setReturnType( Type return_type ) {
-        setType(return_type);
-    }
+    
 
 
-    public Type getReturnType() {
-        return getType();
-    }
+    
 
 
-    public void setArgumentTypes( Type[] arg_types ) {
-        this.arg_types = arg_types;
-    }
+    
 
 
-    public Type[] getArgumentTypes() {
-        return (Type[]) arg_types.clone();
-    }
+    
 
 
-    public void setArgumentType( int i, Type type ) {
-        arg_types[i] = type;
-    }
+    
 
 
-    public Type getArgumentType( int i ) {
-        return arg_types[i];
-    }
+    
 
 
-    public void setArgumentNames( String[] arg_names ) {
-        this.arg_names = arg_names;
-    }
+    
 
 
-    public String[] getArgumentNames() {
-        return (String[]) arg_names.clone();
-    }
+    
 
 
-    public void setArgumentName( int i, String name ) {
-        arg_names[i] = name;
-    }
+    
 
 
-    public String getArgumentName( int i ) {
-        return arg_names[i];
-    }
+    
 
 
-    public InstructionList getInstructionList() {
-        return il;
-    }
+    
 
 
-    public void setInstructionList( InstructionList il ) {
-        this.il = il;
-    }
+    
 
 
     public String getSignature() {
@@ -860,210 +289,31 @@ public class MethodGen extends FieldGenOrMethodGen {
     }
 
 
-    /**
-     * Computes max. stack size by performing control flow analysis.
-     */
-    public void setMaxStack() {
-        if (il != null) {
-            max_stack = getMaxStack(cp, il, getExceptionHandlers());
-        } else {
-            max_stack = 0;
-        }
-    }
-
-
-    /**
-     * Compute maximum number of local variables.
-     */
-    public void setMaxLocals() {
-        if (il != null) {
-            int max = isStatic() ? 0 : 1;
-            if (arg_types != null) {
-                for (int i = 0; i < arg_types.length; i++) {
-                    max += arg_types[i].getSize();
-                }
-            }
-            for (InstructionHandle ih = il.getStart(); ih != null; ih = ih.getNext()) {
-                Instruction ins = ih.getInstruction();
-                if ((ins instanceof LocalVariableInstruction) || (ins instanceof RET)
-                        || (ins instanceof IINC)) {
-                    int index = ((IndexedInstruction) ins).getIndex()
-                            + ((TypedInstruction) ins).getType(cp).getSize();
-                    if (index > max) {
-                        max = index;
-                    }
-                }
-            }
-            max_locals = max;
-        } else {
-            max_locals = 0;
-        }
-    }
-
-
-    /** Do not/Do produce attributes code attributesLineNumberTable and
-     * LocalVariableTable, like javac -O
-     */
-    public void stripAttributes( boolean flag ) {
-        strip_attributes = flag;
-    }
-
-    static final class BranchTarget {
-
-        InstructionHandle target;
-        int stackDepth;
-
-
-        BranchTarget(InstructionHandle target, int stackDepth) {
-            this.target = target;
-            this.stackDepth = stackDepth;
-        }
-    }
-
-    static final class BranchStack {
-
-        Stack branchTargets = new Stack();
-        Hashtable visitedTargets = new Hashtable();
-
-
-        public void push( InstructionHandle target, int stackDepth ) {
-            if (visited(target)) {
-                return;
-            }
-            branchTargets.push(visit(target, stackDepth));
-        }
+    
 
 
-        public BranchTarget pop() {
-            if (!branchTargets.empty()) {
-                BranchTarget bt = (BranchTarget) branchTargets.pop();
-                return bt;
-            }
-            return null;
-        }
+    
 
 
-        private final BranchTarget visit( InstructionHandle target, int stackDepth ) {
-            BranchTarget bt = new BranchTarget(target, stackDepth);
-            visitedTargets.put(target, bt);
-            return bt;
-        }
+    
 
+    
 
-        private final boolean visited( InstructionHandle target ) {
-            return (visitedTargets.get(target) != null);
-        }
-    }
+    
 
 
-    /**
-     * Computes stack usage of an instruction list by performing control flow analysis.
-     *
-     * @return maximum stack depth used by method
-     */
-    public static int getMaxStack( ConstantPoolGen cp, InstructionList il, CodeExceptionGen[] et ) {
-        BranchStack branchTargets = new BranchStack();
-        /* Initially, populate the branch stack with the exception
-         * handlers, because these aren't (necessarily) branched to
-         * explicitly. in each case, the stack will have depth 1,
-         * containing the exception object.
-         */
-        for (int i = 0; i < et.length; i++) {
-            InstructionHandle handler_pc = et[i].getHandlerPC();
-            if (handler_pc != null) {
-                branchTargets.push(handler_pc, 1);
-            }
-        }
-        int stackDepth = 0, maxStackDepth = 0;
-        InstructionHandle ih = il.getStart();
-        while (ih != null) {
-            Instruction instruction = ih.getInstruction();
-            short opcode = instruction.getOpcode();
-            int delta = instruction.produceStack(cp) - instruction.consumeStack(cp);
-            stackDepth += delta;
-            if (stackDepth > maxStackDepth) {
-                maxStackDepth = stackDepth;
-            }
-            // choose the next instruction based on whether current is a branch.
-            if (instruction instanceof BranchInstruction) {
-                BranchInstruction branch = (BranchInstruction) instruction;
-                if (instruction instanceof Select) {
-                    // explore all of the select's targets. the default target is handled below.
-                    Select select = (Select) branch;
-                    InstructionHandle[] targets = select.getTargets();
-                    for (int i = 0; i < targets.length; i++) {
-                        branchTargets.push(targets[i], stackDepth);
-                    }
-                    // nothing to fall through to.
-                    ih = null;
-                } else if (!(branch instanceof IfInstruction)) {
-                    // if an instruction that comes back to following PC,
-                    // push next instruction, with stack depth reduced by 1.
-                    if (opcode == Constants.JSR || opcode == Constants.JSR_W) {
-                        branchTargets.push(ih.getNext(), stackDepth - 1);
-                    }
-                    ih = null;
-                }
-                // for all branches, the target of the branch is pushed on the branch stack.
-                // conditional branches have a fall through case, selects don't, and
-                // jsr/jsr_w return to the next instruction.
-                branchTargets.push(branch.getTarget(), stackDepth);
-            } else {
-                // check for instructions that terminate the method.
-                if (opcode == Constants.ATHROW || opcode == Constants.RET
-                        || (opcode >= Constants.IRETURN && opcode <= Constants.RETURN)) {
-                    ih = null;
-                }
-            }
-            // normal case, go to the next instruction.
-            if (ih != null) {
-                ih = ih.getNext();
-            }
-            // if we have no more instructions, see if there are any deferred branches to explore.
-            if (ih == null) {
-                BranchTarget bt = branchTargets.pop();
-                if (bt != null) {
-                    ih = bt.target;
-                    stackDepth = bt.stackDepth;
-                }
-            }
-        }
-        return maxStackDepth;
-    }
+    
 
     private List observers;
 
 
-    /** Add observer for this object.
-     */
-    public void addObserver( MethodObserver o ) {
-        if (observers == null) {
-            observers = new ArrayList();
-        }
-        observers.add(o);
-    }
+    
 
 
-    /** Remove observer for this object.
-     */
-    public void removeObserver( MethodObserver o ) {
-        if (observers != null) {
-            observers.remove(o);
-        }
-    }
+    
 
 
-    /** Call notify() method on all observers. This method is not called
-     * automatically whenever the state has changed, but has to be
-     * called by the user after he has finished editing the object.
-     */
-    public void update() {
-        if (observers != null) {
-            for (Iterator e = observers.iterator(); e.hasNext();) {
-                ((MethodObserver) e.next()).notify(this);
-            }
-        }
-    }
+    
 
 
     /**
@@ -1094,134 +344,10 @@ public class MethodGen extends FieldGenOrMethodGen {
     }
 
 
-    /** @return deep copy of this method
-     */
-    public MethodGen copy( String class_name, ConstantPoolGen cp ) {
-        Method m = ((MethodGen) clone()).getMethod();
-        MethodGen mg = new MethodGen(m, class_name, this.cp);
-        if (this.cp != cp) {
-            mg.setConstantPool(cp);
-            mg.getInstructionList().replaceConstantPool(this.cp, cp);
-        }
-        return mg;
-    }
     
-    //J5TODO: Should param_annotations be an array of arrays? Rather than an array of lists, this
-    // is more likely to suggest to the caller it is readonly (which a List does not). 
-    /**
-     * Return a list of AnnotationGen objects representing parameter annotations
-     */
-    public List getAnnotationsOnParameter(int i) {
-    	ensureExistingParameterAnnotationsUnpacked();
-    	if (!hasParameterAnnotations || i>arg_types.length) return null;
-    	return param_annotations[i];
-    }
     
-    /**
-	 * Goes through the attributes on the method and identifies any that are
-	 * RuntimeParameterAnnotations, extracting their contents and storing them
-	 * as parameter annotations. There are two kinds of parameter annotation -
-	 * visible and invisible. Once they have been unpacked, these attributes are
-	 * deleted. (The annotations will be rebuilt as attributes when someone
-	 * builds a Method object out of this MethodGen object).
-	 */
-	private void ensureExistingParameterAnnotationsUnpacked()
-	{
-		if (haveUnpackedParameterAnnotations)
-			return;
-		// Find attributes that contain parameter annotation data
-		Attribute[] attrs = getAttributes();
-		ParameterAnnotations paramAnnVisAttr = null;
-		ParameterAnnotations paramAnnInvisAttr = null;
-		for (int i = 0; i < attrs.length; i++)
-		{
-			Attribute attribute = attrs[i];
-			if (attribute instanceof ParameterAnnotations)
-			{
-				// Initialize param_annotations
-				if (!hasParameterAnnotations)
-				{
-					param_annotations = new List[arg_types.length];
-					for (int j = 0; j < arg_types.length; j++)
-						param_annotations[j] = new ArrayList();
-				}
-				hasParameterAnnotations = true;
-				ParameterAnnotations rpa = (ParameterAnnotations) attribute;
-				if (rpa instanceof RuntimeVisibleParameterAnnotations)
-					paramAnnVisAttr = rpa;
-				else
-					paramAnnInvisAttr = rpa;
-				for (int j = 0; j < arg_types.length; j++)
-				{
-					// This returns Annotation[] ...
-					ParameterAnnotationEntry immutableArray = rpa
-							.getParameterAnnotationEntries()[j];
-					// ... which needs transforming into an AnnotationGen[] ...
-					List mutable = makeMutableVersion(immutableArray.getAnnotationEntries());
-					// ... then add these to any we already know about
-					param_annotations[j].addAll(mutable);
-				}
-			}
-		}
-		if (paramAnnVisAttr != null)
-			removeAttribute(paramAnnVisAttr);
-		if (paramAnnInvisAttr != null)
-			removeAttribute(paramAnnInvisAttr);
-		haveUnpackedParameterAnnotations = true;
-	}
-
-	private List /* AnnotationGen */makeMutableVersion(AnnotationEntry[] mutableArray)
-	{
-		List result = new ArrayList();
-		for (int i = 0; i < mutableArray.length; i++)
-		{
-			result.add(new AnnotationEntryGen(mutableArray[i], getConstantPool(),
-					false));
-		}
-		return result;
-	}
-
-	public void addParameterAnnotation(int parameterIndex,
-			AnnotationEntryGen annotation)
-	{
-		ensureExistingParameterAnnotationsUnpacked();
-		if (!hasParameterAnnotations)
-		{
-			param_annotations = new List[arg_types.length];
-			hasParameterAnnotations = true;
-		}
-		List existingAnnotations = param_annotations[parameterIndex];
-		if (existingAnnotations != null)
-		{
-			existingAnnotations.add(annotation);
-		}
-		else
-		{
-			List l = new ArrayList();
-			l.add(annotation);
-			param_annotations[parameterIndex] = l;
-		}
-	}          
-
-
-
-
-    /**
-	 * @return Comparison strategy object
-	 */
-    public static BCELComparator getComparator() {
-        return _cmp;
-    }
-
-
-    /**
-     * @param comparator Comparison strategy object
-     */
-    public static void setComparator( BCELComparator comparator ) {
-        _cmp = comparator;
-    }
-
-
+    
+    
     /**
      * Return value as defined by given BCELComparator strategy.
      * By default two MethodGen objects are said to be equal when

==================================================
NEW.java
deleted file mode 100644
index 15618f3833..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/MethodObserver.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * Implement this interface if you're interested in changes to a MethodGen object
- * and register yourself with addObserver().
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public interface MethodObserver {
-
-    public void notify( MethodGen method );
-}

==================================================
NEWARRAY.java
index c884154327..749a4f0f32 100644
--- a/java/org/apache/tomcat/util/bcel/generic/NEW.java
+++ b/java/org/apache/tomcat/util/bcel/generic/NEW.java
@@ -16,8 +16,6 @@
  */
 package org.apache.tomcat.util.bcel.generic;
 
-import org.apache.tomcat.util.bcel.ExceptionConstants;
-
 /** 
  * NEW - Create new object
  * <PRE>Stack: ... -&gt; ..., objectref</PRE>
@@ -36,22 +34,11 @@ public class NEW extends CPInstruction implements LoadClass, AllocationInstructi
     }
 
 
-    public NEW(int index) {
-        super(org.apache.tomcat.util.bcel.Constants.NEW, index);
-    }
+    
 
 
-    public Class[] getExceptions() {
-        Class[] cs = new Class[2 + ExceptionConstants.EXCS_CLASS_AND_INTERFACE_RESOLUTION.length];
-        System.arraycopy(ExceptionConstants.EXCS_CLASS_AND_INTERFACE_RESOLUTION, 0, cs, 0,
-                ExceptionConstants.EXCS_CLASS_AND_INTERFACE_RESOLUTION.length);
-        cs[ExceptionConstants.EXCS_CLASS_AND_INTERFACE_RESOLUTION.length + 1] = ExceptionConstants.INSTANTIATION_ERROR;
-        cs[ExceptionConstants.EXCS_CLASS_AND_INTERFACE_RESOLUTION.length] = ExceptionConstants.ILLEGAL_ACCESS_ERROR;
-        return cs;
-    }
+    
 
 
-    public ObjectType getLoadClassType( ConstantPoolGen cpg ) {
-        return (ObjectType) getType(cpg);
-    }
+    
 }

==================================================
NOP.java
index d983785eb9..4019358d62 100644
--- a/java/org/apache/tomcat/util/bcel/generic/NEWARRAY.java
+++ b/java/org/apache/tomcat/util/bcel/generic/NEWARRAY.java
@@ -42,15 +42,10 @@ public class NEWARRAY extends Instruction implements AllocationInstruction, Exce
     }
 
 
-    public NEWARRAY(byte type) {
-        super(org.apache.tomcat.util.bcel.Constants.NEWARRAY, (short) 2);
-        this.type = type;
-    }
+    
 
 
-    public NEWARRAY(BasicType type) {
-        this(type.getType());
-    }
+    
 
 
     /**
@@ -71,12 +66,7 @@ public class NEWARRAY extends Instruction implements AllocationInstruction, Exce
     }
 
 
-    /**
-     * @return type of constructed array
-     */
-    public final Type getType() {
-        return new ArrayType(BasicType.getType(type), 1);
-    }
+    
 
 
     /**
@@ -96,9 +86,5 @@ public class NEWARRAY extends Instruction implements AllocationInstruction, Exce
     }
 
 
-    public Class[] getExceptions() {
-        return new Class[] {
-            org.apache.tomcat.util.bcel.ExceptionConstants.NEGATIVE_ARRAY_SIZE_EXCEPTION
-        };
-    }
+    
 }

==================================================
NamedAndTyped.java
deleted file mode 100644
index 75a1f57a47..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/NOP.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * NOP - Do nothing
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class NOP extends Instruction {
-
-    public NOP() {
-        super(org.apache.tomcat.util.bcel.Constants.NOP, (short) 1);
-    }
-}

==================================================
ObjectType.java
index 68bbce2bd2..053a8cb4e2 100644
--- a/java/org/apache/tomcat/util/bcel/generic/NamedAndTyped.java
+++ b/java/org/apache/tomcat/util/bcel/generic/NamedAndTyped.java
@@ -28,7 +28,7 @@ public interface NamedAndTyped {
     public String getName();
 
 
-    public Type getType();
+    
 
 
     public void setName( String name );

==================================================
POP.java
index 7d7d803b8a..59908ac660 100644
--- a/java/org/apache/tomcat/util/bcel/generic/ObjectType.java
+++ b/java/org/apache/tomcat/util/bcel/generic/ObjectType.java
@@ -17,8 +17,6 @@
 package org.apache.tomcat.util.bcel.generic;
 
 import org.apache.tomcat.util.bcel.Constants;
-import org.apache.tomcat.util.bcel.Repository;
-import org.apache.tomcat.util.bcel.classfile.JavaClass;
 
 /** 
  * Denotes reference such as java.lang.String.
@@ -63,93 +61,20 @@ public class ObjectType extends ReferenceType {
     }
 
 
-    /**
-     * If "this" doesn't reference a class, it references an interface
-     * or a non-existant entity.
-     * @deprecated this method returns an inaccurate result
-     *   if the class or interface referenced cannot
-     *   be found: use referencesClassExact() instead
-     */
-    public boolean referencesClass() {
-        try {
-            JavaClass jc = Repository.lookupClass(class_name);
-            return jc.isClass();
-        } catch (ClassNotFoundException e) {
-            return false;
-        }
-    }
+    
 
 
-    /**
-     * If "this" doesn't reference an interface, it references a class
-     * or a non-existant entity.
-     * @deprecated this method returns an inaccurate result
-     *   if the class or interface referenced cannot
-     *   be found: use referencesInterfaceExact() instead
-     */
-    public boolean referencesInterface() {
-        try {
-            JavaClass jc = Repository.lookupClass(class_name);
-            return !jc.isClass();
-        } catch (ClassNotFoundException e) {
-            return false;
-        }
-    }
+    
 
 
-    /**
-     * Return true if this type references a class,
-     * false if it references an interface.
-     * @return true if the type references a class, false if
-     *   it references an interface
-     * @throws ClassNotFoundException if the class or interface
-     *   referenced by this type can't be found
-     */
-    public boolean referencesClassExact() throws ClassNotFoundException {
-        JavaClass jc = Repository.lookupClass(class_name);
-        return jc.isClass();
-    }
+    
 
 
-    /**
-     * Return true if this type references an interface,
-     * false if it references a class.
-     * @return true if the type references an interface, false if
-     *   it references a class
-     * @throws ClassNotFoundException if the class or interface
-     *   referenced by this type can't be found
-     */
-    public boolean referencesInterfaceExact() throws ClassNotFoundException {
-        JavaClass jc = Repository.lookupClass(class_name);
-        return !jc.isClass();
-    }
+    
 
 
-    /**
-     * Return true if this type is a subclass of given ObjectType.
-     * @throws ClassNotFoundException if any of this class's superclasses
-     *  can't be found
-     */
-    public boolean subclassOf( ObjectType superclass ) throws ClassNotFoundException {
-        if (this.referencesInterface() || superclass.referencesInterface()) {
-            return false;
-        }
-        return Repository.instanceOf(this.class_name, superclass.class_name);
-    }
+    
 
 
-    /**
-     * Java Virtual Machine Specification edition 2, � 5.4.4 Access Control
-     * @throws ClassNotFoundException if the class referenced by this type
-     *   can't be found
-     */
-    public boolean accessibleTo( ObjectType accessor ) throws ClassNotFoundException {
-        JavaClass jc = Repository.lookupClass(class_name);
-        if (jc.isPublic()) {
-            return true;
-        } else {
-            JavaClass acc = Repository.lookupClass(accessor.class_name);
-            return acc.getPackageName().equals(jc.getPackageName());
-        }
-    }
+    
 }

==================================================
POP2.java
deleted file mode 100644
index 9c6b77cdd4..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/POP.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * POP - Pop top operand stack word
- *
- * <PRE>Stack: ..., word -&gt; ...</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class POP extends StackInstruction implements PopInstruction {
-
-    public POP() {
-        super(org.apache.tomcat.util.bcel.Constants.POP);
-    }
-}

==================================================
PUSH.java
deleted file mode 100644
index 3db05f65ff..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/POP2.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * POP2 - Pop two top operand stack words
- *
- * <PRE>Stack: ..., word2, word1 -&gt; ...</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class POP2 extends StackInstruction implements PopInstruction {
-
-    public POP2() {
-        super(org.apache.tomcat.util.bcel.Constants.POP2);
-    }
-}

==================================================
PUTFIELD.java
deleted file mode 100644
index d5c1329b38..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/PUSH.java
+++ /dev/null
@@ -1,178 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-import org.apache.tomcat.util.bcel.Constants;
-
-/** 
- * Wrapper class for push operations, which are implemented either as BIPUSH,
- * LDC or xCONST_n instructions.
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public final class PUSH implements CompoundInstruction, VariableLengthInstruction,
-        InstructionConstants {
-
-    private Instruction instruction;
-
-
-    /**
-     * This constructor also applies for values of type short, char, byte 
-     *
-     * @param cp Constant pool
-     * @param value to be pushed 
-     */
-    public PUSH(ConstantPoolGen cp, int value) {
-        if ((value >= -1) && (value <= 5)) {
-            instruction = INSTRUCTIONS[Constants.ICONST_0 + value];
-        } else if ((value >= -128) && (value <= 127)) {
-            instruction = new BIPUSH((byte) value);
-        } else if ((value >= -32768) && (value <= 32767)) {
-            instruction = new SIPUSH((short) value);
-        } else {
-            instruction = new LDC(cp.addInteger(value));
-        }
-    }
-
-
-    /**
-     * @param cp Constant pool
-     * @param value to be pushed 
-     */
-    public PUSH(ConstantPoolGen cp, boolean value) {
-        instruction = INSTRUCTIONS[Constants.ICONST_0 + (value ? 1 : 0)];
-    }
-
-
-    /**
-     * @param cp Constant pool
-     * @param value to be pushed 
-     */
-    public PUSH(ConstantPoolGen cp, float value) {
-        if (value == 0.0) {
-            instruction = FCONST_0;
-        } else if (value == 1.0) {
-            instruction = FCONST_1;
-        } else if (value == 2.0) {
-            instruction = FCONST_2;
-        } else {
-            instruction = new LDC(cp.addFloat(value));
-        }
-    }
-
-
-    /**
-     * @param cp Constant pool
-     * @param value to be pushed 
-     */
-    public PUSH(ConstantPoolGen cp, long value) {
-        if (value == 0) {
-            instruction = LCONST_0;
-        } else if (value == 1) {
-            instruction = LCONST_1;
-        } else {
-            instruction = new LDC2_W(cp.addLong(value));
-        }
-    }
-
-
-    /**
-     * @param cp Constant pool
-     * @param value to be pushed 
-     */
-    public PUSH(ConstantPoolGen cp, double value) {
-        if (value == 0.0) {
-            instruction = DCONST_0;
-        } else if (value == 1.0) {
-            instruction = DCONST_1;
-        } else {
-            instruction = new LDC2_W(cp.addDouble(value));
-        }
-    }
-
-
-    /**
-     * @param cp Constant pool
-     * @param value to be pushed 
-     */
-    public PUSH(ConstantPoolGen cp, String value) {
-        if (value == null) {
-            instruction = ACONST_NULL;
-        } else {
-            instruction = new LDC(cp.addString(value));
-        }
-    }
-
-
-    /**
-     * @param cp Constant pool
-     * @param value to be pushed 
-     */
-    public PUSH(ConstantPoolGen cp, Number value) {
-        if ((value instanceof Integer) || (value instanceof Short) || (value instanceof Byte)) {
-            instruction = new PUSH(cp, value.intValue()).instruction;
-        } else if (value instanceof Double) {
-            instruction = new PUSH(cp, value.doubleValue()).instruction;
-        } else if (value instanceof Float) {
-            instruction = new PUSH(cp, value.floatValue()).instruction;
-        } else if (value instanceof Long) {
-            instruction = new PUSH(cp, value.longValue()).instruction;
-        } else {
-            throw new ClassGenException("What's this: " + value);
-        }
-    }
-
-
-    /**
-     * creates a push object from a Character value. Warning: Make sure not to attempt to allow
-     * autoboxing to create this value parameter, as an alternative constructor will be called
-     * 
-     * @param cp Constant pool
-     * @param value to be pushed 
-     */
-    public PUSH(ConstantPoolGen cp, Character value) {
-        this(cp, value.charValue());
-    }
-
-
-    /**
-     * @param cp Constant pool
-     * @param value to be pushed 
-     */
-    public PUSH(ConstantPoolGen cp, Boolean value) {
-        this(cp, value.booleanValue());
-    }
-
-
-    public final InstructionList getInstructionList() {
-        return new InstructionList(instruction);
-    }
-
-
-    public final Instruction getInstruction() {
-        return instruction;
-    }
-
-
-    /**
-     * @return mnemonic for instruction
-     */
-    public String toString() {
-        return instruction.toString() + " (PUSH)";
-    }
-}

==================================================
PUTSTATIC.java
index c34c52c2ce..d7eeba81e9 100644
--- a/java/org/apache/tomcat/util/bcel/generic/PUTFIELD.java
+++ b/java/org/apache/tomcat/util/bcel/generic/PUTFIELD.java
@@ -16,9 +16,6 @@
  */
 package org.apache.tomcat.util.bcel.generic;
 
-import org.apache.tomcat.util.bcel.Constants;
-import org.apache.tomcat.util.bcel.ExceptionConstants;
-
 /** 
  * PUTFIELD - Put field in object
  * <PRE>Stack: ..., objectref, value -&gt; ...</PRE>
@@ -38,9 +35,7 @@ public class PUTFIELD extends FieldInstruction implements PopInstruction, Except
     }
 
 
-    public PUTFIELD(int index) {
-        super(Constants.PUTFIELD, index);
-    }
+    
 
 
     public int consumeStack( ConstantPoolGen cpg ) {
@@ -48,12 +43,5 @@ public class PUTFIELD extends FieldInstruction implements PopInstruction, Except
     }
 
 
-    public Class[] getExceptions() {
-        Class[] cs = new Class[2 + ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION.length];
-        System.arraycopy(ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION, 0, cs, 0,
-                ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION.length);
-        cs[ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION.length + 1] = ExceptionConstants.INCOMPATIBLE_CLASS_CHANGE_ERROR;
-        cs[ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION.length] = ExceptionConstants.NULL_POINTER_EXCEPTION;
-        return cs;
-    }
+    
 }

==================================================
RET.java
index ce52249b74..251b2d19db 100644
--- a/java/org/apache/tomcat/util/bcel/generic/PUTSTATIC.java
+++ b/java/org/apache/tomcat/util/bcel/generic/PUTSTATIC.java
@@ -16,9 +16,6 @@
  */
 package org.apache.tomcat.util.bcel.generic;
 
-import org.apache.tomcat.util.bcel.Constants;
-import org.apache.tomcat.util.bcel.ExceptionConstants;
-
 /** 
  * PUTSTATIC - Put static field in class
  * <PRE>Stack: ..., value -&gt; ...</PRE>
@@ -38,9 +35,7 @@ public class PUTSTATIC extends FieldInstruction implements ExceptionThrower, Pop
     }
 
 
-    public PUTSTATIC(int index) {
-        super(Constants.PUTSTATIC, index);
-    }
+    
 
 
     public int consumeStack( ConstantPoolGen cpg ) {
@@ -48,11 +43,5 @@ public class PUTSTATIC extends FieldInstruction implements ExceptionThrower, Pop
     }
 
 
-    public Class[] getExceptions() {
-        Class[] cs = new Class[1 + ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION.length];
-        System.arraycopy(ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION, 0, cs, 0,
-                ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION.length);
-        cs[ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION.length] = ExceptionConstants.INCOMPATIBLE_CLASS_CHANGE_ERROR;
-        return cs;
-    }
+    
 }

==================================================
RETURN.java
index 0bf095c90b..573d311593 100644
--- a/java/org/apache/tomcat/util/bcel/generic/RET.java
+++ b/java/org/apache/tomcat/util/bcel/generic/RET.java
@@ -42,10 +42,7 @@ public class RET extends Instruction implements IndexedInstruction, TypedInstruc
     }
 
 
-    public RET(int index) {
-        super(org.apache.tomcat.util.bcel.Constants.RET, (short) 2);
-        setIndex(index); // May set wide as side effect
-    }
+    
 
 
     /**

==================================================
ReferenceType.java
deleted file mode 100644
index e9f25c904e..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/RETURN.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * RETURN -  Return from void method
- * <PRE>Stack: ... -&gt; &lt;empty&gt;</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class RETURN extends ReturnInstruction {
-
-    public RETURN() {
-        super(org.apache.tomcat.util.bcel.Constants.RETURN);
-    }
-}

==================================================
ReturnInstruction.java
index f9cab4c6ec..74d05276aa 100644
--- a/java/org/apache/tomcat/util/bcel/generic/ReferenceType.java
+++ b/java/org/apache/tomcat/util/bcel/generic/ReferenceType.java
@@ -17,8 +17,6 @@
 package org.apache.tomcat.util.bcel.generic;
 
 import org.apache.tomcat.util.bcel.Constants;
-import org.apache.tomcat.util.bcel.Repository;
-import org.apache.tomcat.util.bcel.classfile.JavaClass;
 
 /**
  * Super class for object and array types.
@@ -40,291 +38,14 @@ public abstract class ReferenceType extends Type {
     }
 
 
-    /**
-     * Return true iff this type is castable to another type t as defined in
-     * the JVM specification.  The case where this is Type.NULL is not
-     * defined (see the CHECKCAST definition in the JVM specification).
-     * However, because e.g. CHECKCAST doesn't throw a
-     * ClassCastException when casting a null reference to any Object,
-     * true is returned in this case.
-     *
-     * @throws ClassNotFoundException if any classes or interfaces required
-     *  to determine assignment compatibility can't be found
-     */
-    public boolean isCastableTo( Type t ) throws ClassNotFoundException {
-        if (this.equals(Type.NULL)) {
-            return true; // If this is ever changed in isAssignmentCompatible()
-        }
-        return isAssignmentCompatibleWith(t);
-        /* Yes, it's true: It's the same definition.
-         * See vmspec2 AASTORE / CHECKCAST definitions.
-         */
-    }
+    
 
 
-    /**
-     * Return true iff this is assignment compatible with another type t
-     * as defined in the JVM specification; see the AASTORE definition
-     * there.
-     * @throws ClassNotFoundException if any classes or interfaces required
-     *  to determine assignment compatibility can't be found
-     */
-    public boolean isAssignmentCompatibleWith( Type t ) throws ClassNotFoundException {
-        if (!(t instanceof ReferenceType)) {
-            return false;
-        }
-        ReferenceType T = (ReferenceType) t;
-        if (this.equals(Type.NULL)) {
-            return true; // This is not explicitely stated, but clear. Isn't it?
-        }
-        /* If this is a class type then
-         */
-        if ((this instanceof ObjectType) && (((ObjectType) this).referencesClassExact())) {
-            /* If T is a class type, then this must be the same class as T,
-             or this must be a subclass of T;
-             */
-            if ((T instanceof ObjectType) && (((ObjectType) T).referencesClassExact())) {
-                if (this.equals(T)) {
-                    return true;
-                }
-                if (Repository.instanceOf(((ObjectType) this).getClassName(), ((ObjectType) T)
-                        .getClassName())) {
-                    return true;
-                }
-            }
-            /* If T is an interface type, this must implement interface T.
-             */
-            if ((T instanceof ObjectType) && (((ObjectType) T).referencesInterfaceExact())) {
-                if (Repository.implementationOf(((ObjectType) this).getClassName(),
-                        ((ObjectType) T).getClassName())) {
-                    return true;
-                }
-            }
-        }
-        /* If this is an interface type, then:
-         */
-        if ((this instanceof ObjectType) && (((ObjectType) this).referencesInterfaceExact())) {
-            /* If T is a class type, then T must be Object (�2.4.7).
-             */
-            if ((T instanceof ObjectType) && (((ObjectType) T).referencesClassExact())) {
-                if (T.equals(Type.OBJECT)) {
-                    return true;
-                }
-            }
-            /* If T is an interface type, then T must be the same interface
-             * as this or a superinterface of this (�2.13.2).
-             */
-            if ((T instanceof ObjectType) && (((ObjectType) T).referencesInterfaceExact())) {
-                if (this.equals(T)) {
-                    return true;
-                }
-                if (Repository.implementationOf(((ObjectType) this).getClassName(),
-                        ((ObjectType) T).getClassName())) {
-                    return true;
-                }
-            }
-        }
-        /* If this is an array type, namely, the type SC[], that is, an
-         * array of components of type SC, then:
-         */
-        if (this instanceof ArrayType) {
-            /* If T is a class type, then T must be Object (�2.4.7).
-             */
-            if ((T instanceof ObjectType) && (((ObjectType) T).referencesClassExact())) {
-                if (T.equals(Type.OBJECT)) {
-                    return true;
-                }
-            }
-            /* If T is an array type TC[], that is, an array of components
-             * of type TC, then one of the following must be true:
-             */
-            if (T instanceof ArrayType) {
-                /* TC and SC are the same primitive type (�2.4.1).
-                 */
-                Type sc = ((ArrayType) this).getElementType();
-                Type tc = ((ArrayType) T).getElementType();
-                if (sc instanceof BasicType && tc instanceof BasicType && sc.equals(tc)) {
-                    return true;
-                }
-                /* TC and SC are reference types (�2.4.6), and type SC is
-                 * assignable to TC by these runtime rules.
-                 */
-                if (tc instanceof ReferenceType && sc instanceof ReferenceType
-                        && ((ReferenceType) sc).isAssignmentCompatibleWith(tc)) {
-                    return true;
-                }
-            }
-            /* If T is an interface type, T must be one of the interfaces implemented by arrays (�2.15). */
-            // TODO: Check if this is still valid or find a way to dynamically find out which
-            // interfaces arrays implement. However, as of the JVM specification edition 2, there
-            // are at least two different pages where assignment compatibility is defined and
-            // on one of them "interfaces implemented by arrays" is exchanged with "'Cloneable' or
-            // 'java.io.Serializable'"
-            if ((T instanceof ObjectType) && (((ObjectType) T).referencesInterfaceExact())) {
-                for (int ii = 0; ii < Constants.INTERFACES_IMPLEMENTED_BY_ARRAYS.length; ii++) {
-                    if (T.equals(new ObjectType(Constants.INTERFACES_IMPLEMENTED_BY_ARRAYS[ii]))) {
-                        return true;
-                    }
-                }
-            }
-        }
-        return false; // default.
-    }
+    
 
 
-    /**
-     * This commutative operation returns the first common superclass (narrowest ReferenceType
-     * referencing a class, not an interface).
-     * If one of the types is a superclass of the other, the former is returned.
-     * If "this" is Type.NULL, then t is returned.
-     * If t is Type.NULL, then "this" is returned.
-     * If "this" equals t ['this.equals(t)'] "this" is returned.
-     * If "this" or t is an ArrayType, then Type.OBJECT is returned;
-     * unless their dimensions match. Then an ArrayType of the same
-     * number of dimensions is returned, with its basic type being the
-     * first common super class of the basic types of "this" and t.
-     * If "this" or t is a ReferenceType referencing an interface, then Type.OBJECT is returned.
-     * If not all of the two classes' superclasses cannot be found, "null" is returned.
-     * See the JVM specification edition 2, "�4.9.2 The Bytecode Verifier".
-     *
-     * @throws ClassNotFoundException on failure to find superclasses of this
-     *  type, or the type passed as a parameter
-     */
-    public ReferenceType getFirstCommonSuperclass( ReferenceType t ) throws ClassNotFoundException {
-        if (this.equals(Type.NULL)) {
-            return t;
-        }
-        if (t.equals(Type.NULL)) {
-            return this;
-        }
-        if (this.equals(t)) {
-            return this;
-            /*
-             * TODO: Above sounds a little arbitrary. On the other hand, there is
-             * no object referenced by Type.NULL so we can also say all the objects
-             * referenced by Type.NULL were derived from java.lang.Object.
-             * However, the Java Language's "instanceof" operator proves us wrong:
-             * "null" is not referring to an instance of java.lang.Object :)
-             */
-        }
-        /* This code is from a bug report by Konstantin Shagin <konst@cs.technion.ac.il> */
-        if ((this instanceof ArrayType) && (t instanceof ArrayType)) {
-            ArrayType arrType1 = (ArrayType) this;
-            ArrayType arrType2 = (ArrayType) t;
-            if ((arrType1.getDimensions() == arrType2.getDimensions())
-                    && arrType1.getBasicType() instanceof ObjectType
-                    && arrType2.getBasicType() instanceof ObjectType) {
-                return new ArrayType(((ObjectType) arrType1.getBasicType())
-                        .getFirstCommonSuperclass((ObjectType) arrType2.getBasicType()), arrType1
-                        .getDimensions());
-            }
-        }
-        if ((this instanceof ArrayType) || (t instanceof ArrayType)) {
-            return Type.OBJECT;
-            // TODO: Is there a proof of OBJECT being the direct ancestor of every ArrayType?
-        }
-        if (((this instanceof ObjectType) && ((ObjectType) this).referencesInterface())
-                || ((t instanceof ObjectType) && ((ObjectType) t).referencesInterface())) {
-            return Type.OBJECT;
-            // TODO: The above line is correct comparing to the vmspec2. But one could
-            // make class file verification a bit stronger here by using the notion of
-            // superinterfaces or even castability or assignment compatibility.
-        }
-        // this and t are ObjectTypes, see above.
-        ObjectType thiz = (ObjectType) this;
-        ObjectType other = (ObjectType) t;
-        JavaClass[] thiz_sups = Repository.getSuperClasses(thiz.getClassName());
-        JavaClass[] other_sups = Repository.getSuperClasses(other.getClassName());
-        if ((thiz_sups == null) || (other_sups == null)) {
-            return null;
-        }
-        // Waaahh...
-        JavaClass[] this_sups = new JavaClass[thiz_sups.length + 1];
-        JavaClass[] t_sups = new JavaClass[other_sups.length + 1];
-        System.arraycopy(thiz_sups, 0, this_sups, 1, thiz_sups.length);
-        System.arraycopy(other_sups, 0, t_sups, 1, other_sups.length);
-        this_sups[0] = Repository.lookupClass(thiz.getClassName());
-        t_sups[0] = Repository.lookupClass(other.getClassName());
-        for (int i = 0; i < t_sups.length; i++) {
-            for (int j = 0; j < this_sups.length; j++) {
-                if (this_sups[j].equals(t_sups[i])) {
-                    return new ObjectType(this_sups[j].getClassName());
-                }
-            }
-        }
-        // Huh? Did you ask for Type.OBJECT's superclass??
-        return null;
-    }
+    
 
 
-    /**
-     * This commutative operation returns the first common superclass (narrowest ReferenceType
-     * referencing a class, not an interface).
-     * If one of the types is a superclass of the other, the former is returned.
-     * If "this" is Type.NULL, then t is returned.
-     * If t is Type.NULL, then "this" is returned.
-     * If "this" equals t ['this.equals(t)'] "this" is returned.
-     * If "this" or t is an ArrayType, then Type.OBJECT is returned.
-     * If "this" or t is a ReferenceType referencing an interface, then Type.OBJECT is returned.
-     * If not all of the two classes' superclasses cannot be found, "null" is returned.
-     * See the JVM specification edition 2, "�4.9.2 The Bytecode Verifier".
-     *
-     * @deprecated use getFirstCommonSuperclass(ReferenceType t) which has
-     *             slightly changed semantics.
-     * @throws ClassNotFoundException on failure to find superclasses of this
-     *  type, or the type passed as a parameter
-     */
-    public ReferenceType firstCommonSuperclass( ReferenceType t ) throws ClassNotFoundException {
-        if (this.equals(Type.NULL)) {
-            return t;
-        }
-        if (t.equals(Type.NULL)) {
-            return this;
-        }
-        if (this.equals(t)) {
-            return this;
-            /*
-             * TODO: Above sounds a little arbitrary. On the other hand, there is
-             * no object referenced by Type.NULL so we can also say all the objects
-             * referenced by Type.NULL were derived from java.lang.Object.
-             * However, the Java Language's "instanceof" operator proves us wrong:
-             * "null" is not referring to an instance of java.lang.Object :)
-             */
-        }
-        if ((this instanceof ArrayType) || (t instanceof ArrayType)) {
-            return Type.OBJECT;
-            // TODO: Is there a proof of OBJECT being the direct ancestor of every ArrayType?
-        }
-        if (((this instanceof ObjectType) && ((ObjectType) this).referencesInterface())
-                || ((t instanceof ObjectType) && ((ObjectType) t).referencesInterface())) {
-            return Type.OBJECT;
-            // TODO: The above line is correct comparing to the vmspec2. But one could
-            // make class file verification a bit stronger here by using the notion of
-            // superinterfaces or even castability or assignment compatibility.
-        }
-        // this and t are ObjectTypes, see above.
-        ObjectType thiz = (ObjectType) this;
-        ObjectType other = (ObjectType) t;
-        JavaClass[] thiz_sups = Repository.getSuperClasses(thiz.getClassName());
-        JavaClass[] other_sups = Repository.getSuperClasses(other.getClassName());
-        if ((thiz_sups == null) || (other_sups == null)) {
-            return null;
-        }
-        // Waaahh...
-        JavaClass[] this_sups = new JavaClass[thiz_sups.length + 1];
-        JavaClass[] t_sups = new JavaClass[other_sups.length + 1];
-        System.arraycopy(thiz_sups, 0, this_sups, 1, thiz_sups.length);
-        System.arraycopy(other_sups, 0, t_sups, 1, other_sups.length);
-        this_sups[0] = Repository.lookupClass(thiz.getClassName());
-        t_sups[0] = Repository.lookupClass(other.getClassName());
-        for (int i = 0; i < t_sups.length; i++) {
-            for (int j = 0; j < this_sups.length; j++) {
-                if (this_sups[j].equals(t_sups[i])) {
-                    return new ObjectType(this_sups[j].getClassName());
-                }
-            }
-        }
-        // Huh? Did you ask for Type.OBJECT's superclass??
-        return null;
-    }
+    
 }

==================================================
ReturnaddressType.java
deleted file mode 100644
index 63eba56229..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/ReturnInstruction.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-import org.apache.tomcat.util.bcel.Constants;
-import org.apache.tomcat.util.bcel.ExceptionConstants;
-
-/**
- * Super class for the xRETURN family of instructions.
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public abstract class ReturnInstruction extends Instruction implements ExceptionThrower,
-        TypedInstruction, StackConsumer {
-
-    /**
-     * Empty constructor needed for the Class.newInstance() statement in
-     * Instruction.readInstruction(). Not to be used otherwise.
-     */
-    ReturnInstruction() {
-    }
-
-
-    /**
-     * @param opcode of instruction
-     */
-    protected ReturnInstruction(short opcode) {
-        super(opcode, (short) 1);
-    }
-
-
-    public Type getType() {
-        switch (opcode) {
-            case Constants.IRETURN:
-                return Type.INT;
-            case Constants.LRETURN:
-                return Type.LONG;
-            case Constants.FRETURN:
-                return Type.FLOAT;
-            case Constants.DRETURN:
-                return Type.DOUBLE;
-            case Constants.ARETURN:
-                return Type.OBJECT;
-            case Constants.RETURN:
-                return Type.VOID;
-            default: // Never reached
-                throw new ClassGenException("Unknown type " + opcode);
-        }
-    }
-
-
-    public Class[] getExceptions() {
-        return new Class[] {
-            ExceptionConstants.ILLEGAL_MONITOR_STATE
-        };
-    }
-
-
-    /** @return type associated with the instruction
-     */
-    public Type getType( ConstantPoolGen cp ) {
-        return getType();
-    }
-}

==================================================
SALOAD.java
index aacf3e88af..08015730bd 100644
--- a/java/org/apache/tomcat/util/bcel/generic/ReturnaddressType.java
+++ b/java/org/apache/tomcat/util/bcel/generic/ReturnaddressType.java
@@ -73,10 +73,5 @@ public class ReturnaddressType extends Type {
     }
 
 
-    /**
-     * @return the target of this ReturnaddressType
-     */
-    public InstructionHandle getTarget() {
-        return returnTarget;
-    }
+    
 }

==================================================
SASTORE.java
deleted file mode 100644
index 8942646164..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/SALOAD.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * SALOAD - Load short from array
- * <PRE>Stack: ..., arrayref, index -&gt; ..., value</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class SALOAD extends ArrayInstruction implements StackProducer {
-
-    public SALOAD() {
-        super(org.apache.tomcat.util.bcel.Constants.SALOAD);
-    }
-}

==================================================
SIPUSH.java
deleted file mode 100644
index 94c1b8c7f6..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/SASTORE.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * SASTORE - Store into short array
- * <PRE>Stack: ..., arrayref, index, value -&gt; ...</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class SASTORE extends ArrayInstruction implements StackConsumer {
-
-    public SASTORE() {
-        super(org.apache.tomcat.util.bcel.Constants.SASTORE);
-    }
-}

==================================================
SWAP.java
index 85448a7e17..9367739062 100644
--- a/java/org/apache/tomcat/util/bcel/generic/SIPUSH.java
+++ b/java/org/apache/tomcat/util/bcel/generic/SIPUSH.java
@@ -41,10 +41,7 @@ public class SIPUSH extends Instruction implements ConstantPushInstruction {
     }
 
 
-    public SIPUSH(short b) {
-        super(org.apache.tomcat.util.bcel.Constants.SIPUSH, (short) 3);
-        this.b = b;
-    }
+    
 
 
     /**
@@ -78,9 +75,5 @@ public class SIPUSH extends Instruction implements ConstantPushInstruction {
     }
 
 
-    /** @return Type.SHORT
-     */
-    public Type getType( ConstantPoolGen cp ) {
-        return Type.SHORT;
-    }
+    
 }

==================================================
Select.java
deleted file mode 100644
index abc3432c00..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/SWAP.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * SWAP - Swa top operand stack word
- * <PRE>Stack: ..., word2, word1 -&gt; ..., word1, word2</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class SWAP extends StackInstruction implements StackConsumer, StackProducer {
-
-    public SWAP() {
-        super(org.apache.tomcat.util.bcel.Constants.SWAP);
-    }
-}

==================================================
SimpleElementValueGen.java
index aef247c2b4..c6c244618c 100644
--- a/java/org/apache/tomcat/util/bcel/generic/Select.java
+++ b/java/org/apache/tomcat/util/bcel/generic/Select.java
@@ -50,26 +50,7 @@ public abstract class Select extends BranchInstruction implements VariableLength
     }
 
 
-    /**
-     * (Match, target) pairs for switch.
-     * `Match' and `targets' must have the same length of course.
-     *
-     * @param match array of matching values
-     * @param targets instruction targets
-     * @param defaultTarget default instruction target
-     */
-    Select(short opcode, int[] match, InstructionHandle[] targets, InstructionHandle defaultTarget) {
-        super(opcode, defaultTarget);
-        this.targets = targets;
-        for (int i = 0; i < targets.length; i++) {
-            notifyTarget(null, targets[i], this);
-        }
-        this.match = match;
-        if ((match_length = match.length) != targets.length) {
-            throw new ClassGenException("Match and target array have not the same length: Match length: " + match.length + " Target length: " + targets.length);
-        }
-        indices = new int[match_length];
-    }
+    
 
 
     /**
@@ -211,12 +192,7 @@ public abstract class Select extends BranchInstruction implements VariableLength
     }
 
 
-    /**
-     * @return array of match indices
-     */
-    public int[] getMatchs() {
-        return match;
-    }
+    
 
 
     /**

==================================================
StackConsumer.java
index e1ae11b2b3..568a3f6878 100644
--- a/java/org/apache/tomcat/util/bcel/generic/SimpleElementValueGen.java
+++ b/java/org/apache/tomcat/util/bcel/generic/SimpleElementValueGen.java
@@ -17,74 +17,25 @@ public class SimpleElementValueGen extends ElementValueGen
 	// For 'class' this points to the class entry in the cpGen
 	private int idx;
 
-	// ctors for each supported type... type could be inferred but for now lets
-	// force it to be passed
-	/**
-	 * Protected ctor used for deserialization, doesn't *put* an entry in the
-	 * constant pool, assumes the one at the supplied index is correct.
-	 */
-	protected SimpleElementValueGen(int type, int idx, ConstantPoolGen cpGen)
-	{
-		super(type, cpGen);
-		this.idx = idx;
-	}
+	
 
-	public SimpleElementValueGen(int type, ConstantPoolGen cpGen, int value)
-	{
-		super(type, cpGen);
-		idx = cpGen.addInteger(value);
-	}
+	
 
-	public SimpleElementValueGen(int type, ConstantPoolGen cpGen, long value)
-	{
-		super(type, cpGen);
-		idx = cpGen.addLong(value);
-	}
+	
 
-	public SimpleElementValueGen(int type, ConstantPoolGen cpGen, double value)
-	{
-		super(type, cpGen);
-		idx = cpGen.addDouble(value);
-	}
+	
 
-	public SimpleElementValueGen(int type, ConstantPoolGen cpGen, float value)
-	{
-		super(type, cpGen);
-		idx = cpGen.addFloat(value);
-	}
+	
 
-	public SimpleElementValueGen(int type, ConstantPoolGen cpGen, short value)
-	{
-		super(type, cpGen);
-		idx = cpGen.addInteger(value);
-	}
+	
 
-	public SimpleElementValueGen(int type, ConstantPoolGen cpGen, byte value)
-	{
-		super(type, cpGen);
-		idx = cpGen.addInteger(value);
-	}
+	
 
-	public SimpleElementValueGen(int type, ConstantPoolGen cpGen, char value)
-	{
-		super(type, cpGen);
-		idx = cpGen.addInteger(value);
-	}
+	
 
-	public SimpleElementValueGen(int type, ConstantPoolGen cpGen, boolean value)
-	{
-		super(type, cpGen);
-		if (value)
-			idx = cpGen.addInteger(1);
-		else
-			idx = cpGen.addInteger(0);
-	}
+	
 
-	public SimpleElementValueGen(int type, ConstantPoolGen cpGen, String value)
-	{
-		super(type, cpGen);
-		idx = cpGen.addUtf8(value);
-	}
+	
 
 	/**
 	 * The boolean controls whether we copy info from the 'old' constant pool to
@@ -155,28 +106,11 @@ public class SimpleElementValueGen extends ElementValueGen
 		return new SimpleElementValue(type, idx, cpGen.getConstantPool());
 	}
 
-	public int getIndex()
-	{
-		return idx;
-	}
+	
 
-	public String getValueString()
-	{
-		if (type != STRING)
-			throw new RuntimeException(
-					"Dont call getValueString() on a non STRING ElementValue");
-		ConstantUtf8 c = (ConstantUtf8) cpGen.getConstant(idx);
-		return c.getBytes();
-	}
+	
 
-	public int getValueInt()
-	{
-		if (type != PRIMITIVE_INT)
-			throw new RuntimeException(
-					"Dont call getValueString() on a non STRING ElementValue");
-		ConstantInteger c = (ConstantInteger) cpGen.getConstant(idx);
-		return c.getBytes();
-	}
+	
 
 	// Whatever kind of value it is, return it as a string
 	public String stringifyValue()

==================================================
StackInstruction.java
index 990f5757ba..b02cce4435 100644
--- a/java/org/apache/tomcat/util/bcel/generic/StackConsumer.java
+++ b/java/org/apache/tomcat/util/bcel/generic/StackConsumer.java
@@ -24,7 +24,5 @@ package org.apache.tomcat.util.bcel.generic;
  */
 public interface StackConsumer {
 
-    /** @return how many words are consumed from stack
-     */
-    public int consumeStack( ConstantPoolGen cpg );
+    
 }

==================================================
StackProducer.java
deleted file mode 100644
index 5d7bf76fb3..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/StackInstruction.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * Super class for stack operations like DUP and POP.
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public abstract class StackInstruction extends Instruction {
-
-    /**
-     * Empty constructor needed for the Class.newInstance() statement in
-     * Instruction.readInstruction(). Not to be used otherwise.
-     */
-    StackInstruction() {
-    }
-
-
-    /**
-     * @param opcode instruction opcode
-     */
-    protected StackInstruction(short opcode) {
-        super(opcode, (short) 1);
-    }
-
-
-    /** @return Type.UNKNOWN
-     */
-    public Type getType( ConstantPoolGen cp ) {
-        return Type.UNKNOWN;
-    }
-}

==================================================
TABLESWITCH.java
index 04a32beb9c..6a4f2f5c97 100644
--- a/java/org/apache/tomcat/util/bcel/generic/StackProducer.java
+++ b/java/org/apache/tomcat/util/bcel/generic/StackProducer.java
@@ -25,7 +25,5 @@ package org.apache.tomcat.util.bcel.generic;
  */
 public interface StackProducer {
 
-    /** @return how many words are produced on stack
-     */
-    public int produceStack( ConstantPoolGen cpg );
+    
 }

==================================================
TargetLostException.java
index 2d2e7134a4..35dc981e64 100644
--- a/java/org/apache/tomcat/util/bcel/generic/TABLESWITCH.java
+++ b/java/org/apache/tomcat/util/bcel/generic/TABLESWITCH.java
@@ -37,18 +37,7 @@ public class TABLESWITCH extends Select {
     }
 
 
-    /**
-     * @param match sorted array of match values, match[0] must be low value, 
-     * match[match_length - 1] high value
-     * @param targets where to branch for matched values
-     * @param defaultTarget default branch
-     */
-    public TABLESWITCH(int[] match, InstructionHandle[] targets, InstructionHandle defaultTarget) {
-        super(org.apache.tomcat.util.bcel.Constants.TABLESWITCH, match, targets, defaultTarget);
-        length = (short) (13 + match_length * 4); /* Alignment remainder assumed
-         * 0 here, until dump time */
-        fixed_length = length;
-    }
+    
 
 
     /**

==================================================
Type.java
deleted file mode 100644
index dd7c993ed8..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/TargetLostException.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * Thrown by InstructionList.remove() when one or multiple disposed instruction
- * are still being referenced by a InstructionTargeter object. I.e. the
- * InstructionTargeter has to be notified that (one of) the InstructionHandle it
- * is referencing is being removed from the InstructionList and thus not valid anymore.
- *
- * Making this an exception instead of a return value forces the user to handle
- * these case explicitely in a try { ... } catch. The following code illustrates
- * how this may be done:
- *
- * <PRE>
- *     ...
- *     try {
- *	il.delete(start_ih, end_ih);
- *     } catch(TargetLostException e) {
- *       InstructionHandle[] targets = e.getTargets();
- *	 for(int i=0; i < targets.length; i++) {
- *	   InstructionTargeter[] targeters = targets[i].getTargeters();
- *     
- *	   for(int j=0; j < targeters.length; j++)
- *	     targeters[j].updateTarget(targets[i], new_target);
- *       }
- *     }
- * </PRE>
- *
- * @see InstructionHandle
- * @see InstructionList
- * @see InstructionTargeter
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public final class TargetLostException extends Exception {
-
-    private InstructionHandle[] targets;
-
-
-    TargetLostException(InstructionHandle[] t, String mesg) {
-        super(mesg);
-        targets = t;
-    }
-
-
-    /**
-     * @return list of instructions still being targeted.
-     */
-    public InstructionHandle[] getTargets() {
-        return targets;
-    }
-}

==================================================
TypedInstruction.java
index 1c5d51310e..1ede105e87 100644
--- a/java/org/apache/tomcat/util/bcel/generic/Type.java
+++ b/java/org/apache/tomcat/util/bcel/generic/Type.java
@@ -16,8 +16,6 @@
  */
 package org.apache.tomcat.util.bcel.generic;
 
-import java.util.ArrayList;
-import java.util.List;
 import org.apache.tomcat.util.bcel.Constants;
 import org.apache.tomcat.util.bcel.classfile.ClassFormatException;
 import org.apache.tomcat.util.bcel.classfile.Utility;
@@ -47,13 +45,12 @@ public abstract class Type implements java.io.Serializable {
     public static final ObjectType OBJECT = new ObjectType("java.lang.Object");
     public static final ObjectType CLASS = new ObjectType("java.lang.Class");
     public static final ObjectType STRING = new ObjectType("java.lang.String");
-    public static final ObjectType STRINGBUFFER = new ObjectType("java.lang.StringBuffer");
-    public static final ObjectType THROWABLE = new ObjectType("java.lang.Throwable");
-    public static final Type[] NO_ARGS = new Type[0];
+    
+    
+    
     public static final ReferenceType NULL = new ReferenceType() {
     };
-    public static final Type UNKNOWN = new Type(Constants.T_UNKNOWN, "<unknown object>") {
-    };
+    
 
 
     protected Type(byte t, String s) {
@@ -212,101 +209,16 @@ public abstract class Type implements java.io.Serializable {
     }
 
 
-    /**
-     * Convert arguments of a method (signature) to an array of Type objects.
-     * @param signature signature string such as (Ljava/lang/String;)V
-     * @return array of argument types
-     */
-    public static Type[] getArgumentTypes( String signature ) {
-        List vec = new ArrayList();
-        int index;
-        Type[] types;
-        try { // Read all declarations between for `(' and `)'
-            if (signature.charAt(0) != '(') {
-                throw new ClassFormatException("Invalid method signature: " + signature);
-            }
-            index = 1; // current string position
-            while (signature.charAt(index) != ')') {
-                vec.add(getType(signature.substring(index)));
-                //corrected concurrent private static field acess
-                index += unwrap(consumed_chars); // update position
-            }
-        } catch (StringIndexOutOfBoundsException e) { // Should never occur
-            throw new ClassFormatException("Invalid method signature: " + signature, e);
-        }
-        types = new Type[vec.size()];
-        vec.toArray(types);
-        return types;
-    }
+    
 
 
-    /** Convert runtime java.lang.Class to BCEL Type object.
-     * @param cl Java class
-     * @return corresponding Type object
-     */
-    public static Type getType( java.lang.Class cl ) {
-        if (cl == null) {
-            throw new IllegalArgumentException("Class must not be null");
-        }
-        /* That's an amzingly easy case, because getName() returns
-         * the signature. That's what we would have liked anyway.
-         */
-        if (cl.isArray()) {
-            return getType(cl.getName());
-        } else if (cl.isPrimitive()) {
-            if (cl == Integer.TYPE) {
-                return INT;
-            } else if (cl == Void.TYPE) {
-                return VOID;
-            } else if (cl == Double.TYPE) {
-                return DOUBLE;
-            } else if (cl == Float.TYPE) {
-                return FLOAT;
-            } else if (cl == Boolean.TYPE) {
-                return BOOLEAN;
-            } else if (cl == Byte.TYPE) {
-                return BYTE;
-            } else if (cl == Short.TYPE) {
-                return SHORT;
-            } else if (cl == Byte.TYPE) {
-                return BYTE;
-            } else if (cl == Long.TYPE) {
-                return LONG;
-            } else if (cl == Character.TYPE) {
-                return CHAR;
-            } else {
-                throw new IllegalStateException("Ooops, what primitive type is " + cl);
-            }
-        } else { // "Real" class
-            return new ObjectType(cl.getName());
-        }
-    }
+    
 
 
-    /**
-     * Convert runtime java.lang.Class[] to BCEL Type objects.
-     * @param classes an array of runtime class objects
-     * @return array of corresponding Type objects
-     */
-    public static Type[] getTypes( java.lang.Class[] classes ) {
-        Type[] ret = new Type[classes.length];
-        for (int i = 0; i < ret.length; i++) {
-            ret[i] = getType(classes[i]);
-        }
-        return ret;
-    }
+    
 
 
-    public static String getSignature( java.lang.reflect.Method meth ) {
-        StringBuffer sb = new StringBuffer("(");
-        Class[] params = meth.getParameterTypes(); // avoid clone
-        for (int j = 0; j < params.length; j++) {
-            sb.append(getType(params[j]).getSignature());
-        }
-        sb.append(")");
-        sb.append(getType(meth.getReturnType()).getSignature());
-        return sb.toString();
-    }
+    
     
     private static int size(int coded) {
     	return coded & 3;

==================================================
ByteSequence.java
index db2b4e9cee..e0034b4cf1 100644
--- a/java/org/apache/tomcat/util/bcel/generic/TypedInstruction.java
+++ b/java/org/apache/tomcat/util/bcel/generic/TypedInstruction.java
@@ -25,5 +25,5 @@ package org.apache.tomcat.util.bcel.generic;
  */
 public interface TypedInstruction {
 
-    public Type getType( ConstantPoolGen cpg );
+    
 }

==================================================
ClassLoaderRepository.java
index 9823df5af2..cfbe62a853 100644
--- a/java/org/apache/tomcat/util/bcel/util/ByteSequence.java
+++ b/java/org/apache/tomcat/util/bcel/util/ByteSequence.java
@@ -43,9 +43,7 @@ public final class ByteSequence extends DataInputStream {
     }
 
 
-    final void unreadByte() {
-        byte_stream.unreadByte();
-    }
+    
 
     private static final class ByteArrayStream extends ByteArrayInputStream {
 
@@ -57,12 +55,5 @@ public final class ByteSequence extends DataInputStream {
         final int getPosition() {
             return pos;
         } // is protected in ByteArrayInputStream
-
-
-        final void unreadByte() {
-            if (pos > 0) {
-                pos--;
-            }
-        }
     }
 }

==================================================
ClassPath.java
deleted file mode 100644
index 8cd0bc5c48..0000000000
--- a/java/org/apache/tomcat/util/bcel/util/ClassLoaderRepository.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.util;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.HashMap;
-import java.util.Map;
-import org.apache.tomcat.util.bcel.classfile.ClassParser;
-import org.apache.tomcat.util.bcel.classfile.JavaClass;
-
-/**
- * The repository maintains information about which classes have
- * been loaded.
- *
- * It loads its data from the ClassLoader implementation
- * passed into its constructor.
- *
- * @see org.apache.tomcat.util.bcel.Repository
- *
- * @version $Id$
- * @author <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- * @author David Dixon-Peugh
- */
-public class ClassLoaderRepository implements Repository {
-
-    private java.lang.ClassLoader loader;
-    private Map loadedClasses = new HashMap(); // CLASSNAME X JAVACLASS
-
-
-    public ClassLoaderRepository(java.lang.ClassLoader loader) {
-        this.loader = loader;
-    }
-
-
-    /**
-     * Store a new JavaClass into this Repository.
-     */
-    public void storeClass( JavaClass clazz ) {
-        loadedClasses.put(clazz.getClassName(), clazz);
-        clazz.setRepository(this);
-    }
-
-
-    /**
-     * Remove class from repository
-     */
-    public void removeClass( JavaClass clazz ) {
-        loadedClasses.remove(clazz.getClassName());
-    }
-
-
-    /**
-     * Find an already defined JavaClass.
-     */
-    public JavaClass findClass( String className ) {
-        if (loadedClasses.containsKey(className)) {
-            return (JavaClass) loadedClasses.get(className);
-        } else {
-            return null;
-        }
-    }
-
-
-    /**
-     * Lookup a JavaClass object from the Class Name provided.
-     */
-    public JavaClass loadClass( String className ) throws ClassNotFoundException {
-        String classFile = className.replace('.', '/');
-        JavaClass RC = findClass(className);
-        if (RC != null) {
-            return RC;
-        }
-        try {
-            InputStream is = loader.getResourceAsStream(classFile + ".class");
-            if (is == null) {
-                throw new ClassNotFoundException(className + " not found.");
-            }
-            ClassParser parser = new ClassParser(is, className);
-            RC = parser.parse();
-            storeClass(RC);
-            return RC;
-        } catch (IOException e) {
-            throw new ClassNotFoundException(className + " not found: " + e.toString(), e);
-        }
-    }
-
-
-    public JavaClass loadClass( Class clazz ) throws ClassNotFoundException {
-        return loadClass(clazz.getName());
-    }
-
-
-    /** Clear all entries from cache.
-     */
-    public void clear() {
-        loadedClasses.clear();
-    }
-
-
-    /*
-     * @return null
-     */
-    public ClassPath getClassPath() {
-        return null;
-    }
-}

==================================================
Repository.java
index 284a491bd7..56eb79cc4f 100644
--- a/java/org/apache/tomcat/util/bcel/util/ClassPath.java
+++ b/java/org/apache/tomcat/util/bcel/util/ClassPath.java
@@ -16,7 +16,6 @@
  */
 package org.apache.tomcat.util.bcel.util;
 
-import java.io.DataInputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FilenameFilter;
@@ -26,12 +25,10 @@ import java.io.Serializable;
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.util.ArrayList;
-import java.util.Enumeration;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
 import java.util.StringTokenizer;
-import java.util.Vector;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
 
@@ -189,49 +186,11 @@ public class ClassPath implements Serializable {
         return getClassFile(name, suffix).getInputStream();
     }
 
-    /**
-     * @param name fully qualified resource name, e.g. java/lang/String.class
-     * @return InputStream supplying the resource, or null if no resource with that name.
-     */
-    public InputStream getResourceAsStream(String name) {
-        for (int i = 0; i < paths.length; i++) {
-            InputStream is;
-            if ((is = paths[i].getResourceAsStream(name)) != null) {
-                return is;
-            }
-        }
-        return null;
-    }
     
-    /**
-     * @param name fully qualified resource name, e.g. java/lang/String.class
-     * @return URL supplying the resource, or null if no resource with that name.
-     */
-    public URL getResource(String name) {
-        for (int i = 0; i < paths.length; i++) {
-            URL url;
-            if ((url = paths[i].getResource(name)) != null) {
-                return url;
-            }
-        }
-        return null;
-    }
+    
+    
 
-    /**
-     * @param name fully qualified resource name, e.g. java/lang/String.class
-     * @return An Enumeration of URLs supplying the resource, or an
-     * empty Enumeration if no resource with that name.
-     */
-    public Enumeration getResources(String name) {
-        Vector results = new Vector();
-        for (int i = 0; i < paths.length; i++) {
-            URL url;
-            if ((url = paths[i].getResource(name)) != null) {
-                results.add(url);
-            }
-        }
-        return results.elements();
-    }
+    
 
     /**
      * @param name fully qualified file name, e.g. java/lang/String
@@ -249,70 +208,19 @@ public class ClassPath implements Serializable {
     }
 
 
-    /**
-     * @param name fully qualified class name, e.g. java.lang.String
-     * @return input stream for class
-     */
-    public ClassFile getClassFile( String name ) throws IOException {
-        return getClassFile(name, ".class");
-    }
+    
 
 
-    /**
-     * @param name fully qualified file name, e.g. java/lang/String
-     * @param suffix file name ends with suffix, e.g. .java
-     * @return byte array for file on class path
-     */
-    public byte[] getBytes( String name, String suffix ) throws IOException {
-        DataInputStream dis = null;
-        try {
-            InputStream is = getInputStream(name, suffix);
-            if (is == null) {
-                throw new IOException("Couldn't find: " + name + suffix);
-            }
-            dis = new DataInputStream(is);
-            byte[] bytes = new byte[is.available()];
-            dis.readFully(bytes);
-            return bytes;
-        } finally {
-            if (dis != null) {
-                dis.close();
-            }
-        }
-    }
+    
 
 
-    /**
-     * @return byte array for class
-     */
-    public byte[] getBytes( String name ) throws IOException {
-        return getBytes(name, ".class");
-    }
+    
 
 
-    /**
-     * @param name name of file to search for, e.g. java/lang/String.java
-     * @return full (canonical) path for file
-     */
-    public String getPath( String name ) throws IOException {
-        int index = name.lastIndexOf('.');
-        String suffix = "";
-        if (index > 0) {
-            suffix = name.substring(index);
-            name = name.substring(0, index);
-        }
-        return getPath(name, suffix);
-    }
+    
 
 
-    /**
-     * @param name name of file to search for, e.g. java/lang/String
-     * @param suffix file name suffix, e.g. .java
-     * @return full (canonical) path for file, if it exists
-     */
-    public String getPath( String name, String suffix ) throws IOException {
-        return getClassFile(name, suffix).getPath();
-    }
+    
 
     private static abstract class PathEntry implements Serializable {
 
@@ -330,25 +238,16 @@ public class ClassPath implements Serializable {
         public abstract InputStream getInputStream() throws IOException;
 
 
-        /** @return canonical path to class file.
-         */
-        public abstract String getPath();
+        
 
 
-        /** @return base path of found class, i.e. class is contained relative
-         * to that path, which may either denote a directory, or zip file
-         */
-        public abstract String getBase();
+        
 
 
-        /** @return modification time of class file.
-         */
-        public abstract long getTime();
+        
 
 
-        /** @return size of class file.
-         */
-        public abstract long getSize();
+        
     }
 
     private static class Dir extends PathEntry {
@@ -388,30 +287,6 @@ public class ClassPath implements Serializable {
                 public InputStream getInputStream() throws IOException {
                     return new FileInputStream(file);
                 }
-
-
-                public String getPath() {
-                    try {
-                        return file.getCanonicalPath();
-                    } catch (IOException e) {
-                        return null;
-                    }
-                }
-
-
-                public long getTime() {
-                    return file.lastModified();
-                }
-
-
-                public long getSize() {
-                    return file.length();
-                }
-
-
-                public String getBase() {
-                    return dir;
-                }
             } : null;
         }
 
@@ -459,26 +334,6 @@ public class ClassPath implements Serializable {
                 public InputStream getInputStream() throws IOException {
                     return zip.getInputStream(entry);
                 }
-
-
-                public String getPath() {
-                    return entry.toString();
-                }
-
-
-                public long getTime() {
-                    return entry.getTime();
-                }
-
-
-                public long getSize() {
-                    return entry.getSize();
-                }
-
-
-                public String getBase() {
-                    return zip.getName();
-                }
             };
         }
     }

==================================================
SyntheticRepository.java
index 47484eec54..2e38ab58b9 100644
--- a/java/org/apache/tomcat/util/bcel/util/Repository.java
+++ b/java/org/apache/tomcat/util/bcel/util/Repository.java
@@ -36,10 +36,7 @@ public interface Repository extends java.io.Serializable {
     public void storeClass( JavaClass clazz );
 
 
-    /**
-     * Remove class from repository
-     */
-    public void removeClass( JavaClass clazz );
+    
 
 
     /**
@@ -56,18 +53,11 @@ public interface Repository extends java.io.Serializable {
     public JavaClass loadClass( String className ) throws java.lang.ClassNotFoundException;
 
 
-    /**
-     * Find the JavaClass instance for the given run-time class object
-     */
-    public JavaClass loadClass( Class clazz ) throws java.lang.ClassNotFoundException;
+    
 
 
-    /** Clear all entries from cache.
-     */
-    public void clear();
+    
 
 
-    /** Get the ClassPath associated with this Repository
-     */
-    public ClassPath getClassPath();
+    
 }

==================================================
