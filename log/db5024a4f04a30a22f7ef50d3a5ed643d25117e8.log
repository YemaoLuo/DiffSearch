db5024a4f04a30a22f7ef50d3a5ed643d25117e8
==================================================
Correct props.
==================================================
Mark Emlyn
==================================================
Tue Oct 24 03:17:11 2006 +0000
==================================================
AnnotationProcessor.java
index f0ca8d2000..13e89208df 100644
--- a/java/javax/servlet/resources/datatypes.dtd
+++ b/java/javax/servlet/resources/datatypes.dtd
@@ -16,7 +16,7 @@
 -->
 <!--
         DTD for XML Schemas: Part 2: Datatypes
-        $Id: datatypes.dtd 267129 2004-03-18 16:40:35Z jfarcand $
+        $Id$
         Note this DTD is NOT normative, or even definitive. - - the
         prose copy in the datatypes REC is the definitive version
         (which shouldn't differ from this one except for this comment

==================================================
Authenticator.java
index d7af22aeca..97f9475c04 100644
--- a/java/org/apache/AnnotationProcessor.java
+++ b/java/org/apache/AnnotationProcessor.java
@@ -25,7 +25,7 @@ import javax.naming.NamingException;
  * Comment
  *
  * @author <a href="mailto:bill@jboss.org">Bill Burke</a>
- * @version $Revision: 1.17 $
+ * @version $Revision$
  */
 public interface AnnotationProcessor {
     public void postConstruct(Object instance)

==================================================
Cluster.java
index 5877a997bd..96f60705ea 100644
--- a/java/org/apache/catalina/Authenticator.java
+++ b/java/org/apache/catalina/Authenticator.java
@@ -27,7 +27,7 @@ package org.apache.catalina;
  * of an already configured authentication service.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public interface Authenticator {

==================================================
Contained.java
index 7755415eaf..6b33c86e37 100644
--- a/java/org/apache/catalina/Cluster.java
+++ b/java/org/apache/catalina/Cluster.java
@@ -31,7 +31,7 @@ import java.net.URL;
  * @author Bip Thelin
  * @author Remy Maucherat
  * @author Filip Hanik
- * @version $Revision: 303857 $, $Date: 2005-04-15 22:15:45 +0200 (ven., 15 avr. 2005) $
+ * @version $Revision$, $Date$
  */
 
 public interface Cluster {

==================================================
Container.java
index 697f5ff6b8..a67a672204 100644
--- a/java/org/apache/catalina/Contained.java
+++ b/java/org/apache/catalina/Contained.java
@@ -25,7 +25,7 @@ package org.apache.catalina;
  *
  * @author Craig R. McClanahan
  * @author Peter Donald
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public interface Contained {

==================================================
ContainerEvent.java
index 05cf61a1cd..04a73b33fc 100644
--- a/java/org/apache/catalina/Container.java
+++ b/java/org/apache/catalina/Container.java
@@ -78,7 +78,7 @@ import org.apache.juli.logging.Log;
  *
  * @author Craig R. McClanahan
  * @author Remy Maucherat
- * @version $Revision: 303037 $ $Date: 2004-07-27 09:17:21 +0200 (mar., 27 juil. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public interface Container {

==================================================
ContainerListener.java
index 5533a06bdb..998021c7c1 100644
--- a/java/org/apache/catalina/ContainerEvent.java
+++ b/java/org/apache/catalina/ContainerEvent.java
@@ -26,7 +26,7 @@ import java.util.EventObject;
  * General event for notifying listeners of significant changes on a Container.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public final class ContainerEvent

==================================================
ContainerServlet.java
index e83dba4837..e9402b19ce 100644
--- a/java/org/apache/catalina/ContainerListener.java
+++ b/java/org/apache/catalina/ContainerListener.java
@@ -27,7 +27,7 @@ package org.apache.catalina;
  * LifecycleEvents, not ContainerEvents.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public interface ContainerListener {

==================================================
Context.java
index 9419365fd6..1fe3affad7 100644
--- a/java/org/apache/catalina/ContainerServlet.java
+++ b/java/org/apache/catalina/ContainerServlet.java
@@ -27,7 +27,7 @@ package org.apache.catalina;
  * this servlet is put into service.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public interface ContainerServlet {

==================================================
Engine.java
index d64b7893df..7a4096caba 100644
--- a/java/org/apache/catalina/Context.java
+++ b/java/org/apache/catalina/Context.java
@@ -50,7 +50,7 @@ import org.apache.catalina.util.CharsetMapper;
  * <p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303431 $ $Date: 2004-10-26 17:42:05 +0200 (mar., 26 oct. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public interface Context extends Container {

==================================================
Globals.java
index 393bb5543b..2e845d1cf0 100644
--- a/java/org/apache/catalina/Engine.java
+++ b/java/org/apache/catalina/Engine.java
@@ -41,7 +41,7 @@ package org.apache.catalina;
  * should throw <code>IllegalArgumentException</code>.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303092 $ $Date: 2004-08-16 11:31:09 +0200 (lun., 16 août 2004) $
+ * @version $Revision$ $Date$
  */
 
 public interface Engine extends Container {

==================================================
Group.java
index d3fe5754ea..dc89b4efc4 100644
--- a/java/org/apache/catalina/Globals.java
+++ b/java/org/apache/catalina/Globals.java
@@ -23,7 +23,7 @@ package org.apache.catalina;
  * Global constants that are applicable to multiple packages within Catalina.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303495 $ $Date: 2004-11-19 07:07:56 +0100 (ven., 19 nov. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public final class Globals {

==================================================
Host.java
index a50b4d84cf..fb3ff93520 100644
--- a/java/org/apache/catalina/Group.java
+++ b/java/org/apache/catalina/Group.java
@@ -29,7 +29,7 @@ import java.util.Iterator;
  * inherits the {@link Role}s assigned to the group.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  * @since 4.1
  */
 

==================================================
InstanceEvent.java
index e183453144..0ad833c86b 100644
--- a/java/org/apache/catalina/Host.java
+++ b/java/org/apache/catalina/Host.java
@@ -41,7 +41,7 @@ package org.apache.catalina;
  * of Context (representing an individual servlet context).
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303092 $ $Date: 2004-08-16 11:31:09 +0200 (lun., 16 août 2004) $
+ * @version $Revision$ $Date$
  */
 
 public interface Host extends Container {

==================================================
InstanceListener.java
index 3c814455ac..1fe6a6fef1 100644
--- a/java/org/apache/catalina/InstanceEvent.java
+++ b/java/org/apache/catalina/InstanceEvent.java
@@ -32,7 +32,7 @@ import javax.servlet.ServletResponse;
  * as opposed to the Wrapper component that manages it.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public final class InstanceEvent

==================================================
Lifecycle.java
index a545bd5f57..d9062d9906 100644
--- a/java/org/apache/catalina/InstanceListener.java
+++ b/java/org/apache/catalina/InstanceListener.java
@@ -25,7 +25,7 @@ package org.apache.catalina;
  * is managing that instance.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public interface InstanceListener {

==================================================
LifecycleEvent.java
index 73f07b2d3b..a549f3ed26 100644
--- a/java/org/apache/catalina/Lifecycle.java
+++ b/java/org/apache/catalina/Lifecycle.java
@@ -26,7 +26,7 @@ package org.apache.catalina;
  * provide a consistent mechanism to start and stop the component.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303352 $ $Date: 2004-10-05 19:12:52 +0200 (mar., 05 oct. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public interface Lifecycle {

==================================================
LifecycleException.java
index bd73ffc7c0..9364cf1e87 100644
--- a/java/org/apache/catalina/LifecycleEvent.java
+++ b/java/org/apache/catalina/LifecycleEvent.java
@@ -29,7 +29,7 @@ import java.util.EventObject;
  * Tomcat 3.x.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public final class LifecycleEvent

==================================================
LifecycleListener.java
index 7801b66b3a..3af7585d75 100644
--- a/java/org/apache/catalina/LifecycleException.java
+++ b/java/org/apache/catalina/LifecycleException.java
@@ -25,7 +25,7 @@ package org.apache.catalina;
  * operation of the application containing this component.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public final class LifecycleException extends Exception {

==================================================
Loader.java
index a61372c152..3bdc677448 100644
--- a/java/org/apache/catalina/LifecycleListener.java
+++ b/java/org/apache/catalina/LifecycleListener.java
@@ -27,7 +27,7 @@ package org.apache.catalina;
  * Lifecycle interface.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public interface LifecycleListener {

==================================================
Manager.java
index 28b30d93e8..46d685350a 100644
--- a/java/org/apache/catalina/Loader.java
+++ b/java/org/apache/catalina/Loader.java
@@ -50,7 +50,7 @@ import java.beans.PropertyChangeListener;
  * </ul>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303352 $ $Date: 2004-10-05 19:12:52 +0200 (mar., 05 oct. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public interface Loader {

==================================================
Pipeline.java
index 52a3901436..8c214ca832 100644
--- a/java/org/apache/catalina/Manager.java
+++ b/java/org/apache/catalina/Manager.java
@@ -40,7 +40,7 @@ import java.io.IOException;
  * </ul>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303682 $ $Date: 2005-02-07 22:56:32 +0100 (lun., 07 févr. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public interface Manager {

==================================================
Realm.java
index f7f8e6ca48..beb8fed51e 100644
--- a/java/org/apache/catalina/Pipeline.java
+++ b/java/org/apache/catalina/Pipeline.java
@@ -36,7 +36,7 @@ package org.apache.catalina;
  *
  * @author Craig R. McClanahan
  * @author Peter Donald
- * @version $Revision: 302978 $ $Date: 2004-06-23 18:59:42 +0200 (mer., 23 juin 2004) $
+ * @version $Revision$ $Date$
  */
 
 public interface Pipeline {

==================================================
Role.java
index 37ec06832b..6e5fa3701d 100644
--- a/java/org/apache/catalina/Realm.java
+++ b/java/org/apache/catalina/Realm.java
@@ -34,7 +34,7 @@ import org.apache.catalina.deploy.SecurityConstraint;
  * Container.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303352 $ $Date: 2004-10-05 19:12:52 +0200 (mar., 05 oct. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public interface Realm {

==================================================
Server.java
index 08cc6ce762..eddd0afaba 100644
--- a/java/org/apache/catalina/Role.java
+++ b/java/org/apache/catalina/Role.java
@@ -27,7 +27,7 @@ import java.security.Principal;
  * environments like JAAS that want to deal with <code>Principals</code>.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  * @since 4.1
  */
 

==================================================
ServerFactory.java
index 547a7b2ae6..014f6fd637 100644
--- a/java/org/apache/catalina/Server.java
+++ b/java/org/apache/catalina/Server.java
@@ -42,7 +42,7 @@ import org.apache.catalina.deploy.NamingResources;
  * class in its constructor(s).
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302899 $ $Date: 2004-05-26 17:29:30 +0200 (mer., 26 mai 2004) $
+ * @version $Revision$ $Date$
  */
 
 public interface Server {

==================================================
Service.java
index f2fb382800..be1e398d2f 100644
--- a/java/org/apache/catalina/ServerFactory.java
+++ b/java/org/apache/catalina/ServerFactory.java
@@ -29,7 +29,7 @@ import org.apache.catalina.core.StandardServer;
  * that are built around the internal component implementation classes.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class ServerFactory {

==================================================
Session.java
index bcb9639e8d..a8e8d6af3f 100644
--- a/java/org/apache/catalina/Service.java
+++ b/java/org/apache/catalina/Service.java
@@ -32,7 +32,7 @@ import org.apache.catalina.connector.Connector;
  * and classes on the system class path.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302975 $ $Date: 2004-06-23 10:25:04 +0200 (mer., 23 juin 2004) $
+ * @version $Revision$ $Date$
  */
 
 public interface Service {

==================================================
SessionEvent.java
index c55e9338fb..610084cc32 100644
--- a/java/org/apache/catalina/Session.java
+++ b/java/org/apache/catalina/Session.java
@@ -31,7 +31,7 @@ import javax.servlet.http.HttpSession;
  * between requests for a particular user of a web application.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 384817 $ $Date: 2006-03-10 16:27:43 +0100 (ven., 10 mars 2006) $
+ * @version $Revision$ $Date$
  */
 
 public interface Session {

==================================================
SessionListener.java
index e65c585ec3..69eea43fa9 100644
--- a/java/org/apache/catalina/SessionEvent.java
+++ b/java/org/apache/catalina/SessionEvent.java
@@ -26,7 +26,7 @@ import java.util.EventObject;
  * General event for notifying listeners of significant changes on a Session.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public final class SessionEvent

==================================================
Store.java
index dd7d07c75a..33272503b4 100644
--- a/java/org/apache/catalina/SessionListener.java
+++ b/java/org/apache/catalina/SessionListener.java
@@ -25,7 +25,7 @@ package org.apache.catalina;
  * Interface defining a listener for significant Session generated events.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public interface SessionListener {

==================================================
User.java
index 25334257bb..a9ddab0c35 100644
--- a/java/org/apache/catalina/Store.java
+++ b/java/org/apache/catalina/Store.java
@@ -31,7 +31,7 @@ import java.io.IOException;
  * server or context restarts.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public interface Store {

==================================================
UserDatabase.java
index 86b703d324..b6c48bd7cf 100644
--- a/java/org/apache/catalina/User.java
+++ b/java/org/apache/catalina/User.java
@@ -30,7 +30,7 @@ import java.util.Iterator;
  * of specific {@link Role}s.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  * @since 4.1
  */
 

==================================================
Valve.java
index e377a6d451..461ac518ff 100644
--- a/java/org/apache/catalina/UserDatabase.java
+++ b/java/org/apache/catalina/UserDatabase.java
@@ -29,7 +29,7 @@ import java.util.Iterator;
  * referenced by a {@link Realm} for authentication and access control.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  * @since 4.1
  */
 

==================================================
Wrapper.java
index 72f9656e9d..c31965784e 100644
--- a/java/org/apache/catalina/Valve.java
+++ b/java/org/apache/catalina/Valve.java
@@ -39,7 +39,7 @@ import org.apache.catalina.connector.Response;
  * @author Craig R. McClanahan
  * @author Gunnar Rjnning
  * @author Peter Donald
- * @version $Revision: 303352 $ $Date: 2004-10-05 19:12:52 +0200 (mar., 05 oct. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public interface Valve {

==================================================
AbstractCatalinaTask.java
index e6505052d2..a795dfe8cc 100644
--- a/java/org/apache/catalina/Wrapper.java
+++ b/java/org/apache/catalina/Wrapper.java
@@ -44,7 +44,7 @@ import javax.servlet.UnavailableException;
  * <code>IllegalArgumentException</code>.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303442 $ $Date: 2004-10-28 00:58:17 +0200 (jeu., 28 oct. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public interface Wrapper extends Container {

==================================================
BaseRedirectorHelperTask.java
index 332f514474..fa579c1bb5 100644
--- a/java/org/apache/catalina/ant/AbstractCatalinaTask.java
+++ b/java/org/apache/catalina/ant/AbstractCatalinaTask.java
@@ -36,7 +36,7 @@ import org.apache.tools.ant.Project;
  * undeploying applications.  These tasks require Ant 1.4 or later.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303657 $ $Date: 2005-01-22 17:34:47 +0100 (sam., 22 janv. 2005) $
+ * @version $Revision$ $Date$
  * @since 4.1
  */
 

==================================================
DeployTask.java
index 11fb0a1cbc..ddab137992 100644
--- a/java/org/apache/catalina/ant/BaseRedirectorHelperTask.java
+++ b/java/org/apache/catalina/ant/BaseRedirectorHelperTask.java
@@ -46,7 +46,7 @@ import org.apache.tools.ant.types.RedirectorElement;
  * 
  *
  * @author Gabriele Garuglieri
- * @version $Revision: 303609 $ $Date: 2005-01-03 17:21:21 +0100 (lun., 03 janv. 2005) $
+ * @version $Revision$ $Date$
  * @since 5.5
  */
 

==================================================
InstallTask.java
index 4c9beac89b..8eb11ec1d7 100644
--- a/java/org/apache/catalina/ant/DeployTask.java
+++ b/java/org/apache/catalina/ant/DeployTask.java
@@ -35,7 +35,7 @@ import org.apache.tools.ant.BuildException;
  * the Tomcat manager application.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303657 $ $Date: 2005-01-22 17:34:47 +0100 (sam., 22 janv. 2005) $
+ * @version $Revision$ $Date$
  * @since 4.1
  */
 public class DeployTask extends AbstractCatalinaTask {

==================================================
JKStatusUpdateTask.java
index 8e9d705bd6..dd13c00087 100644
--- a/java/org/apache/catalina/ant/InstallTask.java
+++ b/java/org/apache/catalina/ant/InstallTask.java
@@ -29,7 +29,7 @@ import org.apache.tools.ant.BuildException;
  * Tomcat manager application.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  * @since 4.1
  * @deprecated Replaced by DeployTask
  */

==================================================
JMXGetTask.java
index 55e2b92a3a..a0f5e05bdf 100644
--- a/java/org/apache/catalina/ant/JKStatusUpdateTask.java
+++ b/java/org/apache/catalina/ant/JKStatusUpdateTask.java
@@ -27,7 +27,7 @@ import org.apache.tools.ant.BuildException;
  * mod_jk status (1.2.9) application.
  * 
  * @author Peter Rossbach
- * @version $Revision: 303886 $
+ * @version $Revision$
  * @since 5.5.9
  */
 public class JKStatusUpdateTask extends AbstractCatalinaTask {

==================================================
JMXQueryTask.java
index 23cbd91e48..064a7c0f8b 100644
--- a/java/org/apache/catalina/ant/JMXGetTask.java
+++ b/java/org/apache/catalina/ant/JMXGetTask.java
@@ -27,7 +27,7 @@ import org.apache.tools.ant.BuildException;
  * supported by the Tomcat manager application.
  *
  * @author Peter Rossbach
- * @version $Revision: 303880 $
+ * @version $Revision$
  */
 public class JMXGetTask extends AbstractCatalinaTask {
 

==================================================
JMXSetTask.java
index fdb6e9ac29..ceb89bfc82 100644
--- a/java/org/apache/catalina/ant/JMXQueryTask.java
+++ b/java/org/apache/catalina/ant/JMXQueryTask.java
@@ -27,7 +27,7 @@ import org.apache.tools.ant.BuildException;
  * (<code>/jmxproxy/?qry</code>) supported by the Tomcat manager application.
  *
  * @author Vivek Chopra
- * @version $Revision: 303236 $
+ * @version $Revision$
  */
 public class JMXQueryTask extends AbstractCatalinaTask {
 

==================================================
ListTask.java
index c286f85f45..5bab49bd08 100644
--- a/java/org/apache/catalina/ant/JMXSetTask.java
+++ b/java/org/apache/catalina/ant/JMXSetTask.java
@@ -27,7 +27,7 @@ import org.apache.tools.ant.BuildException;
  * supported by the Tomcat manager application.
  *
  * @author Vivek Chopra
- * @version $Revision: 303236 $
+ * @version $Revision$
  */
 public class JMXSetTask extends AbstractCatalinaTask {
 

==================================================
ReloadTask.java
index 778fcebbce..bc3dfdf737 100644
--- a/java/org/apache/catalina/ant/ListTask.java
+++ b/java/org/apache/catalina/ant/ListTask.java
@@ -27,7 +27,7 @@ import org.apache.tools.ant.BuildException;
  * Tomcat manager application.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  * @since 4.1
  */
 public class ListTask extends AbstractCatalinaTask {

==================================================
RemoveTask.java
index 2543e8d131..75e21a6564 100644
--- a/java/org/apache/catalina/ant/ReloadTask.java
+++ b/java/org/apache/catalina/ant/ReloadTask.java
@@ -30,7 +30,7 @@ import org.apache.tools.ant.BuildException;
  * Tomcat manager application.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303657 $ $Date: 2005-01-22 17:34:47 +0100 (sam., 22 janv. 2005) $
+ * @version $Revision$ $Date$
  * @since 4.1
  */
 public class ReloadTask extends AbstractCatalinaTask {

==================================================
ResourcesTask.java
index ed8416c507..5eb9395669 100644
--- a/java/org/apache/catalina/ant/RemoveTask.java
+++ b/java/org/apache/catalina/ant/RemoveTask.java
@@ -29,7 +29,7 @@ import org.apache.tools.ant.BuildException;
  * Tomcat manager application.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  * @deprecated Replaced by UndeployTask
  */
 public class RemoveTask extends AbstractCatalinaTask {

==================================================
RolesTask.java
index cd1ce568ad..76cbb5422d 100644
--- a/java/org/apache/catalina/ant/ResourcesTask.java
+++ b/java/org/apache/catalina/ant/ResourcesTask.java
@@ -27,7 +27,7 @@ import org.apache.tools.ant.BuildException;
  * the Tomcat manager application.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  * @since 4.1
  */
 public class ResourcesTask extends AbstractCatalinaTask {

==================================================
ServerinfoTask.java
index c96fa8da5c..4041e1089c 100644
--- a/java/org/apache/catalina/ant/RolesTask.java
+++ b/java/org/apache/catalina/ant/RolesTask.java
@@ -27,7 +27,7 @@ import org.apache.tools.ant.BuildException;
  * Tomcat manager application.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  * @since 4.1
  */
 public class RolesTask extends AbstractCatalinaTask {

==================================================
SessionsTask.java
index 3381789955..352fdf88c7 100644
--- a/java/org/apache/catalina/ant/ServerinfoTask.java
+++ b/java/org/apache/catalina/ant/ServerinfoTask.java
@@ -27,7 +27,7 @@ import org.apache.tools.ant.BuildException;
  * supported by the Tomcat manager application.
  *
  * @author Vivek Chopra
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 public class ServerinfoTask extends AbstractCatalinaTask {
 

==================================================
StartTask.java
index bdd438a128..3e615d336c 100644
--- a/java/org/apache/catalina/ant/SessionsTask.java
+++ b/java/org/apache/catalina/ant/SessionsTask.java
@@ -30,7 +30,7 @@ import org.apache.tools.ant.BuildException;
  * supported by the Tomcat manager application.
  *
  * @author Vivek Chopra
- * @version $Revision: 303657 $
+ * @version $Revision$
  */
 public class SessionsTask extends AbstractCatalinaTask {
 

==================================================
StopTask.java
index 271e5a9cc1..260ea167ce 100644
--- a/java/org/apache/catalina/ant/StartTask.java
+++ b/java/org/apache/catalina/ant/StartTask.java
@@ -30,7 +30,7 @@ import org.apache.tools.ant.BuildException;
  * Tomcat manager application.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303657 $ $Date: 2005-01-22 17:34:47 +0100 (sam., 22 janv. 2005) $
+ * @version $Revision$ $Date$
  * @since 4.1
  */
 public class StartTask extends AbstractCatalinaTask {

==================================================
UndeployTask.java
index f1421d9d5a..959331c1e6 100644
--- a/java/org/apache/catalina/ant/StopTask.java
+++ b/java/org/apache/catalina/ant/StopTask.java
@@ -30,7 +30,7 @@ import org.apache.tools.ant.BuildException;
  * Tomcat manager application.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303657 $ $Date: 2005-01-22 17:34:47 +0100 (sam., 22 janv. 2005) $
+ * @version $Revision$ $Date$
  * @since 4.1
  */
 public class StopTask extends AbstractCatalinaTask {

==================================================
ValidatorTask.java
index a09c5e191b..2c0b81a876 100644
--- a/java/org/apache/catalina/ant/UndeployTask.java
+++ b/java/org/apache/catalina/ant/UndeployTask.java
@@ -27,7 +27,7 @@ import org.apache.tools.ant.BuildException;
  * the Tomcat manager application.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303609 $ $Date: 2005-01-03 17:21:21 +0100 (lun., 03 janv. 2005) $
+ * @version $Revision$ $Date$
  * @since 4.1
  */
 public class UndeployTask extends AbstractCatalinaTask {

==================================================
Arg.java
index 04e316650b..703c2e8842 100644
--- a/java/org/apache/catalina/ant/catalina.tasks
+++ b/java/org/apache/catalina/ant/catalina.tasks
@@ -1,23 +1,23 @@
-# Pure catalina tasks
-deploy=org.apache.catalina.ant.DeployTask
-list=org.apache.catalina.ant.ListTask
-reload=org.apache.catalina.ant.ReloadTask
-sessions=org.apache.catalina.ant.SessionsTask
-resources=org.apache.catalina.ant.ResourcesTask
-roles=org.apache.catalina.ant.RolesTask
-start=org.apache.catalina.ant.StartTask
-stop=org.apache.catalina.ant.StopTask
-undeploy=org.apache.catalina.ant.UndeployTask
-validator=org.apache.catalina.ant.ValidatorTask
-
-#Jk Task
-jkstatus=org.apache.catalina.ant.JKStatusUpdateTask
-
-# Manager JMX
-jmxManagerSet=org.apache.catalina.ant.JMXSetTask
-jmxManagerGet=org.apache.catalina.ant.JMXGetTask
-jmxManagerQuery=org.apache.catalina.ant.JMXQueryTask
-
-# Jasper tasks
-jasper=org.apache.jasper.JspC
-jasper2=org.apache.jasper.JspC
+# Pure catalina tasks
+deploy=org.apache.catalina.ant.DeployTask
+list=org.apache.catalina.ant.ListTask
+reload=org.apache.catalina.ant.ReloadTask
+sessions=org.apache.catalina.ant.SessionsTask
+resources=org.apache.catalina.ant.ResourcesTask
+roles=org.apache.catalina.ant.RolesTask
+start=org.apache.catalina.ant.StartTask
+stop=org.apache.catalina.ant.StopTask
+undeploy=org.apache.catalina.ant.UndeployTask
+validator=org.apache.catalina.ant.ValidatorTask
+
+#Jk Task
+jkstatus=org.apache.catalina.ant.JKStatusUpdateTask
+
+# Manager JMX
+jmxManagerSet=org.apache.catalina.ant.JMXSetTask
+jmxManagerGet=org.apache.catalina.ant.JMXGetTask
+jmxManagerQuery=org.apache.catalina.ant.JMXQueryTask
+
+# Jasper tasks
+jasper=org.apache.jasper.JspC
+jasper2=org.apache.jasper.JspC

==================================================
JMXAccessorCondition.java
index 57003da2c3..e5c4a8d1be 100644
--- a/java/org/apache/catalina/ant/jmx/Arg.java
+++ b/java/org/apache/catalina/ant/jmx/Arg.java
@@ -20,7 +20,7 @@ package org.apache.catalina.ant.jmx;
 /**
  *
  * @author Peter Rossbach
- * @version $Revision: 303958 $ $Date: 2005-06-24 13:53:42 +0200 (ven., 24 juin 2005) $
+ * @version $Revision$ $Date$
  * @since 5.5.10
  */
 public class Arg {

==================================================
JMXAccessorCreateTask.java
index 8ccb921c41..4c3ded3b05 100644
--- a/java/org/apache/catalina/ant/jmx/JMXAccessorCondition.java
+++ b/java/org/apache/catalina/ant/jmx/JMXAccessorCondition.java
@@ -86,7 +86,7 @@ import org.apache.tools.ant.taskdefs.condition.Condition;
  * <b>NOTE</b>:  For numeric expressions the type must be set and use xml entities as operations.<br/>
  * As type we currently support <em>long</em> and <em>double</em>.
  * @author Peter Rossbach
- * @version $Revision: 304032 $ $Date: 2005-07-27 17:11:55 +0200 (mer., 27 juil. 2005) $
+ * @version $Revision$ $Date$
  * @since 5.5.10
  *
  */

==================================================
JMXAccessorEqualsCondition.java
index 5c26230340..78861a0898 100644
--- a/java/org/apache/catalina/ant/jmx/JMXAccessorCreateTask.java
+++ b/java/org/apache/catalina/ant/jmx/JMXAccessorCreateTask.java
@@ -55,7 +55,7 @@ import org.apache.tools.ant.BuildException;
  * These tasks require Ant 1.6 or later interface.
  *
  * @author Peter Rossbach
- * @version $Revision: 304089 $
+ * @version $Revision$
  * @since 5.5.12
  */
 public class JMXAccessorCreateTask extends JMXAccessorTask {

==================================================
JMXAccessorGetTask.java
index fe39bab84e..4913767650 100644
--- a/java/org/apache/catalina/ant/jmx/JMXAccessorEqualsCondition.java
+++ b/java/org/apache/catalina/ant/jmx/JMXAccessorEqualsCondition.java
@@ -65,7 +65,7 @@ import org.apache.tools.ant.taskdefs.condition.Condition;
  * </pre>
  * 
  * @author Peter Rossbach
- * @version $Revision: 304032 $ $Date: 2005-07-27 17:11:55 +0200 (mer., 27 juil. 2005) $
+ * @version $Revision$ $Date$
  * @since 5.5.10
  *
  */

==================================================
JMXAccessorInvokeTask.java
index cfa7863ecd..9fd0d605d0 100644
--- a/java/org/apache/catalina/ant/jmx/JMXAccessorGetTask.java
+++ b/java/org/apache/catalina/ant/jmx/JMXAccessorGetTask.java
@@ -52,7 +52,7 @@ import org.apache.tools.ant.BuildException;
  * These tasks require Ant 1.6 or later interface.
  *
  * @author Peter Rossbach
- * @version $Revision: 304032 $ $Date: 2005-07-27 17:11:55 +0200 (mer., 27 juil. 2005) $
+ * @version $Revision$ $Date$
  * @since 5.5.10
  */
 

==================================================
JMXAccessorQueryTask.java
index 982c6a0b51..277753d2f4 100644
--- a/java/org/apache/catalina/ant/jmx/JMXAccessorInvokeTask.java
+++ b/java/org/apache/catalina/ant/jmx/JMXAccessorInvokeTask.java
@@ -87,7 +87,7 @@ import org.apache.tools.ant.BuildException;
  * These tasks require Ant 1.6 or later interface.
  *
  * @author Peter Rossbach
- * @version $Revision: 304013 $ $Date: 2005-07-22 13:39:08 +0200 (ven., 22 juil. 2005) $
+ * @version $Revision$ $Date$
  * @since 5.5.10
  */
 

==================================================
JMXAccessorSetTask.java
index 9ac9bcfebb..1c292bbedc 100644
--- a/java/org/apache/catalina/ant/jmx/JMXAccessorQueryTask.java
+++ b/java/org/apache/catalina/ant/jmx/JMXAccessorQueryTask.java
@@ -56,7 +56,7 @@ import org.apache.tools.ant.BuildException;
  * These tasks require Ant 1.6 or later interface.
  *
  * @author Peter Rossbach
- * @version $Revision: 304089 $ $Date: 2005-09-14 15:28:29 +0200 (mer., 14 sept. 2005) $
+ * @version $Revision$ $Date$
  * @since 5.5.10
  */
 

==================================================
JMXAccessorTask.java
index 2e888e7bc0..0e40d26494 100644
--- a/java/org/apache/catalina/ant/jmx/JMXAccessorSetTask.java
+++ b/java/org/apache/catalina/ant/jmx/JMXAccessorSetTask.java
@@ -58,7 +58,7 @@ import org.apache.tools.ant.BuildException;
  * These tasks require Ant 1.6 or later interface.
  *
  * @author Peter Rossbach
- * @version $Revision: 304089 $ $Date: 2005-09-14 15:28:29 +0200 (mer., 14 sept. 2005) $
+ * @version $Revision$ $Date$
  * @since 5.5.10
  */
 

==================================================
JMXAccessorUnregisterTask.java
index b701f49cc6..a6d560d031 100644
--- a/java/org/apache/catalina/ant/jmx/JMXAccessorTask.java
+++ b/java/org/apache/catalina/ant/jmx/JMXAccessorTask.java
@@ -85,7 +85,7 @@ import org.apache.tools.ant.Project;
  * </b>: These tasks require Ant 1.6 or later interface.
  * 
  * @author Peter Rossbach
- * @version $Revision: 304089 $ $Date: 2005-09-14 15:28:29 +0200 (mer., 14 sept. 2005) $
+ * @version $Revision$ $Date$
  * @since 5.5.10
  */
 

==================================================
AuthenticatorBase.java
index 2eee6dd7dc..797e89e34c 100644
--- a/java/org/apache/catalina/ant/jmx/jmxaccessor.tasks
+++ b/java/org/apache/catalina/ant/jmx/jmxaccessor.tasks
@@ -1,8 +1,8 @@
-# JMX
-jmxOpen=org.apache.catalina.ant.jmx.JMXAccessorTask
-jmxSet=org.apache.catalina.ant.jmx.JMXAccessorSetTask
-jmxGet=org.apache.catalina.ant.jmx.JMXAccessorGetTask
-jmxInvoke=org.apache.catalina.ant.jmx.JMXAccessorInvokeTask
-jmxQuery=org.apache.catalina.ant.jmx.JMXAccessorQueryTask
-jmxCreate=org.apache.catalina.ant.jmx.JMXAccessorCreateTask
-jmxUnregister=org.apache.catalina.ant.jmx.JMXAccessorUnregisterTask
+# JMX
+jmxOpen=org.apache.catalina.ant.jmx.JMXAccessorTask
+jmxSet=org.apache.catalina.ant.jmx.JMXAccessorSetTask
+jmxGet=org.apache.catalina.ant.jmx.JMXAccessorGetTask
+jmxInvoke=org.apache.catalina.ant.jmx.JMXAccessorInvokeTask
+jmxQuery=org.apache.catalina.ant.jmx.JMXAccessorQueryTask
+jmxCreate=org.apache.catalina.ant.jmx.JMXAccessorCreateTask
+jmxUnregister=org.apache.catalina.ant.jmx.JMXAccessorUnregisterTask

==================================================
BasicAuthenticator.java
index a17672248e..572ec9ff5e 100644
--- a/java/org/apache/catalina/authenticator/AuthenticatorBase.java
+++ b/java/org/apache/catalina/authenticator/AuthenticatorBase.java
@@ -70,7 +70,7 @@ import org.apache.juli.logging.LogFactory;
  * requests.  Requests of any other type will simply be passed through.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 357143 $ $Date: 2005-12-16 09:13:19 +0100 (ven., 16 déc. 2005) $
+ * @version $Revision$ $Date$
  */
 
 

==================================================
DigestAuthenticator.java
index 5b08802dc5..643cfd327a 100644
--- a/java/org/apache/catalina/authenticator/BasicAuthenticator.java
+++ b/java/org/apache/catalina/authenticator/BasicAuthenticator.java
@@ -42,7 +42,7 @@ import org.apache.tomcat.util.buf.MessageBytes;
  * and Digest Access Authentication."
  *
  * @author Craig R. McClanahan
- * @version $Revision: 370985 $ $Date: 2006-01-21 06:21:15 +0100 (sam., 21 janv. 2006) $
+ * @version $Revision$ $Date$
  */
 
 public class BasicAuthenticator

==================================================
FormAuthenticator.java
index 5004043194..b62984574b 100644
--- a/java/org/apache/catalina/authenticator/DigestAuthenticator.java
+++ b/java/org/apache/catalina/authenticator/DigestAuthenticator.java
@@ -44,7 +44,7 @@ import org.apache.juli.logging.LogFactory;
  *
  * @author Craig R. McClanahan
  * @author Remy Maucherat
- * @version $Revision: 370985 $ $Date: 2006-01-21 06:21:15 +0100 (sam., 21 janv. 2006) $
+ * @version $Revision$ $Date$
  */
 
 public class DigestAuthenticator

==================================================
NonLoginAuthenticator.java
index fb9c5d5774..ed423d7dc2 100644
--- a/java/org/apache/catalina/authenticator/FormAuthenticator.java
+++ b/java/org/apache/catalina/authenticator/FormAuthenticator.java
@@ -50,7 +50,7 @@ import org.apache.tomcat.util.http.MimeHeaders;
  *
  * @author Craig R. McClanahan
  * @author Remy Maucherat
- * @version $Revision: 320670 $ $Date: 2005-10-13 07:39:55 +0200 (jeu., 13 oct. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class FormAuthenticator

==================================================
SSLAuthenticator.java
index 042f2ac55a..263838c7cd 100644
--- a/java/org/apache/catalina/authenticator/NonLoginAuthenticator.java
+++ b/java/org/apache/catalina/authenticator/NonLoginAuthenticator.java
@@ -32,7 +32,7 @@ import org.apache.catalina.deploy.LoginConfig;
  * only security constraints not involving user authentication.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303721 $ $Date: 2005-02-23 20:27:56 +0100 (mer., 23 févr. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public final class NonLoginAuthenticator

==================================================
SavedRequest.java
index 466f3ef11a..5c9a6665f4 100644
--- a/java/org/apache/catalina/authenticator/SSLAuthenticator.java
+++ b/java/org/apache/catalina/authenticator/SSLAuthenticator.java
@@ -39,7 +39,7 @@ import org.apache.catalina.deploy.LoginConfig;
  * that utilizes SSL certificates to identify client users.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303721 $ $Date: 2005-02-23 20:27:56 +0100 (mer., 23 févr. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class SSLAuthenticator

==================================================
SingleSignOn.java
index be32a26ede..6bc6cd72dd 100644
--- a/java/org/apache/catalina/authenticator/SavedRequest.java
+++ b/java/org/apache/catalina/authenticator/SavedRequest.java
@@ -39,7 +39,7 @@ import org.apache.tomcat.util.buf.ByteChunk;
  * internal collection classes is performed.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303925 $ $Date: 2005-05-11 23:39:41 +0200 (mer., 11 mai 2005) $
+ * @version $Revision$ $Date$
  */
 
 public final class SavedRequest {

==================================================
SingleSignOnEntry.java
index 4136e6a738..23200c8f8a 100644
--- a/java/org/apache/catalina/authenticator/SingleSignOn.java
+++ b/java/org/apache/catalina/authenticator/SingleSignOn.java
@@ -59,7 +59,7 @@ import org.apache.catalina.valves.ValveBase;
  * </ul>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 384817 $ $Date: 2006-03-10 16:27:43 +0100 (ven., 10 mars 2006) $
+ * @version $Revision$ $Date$
  */
 
 public class SingleSignOn

==================================================
ClientAbortException.java
index 924d29d895..7cf68acb2d 100644
--- a/java/org/apache/catalina/authenticator/SingleSignOnEntry.java
+++ b/java/org/apache/catalina/authenticator/SingleSignOnEntry.java
@@ -28,7 +28,7 @@ import org.apache.catalina.authenticator.Constants;
  * reauthentications when SingleSignOn is in use.
  *
  * @author  B Stansberry, based on work by Craig R. McClanahan
- * @version $Revision: 302885 $
+ * @version $Revision$
  *
  * @see SingleSignOn
  * @see AuthenticatorBase#reauthenticateFromSSO

==================================================
Connector.java
index 4786855fe2..d9af270e5e 100644
--- a/java/org/apache/catalina/connector/ClientAbortException.java
+++ b/java/org/apache/catalina/connector/ClientAbortException.java
@@ -25,7 +25,7 @@ import java.io.IOException;
  * of a request by a remote client.
  *
  * @author Glenn L. Nielsen
- * @version $Revision: 304063 $ $Date: 2005-08-18 15:25:18 +0200 (jeu., 18 août 2005) $
+ * @version $Revision$ $Date$
  */
 
 public final class ClientAbortException extends IOException {

==================================================
CoyoteAdapter.java
index fc9886b3ab..babc2f62c9 100644
--- a/java/org/apache/catalina/connector/Connector.java
+++ b/java/org/apache/catalina/connector/Connector.java
@@ -49,7 +49,7 @@ import org.apache.tomcat.util.modeler.Registry;
  *
  * @author Craig R. McClanahan
  * @author Remy Maucherat
- * @version $Revision: 349505 $ $Date: 2005-11-28 22:14:21 +0100 (lun., 28 nov. 2005) $
+ * @version $Revision$ $Date$
  */
 
 

==================================================
CoyotePrincipal.java
index 29844667ba..05ef81aa38 100644
--- a/java/org/apache/catalina/connector/CoyoteAdapter.java
+++ b/java/org/apache/catalina/connector/CoyoteAdapter.java
@@ -44,7 +44,7 @@ import org.apache.tomcat.util.net.SocketStatus;
  *
  * @author Craig R. McClanahan
  * @author Remy Maucherat
- * @version $Revision: 331249 $ $Date: 2005-11-07 10:57:55 +0100 (lun., 07 nov. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class CoyoteAdapter

==================================================
Request.java
index 08a3a98bdc..5e10900dae 100644
--- a/java/org/apache/catalina/connector/CoyotePrincipal.java
+++ b/java/org/apache/catalina/connector/CoyotePrincipal.java
@@ -25,7 +25,7 @@ import java.security.Principal;
  * is used to represent principals authenticated at the protocol handler level.
  *
  * @author Remy Maucherat
- * @version $Revision: 302975 $ $Date: 2004-06-23 10:25:04 +0200 (mer., 23 juin 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class CoyotePrincipal 

==================================================
RequestFacade.java
index 71018209ca..61e3de203a 100644
--- a/java/org/apache/catalina/connector/Request.java
+++ b/java/org/apache/catalina/connector/Request.java
@@ -77,7 +77,7 @@ import org.apache.catalina.util.StringParser;
  *
  * @author Remy Maucherat
  * @author Craig R. McClanahan
- * @version $Revision: 382659 $ $Date: 2006-03-03 06:01:16 +0100 (ven., 03 mars 2006) $
+ * @version $Revision$ $Date$
  */
 
 public class Request

==================================================
Response.java
index ec89e5fd58..783b968fcc 100644
--- a/java/org/apache/catalina/connector/RequestFacade.java
+++ b/java/org/apache/catalina/connector/RequestFacade.java
@@ -44,7 +44,7 @@ import org.apache.catalina.security.SecurityUtil;
  * @author Craig R. McClanahan
  * @author Remy Maucherat
  * @author Jean-Francois Arcand
- * @version $Revision: 303900 $ $Date: 2005-04-30 00:22:29 +0200 (sam., 30 avr. 2005) $
+ * @version $Revision$ $Date$
  */
 
 @SuppressWarnings("deprecation")

==================================================
ResponseFacade.java
index c305a0b6fb..d9c4bc81ec 100644
--- a/java/org/apache/catalina/connector/Response.java
+++ b/java/org/apache/catalina/connector/Response.java
@@ -58,7 +58,7 @@ import org.apache.tomcat.util.net.URL;
  *
  * @author Remy Maucherat
  * @author Craig R. McClanahan
- * @version $Revision: 371866 $ $Date: 2006-01-24 09:52:54 +0100 (mar., 24 janv. 2006) $
+ * @version $Revision$ $Date$
  */
 
 public class Response

==================================================
ApplicationContext.java
index 22d29d9171..af726520f5 100644
--- a/java/org/apache/catalina/connector/ResponseFacade.java
+++ b/java/org/apache/catalina/connector/ResponseFacade.java
@@ -39,7 +39,7 @@ import org.apache.catalina.security.SecurityUtil;
  *
  * @author Remy Maucherat
  * @author Jean-Francois Arcand
- * @version $Revision: 303900 $ $Date: 2005-04-30 00:22:29 +0200 (sam., 30 avr. 2005) $
+ * @version $Revision$ $Date$
  */
 @SuppressWarnings("deprecation")
 public class ResponseFacade 

==================================================
ApplicationContextFacade.java
index 21bc0dd354..d313820fef 100644
--- a/java/org/apache/catalina/core/ApplicationContext.java
+++ b/java/org/apache/catalina/core/ApplicationContext.java
@@ -61,7 +61,7 @@ import org.apache.tomcat.util.http.mapper.MappingData;
  *
  * @author Craig R. McClanahan
  * @author Remy Maucherat
- * @version $Revision: 377994 $ $Date: 2006-02-15 13:37:28 +0100 (mer., 15 févr. 2006) $
+ * @version $Revision$ $Date$
  */
 
 public class ApplicationContext

==================================================
ApplicationDispatcher.java
index a32855dcbe..3a849b9c6e 100644
--- a/java/org/apache/catalina/core/ApplicationContextFacade.java
+++ b/java/org/apache/catalina/core/ApplicationContextFacade.java
@@ -45,7 +45,7 @@ import org.apache.catalina.security.SecurityUtil;
  *
  * @author Remy Maucherat
  * @author Jean-Francois Arcand
- * @version $Revision: 377994 $ $Date: 2006-02-15 13:37:28 +0100 (mer., 15 févr. 2006) $
+ * @version $Revision$ $Date$
  */
 
 public final class ApplicationContextFacade

==================================================
ApplicationFilterChain.java
index dddb2e7a17..b0bec2f2e0 100644
--- a/java/org/apache/catalina/core/ApplicationDispatcher.java
+++ b/java/org/apache/catalina/core/ApplicationDispatcher.java
@@ -61,7 +61,7 @@ import org.apache.juli.logging.LogFactory;
  * <code>javax.servlet.ServletResponseWrapper</code>.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303947 $ $Date: 2005-06-09 07:50:26 +0200 (jeu., 09 juin 2005) $
+ * @version $Revision$ $Date$
  */
 
 final class ApplicationDispatcher

==================================================
ApplicationFilterConfig.java
index 0bb916515d..375879e785 100644
--- a/java/org/apache/catalina/core/ApplicationFilterChain.java
+++ b/java/org/apache/catalina/core/ApplicationFilterChain.java
@@ -49,7 +49,7 @@ import org.apache.catalina.util.StringManager;
  * method itself.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303523 $ $Date: 2004-11-22 17:35:18 +0100 (lun., 22 nov. 2004) $
+ * @version $Revision$ $Date$
  */
 
 final class ApplicationFilterChain implements FilterChain, CometFilterChain {

==================================================
ApplicationHttpRequest.java
index 4446ffb1b8..e71e44a673 100644
--- a/java/org/apache/catalina/core/ApplicationFilterConfig.java
+++ b/java/org/apache/catalina/core/ApplicationFilterConfig.java
@@ -49,7 +49,7 @@ import org.apache.tomcat.util.log.SystemLogHandler;
  * is first started.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 355530 $ $Date: 2005-12-09 17:42:23 +0100 (ven., 09 déc. 2005) $
+ * @version $Revision$ $Date$
  */
 
 final class ApplicationFilterConfig implements FilterConfig, Serializable {

==================================================
ApplicationHttpResponse.java
index 721602ba96..eb273db294 100644
--- a/java/org/apache/catalina/core/ApplicationHttpRequest.java
+++ b/java/org/apache/catalina/core/ApplicationHttpRequest.java
@@ -55,7 +55,7 @@ import org.apache.catalina.util.StringManager;
  *
  * @author Craig R. McClanahan
  * @author Remy Maucherat
- * @version $Revision: 303799 $ $Date: 2005-03-25 09:41:23 +0100 (ven., 25 mars 2005) $
+ * @version $Revision$ $Date$
  */
 
 class ApplicationHttpRequest extends HttpServletRequestWrapper {

==================================================
ApplicationRequest.java
index a86ac23685..ce24523a78 100644
--- a/java/org/apache/catalina/core/ApplicationHttpResponse.java
+++ b/java/org/apache/catalina/core/ApplicationHttpResponse.java
@@ -42,7 +42,7 @@ import org.apache.catalina.util.StringManager;
  * keep these two classes in synchronization when making changes!
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303387 $ $Date: 2004-10-15 18:09:27 +0200 (ven., 15 oct. 2004) $
+ * @version $Revision$ $Date$
  */
 
 class ApplicationHttpResponse extends HttpServletResponseWrapper {

==================================================
ApplicationResponse.java
index 5637424eac..5bf0144dea 100644
--- a/java/org/apache/catalina/core/ApplicationRequest.java
+++ b/java/org/apache/catalina/core/ApplicationRequest.java
@@ -43,7 +43,7 @@ import org.apache.catalina.util.StringManager;
  * keep these two classes in synchronization when making changes!
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 class ApplicationRequest extends ServletRequestWrapper {

==================================================
AprLifecycleListener.java
index ea12b909d3..8ebf384276 100644
--- a/java/org/apache/catalina/core/ApplicationResponse.java
+++ b/java/org/apache/catalina/core/ApplicationResponse.java
@@ -40,7 +40,7 @@ import org.apache.catalina.util.StringManager;
  * keep these two classes in synchronization when making changes!
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 class ApplicationResponse extends ServletResponseWrapper {

==================================================
DummyRequest.java
index ff08f05aa8..34ad43e2f1 100644
--- a/java/org/apache/catalina/core/AprLifecycleListener.java
+++ b/java/org/apache/catalina/core/AprLifecycleListener.java
@@ -35,7 +35,7 @@ import java.lang.reflect.InvocationTargetException;
  *
  * @author Remy Maucherat
  * @author Filip Hanik
- * @version $Revision: 441786 $ $Date: 2006-09-09 14:26:11 +0200 (sam., 09 sept. 2006) $
+ * @version $Revision$ $Date$
  * @since 4.1
  */
 

==================================================
DummyResponse.java
index 183e026bdd..2b6efcef7c 100644
--- a/java/org/apache/catalina/core/DummyRequest.java
+++ b/java/org/apache/catalina/core/DummyRequest.java
@@ -51,7 +51,7 @@ import org.apache.tomcat.util.buf.MessageBytes;
  * JSP precompilation.
  *
  * @author Remy Maucherat
- * @version $Revision: 302975 $ $Date: 2004-06-23 10:25:04 +0200 (mer., 23 juin 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class DummyRequest

==================================================
JasperListener.java
index 3e4aa96559..f4f3667dc3 100644
--- a/java/org/apache/catalina/core/DummyResponse.java
+++ b/java/org/apache/catalina/core/DummyResponse.java
@@ -38,7 +38,7 @@ import org.apache.catalina.connector.Request;
  * Dummy response object, used for JSP precompilation.
  *
  * @author Remy Maucherat
- * @version $Revision: 302975 $ $Date: 2004-06-23 10:25:04 +0200 (mer., 23 juin 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class DummyResponse

==================================================
NamingContextListener.java
index 924da16ec6..05f80aa1ef 100644
--- a/java/org/apache/catalina/core/JasperListener.java
+++ b/java/org/apache/catalina/core/JasperListener.java
@@ -31,7 +31,7 @@ import org.apache.juli.logging.LogFactory;
  * started.
  *
  * @author Remy Maucherat
- * @version $Revision: 374878 $ $Date: 2006-02-04 16:02:39 +0100 (sam., 04 févr. 2006) $
+ * @version $Revision$ $Date$
  * @since 4.1
  */
 

==================================================
StandardContext.java
index fe4f77a215..c0702c8763 100644
--- a/java/org/apache/catalina/core/NamingContextListener.java
+++ b/java/org/apache/catalina/core/NamingContextListener.java
@@ -71,7 +71,7 @@ import org.apache.tomcat.util.modeler.Registry;
  * with each context and server.
  *
  * @author Remy Maucherat
- * @version $Revision: 304032 $ $Date: 2005-07-27 17:11:55 +0200 (mer., 27 juil. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class NamingContextListener

==================================================
StandardContextValve.java
index 05e91a860f..e645f95648 100644
--- a/java/org/apache/catalina/core/StandardContext.java
+++ b/java/org/apache/catalina/core/StandardContext.java
@@ -109,7 +109,7 @@ import org.apache.tomcat.util.modeler.Registry;
  *
  * @author Craig R. McClanahan
  * @author Remy Maucherat
- * @version $Revision: 386331 $ $Date: 2006-03-16 15:03:12 +0100 (jeu., 16 mars 2006) $
+ * @version $Revision$ $Date$
  */
 
 public class StandardContext

==================================================
StandardEngine.java
index c1be326670..c473590a0a 100644
--- a/java/org/apache/catalina/core/StandardContextValve.java
+++ b/java/org/apache/catalina/core/StandardContextValve.java
@@ -45,7 +45,7 @@ import org.apache.tomcat.util.buf.MessageBytes;
  * when processing HTTP requests.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302978 $ $Date: 2004-06-23 18:59:42 +0200 (mer., 23 juin 2004) $
+ * @version $Revision$ $Date$
  */
 
 final class StandardContextValve

==================================================
StandardEngineValve.java
index fd889f306a..e6f01a8bd4 100644
--- a/java/org/apache/catalina/core/StandardEngine.java
+++ b/java/org/apache/catalina/core/StandardEngine.java
@@ -46,7 +46,7 @@ import org.apache.tomcat.util.modeler.modules.MbeansSource;
  * You can set the jvmRoute direct or with the System.property <b>jvmRoute</b>.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303667 $ $Date: 2005-01-29 20:41:16 +0100 (sam., 29 janv. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class StandardEngine

==================================================
StandardHost.java
index 7520f36c11..a388a711fe 100644
--- a/java/org/apache/catalina/core/StandardEngineValve.java
+++ b/java/org/apache/catalina/core/StandardEngineValve.java
@@ -40,7 +40,7 @@ import org.apache.catalina.valves.ValveBase;
  * when processing HTTP requests.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302978 $ $Date: 2004-06-23 18:59:42 +0200 (mer., 23 juin 2004) $
+ * @version $Revision$ $Date$
  */
 
 final class StandardEngineValve

==================================================
StandardHostValve.java
index 3bf330f387..28486678a1 100644
--- a/java/org/apache/catalina/core/StandardHost.java
+++ b/java/org/apache/catalina/core/StandardHost.java
@@ -39,7 +39,7 @@ import org.apache.tomcat.util.modeler.Registry;
  *
  * @author Craig R. McClanahan
  * @author Remy Maucherat
- * @version $Revision: 303666 $ $Date: 2005-01-29 20:38:37 +0100 (sam., 29 janv. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class StandardHost

==================================================
StandardServer.java
index 6846680873..861374fd78 100644
--- a/java/org/apache/catalina/core/StandardHostValve.java
+++ b/java/org/apache/catalina/core/StandardHostValve.java
@@ -50,7 +50,7 @@ import org.apache.juli.logging.LogFactory;
  *
  * @author Craig R. McClanahan
  * @author Remy Maucherat
- * @version $Revision: 304105 $ $Date: 2005-09-27 21:20:54 +0200 (mar., 27 sept. 2005) $
+ * @version $Revision$ $Date$
  */
 
 final class StandardHostValve

==================================================
StandardWrapper.java
index 9052c69dae..4d00476974 100644
--- a/java/org/apache/catalina/core/StandardServer.java
+++ b/java/org/apache/catalina/core/StandardServer.java
@@ -56,7 +56,7 @@ import org.apache.tomcat.util.modeler.Registry;
  * (but not required) when deploying and starting Catalina.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 370082 $ $Date: 2006-01-18 10:17:33 +0100 (mer., 18 janv. 2006) $
+ * @version $Revision$ $Date$
  */
 public final class StandardServer
     implements Lifecycle, Server, MBeanRegistration 

==================================================
StandardWrapperFacade.java
index 37e0805e1d..a08c226206 100644
--- a/java/org/apache/catalina/core/StandardWrapper.java
+++ b/java/org/apache/catalina/core/StandardWrapper.java
@@ -71,7 +71,7 @@ import org.apache.tomcat.util.modeler.Registry;
  *
  * @author Craig R. McClanahan
  * @author Remy Maucherat
- * @version $Revision: 345286 $ $Date: 2005-11-17 18:00:24 +0100 (jeu., 17 nov. 2005) $
+ * @version $Revision$ $Date$
  */
 public class StandardWrapper
     extends ContainerBase

==================================================
StandardWrapperValve.java
index a4c074989c..88ac27adeb 100644
--- a/java/org/apache/catalina/core/StandardWrapperFacade.java
+++ b/java/org/apache/catalina/core/StandardWrapperFacade.java
@@ -29,7 +29,7 @@ import javax.servlet.ServletContext;
  * Facade for the <b>StandardWrapper</b> object.
  *
  * @author Remy Maucharat
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public final class StandardWrapperFacade

==================================================
ApplicationParameter.java
index b520c3a8ba..b35149a54f 100644
--- a/java/org/apache/catalina/core/StandardWrapperValve.java
+++ b/java/org/apache/catalina/core/StandardWrapperValve.java
@@ -47,7 +47,7 @@ import org.apache.tomcat.util.log.SystemLogHandler;
  * <code>StandardWrapper</code> container implementation.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303681 $ $Date: 2005-02-06 11:39:32 +0100 (dim., 06 févr. 2005) $
+ * @version $Revision$ $Date$
  */
 
 final class StandardWrapperValve

==================================================
ContextEjb.java
index 9aca3c2a23..22a4883a9b 100644
--- a/java/org/apache/catalina/deploy/ApplicationParameter.java
+++ b/java/org/apache/catalina/deploy/ApplicationParameter.java
@@ -29,7 +29,7 @@ import java.io.Serializable;
  * to modify the application deployment descriptor itself.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302879 $ $Date: 2004-05-13 22:40:49 +0200 (jeu., 13 mai 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class ApplicationParameter implements Serializable {

==================================================
ContextEnvironment.java
index 69ee22a952..0e0f907670 100644
--- a/java/org/apache/catalina/deploy/ContextEjb.java
+++ b/java/org/apache/catalina/deploy/ContextEjb.java
@@ -28,7 +28,7 @@ import java.io.Serializable;
  *
  * @author Craig R. McClanahan
  * @author Peter Rossbach (pero@apache.org)
- * @version $Revision: 303342 $ $Date: 2004-10-05 09:56:49 +0200 (mar., 05 oct. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class ContextEjb extends ResourceBase implements Serializable {

==================================================
ContextLocalEjb.java
index 363d59d805..7e0022cf8f 100644
--- a/java/org/apache/catalina/deploy/ContextEnvironment.java
+++ b/java/org/apache/catalina/deploy/ContextEnvironment.java
@@ -26,7 +26,7 @@ import java.io.Serializable;
  * an <code>&lt;env-entry&gt;</code> element in the deployment descriptor.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302879 $ $Date: 2004-05-13 22:40:49 +0200 (jeu., 13 mai 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class ContextEnvironment implements Serializable {

==================================================
ContextResource.java
index f2b25e8a20..5d009af538 100644
--- a/java/org/apache/catalina/deploy/ContextLocalEjb.java
+++ b/java/org/apache/catalina/deploy/ContextLocalEjb.java
@@ -28,7 +28,7 @@ import java.io.Serializable;
  *
  * @author Craig R. McClanahan
  * @author Peter Rossbach (pero@apache.org)
- * @version $Revision: 303342 $ $Date: 2004-10-05 09:56:49 +0200 (mar., 05 oct. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class ContextLocalEjb extends ResourceBase implements Serializable {

==================================================
ContextResourceEnvRef.java
index 5d8e9dd43e..fd4d03d88f 100644
--- a/java/org/apache/catalina/deploy/ContextResource.java
+++ b/java/org/apache/catalina/deploy/ContextResource.java
@@ -27,7 +27,7 @@ import java.io.Serializable;
  *
  * @author Craig R. McClanahan
  * @author Peter Rossbach (pero@apache.org)
- * @version $Revision: 303342 $ $Date: 2004-10-05 09:56:49 +0200 (mar., 05 oct. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class ContextResource extends ResourceBase implements Serializable {

==================================================
ContextResourceLink.java
index a00058fc47..5e229ed46a 100644
--- a/java/org/apache/catalina/deploy/ContextResourceEnvRef.java
+++ b/java/org/apache/catalina/deploy/ContextResourceEnvRef.java
@@ -27,7 +27,7 @@ import java.io.Serializable;
  *
  * @author Craig R. McClanahan
  * @author Peter Rossbach (pero@apache.org)
- * @version $Revision: 303342 $ $Date: 2004-10-05 09:56:49 +0200 (mar., 05 oct. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class ContextResourceEnvRef extends ResourceBase implements Serializable {

==================================================
ContextService.java
index ca4bf293a5..939fcf8462 100644
--- a/java/org/apache/catalina/deploy/ContextResourceLink.java
+++ b/java/org/apache/catalina/deploy/ContextResourceLink.java
@@ -28,7 +28,7 @@ import java.io.Serializable;
  *
  * @author Remy Maucherat
  * @author Peter Rossbach (Peter Rossbach (pero@apache.org))
- * @version $Revision: 303342 $ $Date: 2004-10-05 09:56:49 +0200 (mar., 05 oct. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class ContextResourceLink extends ResourceBase implements Serializable {

==================================================
ContextTransaction.java
index d8796b46c9..629f4036f1 100644
--- a/java/org/apache/catalina/deploy/ContextService.java
+++ b/java/org/apache/catalina/deploy/ContextService.java
@@ -26,7 +26,7 @@ import java.io.Serializable;
  * deployment descriptor.
  *
  * @author Fabien Carrion
- * @version $Revision: 303342 $ $Date: 2005-03-15 23:29:49 -0700 (Web, 15 Mar 2006) $
+ * @version $Revision$ $Date$
  */
 
 public class ContextService extends ResourceBase implements Serializable {

==================================================
ErrorPage.java
index 2e8374a51a..abd3b95e52 100644
--- a/java/org/apache/catalina/deploy/ContextTransaction.java
+++ b/java/org/apache/catalina/deploy/ContextTransaction.java
@@ -28,7 +28,7 @@ import java.util.Iterator;
  * an <code>&lt;res-env-refy&gt;</code> element in the deployment descriptor.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303032 $ $Date: 2004-07-26 18:04:02 +0200 (lun., 26 juil. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class ContextTransaction implements Serializable {

==================================================
FilterDef.java
index 6f10df45e2..a29ec146d9 100644
--- a/java/org/apache/catalina/deploy/ErrorPage.java
+++ b/java/org/apache/catalina/deploy/ErrorPage.java
@@ -29,7 +29,7 @@ import java.io.Serializable;
  * deployment descriptor.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302879 $ $Date: 2004-05-13 22:40:49 +0200 (jeu., 13 mai 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class ErrorPage implements Serializable {

==================================================
FilterMap.java
index b94b8fa650..a1f4fd9a76 100644
--- a/java/org/apache/catalina/deploy/FilterDef.java
+++ b/java/org/apache/catalina/deploy/FilterDef.java
@@ -29,7 +29,7 @@ import java.io.Serializable;
  * in a <code>&lt;filter&gt;</code> element in the deployment descriptor.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302879 $ $Date: 2004-05-13 22:40:49 +0200 (jeu., 13 mai 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class FilterDef implements Serializable {

==================================================
LoginConfig.java
index ef255bf85a..3df2a86d26 100644
--- a/java/org/apache/catalina/deploy/FilterMap.java
+++ b/java/org/apache/catalina/deploy/FilterMap.java
@@ -30,7 +30,7 @@ import java.io.Serializable;
  * a URL pattern or a servlet name.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302879 $ $Date: 2004-05-13 22:40:49 +0200 (jeu., 13 mai 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class FilterMap implements Serializable {

==================================================
MessageDestination.java
index a377a4b487..711830d04b 100644
--- a/java/org/apache/catalina/deploy/LoginConfig.java
+++ b/java/org/apache/catalina/deploy/LoginConfig.java
@@ -29,7 +29,7 @@ import java.io.Serializable;
  * deployment descriptor.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302879 $ $Date: 2004-05-13 22:40:49 +0200 (jeu., 13 mai 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class LoginConfig implements Serializable {

==================================================
MessageDestinationRef.java
index a764e7ec65..d75522c718 100644
--- a/java/org/apache/catalina/deploy/MessageDestination.java
+++ b/java/org/apache/catalina/deploy/MessageDestination.java
@@ -25,7 +25,7 @@ package org.apache.catalina.deploy;
  * in the deployment descriptor.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302879 $ $Date: 2004-05-13 22:40:49 +0200 (jeu., 13 mai 2004) $
+ * @version $Revision$ $Date$
  * @since Tomcat 5.0
  */
 

==================================================
NamingResources.java
index d5ebcaaaf0..b3c63d125c 100644
--- a/java/org/apache/catalina/deploy/MessageDestinationRef.java
+++ b/java/org/apache/catalina/deploy/MessageDestinationRef.java
@@ -27,7 +27,7 @@ import java.io.Serializable;
  * in the deployment descriptor.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302879 $ $Date: 2004-05-13 22:40:49 +0200 (jeu., 13 mai 2004) $
+ * @version $Revision$ $Date$
  * @since Tomcat 5.0
  */
 

==================================================
ResourceBase.java
index 8ba59d35e3..a2972344de 100644
--- a/java/org/apache/catalina/deploy/NamingResources.java
+++ b/java/org/apache/catalina/deploy/NamingResources.java
@@ -31,7 +31,7 @@ import java.io.Serializable;
  * Naming Context and their associated JNDI context.
  *
  * @author Remy Maucherat
- * @version $Revision: 303133 $ $Date: 2004-08-29 18:46:15 +0200 (dim., 29 août 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class NamingResources implements Serializable {

==================================================
SecurityCollection.java
index d83bd6e8b8..def136791b 100644
--- a/java/org/apache/catalina/deploy/ResourceBase.java
+++ b/java/org/apache/catalina/deploy/ResourceBase.java
@@ -27,7 +27,7 @@ import java.util.HashMap;
  * Representation of an Context element
  *
  * @author Peter Rossbach (pero@apache.org)
- * @version $Revision: 303342 $ $Date: 2004-10-05 09:56:49 +0200 (mar., 05 oct. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class ResourceBase implements Serializable {

==================================================
SecurityConstraint.java
index 2ff3035946..ead1a16361 100644
--- a/java/org/apache/catalina/deploy/SecurityCollection.java
+++ b/java/org/apache/catalina/deploy/SecurityCollection.java
@@ -39,7 +39,7 @@ import java.io.Serializable;
  * this class is synchronized.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 304007 $ $Date: 2005-07-21 22:14:57 +0200 (jeu., 21 juil. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class SecurityCollection implements Serializable {

==================================================
CatalinaCluster.java
index 4060580c75..84a604f7ef 100644
--- a/java/org/apache/catalina/deploy/SecurityConstraint.java
+++ b/java/org/apache/catalina/deploy/SecurityConstraint.java
@@ -33,7 +33,7 @@ import java.io.Serializable;
  * this class is synchronized.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302879 $ $Date: 2004-05-13 22:40:49 +0200 (jeu., 13 mai 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class SecurityConstraint implements Serializable {

==================================================
ClusterDeployer.java
index de60e2c554..4c927b1335 100644
--- a/java/org/apache/catalina/ha/CatalinaCluster.java
+++ b/java/org/apache/catalina/ha/CatalinaCluster.java
@@ -1,130 +1,130 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha;
-
-import java.util.Map;
-
-import org.apache.catalina.Cluster;
-import org.apache.catalina.LifecycleException;
-import org.apache.catalina.Manager;
-import org.apache.catalina.Valve;
-import org.apache.catalina.tribes.Channel;
-import org.apache.catalina.tribes.Member;
-import org.apache.juli.logging.Log;
-
-
-
-/**
- * A <b>CatalinaCluster</b> interface allows to plug in and out the 
- * different cluster implementations
- *
- * @author Filip Hanik
- * @version $Revision: 379550 $, $Date: 2006-02-21 12:06:35 -0600 (Tue, 21 Feb 2006) $
- */
-
-public interface CatalinaCluster extends Cluster {
-    // ----------------------------------------------------- Instance Variables
-
-    /**
-     * Descriptive information about this component implementation.
-     */
-    public String info = "CatalinaCluster/2.0";
-    
-    /**
-     * Start the cluster, the owning container will invoke this
-     * @throws Exception - if failure to start cluster
-     */
-    public void start() throws Exception;
-    
-    /**
-     * Stops the cluster, the owning container will invoke this
-     * @throws LifecycleException
-     */
-    public void stop() throws LifecycleException;
-    
-    /**
-     * Returns the associates logger with this cluster.
-     *
-     * @return Log
-     */
-    public Log getLogger();
-    
-    /**
-     * Sends a message to all the members in the cluster
-     * @param msg ClusterMessage
-     */
-    public void send(ClusterMessage msg);
-    
-    /**
-     * Sends a message to a specific member in the cluster.
-     *
-     * @param msg ClusterMessage
-     * @param dest Member
-     */
-    public void send(ClusterMessage msg, Member dest);
-    
-    /**
-     * Sends a message to a all members at local cluster domain
-     *
-     * @param msg ClusterMessage
-     */
-    public void sendClusterDomain(ClusterMessage msg);
-
-    /**
-     * Returns that cluster has members.
-     */
-    public boolean hasMembers();
-
-    /**
-     * Returns all the members currently participating in the cluster.
-     *
-     * @return Member[]
-     */
-    public Member[] getMembers();
-    
-    /**
-     * Return the member that represents this node.
-     *
-     * @return Member
-     */
-    public Member getLocalMember();
-    
-    public void addValve(Valve valve);
-    
-    public void addClusterListener(ClusterListener listener);
-    
-    public void removeClusterListener(ClusterListener listener);
-    
-    public void setClusterDeployer(ClusterDeployer deployer);
-    
-    public ClusterDeployer getClusterDeployer();
-    
-    /**
-     * @return The map of managers
-     */
-    public Map getManagers();
-
-    public Manager getManager(String name);
-    public String getManagerName(String name, Manager manager);
-    public Valve[] getValves();
-    
-    public void setChannel(Channel channel);
-    public Channel getChannel();
-    
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha;
+
+import java.util.Map;
+
+import org.apache.catalina.Cluster;
+import org.apache.catalina.LifecycleException;
+import org.apache.catalina.Manager;
+import org.apache.catalina.Valve;
+import org.apache.catalina.tribes.Channel;
+import org.apache.catalina.tribes.Member;
+import org.apache.juli.logging.Log;
+
+
+
+/**
+ * A <b>CatalinaCluster</b> interface allows to plug in and out the 
+ * different cluster implementations
+ *
+ * @author Filip Hanik
+ * @version $Revision$, $Date$
+ */
+
+public interface CatalinaCluster extends Cluster {
+    // ----------------------------------------------------- Instance Variables
+
+    /**
+     * Descriptive information about this component implementation.
+     */
+    public String info = "CatalinaCluster/2.0";
+    
+    /**
+     * Start the cluster, the owning container will invoke this
+     * @throws Exception - if failure to start cluster
+     */
+    public void start() throws Exception;
+    
+    /**
+     * Stops the cluster, the owning container will invoke this
+     * @throws LifecycleException
+     */
+    public void stop() throws LifecycleException;
+    
+    /**
+     * Returns the associates logger with this cluster.
+     *
+     * @return Log
+     */
+    public Log getLogger();
+    
+    /**
+     * Sends a message to all the members in the cluster
+     * @param msg ClusterMessage
+     */
+    public void send(ClusterMessage msg);
+    
+    /**
+     * Sends a message to a specific member in the cluster.
+     *
+     * @param msg ClusterMessage
+     * @param dest Member
+     */
+    public void send(ClusterMessage msg, Member dest);
+    
+    /**
+     * Sends a message to a all members at local cluster domain
+     *
+     * @param msg ClusterMessage
+     */
+    public void sendClusterDomain(ClusterMessage msg);
+
+    /**
+     * Returns that cluster has members.
+     */
+    public boolean hasMembers();
+
+    /**
+     * Returns all the members currently participating in the cluster.
+     *
+     * @return Member[]
+     */
+    public Member[] getMembers();
+    
+    /**
+     * Return the member that represents this node.
+     *
+     * @return Member
+     */
+    public Member getLocalMember();
+    
+    public void addValve(Valve valve);
+    
+    public void addClusterListener(ClusterListener listener);
+    
+    public void removeClusterListener(ClusterListener listener);
+    
+    public void setClusterDeployer(ClusterDeployer deployer);
+    
+    public ClusterDeployer getClusterDeployer();
+    
+    /**
+     * @return The map of managers
+     */
+    public Map getManagers();
+
+    public Manager getManager(String name);
+    public String getManagerName(String name, Manager manager);
+    public Valve[] getValves();
+    
+    public void setChannel(Channel channel);
+    public Channel getChannel();
+    
+
+}

==================================================
ClusterListener.java
index 4823abce58..4d38eec179 100644
--- a/java/org/apache/catalina/ha/ClusterDeployer.java
+++ b/java/org/apache/catalina/ha/ClusterDeployer.java
@@ -1,121 +1,121 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha;
-
-/**
- * A <b>ClusterDeployer</b> interface allows to plug in and out the
- * different deployment implementations
- *
- * @author Filip Hanik
- * @version $Revision: 378050 $, $Date: 2006-02-15 12:30:02 -0600 (Wed, 15 Feb 2006) $
- */
-import org.apache.catalina.LifecycleException;
-import java.io.IOException;
-import java.net.URL;
-import org.apache.catalina.tribes.ChannelListener;
-
-public interface ClusterDeployer extends ChannelListener {
-    /**
-     * Descriptive information about this component implementation.
-     */
-    public String info = "ClusterDeployer/1.0";
-    /**
-     * Start the cluster deployer, the owning container will invoke this
-     * @throws Exception - if failure to start cluster
-     */
-    public void start() throws Exception;
-
-    /**
-     * Stops the cluster deployer, the owning container will invoke this
-     * @throws LifecycleException
-     */
-    public void stop() throws LifecycleException;
-
-    /**
-     * Sets the deployer for this cluster deployer to use.
-     * @param deployer Deployer
-     */
-    // FIXME
-    //public void setDeployer(Deployer deployer);
-
-    /**
-     * Install a new web application, whose web application archive is at the
-     * specified URL, into this container and all the other
-     * members of the cluster with the specified context path.
-     * A context path of "" (the empty string) should be used for the root
-     * application for this container.  Otherwise, the context path must
-     * start with a slash.
-     * <p>
-     * If this application is successfully installed locally, 
-     * a ContainerEvent of type
-     * <code>INSTALL_EVENT</code> will be sent to all registered listeners,
-     * with the newly created <code>Context</code> as an argument.
-     *
-     * @param contextPath The context path to which this application should
-     *  be installed (must be unique)
-     * @param war A URL of type "jar:" that points to a WAR file, or type
-     *  "file:" that points to an unpacked directory structure containing
-     *  the web application to be installed
-     *
-     * @exception IllegalArgumentException if the specified context path
-     *  is malformed (it must be "" or start with a slash)
-     * @exception IllegalStateException if the specified context path
-     *  is already attached to an existing web application
-     * @exception IOException if an input/output error was encountered
-     *  during installation
-     */
-    public void install(String contextPath, URL war) throws IOException;
-
-    /**
-     * Remove an existing web application, attached to the specified context
-     * path.  If this application is successfully removed, a
-     * ContainerEvent of type <code>REMOVE_EVENT</code> will be sent to all
-     * registered listeners, with the removed <code>Context</code> as
-     * an argument. Deletes the web application war file and/or directory
-     * if they exist in the Host's appBase.
-     *
-     * @param contextPath The context path of the application to be removed
-     * @param undeploy boolean flag to remove web application from server
-     *
-     * @exception IllegalArgumentException if the specified context path
-     *  is malformed (it must be "" or start with a slash)
-     * @exception IllegalArgumentException if the specified context path does
-     *  not identify a currently installed web application
-     * @exception IOException if an input/output error occurs during
-     *  removal
-     */
-    public void remove(String contextPath, boolean undeploy) throws IOException;
-
-    /**
-     * call from container Background Process
-     */
-    public void backgroundProcess();
-    
-    /**
-     * Returns the cluster the cluster deployer is associated with
-     * @return CatalinaCluster
-     */
-    public CatalinaCluster getCluster();
-
-    /**
-     * Associates the cluster deployer with a cluster
-     * @param cluster CatalinaCluster
-     */
-    public void setCluster(CatalinaCluster cluster);
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha;
+
+/**
+ * A <b>ClusterDeployer</b> interface allows to plug in and out the
+ * different deployment implementations
+ *
+ * @author Filip Hanik
+ * @version $Revision$, $Date$
+ */
+import org.apache.catalina.LifecycleException;
+import java.io.IOException;
+import java.net.URL;
+import org.apache.catalina.tribes.ChannelListener;
+
+public interface ClusterDeployer extends ChannelListener {
+    /**
+     * Descriptive information about this component implementation.
+     */
+    public String info = "ClusterDeployer/1.0";
+    /**
+     * Start the cluster deployer, the owning container will invoke this
+     * @throws Exception - if failure to start cluster
+     */
+    public void start() throws Exception;
+
+    /**
+     * Stops the cluster deployer, the owning container will invoke this
+     * @throws LifecycleException
+     */
+    public void stop() throws LifecycleException;
+
+    /**
+     * Sets the deployer for this cluster deployer to use.
+     * @param deployer Deployer
+     */
+    // FIXME
+    //public void setDeployer(Deployer deployer);
+
+    /**
+     * Install a new web application, whose web application archive is at the
+     * specified URL, into this container and all the other
+     * members of the cluster with the specified context path.
+     * A context path of "" (the empty string) should be used for the root
+     * application for this container.  Otherwise, the context path must
+     * start with a slash.
+     * <p>
+     * If this application is successfully installed locally, 
+     * a ContainerEvent of type
+     * <code>INSTALL_EVENT</code> will be sent to all registered listeners,
+     * with the newly created <code>Context</code> as an argument.
+     *
+     * @param contextPath The context path to which this application should
+     *  be installed (must be unique)
+     * @param war A URL of type "jar:" that points to a WAR file, or type
+     *  "file:" that points to an unpacked directory structure containing
+     *  the web application to be installed
+     *
+     * @exception IllegalArgumentException if the specified context path
+     *  is malformed (it must be "" or start with a slash)
+     * @exception IllegalStateException if the specified context path
+     *  is already attached to an existing web application
+     * @exception IOException if an input/output error was encountered
+     *  during installation
+     */
+    public void install(String contextPath, URL war) throws IOException;
+
+    /**
+     * Remove an existing web application, attached to the specified context
+     * path.  If this application is successfully removed, a
+     * ContainerEvent of type <code>REMOVE_EVENT</code> will be sent to all
+     * registered listeners, with the removed <code>Context</code> as
+     * an argument. Deletes the web application war file and/or directory
+     * if they exist in the Host's appBase.
+     *
+     * @param contextPath The context path of the application to be removed
+     * @param undeploy boolean flag to remove web application from server
+     *
+     * @exception IllegalArgumentException if the specified context path
+     *  is malformed (it must be "" or start with a slash)
+     * @exception IllegalArgumentException if the specified context path does
+     *  not identify a currently installed web application
+     * @exception IOException if an input/output error occurs during
+     *  removal
+     */
+    public void remove(String contextPath, boolean undeploy) throws IOException;
+
+    /**
+     * call from container Background Process
+     */
+    public void backgroundProcess();
+    
+    /**
+     * Returns the cluster the cluster deployer is associated with
+     * @return CatalinaCluster
+     */
+    public CatalinaCluster getCluster();
+
+    /**
+     * Associates the cluster deployer with a cluster
+     * @param cluster CatalinaCluster
+     */
+    public void setCluster(CatalinaCluster cluster);
+
+}

==================================================
ClusterManager.java
index a99bba4eb4..cbb4a2901c 100644
--- a/java/org/apache/catalina/ha/ClusterListener.java
+++ b/java/org/apache/catalina/ha/ClusterListener.java
@@ -1,114 +1,114 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha;
-
-
-
-
-import java.io.Serializable;
-
-import org.apache.catalina.tribes.ChannelListener;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.util.StringManager;
-
-
-/**
- * Receive SessionID cluster change from other backup node after primary session
- * node is failed.
- * 
- * @author Peter Rossbach
- * @author Filip Hanik
- * @version $Revision: 378258 $ $Date: 2006-02-16 08:42:35 -0600 (Thu, 16 Feb 2006) $
- */
-public abstract class ClusterListener implements ChannelListener {
-
-    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(ClusterListener.class);
-
-
-    //--Instance Variables--------------------------------------
-
-    /**
-     * The string manager for this package.
-     */
-    protected StringManager sm = StringManager.getManager(Constants.Package);
-
-    protected CatalinaCluster cluster = null;
-
-    //--Constructor---------------------------------------------
-
-    public ClusterListener() {
-    }
-    
-    //--Instance Getters/Setters--------------------------------
-    
-    public CatalinaCluster getCluster() {
-        return cluster;
-    }
-
-    public void setCluster(CatalinaCluster cluster) {
-        if (log.isDebugEnabled()) {
-            if (cluster != null)
-                log.debug("add ClusterListener " + this.toString() + " to cluster" + cluster);
-            else
-                log.debug("remove ClusterListener " + this.toString() + " from cluster");
-        }
-        this.cluster = cluster;
-    }
-
-    public boolean equals(Object listener) {
-        return super.equals(listener);
-    }
-
-    public int hashCode() {
-        return super.hashCode();
-    }
-
-    //--Logic---------------------------------------------------
-
-    public final void messageReceived(Serializable msg, Member member) {
-        if ( msg instanceof ClusterMessage ) messageReceived((ClusterMessage)msg);
-    }
-    public final boolean accept(Serializable msg, Member member) {
-        if ( msg instanceof ClusterMessage ) return true;
-        return false;
-    }
-
-
-
-    /**
-     * Callback from the cluster, when a message is received, The cluster will
-     * broadcast it invoking the messageReceived on the receiver.
-     * 
-     * @param msg
-     *            ClusterMessage - the message received from the cluster
-     */
-    public abstract void messageReceived(ClusterMessage msg) ;
-    
-
-    /**
-     * Accept only SessionIDMessages
-     * 
-     * @param msg
-     *            ClusterMessage
-     * @return boolean - returns true to indicate that messageReceived should be
-     *         invoked. If false is returned, the messageReceived method will
-     *         not be invoked.
-     */
-    public abstract boolean accept(ClusterMessage msg) ;
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha;
+
+
+
+
+import java.io.Serializable;
+
+import org.apache.catalina.tribes.ChannelListener;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.util.StringManager;
+
+
+/**
+ * Receive SessionID cluster change from other backup node after primary session
+ * node is failed.
+ * 
+ * @author Peter Rossbach
+ * @author Filip Hanik
+ * @version $Revision$ $Date$
+ */
+public abstract class ClusterListener implements ChannelListener {
+
+    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(ClusterListener.class);
+
+
+    //--Instance Variables--------------------------------------
+
+    /**
+     * The string manager for this package.
+     */
+    protected StringManager sm = StringManager.getManager(Constants.Package);
+
+    protected CatalinaCluster cluster = null;
+
+    //--Constructor---------------------------------------------
+
+    public ClusterListener() {
+    }
+    
+    //--Instance Getters/Setters--------------------------------
+    
+    public CatalinaCluster getCluster() {
+        return cluster;
+    }
+
+    public void setCluster(CatalinaCluster cluster) {
+        if (log.isDebugEnabled()) {
+            if (cluster != null)
+                log.debug("add ClusterListener " + this.toString() + " to cluster" + cluster);
+            else
+                log.debug("remove ClusterListener " + this.toString() + " from cluster");
+        }
+        this.cluster = cluster;
+    }
+
+    public boolean equals(Object listener) {
+        return super.equals(listener);
+    }
+
+    public int hashCode() {
+        return super.hashCode();
+    }
+
+    //--Logic---------------------------------------------------
+
+    public final void messageReceived(Serializable msg, Member member) {
+        if ( msg instanceof ClusterMessage ) messageReceived((ClusterMessage)msg);
+    }
+    public final boolean accept(Serializable msg, Member member) {
+        if ( msg instanceof ClusterMessage ) return true;
+        return false;
+    }
+
+
+
+    /**
+     * Callback from the cluster, when a message is received, The cluster will
+     * broadcast it invoking the messageReceived on the receiver.
+     * 
+     * @param msg
+     *            ClusterMessage - the message received from the cluster
+     */
+    public abstract void messageReceived(ClusterMessage msg) ;
+    
+
+    /**
+     * Accept only SessionIDMessages
+     * 
+     * @param msg
+     *            ClusterMessage
+     * @return boolean - returns true to indicate that messageReceived should be
+     *         invoked. If false is returned, the messageReceived method will
+     *         not be invoked.
+     */
+    public abstract boolean accept(ClusterMessage msg) ;
+
+}

==================================================
ClusterMessage.java
index 0a5da49216..f236854d59 100644
--- a/java/org/apache/catalina/ha/ClusterManager.java
+++ b/java/org/apache/catalina/ha/ClusterManager.java
@@ -1,112 +1,112 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha;
-
-
-import org.apache.catalina.Manager;
-import java.io.IOException;
-import org.apache.catalina.tribes.io.ReplicationStream;
-
-
-/**
- * The common interface used by all cluster manager.
- * This is so that we can have a more pluggable way
- * of swapping session managers for different algorithms.
- *
- * @author Filip Hanik
- * @author Peter Rossbach
- */
-public interface ClusterManager extends Manager {
-
-   /**
-    * A message was received from another node, this
-    * is the callback method to implement if you are interested in
-    * receiving replication messages.
-    * @param msg - the message received.
-    */
-   public void messageDataReceived(ClusterMessage msg);
-
-   /**
-    * When the request has been completed, the replication valve
-    * will notify the manager, and the manager will decide whether
-    * any replication is needed or not.
-    * If there is a need for replication, the manager will
-    * create a session message and that will be replicated.
-    * The cluster determines where it gets sent.
-    * @param sessionId - the sessionId that just completed.
-    * @return a SessionMessage to be sent.
-    */
-   public ClusterMessage requestCompleted(String sessionId);
-
-   /**
-    * When the manager expires session not tied to a request.
-    * The cluster will periodically ask for a list of sessions
-    * that should expire and that should be sent across the wire.
-    * @return String[] The invalidated sessions
-    */
-   public String[] getInvalidatedSessions();
-   
-   /**
-    * Return the name of the manager, at host /context name and at engine hostname+/context.
-    * @return String
-    * @since 5.5.10
-    */
-   public String getName();
-   
-   /**
-    * Set the name of the manager, at host /context name and at engine hostname+/context
-    * @param name
-    * @since 5.5.10
-    */
-   public void setName(String name);
-         
-   public CatalinaCluster getCluster();
-
-   public void setCluster(CatalinaCluster cluster);
-   
-   /**
-    * @return Manager send only to same cluster domain.
-    * @since 5.5.10
-    */
-   public boolean doDomainReplication();
-
-   /**
-    * @param sendClusterDomainOnly Flag value.
-    * @since 5.5.10
-    */
-   public void setDomainReplication(boolean domainReplication);
-
-   /**
-    * @param mode The mode
-    * @since 5.5.10
-    */
-   public void setDefaultMode(boolean mode);
-
-   /**
-    * @since 5.5.10
-    */
-   public boolean isDefaultMode();
-   
-   public ReplicationStream getReplicationStream(byte[] data) throws IOException;
-
-   public ReplicationStream getReplicationStream(byte[] data, int offset, int length) throws IOException;
-   
-   public boolean isNotifyListenersOnReplication();
-
-   public ClusterManager cloneFromTemplate();
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha;
+
+
+import org.apache.catalina.Manager;
+import java.io.IOException;
+import org.apache.catalina.tribes.io.ReplicationStream;
+
+
+/**
+ * The common interface used by all cluster manager.
+ * This is so that we can have a more pluggable way
+ * of swapping session managers for different algorithms.
+ *
+ * @author Filip Hanik
+ * @author Peter Rossbach
+ */
+public interface ClusterManager extends Manager {
+
+   /**
+    * A message was received from another node, this
+    * is the callback method to implement if you are interested in
+    * receiving replication messages.
+    * @param msg - the message received.
+    */
+   public void messageDataReceived(ClusterMessage msg);
+
+   /**
+    * When the request has been completed, the replication valve
+    * will notify the manager, and the manager will decide whether
+    * any replication is needed or not.
+    * If there is a need for replication, the manager will
+    * create a session message and that will be replicated.
+    * The cluster determines where it gets sent.
+    * @param sessionId - the sessionId that just completed.
+    * @return a SessionMessage to be sent.
+    */
+   public ClusterMessage requestCompleted(String sessionId);
+
+   /**
+    * When the manager expires session not tied to a request.
+    * The cluster will periodically ask for a list of sessions
+    * that should expire and that should be sent across the wire.
+    * @return String[] The invalidated sessions
+    */
+   public String[] getInvalidatedSessions();
+   
+   /**
+    * Return the name of the manager, at host /context name and at engine hostname+/context.
+    * @return String
+    * @since 5.5.10
+    */
+   public String getName();
+   
+   /**
+    * Set the name of the manager, at host /context name and at engine hostname+/context
+    * @param name
+    * @since 5.5.10
+    */
+   public void setName(String name);
+         
+   public CatalinaCluster getCluster();
+
+   public void setCluster(CatalinaCluster cluster);
+   
+   /**
+    * @return Manager send only to same cluster domain.
+    * @since 5.5.10
+    */
+   public boolean doDomainReplication();
+
+   /**
+    * @param sendClusterDomainOnly Flag value.
+    * @since 5.5.10
+    */
+   public void setDomainReplication(boolean domainReplication);
+
+   /**
+    * @param mode The mode
+    * @since 5.5.10
+    */
+   public void setDefaultMode(boolean mode);
+
+   /**
+    * @since 5.5.10
+    */
+   public boolean isDefaultMode();
+   
+   public ReplicationStream getReplicationStream(byte[] data) throws IOException;
+
+   public ReplicationStream getReplicationStream(byte[] data, int offset, int length) throws IOException;
+   
+   public boolean isNotifyListenersOnReplication();
+
+   public ClusterManager cloneFromTemplate();
+}

==================================================
ClusterRuleSet.java
index 579a85a9d0..5762a80617 100644
--- a/java/org/apache/catalina/ha/ClusterMessage.java
+++ b/java/org/apache/catalina/ha/ClusterMessage.java
@@ -1,34 +1,34 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.ha;
-
-import java.io.Serializable;
-import org.apache.catalina.tribes.Member;
-
-
-/**
- * @author Filip Hanik
- * 
- */
-public interface ClusterMessage extends Serializable {
-    public Member getAddress();
-    public void setAddress(Member member);
-    public String getUniqueId();
-    public void setUniqueId(String id);
-    public long getTimestamp();
-    public void setTimestamp(long timestamp);
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.ha;
+
+import java.io.Serializable;
+import org.apache.catalina.tribes.Member;
+
+
+/**
+ * @author Filip Hanik
+ * 
+ */
+public interface ClusterMessage extends Serializable {
+    public Member getAddress();
+    public void setAddress(Member member);
+    public String getUniqueId();
+    public void setUniqueId(String id);
+    public long getTimestamp();
+    public void setTimestamp(long timestamp);
+}

==================================================
ClusterSession.java
index 118a0e8880..1a41637a68 100644
--- a/java/org/apache/catalina/ha/ClusterRuleSet.java
+++ b/java/org/apache/catalina/ha/ClusterRuleSet.java
@@ -1,195 +1,195 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina.ha;
-
-
-import org.apache.tomcat.util.digester.Digester;
-import org.apache.tomcat.util.digester.RuleSetBase;
-
-
-/**
- * <p><strong>RuleSet</strong> for processing the contents of a
- * Cluster definition element.  </p>
- *
- * @author Filip Hanik
- * @author Peter Rossbach
- * @version $Revision: 387285 $ $Date: 2006-03-20 13:30:50 -0600 (Mon, 20 Mar 2006) $
- */
-
-public class ClusterRuleSet extends RuleSetBase {
-
-
-    // ----------------------------------------------------- Instance Variables
-
-
-    /**
-     * The matching pattern prefix to use for recognizing our elements.
-     */
-    protected String prefix = null;
-
-
-    // ------------------------------------------------------------ Constructor
-
-
-    /**
-     * Construct an instance of this <code>RuleSet</code> with the default
-     * matching pattern prefix.
-     */
-    public ClusterRuleSet() {
-
-        this("");
-
-    }
-
-
-    /**
-     * Construct an instance of this <code>RuleSet</code> with the specified
-     * matching pattern prefix.
-     *
-     * @param prefix Prefix for matching pattern rules (including the
-     *  trailing slash character)
-     */
-    public ClusterRuleSet(String prefix) {
-        super();
-        this.namespaceURI = null;
-        this.prefix = prefix;
-    }
-
-
-    // --------------------------------------------------------- Public Methods
-
-
-    /**
-     * <p>Add the set of Rule instances defined in this RuleSet to the
-     * specified <code>Digester</code> instance, associating them with
-     * our namespace URI (if any).  This method should only be called
-     * by a Digester instance.</p>
-     *
-     * @param digester Digester instance to which the new Rule instances
-     *  should be added.
-     */
-    public void addRuleInstances(Digester digester) {
-        //Cluster configuration start
-        digester.addObjectCreate(prefix + "Manager",
-                                 null, // MUST be specified in the element
-                                 "className");
-        digester.addSetProperties(prefix + "Manager");
-        digester.addSetNext(prefix + "Manager",
-                            "setManagerTemplate",
-                            "org.apache.catalina.ha.ClusterManager");
-        
-
-
-        digester.addObjectCreate(prefix + "Channel",
-                                 null, // MUST be specified in the element
-                                 "className");
-        digester.addSetProperties(prefix + "Channel");
-        digester.addSetNext(prefix + "Channel",
-                            "setChannel",
-                            "org.apache.catalina.tribes.Channel");
-
-
-        String channelPrefix = prefix + "Channel/";
-        { //channel properties
-            digester.addObjectCreate(channelPrefix + "Membership",
-                                     null, // MUST be specified in the element
-                                     "className");
-            digester.addSetProperties(channelPrefix + "Membership");
-            digester.addSetNext(channelPrefix + "Membership",
-                                "setMembershipService",
-                                "org.apache.catalina.tribes.MembershipService");
-
-            digester.addObjectCreate(channelPrefix + "Sender",
-                                     null, // MUST be specified in the element
-                                     "className");
-            digester.addSetProperties(channelPrefix + "Sender");
-            digester.addSetNext(channelPrefix + "Sender",
-                                "setChannelSender",
-                                "org.apache.catalina.tribes.ChannelSender");
-
-            digester.addObjectCreate(channelPrefix + "Sender/Transport",
-                                     null, // MUST be specified in the element
-                                     "className");
-            digester.addSetProperties(channelPrefix + "Sender/Transport");
-            digester.addSetNext(channelPrefix + "Sender/Transport",
-                                "setTransport",
-                                "org.apache.catalina.tribes.transport.MultiPointSender");
-
-
-            digester.addObjectCreate(channelPrefix + "Receiver",
-                                     null, // MUST be specified in the element
-                                     "className");
-            digester.addSetProperties(channelPrefix + "Receiver");
-            digester.addSetNext(channelPrefix + "Receiver",
-                                "setChannelReceiver",
-                                "org.apache.catalina.tribes.ChannelReceiver");
-
-            digester.addObjectCreate(channelPrefix + "Interceptor",
-                                     null, // MUST be specified in the element
-                                     "className");
-            digester.addSetProperties(channelPrefix + "Interceptor");
-            digester.addSetNext(channelPrefix + "Interceptor",
-                                "addInterceptor",
-                                "org.apache.catalina.tribes.ChannelInterceptor");
-
-            
-            digester.addObjectCreate(channelPrefix + "Interceptor/Member",
-                                     null, // MUST be specified in the element
-                                     "className");
-            digester.addSetProperties(channelPrefix + "Interceptor/Member");
-            digester.addSetNext(channelPrefix + "Interceptor/Member",
-                                "addStaticMember",
-                                "org.apache.catalina.tribes.Member");
-        }
-
-        digester.addObjectCreate(prefix + "Valve",
-                                 null, // MUST be specified in the element
-                                 "className");
-        digester.addSetProperties(prefix + "Valve");
-        digester.addSetNext(prefix + "Valve",
-                            "addValve",
-                            "org.apache.catalina.Valve");
-        
-        digester.addObjectCreate(prefix + "Deployer",
-                                 null, // MUST be specified in the element
-                                 "className");
-        digester.addSetProperties(prefix + "Deployer");
-        digester.addSetNext(prefix + "Deployer",
-                            "setClusterDeployer",
-                            "org.apache.catalina.ha.ClusterDeployer");
-        
-        digester.addObjectCreate(prefix + "Listener",
-                null, // MUST be specified in the element
-                "className");
-        digester.addSetProperties(prefix + "Listener");
-        digester.addSetNext(prefix + "Listener",
-                            "addLifecycleListener",
-                            "org.apache.catalina.LifecycleListener");
-        
-        digester.addObjectCreate(prefix + "ClusterListener",
-                null, // MUST be specified in the element
-                "className");
-        digester.addSetProperties(prefix + "ClusterListener");
-        digester.addSetNext(prefix + "ClusterListener",
-                            "addClusterListener",
-                            "org.apache.catalina.ha.ClusterListener");
-        //Cluster configuration end
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.catalina.ha;
+
+
+import org.apache.tomcat.util.digester.Digester;
+import org.apache.tomcat.util.digester.RuleSetBase;
+
+
+/**
+ * <p><strong>RuleSet</strong> for processing the contents of a
+ * Cluster definition element.  </p>
+ *
+ * @author Filip Hanik
+ * @author Peter Rossbach
+ * @version $Revision$ $Date$
+ */
+
+public class ClusterRuleSet extends RuleSetBase {
+
+
+    // ----------------------------------------------------- Instance Variables
+
+
+    /**
+     * The matching pattern prefix to use for recognizing our elements.
+     */
+    protected String prefix = null;
+
+
+    // ------------------------------------------------------------ Constructor
+
+
+    /**
+     * Construct an instance of this <code>RuleSet</code> with the default
+     * matching pattern prefix.
+     */
+    public ClusterRuleSet() {
+
+        this("");
+
+    }
+
+
+    /**
+     * Construct an instance of this <code>RuleSet</code> with the specified
+     * matching pattern prefix.
+     *
+     * @param prefix Prefix for matching pattern rules (including the
+     *  trailing slash character)
+     */
+    public ClusterRuleSet(String prefix) {
+        super();
+        this.namespaceURI = null;
+        this.prefix = prefix;
+    }
+
+
+    // --------------------------------------------------------- Public Methods
+
+
+    /**
+     * <p>Add the set of Rule instances defined in this RuleSet to the
+     * specified <code>Digester</code> instance, associating them with
+     * our namespace URI (if any).  This method should only be called
+     * by a Digester instance.</p>
+     *
+     * @param digester Digester instance to which the new Rule instances
+     *  should be added.
+     */
+    public void addRuleInstances(Digester digester) {
+        //Cluster configuration start
+        digester.addObjectCreate(prefix + "Manager",
+                                 null, // MUST be specified in the element
+                                 "className");
+        digester.addSetProperties(prefix + "Manager");
+        digester.addSetNext(prefix + "Manager",
+                            "setManagerTemplate",
+                            "org.apache.catalina.ha.ClusterManager");
+        
+
+
+        digester.addObjectCreate(prefix + "Channel",
+                                 null, // MUST be specified in the element
+                                 "className");
+        digester.addSetProperties(prefix + "Channel");
+        digester.addSetNext(prefix + "Channel",
+                            "setChannel",
+                            "org.apache.catalina.tribes.Channel");
+
+
+        String channelPrefix = prefix + "Channel/";
+        { //channel properties
+            digester.addObjectCreate(channelPrefix + "Membership",
+                                     null, // MUST be specified in the element
+                                     "className");
+            digester.addSetProperties(channelPrefix + "Membership");
+            digester.addSetNext(channelPrefix + "Membership",
+                                "setMembershipService",
+                                "org.apache.catalina.tribes.MembershipService");
+
+            digester.addObjectCreate(channelPrefix + "Sender",
+                                     null, // MUST be specified in the element
+                                     "className");
+            digester.addSetProperties(channelPrefix + "Sender");
+            digester.addSetNext(channelPrefix + "Sender",
+                                "setChannelSender",
+                                "org.apache.catalina.tribes.ChannelSender");
+
+            digester.addObjectCreate(channelPrefix + "Sender/Transport",
+                                     null, // MUST be specified in the element
+                                     "className");
+            digester.addSetProperties(channelPrefix + "Sender/Transport");
+            digester.addSetNext(channelPrefix + "Sender/Transport",
+                                "setTransport",
+                                "org.apache.catalina.tribes.transport.MultiPointSender");
+
+
+            digester.addObjectCreate(channelPrefix + "Receiver",
+                                     null, // MUST be specified in the element
+                                     "className");
+            digester.addSetProperties(channelPrefix + "Receiver");
+            digester.addSetNext(channelPrefix + "Receiver",
+                                "setChannelReceiver",
+                                "org.apache.catalina.tribes.ChannelReceiver");
+
+            digester.addObjectCreate(channelPrefix + "Interceptor",
+                                     null, // MUST be specified in the element
+                                     "className");
+            digester.addSetProperties(channelPrefix + "Interceptor");
+            digester.addSetNext(channelPrefix + "Interceptor",
+                                "addInterceptor",
+                                "org.apache.catalina.tribes.ChannelInterceptor");
+
+            
+            digester.addObjectCreate(channelPrefix + "Interceptor/Member",
+                                     null, // MUST be specified in the element
+                                     "className");
+            digester.addSetProperties(channelPrefix + "Interceptor/Member");
+            digester.addSetNext(channelPrefix + "Interceptor/Member",
+                                "addStaticMember",
+                                "org.apache.catalina.tribes.Member");
+        }
+
+        digester.addObjectCreate(prefix + "Valve",
+                                 null, // MUST be specified in the element
+                                 "className");
+        digester.addSetProperties(prefix + "Valve");
+        digester.addSetNext(prefix + "Valve",
+                            "addValve",
+                            "org.apache.catalina.Valve");
+        
+        digester.addObjectCreate(prefix + "Deployer",
+                                 null, // MUST be specified in the element
+                                 "className");
+        digester.addSetProperties(prefix + "Deployer");
+        digester.addSetNext(prefix + "Deployer",
+                            "setClusterDeployer",
+                            "org.apache.catalina.ha.ClusterDeployer");
+        
+        digester.addObjectCreate(prefix + "Listener",
+                null, // MUST be specified in the element
+                "className");
+        digester.addSetProperties(prefix + "Listener");
+        digester.addSetNext(prefix + "Listener",
+                            "addLifecycleListener",
+                            "org.apache.catalina.LifecycleListener");
+        
+        digester.addObjectCreate(prefix + "ClusterListener",
+                null, // MUST be specified in the element
+                "className");
+        digester.addSetProperties(prefix + "ClusterListener");
+        digester.addSetNext(prefix + "ClusterListener",
+                            "addClusterListener",
+                            "org.apache.catalina.ha.ClusterListener");
+        //Cluster configuration end
+    }
+
+}

==================================================
ClusterValve.java
index 6266c27957..40e3c931de 100644
--- a/java/org/apache/catalina/ha/ClusterSession.java
+++ b/java/org/apache/catalina/ha/ClusterSession.java
@@ -1,40 +1,40 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina.ha;
-
-import org.apache.catalina.Session;
-import javax.servlet.http.HttpSession;
-
-public interface ClusterSession extends Session, HttpSession {
-   /**
-    * returns true if this session is the primary session, if that is the
-    * case, the manager can expire it upon timeout.
-    * @return True if this session is primary
-    */
-   public boolean isPrimarySession();
-
-   /**
-    * Sets whether this is the primary session or not.
-    * @param primarySession Flag value
-    */
-   public void setPrimarySession(boolean primarySession);
-   
-   
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.catalina.ha;
+
+import org.apache.catalina.Session;
+import javax.servlet.http.HttpSession;
+
+public interface ClusterSession extends Session, HttpSession {
+   /**
+    * returns true if this session is the primary session, if that is the
+    * case, the manager can expire it upon timeout.
+    * @return True if this session is primary
+    */
+   public boolean isPrimarySession();
+
+   /**
+    * Sets whether this is the primary session or not.
+    * @param primarySession Flag value
+    */
+   public void setPrimarySession(boolean primarySession);
+   
+   
+
+}

==================================================
Constants.java
index 1add40ef3a..f2f268e9f3 100644
--- a/java/org/apache/catalina/ha/ClusterValve.java
+++ b/java/org/apache/catalina/ha/ClusterValve.java
@@ -1,40 +1,40 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.ha;
-
-import org.apache.catalina.Valve;
-
-/**
- * Cluster valves are a simple extension to the Tomcat valve architecture
- * with a small addition of being able to reference the cluster component in the container it sits in.
- * @author Filip Hanik
- * @author Peter Rossbach
- * @version $Revision: 303842 $, $Date: 2005-04-10 11:20:46 -0500 (Sun, 10 Apr 2005) $
- */
-public interface ClusterValve extends Valve{
-    /**
-     * Returns the cluster the cluster deployer is associated with
-     * @return CatalinaCluster
-     */
-    public CatalinaCluster getCluster();
-
-    /**
-     * Associates the cluster deployer with a cluster
-     * @param cluster CatalinaCluster
-     */
-    public void setCluster(CatalinaCluster cluster);
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.ha;
+
+import org.apache.catalina.Valve;
+
+/**
+ * Cluster valves are a simple extension to the Tomcat valve architecture
+ * with a small addition of being able to reference the cluster component in the container it sits in.
+ * @author Filip Hanik
+ * @author Peter Rossbach
+ * @version $Revision$, $Date$
+ */
+public interface ClusterValve extends Valve{
+    /**
+     * Returns the cluster the cluster deployer is associated with
+     * @return CatalinaCluster
+     */
+    public CatalinaCluster getCluster();
+
+    /**
+     * Associates the cluster deployer with a cluster
+     * @param cluster CatalinaCluster
+     */
+    public void setCluster(CatalinaCluster cluster);
+}

==================================================
ReplicatedContext.java
index c2221e5a9f..bbbf6ff97a 100644
--- a/java/org/apache/catalina/ha/Constants.java
+++ b/java/org/apache/catalina/ha/Constants.java
@@ -1,31 +1,31 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina.ha;
-
-/**
- * Manifest constants for the <code>org.apache.catalina.ha</code>
- * package.
- *
- * @author Bip Thelin
- * @version $Revision: 302726 $, $Date: 2004-02-27 08:59:07 -0600 (Fri, 27 Feb 2004) $
- */
-
-public final class Constants {
-    public static final String Package = "org.apache.catalina.ha";
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.catalina.ha;
+
+/**
+ * Manifest constants for the <code>org.apache.catalina.ha</code>
+ * package.
+ *
+ * @author Bip Thelin
+ * @version $Revision$, $Date$
+ */
+
+public final class Constants {
+    public static final String Package = "org.apache.catalina.ha";
+}

==================================================
FarmWarDeployer.java
index 35602a15f0..ec23373a8d 100644
--- a/java/org/apache/catalina/ha/context/ReplicatedContext.java
+++ b/java/org/apache/catalina/ha/context/ReplicatedContext.java
@@ -1,126 +1,126 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.ha.context;
-
-import org.apache.catalina.core.StandardContext;
-import org.apache.catalina.LifecycleException;
-import org.apache.catalina.ha.CatalinaCluster;
-import org.apache.catalina.tribes.tipis.ReplicatedMap;
-import org.apache.catalina.tribes.Channel;
-import org.apache.catalina.Loader;
-import org.apache.catalina.core.ApplicationContext;
-import org.apache.catalina.Globals;
-import javax.servlet.ServletContext;
-import java.util.HashMap;
-import org.apache.catalina.tribes.tipis.LazyReplicatedMap;
-
-/**
- * @author Filip Hanik
- * @version 1.0
- */
-public class ReplicatedContext extends StandardContext {
-    private int mapSendOptions = Channel.SEND_OPTIONS_DEFAULT;
-    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( ReplicatedContext.class );
-
-    protected static long DEFAULT_REPL_TIMEOUT = 15000;//15 seconds
-    
-
-
-    public synchronized void start() throws LifecycleException {
-        if ( this.started ) return;
-        try {
-            CatalinaCluster catclust = (CatalinaCluster)this.getCluster();
-            if (this.context == null) this.context = new ReplApplContext(this.getBasePath(), this);
-            if ( catclust != null ) {
-                ReplicatedMap map = new ReplicatedMap(this,catclust.getChannel(),DEFAULT_REPL_TIMEOUT,
-                                                      getName(),getClassLoaders());
-                map.setChannelSendOptions(mapSendOptions);
-                ((ReplApplContext)this.context).setAttributeMap(map);
-                if (getAltDDName() != null) context.setAttribute(Globals.ALT_DD_ATTR, getAltDDName());
-            }
-            super.start();
-        }  catch ( Exception x ) {
-            log.error("Unable to start ReplicatedContext",x);
-            throw new LifecycleException("Failed to start ReplicatedContext",x);
-        }
-    }
-    
-    public synchronized void stop() throws LifecycleException
-    {
-        ReplicatedMap map = (ReplicatedMap)((ReplApplContext)this.context).getAttributeMap();
-        if ( map!=null ) {
-            map.breakdown();
-        }
-        if ( !this.started ) return;
-        try {
-        } catch ( Exception x ){
-            log.error("Unable to stop ReplicatedContext",x);
-            throw new LifecycleException("Failed to stop ReplicatedContext",x);
-        } finally {
-            super.stop();
-        }
-
-    }
-
-
-    public void setMapSendOptions(int mapSendOptions) {
-        this.mapSendOptions = mapSendOptions;
-    }
-
-    public int getMapSendOptions() {
-        return mapSendOptions;
-    }
-    
-    public ClassLoader[] getClassLoaders() {
-        Loader loader = null;
-        ClassLoader classLoader = null;
-        loader = this.getLoader();
-        if (loader != null) classLoader = loader.getClassLoader();
-        if ( classLoader == null ) classLoader = Thread.currentThread().getContextClassLoader();
-        if ( classLoader == Thread.currentThread().getContextClassLoader() ) {
-            return new ClassLoader[] {classLoader};
-        } else {
-            return new ClassLoader[] {classLoader,Thread.currentThread().getContextClassLoader()};
-        }
-    }
-    
-    public ServletContext getServletContext() {
-        return ((ReplApplContext)context).getFacade();
-
-    }
-
-    
-    protected static class ReplApplContext extends ApplicationContext {
-        public ReplApplContext(String basePath, StandardContext context) {
-            super(basePath,context);
-        }
-        
-         protected ServletContext getFacade() {
-             return super.getFacade();
-        }
-        
-        public HashMap getAttributeMap() {
-            return (HashMap)this.attributes;
-        }
-        public void setAttributeMap(HashMap map) {
-            this.attributes = map;
-        }
-
-    }
-
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.ha.context;
+
+import org.apache.catalina.core.StandardContext;
+import org.apache.catalina.LifecycleException;
+import org.apache.catalina.ha.CatalinaCluster;
+import org.apache.catalina.tribes.tipis.ReplicatedMap;
+import org.apache.catalina.tribes.Channel;
+import org.apache.catalina.Loader;
+import org.apache.catalina.core.ApplicationContext;
+import org.apache.catalina.Globals;
+import javax.servlet.ServletContext;
+import java.util.HashMap;
+import org.apache.catalina.tribes.tipis.LazyReplicatedMap;
+
+/**
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class ReplicatedContext extends StandardContext {
+    private int mapSendOptions = Channel.SEND_OPTIONS_DEFAULT;
+    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( ReplicatedContext.class );
+
+    protected static long DEFAULT_REPL_TIMEOUT = 15000;//15 seconds
+    
+
+
+    public synchronized void start() throws LifecycleException {
+        if ( this.started ) return;
+        try {
+            CatalinaCluster catclust = (CatalinaCluster)this.getCluster();
+            if (this.context == null) this.context = new ReplApplContext(this.getBasePath(), this);
+            if ( catclust != null ) {
+                ReplicatedMap map = new ReplicatedMap(this,catclust.getChannel(),DEFAULT_REPL_TIMEOUT,
+                                                      getName(),getClassLoaders());
+                map.setChannelSendOptions(mapSendOptions);
+                ((ReplApplContext)this.context).setAttributeMap(map);
+                if (getAltDDName() != null) context.setAttribute(Globals.ALT_DD_ATTR, getAltDDName());
+            }
+            super.start();
+        }  catch ( Exception x ) {
+            log.error("Unable to start ReplicatedContext",x);
+            throw new LifecycleException("Failed to start ReplicatedContext",x);
+        }
+    }
+    
+    public synchronized void stop() throws LifecycleException
+    {
+        ReplicatedMap map = (ReplicatedMap)((ReplApplContext)this.context).getAttributeMap();
+        if ( map!=null ) {
+            map.breakdown();
+        }
+        if ( !this.started ) return;
+        try {
+        } catch ( Exception x ){
+            log.error("Unable to stop ReplicatedContext",x);
+            throw new LifecycleException("Failed to stop ReplicatedContext",x);
+        } finally {
+            super.stop();
+        }
+
+    }
+
+
+    public void setMapSendOptions(int mapSendOptions) {
+        this.mapSendOptions = mapSendOptions;
+    }
+
+    public int getMapSendOptions() {
+        return mapSendOptions;
+    }
+    
+    public ClassLoader[] getClassLoaders() {
+        Loader loader = null;
+        ClassLoader classLoader = null;
+        loader = this.getLoader();
+        if (loader != null) classLoader = loader.getClassLoader();
+        if ( classLoader == null ) classLoader = Thread.currentThread().getContextClassLoader();
+        if ( classLoader == Thread.currentThread().getContextClassLoader() ) {
+            return new ClassLoader[] {classLoader};
+        } else {
+            return new ClassLoader[] {classLoader,Thread.currentThread().getContextClassLoader()};
+        }
+    }
+    
+    public ServletContext getServletContext() {
+        return ((ReplApplContext)context).getFacade();
+
+    }
+
+    
+    protected static class ReplApplContext extends ApplicationContext {
+        public ReplApplContext(String basePath, StandardContext context) {
+            super(basePath,context);
+        }
+        
+         protected ServletContext getFacade() {
+             return super.getFacade();
+        }
+        
+        public HashMap getAttributeMap() {
+            return (HashMap)this.attributes;
+        }
+        public void setAttributeMap(HashMap map) {
+            this.attributes = map;
+        }
+
+    }
+
+
 }
\ No newline at end of file

==================================================
FileChangeListener.java
index dc17bb77f0..8d877a138f 100644
--- a/java/org/apache/catalina/ha/deploy/FarmWarDeployer.java
+++ b/java/org/apache/catalina/ha/deploy/FarmWarDeployer.java
@@ -1,747 +1,747 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha.deploy;
-
-import java.io.File;
-import java.io.IOException;
-import java.net.URL;
-import java.util.HashMap;
-import javax.management.MBeanServer;
-import javax.management.ObjectName;
-
-import org.apache.catalina.Context;
-import org.apache.catalina.Engine;
-import org.apache.catalina.Host;
-import org.apache.catalina.Lifecycle;
-import org.apache.catalina.LifecycleException;
-import org.apache.catalina.ha.CatalinaCluster;
-import org.apache.catalina.ha.ClusterDeployer;
-import org.apache.catalina.ha.ClusterListener;
-import org.apache.catalina.ha.ClusterMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.tomcat.util.modeler.Registry;
-
-
-/**
- * <p>
- * A farm war deployer is a class that is able to deploy/undeploy web
- * applications in WAR form within the cluster.
- * </p>
- * Any host can act as the admin, and will have three directories
- * <ul>
- * <li>deployDir - the directory where we watch for changes</li>
- * <li>applicationDir - the directory where we install applications</li>
- * <li>tempDir - a temporaryDirectory to store binary data when downloading a
- * war from the cluster</li>
- * </ul>
- * Currently we only support deployment of WAR files since they are easier to
- * send across the wire.
- * 
- * @author Filip Hanik
- * @author Peter Rossbach
- * @version $Revision: 390639 $
- */
-public class FarmWarDeployer extends ClusterListener implements ClusterDeployer, FileChangeListener {
-    /*--Static Variables----------------------------------------*/
-    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory
-            .getLog(FarmWarDeployer.class);
-    /**
-     * The descriptive information about this implementation.
-     */
-    private static final String info = "FarmWarDeployer/1.2";
-
-    /*--Instance Variables--------------------------------------*/
-    protected CatalinaCluster cluster = null;
-
-    protected boolean started = false; //default 5 seconds
-
-    protected HashMap fileFactories = new HashMap();
-
-    protected String deployDir;
-
-    protected String tempDir;
-
-    protected String watchDir;
-
-    protected boolean watchEnabled = false;
-
-    protected WarWatcher watcher = null;
-
-    /**
-     * Iteration count for background processing.
-     */
-    private int count = 0;
-
-    /**
-     * Frequency of the Farm watchDir check. Cluster wide deployment will be
-     * done once for the specified amount of backgrondProcess calls (ie, the
-     * lower the amount, the most often the checks will occur).
-     */
-    protected int processDeployFrequency = 2;
-
-    /**
-     * Path where context descriptors should be deployed.
-     */
-    protected File configBase = null;
-
-    /**
-     * The associated host.
-     */
-    protected Host host = null;
-
-    /**
-     * The host appBase.
-     */
-    protected File appBase = null;
-
-    /**
-     * MBean server.
-     */
-    protected MBeanServer mBeanServer = null;
-
-    /**
-     * The associated deployer ObjectName.
-     */
-    protected ObjectName oname = null;
-
-    /*--Constructor---------------------------------------------*/
-    public FarmWarDeployer() {
-    }
-
-    /**
-     * Return descriptive information about this deployer implementation and the
-     * corresponding version number, in the format
-     * <code>&lt;description&gt;/&lt;version&gt;</code>.
-     */
-    public String getInfo() {
-
-        return (info);
-
-    }
-
-    /*--Logic---------------------------------------------------*/
-    public void start() throws Exception {
-        if (started)
-            return;
-        getCluster().addClusterListener(this);
-        if (watchEnabled) {
-            watcher = new WarWatcher(this, new File(getWatchDir()));
-            if (log.isInfoEnabled())
-                log.info("Cluster deployment is watching " + getWatchDir()
-                         + " for changes.");
-        }
-    
-        // Check to correct engine and host setup
-        Object parent = getCluster().getContainer();
-        Engine engine = null;
-        if ( parent instanceof Host ) {
-            host = (Host) parent;
-            engine = (Engine) host.getParent();
-        }else {
-            engine = (Engine)parent;
-        }
-        try {
-            oname = new ObjectName(engine.getName() + ":type=Deployer,host="
-                    + host.getName());
-        } catch (Exception e) {
-            log.error("Can't construct MBean object name" + e);
-        }
-        configBase = new File(System.getProperty("catalina.base"), "conf");
-        if (engine != null) {
-            configBase = new File(configBase, engine.getName());
-        } else if (host != null) {
-            configBase = new File(configBase, host.getName());
-        }
-
-        // Retrieve the MBean server
-        mBeanServer = Registry.getRegistry(null, null).getMBeanServer();
-
-        started = true;
-        count = 0;
-        if (log.isInfoEnabled())
-            log.info("Cluster FarmWarDeployer started.");
-    }
-
-    /*
-     * stop cluster wide deployments
-     * 
-     * @see org.apache.catalina.ha.ClusterDeployer#stop()
-     */
-    public void stop() throws LifecycleException {
-        started = false;
-        getCluster().removeClusterListener(this);
-        count = 0;
-        if (watcher != null) {
-            watcher.clear();
-            watcher = null;
-
-        }
-        if (log.isInfoEnabled())
-            log.info("Cluster FarmWarDeployer stopped.");
-    }
-
-    public void cleanDeployDir() {
-        throw new java.lang.UnsupportedOperationException(
-                "Method cleanDeployDir() not yet implemented.");
-    }
-
-    /**
-     * Callback from the cluster, when a message is received, The cluster will
-     * broadcast it invoking the messageReceived on the receiver.
-     * 
-     * @param msg
-     *            ClusterMessage - the message received from the cluster
-     */
-    public void messageReceived(ClusterMessage msg) {
-        try {
-            if (msg instanceof FileMessage && msg != null) {
-                FileMessage fmsg = (FileMessage) msg;
-                if (log.isDebugEnabled())
-                    log.debug("receive cluster deployment [ path: "
-                            + fmsg.getContextPath() + " war:  "
-                            + fmsg.getFileName() + " ]");
-                FileMessageFactory factory = getFactory(fmsg);
-                // TODO correct second try after app is in service!
-                if (factory.writeMessage(fmsg)) {
-                    //last message received war file is completed
-                    String name = factory.getFile().getName();
-                    if (!name.endsWith(".war"))
-                        name = name + ".war";
-                    File deployable = new File(getDeployDir(), name);
-                    try {
-                        String path = fmsg.getContextPath();
-                        if (!isServiced(path)) {
-                            addServiced(path);
-                            try {
-                                remove(path);
-                                factory.getFile().renameTo(deployable);
-                                check(path);
-                            } finally {
-                                removeServiced(path);
-                            }
-                            if (log.isDebugEnabled())
-                                log.debug("deployment from " + path
-                                        + " finished.");
-                        } else
-                            log.error("Application " + path
-                                    + " in used. touch war file " + name
-                                    + " again!");
-                    } catch (Exception ex) {
-                        log.error(ex);
-                    } finally {
-                        removeFactory(fmsg);
-                    }
-                }
-            } else if (msg instanceof UndeployMessage && msg != null) {
-                try {
-                    UndeployMessage umsg = (UndeployMessage) msg;
-                    String path = umsg.getContextPath();
-                    if (log.isDebugEnabled())
-                        log.debug("receive cluster undeployment from " + path);
-                    if (!isServiced(path)) {
-                        addServiced(path);
-                        try {
-                            remove(path);
-                        } finally {
-                            removeServiced(path);
-                        }
-                        if (log.isDebugEnabled())
-                            log.debug("undeployment from " + path
-                                    + " finished.");
-                    } else
-                        log.error("Application "
-                            + path
-                            + " in used. Sorry not remove from backup cluster nodes!");
-                } catch (Exception ex) {
-                    log.error(ex);
-                }
-            }
-        } catch (java.io.IOException x) {
-            log.error("Unable to read farm deploy file message.", x);
-        }
-    }
-
-    /**
-     * create factory for all transported war files
-     * 
-     * @param msg
-     * @return Factory for all app message (war files)
-     * @throws java.io.FileNotFoundException
-     * @throws java.io.IOException
-     */
-    public synchronized FileMessageFactory getFactory(FileMessage msg)
-            throws java.io.FileNotFoundException, java.io.IOException {
-        File tmpFile = new File(msg.getFileName());
-        File writeToFile = new File(getTempDir(), tmpFile.getName());
-        FileMessageFactory factory = (FileMessageFactory) fileFactories.get(msg
-                .getFileName());
-        if (factory == null) {
-            factory = FileMessageFactory.getInstance(writeToFile, true);
-            fileFactories.put(msg.getFileName(), factory);
-        }
-        return factory;
-    }
-
-    /**
-     * Remove file (war) from messages)
-     * 
-     * @param msg
-     */
-    public void removeFactory(FileMessage msg) {
-        fileFactories.remove(msg.getFileName());
-    }
-
-    /**
-     * Before the cluster invokes messageReceived the cluster will ask the
-     * receiver to accept or decline the message, In the future, when messages
-     * get big, the accept method will only take a message header
-     * 
-     * @param msg
-     *            ClusterMessage
-     * @return boolean - returns true to indicate that messageReceived should be
-     *         invoked. If false is returned, the messageReceived method will
-     *         not be invoked.
-     */
-    public boolean accept(ClusterMessage msg) {
-        return (msg instanceof FileMessage) || (msg instanceof UndeployMessage);
-    }
-
-    /**
-     * Install a new web application, whose web application archive is at the
-     * specified URL, into this container and all the other members of the
-     * cluster with the specified context path. A context path of "" (the empty
-     * string) should be used for the root application for this container.
-     * Otherwise, the context path must start with a slash.
-     * <p>
-     * If this application is successfully installed locally, a ContainerEvent
-     * of type <code>INSTALL_EVENT</code> will be sent to all registered
-     * listeners, with the newly created <code>Context</code> as an argument.
-     * 
-     * @param contextPath
-     *            The context path to which this application should be installed
-     *            (must be unique)
-     * @param war
-     *            A URL of type "jar:" that points to a WAR file, or type
-     *            "file:" that points to an unpacked directory structure
-     *            containing the web application to be installed
-     * 
-     * @exception IllegalArgumentException
-     *                if the specified context path is malformed (it must be ""
-     *                or start with a slash)
-     * @exception IllegalStateException
-     *                if the specified context path is already attached to an
-     *                existing web application
-     * @exception IOException
-     *                if an input/output error was encountered during
-     *                installation
-     */
-    public void install(String contextPath, URL war) throws IOException {
-        Member[] members = getCluster().getMembers();
-        Member localMember = getCluster().getLocalMember();
-        FileMessageFactory factory = FileMessageFactory.getInstance(new File(
-                war.getFile()), false);
-        FileMessage msg = new FileMessage(localMember, war.getFile(),
-                contextPath);
-        if(log.isDebugEnabled())
-            log.debug("Send cluster war deployment [ path:"
-                    + contextPath + " war: " + war + " ] started.");
-        msg = factory.readMessage(msg);
-        while (msg != null) {
-            for (int i = 0; i < members.length; i++) {
-                if (log.isDebugEnabled())
-                    log.debug("Send cluster war fragment [ path: "
-                            + contextPath + " war: " + war + " to: " +  members[i] + " ]");
-                getCluster().send(msg, members[i]);
-            }
-            msg = factory.readMessage(msg);
-        }
-        if(log.isDebugEnabled())
-            log.debug("Send cluster war deployment [ path: "
-                    + contextPath + " war: " + war + " ] finished.");
-    }
-
-    /**
-     * Remove an existing web application, attached to the specified context
-     * path. If this application is successfully removed, a ContainerEvent of
-     * type <code>REMOVE_EVENT</code> will be sent to all registered
-     * listeners, with the removed <code>Context</code> as an argument.
-     * Deletes the web application war file and/or directory if they exist in
-     * the Host's appBase.
-     * 
-     * @param contextPath
-     *            The context path of the application to be removed
-     * @param undeploy
-     *            boolean flag to remove web application from server
-     * 
-     * @exception IllegalArgumentException
-     *                if the specified context path is malformed (it must be ""
-     *                or start with a slash)
-     * @exception IllegalArgumentException
-     *                if the specified context path does not identify a
-     *                currently installed web application
-     * @exception IOException
-     *                if an input/output error occurs during removal
-     */
-    public void remove(String contextPath, boolean undeploy) throws IOException {
-        if (log.isInfoEnabled())
-            log.info("Cluster wide remove of web app " + contextPath);
-        Member localMember = getCluster().getLocalMember();
-        UndeployMessage msg = new UndeployMessage(localMember, System
-                .currentTimeMillis(), "Undeploy:" + contextPath + ":"
-                + System.currentTimeMillis(), contextPath, undeploy);
-        if (log.isDebugEnabled())
-            log.debug("Send cluster wide undeployment from "
-                    + contextPath );
-        cluster.send(msg);
-        // remove locally
-        if (undeploy) {
-            try {
-                if (!isServiced(contextPath)) {
-                    addServiced(contextPath);
-                    try {
-                        remove(contextPath);
-                    } finally {
-                        removeServiced(contextPath);
-                    }
-                } else
-                    log.error("Local remove from " + contextPath
-                            + "failed, other manager has app in service!");
-
-            } catch (Exception ex) {
-                log.error("local remove from " + contextPath + " failed", ex);
-            }
-        }
-
-    }
-
-    /*
-     * Modifcation from watchDir war detected!
-     * 
-     * @see org.apache.catalina.ha.deploy.FileChangeListener#fileModified(java.io.File)
-     */
-    public void fileModified(File newWar) {
-        try {
-            File deployWar = new File(getDeployDir(), newWar.getName());
-            copy(newWar, deployWar);
-            String contextName = getContextName(deployWar);
-            if (log.isInfoEnabled())
-                log.info("Installing webapp[" + contextName + "] from "
-                        + deployWar.getAbsolutePath());
-            try {
-                remove(contextName, false);
-            } catch (Exception x) {
-                log.error("No removal", x);
-            }
-            install(contextName, deployWar.toURL());
-        } catch (Exception x) {
-            log.error("Unable to install WAR file", x);
-        }
-    }
-
-    /*
-     * War remvoe from watchDir
-     * 
-     * @see org.apache.catalina.ha.deploy.FileChangeListener#fileRemoved(java.io.File)
-     */
-    public void fileRemoved(File removeWar) {
-        try {
-            String contextName = getContextName(removeWar);
-            if (log.isInfoEnabled())
-                log.info("Removing webapp[" + contextName + "]");
-            remove(contextName, true);
-        } catch (Exception x) {
-            log.error("Unable to remove WAR file", x);
-        }
-    }
-
-    /**
-     * Create a context path from war
-     * @param war War filename
-     * @return '/filename' or if war name is ROOT.war context name is empty string '' 
-     */
-    protected String getContextName(File war) {
-        String contextName = "/"
-        + war.getName().substring(0,
-                war.getName().lastIndexOf(".war"));
-        if("/ROOT".equals(contextName))
-            contextName= "" ;
-        return contextName ;
-    }
-    
-    /**
-     * Given a context path, get the config file name.
-     */
-    protected String getConfigFile(String path) {
-        String basename = null;
-        if (path.equals("")) {
-            basename = "ROOT";
-        } else {
-            basename = path.substring(1).replace('/', '#');
-        }
-        return (basename);
-    }
-
-    /**
-     * Given a context path, get the config file name.
-     */
-    protected String getDocBase(String path) {
-        String basename = null;
-        if (path.equals("")) {
-            basename = "ROOT";
-        } else {
-            basename = path.substring(1);
-        }
-        return (basename);
-    }
-
-    /**
-     * Return a File object representing the "application root" directory for
-     * our associated Host.
-     */
-    protected File getAppBase() {
-
-        if (appBase != null) {
-            return appBase;
-        }
-
-        File file = new File(host.getAppBase());
-        if (!file.isAbsolute())
-            file = new File(System.getProperty("catalina.base"), host
-                    .getAppBase());
-        try {
-            appBase = file.getCanonicalFile();
-        } catch (IOException e) {
-            appBase = file;
-        }
-        return (appBase);
-
-    }
-
-    /**
-     * Invoke the remove method on the deployer.
-     */
-    protected void remove(String path) throws Exception {
-        // TODO Handle remove also work dir content !
-        // Stop the context first to be nicer
-        Context context = (Context) host.findChild(path);
-        if (context != null) {
-            if(log.isDebugEnabled())
-                log.debug("Undeploy local context " +path );
-            ((Lifecycle) context).stop();
-            File war = new File(getAppBase(), getDocBase(path) + ".war");
-            File dir = new File(getAppBase(), getDocBase(path));
-            File xml = new File(configBase, getConfigFile(path) + ".xml");
-            if (war.exists()) {
-                war.delete();
-            } else if (dir.exists()) {
-                undeployDir(dir);
-            } else {
-                xml.delete();
-            }
-            // Perform new deployment and remove internal HostConfig state
-            check(path);
-        }
-
-    }
-
-    /**
-     * Delete the specified directory, including all of its contents and
-     * subdirectories recursively.
-     * 
-     * @param dir
-     *            File object representing the directory to be deleted
-     */
-    protected void undeployDir(File dir) {
-
-        String files[] = dir.list();
-        if (files == null) {
-            files = new String[0];
-        }
-        for (int i = 0; i < files.length; i++) {
-            File file = new File(dir, files[i]);
-            if (file.isDirectory()) {
-                undeployDir(file);
-            } else {
-                file.delete();
-            }
-        }
-        dir.delete();
-
-    }
-
-    /*
-     * Call watcher to check for deploy changes
-     * 
-     * @see org.apache.catalina.ha.ClusterDeployer#backgroundProcess()
-     */
-    public void backgroundProcess() {
-        if (started) {
-            count = (count + 1) % processDeployFrequency;
-            if (count == 0 && watchEnabled) {
-                watcher.check();
-            }
-        }
-
-    }
-
-    /*--Deployer Operations ------------------------------------*/
-
-    /**
-     * Invoke the check method on the deployer.
-     */
-    protected void check(String name) throws Exception {
-        String[] params = { name };
-        String[] signature = { "java.lang.String" };
-        mBeanServer.invoke(oname, "check", params, signature);
-    }
-
-    /**
-     * Invoke the check method on the deployer.
-     */
-    protected boolean isServiced(String name) throws Exception {
-        String[] params = { name };
-        String[] signature = { "java.lang.String" };
-        Boolean result = (Boolean) mBeanServer.invoke(oname, "isServiced",
-                params, signature);
-        return result.booleanValue();
-    }
-
-    /**
-     * Invoke the check method on the deployer.
-     */
-    protected void addServiced(String name) throws Exception {
-        String[] params = { name };
-        String[] signature = { "java.lang.String" };
-        mBeanServer.invoke(oname, "addServiced", params, signature);
-    }
-
-    /**
-     * Invoke the check method on the deployer.
-     */
-    protected void removeServiced(String name) throws Exception {
-        String[] params = { name };
-        String[] signature = { "java.lang.String" };
-        mBeanServer.invoke(oname, "removeServiced", params, signature);
-    }
-
-    /*--Instance Getters/Setters--------------------------------*/
-    public CatalinaCluster getCluster() {
-        return cluster;
-    }
-
-    public void setCluster(CatalinaCluster cluster) {
-        this.cluster = cluster;
-    }
-
-    public boolean equals(Object listener) {
-        return super.equals(listener);
-    }
-
-    public int hashCode() {
-        return super.hashCode();
-    }
-
-    public String getDeployDir() {
-        return deployDir;
-    }
-
-    public void setDeployDir(String deployDir) {
-        this.deployDir = deployDir;
-    }
-
-    public String getTempDir() {
-        return tempDir;
-    }
-
-    public void setTempDir(String tempDir) {
-        this.tempDir = tempDir;
-    }
-
-    public String getWatchDir() {
-        return watchDir;
-    }
-
-    public void setWatchDir(String watchDir) {
-        this.watchDir = watchDir;
-    }
-
-    public boolean isWatchEnabled() {
-        return watchEnabled;
-    }
-
-    public boolean getWatchEnabled() {
-        return watchEnabled;
-    }
-
-    public void setWatchEnabled(boolean watchEnabled) {
-        this.watchEnabled = watchEnabled;
-    }
-
-    /**
-     * Return the frequency of watcher checks.
-     */
-    public int getProcessDeployFrequency() {
-
-        return (this.processDeployFrequency);
-
-    }
-
-    /**
-     * Set the watcher checks frequency.
-     * 
-     * @param processExpiresFrequency
-     *            the new manager checks frequency
-     */
-    public void setProcessDeployFrequency(int processExpiresFrequency) {
-
-        if (processExpiresFrequency <= 0) {
-            return;
-        }
-        this.processDeployFrequency = processExpiresFrequency;
-    }
-
-    /**
-     * Copy a file to the specified temp directory.
-     * @param from copy from temp
-     * @param to   to host appBase directory
-     * @return true, copy successful
-     */
-    protected boolean copy(File from, File to) {
-        try {
-            if (!to.exists())
-                to.createNewFile();
-            java.io.FileInputStream is = new java.io.FileInputStream(from);
-            java.io.FileOutputStream os = new java.io.FileOutputStream(to,
-                    false);
-            byte[] buf = new byte[4096];
-            while (true) {
-                int len = is.read(buf);
-                if (len < 0)
-                    break;
-                os.write(buf, 0, len);
-            }
-            is.close();
-            os.close();
-        } catch (IOException e) {
-            log.error("Unable to copy file from:" + from + " to:" + to, e);
-            return false;
-        }
-        return true;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha.deploy;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.URL;
+import java.util.HashMap;
+import javax.management.MBeanServer;
+import javax.management.ObjectName;
+
+import org.apache.catalina.Context;
+import org.apache.catalina.Engine;
+import org.apache.catalina.Host;
+import org.apache.catalina.Lifecycle;
+import org.apache.catalina.LifecycleException;
+import org.apache.catalina.ha.CatalinaCluster;
+import org.apache.catalina.ha.ClusterDeployer;
+import org.apache.catalina.ha.ClusterListener;
+import org.apache.catalina.ha.ClusterMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.tomcat.util.modeler.Registry;
+
+
+/**
+ * <p>
+ * A farm war deployer is a class that is able to deploy/undeploy web
+ * applications in WAR form within the cluster.
+ * </p>
+ * Any host can act as the admin, and will have three directories
+ * <ul>
+ * <li>deployDir - the directory where we watch for changes</li>
+ * <li>applicationDir - the directory where we install applications</li>
+ * <li>tempDir - a temporaryDirectory to store binary data when downloading a
+ * war from the cluster</li>
+ * </ul>
+ * Currently we only support deployment of WAR files since they are easier to
+ * send across the wire.
+ * 
+ * @author Filip Hanik
+ * @author Peter Rossbach
+ * @version $Revision$
+ */
+public class FarmWarDeployer extends ClusterListener implements ClusterDeployer, FileChangeListener {
+    /*--Static Variables----------------------------------------*/
+    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory
+            .getLog(FarmWarDeployer.class);
+    /**
+     * The descriptive information about this implementation.
+     */
+    private static final String info = "FarmWarDeployer/1.2";
+
+    /*--Instance Variables--------------------------------------*/
+    protected CatalinaCluster cluster = null;
+
+    protected boolean started = false; //default 5 seconds
+
+    protected HashMap fileFactories = new HashMap();
+
+    protected String deployDir;
+
+    protected String tempDir;
+
+    protected String watchDir;
+
+    protected boolean watchEnabled = false;
+
+    protected WarWatcher watcher = null;
+
+    /**
+     * Iteration count for background processing.
+     */
+    private int count = 0;
+
+    /**
+     * Frequency of the Farm watchDir check. Cluster wide deployment will be
+     * done once for the specified amount of backgrondProcess calls (ie, the
+     * lower the amount, the most often the checks will occur).
+     */
+    protected int processDeployFrequency = 2;
+
+    /**
+     * Path where context descriptors should be deployed.
+     */
+    protected File configBase = null;
+
+    /**
+     * The associated host.
+     */
+    protected Host host = null;
+
+    /**
+     * The host appBase.
+     */
+    protected File appBase = null;
+
+    /**
+     * MBean server.
+     */
+    protected MBeanServer mBeanServer = null;
+
+    /**
+     * The associated deployer ObjectName.
+     */
+    protected ObjectName oname = null;
+
+    /*--Constructor---------------------------------------------*/
+    public FarmWarDeployer() {
+    }
+
+    /**
+     * Return descriptive information about this deployer implementation and the
+     * corresponding version number, in the format
+     * <code>&lt;description&gt;/&lt;version&gt;</code>.
+     */
+    public String getInfo() {
+
+        return (info);
+
+    }
+
+    /*--Logic---------------------------------------------------*/
+    public void start() throws Exception {
+        if (started)
+            return;
+        getCluster().addClusterListener(this);
+        if (watchEnabled) {
+            watcher = new WarWatcher(this, new File(getWatchDir()));
+            if (log.isInfoEnabled())
+                log.info("Cluster deployment is watching " + getWatchDir()
+                         + " for changes.");
+        }
+    
+        // Check to correct engine and host setup
+        Object parent = getCluster().getContainer();
+        Engine engine = null;
+        if ( parent instanceof Host ) {
+            host = (Host) parent;
+            engine = (Engine) host.getParent();
+        }else {
+            engine = (Engine)parent;
+        }
+        try {
+            oname = new ObjectName(engine.getName() + ":type=Deployer,host="
+                    + host.getName());
+        } catch (Exception e) {
+            log.error("Can't construct MBean object name" + e);
+        }
+        configBase = new File(System.getProperty("catalina.base"), "conf");
+        if (engine != null) {
+            configBase = new File(configBase, engine.getName());
+        } else if (host != null) {
+            configBase = new File(configBase, host.getName());
+        }
+
+        // Retrieve the MBean server
+        mBeanServer = Registry.getRegistry(null, null).getMBeanServer();
+
+        started = true;
+        count = 0;
+        if (log.isInfoEnabled())
+            log.info("Cluster FarmWarDeployer started.");
+    }
+
+    /*
+     * stop cluster wide deployments
+     * 
+     * @see org.apache.catalina.ha.ClusterDeployer#stop()
+     */
+    public void stop() throws LifecycleException {
+        started = false;
+        getCluster().removeClusterListener(this);
+        count = 0;
+        if (watcher != null) {
+            watcher.clear();
+            watcher = null;
+
+        }
+        if (log.isInfoEnabled())
+            log.info("Cluster FarmWarDeployer stopped.");
+    }
+
+    public void cleanDeployDir() {
+        throw new java.lang.UnsupportedOperationException(
+                "Method cleanDeployDir() not yet implemented.");
+    }
+
+    /**
+     * Callback from the cluster, when a message is received, The cluster will
+     * broadcast it invoking the messageReceived on the receiver.
+     * 
+     * @param msg
+     *            ClusterMessage - the message received from the cluster
+     */
+    public void messageReceived(ClusterMessage msg) {
+        try {
+            if (msg instanceof FileMessage && msg != null) {
+                FileMessage fmsg = (FileMessage) msg;
+                if (log.isDebugEnabled())
+                    log.debug("receive cluster deployment [ path: "
+                            + fmsg.getContextPath() + " war:  "
+                            + fmsg.getFileName() + " ]");
+                FileMessageFactory factory = getFactory(fmsg);
+                // TODO correct second try after app is in service!
+                if (factory.writeMessage(fmsg)) {
+                    //last message received war file is completed
+                    String name = factory.getFile().getName();
+                    if (!name.endsWith(".war"))
+                        name = name + ".war";
+                    File deployable = new File(getDeployDir(), name);
+                    try {
+                        String path = fmsg.getContextPath();
+                        if (!isServiced(path)) {
+                            addServiced(path);
+                            try {
+                                remove(path);
+                                factory.getFile().renameTo(deployable);
+                                check(path);
+                            } finally {
+                                removeServiced(path);
+                            }
+                            if (log.isDebugEnabled())
+                                log.debug("deployment from " + path
+                                        + " finished.");
+                        } else
+                            log.error("Application " + path
+                                    + " in used. touch war file " + name
+                                    + " again!");
+                    } catch (Exception ex) {
+                        log.error(ex);
+                    } finally {
+                        removeFactory(fmsg);
+                    }
+                }
+            } else if (msg instanceof UndeployMessage && msg != null) {
+                try {
+                    UndeployMessage umsg = (UndeployMessage) msg;
+                    String path = umsg.getContextPath();
+                    if (log.isDebugEnabled())
+                        log.debug("receive cluster undeployment from " + path);
+                    if (!isServiced(path)) {
+                        addServiced(path);
+                        try {
+                            remove(path);
+                        } finally {
+                            removeServiced(path);
+                        }
+                        if (log.isDebugEnabled())
+                            log.debug("undeployment from " + path
+                                    + " finished.");
+                    } else
+                        log.error("Application "
+                            + path
+                            + " in used. Sorry not remove from backup cluster nodes!");
+                } catch (Exception ex) {
+                    log.error(ex);
+                }
+            }
+        } catch (java.io.IOException x) {
+            log.error("Unable to read farm deploy file message.", x);
+        }
+    }
+
+    /**
+     * create factory for all transported war files
+     * 
+     * @param msg
+     * @return Factory for all app message (war files)
+     * @throws java.io.FileNotFoundException
+     * @throws java.io.IOException
+     */
+    public synchronized FileMessageFactory getFactory(FileMessage msg)
+            throws java.io.FileNotFoundException, java.io.IOException {
+        File tmpFile = new File(msg.getFileName());
+        File writeToFile = new File(getTempDir(), tmpFile.getName());
+        FileMessageFactory factory = (FileMessageFactory) fileFactories.get(msg
+                .getFileName());
+        if (factory == null) {
+            factory = FileMessageFactory.getInstance(writeToFile, true);
+            fileFactories.put(msg.getFileName(), factory);
+        }
+        return factory;
+    }
+
+    /**
+     * Remove file (war) from messages)
+     * 
+     * @param msg
+     */
+    public void removeFactory(FileMessage msg) {
+        fileFactories.remove(msg.getFileName());
+    }
+
+    /**
+     * Before the cluster invokes messageReceived the cluster will ask the
+     * receiver to accept or decline the message, In the future, when messages
+     * get big, the accept method will only take a message header
+     * 
+     * @param msg
+     *            ClusterMessage
+     * @return boolean - returns true to indicate that messageReceived should be
+     *         invoked. If false is returned, the messageReceived method will
+     *         not be invoked.
+     */
+    public boolean accept(ClusterMessage msg) {
+        return (msg instanceof FileMessage) || (msg instanceof UndeployMessage);
+    }
+
+    /**
+     * Install a new web application, whose web application archive is at the
+     * specified URL, into this container and all the other members of the
+     * cluster with the specified context path. A context path of "" (the empty
+     * string) should be used for the root application for this container.
+     * Otherwise, the context path must start with a slash.
+     * <p>
+     * If this application is successfully installed locally, a ContainerEvent
+     * of type <code>INSTALL_EVENT</code> will be sent to all registered
+     * listeners, with the newly created <code>Context</code> as an argument.
+     * 
+     * @param contextPath
+     *            The context path to which this application should be installed
+     *            (must be unique)
+     * @param war
+     *            A URL of type "jar:" that points to a WAR file, or type
+     *            "file:" that points to an unpacked directory structure
+     *            containing the web application to be installed
+     * 
+     * @exception IllegalArgumentException
+     *                if the specified context path is malformed (it must be ""
+     *                or start with a slash)
+     * @exception IllegalStateException
+     *                if the specified context path is already attached to an
+     *                existing web application
+     * @exception IOException
+     *                if an input/output error was encountered during
+     *                installation
+     */
+    public void install(String contextPath, URL war) throws IOException {
+        Member[] members = getCluster().getMembers();
+        Member localMember = getCluster().getLocalMember();
+        FileMessageFactory factory = FileMessageFactory.getInstance(new File(
+                war.getFile()), false);
+        FileMessage msg = new FileMessage(localMember, war.getFile(),
+                contextPath);
+        if(log.isDebugEnabled())
+            log.debug("Send cluster war deployment [ path:"
+                    + contextPath + " war: " + war + " ] started.");
+        msg = factory.readMessage(msg);
+        while (msg != null) {
+            for (int i = 0; i < members.length; i++) {
+                if (log.isDebugEnabled())
+                    log.debug("Send cluster war fragment [ path: "
+                            + contextPath + " war: " + war + " to: " +  members[i] + " ]");
+                getCluster().send(msg, members[i]);
+            }
+            msg = factory.readMessage(msg);
+        }
+        if(log.isDebugEnabled())
+            log.debug("Send cluster war deployment [ path: "
+                    + contextPath + " war: " + war + " ] finished.");
+    }
+
+    /**
+     * Remove an existing web application, attached to the specified context
+     * path. If this application is successfully removed, a ContainerEvent of
+     * type <code>REMOVE_EVENT</code> will be sent to all registered
+     * listeners, with the removed <code>Context</code> as an argument.
+     * Deletes the web application war file and/or directory if they exist in
+     * the Host's appBase.
+     * 
+     * @param contextPath
+     *            The context path of the application to be removed
+     * @param undeploy
+     *            boolean flag to remove web application from server
+     * 
+     * @exception IllegalArgumentException
+     *                if the specified context path is malformed (it must be ""
+     *                or start with a slash)
+     * @exception IllegalArgumentException
+     *                if the specified context path does not identify a
+     *                currently installed web application
+     * @exception IOException
+     *                if an input/output error occurs during removal
+     */
+    public void remove(String contextPath, boolean undeploy) throws IOException {
+        if (log.isInfoEnabled())
+            log.info("Cluster wide remove of web app " + contextPath);
+        Member localMember = getCluster().getLocalMember();
+        UndeployMessage msg = new UndeployMessage(localMember, System
+                .currentTimeMillis(), "Undeploy:" + contextPath + ":"
+                + System.currentTimeMillis(), contextPath, undeploy);
+        if (log.isDebugEnabled())
+            log.debug("Send cluster wide undeployment from "
+                    + contextPath );
+        cluster.send(msg);
+        // remove locally
+        if (undeploy) {
+            try {
+                if (!isServiced(contextPath)) {
+                    addServiced(contextPath);
+                    try {
+                        remove(contextPath);
+                    } finally {
+                        removeServiced(contextPath);
+                    }
+                } else
+                    log.error("Local remove from " + contextPath
+                            + "failed, other manager has app in service!");
+
+            } catch (Exception ex) {
+                log.error("local remove from " + contextPath + " failed", ex);
+            }
+        }
+
+    }
+
+    /*
+     * Modifcation from watchDir war detected!
+     * 
+     * @see org.apache.catalina.ha.deploy.FileChangeListener#fileModified(java.io.File)
+     */
+    public void fileModified(File newWar) {
+        try {
+            File deployWar = new File(getDeployDir(), newWar.getName());
+            copy(newWar, deployWar);
+            String contextName = getContextName(deployWar);
+            if (log.isInfoEnabled())
+                log.info("Installing webapp[" + contextName + "] from "
+                        + deployWar.getAbsolutePath());
+            try {
+                remove(contextName, false);
+            } catch (Exception x) {
+                log.error("No removal", x);
+            }
+            install(contextName, deployWar.toURL());
+        } catch (Exception x) {
+            log.error("Unable to install WAR file", x);
+        }
+    }
+
+    /*
+     * War remvoe from watchDir
+     * 
+     * @see org.apache.catalina.ha.deploy.FileChangeListener#fileRemoved(java.io.File)
+     */
+    public void fileRemoved(File removeWar) {
+        try {
+            String contextName = getContextName(removeWar);
+            if (log.isInfoEnabled())
+                log.info("Removing webapp[" + contextName + "]");
+            remove(contextName, true);
+        } catch (Exception x) {
+            log.error("Unable to remove WAR file", x);
+        }
+    }
+
+    /**
+     * Create a context path from war
+     * @param war War filename
+     * @return '/filename' or if war name is ROOT.war context name is empty string '' 
+     */
+    protected String getContextName(File war) {
+        String contextName = "/"
+        + war.getName().substring(0,
+                war.getName().lastIndexOf(".war"));
+        if("/ROOT".equals(contextName))
+            contextName= "" ;
+        return contextName ;
+    }
+    
+    /**
+     * Given a context path, get the config file name.
+     */
+    protected String getConfigFile(String path) {
+        String basename = null;
+        if (path.equals("")) {
+            basename = "ROOT";
+        } else {
+            basename = path.substring(1).replace('/', '#');
+        }
+        return (basename);
+    }
+
+    /**
+     * Given a context path, get the config file name.
+     */
+    protected String getDocBase(String path) {
+        String basename = null;
+        if (path.equals("")) {
+            basename = "ROOT";
+        } else {
+            basename = path.substring(1);
+        }
+        return (basename);
+    }
+
+    /**
+     * Return a File object representing the "application root" directory for
+     * our associated Host.
+     */
+    protected File getAppBase() {
+
+        if (appBase != null) {
+            return appBase;
+        }
+
+        File file = new File(host.getAppBase());
+        if (!file.isAbsolute())
+            file = new File(System.getProperty("catalina.base"), host
+                    .getAppBase());
+        try {
+            appBase = file.getCanonicalFile();
+        } catch (IOException e) {
+            appBase = file;
+        }
+        return (appBase);
+
+    }
+
+    /**
+     * Invoke the remove method on the deployer.
+     */
+    protected void remove(String path) throws Exception {
+        // TODO Handle remove also work dir content !
+        // Stop the context first to be nicer
+        Context context = (Context) host.findChild(path);
+        if (context != null) {
+            if(log.isDebugEnabled())
+                log.debug("Undeploy local context " +path );
+            ((Lifecycle) context).stop();
+            File war = new File(getAppBase(), getDocBase(path) + ".war");
+            File dir = new File(getAppBase(), getDocBase(path));
+            File xml = new File(configBase, getConfigFile(path) + ".xml");
+            if (war.exists()) {
+                war.delete();
+            } else if (dir.exists()) {
+                undeployDir(dir);
+            } else {
+                xml.delete();
+            }
+            // Perform new deployment and remove internal HostConfig state
+            check(path);
+        }
+
+    }
+
+    /**
+     * Delete the specified directory, including all of its contents and
+     * subdirectories recursively.
+     * 
+     * @param dir
+     *            File object representing the directory to be deleted
+     */
+    protected void undeployDir(File dir) {
+
+        String files[] = dir.list();
+        if (files == null) {
+            files = new String[0];
+        }
+        for (int i = 0; i < files.length; i++) {
+            File file = new File(dir, files[i]);
+            if (file.isDirectory()) {
+                undeployDir(file);
+            } else {
+                file.delete();
+            }
+        }
+        dir.delete();
+
+    }
+
+    /*
+     * Call watcher to check for deploy changes
+     * 
+     * @see org.apache.catalina.ha.ClusterDeployer#backgroundProcess()
+     */
+    public void backgroundProcess() {
+        if (started) {
+            count = (count + 1) % processDeployFrequency;
+            if (count == 0 && watchEnabled) {
+                watcher.check();
+            }
+        }
+
+    }
+
+    /*--Deployer Operations ------------------------------------*/
+
+    /**
+     * Invoke the check method on the deployer.
+     */
+    protected void check(String name) throws Exception {
+        String[] params = { name };
+        String[] signature = { "java.lang.String" };
+        mBeanServer.invoke(oname, "check", params, signature);
+    }
+
+    /**
+     * Invoke the check method on the deployer.
+     */
+    protected boolean isServiced(String name) throws Exception {
+        String[] params = { name };
+        String[] signature = { "java.lang.String" };
+        Boolean result = (Boolean) mBeanServer.invoke(oname, "isServiced",
+                params, signature);
+        return result.booleanValue();
+    }
+
+    /**
+     * Invoke the check method on the deployer.
+     */
+    protected void addServiced(String name) throws Exception {
+        String[] params = { name };
+        String[] signature = { "java.lang.String" };
+        mBeanServer.invoke(oname, "addServiced", params, signature);
+    }
+
+    /**
+     * Invoke the check method on the deployer.
+     */
+    protected void removeServiced(String name) throws Exception {
+        String[] params = { name };
+        String[] signature = { "java.lang.String" };
+        mBeanServer.invoke(oname, "removeServiced", params, signature);
+    }
+
+    /*--Instance Getters/Setters--------------------------------*/
+    public CatalinaCluster getCluster() {
+        return cluster;
+    }
+
+    public void setCluster(CatalinaCluster cluster) {
+        this.cluster = cluster;
+    }
+
+    public boolean equals(Object listener) {
+        return super.equals(listener);
+    }
+
+    public int hashCode() {
+        return super.hashCode();
+    }
+
+    public String getDeployDir() {
+        return deployDir;
+    }
+
+    public void setDeployDir(String deployDir) {
+        this.deployDir = deployDir;
+    }
+
+    public String getTempDir() {
+        return tempDir;
+    }
+
+    public void setTempDir(String tempDir) {
+        this.tempDir = tempDir;
+    }
+
+    public String getWatchDir() {
+        return watchDir;
+    }
+
+    public void setWatchDir(String watchDir) {
+        this.watchDir = watchDir;
+    }
+
+    public boolean isWatchEnabled() {
+        return watchEnabled;
+    }
+
+    public boolean getWatchEnabled() {
+        return watchEnabled;
+    }
+
+    public void setWatchEnabled(boolean watchEnabled) {
+        this.watchEnabled = watchEnabled;
+    }
+
+    /**
+     * Return the frequency of watcher checks.
+     */
+    public int getProcessDeployFrequency() {
+
+        return (this.processDeployFrequency);
+
+    }
+
+    /**
+     * Set the watcher checks frequency.
+     * 
+     * @param processExpiresFrequency
+     *            the new manager checks frequency
+     */
+    public void setProcessDeployFrequency(int processExpiresFrequency) {
+
+        if (processExpiresFrequency <= 0) {
+            return;
+        }
+        this.processDeployFrequency = processExpiresFrequency;
+    }
+
+    /**
+     * Copy a file to the specified temp directory.
+     * @param from copy from temp
+     * @param to   to host appBase directory
+     * @return true, copy successful
+     */
+    protected boolean copy(File from, File to) {
+        try {
+            if (!to.exists())
+                to.createNewFile();
+            java.io.FileInputStream is = new java.io.FileInputStream(from);
+            java.io.FileOutputStream os = new java.io.FileOutputStream(to,
+                    false);
+            byte[] buf = new byte[4096];
+            while (true) {
+                int len = is.read(buf);
+                if (len < 0)
+                    break;
+                os.write(buf, 0, len);
+            }
+            is.close();
+            os.close();
+        } catch (IOException e) {
+            log.error("Unable to copy file from:" + from + " to:" + to, e);
+            return false;
+        }
+        return true;
+    }
+
+}

==================================================
FileMessage.java
index 51858cc0f4..4358cacb3d 100644
--- a/java/org/apache/catalina/ha/deploy/FileChangeListener.java
+++ b/java/org/apache/catalina/ha/deploy/FileChangeListener.java
@@ -1,24 +1,24 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha.deploy;
-import java.io.File;
-
-public interface FileChangeListener {
-    public void fileModified(File f);
-    public void fileRemoved(File f);
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha.deploy;
+import java.io.File;
+
+public interface FileChangeListener {
+    public void fileModified(File f);
+    public void fileRemoved(File f);
+}

==================================================
FileMessageFactory.java
index acab7fd4da..4f2d0ef9ad 100644
--- a/java/org/apache/catalina/ha/deploy/FileMessage.java
+++ b/java/org/apache/catalina/ha/deploy/FileMessage.java
@@ -1,113 +1,113 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha.deploy;
-
-import java.io.Serializable;
-
-import org.apache.catalina.ha.ClusterMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.ha.ClusterMessageBase;
-
-/**
- * Contains the data for a file being transferred over TCP, this is 
- * essentially a fragment of a file, read and written by the FileMessageFactory
- * @author Filip Hanik
- * @version 1.0
- */
-
-public class FileMessage extends ClusterMessageBase implements ClusterMessage, Serializable {
-    private int messageNumber;
-    private byte[] data;
-    private int dataLength;
-    
-    private long totalLength;
-    private long totalNrOfMsgs;
-    private String fileName;
-    private String contextPath;
-    
-    public FileMessage(Member source,
-                       String fileName,
-                       String contextPath) {
-        this.address=source;
-        this.fileName=fileName;
-        this.contextPath=contextPath;
-    }
-    
-    /*
-    public void writeExternal(ObjectOutput out) throws IOException {
-                   
-    }
-    
-    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
-                  
-    }
-    */
-   
-    public int getMessageNumber() {
-        return messageNumber;
-    }
-    public void setMessageNumber(int messageNumber) {
-        this.messageNumber = messageNumber;
-    }
-    public long getTotalNrOfMsgs() {
-        return totalNrOfMsgs;
-    }
-    public void setTotalNrOfMsgs(long totalNrOfMsgs) {
-        this.totalNrOfMsgs = totalNrOfMsgs;
-    }
-    public byte[] getData() {
-        return data;
-    }
-    public void setData(byte[] data, int length) {
-        this.data = data;
-        this.dataLength = length;
-    }
-    public int getDataLength() {
-        return dataLength;
-    }
-    public void setDataLength(int dataLength) {
-        this.dataLength = dataLength;
-    }
-    public long getTotalLength() {
-        return totalLength;
-    }
-    public void setTotalLength(long totalLength) {
-        this.totalLength = totalLength;
-    }
-
-    public String getUniqueId() {
-        StringBuffer result = new StringBuffer(getFileName());
-        result.append("#-#");
-        result.append(getMessageNumber());
-        result.append("#-#");
-        result.append(System.currentTimeMillis());
-        return result.toString();
-    }
-
-    
-    public String getFileName() {
-        return fileName;
-    }
-    public void setFileName(String fileName) {
-        this.fileName = fileName;
-    }
-    public String getContextPath() {
-        return contextPath;
-    }
-    
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha.deploy;
+
+import java.io.Serializable;
+
+import org.apache.catalina.ha.ClusterMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.ha.ClusterMessageBase;
+
+/**
+ * Contains the data for a file being transferred over TCP, this is 
+ * essentially a fragment of a file, read and written by the FileMessageFactory
+ * @author Filip Hanik
+ * @version 1.0
+ */
+
+public class FileMessage extends ClusterMessageBase implements ClusterMessage, Serializable {
+    private int messageNumber;
+    private byte[] data;
+    private int dataLength;
+    
+    private long totalLength;
+    private long totalNrOfMsgs;
+    private String fileName;
+    private String contextPath;
+    
+    public FileMessage(Member source,
+                       String fileName,
+                       String contextPath) {
+        this.address=source;
+        this.fileName=fileName;
+        this.contextPath=contextPath;
+    }
+    
+    /*
+    public void writeExternal(ObjectOutput out) throws IOException {
+                   
+    }
+    
+    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
+                  
+    }
+    */
+   
+    public int getMessageNumber() {
+        return messageNumber;
+    }
+    public void setMessageNumber(int messageNumber) {
+        this.messageNumber = messageNumber;
+    }
+    public long getTotalNrOfMsgs() {
+        return totalNrOfMsgs;
+    }
+    public void setTotalNrOfMsgs(long totalNrOfMsgs) {
+        this.totalNrOfMsgs = totalNrOfMsgs;
+    }
+    public byte[] getData() {
+        return data;
+    }
+    public void setData(byte[] data, int length) {
+        this.data = data;
+        this.dataLength = length;
+    }
+    public int getDataLength() {
+        return dataLength;
+    }
+    public void setDataLength(int dataLength) {
+        this.dataLength = dataLength;
+    }
+    public long getTotalLength() {
+        return totalLength;
+    }
+    public void setTotalLength(long totalLength) {
+        this.totalLength = totalLength;
+    }
+
+    public String getUniqueId() {
+        StringBuffer result = new StringBuffer(getFileName());
+        result.append("#-#");
+        result.append(getMessageNumber());
+        result.append("#-#");
+        result.append(System.currentTimeMillis());
+        return result.toString();
+    }
+
+    
+    public String getFileName() {
+        return fileName;
+    }
+    public void setFileName(String fileName) {
+        this.fileName = fileName;
+    }
+    public String getContextPath() {
+        return contextPath;
+    }
+    
+}

==================================================
UndeployMessage.java
index 43866699fc..225f964b1a 100644
--- a/java/org/apache/catalina/ha/deploy/FileMessageFactory.java
+++ b/java/org/apache/catalina/ha/deploy/FileMessageFactory.java
@@ -1,312 +1,312 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha.deploy;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.FileNotFoundException;
-
-/**
- * This factory is used to read files and write files by splitting them up into
- * smaller messages. So that entire files don't have to be read into memory.
- * <BR>
- * The factory can be used as a reader or writer but not both at the same time.
- * When done reading or writing the factory will close the input or output
- * streams and mark the factory as closed. It is not possible to use it after
- * that. <BR>
- * To force a cleanup, call cleanup() from the calling object. <BR>
- * This class is not thread safe.
- * 
- * @author Filip Hanik
- * @version 1.0
- */
-public class FileMessageFactory {
-    /*--Static Variables----------------------------------------*/
-    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory
-            .getLog(FileMessageFactory.class);
-
-    /**
-     * The number of bytes that we read from file
-     */
-    public static final int READ_SIZE = 1024 * 10; //10kb
-
-    /**
-     * The file that we are reading/writing
-     */
-    protected File file = null;
-
-    /**
-     * True means that we are writing with this factory. False means that we are
-     * reading with this factory
-     */
-    protected boolean openForWrite;
-
-    /**
-     * Once the factory is used, it can not be reused.
-     */
-    protected boolean closed = false;
-
-    /**
-     * When openForWrite=false, the input stream is held by this variable
-     */
-    protected FileInputStream in;
-
-    /**
-     * When openForWrite=true, the output stream is held by this variable
-     */
-    protected FileOutputStream out;
-
-    /**
-     * The number of messages we have read or written
-     */
-    protected int nrOfMessagesProcessed = 0;
-
-    /**
-     * The total size of the file
-     */
-    protected long size = 0;
-
-    /**
-     * The total number of packets that we split this file into
-     */
-    protected long totalNrOfMessages = 0;
-
-    /**
-     * The bytes that we hold the data in, not thread safe.
-     */
-    protected byte[] data = new byte[READ_SIZE];
-
-    /**
-     * Private constructor, either instantiates a factory to read or write. <BR>
-     * When openForWrite==true, then a the file, f, will be created and an
-     * output stream is opened to write to it. <BR>
-     * When openForWrite==false, an input stream is opened, the file has to
-     * exist.
-     * 
-     * @param f
-     *            File - the file to be read/written
-     * @param openForWrite
-     *            boolean - true means we are writing to the file, false means
-     *            we are reading from the file
-     * @throws FileNotFoundException -
-     *             if the file to be read doesn't exist
-     * @throws IOException -
-     *             if the system fails to open input/output streams to the file
-     *             or if it fails to create the file to be written to.
-     */
-    private FileMessageFactory(File f, boolean openForWrite)
-            throws FileNotFoundException, IOException {
-        this.file = f;
-        this.openForWrite = openForWrite;
-        if (log.isDebugEnabled())
-            log.debug("open file " + f + " write " + openForWrite);
-        if (openForWrite) {
-            if (!file.exists())
-                file.createNewFile();
-            out = new FileOutputStream(f);
-        } else {
-            size = file.length();
-            totalNrOfMessages = (size / READ_SIZE) + 1;
-            in = new FileInputStream(f);
-        }//end if
-
-    }
-
-    /**
-     * Creates a factory to read or write from a file. When opening for read,
-     * the readMessage can be invoked, and when opening for write the
-     * writeMessage can be invoked.
-     * 
-     * @param f
-     *            File - the file to be read or written
-     * @param openForWrite
-     *            boolean - true, means we are writing to the file, false means
-     *            we are reading from it
-     * @throws FileNotFoundException -
-     *             if the file to be read doesn't exist
-     * @throws IOException -
-     *             if it fails to create the file that is to be written
-     * @return FileMessageFactory
-     */
-    public static FileMessageFactory getInstance(File f, boolean openForWrite)
-            throws FileNotFoundException, IOException {
-        return new FileMessageFactory(f, openForWrite);
-    }
-
-    /**
-     * Reads file data into the file message and sets the size, totalLength,
-     * totalNrOfMsgs and the message number <BR>
-     * If EOF is reached, the factory returns null, and closes itself, otherwise
-     * the same message is returned as was passed in. This makes sure that not
-     * more memory is ever used. To remember, neither the file message or the
-     * factory are thread safe. dont hand off the message to one thread and read
-     * the same with another.
-     * 
-     * @param f
-     *            FileMessage - the message to be populated with file data
-     * @throws IllegalArgumentException -
-     *             if the factory is for writing or is closed
-     * @throws IOException -
-     *             if a file read exception occurs
-     * @return FileMessage - returns the same message passed in as a parameter,
-     *         or null if EOF
-     */
-    public FileMessage readMessage(FileMessage f)
-            throws IllegalArgumentException, IOException {
-        checkState(false);
-        int length = in.read(data);
-        if (length == -1) {
-            cleanup();
-            return null;
-        } else {
-            f.setData(data, length);
-            f.setTotalLength(size);
-            f.setTotalNrOfMsgs(totalNrOfMessages);
-            f.setMessageNumber(++nrOfMessagesProcessed);
-            return f;
-        }//end if
-    }
-
-    /**
-     * Writes a message to file. If (msg.getMessageNumber() ==
-     * msg.getTotalNrOfMsgs()) the output stream will be closed after writing.
-     * 
-     * @param msg
-     *            FileMessage - message containing data to be written
-     * @throws IllegalArgumentException -
-     *             if the factory is opened for read or closed
-     * @throws IOException -
-     *             if a file write error occurs
-     * @return returns true if the file is complete and outputstream is closed,
-     *         false otherwise.
-     */
-    public boolean writeMessage(FileMessage msg)
-            throws IllegalArgumentException, IOException {
-        if (!openForWrite)
-            throw new IllegalArgumentException(
-                    "Can't write message, this factory is reading.");
-        if (log.isDebugEnabled())
-            log.debug("Message " + msg + " data " + msg.getData()
-                    + " data length " + msg.getDataLength() + " out " + out);
-        if (out != null) {
-            out.write(msg.getData(), 0, msg.getDataLength());
-            nrOfMessagesProcessed++;
-            out.flush();
-            if (msg.getMessageNumber() == msg.getTotalNrOfMsgs()) {
-                out.close();
-                cleanup();
-                return true;
-            }//end if
-        } else {
-            if (log.isWarnEnabled())
-                log.warn("Receive Message again -- Sender ActTimeout to short [ path: "
-                                + msg.getContextPath()
-                                + " war: "
-                                + msg.getFileName()
-                                + " data: "
-                                + msg.getData()
-                                + " data length: " + msg.getDataLength() + " ]");
-        }
-        return false;
-    }//writeMessage
-
-    /**
-     * Closes the factory, its streams and sets all its references to null
-     */
-    public void cleanup() {
-        if (in != null)
-            try {
-                in.close();
-            } catch (Exception ignore) {
-            }
-        if (out != null)
-            try {
-                out.close();
-            } catch (Exception ignore) {
-            }
-        in = null;
-        out = null;
-        size = 0;
-        closed = true;
-        data = null;
-        nrOfMessagesProcessed = 0;
-        totalNrOfMessages = 0;
-    }
-
-    /**
-     * Check to make sure the factory is able to perform the function it is
-     * asked to do. Invoked by readMessage/writeMessage before those methods
-     * proceed.
-     * 
-     * @param openForWrite
-     *            boolean
-     * @throws IllegalArgumentException
-     */
-    protected void checkState(boolean openForWrite)
-            throws IllegalArgumentException {
-        if (this.openForWrite != openForWrite) {
-            cleanup();
-            if (openForWrite)
-                throw new IllegalArgumentException(
-                        "Can't write message, this factory is reading.");
-            else
-                throw new IllegalArgumentException(
-                        "Can't read message, this factory is writing.");
-        }
-        if (this.closed) {
-            cleanup();
-            throw new IllegalArgumentException("Factory has been closed.");
-        }
-    }
-
-    /**
-     * Example usage.
-     * 
-     * @param args
-     *            String[], args[0] - read from filename, args[1] write to
-     *            filename
-     * @throws Exception
-     */
-    public static void main(String[] args) throws Exception {
-
-        System.out
-                .println("Usage: FileMessageFactory fileToBeRead fileToBeWritten");
-        System.out
-                .println("Usage: This will make a copy of the file on the local file system");
-        FileMessageFactory read = getInstance(new File(args[0]), false);
-        FileMessageFactory write = getInstance(new File(args[1]), true);
-        FileMessage msg = new FileMessage(null, args[0], args[0]);
-        msg = read.readMessage(msg);
-        System.out.println("Expecting to write " + msg.getTotalNrOfMsgs()
-                + " messages.");
-        int cnt = 0;
-        while (msg != null) {
-            write.writeMessage(msg);
-            cnt++;
-            msg = read.readMessage(msg);
-        }//while
-        System.out.println("Actually wrote " + cnt + " messages.");
-    }///main
-
-    public File getFile() {
-        return file;
-    }
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha.deploy;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.FileNotFoundException;
+
+/**
+ * This factory is used to read files and write files by splitting them up into
+ * smaller messages. So that entire files don't have to be read into memory.
+ * <BR>
+ * The factory can be used as a reader or writer but not both at the same time.
+ * When done reading or writing the factory will close the input or output
+ * streams and mark the factory as closed. It is not possible to use it after
+ * that. <BR>
+ * To force a cleanup, call cleanup() from the calling object. <BR>
+ * This class is not thread safe.
+ * 
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class FileMessageFactory {
+    /*--Static Variables----------------------------------------*/
+    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory
+            .getLog(FileMessageFactory.class);
+
+    /**
+     * The number of bytes that we read from file
+     */
+    public static final int READ_SIZE = 1024 * 10; //10kb
+
+    /**
+     * The file that we are reading/writing
+     */
+    protected File file = null;
+
+    /**
+     * True means that we are writing with this factory. False means that we are
+     * reading with this factory
+     */
+    protected boolean openForWrite;
+
+    /**
+     * Once the factory is used, it can not be reused.
+     */
+    protected boolean closed = false;
+
+    /**
+     * When openForWrite=false, the input stream is held by this variable
+     */
+    protected FileInputStream in;
+
+    /**
+     * When openForWrite=true, the output stream is held by this variable
+     */
+    protected FileOutputStream out;
+
+    /**
+     * The number of messages we have read or written
+     */
+    protected int nrOfMessagesProcessed = 0;
+
+    /**
+     * The total size of the file
+     */
+    protected long size = 0;
+
+    /**
+     * The total number of packets that we split this file into
+     */
+    protected long totalNrOfMessages = 0;
+
+    /**
+     * The bytes that we hold the data in, not thread safe.
+     */
+    protected byte[] data = new byte[READ_SIZE];
+
+    /**
+     * Private constructor, either instantiates a factory to read or write. <BR>
+     * When openForWrite==true, then a the file, f, will be created and an
+     * output stream is opened to write to it. <BR>
+     * When openForWrite==false, an input stream is opened, the file has to
+     * exist.
+     * 
+     * @param f
+     *            File - the file to be read/written
+     * @param openForWrite
+     *            boolean - true means we are writing to the file, false means
+     *            we are reading from the file
+     * @throws FileNotFoundException -
+     *             if the file to be read doesn't exist
+     * @throws IOException -
+     *             if the system fails to open input/output streams to the file
+     *             or if it fails to create the file to be written to.
+     */
+    private FileMessageFactory(File f, boolean openForWrite)
+            throws FileNotFoundException, IOException {
+        this.file = f;
+        this.openForWrite = openForWrite;
+        if (log.isDebugEnabled())
+            log.debug("open file " + f + " write " + openForWrite);
+        if (openForWrite) {
+            if (!file.exists())
+                file.createNewFile();
+            out = new FileOutputStream(f);
+        } else {
+            size = file.length();
+            totalNrOfMessages = (size / READ_SIZE) + 1;
+            in = new FileInputStream(f);
+        }//end if
+
+    }
+
+    /**
+     * Creates a factory to read or write from a file. When opening for read,
+     * the readMessage can be invoked, and when opening for write the
+     * writeMessage can be invoked.
+     * 
+     * @param f
+     *            File - the file to be read or written
+     * @param openForWrite
+     *            boolean - true, means we are writing to the file, false means
+     *            we are reading from it
+     * @throws FileNotFoundException -
+     *             if the file to be read doesn't exist
+     * @throws IOException -
+     *             if it fails to create the file that is to be written
+     * @return FileMessageFactory
+     */
+    public static FileMessageFactory getInstance(File f, boolean openForWrite)
+            throws FileNotFoundException, IOException {
+        return new FileMessageFactory(f, openForWrite);
+    }
+
+    /**
+     * Reads file data into the file message and sets the size, totalLength,
+     * totalNrOfMsgs and the message number <BR>
+     * If EOF is reached, the factory returns null, and closes itself, otherwise
+     * the same message is returned as was passed in. This makes sure that not
+     * more memory is ever used. To remember, neither the file message or the
+     * factory are thread safe. dont hand off the message to one thread and read
+     * the same with another.
+     * 
+     * @param f
+     *            FileMessage - the message to be populated with file data
+     * @throws IllegalArgumentException -
+     *             if the factory is for writing or is closed
+     * @throws IOException -
+     *             if a file read exception occurs
+     * @return FileMessage - returns the same message passed in as a parameter,
+     *         or null if EOF
+     */
+    public FileMessage readMessage(FileMessage f)
+            throws IllegalArgumentException, IOException {
+        checkState(false);
+        int length = in.read(data);
+        if (length == -1) {
+            cleanup();
+            return null;
+        } else {
+            f.setData(data, length);
+            f.setTotalLength(size);
+            f.setTotalNrOfMsgs(totalNrOfMessages);
+            f.setMessageNumber(++nrOfMessagesProcessed);
+            return f;
+        }//end if
+    }
+
+    /**
+     * Writes a message to file. If (msg.getMessageNumber() ==
+     * msg.getTotalNrOfMsgs()) the output stream will be closed after writing.
+     * 
+     * @param msg
+     *            FileMessage - message containing data to be written
+     * @throws IllegalArgumentException -
+     *             if the factory is opened for read or closed
+     * @throws IOException -
+     *             if a file write error occurs
+     * @return returns true if the file is complete and outputstream is closed,
+     *         false otherwise.
+     */
+    public boolean writeMessage(FileMessage msg)
+            throws IllegalArgumentException, IOException {
+        if (!openForWrite)
+            throw new IllegalArgumentException(
+                    "Can't write message, this factory is reading.");
+        if (log.isDebugEnabled())
+            log.debug("Message " + msg + " data " + msg.getData()
+                    + " data length " + msg.getDataLength() + " out " + out);
+        if (out != null) {
+            out.write(msg.getData(), 0, msg.getDataLength());
+            nrOfMessagesProcessed++;
+            out.flush();
+            if (msg.getMessageNumber() == msg.getTotalNrOfMsgs()) {
+                out.close();
+                cleanup();
+                return true;
+            }//end if
+        } else {
+            if (log.isWarnEnabled())
+                log.warn("Receive Message again -- Sender ActTimeout to short [ path: "
+                                + msg.getContextPath()
+                                + " war: "
+                                + msg.getFileName()
+                                + " data: "
+                                + msg.getData()
+                                + " data length: " + msg.getDataLength() + " ]");
+        }
+        return false;
+    }//writeMessage
+
+    /**
+     * Closes the factory, its streams and sets all its references to null
+     */
+    public void cleanup() {
+        if (in != null)
+            try {
+                in.close();
+            } catch (Exception ignore) {
+            }
+        if (out != null)
+            try {
+                out.close();
+            } catch (Exception ignore) {
+            }
+        in = null;
+        out = null;
+        size = 0;
+        closed = true;
+        data = null;
+        nrOfMessagesProcessed = 0;
+        totalNrOfMessages = 0;
+    }
+
+    /**
+     * Check to make sure the factory is able to perform the function it is
+     * asked to do. Invoked by readMessage/writeMessage before those methods
+     * proceed.
+     * 
+     * @param openForWrite
+     *            boolean
+     * @throws IllegalArgumentException
+     */
+    protected void checkState(boolean openForWrite)
+            throws IllegalArgumentException {
+        if (this.openForWrite != openForWrite) {
+            cleanup();
+            if (openForWrite)
+                throw new IllegalArgumentException(
+                        "Can't write message, this factory is reading.");
+            else
+                throw new IllegalArgumentException(
+                        "Can't read message, this factory is writing.");
+        }
+        if (this.closed) {
+            cleanup();
+            throw new IllegalArgumentException("Factory has been closed.");
+        }
+    }
+
+    /**
+     * Example usage.
+     * 
+     * @param args
+     *            String[], args[0] - read from filename, args[1] write to
+     *            filename
+     * @throws Exception
+     */
+    public static void main(String[] args) throws Exception {
+
+        System.out
+                .println("Usage: FileMessageFactory fileToBeRead fileToBeWritten");
+        System.out
+                .println("Usage: This will make a copy of the file on the local file system");
+        FileMessageFactory read = getInstance(new File(args[0]), false);
+        FileMessageFactory write = getInstance(new File(args[1]), true);
+        FileMessage msg = new FileMessage(null, args[0], args[0]);
+        msg = read.readMessage(msg);
+        System.out.println("Expecting to write " + msg.getTotalNrOfMsgs()
+                + " messages.");
+        int cnt = 0;
+        while (msg != null) {
+            write.writeMessage(msg);
+            cnt++;
+            msg = read.readMessage(msg);
+        }//while
+        System.out.println("Actually wrote " + cnt + " messages.");
+    }///main
+
+    public File getFile() {
+        return file;
+    }
+
 }
\ No newline at end of file

==================================================
WarWatcher.java
index 24f1c4670b..3cd284a2e5 100644
--- a/java/org/apache/catalina/ha/deploy/UndeployMessage.java
+++ b/java/org/apache/catalina/ha/deploy/UndeployMessage.java
@@ -1,114 +1,114 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha.deploy;
-
-import org.apache.catalina.ha.ClusterMessage;
-import org.apache.catalina.tribes.Member;
-import java.io.Serializable;
-public class UndeployMessage implements ClusterMessage,Serializable {
-    private Member address;
-    private long timestamp;
-    private String uniqueId;
-    private String contextPath;
-    private boolean undeploy;
-    private int resend = 0;
-    private int compress = 0;
-
-    public UndeployMessage() {} //for serialization
-    public UndeployMessage(Member address,
-                           long timestamp,
-                           String uniqueId,
-                           String contextPath,
-                           boolean undeploy) {
-        this.address  = address;
-        this.timestamp= timestamp;
-        this.undeploy = undeploy;
-        this.uniqueId = uniqueId;
-        this.undeploy = undeploy;
-        this.contextPath = contextPath;
-    }
-
-    public Member getAddress() {
-        return address;
-    }
-
-    public void setAddress(Member address) {
-        this.address = address;
-    }
-
-    public long getTimestamp() {
-        return timestamp;
-    }
-
-    public void setTimestamp(long timestamp) {
-        this.timestamp = timestamp;
-    }
-
-    public String getUniqueId() {
-        return uniqueId;
-    }
-
-    public void setUniqueId(String uniqueId) {
-        this.uniqueId = uniqueId;
-    }
-
-    public String getContextPath() {
-        return contextPath;
-    }
-
-    public void setContextPath(String contextPath) {
-        this.contextPath = contextPath;
-    }
-
-    public boolean getUndeploy() {
-        return undeploy;
-    }
-
-    public void setUndeploy(boolean undeploy) {
-        this.undeploy = undeploy;
-    }
-    /**
-     * @return Returns the compress.
-     * @since 5.5.10 
-     */
-    public int getCompress() {
-        return compress;
-    }
-    /**
-     * @param compress The compress to set.
-     * @since 5.5.10
-     */
-    public void setCompress(int compress) {
-        this.compress = compress;
-    }
-    /**
-     * @return Returns the resend.
-     * @since 5.5.10
-     */
-    public int getResend() {
-        return resend;
-    }
-    /**
-     * @param resend The resend to set.
-     * @since 5.5.10
-     */
-    public void setResend(int resend) {
-        this.resend = resend;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha.deploy;
+
+import org.apache.catalina.ha.ClusterMessage;
+import org.apache.catalina.tribes.Member;
+import java.io.Serializable;
+public class UndeployMessage implements ClusterMessage,Serializable {
+    private Member address;
+    private long timestamp;
+    private String uniqueId;
+    private String contextPath;
+    private boolean undeploy;
+    private int resend = 0;
+    private int compress = 0;
+
+    public UndeployMessage() {} //for serialization
+    public UndeployMessage(Member address,
+                           long timestamp,
+                           String uniqueId,
+                           String contextPath,
+                           boolean undeploy) {
+        this.address  = address;
+        this.timestamp= timestamp;
+        this.undeploy = undeploy;
+        this.uniqueId = uniqueId;
+        this.undeploy = undeploy;
+        this.contextPath = contextPath;
+    }
+
+    public Member getAddress() {
+        return address;
+    }
+
+    public void setAddress(Member address) {
+        this.address = address;
+    }
+
+    public long getTimestamp() {
+        return timestamp;
+    }
+
+    public void setTimestamp(long timestamp) {
+        this.timestamp = timestamp;
+    }
+
+    public String getUniqueId() {
+        return uniqueId;
+    }
+
+    public void setUniqueId(String uniqueId) {
+        this.uniqueId = uniqueId;
+    }
+
+    public String getContextPath() {
+        return contextPath;
+    }
+
+    public void setContextPath(String contextPath) {
+        this.contextPath = contextPath;
+    }
+
+    public boolean getUndeploy() {
+        return undeploy;
+    }
+
+    public void setUndeploy(boolean undeploy) {
+        this.undeploy = undeploy;
+    }
+    /**
+     * @return Returns the compress.
+     * @since 5.5.10 
+     */
+    public int getCompress() {
+        return compress;
+    }
+    /**
+     * @param compress The compress to set.
+     * @since 5.5.10
+     */
+    public void setCompress(int compress) {
+        this.compress = compress;
+    }
+    /**
+     * @return Returns the resend.
+     * @since 5.5.10
+     */
+    public int getResend() {
+        return resend;
+    }
+    /**
+     * @param resend The resend to set.
+     * @since 5.5.10
+     */
+    public void setResend(int resend) {
+        this.resend = resend;
+    }
+
+}

==================================================
BackupManager.java
index 925b6c2d29..beb7636081 100644
--- a/java/org/apache/catalina/ha/deploy/WarWatcher.java
+++ b/java/org/apache/catalina/ha/deploy/WarWatcher.java
@@ -1,239 +1,239 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha.deploy;
-
-import java.io.File;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Iterator;
-
-/**
- * <p>
- * The <b>WarWatcher </b> watches the deployDir for changes made to the
- * directory (adding new WAR files->deploy or remove WAR files->undeploy) And
- * notifies a listener of the changes made
- * </p>
- * 
- * @author Filip Hanik
- * @author Peter Rossbach
- * @version 1.1
- */
-
-public class WarWatcher {
-
-    /*--Static Variables----------------------------------------*/
-    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory
-            .getLog(WarWatcher.class);
-
-    /*--Instance Variables--------------------------------------*/
-    /**
-     * Directory to watch for war files
-     */
-    protected File watchDir = null;
-
-    /**
-     * Parent to be notified of changes
-     */
-    protected FileChangeListener listener = null;
-
-    /**
-     * Currently deployed files
-     */
-    protected Map currentStatus = new HashMap();
-
-    /*--Constructor---------------------------------------------*/
-
-    public WarWatcher() {
-    }
-
-    public WarWatcher(FileChangeListener listener, File watchDir) {
-        this.listener = listener;
-        this.watchDir = watchDir;
-    }
-
-    /*--Logic---------------------------------------------------*/
-
-    /**
-     * check for modification and send notifcation to listener
-     */
-    public void check() {
-        if (log.isInfoEnabled())
-            log.info("check cluster wars at " + watchDir);
-        File[] list = watchDir.listFiles(new WarFilter());
-        if (list == null)
-            list = new File[0];
-        //first make sure all the files are listed in our current status
-        for (int i = 0; i < list.length; i++) {
-            addWarInfo(list[i]);
-        }
-
-        //check all the status codes and update the FarmDeployer
-        for (Iterator i = currentStatus.entrySet().iterator(); i.hasNext();) {
-            Map.Entry entry = (Map.Entry) i.next();
-            WarInfo info = (WarInfo) entry.getValue();
-            int check = info.check();
-            if (check == 1) {
-                listener.fileModified(info.getWar());
-            } else if (check == -1) {
-                listener.fileRemoved(info.getWar());
-                //no need to keep in memory
-                currentStatus.remove(info.getWar());
-            }
-        }
-
-    }
-
-    /**
-     * add cluster war to the watcher state
-     * @param warfile
-     */
-    protected void addWarInfo(File warfile) {
-        WarInfo info = (WarInfo) currentStatus.get(warfile.getAbsolutePath());
-        if (info == null) {
-            info = new WarInfo(warfile);
-            info.setLastState(-1); //assume file is non existent
-            currentStatus.put(warfile.getAbsolutePath(), info);
-        }
-    }
-
-    /**
-     * clear watcher state
-     */
-    public void clear() {
-        currentStatus.clear();
-    }
-
-    /**
-     * @return Returns the watchDir.
-     */
-    public File getWatchDir() {
-        return watchDir;
-    }
-
-    /**
-     * @param watchDir
-     *            The watchDir to set.
-     */
-    public void setWatchDir(File watchDir) {
-        this.watchDir = watchDir;
-    }
-
-    /**
-     * @return Returns the listener.
-     */
-    public FileChangeListener getListener() {
-        return listener;
-    }
-
-    /**
-     * @param listener
-     *            The listener to set.
-     */
-    public void setListener(FileChangeListener listener) {
-        this.listener = listener;
-    }
-
-    /*--Inner classes-------------------------------------------*/
-
-    /**
-     * File name filter for war files
-     */
-    protected class WarFilter implements java.io.FilenameFilter {
-        public boolean accept(File path, String name) {
-            if (name == null)
-                return false;
-            return name.endsWith(".war");
-        }
-    }
-
-    /**
-     * File information on existing WAR files
-     */
-    protected class WarInfo {
-        protected File war = null;
-
-        protected long lastChecked = 0;
-
-        protected long lastState = 0;
-
-        public WarInfo(File war) {
-            this.war = war;
-            this.lastChecked = war.lastModified();
-            if (!war.exists())
-                lastState = -1;
-        }
-
-        public boolean modified() {
-            return war.exists() && war.lastModified() > lastChecked;
-        }
-
-        public boolean exists() {
-            return war.exists();
-        }
-
-        /**
-         * Returns 1 if the file has been added/modified, 0 if the file is
-         * unchanged and -1 if the file has been removed
-         * 
-         * @return int 1=file added; 0=unchanged; -1=file removed
-         */
-        public int check() {
-            //file unchanged by default
-            int result = 0;
-
-            if (modified()) {
-                //file has changed - timestamp
-                result = 1;
-                lastState = result;
-            } else if ((!exists()) && (!(lastState == -1))) {
-                //file was removed
-                result = -1;
-                lastState = result;
-            } else if ((lastState == -1) && exists()) {
-                //file was added
-                result = 1;
-                lastState = result;
-            }
-            this.lastChecked = System.currentTimeMillis();
-            return result;
-        }
-
-        public File getWar() {
-            return war;
-        }
-
-        public int hashCode() {
-            return war.getAbsolutePath().hashCode();
-        }
-
-        public boolean equals(Object other) {
-            if (other instanceof WarInfo) {
-                WarInfo wo = (WarInfo) other;
-                return wo.getWar().equals(getWar());
-            } else {
-                return false;
-            }
-        }
-
-        protected void setLastState(int lastState) {
-            this.lastState = lastState;
-        }
-
-    }
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha.deploy;
+
+import java.io.File;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Iterator;
+
+/**
+ * <p>
+ * The <b>WarWatcher </b> watches the deployDir for changes made to the
+ * directory (adding new WAR files->deploy or remove WAR files->undeploy) And
+ * notifies a listener of the changes made
+ * </p>
+ * 
+ * @author Filip Hanik
+ * @author Peter Rossbach
+ * @version 1.1
+ */
+
+public class WarWatcher {
+
+    /*--Static Variables----------------------------------------*/
+    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory
+            .getLog(WarWatcher.class);
+
+    /*--Instance Variables--------------------------------------*/
+    /**
+     * Directory to watch for war files
+     */
+    protected File watchDir = null;
+
+    /**
+     * Parent to be notified of changes
+     */
+    protected FileChangeListener listener = null;
+
+    /**
+     * Currently deployed files
+     */
+    protected Map currentStatus = new HashMap();
+
+    /*--Constructor---------------------------------------------*/
+
+    public WarWatcher() {
+    }
+
+    public WarWatcher(FileChangeListener listener, File watchDir) {
+        this.listener = listener;
+        this.watchDir = watchDir;
+    }
+
+    /*--Logic---------------------------------------------------*/
+
+    /**
+     * check for modification and send notifcation to listener
+     */
+    public void check() {
+        if (log.isInfoEnabled())
+            log.info("check cluster wars at " + watchDir);
+        File[] list = watchDir.listFiles(new WarFilter());
+        if (list == null)
+            list = new File[0];
+        //first make sure all the files are listed in our current status
+        for (int i = 0; i < list.length; i++) {
+            addWarInfo(list[i]);
+        }
+
+        //check all the status codes and update the FarmDeployer
+        for (Iterator i = currentStatus.entrySet().iterator(); i.hasNext();) {
+            Map.Entry entry = (Map.Entry) i.next();
+            WarInfo info = (WarInfo) entry.getValue();
+            int check = info.check();
+            if (check == 1) {
+                listener.fileModified(info.getWar());
+            } else if (check == -1) {
+                listener.fileRemoved(info.getWar());
+                //no need to keep in memory
+                currentStatus.remove(info.getWar());
+            }
+        }
+
+    }
+
+    /**
+     * add cluster war to the watcher state
+     * @param warfile
+     */
+    protected void addWarInfo(File warfile) {
+        WarInfo info = (WarInfo) currentStatus.get(warfile.getAbsolutePath());
+        if (info == null) {
+            info = new WarInfo(warfile);
+            info.setLastState(-1); //assume file is non existent
+            currentStatus.put(warfile.getAbsolutePath(), info);
+        }
+    }
+
+    /**
+     * clear watcher state
+     */
+    public void clear() {
+        currentStatus.clear();
+    }
+
+    /**
+     * @return Returns the watchDir.
+     */
+    public File getWatchDir() {
+        return watchDir;
+    }
+
+    /**
+     * @param watchDir
+     *            The watchDir to set.
+     */
+    public void setWatchDir(File watchDir) {
+        this.watchDir = watchDir;
+    }
+
+    /**
+     * @return Returns the listener.
+     */
+    public FileChangeListener getListener() {
+        return listener;
+    }
+
+    /**
+     * @param listener
+     *            The listener to set.
+     */
+    public void setListener(FileChangeListener listener) {
+        this.listener = listener;
+    }
+
+    /*--Inner classes-------------------------------------------*/
+
+    /**
+     * File name filter for war files
+     */
+    protected class WarFilter implements java.io.FilenameFilter {
+        public boolean accept(File path, String name) {
+            if (name == null)
+                return false;
+            return name.endsWith(".war");
+        }
+    }
+
+    /**
+     * File information on existing WAR files
+     */
+    protected class WarInfo {
+        protected File war = null;
+
+        protected long lastChecked = 0;
+
+        protected long lastState = 0;
+
+        public WarInfo(File war) {
+            this.war = war;
+            this.lastChecked = war.lastModified();
+            if (!war.exists())
+                lastState = -1;
+        }
+
+        public boolean modified() {
+            return war.exists() && war.lastModified() > lastChecked;
+        }
+
+        public boolean exists() {
+            return war.exists();
+        }
+
+        /**
+         * Returns 1 if the file has been added/modified, 0 if the file is
+         * unchanged and -1 if the file has been removed
+         * 
+         * @return int 1=file added; 0=unchanged; -1=file removed
+         */
+        public int check() {
+            //file unchanged by default
+            int result = 0;
+
+            if (modified()) {
+                //file has changed - timestamp
+                result = 1;
+                lastState = result;
+            } else if ((!exists()) && (!(lastState == -1))) {
+                //file was removed
+                result = -1;
+                lastState = result;
+            } else if ((lastState == -1) && exists()) {
+                //file was added
+                result = 1;
+                lastState = result;
+            }
+            this.lastChecked = System.currentTimeMillis();
+            return result;
+        }
+
+        public File getWar() {
+            return war;
+        }
+
+        public int hashCode() {
+            return war.getAbsolutePath().hashCode();
+        }
+
+        public boolean equals(Object other) {
+            if (other instanceof WarInfo) {
+                WarInfo wo = (WarInfo) other;
+                return wo.getWar().equals(getWar());
+            } else {
+                return false;
+            }
+        }
+
+        protected void setLastState(int lastState) {
+            this.lastState = lastState;
+        }
+
+    }
+
 }
\ No newline at end of file

==================================================
ClusterManagerBase.java
index 1e39e4b65c..c4bc697f80 100644
--- a/java/org/apache/catalina/ha/session/BackupManager.java
+++ b/java/org/apache/catalina/ha/session/BackupManager.java
@@ -1,282 +1,282 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.ha.session;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-
-import org.apache.catalina.LifecycleException;
-import org.apache.catalina.Session;
-import org.apache.catalina.ha.CatalinaCluster;
-import org.apache.catalina.ha.ClusterManager;
-import org.apache.catalina.ha.ClusterMessage;
-import org.apache.catalina.session.StandardManager;
-import org.apache.catalina.tribes.Channel;
-import org.apache.catalina.tribes.io.ReplicationStream;
-import org.apache.catalina.tribes.tipis.LazyReplicatedMap;
-
-/**
- *@author Filip Hanik
- *@version 1.0
- */
-public class BackupManager extends StandardManager implements ClusterManager
-{
-    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( BackupManager.class );
-
-    protected static long DEFAULT_REPL_TIMEOUT = 15000;//15 seconds
-
-    /** Set to true if we don't want the sessions to expire on shutdown */
-    protected boolean mExpireSessionsOnShutdown = true;
-    
-    /**
-     * The name of this manager
-     */
-    protected String name;
-
-    /**
-     * A reference to the cluster
-     */
-    protected CatalinaCluster cluster;
-    
-    /**
-     * Should listeners be notified?
-     */
-    private boolean notifyListenersOnReplication;
-    /**
-     * 
-     */
-    private int mapSendOptions = Channel.SEND_OPTIONS_SYNCHRONIZED_ACK|Channel.SEND_OPTIONS_USE_ACK;
-
-    /**
-     * Constructor, just calls super()
-     *
-     */
-    public BackupManager() {
-        super();
-    }
-
-
-//******************************************************************************/
-//      ClusterManager Interface     
-//******************************************************************************/
-
-    public void messageDataReceived(ClusterMessage msg) {
-    }
-
-    public boolean doDomainReplication() {
-        return false;
-    }
-
-    /**
-     * @param sendClusterDomainOnly The sendClusterDomainOnly to set.
-     */
-    public void setDomainReplication(boolean sendClusterDomainOnly) {
-    }
-
-    /**
-     * @return Returns the defaultMode.
-     */
-    public boolean isDefaultMode() {
-        return false;
-    }
-    /**
-     * @param defaultMode The defaultMode to set.
-     */
-    public void setDefaultMode(boolean defaultMode) {
-    }
-
-    public void setExpireSessionsOnShutdown(boolean expireSessionsOnShutdown)
-    {
-        mExpireSessionsOnShutdown = expireSessionsOnShutdown;
-    }
-
-    public void setCluster(CatalinaCluster cluster) {
-        if(log.isDebugEnabled())
-            log.debug("Cluster associated with SimpleTcpReplicationManager");
-        this.cluster = cluster;
-    }
-
-    public boolean getExpireSessionsOnShutdown()
-    {
-        return mExpireSessionsOnShutdown;
-    }
-
-
-    /**
-     * Override persistence since they don't go hand in hand with replication for now.
-     */
-    public void unload() throws IOException {
-    }
-    
-    public ClusterMessage requestCompleted(String sessionId) {
-        if ( !this.started ) return null;
-        LazyReplicatedMap map = (LazyReplicatedMap)sessions;
-        map.replicate(sessionId,false);
-        return null;
-    }
-
-
-//=========================================================================
-// OVERRIDE THESE METHODS TO IMPLEMENT THE REPLICATION
-//=========================================================================
-
-    public Session createEmptySession() {
-        return new DeltaSession(this);
-    }
-    
-    public ClassLoader[] getClassLoaders() {
-        return ClusterManagerBase.getClassLoaders(this.container);
-    }
-
-    /**
-     * Open Stream and use correct ClassLoader (Container) Switch
-     * ThreadClassLoader
-     * 
-     * @param data
-     * @return The object input stream
-     * @throws IOException
-     */
-    public ReplicationStream getReplicationStream(byte[] data) throws IOException {
-        return getReplicationStream(data,0,data.length);
-    }
-
-    public ReplicationStream getReplicationStream(byte[] data, int offset, int length) throws IOException {
-        ByteArrayInputStream fis = new ByteArrayInputStream(data, offset, length);
-        return new ReplicationStream(fis, getClassLoaders());
-    }    
-
-
-
-
-    public String getName() {
-        return this.name;
-    }
-    /**
-     * Prepare for the beginning of active use of the public methods of this
-     * component.  This method should be called after <code>configure()</code>,
-     * and before any of the public methods of the component are utilized.<BR>
-     * Starts the cluster communication channel, this will connect with the other nodes
-     * in the cluster, and request the current session state to be transferred to this node.
-     * @exception IllegalStateException if this component has already been
-     *  started
-     * @exception LifecycleException if this component detects a fatal error
-     *  that prevents this component from being used
-     */
-    public void start() throws LifecycleException {
-        if ( this.started ) return;
-        
-        try {
-            cluster.registerManager(this);
-            CatalinaCluster catclust = (CatalinaCluster)cluster;
-            LazyReplicatedMap map = new LazyReplicatedMap(this,
-                                                          catclust.getChannel(),
-                                                          DEFAULT_REPL_TIMEOUT,
-                                                          getMapName(),
-                                                          getClassLoaders());
-            map.setChannelSendOptions(mapSendOptions);
-            this.sessions = map;
-            super.start();
-            this.started = true;
-        }  catch ( Exception x ) {
-            log.error("Unable to start BackupManager",x);
-            throw new LifecycleException("Failed to start BackupManager",x);
-        }
-    }
-    
-    public String getMapName() {
-        CatalinaCluster catclust = (CatalinaCluster)cluster;
-        String name = catclust.getManagerName(getName(),this)+"-"+"map";
-        if ( log.isDebugEnabled() ) log.debug("Backup manager, Setting map name to:"+name);
-        return name;
-    }
-
-    /**
-     * Gracefully terminate the active use of the public methods of this
-     * component.  This method should be the last one called on a given
-     * instance of this component.<BR>
-     * This will disconnect the cluster communication channel and stop the listener thread.
-     * @exception IllegalStateException if this component has not been started
-     * @exception LifecycleException if this component detects a fatal error
-     *  that needs to be reported
-     */
-    public void stop() throws LifecycleException
-    {
-        
-        LazyReplicatedMap map = (LazyReplicatedMap)sessions;
-        if ( map!=null ) {
-            map.breakdown();
-        }
-        if ( !this.started ) return;
-        try {
-        } catch ( Exception x ){
-            log.error("Unable to stop BackupManager",x);
-            throw new LifecycleException("Failed to stop BackupManager",x);
-        } finally {
-            super.stop();
-        }
-        cluster.removeManager(this);
-
-    }
-
-    public void setDistributable(boolean dist) {
-        this.distributable = dist;
-    }
-
-    public boolean getDistributable() {
-        return distributable;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-    public boolean isNotifyListenersOnReplication() {
-        return notifyListenersOnReplication;
-    }
-    public void setNotifyListenersOnReplication(boolean notifyListenersOnReplication) {
-        this.notifyListenersOnReplication = notifyListenersOnReplication;
-    }
-
-    public void setMapSendOptions(int mapSendOptions) {
-        this.mapSendOptions = mapSendOptions;
-    }
-
-    /* 
-     * @see org.apache.catalina.ha.ClusterManager#getCluster()
-     */
-    public CatalinaCluster getCluster() {
-        return cluster;
-    }
-
-    public int getMapSendOptions() {
-        return mapSendOptions;
-    }
-
-    public String[] getInvalidatedSessions() {
-        return new String[0];
-    }
-    
-    public ClusterManager cloneFromTemplate() {
-        BackupManager result = new BackupManager();
-        result.mExpireSessionsOnShutdown = mExpireSessionsOnShutdown;
-        result.name = "Clone-from-"+name;
-        result.cluster = cluster;
-        result.notifyListenersOnReplication = notifyListenersOnReplication;
-        result.mapSendOptions = mapSendOptions;
-        return result;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.ha.session;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+
+import org.apache.catalina.LifecycleException;
+import org.apache.catalina.Session;
+import org.apache.catalina.ha.CatalinaCluster;
+import org.apache.catalina.ha.ClusterManager;
+import org.apache.catalina.ha.ClusterMessage;
+import org.apache.catalina.session.StandardManager;
+import org.apache.catalina.tribes.Channel;
+import org.apache.catalina.tribes.io.ReplicationStream;
+import org.apache.catalina.tribes.tipis.LazyReplicatedMap;
+
+/**
+ *@author Filip Hanik
+ *@version 1.0
+ */
+public class BackupManager extends StandardManager implements ClusterManager
+{
+    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( BackupManager.class );
+
+    protected static long DEFAULT_REPL_TIMEOUT = 15000;//15 seconds
+
+    /** Set to true if we don't want the sessions to expire on shutdown */
+    protected boolean mExpireSessionsOnShutdown = true;
+    
+    /**
+     * The name of this manager
+     */
+    protected String name;
+
+    /**
+     * A reference to the cluster
+     */
+    protected CatalinaCluster cluster;
+    
+    /**
+     * Should listeners be notified?
+     */
+    private boolean notifyListenersOnReplication;
+    /**
+     * 
+     */
+    private int mapSendOptions = Channel.SEND_OPTIONS_SYNCHRONIZED_ACK|Channel.SEND_OPTIONS_USE_ACK;
+
+    /**
+     * Constructor, just calls super()
+     *
+     */
+    public BackupManager() {
+        super();
+    }
+
+
+//******************************************************************************/
+//      ClusterManager Interface     
+//******************************************************************************/
+
+    public void messageDataReceived(ClusterMessage msg) {
+    }
+
+    public boolean doDomainReplication() {
+        return false;
+    }
+
+    /**
+     * @param sendClusterDomainOnly The sendClusterDomainOnly to set.
+     */
+    public void setDomainReplication(boolean sendClusterDomainOnly) {
+    }
+
+    /**
+     * @return Returns the defaultMode.
+     */
+    public boolean isDefaultMode() {
+        return false;
+    }
+    /**
+     * @param defaultMode The defaultMode to set.
+     */
+    public void setDefaultMode(boolean defaultMode) {
+    }
+
+    public void setExpireSessionsOnShutdown(boolean expireSessionsOnShutdown)
+    {
+        mExpireSessionsOnShutdown = expireSessionsOnShutdown;
+    }
+
+    public void setCluster(CatalinaCluster cluster) {
+        if(log.isDebugEnabled())
+            log.debug("Cluster associated with SimpleTcpReplicationManager");
+        this.cluster = cluster;
+    }
+
+    public boolean getExpireSessionsOnShutdown()
+    {
+        return mExpireSessionsOnShutdown;
+    }
+
+
+    /**
+     * Override persistence since they don't go hand in hand with replication for now.
+     */
+    public void unload() throws IOException {
+    }
+    
+    public ClusterMessage requestCompleted(String sessionId) {
+        if ( !this.started ) return null;
+        LazyReplicatedMap map = (LazyReplicatedMap)sessions;
+        map.replicate(sessionId,false);
+        return null;
+    }
+
+
+//=========================================================================
+// OVERRIDE THESE METHODS TO IMPLEMENT THE REPLICATION
+//=========================================================================
+
+    public Session createEmptySession() {
+        return new DeltaSession(this);
+    }
+    
+    public ClassLoader[] getClassLoaders() {
+        return ClusterManagerBase.getClassLoaders(this.container);
+    }
+
+    /**
+     * Open Stream and use correct ClassLoader (Container) Switch
+     * ThreadClassLoader
+     * 
+     * @param data
+     * @return The object input stream
+     * @throws IOException
+     */
+    public ReplicationStream getReplicationStream(byte[] data) throws IOException {
+        return getReplicationStream(data,0,data.length);
+    }
+
+    public ReplicationStream getReplicationStream(byte[] data, int offset, int length) throws IOException {
+        ByteArrayInputStream fis = new ByteArrayInputStream(data, offset, length);
+        return new ReplicationStream(fis, getClassLoaders());
+    }    
+
+
+
+
+    public String getName() {
+        return this.name;
+    }
+    /**
+     * Prepare for the beginning of active use of the public methods of this
+     * component.  This method should be called after <code>configure()</code>,
+     * and before any of the public methods of the component are utilized.<BR>
+     * Starts the cluster communication channel, this will connect with the other nodes
+     * in the cluster, and request the current session state to be transferred to this node.
+     * @exception IllegalStateException if this component has already been
+     *  started
+     * @exception LifecycleException if this component detects a fatal error
+     *  that prevents this component from being used
+     */
+    public void start() throws LifecycleException {
+        if ( this.started ) return;
+        
+        try {
+            cluster.registerManager(this);
+            CatalinaCluster catclust = (CatalinaCluster)cluster;
+            LazyReplicatedMap map = new LazyReplicatedMap(this,
+                                                          catclust.getChannel(),
+                                                          DEFAULT_REPL_TIMEOUT,
+                                                          getMapName(),
+                                                          getClassLoaders());
+            map.setChannelSendOptions(mapSendOptions);
+            this.sessions = map;
+            super.start();
+            this.started = true;
+        }  catch ( Exception x ) {
+            log.error("Unable to start BackupManager",x);
+            throw new LifecycleException("Failed to start BackupManager",x);
+        }
+    }
+    
+    public String getMapName() {
+        CatalinaCluster catclust = (CatalinaCluster)cluster;
+        String name = catclust.getManagerName(getName(),this)+"-"+"map";
+        if ( log.isDebugEnabled() ) log.debug("Backup manager, Setting map name to:"+name);
+        return name;
+    }
+
+    /**
+     * Gracefully terminate the active use of the public methods of this
+     * component.  This method should be the last one called on a given
+     * instance of this component.<BR>
+     * This will disconnect the cluster communication channel and stop the listener thread.
+     * @exception IllegalStateException if this component has not been started
+     * @exception LifecycleException if this component detects a fatal error
+     *  that needs to be reported
+     */
+    public void stop() throws LifecycleException
+    {
+        
+        LazyReplicatedMap map = (LazyReplicatedMap)sessions;
+        if ( map!=null ) {
+            map.breakdown();
+        }
+        if ( !this.started ) return;
+        try {
+        } catch ( Exception x ){
+            log.error("Unable to stop BackupManager",x);
+            throw new LifecycleException("Failed to stop BackupManager",x);
+        } finally {
+            super.stop();
+        }
+        cluster.removeManager(this);
+
+    }
+
+    public void setDistributable(boolean dist) {
+        this.distributable = dist;
+    }
+
+    public boolean getDistributable() {
+        return distributable;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+    public boolean isNotifyListenersOnReplication() {
+        return notifyListenersOnReplication;
+    }
+    public void setNotifyListenersOnReplication(boolean notifyListenersOnReplication) {
+        this.notifyListenersOnReplication = notifyListenersOnReplication;
+    }
+
+    public void setMapSendOptions(int mapSendOptions) {
+        this.mapSendOptions = mapSendOptions;
+    }
+
+    /* 
+     * @see org.apache.catalina.ha.ClusterManager#getCluster()
+     */
+    public CatalinaCluster getCluster() {
+        return cluster;
+    }
+
+    public int getMapSendOptions() {
+        return mapSendOptions;
+    }
+
+    public String[] getInvalidatedSessions() {
+        return new String[0];
+    }
+    
+    public ClusterManager cloneFromTemplate() {
+        BackupManager result = new BackupManager();
+        result.mExpireSessionsOnShutdown = mExpireSessionsOnShutdown;
+        result.name = "Clone-from-"+name;
+        result.cluster = cluster;
+        result.notifyListenersOnReplication = notifyListenersOnReplication;
+        result.mapSendOptions = mapSendOptions;
+        return result;
+    }
+
+}

==================================================
ClusterSessionListener.java
index bdcebd1e05..90a50f1764 100644
--- a/java/org/apache/catalina/ha/session/ClusterManagerBase.java
+++ b/java/org/apache/catalina/ha/session/ClusterManagerBase.java
@@ -1,75 +1,75 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha.session;
-
-import org.apache.catalina.ha.ClusterManager;
-import java.beans.PropertyChangeListener;
-import org.apache.catalina.Lifecycle;
-import org.apache.catalina.session.ManagerBase;
-import org.apache.catalina.Loader;
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import org.apache.catalina.tribes.io.ReplicationStream;
-import org.apache.catalina.Container;
-
-/**
- * 
- * @author Filip Hanik
- * @version $Revision: 380100 $ $Date: 2006-02-23 06:08:14 -0600 (Thu, 23 Feb 2006) $
- */
-
-public abstract class ClusterManagerBase extends ManagerBase implements Lifecycle, PropertyChangeListener, ClusterManager{
-    
-
-    public static ClassLoader[] getClassLoaders(Container container) {
-        Loader loader = null;
-        ClassLoader classLoader = null;
-        if (container != null) loader = container.getLoader();
-        if (loader != null) classLoader = loader.getClassLoader();
-        else classLoader = Thread.currentThread().getContextClassLoader();
-        if ( classLoader == Thread.currentThread().getContextClassLoader() ) {
-            return new ClassLoader[] {classLoader};
-        } else {
-            return new ClassLoader[] {classLoader,Thread.currentThread().getContextClassLoader()};
-        }
-    }
-
-
-    public ClassLoader[] getClassLoaders() {
-        return getClassLoaders(container);
-    }
-
-    /**
-     * Open Stream and use correct ClassLoader (Container) Switch
-     * ThreadClassLoader
-     * 
-     * @param data
-     * @return The object input stream
-     * @throws IOException
-     */
-    public ReplicationStream getReplicationStream(byte[] data) throws IOException {
-        return getReplicationStream(data,0,data.length);
-    }
-
-    public ReplicationStream getReplicationStream(byte[] data, int offset, int length) throws IOException {
-        ByteArrayInputStream fis = new ByteArrayInputStream(data, offset, length);
-        return new ReplicationStream(fis, getClassLoaders());
-    }    
-
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha.session;
+
+import org.apache.catalina.ha.ClusterManager;
+import java.beans.PropertyChangeListener;
+import org.apache.catalina.Lifecycle;
+import org.apache.catalina.session.ManagerBase;
+import org.apache.catalina.Loader;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import org.apache.catalina.tribes.io.ReplicationStream;
+import org.apache.catalina.Container;
+
+/**
+ * 
+ * @author Filip Hanik
+ * @version $Revision$ $Date$
+ */
+
+public abstract class ClusterManagerBase extends ManagerBase implements Lifecycle, PropertyChangeListener, ClusterManager{
+    
+
+    public static ClassLoader[] getClassLoaders(Container container) {
+        Loader loader = null;
+        ClassLoader classLoader = null;
+        if (container != null) loader = container.getLoader();
+        if (loader != null) classLoader = loader.getClassLoader();
+        else classLoader = Thread.currentThread().getContextClassLoader();
+        if ( classLoader == Thread.currentThread().getContextClassLoader() ) {
+            return new ClassLoader[] {classLoader};
+        } else {
+            return new ClassLoader[] {classLoader,Thread.currentThread().getContextClassLoader()};
+        }
+    }
+
+
+    public ClassLoader[] getClassLoaders() {
+        return getClassLoaders(container);
+    }
+
+    /**
+     * Open Stream and use correct ClassLoader (Container) Switch
+     * ThreadClassLoader
+     * 
+     * @param data
+     * @return The object input stream
+     * @throws IOException
+     */
+    public ReplicationStream getReplicationStream(byte[] data) throws IOException {
+        return getReplicationStream(data,0,data.length);
+    }
+
+    public ReplicationStream getReplicationStream(byte[] data, int offset, int length) throws IOException {
+        ByteArrayInputStream fis = new ByteArrayInputStream(data, offset, length);
+        return new ReplicationStream(fis, getClassLoaders());
+    }    
+
+
 }
\ No newline at end of file

==================================================
Constants.java
index 14d2d03445..14a911447f 100644
--- a/java/org/apache/catalina/ha/session/ClusterSessionListener.java
+++ b/java/org/apache/catalina/ha/session/ClusterSessionListener.java
@@ -1,108 +1,108 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha.session;
-
-import java.util.Map;
-
-import org.apache.catalina.ha.ClusterManager;
-import org.apache.catalina.ha.ClusterMessage;
-import org.apache.catalina.ha.*;
-
-/**
- * Receive replicated SessionMessage form other cluster node.
- * @author Filip Hanik
- * @author Peter Rossbach
- * @version $Revision: 378258 $ $Date: 2006-02-16 08:42:35 -0600 (Thu, 16 Feb 2006) $
- */
-public class ClusterSessionListener extends ClusterListener {
- 
-    /**
-     * The descriptive information about this implementation.
-     */
-    protected static final String info = "org.apache.catalina.session.ClusterSessionListener/1.1";
-
-    //--Constructor---------------------------------------------
-
-    public ClusterSessionListener() {
-    }
-
-    //--Logic---------------------------------------------------
-
-    /**
-     * Return descriptive information about this implementation.
-     */
-    public String getInfo() {
-
-        return (info);
-
-    }
-
-    /**
-     * Callback from the cluster, when a message is received, The cluster will
-     * broadcast it invoking the messageReceived on the receiver.
-     * 
-     * @param myobj
-     *            ClusterMessage - the message received from the cluster
-     */
-    public void messageReceived(ClusterMessage myobj) {
-        if (myobj != null && myobj instanceof SessionMessage) {
-            SessionMessage msg = (SessionMessage) myobj;
-            String ctxname = msg.getContextName();
-            //check if the message is a EVT_GET_ALL_SESSIONS,
-            //if so, wait until we are fully started up
-            Map managers = cluster.getManagers() ;
-            if (ctxname == null) {
-                java.util.Iterator i = managers.keySet().iterator();
-                while (i.hasNext()) {
-                    String key = (String) i.next();
-                    ClusterManager mgr = (ClusterManager) managers.get(key);
-                    if (mgr != null)
-                        mgr.messageDataReceived(msg);
-                    else {
-                        //this happens a lot before the system has started
-                        // up
-                        if (log.isDebugEnabled())
-                            log.debug("Context manager doesn't exist:"
-                                    + key);
-                    }
-                }
-            } else {
-                ClusterManager mgr = (ClusterManager) managers.get(ctxname);
-                if (mgr != null)
-                    mgr.messageDataReceived(msg);
-                else if (log.isWarnEnabled())
-                    log.warn("Context manager doesn't exist:" + ctxname);
-            }
-        }
-        return;
-    }
-
-    /**
-     * Accept only SessionMessage
-     * 
-     * @param msg
-     *            ClusterMessage
-     * @return boolean - returns true to indicate that messageReceived should be
-     *         invoked. If false is returned, the messageReceived method will
-     *         not be invoked.
-     */
-    public boolean accept(ClusterMessage msg) {
-        return (msg instanceof SessionMessage);
-    }
-}
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha.session;
+
+import java.util.Map;
+
+import org.apache.catalina.ha.ClusterManager;
+import org.apache.catalina.ha.ClusterMessage;
+import org.apache.catalina.ha.*;
+
+/**
+ * Receive replicated SessionMessage form other cluster node.
+ * @author Filip Hanik
+ * @author Peter Rossbach
+ * @version $Revision$ $Date$
+ */
+public class ClusterSessionListener extends ClusterListener {
+ 
+    /**
+     * The descriptive information about this implementation.
+     */
+    protected static final String info = "org.apache.catalina.session.ClusterSessionListener/1.1";
+
+    //--Constructor---------------------------------------------
+
+    public ClusterSessionListener() {
+    }
+
+    //--Logic---------------------------------------------------
+
+    /**
+     * Return descriptive information about this implementation.
+     */
+    public String getInfo() {
+
+        return (info);
+
+    }
+
+    /**
+     * Callback from the cluster, when a message is received, The cluster will
+     * broadcast it invoking the messageReceived on the receiver.
+     * 
+     * @param myobj
+     *            ClusterMessage - the message received from the cluster
+     */
+    public void messageReceived(ClusterMessage myobj) {
+        if (myobj != null && myobj instanceof SessionMessage) {
+            SessionMessage msg = (SessionMessage) myobj;
+            String ctxname = msg.getContextName();
+            //check if the message is a EVT_GET_ALL_SESSIONS,
+            //if so, wait until we are fully started up
+            Map managers = cluster.getManagers() ;
+            if (ctxname == null) {
+                java.util.Iterator i = managers.keySet().iterator();
+                while (i.hasNext()) {
+                    String key = (String) i.next();
+                    ClusterManager mgr = (ClusterManager) managers.get(key);
+                    if (mgr != null)
+                        mgr.messageDataReceived(msg);
+                    else {
+                        //this happens a lot before the system has started
+                        // up
+                        if (log.isDebugEnabled())
+                            log.debug("Context manager doesn't exist:"
+                                    + key);
+                    }
+                }
+            } else {
+                ClusterManager mgr = (ClusterManager) managers.get(ctxname);
+                if (mgr != null)
+                    mgr.messageDataReceived(msg);
+                else if (log.isWarnEnabled())
+                    log.warn("Context manager doesn't exist:" + ctxname);
+            }
+        }
+        return;
+    }
+
+    /**
+     * Accept only SessionMessage
+     * 
+     * @param msg
+     *            ClusterMessage
+     * @return boolean - returns true to indicate that messageReceived should be
+     *         invoked. If false is returned, the messageReceived method will
+     *         not be invoked.
+     */
+    public boolean accept(ClusterMessage msg) {
+        return (msg instanceof SessionMessage);
+    }
+}
+

==================================================
DeltaManager.java
index 16e2e90856..6fe996b57f 100644
--- a/java/org/apache/catalina/ha/session/Constants.java
+++ b/java/org/apache/catalina/ha/session/Constants.java
@@ -1,32 +1,32 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina.ha.session;
-
-/**
- * Manifest constants for the <code>org.apache.catalina.ha.session</code>
- * package.
- *
- * @author Peter Rossbach Pero
- */
-
-public class Constants {
-
-    public static final String Package = "org.apache.catalina.ha.session";
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.catalina.ha.session;
+
+/**
+ * Manifest constants for the <code>org.apache.catalina.ha.session</code>
+ * package.
+ *
+ * @author Peter Rossbach Pero
+ */
+
+public class Constants {
+
+    public static final String Package = "org.apache.catalina.ha.session";
+
+}

==================================================
DeltaRequest.java
index 3aae2f950a..478d28f6f5 100644
--- a/java/org/apache/catalina/ha/session/DeltaManager.java
+++ b/java/org/apache/catalina/ha/session/DeltaManager.java
@@ -1,1520 +1,1520 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha.session;
-
-import java.beans.PropertyChangeEvent;
-import java.io.BufferedOutputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.Iterator;
-
-import org.apache.catalina.Cluster;
-import org.apache.catalina.Container;
-import org.apache.catalina.Context;
-import org.apache.catalina.Engine;
-import org.apache.catalina.Host;
-import org.apache.catalina.LifecycleException;
-import org.apache.catalina.LifecycleListener;
-import org.apache.catalina.Session;
-import org.apache.catalina.Valve;
-import org.apache.catalina.core.StandardContext;
-import org.apache.catalina.ha.CatalinaCluster;
-import org.apache.catalina.ha.ClusterMessage;
-import org.apache.catalina.ha.tcp.ReplicationValve;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.io.ReplicationStream;
-import org.apache.catalina.util.LifecycleSupport;
-import org.apache.catalina.util.StringManager;
-import org.apache.catalina.ha.ClusterManager;
-
-/**
- * The DeltaManager manages replicated sessions by only replicating the deltas
- * in data. For applications written to handle this, the DeltaManager is the
- * optimal way of replicating data.
- * 
- * This code is almost identical to StandardManager with a difference in how it
- * persists sessions and some modifications to it.
- * 
- * <b>IMPLEMENTATION NOTE </b>: Correct behavior of session storing and
- * reloading depends upon external calls to the <code>start()</code> and
- * <code>stop()</code> methods of this class at the correct times.
- * 
- * @author Filip Hanik
- * @author Craig R. McClanahan
- * @author Jean-Francois Arcand
- * @author Peter Rossbach
- * @version $Revision: 380100 $ $Date: 2006-02-23 06:08:14 -0600 (Thu, 23 Feb 2006) $
- */
-
-public class DeltaManager extends ClusterManagerBase{
-
-    // ---------------------------------------------------- Security Classes
-    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(DeltaManager.class);
-
-    /**
-     * The string manager for this package.
-     */
-    protected static StringManager sm = StringManager.getManager(Constants.Package);
-
-    // ----------------------------------------------------- Instance Variables
-
-    /**
-     * The descriptive information about this implementation.
-     */
-    private static final String info = "DeltaManager/2.1";
-
-    /**
-     * Has this component been started yet?
-     */
-    private boolean started = false;
-
-    /**
-     * The descriptive name of this Manager implementation (for logging).
-     */
-    protected static String managerName = "DeltaManager";
-    protected String name = null;
-    protected boolean defaultMode = false;
-    private CatalinaCluster cluster = null;
-
-    /**
-     * cached replication valve cluster container!
-     */
-    private ReplicationValve replicationValve = null ;
-    
-    /**
-     * The lifecycle event support for this component.
-     */
-    protected LifecycleSupport lifecycle = new LifecycleSupport(this);
-
-    /**
-     * The maximum number of active Sessions allowed, or -1 for no limit.
-     */
-    private int maxActiveSessions = -1;
-    private boolean expireSessionsOnShutdown = false;
-    private boolean notifyListenersOnReplication = true;
-    private boolean notifySessionListenersOnReplication = true;
-    private boolean stateTransfered = false ;
-    private int stateTransferTimeout = 60;
-    private boolean sendAllSessions = true;
-    private boolean sendClusterDomainOnly = true ;
-    private int sendAllSessionsSize = 1000 ;
-    
-    /**
-     * wait time between send session block (default 2 sec) 
-     */
-    private int sendAllSessionsWaitTime = 2 * 1000 ; 
-    private ArrayList receivedMessageQueue = new ArrayList() ;
-    private boolean receiverQueue = false ;
-    private boolean stateTimestampDrop = true ;
-    private long stateTransferCreateSendTime; 
-    
-    // ------------------------------------------------------------------ stats attributes
-    
-    int rejectedSessions = 0;
-    private long sessionReplaceCounter = 0 ;
-    long processingTime = 0;
-    private long counterReceive_EVT_GET_ALL_SESSIONS = 0 ;
-    private long counterSend_EVT_ALL_SESSION_DATA = 0 ;
-    private long counterReceive_EVT_ALL_SESSION_DATA = 0 ;
-    private long counterReceive_EVT_SESSION_CREATED = 0 ;
-    private long counterReceive_EVT_SESSION_EXPIRED = 0;
-    private long counterReceive_EVT_SESSION_ACCESSED = 0 ;
-    private long counterReceive_EVT_SESSION_DELTA = 0;
-    private long counterSend_EVT_GET_ALL_SESSIONS = 0 ;
-    private long counterSend_EVT_SESSION_CREATED = 0;
-    private long counterSend_EVT_SESSION_DELTA = 0 ;
-    private long counterSend_EVT_SESSION_ACCESSED = 0;
-    private long counterSend_EVT_SESSION_EXPIRED = 0;
-    private int counterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE = 0 ;
-    private int counterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE = 0 ;
-    private int counterNoStateTransfered = 0 ;
-
-
-    // ------------------------------------------------------------- Constructor
-    public DeltaManager() {
-        super();
-    }
-
-    // ------------------------------------------------------------- Properties
-    
-    /**
-     * Return descriptive information about this Manager implementation and the
-     * corresponding version number, in the format
-     * <code>&lt;description&gt;/&lt;version&gt;</code>.
-     */
-    public String getInfo() {
-        return info;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-
-    /**
-     * Return the descriptive short name of this Manager implementation.
-     */
-    public String getName() {
-        return name;
-    }
-
-    /**
-     * @return Returns the counterSend_EVT_GET_ALL_SESSIONS.
-     */
-    public long getCounterSend_EVT_GET_ALL_SESSIONS() {
-        return counterSend_EVT_GET_ALL_SESSIONS;
-    }
-    
-    /**
-     * @return Returns the counterSend_EVT_SESSION_ACCESSED.
-     */
-    public long getCounterSend_EVT_SESSION_ACCESSED() {
-        return counterSend_EVT_SESSION_ACCESSED;
-    }
-    
-    /**
-     * @return Returns the counterSend_EVT_SESSION_CREATED.
-     */
-    public long getCounterSend_EVT_SESSION_CREATED() {
-        return counterSend_EVT_SESSION_CREATED;
-    }
-
-    /**
-     * @return Returns the counterSend_EVT_SESSION_DELTA.
-     */
-    public long getCounterSend_EVT_SESSION_DELTA() {
-        return counterSend_EVT_SESSION_DELTA;
-    }
-
-    /**
-     * @return Returns the counterSend_EVT_SESSION_EXPIRED.
-     */
-    public long getCounterSend_EVT_SESSION_EXPIRED() {
-        return counterSend_EVT_SESSION_EXPIRED;
-    }
- 
-    /**
-     * @return Returns the counterSend_EVT_ALL_SESSION_DATA.
-     */
-    public long getCounterSend_EVT_ALL_SESSION_DATA() {
-        return counterSend_EVT_ALL_SESSION_DATA;
-    }
-
-    /**
-     * @return Returns the counterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE.
-     */
-    public int getCounterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE() {
-        return counterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE;
-    }
- 
-    /**
-     * @return Returns the counterReceive_EVT_ALL_SESSION_DATA.
-     */
-    public long getCounterReceive_EVT_ALL_SESSION_DATA() {
-        return counterReceive_EVT_ALL_SESSION_DATA;
-    }
-    
-    /**
-     * @return Returns the counterReceive_EVT_GET_ALL_SESSIONS.
-     */
-    public long getCounterReceive_EVT_GET_ALL_SESSIONS() {
-        return counterReceive_EVT_GET_ALL_SESSIONS;
-    }
-    
-    /**
-     * @return Returns the counterReceive_EVT_SESSION_ACCESSED.
-     */
-    public long getCounterReceive_EVT_SESSION_ACCESSED() {
-        return counterReceive_EVT_SESSION_ACCESSED;
-    }
-    
-    /**
-     * @return Returns the counterReceive_EVT_SESSION_CREATED.
-     */
-    public long getCounterReceive_EVT_SESSION_CREATED() {
-        return counterReceive_EVT_SESSION_CREATED;
-    }
-    
-    /**
-     * @return Returns the counterReceive_EVT_SESSION_DELTA.
-     */
-    public long getCounterReceive_EVT_SESSION_DELTA() {
-        return counterReceive_EVT_SESSION_DELTA;
-    }
-    
-    /**
-     * @return Returns the counterReceive_EVT_SESSION_EXPIRED.
-     */
-    public long getCounterReceive_EVT_SESSION_EXPIRED() {
-        return counterReceive_EVT_SESSION_EXPIRED;
-    }
-    
-    
-    /**
-     * @return Returns the counterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE.
-     */
-    public int getCounterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE() {
-        return counterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE;
-    }
-    
-    /**
-     * @return Returns the processingTime.
-     */
-    public long getProcessingTime() {
-        return processingTime;
-    }
- 
-    /**
-     * @return Returns the sessionReplaceCounter.
-     */
-    public long getSessionReplaceCounter() {
-        return sessionReplaceCounter;
-    }
-    
-    /**
-     * Number of session creations that failed due to maxActiveSessions
-     * 
-     * @return The count
-     */
-    public int getRejectedSessions() {
-        return rejectedSessions;
-    }
-
-    public void setRejectedSessions(int rejectedSessions) {
-        this.rejectedSessions = rejectedSessions;
-    }
-
-    /**
-     * @return Returns the counterNoStateTransfered.
-     */
-    public int getCounterNoStateTransfered() {
-        return counterNoStateTransfered;
-    }
-    
-    public int getReceivedQueueSize() {
-        return receivedMessageQueue.size() ;
-    }
-    
-    /**
-     * @return Returns the stateTransferTimeout.
-     */
-    public int getStateTransferTimeout() {
-        return stateTransferTimeout;
-    }
-    /**
-     * @param timeoutAllSession The timeout
-     */
-    public void setStateTransferTimeout(int timeoutAllSession) {
-        this.stateTransferTimeout = timeoutAllSession;
-    }
-
-    /**
-     * is session state transfered complete?
-     * 
-     */
-    public boolean getStateTransfered() {
-        return stateTransfered;
-    }
-
-    /**
-     * set that state ist complete transfered  
-     * @param stateTransfered
-     */
-    public void setStateTransfered(boolean stateTransfered) {
-        this.stateTransfered = stateTransfered;
-    }
-    
-    /**
-     * @return Returns the sendAllSessionsWaitTime in msec
-     */
-    public int getSendAllSessionsWaitTime() {
-        return sendAllSessionsWaitTime;
-    }
-    
-    /**
-     * @param sendAllSessionsWaitTime The sendAllSessionsWaitTime to set at msec.
-     */
-    public void setSendAllSessionsWaitTime(int sendAllSessionsWaitTime) {
-        this.sendAllSessionsWaitTime = sendAllSessionsWaitTime;
-    }
-    
-    /**
-     * @return Returns the sendClusterDomainOnly.
-     */
-    public boolean doDomainReplication() {
-        return sendClusterDomainOnly;
-    }
-    
-    /**
-     * @param sendClusterDomainOnly The sendClusterDomainOnly to set.
-     */
-    public void setDomainReplication(boolean sendClusterDomainOnly) {
-        this.sendClusterDomainOnly = sendClusterDomainOnly;
-    }
-
-    /**
-     * @return Returns the stateTimestampDrop.
-     */
-    public boolean isStateTimestampDrop() {
-        return stateTimestampDrop;
-    }
-    
-    /**
-     * @param isTimestampDrop The new flag value
-     */
-    public void setStateTimestampDrop(boolean isTimestampDrop) {
-        this.stateTimestampDrop = isTimestampDrop;
-    }
-    
-    /**
-     * Return the maximum number of active Sessions allowed, or -1 for no limit.
-     */
-    public int getMaxActiveSessions() {
-        return (this.maxActiveSessions);
-    }
-
-    /**
-     * Set the maximum number of actives Sessions allowed, or -1 for no limit.
-     * 
-     * @param max
-     *            The new maximum number of sessions
-     */
-    public void setMaxActiveSessions(int max) {
-        int oldMaxActiveSessions = this.maxActiveSessions;
-        this.maxActiveSessions = max;
-        support.firePropertyChange("maxActiveSessions", new Integer(oldMaxActiveSessions), new Integer(this.maxActiveSessions));
-    }
-    
-    /**
-     * 
-     * @return Returns the sendAllSessions.
-     */
-    public boolean isSendAllSessions() {
-        return sendAllSessions;
-    }
-    
-    /**
-     * @param sendAllSessions The sendAllSessions to set.
-     */
-    public void setSendAllSessions(boolean sendAllSessions) {
-        this.sendAllSessions = sendAllSessions;
-    }
-    
-    /**
-     * @return Returns the sendAllSessionsSize.
-     */
-    public int getSendAllSessionsSize() {
-        return sendAllSessionsSize;
-    }
-    
-    /**
-     * @param sendAllSessionsSize The sendAllSessionsSize to set.
-     */
-    public void setSendAllSessionsSize(int sendAllSessionsSize) {
-        this.sendAllSessionsSize = sendAllSessionsSize;
-    }
-    
-    /**
-     * @return Returns the notifySessionListenersOnReplication.
-     */
-    public boolean isNotifySessionListenersOnReplication() {
-        return notifySessionListenersOnReplication;
-    }
-    
-    /**
-     * @param notifyListenersCreateSessionOnReplication The notifySessionListenersOnReplication to set.
-     */
-    public void setNotifySessionListenersOnReplication(boolean notifyListenersCreateSessionOnReplication) {
-        this.notifySessionListenersOnReplication = notifyListenersCreateSessionOnReplication;
-    }
-    
-    
-    public boolean isExpireSessionsOnShutdown() {
-        return expireSessionsOnShutdown;
-    }
-
-    public void setExpireSessionsOnShutdown(boolean expireSessionsOnShutdown) {
-        this.expireSessionsOnShutdown = expireSessionsOnShutdown;
-    }
-    
-    public boolean isNotifyListenersOnReplication() {
-        return notifyListenersOnReplication;
-    }
-
-    public void setNotifyListenersOnReplication(boolean notifyListenersOnReplication) {
-        this.notifyListenersOnReplication = notifyListenersOnReplication;
-    }
-
-    
-    /**
-     * @return Returns the defaultMode.
-     */
-    public boolean isDefaultMode() {
-        return defaultMode;
-    }
-    /**
-     * @param defaultMode The defaultMode to set.
-     */
-    public void setDefaultMode(boolean defaultMode) {
-        this.defaultMode = defaultMode;
-    }
-    
-    public CatalinaCluster getCluster() {
-        return cluster;
-    }
-
-    public void setCluster(CatalinaCluster cluster) {
-        this.cluster = cluster;
-    }
-
-    /**
-     * Set the Container with which this Manager has been associated. If it is a
-     * Context (the usual case), listen for changes to the session timeout
-     * property.
-     * 
-     * @param container
-     *            The associated Container
-     */
-    public void setContainer(Container container) {
-        // De-register from the old Container (if any)
-        if ((this.container != null) && (this.container instanceof Context))
-            ((Context) this.container).removePropertyChangeListener(this);
-
-        // Default processing provided by our superclass
-        super.setContainer(container);
-
-        // Register with the new Container (if any)
-        if ((this.container != null) && (this.container instanceof Context)) {
-            setMaxInactiveInterval(((Context) this.container).getSessionTimeout() * 60);
-            ((Context) this.container).addPropertyChangeListener(this);
-        }
-
-    }
-    
-    // --------------------------------------------------------- Public Methods
-
-    /**
-     * Construct and return a new session object, based on the default settings
-     * specified by this Manager's properties. The session id will be assigned
-     * by this method, and available via the getId() method of the returned
-     * session. If a new session cannot be created for any reason, return
-     * <code>null</code>.
-     * 
-     * @exception IllegalStateException
-     *                if a new session cannot be instantiated for any reason
-     * 
-     * Construct and return a new session object, based on the default settings
-     * specified by this Manager's properties. The session id will be assigned
-     * by this method, and available via the getId() method of the returned
-     * session. If a new session cannot be created for any reason, return
-     * <code>null</code>.
-     * 
-     * @exception IllegalStateException
-     *                if a new session cannot be instantiated for any reason
-     */
-    public Session createSession(String sessionId) {
-        return createSession(sessionId, true);
-    }
-
-    /**
-     * create new session with check maxActiveSessions and send session creation
-     * to other cluster nodes.
-     * 
-     * @param distribute
-     * @return The session
-     */
-    public Session createSession(String sessionId, boolean distribute) {
-        if ((maxActiveSessions >= 0) && (sessions.size() >= maxActiveSessions)) {
-            rejectedSessions++;
-            throw new IllegalStateException(sm.getString("deltaManager.createSession.ise"));
-        }
-        DeltaSession session = (DeltaSession) super.createSession(sessionId) ;
-        if (distribute) {
-            sendCreateSession(session.getId(), session);
-        }
-        if (log.isDebugEnabled())
-            log.debug(sm.getString("deltaManager.createSession.newSession",session.getId(), new Integer(sessions.size())));
-        return (session);
-
-    }
-
-    /**
-     * Send create session evt to all backup node
-     * @param sessionId
-     * @param session
-     */
-    protected void sendCreateSession(String sessionId, DeltaSession session) {
-        if(cluster.getMembers().length > 0 ) {
-            SessionMessage msg = 
-                new SessionMessageImpl(getName(),
-                                       SessionMessage.EVT_SESSION_CREATED, 
-                                       null, 
-                                       sessionId,
-                                       sessionId + "-" + System.currentTimeMillis());
-            if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.sendMessage.newSession",name, sessionId));
-            msg.setTimestamp(session.getCreationTime());
-            counterSend_EVT_SESSION_CREATED++;
-            send(msg);
-        }
-    }
-    
-    /**
-     * Send messages to other backup member (domain or all)
-     * @param msg Session message
-     */
-    protected void send(SessionMessage msg) {
-        if(cluster != null) {
-            if(doDomainReplication())
-                cluster.sendClusterDomain(msg);
-            else
-                cluster.send(msg);
-        }
-    }
-
-    /**
-     * Create DeltaSession
-     * @see org.apache.catalina.Manager#createEmptySession()
-     */
-    public Session createEmptySession() {
-        return getNewDeltaSession() ;
-    }
-    
-    /**
-     * Get new session class to be used in the doLoad() method.
-     */
-    protected DeltaSession getNewDeltaSession() {
-        return new DeltaSession(this);
-    }
-
-    /**
-     * Load Deltarequest from external node
-     * Load the Class at container classloader
-     * @see DeltaRequest#readExternal(java.io.ObjectInput)
-     * @param session
-     * @param data message data
-     * @return The request
-     * @throws ClassNotFoundException
-     * @throws IOException
-     */
-    protected DeltaRequest deserializeDeltaRequest(DeltaSession session, byte[] data) throws ClassNotFoundException, IOException {
-        ReplicationStream ois = getReplicationStream(data);
-        session.getDeltaRequest().readExternal(ois);
-        ois.close();
-        return session.getDeltaRequest();
-    }
-
-    /**
-     * serialize DeltaRequest
-     * @see DeltaRequest#writeExternal(java.io.ObjectOutput)
-     * 
-     * @param deltaRequest
-     * @return serialized delta request
-     * @throws IOException
-     */
-    protected byte[] serializeDeltaRequest(DeltaRequest deltaRequest) throws IOException {
-        return deltaRequest.serialize();
-    }
-
-    /**
-     * Load sessions from other cluster node.
-     * FIXME replace currently sessions with same id without notifcation.
-     * FIXME SSO handling is not really correct with the session replacement!
-     * @exception ClassNotFoundException
-     *                if a serialized class cannot be found during the reload
-     * @exception IOException
-     *                if an input/output error occurs
-     */
-    protected void deserializeSessions(byte[] data) throws ClassNotFoundException,IOException {
-
-        // Initialize our internal data structures
-        //sessions.clear(); //should not do this
-        // Open an input stream to the specified pathname, if any
-        ClassLoader originalLoader = Thread.currentThread().getContextClassLoader();
-        ObjectInputStream ois = null;
-        // Load the previously unloaded active sessions
-        try {
-            ois = getReplicationStream(data);
-            Integer count = (Integer) ois.readObject();
-            int n = count.intValue();
-            for (int i = 0; i < n; i++) {
-                DeltaSession session = (DeltaSession) createEmptySession();
-                session.readObjectData(ois);
-                session.setManager(this);
-                session.setValid(true);
-                session.setPrimarySession(false);
-                //in case the nodes in the cluster are out of
-                //time synch, this will make sure that we have the
-                //correct timestamp, isValid returns true, cause
-                // accessCount=1
-                session.access();
-                //make sure that the session gets ready to expire if
-                // needed
-                session.setAccessCount(0);
-                session.resetDeltaRequest();
-                // FIXME How inform other session id cache like SingleSignOn
-                // increment sessionCounter to correct stats report
-                if (findSession(session.getIdInternal()) == null ) {
-                    sessionCounter++;
-                } else {
-                    sessionReplaceCounter++;
-                    // FIXME better is to grap this sessions again !
-                    if (log.isWarnEnabled()) log.warn(sm.getString("deltaManager.loading.existing.session",session.getIdInternal()));
-                }
-                add(session);
-            }
-        } catch (ClassNotFoundException e) {
-            log.error(sm.getString("deltaManager.loading.cnfe", e), e);
-            throw e;
-        } catch (IOException e) {
-            log.error(sm.getString("deltaManager.loading.ioe", e), e);
-            throw e;
-        } finally {
-            // Close the input stream
-            try {
-                if (ois != null) ois.close();
-            } catch (IOException f) {
-                // ignored
-            }
-            ois = null;
-            if (originalLoader != null) Thread.currentThread().setContextClassLoader(originalLoader);
-        }
-
-    }
-
-    
-
-    /**
-     * Save any currently active sessions in the appropriate persistence
-     * mechanism, if any. If persistence is not supported, this method returns
-     * without doing anything.
-     * 
-     * @exception IOException
-     *                if an input/output error occurs
-     */
-    protected byte[] serializeSessions(Session[] currentSessions) throws IOException {
-
-        // Open an output stream to the specified pathname, if any
-        ByteArrayOutputStream fos = null;
-        ObjectOutputStream oos = null;
-
-        try {
-            fos = new ByteArrayOutputStream();
-            oos = new ObjectOutputStream(new BufferedOutputStream(fos));
-            oos.writeObject(new Integer(currentSessions.length));
-            for(int i=0 ; i < currentSessions.length;i++) {
-                ((DeltaSession)currentSessions[i]).writeObjectData(oos);                
-            }
-            // Flush and close the output stream
-            oos.flush();
-        } catch (IOException e) {
-            log.error(sm.getString("deltaManager.unloading.ioe", e), e);
-            throw e;
-        } finally {
-            if (oos != null) {
-                try {
-                    oos.close();
-                } catch (IOException f) {
-                    ;
-                }
-                oos = null;
-            }
-        }
-        // send object data as byte[]
-        return fos.toByteArray();
-    }
-
-    // ------------------------------------------------------ Lifecycle Methods
-
-    /**
-     * Add a lifecycle event listener to this component.
-     * 
-     * @param listener
-     *            The listener to add
-     */
-    public void addLifecycleListener(LifecycleListener listener) {
-        lifecycle.addLifecycleListener(listener);
-    }
-
-    /**
-     * Get the lifecycle listeners associated with this lifecycle. If this
-     * Lifecycle has no listeners registered, a zero-length array is returned.
-     */
-    public LifecycleListener[] findLifecycleListeners() {
-        return lifecycle.findLifecycleListeners();
-    }
-
-    /**
-     * Remove a lifecycle event listener from this component.
-     * 
-     * @param listener
-     *            The listener to remove
-     */
-    public void removeLifecycleListener(LifecycleListener listener) {
-        lifecycle.removeLifecycleListener(listener);
-    }
-
-    /**
-     * Prepare for the beginning of active use of the public methods of this
-     * component. This method should be called after <code>configure()</code>,
-     * and before any of the public methods of the component are utilized.
-     * 
-     * @exception LifecycleException
-     *                if this component detects a fatal error that prevents this
-     *                component from being used
-     */
-    public void start() throws LifecycleException {
-        if (!initialized) init();
-
-        // Validate and update our current component state
-        if (started) {
-            return;
-        }
-        started = true;
-        lifecycle.fireLifecycleEvent(START_EVENT, null);
-
-        // Force initialization of the random number generator
-        generateSessionId();
-
-        // Load unloaded sessions, if any
-        try {
-            //the channel is already running
-            Cluster cluster = getCluster() ;
-            // stop remove cluster binding
-            //wow, how many nested levels of if statements can we have ;)
-            if(cluster == null) {
-                Container context = getContainer() ;
-                if(context != null && context instanceof Context) {
-                     Container host = context.getParent() ;
-                     if(host != null && host instanceof Host) {
-                         cluster = host.getCluster();
-                         if(cluster != null && cluster instanceof CatalinaCluster) {
-                             setCluster((CatalinaCluster) cluster) ;
-                         } else {
-                             Container engine = host.getParent() ;
-                             if(engine != null && engine instanceof Engine) {
-                                 cluster = engine.getCluster();
-                                 if(cluster != null && cluster instanceof CatalinaCluster) {
-                                     setCluster((CatalinaCluster) cluster) ;
-                                 }
-                             } else {
-                                     cluster = null ;
-                             }
-                         }
-                     }
-                }
-            }
-            if (cluster == null) {
-                log.error(sm.getString("deltaManager.noCluster", getName()));
-                return;
-            } else {
-                if (log.isInfoEnabled()) {
-                    String type = "unknown" ;
-                    if( cluster.getContainer() instanceof Host){
-                        type = "Host" ;
-                    } else if( cluster.getContainer() instanceof Engine){
-                        type = "Engine" ;
-                    }
-                    log.info(sm.getString("deltaManager.registerCluster", getName(), type, cluster.getClusterName()));
-                }
-            }
-            if (log.isInfoEnabled()) log.info(sm.getString("deltaManager.startClustering", getName()));
-            //to survice context reloads, as only a stop/start is called, not
-            // createManager
-            cluster.registerManager(this);
-
-            getAllClusterSessions();
-
-        } catch (Throwable t) {
-            log.error(sm.getString("deltaManager.managerLoad"), t);
-        }
-    }
-
-    /**
-     * get from first session master the backup from all clustered sessions
-     * @see #findSessionMasterMember()
-     */
-    public synchronized void getAllClusterSessions() {
-        if (cluster != null && cluster.getMembers().length > 0) {
-            long beforeSendTime = System.currentTimeMillis();
-            Member mbr = findSessionMasterMember();
-            if(mbr == null) { // No domain member found
-                 return;
-            }
-            SessionMessage msg = new SessionMessageImpl(this.getName(),SessionMessage.EVT_GET_ALL_SESSIONS, null, "GET-ALL","GET-ALL-" + getName());
-            // set reference time
-            stateTransferCreateSendTime = beforeSendTime ;
-            // request session state
-            counterSend_EVT_GET_ALL_SESSIONS++;
-            stateTransfered = false ;
-            // FIXME This send call block the deploy thread, when sender waitForAck is enabled
-            try {
-                synchronized(receivedMessageQueue) {
-                     receiverQueue = true ;
-                }
-                cluster.send(msg, mbr);
-                if (log.isWarnEnabled()) log.warn(sm.getString("deltaManager.waitForSessionState",getName(), mbr));
-                // FIXME At sender ack mode this method check only the state transfer and resend is a problem!
-                waitForSendAllSessions(beforeSendTime);
-            } finally {
-                synchronized(receivedMessageQueue) {
-                    for (Iterator iter = receivedMessageQueue.iterator(); iter.hasNext();) {
-                        SessionMessage smsg = (SessionMessage) iter.next();
-                        if (!stateTimestampDrop) {
-                            messageReceived(smsg, smsg.getAddress() != null ? (Member) smsg.getAddress() : null);
-                        } else {
-                            if (smsg.getEventType() != SessionMessage.EVT_GET_ALL_SESSIONS && smsg.getTimestamp() >= stateTransferCreateSendTime) {
-                                // FIXME handle EVT_GET_ALL_SESSIONS later
-                                messageReceived(smsg,smsg.getAddress() != null ? (Member) smsg.getAddress() : null);
-                            } else {
-                                if (log.isWarnEnabled()) {
-                                    log.warn(sm.getString("deltaManager.dropMessage",getName(), smsg.getEventTypeString(),new Date(stateTransferCreateSendTime), new Date(smsg.getTimestamp())));
-                                }
-                            }
-                        }
-                    }        
-                    receivedMessageQueue.clear();
-                    receiverQueue = false ;
-                }
-           }
-        } else {
-            if (log.isInfoEnabled()) log.info(sm.getString("deltaManager.noMembers", getName()));
-        }
-    }
-
-    /**
-     * Register cross context session at replication valve thread local
-     * @param session cross context session
-     */
-    protected void registerSessionAtReplicationValve(DeltaSession session) {
-        if(replicationValve == null) {
-            if(container instanceof StandardContext && ((StandardContext)container).getCrossContext()) {
-                Cluster cluster = getCluster() ;
-                if(cluster != null && cluster instanceof CatalinaCluster) {
-                    Valve[] valves = ((CatalinaCluster)cluster).getValves();
-                    if(valves != null && valves.length > 0) {
-                        for(int i=0; replicationValve == null && i < valves.length ; i++ ){
-                            if(valves[i] instanceof ReplicationValve) replicationValve = (ReplicationValve)valves[i] ;
-                        }//for
-
-                        if(replicationValve == null && log.isDebugEnabled()) {
-                            log.debug("no ReplicationValve found for CrossContext Support");
-                        }//endif 
-                    }//end if
-                }//endif
-            }//end if
-        }//end if
-        if(replicationValve != null) {
-            replicationValve.registerReplicationSession(session);
-        }
-    }
-    
-    /**
-     * Find the master of the session state
-     * @return master member of sessions 
-     */
-    protected Member findSessionMasterMember() {
-        Member mbr = null;
-        Member mbrs[] = cluster.getMembers();
-        if(mbrs.length != 0 ) mbr = mbrs[0];
-        if(mbr == null && log.isWarnEnabled()) log.warn(sm.getString("deltaManager.noMasterMember",getName(), ""));
-        if(mbr != null && log.isDebugEnabled()) log.warn(sm.getString("deltaManager.foundMasterMember",getName(), mbr));
-        return mbr;
-    }
-
-    /**
-     * Wait that cluster session state is transfer or timeout after 60 Sec
-     * With stateTransferTimeout == -1 wait that backup is transfered (forever mode)
-     */
-    protected void waitForSendAllSessions(long beforeSendTime) {
-        long reqStart = System.currentTimeMillis();
-        long reqNow = reqStart ;
-        boolean isTimeout = false;
-        if(getStateTransferTimeout() > 0) {
-            // wait that state is transfered with timeout check
-            do {
-                try {
-                    Thread.sleep(100);
-                } catch (Exception sleep) {
-                    //
-                }
-                reqNow = System.currentTimeMillis();
-                isTimeout = ((reqNow - reqStart) > (1000 * getStateTransferTimeout()));
-            } while ((!getStateTransfered()) && (!isTimeout));
-        } else {
-            if(getStateTransferTimeout() == -1) {
-                // wait that state is transfered
-                do {
-                    try {
-                        Thread.sleep(100);
-                    } catch (Exception sleep) {
-                    }
-                } while ((!getStateTransfered()));
-                reqNow = System.currentTimeMillis();
-            }
-        }
-        if (isTimeout || (!getStateTransfered())) {
-            counterNoStateTransfered++ ;
-            log.error(sm.getString("deltaManager.noSessionState",getName(),new Date(beforeSendTime),new Long(reqNow - beforeSendTime)));
-        } else {
-            if (log.isInfoEnabled())
-                log.info(sm.getString("deltaManager.sessionReceived",getName(), new Date(beforeSendTime), new Long(reqNow - beforeSendTime)));
-        }
-    }
-
-    /**
-     * Gracefully terminate the active use of the public methods of this
-     * component. This method should be the last one called on a given instance
-     * of this component.
-     * 
-     * @exception LifecycleException
-     *                if this component detects a fatal error that needs to be
-     *                reported
-     */
-    public void stop() throws LifecycleException {
-
-        if (log.isDebugEnabled())
-            log.debug(sm.getString("deltaManager.stopped", getName()));
-
-
-        // Validate and update our current component state
-        if (!started)
-            throw new LifecycleException(sm.getString("deltaManager.notStarted"));
-        lifecycle.fireLifecycleEvent(STOP_EVENT, null);
-        started = false;
-
-        // Expire all active sessions
-        if (log.isInfoEnabled()) log.info(sm.getString("deltaManager.expireSessions", getName()));
-        Session sessions[] = findSessions();
-        for (int i = 0; i < sessions.length; i++) {
-            DeltaSession session = (DeltaSession) sessions[i];
-            if (!session.isValid())
-                continue;
-            try {
-                session.expire(true, isExpireSessionsOnShutdown());
-            } catch (Throwable ignore) {
-                ;
-            } 
-        }
-
-        // Require a new random number generator if we are restarted
-        this.random = null;
-        getCluster().removeManager(this);
-        replicationValve = null;
-        if (initialized) {
-            destroy();
-        }
-    }
-
-    // ----------------------------------------- PropertyChangeListener Methods
-
-    /**
-     * Process property change events from our associated Context.
-     * 
-     * @param event
-     *            The property change event that has occurred
-     */
-    public void propertyChange(PropertyChangeEvent event) {
-
-        // Validate the source of this event
-        if (!(event.getSource() instanceof Context))
-            return;
-        // Process a relevant property change
-        if (event.getPropertyName().equals("sessionTimeout")) {
-            try {
-                setMaxInactiveInterval(((Integer) event.getNewValue()).intValue() * 60);
-            } catch (NumberFormatException e) {
-                log.error(sm.getString("deltaManager.sessionTimeout", event.getNewValue()));
-            }
-        }
-
-    }
-
-    // -------------------------------------------------------- Replication
-    // Methods
-
-    /**
-     * A message was received from another node, this is the callback method to
-     * implement if you are interested in receiving replication messages.
-     * 
-     * @param cmsg -
-     *            the message received.
-     */
-    public void messageDataReceived(ClusterMessage cmsg) {
-        if (cmsg != null && cmsg instanceof SessionMessage) {
-            SessionMessage msg = (SessionMessage) cmsg;
-            switch (msg.getEventType()) {
-                case SessionMessage.EVT_GET_ALL_SESSIONS:
-                case SessionMessage.EVT_SESSION_CREATED: 
-                case SessionMessage.EVT_SESSION_EXPIRED: 
-                case SessionMessage.EVT_SESSION_ACCESSED:
-                case SessionMessage.EVT_SESSION_DELTA: {
-                    synchronized(receivedMessageQueue) {
-                        if(receiverQueue) {
-                            receivedMessageQueue.add(msg);
-                            return ;
-                        }
-                    }
-                   break;
-                }
-                default: {
-                    //we didn't queue, do nothing
-                    break;
-                }
-            } //switch
-            
-            messageReceived(msg, msg.getAddress() != null ? (Member) msg.getAddress() : null);
-        }
-    }
-
-    /**
-     * When the request has been completed, the replication valve will notify
-     * the manager, and the manager will decide whether any replication is
-     * needed or not. If there is a need for replication, the manager will
-     * create a session message and that will be replicated. The cluster
-     * determines where it gets sent.
-     * 
-     * @param sessionId -
-     *            the sessionId that just completed.
-     * @return a SessionMessage to be sent,
-     */
-    public ClusterMessage requestCompleted(String sessionId) {
-        try {
-            DeltaSession session = (DeltaSession) findSession(sessionId);
-            DeltaRequest deltaRequest = session.getDeltaRequest();
-            SessionMessage msg = null;
-            boolean isDeltaRequest = false ;
-            synchronized(deltaRequest) {
-                isDeltaRequest = deltaRequest.getSize() > 0 ;
-                if (isDeltaRequest) {    
-                    counterSend_EVT_SESSION_DELTA++;
-                    byte[] data = serializeDeltaRequest(deltaRequest);
-                    msg = new SessionMessageImpl(getName(),
-                                                 SessionMessage.EVT_SESSION_DELTA, 
-                                                 data, 
-                                                 sessionId,
-                                                 sessionId + "-" + System.currentTimeMillis());
-                    session.resetDeltaRequest();
-                }  
-            }
-            if(!isDeltaRequest) {
-                if(!session.isPrimarySession()) {               
-                    counterSend_EVT_SESSION_ACCESSED++;
-                    msg = new SessionMessageImpl(getName(),
-                                                 SessionMessage.EVT_SESSION_ACCESSED, 
-                                                 null, 
-                                                 sessionId,
-                                                 sessionId + "-" + System.currentTimeMillis());
-                    if (log.isDebugEnabled()) {
-                        log.debug(sm.getString("deltaManager.createMessage.accessChangePrimary",getName(), sessionId));
-                    }
-                }    
-            } else { // log only outside synch block!
-                if (log.isDebugEnabled()) {
-                    log.debug(sm.getString("deltaManager.createMessage.delta",getName(), sessionId));
-                }
-            }
-            session.setPrimarySession(true);
-            //check to see if we need to send out an access message
-            if ((msg == null)) {
-                long replDelta = System.currentTimeMillis() - session.getLastTimeReplicated();
-                if (replDelta > (getMaxInactiveInterval() * 1000)) {
-                    counterSend_EVT_SESSION_ACCESSED++;
-                    msg = new SessionMessageImpl(getName(),
-                                                 SessionMessage.EVT_SESSION_ACCESSED, 
-                                                 null,
-                                                 sessionId, 
-                                                 sessionId + "-" + System.currentTimeMillis());
-                    if (log.isDebugEnabled()) {
-                        log.debug(sm.getString("deltaManager.createMessage.access", getName(),sessionId));
-                    }
-                }
-
-            }
-
-            //update last replicated time
-            if (msg != null) session.setLastTimeReplicated(System.currentTimeMillis());
-            return msg;
-        } catch (IOException x) {
-            log.error(sm.getString("deltaManager.createMessage.unableCreateDeltaRequest",sessionId), x);
-            return null;
-        }
-
-    }
-    /**
-     * Reset manager statistics
-     */
-    public synchronized void resetStatistics() {
-        processingTime = 0 ;
-        expiredSessions = 0 ;
-        rejectedSessions = 0 ;
-        sessionReplaceCounter = 0 ;
-        counterNoStateTransfered = 0 ;
-        maxActive = getActiveSessions() ;
-        sessionCounter = getActiveSessions() ;
-        counterReceive_EVT_ALL_SESSION_DATA = 0;
-        counterReceive_EVT_GET_ALL_SESSIONS = 0;
-        counterReceive_EVT_SESSION_ACCESSED = 0 ;
-        counterReceive_EVT_SESSION_CREATED = 0 ;
-        counterReceive_EVT_SESSION_DELTA = 0 ;
-        counterReceive_EVT_SESSION_EXPIRED = 0 ;
-        counterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE = 0;
-        counterSend_EVT_ALL_SESSION_DATA = 0;
-        counterSend_EVT_GET_ALL_SESSIONS = 0;
-        counterSend_EVT_SESSION_ACCESSED = 0 ;
-        counterSend_EVT_SESSION_CREATED = 0 ;
-        counterSend_EVT_SESSION_DELTA = 0 ;
-        counterSend_EVT_SESSION_EXPIRED = 0 ;
-        counterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE = 0;
-        
-    }
-   
-    //  -------------------------------------------------------- persistence handler
-
-    public void load() {
-
-    }
-
-    public void unload() {
-
-    }
-
-    //  -------------------------------------------------------- expire
-
-    /**
-     * send session expired to other cluster nodes
-     * 
-     * @param id
-     *            session id
-     */
-    protected void sessionExpired(String id) {
-        counterSend_EVT_SESSION_EXPIRED++ ;
-        SessionMessage msg = new SessionMessageImpl(getName(),SessionMessage.EVT_SESSION_EXPIRED, null, id, id+ "-EXPIRED-MSG");
-        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.createMessage.expire",getName(), id));
-        send(msg);
-    }
-
-    /**
-     * Exipre all find sessions.
-     */
-    public void expireAllLocalSessions()
-    {
-        long timeNow = System.currentTimeMillis();
-        Session sessions[] = findSessions();
-        int expireDirect  = 0 ;
-        int expireIndirect = 0 ;
-        
-        if(log.isDebugEnabled()) log.debug("Start expire all sessions " + getName() + " at " + timeNow + " sessioncount " + sessions.length);
-        for (int i = 0; i < sessions.length; i++) {
-            if (sessions[i] instanceof DeltaSession) {
-                DeltaSession session = (DeltaSession) sessions[i];
-                if (session.isPrimarySession()) {
-                    if (session.isValid()) {
-                        session.expire();
-                        expireDirect++;
-                    } else {
-                        expireIndirect++;
-                    }//end if
-                }//end if
-            }//end if
-        }//for
-        long timeEnd = System.currentTimeMillis();
-        if(log.isDebugEnabled()) log.debug("End expire sessions " + getName() + " exipre processingTime " + (timeEnd - timeNow) + " expired direct sessions: " + expireDirect + " expired direct sessions: " + expireIndirect);
-      
-    }
-    
-    /**
-     * When the manager expires session not tied to a request. The cluster will
-     * periodically ask for a list of sessions that should expire and that
-     * should be sent across the wire.
-     * 
-     * @return The invalidated sessions array
-     */
-    public String[] getInvalidatedSessions() {
-        return new String[0];
-    }
-
-    //  -------------------------------------------------------- message receive
-
-    /**
-     * Test that sender and local domain is the same
-     */
-    protected boolean checkSenderDomain(SessionMessage msg,Member sender) {
-        boolean sameDomain= true;
-        if (!sameDomain && log.isWarnEnabled()) {
-                log.warn(sm.getString("deltaManager.receiveMessage.fromWrongDomain",
-                         new Object[] {getName(), 
-                         msg.getEventTypeString(), 
-                         sender,
-                         "",
-                         "" }));
-        }
-        return sameDomain ;
-    }
-
-    /**
-     * This method is called by the received thread when a SessionMessage has
-     * been received from one of the other nodes in the cluster.
-     * 
-     * @param msg -
-     *            the message received
-     * @param sender -
-     *            the sender of the message, this is used if we receive a
-     *            EVT_GET_ALL_SESSION message, so that we only reply to the
-     *            requesting node
-     */
-    protected void messageReceived(SessionMessage msg, Member sender) {
-        if(doDomainReplication() && !checkSenderDomain(msg,sender)) {
-            return;
-        }
-        ClassLoader contextLoader = Thread.currentThread().getContextClassLoader();
-        try {
-            
-            ClassLoader[] loaders = getClassLoaders();
-            if ( loaders != null && loaders.length > 0) Thread.currentThread().setContextClassLoader(loaders[0]);
-            if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.eventType",getName(), msg.getEventTypeString(), sender));
- 
-            switch (msg.getEventType()) {
-                case SessionMessage.EVT_GET_ALL_SESSIONS: {
-                    handleGET_ALL_SESSIONS(msg,sender);
-                    break;
-                }
-                case SessionMessage.EVT_ALL_SESSION_DATA: {
-                    handleALL_SESSION_DATA(msg,sender);
-                    break;
-                }
-                case SessionMessage.EVT_ALL_SESSION_TRANSFERCOMPLETE: {
-                    handleALL_SESSION_TRANSFERCOMPLETE(msg,sender);
-                    break;
-                }
-                case SessionMessage.EVT_SESSION_CREATED: {
-                    handleSESSION_CREATED(msg,sender);
-                    break;
-                }
-                case SessionMessage.EVT_SESSION_EXPIRED: {
-                    handleSESSION_EXPIRED(msg,sender);
-                    break;
-                }
-                case SessionMessage.EVT_SESSION_ACCESSED: {
-                    handleSESSION_ACCESSED(msg,sender);
-                    break;
-                }
-                case SessionMessage.EVT_SESSION_DELTA: {
-                   handleSESSION_DELTA(msg,sender);
-                   break;
-                }
-                default: {
-                    //we didn't recognize the message type, do nothing
-                    break;
-                }
-            } //switch
-        } catch (Exception x) {
-            log.error(sm.getString("deltaManager.receiveMessage.error",getName()), x);
-        } finally {
-            Thread.currentThread().setContextClassLoader(contextLoader);
-        }
-    }
-
-    // -------------------------------------------------------- message receiver handler
-
-
-    /**
-     * handle receive session state is complete transfered
-     * @param msg
-     * @param sender
-     */
-    protected void handleALL_SESSION_TRANSFERCOMPLETE(SessionMessage msg, Member sender) {
-        counterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE++ ;
-        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.transfercomplete",getName(), sender.getHost(), new Integer(sender.getPort())));
-        stateTransferCreateSendTime = msg.getTimestamp() ;
-        stateTransfered = true ;
-    }
-
-    /**
-     * handle receive session delta
-     * @param msg
-     * @param sender
-     * @throws IOException
-     * @throws ClassNotFoundException
-     */
-    protected void handleSESSION_DELTA(SessionMessage msg, Member sender) throws IOException, ClassNotFoundException {
-        counterReceive_EVT_SESSION_DELTA++;
-        byte[] delta = msg.getSession();
-        DeltaSession session = (DeltaSession) findSession(msg.getSessionID());
-        if (session != null) {
-            if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.delta",getName(), msg.getSessionID()));
-            DeltaRequest dreq = deserializeDeltaRequest(session, delta);
-            dreq.execute(session, notifyListenersOnReplication);
-            session.setPrimarySession(false);
-        }
-    }
-
-    /**
-     * handle receive session is access at other node ( primary session is now false)
-     * @param msg
-     * @param sender
-     * @throws IOException
-     */
-    protected void handleSESSION_ACCESSED(SessionMessage msg,Member sender) throws IOException {
-        counterReceive_EVT_SESSION_ACCESSED++;
-        DeltaSession session = (DeltaSession) findSession(msg.getSessionID());
-        if (session != null) {
-            if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.accessed",getName(), msg.getSessionID()));
-            session.access();
-            session.setPrimarySession(false);
-            session.endAccess();
-        }
-    }
-
-    /**
-     * handle receive session is expire at other node ( expire session also here)
-     * @param msg
-     * @param sender
-     * @throws IOException
-     */
-    protected void handleSESSION_EXPIRED(SessionMessage msg,Member sender) throws IOException {
-        counterReceive_EVT_SESSION_EXPIRED++;
-        DeltaSession session = (DeltaSession) findSession(msg.getSessionID());
-        if (session != null) {
-            if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.expired",getName(), msg.getSessionID()));
-            session.expire(notifySessionListenersOnReplication, false);
-        }
-    }
-
-    /**
-     * handle receive new session is created at other node (create backup - primary false)
-     * @param msg
-     * @param sender
-     */
-    protected void handleSESSION_CREATED(SessionMessage msg,Member sender) {
-        counterReceive_EVT_SESSION_CREATED++;
-        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.createNewSession",getName(), msg.getSessionID()));
-        DeltaSession session = (DeltaSession) createEmptySession();
-        session.setManager(this);
-        session.setValid(true);
-        session.setPrimarySession(false);
-        session.setCreationTime(msg.getTimestamp());
-        session.access();
-        if(notifySessionListenersOnReplication)
-            session.setId(msg.getSessionID());
-        else
-            session.setIdInternal(msg.getSessionID());
-        session.resetDeltaRequest();
-        session.endAccess();
-
-    }
-
-    /**
-     * handle receive sessions from other not ( restart )
-     * @param msg
-     * @param sender
-     * @throws ClassNotFoundException
-     * @throws IOException
-     */
-    protected void handleALL_SESSION_DATA(SessionMessage msg,Member sender) throws ClassNotFoundException, IOException {
-        counterReceive_EVT_ALL_SESSION_DATA++;
-        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.allSessionDataBegin",getName()));
-        byte[] data = msg.getSession();
-        deserializeSessions(data);
-        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.allSessionDataAfter",getName()));
-        //stateTransferred = true;
-    }
-
-    /**
-     * handle receive that other node want all sessions ( restart )
-     * a) send all sessions with one message
-     * b) send session at blocks
-     * After sending send state is complete transfered
-     * @param msg
-     * @param sender
-     * @throws IOException
-     */
-    protected void handleGET_ALL_SESSIONS(SessionMessage msg, Member sender) throws IOException {
-        counterReceive_EVT_GET_ALL_SESSIONS++;
-        //get a list of all the session from this manager
-        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.unloadingBegin", getName()));
-        // Write the number of active sessions, followed by the details
-        // get all sessions and serialize without sync
-        Session[] currentSessions = findSessions();
-        long findSessionTimestamp = System.currentTimeMillis() ;
-        if (isSendAllSessions()) {
-            sendSessions(sender, currentSessions, findSessionTimestamp);
-        } else {
-            // send session at blocks
-            int len = currentSessions.length < getSendAllSessionsSize() ? currentSessions.length : getSendAllSessionsSize();
-            Session[] sendSessions = new Session[len];
-            for (int i = 0; i < currentSessions.length; i += getSendAllSessionsSize()) {
-                len = i + getSendAllSessionsSize() > currentSessions.length ? currentSessions.length - i : getSendAllSessionsSize();
-                System.arraycopy(currentSessions, i, sendSessions, 0, len);
-                sendSessions(sender, sendSessions,findSessionTimestamp);
-                if (getSendAllSessionsWaitTime() > 0) {
-                    try {
-                        Thread.sleep(getSendAllSessionsWaitTime());
-                    } catch (Exception sleep) {
-                    }
-                }//end if
-            }//for
-        }//end if
-        
-        SessionMessage newmsg = new SessionMessageImpl(name,SessionMessage.EVT_ALL_SESSION_TRANSFERCOMPLETE, null,"SESSION-STATE-TRANSFERED", "SESSION-STATE-TRANSFERED"+ getName());
-        newmsg.setTimestamp(findSessionTimestamp);
-        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.createMessage.allSessionTransfered",getName()));
-        counterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE++;
-        cluster.send(newmsg, sender);
-    }
-
-
-    /**
-     * send a block of session to sender
-     * @param sender
-     * @param currentSessions
-     * @param sendTimestamp
-     * @throws IOException
-     */
-    protected void sendSessions(Member sender, Session[] currentSessions,long sendTimestamp) throws IOException {
-        byte[] data = serializeSessions(currentSessions);
-        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.unloadingAfter",getName()));
-        SessionMessage newmsg = new SessionMessageImpl(name,SessionMessage.EVT_ALL_SESSION_DATA, data,"SESSION-STATE", "SESSION-STATE-" + getName());
-        newmsg.setTimestamp(sendTimestamp);
-        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.createMessage.allSessionData",getName()));
-        counterSend_EVT_ALL_SESSION_DATA++;
-        cluster.send(newmsg, sender);
-    }
-
-    public ClusterManager cloneFromTemplate() {
-        DeltaManager result = new DeltaManager();
-        result.name = "Clone-from-"+name;
-        result.cluster = cluster;
-        result.replicationValve = replicationValve;
-        result.maxActiveSessions = maxActiveSessions;
-        result.expireSessionsOnShutdown = expireSessionsOnShutdown;
-        result.notifyListenersOnReplication = notifyListenersOnReplication;
-        result.notifySessionListenersOnReplication = notifySessionListenersOnReplication;
-        result.stateTransferTimeout = stateTransferTimeout;
-        result.sendAllSessions = sendAllSessions;
-        result.sendClusterDomainOnly = sendClusterDomainOnly ;
-        result.sendAllSessionsSize = sendAllSessionsSize;
-        result.sendAllSessionsWaitTime = sendAllSessionsWaitTime ; 
-        result.receiverQueue = receiverQueue ;
-        result.stateTimestampDrop = stateTimestampDrop ;
-        result.stateTransferCreateSendTime = stateTransferCreateSendTime; 
-        return result;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha.session;
+
+import java.beans.PropertyChangeEvent;
+import java.io.BufferedOutputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.Iterator;
+
+import org.apache.catalina.Cluster;
+import org.apache.catalina.Container;
+import org.apache.catalina.Context;
+import org.apache.catalina.Engine;
+import org.apache.catalina.Host;
+import org.apache.catalina.LifecycleException;
+import org.apache.catalina.LifecycleListener;
+import org.apache.catalina.Session;
+import org.apache.catalina.Valve;
+import org.apache.catalina.core.StandardContext;
+import org.apache.catalina.ha.CatalinaCluster;
+import org.apache.catalina.ha.ClusterMessage;
+import org.apache.catalina.ha.tcp.ReplicationValve;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.io.ReplicationStream;
+import org.apache.catalina.util.LifecycleSupport;
+import org.apache.catalina.util.StringManager;
+import org.apache.catalina.ha.ClusterManager;
+
+/**
+ * The DeltaManager manages replicated sessions by only replicating the deltas
+ * in data. For applications written to handle this, the DeltaManager is the
+ * optimal way of replicating data.
+ * 
+ * This code is almost identical to StandardManager with a difference in how it
+ * persists sessions and some modifications to it.
+ * 
+ * <b>IMPLEMENTATION NOTE </b>: Correct behavior of session storing and
+ * reloading depends upon external calls to the <code>start()</code> and
+ * <code>stop()</code> methods of this class at the correct times.
+ * 
+ * @author Filip Hanik
+ * @author Craig R. McClanahan
+ * @author Jean-Francois Arcand
+ * @author Peter Rossbach
+ * @version $Revision$ $Date$
+ */
+
+public class DeltaManager extends ClusterManagerBase{
+
+    // ---------------------------------------------------- Security Classes
+    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(DeltaManager.class);
+
+    /**
+     * The string manager for this package.
+     */
+    protected static StringManager sm = StringManager.getManager(Constants.Package);
+
+    // ----------------------------------------------------- Instance Variables
+
+    /**
+     * The descriptive information about this implementation.
+     */
+    private static final String info = "DeltaManager/2.1";
+
+    /**
+     * Has this component been started yet?
+     */
+    private boolean started = false;
+
+    /**
+     * The descriptive name of this Manager implementation (for logging).
+     */
+    protected static String managerName = "DeltaManager";
+    protected String name = null;
+    protected boolean defaultMode = false;
+    private CatalinaCluster cluster = null;
+
+    /**
+     * cached replication valve cluster container!
+     */
+    private ReplicationValve replicationValve = null ;
+    
+    /**
+     * The lifecycle event support for this component.
+     */
+    protected LifecycleSupport lifecycle = new LifecycleSupport(this);
+
+    /**
+     * The maximum number of active Sessions allowed, or -1 for no limit.
+     */
+    private int maxActiveSessions = -1;
+    private boolean expireSessionsOnShutdown = false;
+    private boolean notifyListenersOnReplication = true;
+    private boolean notifySessionListenersOnReplication = true;
+    private boolean stateTransfered = false ;
+    private int stateTransferTimeout = 60;
+    private boolean sendAllSessions = true;
+    private boolean sendClusterDomainOnly = true ;
+    private int sendAllSessionsSize = 1000 ;
+    
+    /**
+     * wait time between send session block (default 2 sec) 
+     */
+    private int sendAllSessionsWaitTime = 2 * 1000 ; 
+    private ArrayList receivedMessageQueue = new ArrayList() ;
+    private boolean receiverQueue = false ;
+    private boolean stateTimestampDrop = true ;
+    private long stateTransferCreateSendTime; 
+    
+    // ------------------------------------------------------------------ stats attributes
+    
+    int rejectedSessions = 0;
+    private long sessionReplaceCounter = 0 ;
+    long processingTime = 0;
+    private long counterReceive_EVT_GET_ALL_SESSIONS = 0 ;
+    private long counterSend_EVT_ALL_SESSION_DATA = 0 ;
+    private long counterReceive_EVT_ALL_SESSION_DATA = 0 ;
+    private long counterReceive_EVT_SESSION_CREATED = 0 ;
+    private long counterReceive_EVT_SESSION_EXPIRED = 0;
+    private long counterReceive_EVT_SESSION_ACCESSED = 0 ;
+    private long counterReceive_EVT_SESSION_DELTA = 0;
+    private long counterSend_EVT_GET_ALL_SESSIONS = 0 ;
+    private long counterSend_EVT_SESSION_CREATED = 0;
+    private long counterSend_EVT_SESSION_DELTA = 0 ;
+    private long counterSend_EVT_SESSION_ACCESSED = 0;
+    private long counterSend_EVT_SESSION_EXPIRED = 0;
+    private int counterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE = 0 ;
+    private int counterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE = 0 ;
+    private int counterNoStateTransfered = 0 ;
+
+
+    // ------------------------------------------------------------- Constructor
+    public DeltaManager() {
+        super();
+    }
+
+    // ------------------------------------------------------------- Properties
+    
+    /**
+     * Return descriptive information about this Manager implementation and the
+     * corresponding version number, in the format
+     * <code>&lt;description&gt;/&lt;version&gt;</code>.
+     */
+    public String getInfo() {
+        return info;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    /**
+     * Return the descriptive short name of this Manager implementation.
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * @return Returns the counterSend_EVT_GET_ALL_SESSIONS.
+     */
+    public long getCounterSend_EVT_GET_ALL_SESSIONS() {
+        return counterSend_EVT_GET_ALL_SESSIONS;
+    }
+    
+    /**
+     * @return Returns the counterSend_EVT_SESSION_ACCESSED.
+     */
+    public long getCounterSend_EVT_SESSION_ACCESSED() {
+        return counterSend_EVT_SESSION_ACCESSED;
+    }
+    
+    /**
+     * @return Returns the counterSend_EVT_SESSION_CREATED.
+     */
+    public long getCounterSend_EVT_SESSION_CREATED() {
+        return counterSend_EVT_SESSION_CREATED;
+    }
+
+    /**
+     * @return Returns the counterSend_EVT_SESSION_DELTA.
+     */
+    public long getCounterSend_EVT_SESSION_DELTA() {
+        return counterSend_EVT_SESSION_DELTA;
+    }
+
+    /**
+     * @return Returns the counterSend_EVT_SESSION_EXPIRED.
+     */
+    public long getCounterSend_EVT_SESSION_EXPIRED() {
+        return counterSend_EVT_SESSION_EXPIRED;
+    }
+ 
+    /**
+     * @return Returns the counterSend_EVT_ALL_SESSION_DATA.
+     */
+    public long getCounterSend_EVT_ALL_SESSION_DATA() {
+        return counterSend_EVT_ALL_SESSION_DATA;
+    }
+
+    /**
+     * @return Returns the counterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE.
+     */
+    public int getCounterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE() {
+        return counterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE;
+    }
+ 
+    /**
+     * @return Returns the counterReceive_EVT_ALL_SESSION_DATA.
+     */
+    public long getCounterReceive_EVT_ALL_SESSION_DATA() {
+        return counterReceive_EVT_ALL_SESSION_DATA;
+    }
+    
+    /**
+     * @return Returns the counterReceive_EVT_GET_ALL_SESSIONS.
+     */
+    public long getCounterReceive_EVT_GET_ALL_SESSIONS() {
+        return counterReceive_EVT_GET_ALL_SESSIONS;
+    }
+    
+    /**
+     * @return Returns the counterReceive_EVT_SESSION_ACCESSED.
+     */
+    public long getCounterReceive_EVT_SESSION_ACCESSED() {
+        return counterReceive_EVT_SESSION_ACCESSED;
+    }
+    
+    /**
+     * @return Returns the counterReceive_EVT_SESSION_CREATED.
+     */
+    public long getCounterReceive_EVT_SESSION_CREATED() {
+        return counterReceive_EVT_SESSION_CREATED;
+    }
+    
+    /**
+     * @return Returns the counterReceive_EVT_SESSION_DELTA.
+     */
+    public long getCounterReceive_EVT_SESSION_DELTA() {
+        return counterReceive_EVT_SESSION_DELTA;
+    }
+    
+    /**
+     * @return Returns the counterReceive_EVT_SESSION_EXPIRED.
+     */
+    public long getCounterReceive_EVT_SESSION_EXPIRED() {
+        return counterReceive_EVT_SESSION_EXPIRED;
+    }
+    
+    
+    /**
+     * @return Returns the counterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE.
+     */
+    public int getCounterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE() {
+        return counterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE;
+    }
+    
+    /**
+     * @return Returns the processingTime.
+     */
+    public long getProcessingTime() {
+        return processingTime;
+    }
+ 
+    /**
+     * @return Returns the sessionReplaceCounter.
+     */
+    public long getSessionReplaceCounter() {
+        return sessionReplaceCounter;
+    }
+    
+    /**
+     * Number of session creations that failed due to maxActiveSessions
+     * 
+     * @return The count
+     */
+    public int getRejectedSessions() {
+        return rejectedSessions;
+    }
+
+    public void setRejectedSessions(int rejectedSessions) {
+        this.rejectedSessions = rejectedSessions;
+    }
+
+    /**
+     * @return Returns the counterNoStateTransfered.
+     */
+    public int getCounterNoStateTransfered() {
+        return counterNoStateTransfered;
+    }
+    
+    public int getReceivedQueueSize() {
+        return receivedMessageQueue.size() ;
+    }
+    
+    /**
+     * @return Returns the stateTransferTimeout.
+     */
+    public int getStateTransferTimeout() {
+        return stateTransferTimeout;
+    }
+    /**
+     * @param timeoutAllSession The timeout
+     */
+    public void setStateTransferTimeout(int timeoutAllSession) {
+        this.stateTransferTimeout = timeoutAllSession;
+    }
+
+    /**
+     * is session state transfered complete?
+     * 
+     */
+    public boolean getStateTransfered() {
+        return stateTransfered;
+    }
+
+    /**
+     * set that state ist complete transfered  
+     * @param stateTransfered
+     */
+    public void setStateTransfered(boolean stateTransfered) {
+        this.stateTransfered = stateTransfered;
+    }
+    
+    /**
+     * @return Returns the sendAllSessionsWaitTime in msec
+     */
+    public int getSendAllSessionsWaitTime() {
+        return sendAllSessionsWaitTime;
+    }
+    
+    /**
+     * @param sendAllSessionsWaitTime The sendAllSessionsWaitTime to set at msec.
+     */
+    public void setSendAllSessionsWaitTime(int sendAllSessionsWaitTime) {
+        this.sendAllSessionsWaitTime = sendAllSessionsWaitTime;
+    }
+    
+    /**
+     * @return Returns the sendClusterDomainOnly.
+     */
+    public boolean doDomainReplication() {
+        return sendClusterDomainOnly;
+    }
+    
+    /**
+     * @param sendClusterDomainOnly The sendClusterDomainOnly to set.
+     */
+    public void setDomainReplication(boolean sendClusterDomainOnly) {
+        this.sendClusterDomainOnly = sendClusterDomainOnly;
+    }
+
+    /**
+     * @return Returns the stateTimestampDrop.
+     */
+    public boolean isStateTimestampDrop() {
+        return stateTimestampDrop;
+    }
+    
+    /**
+     * @param isTimestampDrop The new flag value
+     */
+    public void setStateTimestampDrop(boolean isTimestampDrop) {
+        this.stateTimestampDrop = isTimestampDrop;
+    }
+    
+    /**
+     * Return the maximum number of active Sessions allowed, or -1 for no limit.
+     */
+    public int getMaxActiveSessions() {
+        return (this.maxActiveSessions);
+    }
+
+    /**
+     * Set the maximum number of actives Sessions allowed, or -1 for no limit.
+     * 
+     * @param max
+     *            The new maximum number of sessions
+     */
+    public void setMaxActiveSessions(int max) {
+        int oldMaxActiveSessions = this.maxActiveSessions;
+        this.maxActiveSessions = max;
+        support.firePropertyChange("maxActiveSessions", new Integer(oldMaxActiveSessions), new Integer(this.maxActiveSessions));
+    }
+    
+    /**
+     * 
+     * @return Returns the sendAllSessions.
+     */
+    public boolean isSendAllSessions() {
+        return sendAllSessions;
+    }
+    
+    /**
+     * @param sendAllSessions The sendAllSessions to set.
+     */
+    public void setSendAllSessions(boolean sendAllSessions) {
+        this.sendAllSessions = sendAllSessions;
+    }
+    
+    /**
+     * @return Returns the sendAllSessionsSize.
+     */
+    public int getSendAllSessionsSize() {
+        return sendAllSessionsSize;
+    }
+    
+    /**
+     * @param sendAllSessionsSize The sendAllSessionsSize to set.
+     */
+    public void setSendAllSessionsSize(int sendAllSessionsSize) {
+        this.sendAllSessionsSize = sendAllSessionsSize;
+    }
+    
+    /**
+     * @return Returns the notifySessionListenersOnReplication.
+     */
+    public boolean isNotifySessionListenersOnReplication() {
+        return notifySessionListenersOnReplication;
+    }
+    
+    /**
+     * @param notifyListenersCreateSessionOnReplication The notifySessionListenersOnReplication to set.
+     */
+    public void setNotifySessionListenersOnReplication(boolean notifyListenersCreateSessionOnReplication) {
+        this.notifySessionListenersOnReplication = notifyListenersCreateSessionOnReplication;
+    }
+    
+    
+    public boolean isExpireSessionsOnShutdown() {
+        return expireSessionsOnShutdown;
+    }
+
+    public void setExpireSessionsOnShutdown(boolean expireSessionsOnShutdown) {
+        this.expireSessionsOnShutdown = expireSessionsOnShutdown;
+    }
+    
+    public boolean isNotifyListenersOnReplication() {
+        return notifyListenersOnReplication;
+    }
+
+    public void setNotifyListenersOnReplication(boolean notifyListenersOnReplication) {
+        this.notifyListenersOnReplication = notifyListenersOnReplication;
+    }
+
+    
+    /**
+     * @return Returns the defaultMode.
+     */
+    public boolean isDefaultMode() {
+        return defaultMode;
+    }
+    /**
+     * @param defaultMode The defaultMode to set.
+     */
+    public void setDefaultMode(boolean defaultMode) {
+        this.defaultMode = defaultMode;
+    }
+    
+    public CatalinaCluster getCluster() {
+        return cluster;
+    }
+
+    public void setCluster(CatalinaCluster cluster) {
+        this.cluster = cluster;
+    }
+
+    /**
+     * Set the Container with which this Manager has been associated. If it is a
+     * Context (the usual case), listen for changes to the session timeout
+     * property.
+     * 
+     * @param container
+     *            The associated Container
+     */
+    public void setContainer(Container container) {
+        // De-register from the old Container (if any)
+        if ((this.container != null) && (this.container instanceof Context))
+            ((Context) this.container).removePropertyChangeListener(this);
+
+        // Default processing provided by our superclass
+        super.setContainer(container);
+
+        // Register with the new Container (if any)
+        if ((this.container != null) && (this.container instanceof Context)) {
+            setMaxInactiveInterval(((Context) this.container).getSessionTimeout() * 60);
+            ((Context) this.container).addPropertyChangeListener(this);
+        }
+
+    }
+    
+    // --------------------------------------------------------- Public Methods
+
+    /**
+     * Construct and return a new session object, based on the default settings
+     * specified by this Manager's properties. The session id will be assigned
+     * by this method, and available via the getId() method of the returned
+     * session. If a new session cannot be created for any reason, return
+     * <code>null</code>.
+     * 
+     * @exception IllegalStateException
+     *                if a new session cannot be instantiated for any reason
+     * 
+     * Construct and return a new session object, based on the default settings
+     * specified by this Manager's properties. The session id will be assigned
+     * by this method, and available via the getId() method of the returned
+     * session. If a new session cannot be created for any reason, return
+     * <code>null</code>.
+     * 
+     * @exception IllegalStateException
+     *                if a new session cannot be instantiated for any reason
+     */
+    public Session createSession(String sessionId) {
+        return createSession(sessionId, true);
+    }
+
+    /**
+     * create new session with check maxActiveSessions and send session creation
+     * to other cluster nodes.
+     * 
+     * @param distribute
+     * @return The session
+     */
+    public Session createSession(String sessionId, boolean distribute) {
+        if ((maxActiveSessions >= 0) && (sessions.size() >= maxActiveSessions)) {
+            rejectedSessions++;
+            throw new IllegalStateException(sm.getString("deltaManager.createSession.ise"));
+        }
+        DeltaSession session = (DeltaSession) super.createSession(sessionId) ;
+        if (distribute) {
+            sendCreateSession(session.getId(), session);
+        }
+        if (log.isDebugEnabled())
+            log.debug(sm.getString("deltaManager.createSession.newSession",session.getId(), new Integer(sessions.size())));
+        return (session);
+
+    }
+
+    /**
+     * Send create session evt to all backup node
+     * @param sessionId
+     * @param session
+     */
+    protected void sendCreateSession(String sessionId, DeltaSession session) {
+        if(cluster.getMembers().length > 0 ) {
+            SessionMessage msg = 
+                new SessionMessageImpl(getName(),
+                                       SessionMessage.EVT_SESSION_CREATED, 
+                                       null, 
+                                       sessionId,
+                                       sessionId + "-" + System.currentTimeMillis());
+            if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.sendMessage.newSession",name, sessionId));
+            msg.setTimestamp(session.getCreationTime());
+            counterSend_EVT_SESSION_CREATED++;
+            send(msg);
+        }
+    }
+    
+    /**
+     * Send messages to other backup member (domain or all)
+     * @param msg Session message
+     */
+    protected void send(SessionMessage msg) {
+        if(cluster != null) {
+            if(doDomainReplication())
+                cluster.sendClusterDomain(msg);
+            else
+                cluster.send(msg);
+        }
+    }
+
+    /**
+     * Create DeltaSession
+     * @see org.apache.catalina.Manager#createEmptySession()
+     */
+    public Session createEmptySession() {
+        return getNewDeltaSession() ;
+    }
+    
+    /**
+     * Get new session class to be used in the doLoad() method.
+     */
+    protected DeltaSession getNewDeltaSession() {
+        return new DeltaSession(this);
+    }
+
+    /**
+     * Load Deltarequest from external node
+     * Load the Class at container classloader
+     * @see DeltaRequest#readExternal(java.io.ObjectInput)
+     * @param session
+     * @param data message data
+     * @return The request
+     * @throws ClassNotFoundException
+     * @throws IOException
+     */
+    protected DeltaRequest deserializeDeltaRequest(DeltaSession session, byte[] data) throws ClassNotFoundException, IOException {
+        ReplicationStream ois = getReplicationStream(data);
+        session.getDeltaRequest().readExternal(ois);
+        ois.close();
+        return session.getDeltaRequest();
+    }
+
+    /**
+     * serialize DeltaRequest
+     * @see DeltaRequest#writeExternal(java.io.ObjectOutput)
+     * 
+     * @param deltaRequest
+     * @return serialized delta request
+     * @throws IOException
+     */
+    protected byte[] serializeDeltaRequest(DeltaRequest deltaRequest) throws IOException {
+        return deltaRequest.serialize();
+    }
+
+    /**
+     * Load sessions from other cluster node.
+     * FIXME replace currently sessions with same id without notifcation.
+     * FIXME SSO handling is not really correct with the session replacement!
+     * @exception ClassNotFoundException
+     *                if a serialized class cannot be found during the reload
+     * @exception IOException
+     *                if an input/output error occurs
+     */
+    protected void deserializeSessions(byte[] data) throws ClassNotFoundException,IOException {
+
+        // Initialize our internal data structures
+        //sessions.clear(); //should not do this
+        // Open an input stream to the specified pathname, if any
+        ClassLoader originalLoader = Thread.currentThread().getContextClassLoader();
+        ObjectInputStream ois = null;
+        // Load the previously unloaded active sessions
+        try {
+            ois = getReplicationStream(data);
+            Integer count = (Integer) ois.readObject();
+            int n = count.intValue();
+            for (int i = 0; i < n; i++) {
+                DeltaSession session = (DeltaSession) createEmptySession();
+                session.readObjectData(ois);
+                session.setManager(this);
+                session.setValid(true);
+                session.setPrimarySession(false);
+                //in case the nodes in the cluster are out of
+                //time synch, this will make sure that we have the
+                //correct timestamp, isValid returns true, cause
+                // accessCount=1
+                session.access();
+                //make sure that the session gets ready to expire if
+                // needed
+                session.setAccessCount(0);
+                session.resetDeltaRequest();
+                // FIXME How inform other session id cache like SingleSignOn
+                // increment sessionCounter to correct stats report
+                if (findSession(session.getIdInternal()) == null ) {
+                    sessionCounter++;
+                } else {
+                    sessionReplaceCounter++;
+                    // FIXME better is to grap this sessions again !
+                    if (log.isWarnEnabled()) log.warn(sm.getString("deltaManager.loading.existing.session",session.getIdInternal()));
+                }
+                add(session);
+            }
+        } catch (ClassNotFoundException e) {
+            log.error(sm.getString("deltaManager.loading.cnfe", e), e);
+            throw e;
+        } catch (IOException e) {
+            log.error(sm.getString("deltaManager.loading.ioe", e), e);
+            throw e;
+        } finally {
+            // Close the input stream
+            try {
+                if (ois != null) ois.close();
+            } catch (IOException f) {
+                // ignored
+            }
+            ois = null;
+            if (originalLoader != null) Thread.currentThread().setContextClassLoader(originalLoader);
+        }
+
+    }
+
+    
+
+    /**
+     * Save any currently active sessions in the appropriate persistence
+     * mechanism, if any. If persistence is not supported, this method returns
+     * without doing anything.
+     * 
+     * @exception IOException
+     *                if an input/output error occurs
+     */
+    protected byte[] serializeSessions(Session[] currentSessions) throws IOException {
+
+        // Open an output stream to the specified pathname, if any
+        ByteArrayOutputStream fos = null;
+        ObjectOutputStream oos = null;
+
+        try {
+            fos = new ByteArrayOutputStream();
+            oos = new ObjectOutputStream(new BufferedOutputStream(fos));
+            oos.writeObject(new Integer(currentSessions.length));
+            for(int i=0 ; i < currentSessions.length;i++) {
+                ((DeltaSession)currentSessions[i]).writeObjectData(oos);                
+            }
+            // Flush and close the output stream
+            oos.flush();
+        } catch (IOException e) {
+            log.error(sm.getString("deltaManager.unloading.ioe", e), e);
+            throw e;
+        } finally {
+            if (oos != null) {
+                try {
+                    oos.close();
+                } catch (IOException f) {
+                    ;
+                }
+                oos = null;
+            }
+        }
+        // send object data as byte[]
+        return fos.toByteArray();
+    }
+
+    // ------------------------------------------------------ Lifecycle Methods
+
+    /**
+     * Add a lifecycle event listener to this component.
+     * 
+     * @param listener
+     *            The listener to add
+     */
+    public void addLifecycleListener(LifecycleListener listener) {
+        lifecycle.addLifecycleListener(listener);
+    }
+
+    /**
+     * Get the lifecycle listeners associated with this lifecycle. If this
+     * Lifecycle has no listeners registered, a zero-length array is returned.
+     */
+    public LifecycleListener[] findLifecycleListeners() {
+        return lifecycle.findLifecycleListeners();
+    }
+
+    /**
+     * Remove a lifecycle event listener from this component.
+     * 
+     * @param listener
+     *            The listener to remove
+     */
+    public void removeLifecycleListener(LifecycleListener listener) {
+        lifecycle.removeLifecycleListener(listener);
+    }
+
+    /**
+     * Prepare for the beginning of active use of the public methods of this
+     * component. This method should be called after <code>configure()</code>,
+     * and before any of the public methods of the component are utilized.
+     * 
+     * @exception LifecycleException
+     *                if this component detects a fatal error that prevents this
+     *                component from being used
+     */
+    public void start() throws LifecycleException {
+        if (!initialized) init();
+
+        // Validate and update our current component state
+        if (started) {
+            return;
+        }
+        started = true;
+        lifecycle.fireLifecycleEvent(START_EVENT, null);
+
+        // Force initialization of the random number generator
+        generateSessionId();
+
+        // Load unloaded sessions, if any
+        try {
+            //the channel is already running
+            Cluster cluster = getCluster() ;
+            // stop remove cluster binding
+            //wow, how many nested levels of if statements can we have ;)
+            if(cluster == null) {
+                Container context = getContainer() ;
+                if(context != null && context instanceof Context) {
+                     Container host = context.getParent() ;
+                     if(host != null && host instanceof Host) {
+                         cluster = host.getCluster();
+                         if(cluster != null && cluster instanceof CatalinaCluster) {
+                             setCluster((CatalinaCluster) cluster) ;
+                         } else {
+                             Container engine = host.getParent() ;
+                             if(engine != null && engine instanceof Engine) {
+                                 cluster = engine.getCluster();
+                                 if(cluster != null && cluster instanceof CatalinaCluster) {
+                                     setCluster((CatalinaCluster) cluster) ;
+                                 }
+                             } else {
+                                     cluster = null ;
+                             }
+                         }
+                     }
+                }
+            }
+            if (cluster == null) {
+                log.error(sm.getString("deltaManager.noCluster", getName()));
+                return;
+            } else {
+                if (log.isInfoEnabled()) {
+                    String type = "unknown" ;
+                    if( cluster.getContainer() instanceof Host){
+                        type = "Host" ;
+                    } else if( cluster.getContainer() instanceof Engine){
+                        type = "Engine" ;
+                    }
+                    log.info(sm.getString("deltaManager.registerCluster", getName(), type, cluster.getClusterName()));
+                }
+            }
+            if (log.isInfoEnabled()) log.info(sm.getString("deltaManager.startClustering", getName()));
+            //to survice context reloads, as only a stop/start is called, not
+            // createManager
+            cluster.registerManager(this);
+
+            getAllClusterSessions();
+
+        } catch (Throwable t) {
+            log.error(sm.getString("deltaManager.managerLoad"), t);
+        }
+    }
+
+    /**
+     * get from first session master the backup from all clustered sessions
+     * @see #findSessionMasterMember()
+     */
+    public synchronized void getAllClusterSessions() {
+        if (cluster != null && cluster.getMembers().length > 0) {
+            long beforeSendTime = System.currentTimeMillis();
+            Member mbr = findSessionMasterMember();
+            if(mbr == null) { // No domain member found
+                 return;
+            }
+            SessionMessage msg = new SessionMessageImpl(this.getName(),SessionMessage.EVT_GET_ALL_SESSIONS, null, "GET-ALL","GET-ALL-" + getName());
+            // set reference time
+            stateTransferCreateSendTime = beforeSendTime ;
+            // request session state
+            counterSend_EVT_GET_ALL_SESSIONS++;
+            stateTransfered = false ;
+            // FIXME This send call block the deploy thread, when sender waitForAck is enabled
+            try {
+                synchronized(receivedMessageQueue) {
+                     receiverQueue = true ;
+                }
+                cluster.send(msg, mbr);
+                if (log.isWarnEnabled()) log.warn(sm.getString("deltaManager.waitForSessionState",getName(), mbr));
+                // FIXME At sender ack mode this method check only the state transfer and resend is a problem!
+                waitForSendAllSessions(beforeSendTime);
+            } finally {
+                synchronized(receivedMessageQueue) {
+                    for (Iterator iter = receivedMessageQueue.iterator(); iter.hasNext();) {
+                        SessionMessage smsg = (SessionMessage) iter.next();
+                        if (!stateTimestampDrop) {
+                            messageReceived(smsg, smsg.getAddress() != null ? (Member) smsg.getAddress() : null);
+                        } else {
+                            if (smsg.getEventType() != SessionMessage.EVT_GET_ALL_SESSIONS && smsg.getTimestamp() >= stateTransferCreateSendTime) {
+                                // FIXME handle EVT_GET_ALL_SESSIONS later
+                                messageReceived(smsg,smsg.getAddress() != null ? (Member) smsg.getAddress() : null);
+                            } else {
+                                if (log.isWarnEnabled()) {
+                                    log.warn(sm.getString("deltaManager.dropMessage",getName(), smsg.getEventTypeString(),new Date(stateTransferCreateSendTime), new Date(smsg.getTimestamp())));
+                                }
+                            }
+                        }
+                    }        
+                    receivedMessageQueue.clear();
+                    receiverQueue = false ;
+                }
+           }
+        } else {
+            if (log.isInfoEnabled()) log.info(sm.getString("deltaManager.noMembers", getName()));
+        }
+    }
+
+    /**
+     * Register cross context session at replication valve thread local
+     * @param session cross context session
+     */
+    protected void registerSessionAtReplicationValve(DeltaSession session) {
+        if(replicationValve == null) {
+            if(container instanceof StandardContext && ((StandardContext)container).getCrossContext()) {
+                Cluster cluster = getCluster() ;
+                if(cluster != null && cluster instanceof CatalinaCluster) {
+                    Valve[] valves = ((CatalinaCluster)cluster).getValves();
+                    if(valves != null && valves.length > 0) {
+                        for(int i=0; replicationValve == null && i < valves.length ; i++ ){
+                            if(valves[i] instanceof ReplicationValve) replicationValve = (ReplicationValve)valves[i] ;
+                        }//for
+
+                        if(replicationValve == null && log.isDebugEnabled()) {
+                            log.debug("no ReplicationValve found for CrossContext Support");
+                        }//endif 
+                    }//end if
+                }//endif
+            }//end if
+        }//end if
+        if(replicationValve != null) {
+            replicationValve.registerReplicationSession(session);
+        }
+    }
+    
+    /**
+     * Find the master of the session state
+     * @return master member of sessions 
+     */
+    protected Member findSessionMasterMember() {
+        Member mbr = null;
+        Member mbrs[] = cluster.getMembers();
+        if(mbrs.length != 0 ) mbr = mbrs[0];
+        if(mbr == null && log.isWarnEnabled()) log.warn(sm.getString("deltaManager.noMasterMember",getName(), ""));
+        if(mbr != null && log.isDebugEnabled()) log.warn(sm.getString("deltaManager.foundMasterMember",getName(), mbr));
+        return mbr;
+    }
+
+    /**
+     * Wait that cluster session state is transfer or timeout after 60 Sec
+     * With stateTransferTimeout == -1 wait that backup is transfered (forever mode)
+     */
+    protected void waitForSendAllSessions(long beforeSendTime) {
+        long reqStart = System.currentTimeMillis();
+        long reqNow = reqStart ;
+        boolean isTimeout = false;
+        if(getStateTransferTimeout() > 0) {
+            // wait that state is transfered with timeout check
+            do {
+                try {
+                    Thread.sleep(100);
+                } catch (Exception sleep) {
+                    //
+                }
+                reqNow = System.currentTimeMillis();
+                isTimeout = ((reqNow - reqStart) > (1000 * getStateTransferTimeout()));
+            } while ((!getStateTransfered()) && (!isTimeout));
+        } else {
+            if(getStateTransferTimeout() == -1) {
+                // wait that state is transfered
+                do {
+                    try {
+                        Thread.sleep(100);
+                    } catch (Exception sleep) {
+                    }
+                } while ((!getStateTransfered()));
+                reqNow = System.currentTimeMillis();
+            }
+        }
+        if (isTimeout || (!getStateTransfered())) {
+            counterNoStateTransfered++ ;
+            log.error(sm.getString("deltaManager.noSessionState",getName(),new Date(beforeSendTime),new Long(reqNow - beforeSendTime)));
+        } else {
+            if (log.isInfoEnabled())
+                log.info(sm.getString("deltaManager.sessionReceived",getName(), new Date(beforeSendTime), new Long(reqNow - beforeSendTime)));
+        }
+    }
+
+    /**
+     * Gracefully terminate the active use of the public methods of this
+     * component. This method should be the last one called on a given instance
+     * of this component.
+     * 
+     * @exception LifecycleException
+     *                if this component detects a fatal error that needs to be
+     *                reported
+     */
+    public void stop() throws LifecycleException {
+
+        if (log.isDebugEnabled())
+            log.debug(sm.getString("deltaManager.stopped", getName()));
+
+
+        // Validate and update our current component state
+        if (!started)
+            throw new LifecycleException(sm.getString("deltaManager.notStarted"));
+        lifecycle.fireLifecycleEvent(STOP_EVENT, null);
+        started = false;
+
+        // Expire all active sessions
+        if (log.isInfoEnabled()) log.info(sm.getString("deltaManager.expireSessions", getName()));
+        Session sessions[] = findSessions();
+        for (int i = 0; i < sessions.length; i++) {
+            DeltaSession session = (DeltaSession) sessions[i];
+            if (!session.isValid())
+                continue;
+            try {
+                session.expire(true, isExpireSessionsOnShutdown());
+            } catch (Throwable ignore) {
+                ;
+            } 
+        }
+
+        // Require a new random number generator if we are restarted
+        this.random = null;
+        getCluster().removeManager(this);
+        replicationValve = null;
+        if (initialized) {
+            destroy();
+        }
+    }
+
+    // ----------------------------------------- PropertyChangeListener Methods
+
+    /**
+     * Process property change events from our associated Context.
+     * 
+     * @param event
+     *            The property change event that has occurred
+     */
+    public void propertyChange(PropertyChangeEvent event) {
+
+        // Validate the source of this event
+        if (!(event.getSource() instanceof Context))
+            return;
+        // Process a relevant property change
+        if (event.getPropertyName().equals("sessionTimeout")) {
+            try {
+                setMaxInactiveInterval(((Integer) event.getNewValue()).intValue() * 60);
+            } catch (NumberFormatException e) {
+                log.error(sm.getString("deltaManager.sessionTimeout", event.getNewValue()));
+            }
+        }
+
+    }
+
+    // -------------------------------------------------------- Replication
+    // Methods
+
+    /**
+     * A message was received from another node, this is the callback method to
+     * implement if you are interested in receiving replication messages.
+     * 
+     * @param cmsg -
+     *            the message received.
+     */
+    public void messageDataReceived(ClusterMessage cmsg) {
+        if (cmsg != null && cmsg instanceof SessionMessage) {
+            SessionMessage msg = (SessionMessage) cmsg;
+            switch (msg.getEventType()) {
+                case SessionMessage.EVT_GET_ALL_SESSIONS:
+                case SessionMessage.EVT_SESSION_CREATED: 
+                case SessionMessage.EVT_SESSION_EXPIRED: 
+                case SessionMessage.EVT_SESSION_ACCESSED:
+                case SessionMessage.EVT_SESSION_DELTA: {
+                    synchronized(receivedMessageQueue) {
+                        if(receiverQueue) {
+                            receivedMessageQueue.add(msg);
+                            return ;
+                        }
+                    }
+                   break;
+                }
+                default: {
+                    //we didn't queue, do nothing
+                    break;
+                }
+            } //switch
+            
+            messageReceived(msg, msg.getAddress() != null ? (Member) msg.getAddress() : null);
+        }
+    }
+
+    /**
+     * When the request has been completed, the replication valve will notify
+     * the manager, and the manager will decide whether any replication is
+     * needed or not. If there is a need for replication, the manager will
+     * create a session message and that will be replicated. The cluster
+     * determines where it gets sent.
+     * 
+     * @param sessionId -
+     *            the sessionId that just completed.
+     * @return a SessionMessage to be sent,
+     */
+    public ClusterMessage requestCompleted(String sessionId) {
+        try {
+            DeltaSession session = (DeltaSession) findSession(sessionId);
+            DeltaRequest deltaRequest = session.getDeltaRequest();
+            SessionMessage msg = null;
+            boolean isDeltaRequest = false ;
+            synchronized(deltaRequest) {
+                isDeltaRequest = deltaRequest.getSize() > 0 ;
+                if (isDeltaRequest) {    
+                    counterSend_EVT_SESSION_DELTA++;
+                    byte[] data = serializeDeltaRequest(deltaRequest);
+                    msg = new SessionMessageImpl(getName(),
+                                                 SessionMessage.EVT_SESSION_DELTA, 
+                                                 data, 
+                                                 sessionId,
+                                                 sessionId + "-" + System.currentTimeMillis());
+                    session.resetDeltaRequest();
+                }  
+            }
+            if(!isDeltaRequest) {
+                if(!session.isPrimarySession()) {               
+                    counterSend_EVT_SESSION_ACCESSED++;
+                    msg = new SessionMessageImpl(getName(),
+                                                 SessionMessage.EVT_SESSION_ACCESSED, 
+                                                 null, 
+                                                 sessionId,
+                                                 sessionId + "-" + System.currentTimeMillis());
+                    if (log.isDebugEnabled()) {
+                        log.debug(sm.getString("deltaManager.createMessage.accessChangePrimary",getName(), sessionId));
+                    }
+                }    
+            } else { // log only outside synch block!
+                if (log.isDebugEnabled()) {
+                    log.debug(sm.getString("deltaManager.createMessage.delta",getName(), sessionId));
+                }
+            }
+            session.setPrimarySession(true);
+            //check to see if we need to send out an access message
+            if ((msg == null)) {
+                long replDelta = System.currentTimeMillis() - session.getLastTimeReplicated();
+                if (replDelta > (getMaxInactiveInterval() * 1000)) {
+                    counterSend_EVT_SESSION_ACCESSED++;
+                    msg = new SessionMessageImpl(getName(),
+                                                 SessionMessage.EVT_SESSION_ACCESSED, 
+                                                 null,
+                                                 sessionId, 
+                                                 sessionId + "-" + System.currentTimeMillis());
+                    if (log.isDebugEnabled()) {
+                        log.debug(sm.getString("deltaManager.createMessage.access", getName(),sessionId));
+                    }
+                }
+
+            }
+
+            //update last replicated time
+            if (msg != null) session.setLastTimeReplicated(System.currentTimeMillis());
+            return msg;
+        } catch (IOException x) {
+            log.error(sm.getString("deltaManager.createMessage.unableCreateDeltaRequest",sessionId), x);
+            return null;
+        }
+
+    }
+    /**
+     * Reset manager statistics
+     */
+    public synchronized void resetStatistics() {
+        processingTime = 0 ;
+        expiredSessions = 0 ;
+        rejectedSessions = 0 ;
+        sessionReplaceCounter = 0 ;
+        counterNoStateTransfered = 0 ;
+        maxActive = getActiveSessions() ;
+        sessionCounter = getActiveSessions() ;
+        counterReceive_EVT_ALL_SESSION_DATA = 0;
+        counterReceive_EVT_GET_ALL_SESSIONS = 0;
+        counterReceive_EVT_SESSION_ACCESSED = 0 ;
+        counterReceive_EVT_SESSION_CREATED = 0 ;
+        counterReceive_EVT_SESSION_DELTA = 0 ;
+        counterReceive_EVT_SESSION_EXPIRED = 0 ;
+        counterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE = 0;
+        counterSend_EVT_ALL_SESSION_DATA = 0;
+        counterSend_EVT_GET_ALL_SESSIONS = 0;
+        counterSend_EVT_SESSION_ACCESSED = 0 ;
+        counterSend_EVT_SESSION_CREATED = 0 ;
+        counterSend_EVT_SESSION_DELTA = 0 ;
+        counterSend_EVT_SESSION_EXPIRED = 0 ;
+        counterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE = 0;
+        
+    }
+   
+    //  -------------------------------------------------------- persistence handler
+
+    public void load() {
+
+    }
+
+    public void unload() {
+
+    }
+
+    //  -------------------------------------------------------- expire
+
+    /**
+     * send session expired to other cluster nodes
+     * 
+     * @param id
+     *            session id
+     */
+    protected void sessionExpired(String id) {
+        counterSend_EVT_SESSION_EXPIRED++ ;
+        SessionMessage msg = new SessionMessageImpl(getName(),SessionMessage.EVT_SESSION_EXPIRED, null, id, id+ "-EXPIRED-MSG");
+        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.createMessage.expire",getName(), id));
+        send(msg);
+    }
+
+    /**
+     * Exipre all find sessions.
+     */
+    public void expireAllLocalSessions()
+    {
+        long timeNow = System.currentTimeMillis();
+        Session sessions[] = findSessions();
+        int expireDirect  = 0 ;
+        int expireIndirect = 0 ;
+        
+        if(log.isDebugEnabled()) log.debug("Start expire all sessions " + getName() + " at " + timeNow + " sessioncount " + sessions.length);
+        for (int i = 0; i < sessions.length; i++) {
+            if (sessions[i] instanceof DeltaSession) {
+                DeltaSession session = (DeltaSession) sessions[i];
+                if (session.isPrimarySession()) {
+                    if (session.isValid()) {
+                        session.expire();
+                        expireDirect++;
+                    } else {
+                        expireIndirect++;
+                    }//end if
+                }//end if
+            }//end if
+        }//for
+        long timeEnd = System.currentTimeMillis();
+        if(log.isDebugEnabled()) log.debug("End expire sessions " + getName() + " exipre processingTime " + (timeEnd - timeNow) + " expired direct sessions: " + expireDirect + " expired direct sessions: " + expireIndirect);
+      
+    }
+    
+    /**
+     * When the manager expires session not tied to a request. The cluster will
+     * periodically ask for a list of sessions that should expire and that
+     * should be sent across the wire.
+     * 
+     * @return The invalidated sessions array
+     */
+    public String[] getInvalidatedSessions() {
+        return new String[0];
+    }
+
+    //  -------------------------------------------------------- message receive
+
+    /**
+     * Test that sender and local domain is the same
+     */
+    protected boolean checkSenderDomain(SessionMessage msg,Member sender) {
+        boolean sameDomain= true;
+        if (!sameDomain && log.isWarnEnabled()) {
+                log.warn(sm.getString("deltaManager.receiveMessage.fromWrongDomain",
+                         new Object[] {getName(), 
+                         msg.getEventTypeString(), 
+                         sender,
+                         "",
+                         "" }));
+        }
+        return sameDomain ;
+    }
+
+    /**
+     * This method is called by the received thread when a SessionMessage has
+     * been received from one of the other nodes in the cluster.
+     * 
+     * @param msg -
+     *            the message received
+     * @param sender -
+     *            the sender of the message, this is used if we receive a
+     *            EVT_GET_ALL_SESSION message, so that we only reply to the
+     *            requesting node
+     */
+    protected void messageReceived(SessionMessage msg, Member sender) {
+        if(doDomainReplication() && !checkSenderDomain(msg,sender)) {
+            return;
+        }
+        ClassLoader contextLoader = Thread.currentThread().getContextClassLoader();
+        try {
+            
+            ClassLoader[] loaders = getClassLoaders();
+            if ( loaders != null && loaders.length > 0) Thread.currentThread().setContextClassLoader(loaders[0]);
+            if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.eventType",getName(), msg.getEventTypeString(), sender));
+ 
+            switch (msg.getEventType()) {
+                case SessionMessage.EVT_GET_ALL_SESSIONS: {
+                    handleGET_ALL_SESSIONS(msg,sender);
+                    break;
+                }
+                case SessionMessage.EVT_ALL_SESSION_DATA: {
+                    handleALL_SESSION_DATA(msg,sender);
+                    break;
+                }
+                case SessionMessage.EVT_ALL_SESSION_TRANSFERCOMPLETE: {
+                    handleALL_SESSION_TRANSFERCOMPLETE(msg,sender);
+                    break;
+                }
+                case SessionMessage.EVT_SESSION_CREATED: {
+                    handleSESSION_CREATED(msg,sender);
+                    break;
+                }
+                case SessionMessage.EVT_SESSION_EXPIRED: {
+                    handleSESSION_EXPIRED(msg,sender);
+                    break;
+                }
+                case SessionMessage.EVT_SESSION_ACCESSED: {
+                    handleSESSION_ACCESSED(msg,sender);
+                    break;
+                }
+                case SessionMessage.EVT_SESSION_DELTA: {
+                   handleSESSION_DELTA(msg,sender);
+                   break;
+                }
+                default: {
+                    //we didn't recognize the message type, do nothing
+                    break;
+                }
+            } //switch
+        } catch (Exception x) {
+            log.error(sm.getString("deltaManager.receiveMessage.error",getName()), x);
+        } finally {
+            Thread.currentThread().setContextClassLoader(contextLoader);
+        }
+    }
+
+    // -------------------------------------------------------- message receiver handler
+
+
+    /**
+     * handle receive session state is complete transfered
+     * @param msg
+     * @param sender
+     */
+    protected void handleALL_SESSION_TRANSFERCOMPLETE(SessionMessage msg, Member sender) {
+        counterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE++ ;
+        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.transfercomplete",getName(), sender.getHost(), new Integer(sender.getPort())));
+        stateTransferCreateSendTime = msg.getTimestamp() ;
+        stateTransfered = true ;
+    }
+
+    /**
+     * handle receive session delta
+     * @param msg
+     * @param sender
+     * @throws IOException
+     * @throws ClassNotFoundException
+     */
+    protected void handleSESSION_DELTA(SessionMessage msg, Member sender) throws IOException, ClassNotFoundException {
+        counterReceive_EVT_SESSION_DELTA++;
+        byte[] delta = msg.getSession();
+        DeltaSession session = (DeltaSession) findSession(msg.getSessionID());
+        if (session != null) {
+            if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.delta",getName(), msg.getSessionID()));
+            DeltaRequest dreq = deserializeDeltaRequest(session, delta);
+            dreq.execute(session, notifyListenersOnReplication);
+            session.setPrimarySession(false);
+        }
+    }
+
+    /**
+     * handle receive session is access at other node ( primary session is now false)
+     * @param msg
+     * @param sender
+     * @throws IOException
+     */
+    protected void handleSESSION_ACCESSED(SessionMessage msg,Member sender) throws IOException {
+        counterReceive_EVT_SESSION_ACCESSED++;
+        DeltaSession session = (DeltaSession) findSession(msg.getSessionID());
+        if (session != null) {
+            if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.accessed",getName(), msg.getSessionID()));
+            session.access();
+            session.setPrimarySession(false);
+            session.endAccess();
+        }
+    }
+
+    /**
+     * handle receive session is expire at other node ( expire session also here)
+     * @param msg
+     * @param sender
+     * @throws IOException
+     */
+    protected void handleSESSION_EXPIRED(SessionMessage msg,Member sender) throws IOException {
+        counterReceive_EVT_SESSION_EXPIRED++;
+        DeltaSession session = (DeltaSession) findSession(msg.getSessionID());
+        if (session != null) {
+            if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.expired",getName(), msg.getSessionID()));
+            session.expire(notifySessionListenersOnReplication, false);
+        }
+    }
+
+    /**
+     * handle receive new session is created at other node (create backup - primary false)
+     * @param msg
+     * @param sender
+     */
+    protected void handleSESSION_CREATED(SessionMessage msg,Member sender) {
+        counterReceive_EVT_SESSION_CREATED++;
+        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.createNewSession",getName(), msg.getSessionID()));
+        DeltaSession session = (DeltaSession) createEmptySession();
+        session.setManager(this);
+        session.setValid(true);
+        session.setPrimarySession(false);
+        session.setCreationTime(msg.getTimestamp());
+        session.access();
+        if(notifySessionListenersOnReplication)
+            session.setId(msg.getSessionID());
+        else
+            session.setIdInternal(msg.getSessionID());
+        session.resetDeltaRequest();
+        session.endAccess();
+
+    }
+
+    /**
+     * handle receive sessions from other not ( restart )
+     * @param msg
+     * @param sender
+     * @throws ClassNotFoundException
+     * @throws IOException
+     */
+    protected void handleALL_SESSION_DATA(SessionMessage msg,Member sender) throws ClassNotFoundException, IOException {
+        counterReceive_EVT_ALL_SESSION_DATA++;
+        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.allSessionDataBegin",getName()));
+        byte[] data = msg.getSession();
+        deserializeSessions(data);
+        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.allSessionDataAfter",getName()));
+        //stateTransferred = true;
+    }
+
+    /**
+     * handle receive that other node want all sessions ( restart )
+     * a) send all sessions with one message
+     * b) send session at blocks
+     * After sending send state is complete transfered
+     * @param msg
+     * @param sender
+     * @throws IOException
+     */
+    protected void handleGET_ALL_SESSIONS(SessionMessage msg, Member sender) throws IOException {
+        counterReceive_EVT_GET_ALL_SESSIONS++;
+        //get a list of all the session from this manager
+        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.unloadingBegin", getName()));
+        // Write the number of active sessions, followed by the details
+        // get all sessions and serialize without sync
+        Session[] currentSessions = findSessions();
+        long findSessionTimestamp = System.currentTimeMillis() ;
+        if (isSendAllSessions()) {
+            sendSessions(sender, currentSessions, findSessionTimestamp);
+        } else {
+            // send session at blocks
+            int len = currentSessions.length < getSendAllSessionsSize() ? currentSessions.length : getSendAllSessionsSize();
+            Session[] sendSessions = new Session[len];
+            for (int i = 0; i < currentSessions.length; i += getSendAllSessionsSize()) {
+                len = i + getSendAllSessionsSize() > currentSessions.length ? currentSessions.length - i : getSendAllSessionsSize();
+                System.arraycopy(currentSessions, i, sendSessions, 0, len);
+                sendSessions(sender, sendSessions,findSessionTimestamp);
+                if (getSendAllSessionsWaitTime() > 0) {
+                    try {
+                        Thread.sleep(getSendAllSessionsWaitTime());
+                    } catch (Exception sleep) {
+                    }
+                }//end if
+            }//for
+        }//end if
+        
+        SessionMessage newmsg = new SessionMessageImpl(name,SessionMessage.EVT_ALL_SESSION_TRANSFERCOMPLETE, null,"SESSION-STATE-TRANSFERED", "SESSION-STATE-TRANSFERED"+ getName());
+        newmsg.setTimestamp(findSessionTimestamp);
+        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.createMessage.allSessionTransfered",getName()));
+        counterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE++;
+        cluster.send(newmsg, sender);
+    }
+
+
+    /**
+     * send a block of session to sender
+     * @param sender
+     * @param currentSessions
+     * @param sendTimestamp
+     * @throws IOException
+     */
+    protected void sendSessions(Member sender, Session[] currentSessions,long sendTimestamp) throws IOException {
+        byte[] data = serializeSessions(currentSessions);
+        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.receiveMessage.unloadingAfter",getName()));
+        SessionMessage newmsg = new SessionMessageImpl(name,SessionMessage.EVT_ALL_SESSION_DATA, data,"SESSION-STATE", "SESSION-STATE-" + getName());
+        newmsg.setTimestamp(sendTimestamp);
+        if (log.isDebugEnabled()) log.debug(sm.getString("deltaManager.createMessage.allSessionData",getName()));
+        counterSend_EVT_ALL_SESSION_DATA++;
+        cluster.send(newmsg, sender);
+    }
+
+    public ClusterManager cloneFromTemplate() {
+        DeltaManager result = new DeltaManager();
+        result.name = "Clone-from-"+name;
+        result.cluster = cluster;
+        result.replicationValve = replicationValve;
+        result.maxActiveSessions = maxActiveSessions;
+        result.expireSessionsOnShutdown = expireSessionsOnShutdown;
+        result.notifyListenersOnReplication = notifyListenersOnReplication;
+        result.notifySessionListenersOnReplication = notifySessionListenersOnReplication;
+        result.stateTransferTimeout = stateTransferTimeout;
+        result.sendAllSessions = sendAllSessions;
+        result.sendClusterDomainOnly = sendClusterDomainOnly ;
+        result.sendAllSessionsSize = sendAllSessionsSize;
+        result.sendAllSessionsWaitTime = sendAllSessionsWaitTime ; 
+        result.receiverQueue = receiverQueue ;
+        result.stateTimestampDrop = stateTimestampDrop ;
+        result.stateTransferCreateSendTime = stateTransferCreateSendTime; 
+        return result;
+    }
+}

==================================================
DeltaSession.java
index 0762255bc1..83c6426863 100644
--- a/java/org/apache/catalina/ha/session/DeltaRequest.java
+++ b/java/org/apache/catalina/ha/session/DeltaRequest.java
@@ -1,387 +1,387 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina.ha.session;
-
-/**
- * This class is used to track the series of actions that happens when
- * a request is executed. These actions will then translate into invokations of methods 
- * on the actual session.
- * This class is NOT thread safe. One DeltaRequest per session
- * @author <a href="mailto:fhanik@apache.org">Filip Hanik</a>
- * @version 1.0
- */
-
-import java.io.Externalizable;
-import java.security.Principal;
-import java.util.LinkedList;
-
-import org.apache.catalina.realm.GenericPrincipal;
-import org.apache.catalina.util.StringManager;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.ObjectOutputStream;
-
-
-public class DeltaRequest implements Externalizable {
-
-    public static org.apache.juli.logging.Log log =
-        org.apache.juli.logging.LogFactory.getLog( DeltaRequest.class );
-
-    /**
-     * The string manager for this package.
-     */
-    protected static StringManager sm = StringManager
-            .getManager(Constants.Package);
-
-    public static final int TYPE_ATTRIBUTE = 0;
-    public static final int TYPE_PRINCIPAL = 1;
-    public static final int TYPE_ISNEW = 2;
-    public static final int TYPE_MAXINTERVAL = 3;
-
-    public static final int ACTION_SET = 0;
-    public static final int ACTION_REMOVE = 1;
-
-    public static final String NAME_PRINCIPAL = "__SET__PRINCIPAL__";
-    public static final String NAME_MAXINTERVAL = "__SET__MAXINTERVAL__";
-    public static final String NAME_ISNEW = "__SET__ISNEW__";
-
-    private String sessionId;
-    private LinkedList actions = new LinkedList();
-    private LinkedList actionPool = new LinkedList();
-    
-    private boolean recordAllActions = false;
-
-    public DeltaRequest() {
-        
-    }
-    
-    public DeltaRequest(String sessionId, boolean recordAllActions) {
-        this.recordAllActions=recordAllActions;
-        if(sessionId != null)
-            setSessionId(sessionId);
-    }
-
-
-    public void setAttribute(String name, Object value) {
-        int action = (value==null)?ACTION_REMOVE:ACTION_SET;
-        addAction(TYPE_ATTRIBUTE,action,name,value);
-    }
-
-    public void removeAttribute(String name) {
-        int action = ACTION_REMOVE;
-        addAction(TYPE_ATTRIBUTE,action,name,null);
-    }
-
-    public void setMaxInactiveInterval(int interval) {
-        int action = ACTION_SET;
-        addAction(TYPE_MAXINTERVAL,action,NAME_MAXINTERVAL,new Integer(interval));
-    }
-    
-    /**
-     * convert principal at SerializablePrincipal for backup nodes.
-     * Only support principals from type {@link GenericPrincipal GenericPrincipal}
-     * @param p Session principal
-     * @see GenericPrincipal
-     */
-    public void setPrincipal(Principal p) {
-        int action = (p==null)?ACTION_REMOVE:ACTION_SET;
-        SerializablePrincipal sp = null;
-        if ( p != null ) {
-            if(p instanceof GenericPrincipal) {
-                sp = SerializablePrincipal.createPrincipal((GenericPrincipal)p);
-                if(log.isDebugEnabled())
-                    log.debug(sm.getString("deltaRequest.showPrincipal", p.getName() , getSessionId()));
-            } else
-                log.error(sm.getString("deltaRequest.wrongPrincipalClass",p.getClass().getName()));
-        }
-        addAction(TYPE_PRINCIPAL,action,NAME_PRINCIPAL,sp);
-    }
-
-    public void setNew(boolean n) {
-        int action = ACTION_SET;
-        addAction(TYPE_ISNEW,action,NAME_ISNEW,new Boolean(n));
-    }
-
-    protected synchronized void addAction(int type,
-                             int action,
-                             String name,
-                             Object value) {
-        AttributeInfo info = null;
-        if ( this.actionPool.size() > 0 ) {
-            try {
-                info = (AttributeInfo) actionPool.removeFirst();
-            }catch ( Exception x ) {
-                log.error("Unable to remove element:",x);
-                info = new AttributeInfo(type, action, name, value);
-            }
-            info.init(type,action,name,value);
-        } else {
-            info = new AttributeInfo(type, action, name, value);
-        }
-        //if we have already done something to this attribute, make sure
-        //we don't send multiple actions across the wire
-        if ( !recordAllActions) {
-            try {
-                actions.remove(info);
-            } catch (java.util.NoSuchElementException x) {
-                //do nothing, we wanted to remove it anyway
-            }
-        }
-        //add the action
-        actions.addLast(info);
-    }
-    
-    public void execute(DeltaSession session) {
-        execute(session,true);
-    }
-
-    public synchronized void execute(DeltaSession session, boolean notifyListeners) {
-        if ( !this.sessionId.equals( session.getId() ) )
-            throw new java.lang.IllegalArgumentException("Session id mismatch, not executing the delta request");
-        session.access();
-        for ( int i=0; i<actions.size(); i++ ) {
-            AttributeInfo info = (AttributeInfo)actions.get(i);
-            switch ( info.getType() ) {
-                case TYPE_ATTRIBUTE: {
-                    if ( info.getAction() == ACTION_SET ) {
-                        if ( log.isTraceEnabled() ) log.trace("Session.setAttribute('"+info.getName()+"', '"+info.getValue()+"')");
-                        session.setAttribute(info.getName(), info.getValue(),notifyListeners,false);
-                    }  else {
-                        if ( log.isTraceEnabled() ) log.trace("Session.removeAttribute('"+info.getName()+"')");
-                        session.removeAttribute(info.getName(),notifyListeners,false);
-                    }
-                        
-                    break;
-                }//case
-                case TYPE_ISNEW: {
-                if ( log.isTraceEnabled() ) log.trace("Session.setNew('"+info.getValue()+"')");
-                    session.setNew(((Boolean)info.getValue()).booleanValue(),false);
-                    break;
-                }//case
-                case TYPE_MAXINTERVAL: {
-                    if ( log.isTraceEnabled() ) log.trace("Session.setMaxInactiveInterval('"+info.getValue()+"')");
-                    session.setMaxInactiveInterval(((Integer)info.getValue()).intValue(),false);
-                    break;
-                }//case
-                case TYPE_PRINCIPAL: {
-                    Principal p = null;
-                    if ( info.getAction() == ACTION_SET ) {
-                        SerializablePrincipal sp = (SerializablePrincipal)info.getValue();
-                        p = (Principal)sp.getPrincipal(session.getManager().getContainer().getRealm());
-                    }
-                    session.setPrincipal(p,false);
-                    break;
-                }//case
-                default : throw new java.lang.IllegalArgumentException("Invalid attribute info type="+info);
-            }//switch
-        }//for
-        session.endAccess();
-        reset();
-    }
-
-    public synchronized void reset() {
-        while ( actions.size() > 0 ) {
-            try {
-                AttributeInfo info = (AttributeInfo) actions.removeFirst();
-                info.recycle();
-                actionPool.addLast(info);
-            }catch  ( Exception x ) {
-                log.error("Unable to remove element",x);
-            }
-        }
-        actions.clear();
-    }
-    
-    public String getSessionId() {
-        return sessionId;
-    }
-    public void setSessionId(String sessionId) {
-        this.sessionId = sessionId;
-        if ( sessionId == null ) {
-            new Exception("Session Id is null for setSessionId").fillInStackTrace().printStackTrace();
-        }
-    }
-    public int getSize() {
-        return actions.size();
-    }
-    
-    public synchronized void clear() {
-        actions.clear();
-        actionPool.clear();
-    }
-    
-    public synchronized void readExternal(java.io.ObjectInput in) throws IOException,ClassNotFoundException {
-        //sessionId - String
-        //recordAll - boolean
-        //size - int
-        //AttributeInfo - in an array
-        reset();
-        sessionId = in.readUTF();
-        recordAllActions = in.readBoolean();
-        int cnt = in.readInt();
-        if (actions == null)
-            actions = new LinkedList();
-        else
-            actions.clear();
-        for (int i = 0; i < cnt; i++) {
-            AttributeInfo info = null;
-            if (this.actionPool.size() > 0) {
-                try {
-                    info = (AttributeInfo) actionPool.removeFirst();
-                } catch ( Exception x )  {
-                    log.error("Unable to remove element",x);
-                    info = new AttributeInfo(-1,-1,null,null);
-                }
-            }
-            else {
-                info = new AttributeInfo(-1,-1,null,null);
-            }
-            info.readExternal(in);
-            actions.addLast(info);
-        }//for
-    }
-        
-
-
-    public synchronized void writeExternal(java.io.ObjectOutput out ) throws java.io.IOException {
-        //sessionId - String
-        //recordAll - boolean
-        //size - int
-        //AttributeInfo - in an array
-        out.writeUTF(getSessionId());
-        out.writeBoolean(recordAllActions);
-        out.writeInt(getSize());
-        for ( int i=0; i<getSize(); i++ ) {
-            AttributeInfo info = (AttributeInfo)actions.get(i);
-            info.writeExternal(out);
-        }
-    }
-    
-    /**
-     * serialize DeltaRequest
-     * @see DeltaRequest#writeExternal(java.io.ObjectOutput)
-     * 
-     * @param deltaRequest
-     * @return serialized delta request
-     * @throws IOException
-     */
-    protected byte[] serialize() throws IOException {
-        ByteArrayOutputStream bos = new ByteArrayOutputStream();
-        ObjectOutputStream oos = new ObjectOutputStream(bos);
-        writeExternal(oos);
-        oos.flush();
-        oos.close();
-        return bos.toByteArray();
-    }
-    
-    private static class AttributeInfo implements java.io.Externalizable {
-        private String name = null;
-        private Object value = null;
-        private int action;
-        private int type;
-
-        public AttributeInfo() {}
-
-        public AttributeInfo(int type,
-                             int action,
-                             String name,
-                             Object value) {
-            super();
-            init(type,action,name,value);
-        }
-
-        public void init(int type,
-                         int action,
-                         String name,
-                         Object value) {
-            this.name = name;
-            this.value = value;
-            this.action = action;
-            this.type = type;
-        }
-
-        public int getType() {
-            return type;
-        }
-
-        public int getAction() {
-            return action;
-        }
-
-        public Object getValue() {
-            return value;
-        }
-        public int hashCode() {
-            return name.hashCode();
-        }
-
-        public String getName() {
-            return name;
-        }
-        
-        public void recycle() {
-            name = null;
-            value = null;
-            type=-1;
-            action=-1;
-        }
-
-        public boolean equals(Object o) {
-            if ( ! (o instanceof AttributeInfo ) ) return false;
-            AttributeInfo other =  (AttributeInfo)o;
-            return other.getName().equals(this.getName());
-        }
-        
-        public synchronized void readExternal(java.io.ObjectInput in ) throws IOException,ClassNotFoundException {
-            //type - int
-            //action - int
-            //name - String
-            //hasvalue - boolean
-            //value - object
-            type = in.readInt();
-            action = in.readInt();
-            name = in.readUTF();
-            boolean hasValue = in.readBoolean();
-            if ( hasValue ) value = in.readObject();
-        }
-
-        public synchronized void writeExternal(java.io.ObjectOutput out) throws IOException {
-            //type - int
-            //action - int
-            //name - String
-            //hasvalue - boolean
-            //value - object
-            out.writeInt(getType());
-            out.writeInt(getAction());
-            out.writeUTF(getName());
-            out.writeBoolean(getValue()!=null);
-            if (getValue()!=null) out.writeObject(getValue());
-        }
-        
-        public String toString() {
-            StringBuffer buf = new StringBuffer("AttributeInfo[type=");
-            buf.append(getType()).append(", action=").append(getAction());
-            buf.append(", name=").append(getName()).append(", value=").append(getValue());
-            buf.append(", addr=").append(super.toString()).append("]");
-            return buf.toString();
-        }
-
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.catalina.ha.session;
+
+/**
+ * This class is used to track the series of actions that happens when
+ * a request is executed. These actions will then translate into invokations of methods 
+ * on the actual session.
+ * This class is NOT thread safe. One DeltaRequest per session
+ * @author <a href="mailto:fhanik@apache.org">Filip Hanik</a>
+ * @version 1.0
+ */
+
+import java.io.Externalizable;
+import java.security.Principal;
+import java.util.LinkedList;
+
+import org.apache.catalina.realm.GenericPrincipal;
+import org.apache.catalina.util.StringManager;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.ObjectOutputStream;
+
+
+public class DeltaRequest implements Externalizable {
+
+    public static org.apache.juli.logging.Log log =
+        org.apache.juli.logging.LogFactory.getLog( DeltaRequest.class );
+
+    /**
+     * The string manager for this package.
+     */
+    protected static StringManager sm = StringManager
+            .getManager(Constants.Package);
+
+    public static final int TYPE_ATTRIBUTE = 0;
+    public static final int TYPE_PRINCIPAL = 1;
+    public static final int TYPE_ISNEW = 2;
+    public static final int TYPE_MAXINTERVAL = 3;
+
+    public static final int ACTION_SET = 0;
+    public static final int ACTION_REMOVE = 1;
+
+    public static final String NAME_PRINCIPAL = "__SET__PRINCIPAL__";
+    public static final String NAME_MAXINTERVAL = "__SET__MAXINTERVAL__";
+    public static final String NAME_ISNEW = "__SET__ISNEW__";
+
+    private String sessionId;
+    private LinkedList actions = new LinkedList();
+    private LinkedList actionPool = new LinkedList();
+    
+    private boolean recordAllActions = false;
+
+    public DeltaRequest() {
+        
+    }
+    
+    public DeltaRequest(String sessionId, boolean recordAllActions) {
+        this.recordAllActions=recordAllActions;
+        if(sessionId != null)
+            setSessionId(sessionId);
+    }
+
+
+    public void setAttribute(String name, Object value) {
+        int action = (value==null)?ACTION_REMOVE:ACTION_SET;
+        addAction(TYPE_ATTRIBUTE,action,name,value);
+    }
+
+    public void removeAttribute(String name) {
+        int action = ACTION_REMOVE;
+        addAction(TYPE_ATTRIBUTE,action,name,null);
+    }
+
+    public void setMaxInactiveInterval(int interval) {
+        int action = ACTION_SET;
+        addAction(TYPE_MAXINTERVAL,action,NAME_MAXINTERVAL,new Integer(interval));
+    }
+    
+    /**
+     * convert principal at SerializablePrincipal for backup nodes.
+     * Only support principals from type {@link GenericPrincipal GenericPrincipal}
+     * @param p Session principal
+     * @see GenericPrincipal
+     */
+    public void setPrincipal(Principal p) {
+        int action = (p==null)?ACTION_REMOVE:ACTION_SET;
+        SerializablePrincipal sp = null;
+        if ( p != null ) {
+            if(p instanceof GenericPrincipal) {
+                sp = SerializablePrincipal.createPrincipal((GenericPrincipal)p);
+                if(log.isDebugEnabled())
+                    log.debug(sm.getString("deltaRequest.showPrincipal", p.getName() , getSessionId()));
+            } else
+                log.error(sm.getString("deltaRequest.wrongPrincipalClass",p.getClass().getName()));
+        }
+        addAction(TYPE_PRINCIPAL,action,NAME_PRINCIPAL,sp);
+    }
+
+    public void setNew(boolean n) {
+        int action = ACTION_SET;
+        addAction(TYPE_ISNEW,action,NAME_ISNEW,new Boolean(n));
+    }
+
+    protected synchronized void addAction(int type,
+                             int action,
+                             String name,
+                             Object value) {
+        AttributeInfo info = null;
+        if ( this.actionPool.size() > 0 ) {
+            try {
+                info = (AttributeInfo) actionPool.removeFirst();
+            }catch ( Exception x ) {
+                log.error("Unable to remove element:",x);
+                info = new AttributeInfo(type, action, name, value);
+            }
+            info.init(type,action,name,value);
+        } else {
+            info = new AttributeInfo(type, action, name, value);
+        }
+        //if we have already done something to this attribute, make sure
+        //we don't send multiple actions across the wire
+        if ( !recordAllActions) {
+            try {
+                actions.remove(info);
+            } catch (java.util.NoSuchElementException x) {
+                //do nothing, we wanted to remove it anyway
+            }
+        }
+        //add the action
+        actions.addLast(info);
+    }
+    
+    public void execute(DeltaSession session) {
+        execute(session,true);
+    }
+
+    public synchronized void execute(DeltaSession session, boolean notifyListeners) {
+        if ( !this.sessionId.equals( session.getId() ) )
+            throw new java.lang.IllegalArgumentException("Session id mismatch, not executing the delta request");
+        session.access();
+        for ( int i=0; i<actions.size(); i++ ) {
+            AttributeInfo info = (AttributeInfo)actions.get(i);
+            switch ( info.getType() ) {
+                case TYPE_ATTRIBUTE: {
+                    if ( info.getAction() == ACTION_SET ) {
+                        if ( log.isTraceEnabled() ) log.trace("Session.setAttribute('"+info.getName()+"', '"+info.getValue()+"')");
+                        session.setAttribute(info.getName(), info.getValue(),notifyListeners,false);
+                    }  else {
+                        if ( log.isTraceEnabled() ) log.trace("Session.removeAttribute('"+info.getName()+"')");
+                        session.removeAttribute(info.getName(),notifyListeners,false);
+                    }
+                        
+                    break;
+                }//case
+                case TYPE_ISNEW: {
+                if ( log.isTraceEnabled() ) log.trace("Session.setNew('"+info.getValue()+"')");
+                    session.setNew(((Boolean)info.getValue()).booleanValue(),false);
+                    break;
+                }//case
+                case TYPE_MAXINTERVAL: {
+                    if ( log.isTraceEnabled() ) log.trace("Session.setMaxInactiveInterval('"+info.getValue()+"')");
+                    session.setMaxInactiveInterval(((Integer)info.getValue()).intValue(),false);
+                    break;
+                }//case
+                case TYPE_PRINCIPAL: {
+                    Principal p = null;
+                    if ( info.getAction() == ACTION_SET ) {
+                        SerializablePrincipal sp = (SerializablePrincipal)info.getValue();
+                        p = (Principal)sp.getPrincipal(session.getManager().getContainer().getRealm());
+                    }
+                    session.setPrincipal(p,false);
+                    break;
+                }//case
+                default : throw new java.lang.IllegalArgumentException("Invalid attribute info type="+info);
+            }//switch
+        }//for
+        session.endAccess();
+        reset();
+    }
+
+    public synchronized void reset() {
+        while ( actions.size() > 0 ) {
+            try {
+                AttributeInfo info = (AttributeInfo) actions.removeFirst();
+                info.recycle();
+                actionPool.addLast(info);
+            }catch  ( Exception x ) {
+                log.error("Unable to remove element",x);
+            }
+        }
+        actions.clear();
+    }
+    
+    public String getSessionId() {
+        return sessionId;
+    }
+    public void setSessionId(String sessionId) {
+        this.sessionId = sessionId;
+        if ( sessionId == null ) {
+            new Exception("Session Id is null for setSessionId").fillInStackTrace().printStackTrace();
+        }
+    }
+    public int getSize() {
+        return actions.size();
+    }
+    
+    public synchronized void clear() {
+        actions.clear();
+        actionPool.clear();
+    }
+    
+    public synchronized void readExternal(java.io.ObjectInput in) throws IOException,ClassNotFoundException {
+        //sessionId - String
+        //recordAll - boolean
+        //size - int
+        //AttributeInfo - in an array
+        reset();
+        sessionId = in.readUTF();
+        recordAllActions = in.readBoolean();
+        int cnt = in.readInt();
+        if (actions == null)
+            actions = new LinkedList();
+        else
+            actions.clear();
+        for (int i = 0; i < cnt; i++) {
+            AttributeInfo info = null;
+            if (this.actionPool.size() > 0) {
+                try {
+                    info = (AttributeInfo) actionPool.removeFirst();
+                } catch ( Exception x )  {
+                    log.error("Unable to remove element",x);
+                    info = new AttributeInfo(-1,-1,null,null);
+                }
+            }
+            else {
+                info = new AttributeInfo(-1,-1,null,null);
+            }
+            info.readExternal(in);
+            actions.addLast(info);
+        }//for
+    }
+        
+
+
+    public synchronized void writeExternal(java.io.ObjectOutput out ) throws java.io.IOException {
+        //sessionId - String
+        //recordAll - boolean
+        //size - int
+        //AttributeInfo - in an array
+        out.writeUTF(getSessionId());
+        out.writeBoolean(recordAllActions);
+        out.writeInt(getSize());
+        for ( int i=0; i<getSize(); i++ ) {
+            AttributeInfo info = (AttributeInfo)actions.get(i);
+            info.writeExternal(out);
+        }
+    }
+    
+    /**
+     * serialize DeltaRequest
+     * @see DeltaRequest#writeExternal(java.io.ObjectOutput)
+     * 
+     * @param deltaRequest
+     * @return serialized delta request
+     * @throws IOException
+     */
+    protected byte[] serialize() throws IOException {
+        ByteArrayOutputStream bos = new ByteArrayOutputStream();
+        ObjectOutputStream oos = new ObjectOutputStream(bos);
+        writeExternal(oos);
+        oos.flush();
+        oos.close();
+        return bos.toByteArray();
+    }
+    
+    private static class AttributeInfo implements java.io.Externalizable {
+        private String name = null;
+        private Object value = null;
+        private int action;
+        private int type;
+
+        public AttributeInfo() {}
+
+        public AttributeInfo(int type,
+                             int action,
+                             String name,
+                             Object value) {
+            super();
+            init(type,action,name,value);
+        }
+
+        public void init(int type,
+                         int action,
+                         String name,
+                         Object value) {
+            this.name = name;
+            this.value = value;
+            this.action = action;
+            this.type = type;
+        }
+
+        public int getType() {
+            return type;
+        }
+
+        public int getAction() {
+            return action;
+        }
+
+        public Object getValue() {
+            return value;
+        }
+        public int hashCode() {
+            return name.hashCode();
+        }
+
+        public String getName() {
+            return name;
+        }
+        
+        public void recycle() {
+            name = null;
+            value = null;
+            type=-1;
+            action=-1;
+        }
+
+        public boolean equals(Object o) {
+            if ( ! (o instanceof AttributeInfo ) ) return false;
+            AttributeInfo other =  (AttributeInfo)o;
+            return other.getName().equals(this.getName());
+        }
+        
+        public synchronized void readExternal(java.io.ObjectInput in ) throws IOException,ClassNotFoundException {
+            //type - int
+            //action - int
+            //name - String
+            //hasvalue - boolean
+            //value - object
+            type = in.readInt();
+            action = in.readInt();
+            name = in.readUTF();
+            boolean hasValue = in.readBoolean();
+            if ( hasValue ) value = in.readObject();
+        }
+
+        public synchronized void writeExternal(java.io.ObjectOutput out) throws IOException {
+            //type - int
+            //action - int
+            //name - String
+            //hasvalue - boolean
+            //value - object
+            out.writeInt(getType());
+            out.writeInt(getAction());
+            out.writeUTF(getName());
+            out.writeBoolean(getValue()!=null);
+            if (getValue()!=null) out.writeObject(getValue());
+        }
+        
+        public String toString() {
+            StringBuffer buf = new StringBuffer("AttributeInfo[type=");
+            buf.append(getType()).append(", action=").append(getAction());
+            buf.append(", name=").append(getName()).append(", value=").append(getValue());
+            buf.append(", addr=").append(super.toString()).append("]");
+            return buf.toString();
+        }
+
+    }
+
+}

==================================================
JvmRouteBinderValve.java
index 1104db5e3a..96a2f8cd00 100644
--- a/java/org/apache/catalina/ha/session/DeltaSession.java
+++ b/java/org/apache/catalina/ha/session/DeltaSession.java
@@ -1,752 +1,752 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha.session;
-
-import java.io.Externalizable;
-import java.io.IOException;
-import java.io.NotSerializableException;
-import java.io.ObjectInput;
-import java.io.ObjectOutput;
-import java.io.Serializable;
-import java.security.Principal;
-import java.util.ArrayList;
-import java.util.Enumeration;
-import java.util.HashMap;
-import java.util.Hashtable;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantReadWriteLock;
-import javax.servlet.http.HttpSession;
-import javax.servlet.http.HttpSessionContext;
-
-import org.apache.catalina.Manager;
-import org.apache.catalina.ha.ClusterManager;
-import org.apache.catalina.ha.ClusterSession;
-import org.apache.catalina.realm.GenericPrincipal;
-import org.apache.catalina.session.StandardSession;
-import org.apache.catalina.tribes.io.ReplicationStream;
-import org.apache.catalina.tribes.tipis.ReplicatedMapEntry;
-import org.apache.catalina.util.Enumerator;
-import org.apache.catalina.util.StringManager;
-import org.apache.catalina.session.StandardManager;
-import org.apache.catalina.session.ManagerBase;
-import java.util.concurrent.atomic.AtomicInteger;
-
-/**
- *
- * Similar to the StandardSession except that this session will keep
- * track of deltas during a request.
- *
- * @author Filip Hanik
- * @version $Revision: 372887 $ $Date: 2006-01-27 09:58:58 -0600 (Fri, 27 Jan 2006) $
- */
-
-public class DeltaSession extends StandardSession implements Externalizable,ClusterSession,ReplicatedMapEntry {
-
-    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(DeltaSession.class);
-
-    /**
-     * The string manager for this package.
-     */
-    protected static StringManager sm = StringManager.getManager(Constants.Package);
-
-    // ----------------------------------------------------- Instance Variables
-
-    /**
-     * only the primary session will expire, or be able to expire due to
-     * inactivity. This is set to false as soon as I receive this session over
-     * the wire in a session message. That means that someone else has made a
-     * request on another server.
-     */
-    private transient boolean isPrimarySession = true;
-
-    /**
-     * The delta request contains all the action info
-     *
-     */
-    private transient DeltaRequest deltaRequest = null;
-
-    /**
-     * Last time the session was replicatd, used for distributed expiring of
-     * session
-     */
-    private transient long lastTimeReplicated = System.currentTimeMillis();
-
-
-    protected Lock diffLock = new ReentrantReadWriteLock().writeLock();
-
-    private long version;
-
-    // ----------------------------------------------------------- Constructors
-
-    /**
-     * Construct a new Session associated with the specified Manager.
-     *
-     * @param manager
-     *            The manager with which this Session is associated
-     */
-    public DeltaSession() {
-        this(null);
-    }
-
-    public DeltaSession(Manager manager) {
-        super(manager);
-        this.resetDeltaRequest();
-    }
-
-    // ----------------------------------------------------- ReplicatedMapEntry
-
-    /**
-         * Has the object changed since last replication
-         * and is not in a locked state
-         * @return boolean
-         */
-        public boolean isDirty() {
-            return getDeltaRequest().getSize()>0;
-        }
-
-        /**
-         * If this returns true, the map will extract the diff using getDiff()
-         * Otherwise it will serialize the entire object.
-         * @return boolean
-         */
-        public boolean isDiffable() {
-            return true;
-        }
-
-        /**
-         * Returns a diff and sets the dirty map to false
-         * @return byte[]
-         * @throws IOException
-         */
-        public byte[] getDiff() throws IOException {
-            return getDeltaRequest().serialize();
-        }
-
-        public ClassLoader[] getClassLoaders() {
-            if ( manager instanceof BackupManager ) return ((BackupManager)manager).getClassLoaders();
-            else if ( manager instanceof ClusterManagerBase ) return ((ClusterManagerBase)manager).getClassLoaders();
-            else if ( manager instanceof StandardManager ) {
-                StandardManager sm = (StandardManager)manager;
-                return ClusterManagerBase.getClassLoaders(sm.getContainer());
-            } else if ( manager instanceof ManagerBase ) {
-                ManagerBase mb = (ManagerBase)manager;
-                return ClusterManagerBase.getClassLoaders(mb.getContainer());
-            }//end if
-            return null;
-        }
-
-        /**
-         * Applies a diff to an existing object.
-         * @param diff byte[]
-         * @param offset int
-         * @param length int
-         * @throws IOException
-         */
-        public void applyDiff(byte[] diff, int offset, int length) throws IOException, ClassNotFoundException {
-            ReplicationStream stream = ((ClusterManager)getManager()).getReplicationStream(diff,offset,length);
-            getDeltaRequest().readExternal(stream);
-            ClassLoader contextLoader = Thread.currentThread().getContextClassLoader();
-            try {
-                ClassLoader[] loaders = getClassLoaders();
-                if ( loaders != null && loaders.length >0 ) Thread.currentThread().setContextClassLoader(loaders[0]);
-                getDeltaRequest().execute(this);
-            }finally {
-                Thread.currentThread().setContextClassLoader(contextLoader);
-            }
-        }
-
-        /**
-         * Resets the current diff state and resets the dirty flag
-         */
-        public void resetDiff() {
-            resetDeltaRequest();
-        }
-
-        /**
-         * Lock during serialization
-         */
-        public void lock() {
-            diffLock.lock();
-        }
-
-        /**
-         * Unlock after serialization
-         */
-        public void unlock() {
-            diffLock.unlock();
-        }
-
-        public void setOwner(Object owner) {
-            if ( owner instanceof ClusterManager && getManager()==null) {
-                ClusterManager cm = (ClusterManager)owner;
-                this.setManager(cm);
-                this.setValid(true);
-                this.setPrimarySession(false);
-                this.access();
-                this.resetDeltaRequest();
-                this.endAccess();
-            }
-        }
-    // ----------------------------------------------------- Session Properties
-
-    /**
-     * returns true if this session is the primary session, if that is the case,
-     * the manager can expire it upon timeout.
-     */
-    public boolean isPrimarySession() {
-        return isPrimarySession;
-    }
-
-    /**
-     * Sets whether this is the primary session or not.
-     *
-     * @param primarySession
-     *            Flag value
-     */
-    public void setPrimarySession(boolean primarySession) {
-        this.isPrimarySession = primarySession;
-    }
-
-    /**
-     * Set the session identifier for this session without notify listeners.
-     *
-     * @param id
-     *            The new session identifier
-     */
-    public void setIdInternal(String id) {
-        this.id = id;
-        resetDeltaRequest();
-    }
-
-    /**
-     * Set the session identifier for this session.
-     *
-     * @param id
-     *            The new session identifier
-     */
-    public void setId(String id) {
-        super.setId(id);
-        resetDeltaRequest();
-    }
-
-   
-
-    /**
-     * Return the last client access time without invalidation check
-     * @see #getLastAccessedTime().
-     */
-    public long getLastAccessedTimeInternal() {
-        return (this.lastAccessedTime);
-    }
-
-
-   
-    public void setMaxInactiveInterval(int interval, boolean addDeltaRequest) {
-        super.maxInactiveInterval = interval;
-        if (isValid && interval == 0) {
-            expire();
-        } else {
-            if (addDeltaRequest && (deltaRequest != null))
-                deltaRequest.setMaxInactiveInterval(interval);
-        }
-    }
-
-    /**
-     * Set the <code>isNew</code> flag for this session.
-     *
-     * @param isNew
-     *            The new value for the <code>isNew</code> flag
-     */
-    public void setNew(boolean isNew) {
-        setNew(isNew, true);
-    }
-
-    public void setNew(boolean isNew, boolean addDeltaRequest) {
-        super.setNew(isNew);
-        if (addDeltaRequest && (deltaRequest != null))
-            deltaRequest.setNew(isNew);
-    }
-
-    /**
-     * Set the authenticated Principal that is associated with this Session.
-     * This provides an <code>Authenticator</code> with a means to cache a
-     * previously authenticated Principal, and avoid potentially expensive
-     * <code>Realm.authenticate()</code> calls on every request.
-     *
-     * @param principal
-     *            The new Principal, or <code>null</code> if none
-     */
-    public void setPrincipal(Principal principal) {
-        setPrincipal(principal, true);
-    }
-
-    public void setPrincipal(Principal principal, boolean addDeltaRequest) {
-        try { 
-            lock();
-            super.setPrincipal(principal);
-            if (addDeltaRequest && (deltaRequest != null))
-                deltaRequest.setPrincipal(principal);
-        } finally {
-            unlock();
-        }
-    }
-
-    /**
-     * Return the <code>isValid</code> flag for this session.
-     */
-    public boolean isValid() {
-        if (this.expiring) {
-            return true;
-        }
-        if (!this.isValid) {
-            return false;
-        }
-        if (ACTIVITY_CHECK && accessCount.get() > 0) {
-            return true;
-        }
-        if (maxInactiveInterval >= 0) {
-            long timeNow = System.currentTimeMillis();
-            int timeIdle = (int) ( (timeNow - thisAccessedTime) / 1000L);
-            if (isPrimarySession()) {
-                if (timeIdle >= maxInactiveInterval) {
-                    expire(true);
-                }
-            } else {
-                if (timeIdle >= (2 * maxInactiveInterval)) {
-                    //if the session has been idle twice as long as allowed,
-                    //the primary session has probably crashed, and no other
-                    //requests are coming in. that is why we do this. otherwise
-                    //we would have a memory leak
-                    expire(true, false);
-                }
-            }
-        }
-        return (this.isValid);
-    }
-
-    // ------------------------------------------------- Session Public Methods
-
-    /**
-     * Perform the internal processing required to invalidate this session,
-     * without triggering an exception if the session has already expired.
-     *
-     * @param notify
-     *            Should we notify listeners about the demise of this session?
-     */
-    public void expire(boolean notify) {
-        expire(notify, true);
-    }
-
-    public void expire(boolean notify, boolean notifyCluster) {
-        String expiredId = getIdInternal();
-        super.expire(notify);
-
-        if (notifyCluster) {
-            if (log.isDebugEnabled())
-                log.debug(sm.getString("deltaSession.notifying",
-                                       ((DeltaManager)manager).getName(), 
-                                       new Boolean(isPrimarySession()), 
-                                       expiredId));
-            if ( manager instanceof DeltaManager ) {
-                ( (DeltaManager) manager).sessionExpired(expiredId);
-            }
-        }
-    }
-
-    /**
-     * Release all object references, and initialize instance variables, in
-     * preparation for reuse of this object.
-     */
-    public void recycle() {
-        super.recycle();
-        deltaRequest.clear();
-    }
-
-
-    /**
-     * Return a string representation of this object.
-     */
-    public String toString() {
-        StringBuffer sb = new StringBuffer();
-        sb.append("DeltaSession[");
-        sb.append(id);
-        sb.append("]");
-        return (sb.toString());
-    }
-
-    // ------------------------------------------------ Session Package Methods
-
-    public synchronized void readExternal(ObjectInput in) throws IOException,ClassNotFoundException {
-        readObjectData(in);
-    }
-
-
-    /**
-     * Read a serialized version of the contents of this session object from the
-     * specified object input stream, without requiring that the StandardSession
-     * itself have been serialized.
-     *
-     * @param stream
-     *            The object input stream to read from
-     *
-     * @exception ClassNotFoundException
-     *                if an unknown class is specified
-     * @exception IOException
-     *                if an input/output error occurs
-     */
-    public void readObjectData(ObjectInput stream) throws ClassNotFoundException, IOException {
-        readObject(stream);
-    }
-
-    /**
-     * Write a serialized version of the contents of this session object to the
-     * specified object output stream, without requiring that the
-     * StandardSession itself have been serialized.
-     *
-     * @param stream
-     *            The object output stream to write to
-     *
-     * @exception IOException
-     *                if an input/output error occurs
-     */
-    public void writeObjectData(ObjectOutput stream) throws IOException {
-        writeObject(stream);
-    }
-
-    public void resetDeltaRequest() {
-        if (deltaRequest == null) {
-            deltaRequest = new DeltaRequest(getIdInternal(), false);
-        } else {
-            deltaRequest.reset();
-            deltaRequest.setSessionId(getIdInternal());
-        }
-    }
-
-    public DeltaRequest getDeltaRequest() {
-        if (deltaRequest == null) resetDeltaRequest();
-        return deltaRequest;
-    }
-
-    // ------------------------------------------------- HttpSession Properties
-
-    // ----------------------------------------------HttpSession Public Methods
-
-
-
-    /**
-     * Remove the object bound with the specified name from this session. If the
-     * session does not have an object bound with this name, this method does
-     * nothing.
-     * <p>
-     * After this method executes, and if the object implements
-     * <code>HttpSessionBindingListener</code>, the container calls
-     * <code>valueUnbound()</code> on the object.
-     *
-     * @param name
-     *            Name of the object to remove from this session.
-     * @param notify
-     *            Should we notify interested listeners that this attribute is
-     *            being removed?
-     *
-     * @exception IllegalStateException
-     *                if this method is called on an invalidated session
-     */
-    public void removeAttribute(String name, boolean notify) {
-        removeAttribute(name, notify, true);
-    }
-
-    public void removeAttribute(String name, boolean notify,boolean addDeltaRequest) {
-        // Validate our current state
-        if (!isValid()) throw new IllegalStateException(sm.getString("standardSession.removeAttribute.ise"));
-        removeAttributeInternal(name, notify, addDeltaRequest);
-    }
-
-    /**
-     * Bind an object to this session, using the specified name. If an object of
-     * the same name is already bound to this session, the object is replaced.
-     * <p>
-     * After this method executes, and if the object implements
-     * <code>HttpSessionBindingListener</code>, the container calls
-     * <code>valueBound()</code> on the object.
-     *
-     * @param name
-     *            Name to which the object is bound, cannot be null
-     * @param value
-     *            Object to be bound, cannot be null
-     *
-     * @exception IllegalArgumentException
-     *                if an attempt is made to add a non-serializable object in
-     *                an environment marked distributable.
-     * @exception IllegalStateException
-     *                if this method is called on an invalidated session
-     */
-    public void setAttribute(String name, Object value) {
-        setAttribute(name, value, true, true);
-    }
-
-    public void setAttribute(String name, Object value, boolean notify,boolean addDeltaRequest) {
-
-        // Name cannot be null
-        if (name == null) throw new IllegalArgumentException(sm.getString("standardSession.setAttribute.namenull"));
-
-        // Null value is the same as removeAttribute()
-        if (value == null) {
-            removeAttribute(name);
-            return;
-        }
-
-        try {
-            lock();
-            super.setAttribute(name,value, notify);
-            if (addDeltaRequest && (deltaRequest != null)) deltaRequest.setAttribute(name, value);
-        } finally {
-            unlock();
-        }
-    }
-
-    // -------------------------------------------- HttpSession Private Methods
-
-    /**
-     * Read a serialized version of this session object from the specified
-     * object input stream.
-     * <p>
-     * <b>IMPLEMENTATION NOTE </b>: The reference to the owning Manager is not
-     * restored by this method, and must be set explicitly.
-     *
-     * @param stream
-     *            The input stream to read from
-     *
-     * @exception ClassNotFoundException
-     *                if an unknown class is specified
-     * @exception IOException
-     *                if an input/output error occurs
-     */
-    private void readObject(ObjectInput stream) throws ClassNotFoundException, IOException {
-
-        // Deserialize the scalar instance variables (except Manager)
-        authType = null; // Transient only
-        creationTime = ( (Long) stream.readObject()).longValue();
-        lastAccessedTime = ( (Long) stream.readObject()).longValue();
-        maxInactiveInterval = ( (Integer) stream.readObject()).intValue();
-        isNew = ( (Boolean) stream.readObject()).booleanValue();
-        isValid = ( (Boolean) stream.readObject()).booleanValue();
-        thisAccessedTime = ( (Long) stream.readObject()).longValue();
-        version = ( (Long) stream.readObject()).longValue();
-        boolean hasPrincipal = stream.readBoolean();
-        principal = null;
-        if (hasPrincipal) {
-            principal = SerializablePrincipal.readPrincipal(stream,getManager().getContainer().getRealm());
-        }
-
-        //        setId((String) stream.readObject());
-        id = (String) stream.readObject();
-        if (log.isDebugEnabled()) log.debug(sm.getString("deltaSession.readSession", id));
-
-        // Deserialize the attribute count and attribute values
-        if (attributes == null) attributes = new Hashtable();
-        int n = ( (Integer) stream.readObject()).intValue();
-        boolean isValidSave = isValid;
-        isValid = true;
-        for (int i = 0; i < n; i++) {
-            String name = (String) stream.readObject();
-            Object value = (Object) stream.readObject();
-            if ( (value instanceof String) && (value.equals(NOT_SERIALIZED)))
-                continue;
-            attributes.put(name, value);
-        }
-        isValid = isValidSave;
-
-        if (listeners == null) {
-            listeners = new ArrayList();
-        }
-
-        if (notes == null) {
-            notes = new Hashtable();
-        }
-        activate();
-    }
-
-    public synchronized void writeExternal(ObjectOutput out ) throws java.io.IOException {
-        writeObject(out);
-    }
-
-
-    /**
-     * Write a serialized version of this session object to the specified object
-     * output stream.
-     * <p>
-     * <b>IMPLEMENTATION NOTE </b>: The owning Manager will not be stored in the
-     * serialized representation of this Session. After calling
-     * <code>readObject()</code>, you must set the associated Manager
-     * explicitly.
-     * <p>
-     * <b>IMPLEMENTATION NOTE </b>: Any attribute that is not Serializable will
-     * be unbound from the session, with appropriate actions if it implements
-     * HttpSessionBindingListener. If you do not want any such attributes, be
-     * sure the <code>distributable</code> property of the associated Manager
-     * is set to <code>true</code>.
-     *
-     * @param stream
-     *            The output stream to write to
-     *
-     * @exception IOException
-     *                if an input/output error occurs
-     */
-    private void writeObject(ObjectOutput stream) throws IOException {
-        // Write the scalar instance variables (except Manager)
-        stream.writeObject(new Long(creationTime));
-        stream.writeObject(new Long(lastAccessedTime));
-        stream.writeObject(new Integer(maxInactiveInterval));
-        stream.writeObject(new Boolean(isNew));
-        stream.writeObject(new Boolean(isValid));
-        stream.writeObject(new Long(thisAccessedTime));
-        stream.writeObject(new Long(version));
-        stream.writeBoolean(getPrincipal() != null);
-        if (getPrincipal() != null) {
-            SerializablePrincipal.writePrincipal((GenericPrincipal) principal,stream);
-        }
-
-        stream.writeObject(id);
-        if (log.isDebugEnabled()) log.debug(sm.getString("deltaSession.writeSession", id));
-
-        // Accumulate the names of serializable and non-serializable attributes
-        String keys[] = keys();
-        ArrayList saveNames = new ArrayList();
-        ArrayList saveValues = new ArrayList();
-        for (int i = 0; i < keys.length; i++) {
-            Object value = null;
-            value = attributes.get(keys[i]);
-            if (value == null)
-                continue;
-            else if (value instanceof Serializable) {
-                saveNames.add(keys[i]);
-                saveValues.add(value);
-            }
-        }
-
-        // Serialize the attribute count and the Serializable attributes
-        int n = saveNames.size();
-        stream.writeObject(new Integer(n));
-        for (int i = 0; i < n; i++) {
-            stream.writeObject( (String) saveNames.get(i));
-            try {
-                stream.writeObject(saveValues.get(i));
-            } catch (NotSerializableException e) {
-                log.error(sm.getString("standardSession.notSerializable",saveNames.get(i), id), e);
-                stream.writeObject(NOT_SERIALIZED);
-                log.error("  storing attribute '" + saveNames.get(i)+ "' with value NOT_SERIALIZED");
-            }
-        }
-
-    }
-
-    // -------------------------------------------------------- Private Methods
-
-    
-
-    /**
-     * Return the value of an attribute without a check for validity.
-     */
-    protected Object getAttributeInternal(String name) {
-        return (attributes.get(name));
-    }
-
-    protected void removeAttributeInternal(String name, boolean notify,
-                                           boolean addDeltaRequest) {
-        try {
-            lock();
-            // Remove this attribute from our collection
-            Object value = attributes.get(name);
-            if (value == null) return;
-
-            super.removeAttributeInternal(name,notify);
-            if (addDeltaRequest && (deltaRequest != null)) deltaRequest.removeAttribute(name);
-
-        }finally {
-            unlock();
-        }
-    }
-
-    protected long getLastTimeReplicated() {
-        return lastTimeReplicated;
-    }
-
-    public long getVersion() {
-        return version;
-    }
-
-    protected void setLastTimeReplicated(long lastTimeReplicated) {
-        this.lastTimeReplicated = lastTimeReplicated;
-    }
-
-    public void setVersion(long version) {
-        this.version = version;
-    }
-
-    protected void setAccessCount(int count) {
-        if ( accessCount == null && ACTIVITY_CHECK ) accessCount = new AtomicInteger();
-        if ( accessCount != null ) super.accessCount.set(count);
-    }
-}
-
-// -------------------------------------------------------------- Private Class
-
-/**
- * This class is a dummy implementation of the <code>HttpSessionContext</code>
- * interface, to conform to the requirement that such an object be returned when
- * <code>HttpSession.getSessionContext()</code> is called.
- *
- * @author Craig R. McClanahan
- *
- * @deprecated As of Java Servlet API 2.1 with no replacement. The interface
- *             will be removed in a future version of this API.
- */
-
-final class StandardSessionContext
-    implements HttpSessionContext {
-
-    private HashMap dummy = new HashMap();
-
-    /**
-     * Return the session identifiers of all sessions defined within this
-     * context.
-     *
-     * @deprecated As of Java Servlet API 2.1 with no replacement. This method
-     *             must return an empty <code>Enumeration</code> and will be
-     *             removed in a future version of the API.
-     */
-    public Enumeration getIds() {
-        return (new Enumerator(dummy));
-    }
-
-    /**
-     * Return the <code>HttpSession</code> associated with the specified
-     * session identifier.
-     *
-     * @param id
-     *            Session identifier for which to look up a session
-     *
-     * @deprecated As of Java Servlet API 2.1 with no replacement. This method
-     *             must return null and will be removed in a future version of
-     *             the API.
-     */
-    public HttpSession getSession(String id) {
-        return (null);
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha.session;
+
+import java.io.Externalizable;
+import java.io.IOException;
+import java.io.NotSerializableException;
+import java.io.ObjectInput;
+import java.io.ObjectOutput;
+import java.io.Serializable;
+import java.security.Principal;
+import java.util.ArrayList;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Hashtable;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+import javax.servlet.http.HttpSession;
+import javax.servlet.http.HttpSessionContext;
+
+import org.apache.catalina.Manager;
+import org.apache.catalina.ha.ClusterManager;
+import org.apache.catalina.ha.ClusterSession;
+import org.apache.catalina.realm.GenericPrincipal;
+import org.apache.catalina.session.StandardSession;
+import org.apache.catalina.tribes.io.ReplicationStream;
+import org.apache.catalina.tribes.tipis.ReplicatedMapEntry;
+import org.apache.catalina.util.Enumerator;
+import org.apache.catalina.util.StringManager;
+import org.apache.catalina.session.StandardManager;
+import org.apache.catalina.session.ManagerBase;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ *
+ * Similar to the StandardSession except that this session will keep
+ * track of deltas during a request.
+ *
+ * @author Filip Hanik
+ * @version $Revision$ $Date$
+ */
+
+public class DeltaSession extends StandardSession implements Externalizable,ClusterSession,ReplicatedMapEntry {
+
+    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(DeltaSession.class);
+
+    /**
+     * The string manager for this package.
+     */
+    protected static StringManager sm = StringManager.getManager(Constants.Package);
+
+    // ----------------------------------------------------- Instance Variables
+
+    /**
+     * only the primary session will expire, or be able to expire due to
+     * inactivity. This is set to false as soon as I receive this session over
+     * the wire in a session message. That means that someone else has made a
+     * request on another server.
+     */
+    private transient boolean isPrimarySession = true;
+
+    /**
+     * The delta request contains all the action info
+     *
+     */
+    private transient DeltaRequest deltaRequest = null;
+
+    /**
+     * Last time the session was replicatd, used for distributed expiring of
+     * session
+     */
+    private transient long lastTimeReplicated = System.currentTimeMillis();
+
+
+    protected Lock diffLock = new ReentrantReadWriteLock().writeLock();
+
+    private long version;
+
+    // ----------------------------------------------------------- Constructors
+
+    /**
+     * Construct a new Session associated with the specified Manager.
+     *
+     * @param manager
+     *            The manager with which this Session is associated
+     */
+    public DeltaSession() {
+        this(null);
+    }
+
+    public DeltaSession(Manager manager) {
+        super(manager);
+        this.resetDeltaRequest();
+    }
+
+    // ----------------------------------------------------- ReplicatedMapEntry
+
+    /**
+         * Has the object changed since last replication
+         * and is not in a locked state
+         * @return boolean
+         */
+        public boolean isDirty() {
+            return getDeltaRequest().getSize()>0;
+        }
+
+        /**
+         * If this returns true, the map will extract the diff using getDiff()
+         * Otherwise it will serialize the entire object.
+         * @return boolean
+         */
+        public boolean isDiffable() {
+            return true;
+        }
+
+        /**
+         * Returns a diff and sets the dirty map to false
+         * @return byte[]
+         * @throws IOException
+         */
+        public byte[] getDiff() throws IOException {
+            return getDeltaRequest().serialize();
+        }
+
+        public ClassLoader[] getClassLoaders() {
+            if ( manager instanceof BackupManager ) return ((BackupManager)manager).getClassLoaders();
+            else if ( manager instanceof ClusterManagerBase ) return ((ClusterManagerBase)manager).getClassLoaders();
+            else if ( manager instanceof StandardManager ) {
+                StandardManager sm = (StandardManager)manager;
+                return ClusterManagerBase.getClassLoaders(sm.getContainer());
+            } else if ( manager instanceof ManagerBase ) {
+                ManagerBase mb = (ManagerBase)manager;
+                return ClusterManagerBase.getClassLoaders(mb.getContainer());
+            }//end if
+            return null;
+        }
+
+        /**
+         * Applies a diff to an existing object.
+         * @param diff byte[]
+         * @param offset int
+         * @param length int
+         * @throws IOException
+         */
+        public void applyDiff(byte[] diff, int offset, int length) throws IOException, ClassNotFoundException {
+            ReplicationStream stream = ((ClusterManager)getManager()).getReplicationStream(diff,offset,length);
+            getDeltaRequest().readExternal(stream);
+            ClassLoader contextLoader = Thread.currentThread().getContextClassLoader();
+            try {
+                ClassLoader[] loaders = getClassLoaders();
+                if ( loaders != null && loaders.length >0 ) Thread.currentThread().setContextClassLoader(loaders[0]);
+                getDeltaRequest().execute(this);
+            }finally {
+                Thread.currentThread().setContextClassLoader(contextLoader);
+            }
+        }
+
+        /**
+         * Resets the current diff state and resets the dirty flag
+         */
+        public void resetDiff() {
+            resetDeltaRequest();
+        }
+
+        /**
+         * Lock during serialization
+         */
+        public void lock() {
+            diffLock.lock();
+        }
+
+        /**
+         * Unlock after serialization
+         */
+        public void unlock() {
+            diffLock.unlock();
+        }
+
+        public void setOwner(Object owner) {
+            if ( owner instanceof ClusterManager && getManager()==null) {
+                ClusterManager cm = (ClusterManager)owner;
+                this.setManager(cm);
+                this.setValid(true);
+                this.setPrimarySession(false);
+                this.access();
+                this.resetDeltaRequest();
+                this.endAccess();
+            }
+        }
+    // ----------------------------------------------------- Session Properties
+
+    /**
+     * returns true if this session is the primary session, if that is the case,
+     * the manager can expire it upon timeout.
+     */
+    public boolean isPrimarySession() {
+        return isPrimarySession;
+    }
+
+    /**
+     * Sets whether this is the primary session or not.
+     *
+     * @param primarySession
+     *            Flag value
+     */
+    public void setPrimarySession(boolean primarySession) {
+        this.isPrimarySession = primarySession;
+    }
+
+    /**
+     * Set the session identifier for this session without notify listeners.
+     *
+     * @param id
+     *            The new session identifier
+     */
+    public void setIdInternal(String id) {
+        this.id = id;
+        resetDeltaRequest();
+    }
+
+    /**
+     * Set the session identifier for this session.
+     *
+     * @param id
+     *            The new session identifier
+     */
+    public void setId(String id) {
+        super.setId(id);
+        resetDeltaRequest();
+    }
+
+   
+
+    /**
+     * Return the last client access time without invalidation check
+     * @see #getLastAccessedTime().
+     */
+    public long getLastAccessedTimeInternal() {
+        return (this.lastAccessedTime);
+    }
+
+
+   
+    public void setMaxInactiveInterval(int interval, boolean addDeltaRequest) {
+        super.maxInactiveInterval = interval;
+        if (isValid && interval == 0) {
+            expire();
+        } else {
+            if (addDeltaRequest && (deltaRequest != null))
+                deltaRequest.setMaxInactiveInterval(interval);
+        }
+    }
+
+    /**
+     * Set the <code>isNew</code> flag for this session.
+     *
+     * @param isNew
+     *            The new value for the <code>isNew</code> flag
+     */
+    public void setNew(boolean isNew) {
+        setNew(isNew, true);
+    }
+
+    public void setNew(boolean isNew, boolean addDeltaRequest) {
+        super.setNew(isNew);
+        if (addDeltaRequest && (deltaRequest != null))
+            deltaRequest.setNew(isNew);
+    }
+
+    /**
+     * Set the authenticated Principal that is associated with this Session.
+     * This provides an <code>Authenticator</code> with a means to cache a
+     * previously authenticated Principal, and avoid potentially expensive
+     * <code>Realm.authenticate()</code> calls on every request.
+     *
+     * @param principal
+     *            The new Principal, or <code>null</code> if none
+     */
+    public void setPrincipal(Principal principal) {
+        setPrincipal(principal, true);
+    }
+
+    public void setPrincipal(Principal principal, boolean addDeltaRequest) {
+        try { 
+            lock();
+            super.setPrincipal(principal);
+            if (addDeltaRequest && (deltaRequest != null))
+                deltaRequest.setPrincipal(principal);
+        } finally {
+            unlock();
+        }
+    }
+
+    /**
+     * Return the <code>isValid</code> flag for this session.
+     */
+    public boolean isValid() {
+        if (this.expiring) {
+            return true;
+        }
+        if (!this.isValid) {
+            return false;
+        }
+        if (ACTIVITY_CHECK && accessCount.get() > 0) {
+            return true;
+        }
+        if (maxInactiveInterval >= 0) {
+            long timeNow = System.currentTimeMillis();
+            int timeIdle = (int) ( (timeNow - thisAccessedTime) / 1000L);
+            if (isPrimarySession()) {
+                if (timeIdle >= maxInactiveInterval) {
+                    expire(true);
+                }
+            } else {
+                if (timeIdle >= (2 * maxInactiveInterval)) {
+                    //if the session has been idle twice as long as allowed,
+                    //the primary session has probably crashed, and no other
+                    //requests are coming in. that is why we do this. otherwise
+                    //we would have a memory leak
+                    expire(true, false);
+                }
+            }
+        }
+        return (this.isValid);
+    }
+
+    // ------------------------------------------------- Session Public Methods
+
+    /**
+     * Perform the internal processing required to invalidate this session,
+     * without triggering an exception if the session has already expired.
+     *
+     * @param notify
+     *            Should we notify listeners about the demise of this session?
+     */
+    public void expire(boolean notify) {
+        expire(notify, true);
+    }
+
+    public void expire(boolean notify, boolean notifyCluster) {
+        String expiredId = getIdInternal();
+        super.expire(notify);
+
+        if (notifyCluster) {
+            if (log.isDebugEnabled())
+                log.debug(sm.getString("deltaSession.notifying",
+                                       ((DeltaManager)manager).getName(), 
+                                       new Boolean(isPrimarySession()), 
+                                       expiredId));
+            if ( manager instanceof DeltaManager ) {
+                ( (DeltaManager) manager).sessionExpired(expiredId);
+            }
+        }
+    }
+
+    /**
+     * Release all object references, and initialize instance variables, in
+     * preparation for reuse of this object.
+     */
+    public void recycle() {
+        super.recycle();
+        deltaRequest.clear();
+    }
+
+
+    /**
+     * Return a string representation of this object.
+     */
+    public String toString() {
+        StringBuffer sb = new StringBuffer();
+        sb.append("DeltaSession[");
+        sb.append(id);
+        sb.append("]");
+        return (sb.toString());
+    }
+
+    // ------------------------------------------------ Session Package Methods
+
+    public synchronized void readExternal(ObjectInput in) throws IOException,ClassNotFoundException {
+        readObjectData(in);
+    }
+
+
+    /**
+     * Read a serialized version of the contents of this session object from the
+     * specified object input stream, without requiring that the StandardSession
+     * itself have been serialized.
+     *
+     * @param stream
+     *            The object input stream to read from
+     *
+     * @exception ClassNotFoundException
+     *                if an unknown class is specified
+     * @exception IOException
+     *                if an input/output error occurs
+     */
+    public void readObjectData(ObjectInput stream) throws ClassNotFoundException, IOException {
+        readObject(stream);
+    }
+
+    /**
+     * Write a serialized version of the contents of this session object to the
+     * specified object output stream, without requiring that the
+     * StandardSession itself have been serialized.
+     *
+     * @param stream
+     *            The object output stream to write to
+     *
+     * @exception IOException
+     *                if an input/output error occurs
+     */
+    public void writeObjectData(ObjectOutput stream) throws IOException {
+        writeObject(stream);
+    }
+
+    public void resetDeltaRequest() {
+        if (deltaRequest == null) {
+            deltaRequest = new DeltaRequest(getIdInternal(), false);
+        } else {
+            deltaRequest.reset();
+            deltaRequest.setSessionId(getIdInternal());
+        }
+    }
+
+    public DeltaRequest getDeltaRequest() {
+        if (deltaRequest == null) resetDeltaRequest();
+        return deltaRequest;
+    }
+
+    // ------------------------------------------------- HttpSession Properties
+
+    // ----------------------------------------------HttpSession Public Methods
+
+
+
+    /**
+     * Remove the object bound with the specified name from this session. If the
+     * session does not have an object bound with this name, this method does
+     * nothing.
+     * <p>
+     * After this method executes, and if the object implements
+     * <code>HttpSessionBindingListener</code>, the container calls
+     * <code>valueUnbound()</code> on the object.
+     *
+     * @param name
+     *            Name of the object to remove from this session.
+     * @param notify
+     *            Should we notify interested listeners that this attribute is
+     *            being removed?
+     *
+     * @exception IllegalStateException
+     *                if this method is called on an invalidated session
+     */
+    public void removeAttribute(String name, boolean notify) {
+        removeAttribute(name, notify, true);
+    }
+
+    public void removeAttribute(String name, boolean notify,boolean addDeltaRequest) {
+        // Validate our current state
+        if (!isValid()) throw new IllegalStateException(sm.getString("standardSession.removeAttribute.ise"));
+        removeAttributeInternal(name, notify, addDeltaRequest);
+    }
+
+    /**
+     * Bind an object to this session, using the specified name. If an object of
+     * the same name is already bound to this session, the object is replaced.
+     * <p>
+     * After this method executes, and if the object implements
+     * <code>HttpSessionBindingListener</code>, the container calls
+     * <code>valueBound()</code> on the object.
+     *
+     * @param name
+     *            Name to which the object is bound, cannot be null
+     * @param value
+     *            Object to be bound, cannot be null
+     *
+     * @exception IllegalArgumentException
+     *                if an attempt is made to add a non-serializable object in
+     *                an environment marked distributable.
+     * @exception IllegalStateException
+     *                if this method is called on an invalidated session
+     */
+    public void setAttribute(String name, Object value) {
+        setAttribute(name, value, true, true);
+    }
+
+    public void setAttribute(String name, Object value, boolean notify,boolean addDeltaRequest) {
+
+        // Name cannot be null
+        if (name == null) throw new IllegalArgumentException(sm.getString("standardSession.setAttribute.namenull"));
+
+        // Null value is the same as removeAttribute()
+        if (value == null) {
+            removeAttribute(name);
+            return;
+        }
+
+        try {
+            lock();
+            super.setAttribute(name,value, notify);
+            if (addDeltaRequest && (deltaRequest != null)) deltaRequest.setAttribute(name, value);
+        } finally {
+            unlock();
+        }
+    }
+
+    // -------------------------------------------- HttpSession Private Methods
+
+    /**
+     * Read a serialized version of this session object from the specified
+     * object input stream.
+     * <p>
+     * <b>IMPLEMENTATION NOTE </b>: The reference to the owning Manager is not
+     * restored by this method, and must be set explicitly.
+     *
+     * @param stream
+     *            The input stream to read from
+     *
+     * @exception ClassNotFoundException
+     *                if an unknown class is specified
+     * @exception IOException
+     *                if an input/output error occurs
+     */
+    private void readObject(ObjectInput stream) throws ClassNotFoundException, IOException {
+
+        // Deserialize the scalar instance variables (except Manager)
+        authType = null; // Transient only
+        creationTime = ( (Long) stream.readObject()).longValue();
+        lastAccessedTime = ( (Long) stream.readObject()).longValue();
+        maxInactiveInterval = ( (Integer) stream.readObject()).intValue();
+        isNew = ( (Boolean) stream.readObject()).booleanValue();
+        isValid = ( (Boolean) stream.readObject()).booleanValue();
+        thisAccessedTime = ( (Long) stream.readObject()).longValue();
+        version = ( (Long) stream.readObject()).longValue();
+        boolean hasPrincipal = stream.readBoolean();
+        principal = null;
+        if (hasPrincipal) {
+            principal = SerializablePrincipal.readPrincipal(stream,getManager().getContainer().getRealm());
+        }
+
+        //        setId((String) stream.readObject());
+        id = (String) stream.readObject();
+        if (log.isDebugEnabled()) log.debug(sm.getString("deltaSession.readSession", id));
+
+        // Deserialize the attribute count and attribute values
+        if (attributes == null) attributes = new Hashtable();
+        int n = ( (Integer) stream.readObject()).intValue();
+        boolean isValidSave = isValid;
+        isValid = true;
+        for (int i = 0; i < n; i++) {
+            String name = (String) stream.readObject();
+            Object value = (Object) stream.readObject();
+            if ( (value instanceof String) && (value.equals(NOT_SERIALIZED)))
+                continue;
+            attributes.put(name, value);
+        }
+        isValid = isValidSave;
+
+        if (listeners == null) {
+            listeners = new ArrayList();
+        }
+
+        if (notes == null) {
+            notes = new Hashtable();
+        }
+        activate();
+    }
+
+    public synchronized void writeExternal(ObjectOutput out ) throws java.io.IOException {
+        writeObject(out);
+    }
+
+
+    /**
+     * Write a serialized version of this session object to the specified object
+     * output stream.
+     * <p>
+     * <b>IMPLEMENTATION NOTE </b>: The owning Manager will not be stored in the
+     * serialized representation of this Session. After calling
+     * <code>readObject()</code>, you must set the associated Manager
+     * explicitly.
+     * <p>
+     * <b>IMPLEMENTATION NOTE </b>: Any attribute that is not Serializable will
+     * be unbound from the session, with appropriate actions if it implements
+     * HttpSessionBindingListener. If you do not want any such attributes, be
+     * sure the <code>distributable</code> property of the associated Manager
+     * is set to <code>true</code>.
+     *
+     * @param stream
+     *            The output stream to write to
+     *
+     * @exception IOException
+     *                if an input/output error occurs
+     */
+    private void writeObject(ObjectOutput stream) throws IOException {
+        // Write the scalar instance variables (except Manager)
+        stream.writeObject(new Long(creationTime));
+        stream.writeObject(new Long(lastAccessedTime));
+        stream.writeObject(new Integer(maxInactiveInterval));
+        stream.writeObject(new Boolean(isNew));
+        stream.writeObject(new Boolean(isValid));
+        stream.writeObject(new Long(thisAccessedTime));
+        stream.writeObject(new Long(version));
+        stream.writeBoolean(getPrincipal() != null);
+        if (getPrincipal() != null) {
+            SerializablePrincipal.writePrincipal((GenericPrincipal) principal,stream);
+        }
+
+        stream.writeObject(id);
+        if (log.isDebugEnabled()) log.debug(sm.getString("deltaSession.writeSession", id));
+
+        // Accumulate the names of serializable and non-serializable attributes
+        String keys[] = keys();
+        ArrayList saveNames = new ArrayList();
+        ArrayList saveValues = new ArrayList();
+        for (int i = 0; i < keys.length; i++) {
+            Object value = null;
+            value = attributes.get(keys[i]);
+            if (value == null)
+                continue;
+            else if (value instanceof Serializable) {
+                saveNames.add(keys[i]);
+                saveValues.add(value);
+            }
+        }
+
+        // Serialize the attribute count and the Serializable attributes
+        int n = saveNames.size();
+        stream.writeObject(new Integer(n));
+        for (int i = 0; i < n; i++) {
+            stream.writeObject( (String) saveNames.get(i));
+            try {
+                stream.writeObject(saveValues.get(i));
+            } catch (NotSerializableException e) {
+                log.error(sm.getString("standardSession.notSerializable",saveNames.get(i), id), e);
+                stream.writeObject(NOT_SERIALIZED);
+                log.error("  storing attribute '" + saveNames.get(i)+ "' with value NOT_SERIALIZED");
+            }
+        }
+
+    }
+
+    // -------------------------------------------------------- Private Methods
+
+    
+
+    /**
+     * Return the value of an attribute without a check for validity.
+     */
+    protected Object getAttributeInternal(String name) {
+        return (attributes.get(name));
+    }
+
+    protected void removeAttributeInternal(String name, boolean notify,
+                                           boolean addDeltaRequest) {
+        try {
+            lock();
+            // Remove this attribute from our collection
+            Object value = attributes.get(name);
+            if (value == null) return;
+
+            super.removeAttributeInternal(name,notify);
+            if (addDeltaRequest && (deltaRequest != null)) deltaRequest.removeAttribute(name);
+
+        }finally {
+            unlock();
+        }
+    }
+
+    protected long getLastTimeReplicated() {
+        return lastTimeReplicated;
+    }
+
+    public long getVersion() {
+        return version;
+    }
+
+    protected void setLastTimeReplicated(long lastTimeReplicated) {
+        this.lastTimeReplicated = lastTimeReplicated;
+    }
+
+    public void setVersion(long version) {
+        this.version = version;
+    }
+
+    protected void setAccessCount(int count) {
+        if ( accessCount == null && ACTIVITY_CHECK ) accessCount = new AtomicInteger();
+        if ( accessCount != null ) super.accessCount.set(count);
+    }
+}
+
+// -------------------------------------------------------------- Private Class
+
+/**
+ * This class is a dummy implementation of the <code>HttpSessionContext</code>
+ * interface, to conform to the requirement that such an object be returned when
+ * <code>HttpSession.getSessionContext()</code> is called.
+ *
+ * @author Craig R. McClanahan
+ *
+ * @deprecated As of Java Servlet API 2.1 with no replacement. The interface
+ *             will be removed in a future version of this API.
+ */
+
+final class StandardSessionContext
+    implements HttpSessionContext {
+
+    private HashMap dummy = new HashMap();
+
+    /**
+     * Return the session identifiers of all sessions defined within this
+     * context.
+     *
+     * @deprecated As of Java Servlet API 2.1 with no replacement. This method
+     *             must return an empty <code>Enumeration</code> and will be
+     *             removed in a future version of the API.
+     */
+    public Enumeration getIds() {
+        return (new Enumerator(dummy));
+    }
+
+    /**
+     * Return the <code>HttpSession</code> associated with the specified
+     * session identifier.
+     *
+     * @param id
+     *            Session identifier for which to look up a session
+     *
+     * @deprecated As of Java Servlet API 2.1 with no replacement. This method
+     *             must return null and will be removed in a future version of
+     *             the API.
+     */
+    public HttpSession getSession(String id) {
+        return (null);
+    }
+
+}

==================================================
JvmRouteSessionIDBinderListener.java
index b0e0a0b38c..8e574a9394 100644
--- a/java/org/apache/catalina/ha/session/JvmRouteBinderValve.java
+++ b/java/org/apache/catalina/ha/session/JvmRouteBinderValve.java
@@ -1,544 +1,544 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.ha.session;
-
-import java.io.IOException;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.Cookie;
-
-import org.apache.catalina.Container;
-import org.apache.catalina.Context;
-import org.apache.catalina.Engine;
-import org.apache.catalina.Globals;
-import org.apache.catalina.Host;
-import org.apache.catalina.Lifecycle;
-import org.apache.catalina.LifecycleException;
-import org.apache.catalina.LifecycleListener;
-import org.apache.catalina.Manager;
-import org.apache.catalina.Session;
-import org.apache.catalina.ha.CatalinaCluster;
-import org.apache.catalina.ha.ClusterManager;
-import org.apache.catalina.ha.ClusterMessage;
-import org.apache.catalina.ha.ClusterValve;
-import org.apache.catalina.connector.Request;
-import org.apache.catalina.connector.Response;
-import org.apache.catalina.session.ManagerBase;
-import org.apache.catalina.util.LifecycleSupport;
-import org.apache.catalina.util.StringManager;
-import org.apache.catalina.valves.ValveBase;
-
-/**
- * Valve to handle Tomcat jvmRoute takeover using mod_jk module after node
- * failure. After a node crashed the next request going to other cluster node.
- * Now the answering from apache is slower ( make some error handshaking. Very
- * bad with apache at my windows.). We rewrite now the cookie jsessionid
- * information to the backup cluster node. After the next response all client
- * request goes direct to the backup node. The change sessionid send also to all
- * other cluster nodes. Well, now the session stickyness work directly to the
- * backup node and traffic don't go back too restarted cluster nodes!
- * 
- * At all cluster node you must configure the as ClusterListener since 5.5.10
- * {@link org.apache.catalina.ha.session.JvmRouteSessionIDBinderListener JvmRouteSessionIDBinderListener}
- * or before with
- * org.apache.catalina.ha.session.JvmRouteSessionIDBinderListenerLifecycle.
- * 
- * Add this Valve to your host definition at conf/server.xml .
- * 
- * Since 5.5.10 as direct cluster valve:<br/>
- * <pre>
- *  &lt;Cluster&gt;
- *  &lt;Valve className=&quot;org.apache.catalina.ha.session.JvmRouteBinderValve&quot; /&gt;  
- *  &lt;/Cluster&gt;
- * </pre>
- * <br />
- * Before 5.5.10 as Host element:<br/>
- * <pre>
- *  &lt;Hostr&gt;
- *  &lt;Valve className=&quot;org.apache.catalina.ha.session.JvmRouteBinderValve&quot; /&gt;  
- *  &lt;/Hostr&gt;
- * </pre>
- * 
- * Trick:<br/>
- * You can enable this mod_jk turnover mode via JMX before you drop a node to all backup nodes!
- * Set enable true on all JvmRouteBinderValve backups, disable worker at mod_jk 
- * and then drop node and restart it! Then enable mod_jk Worker and disable JvmRouteBinderValves again. 
- * This use case means that only requested session are migrated.
- * 
- * @author Peter Rossbach
- * @version $Revision: 326110 $ $Date: 2005-10-18 09:08:36 -0500 (Tue, 18 Oct 2005) $
- */
-public class JvmRouteBinderValve extends ValveBase implements ClusterValve, Lifecycle {
-
-    /*--Static Variables----------------------------------------*/
-    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory
-            .getLog(JvmRouteBinderValve.class);
-
-    /**
-     * The descriptive information about this implementation.
-     */
-    protected static final String info = "org.apache.catalina.ha.session.JvmRouteBinderValve/1.2";
-
-    /*--Instance Variables--------------------------------------*/
-
-    /**
-     * the cluster
-     */
-    protected CatalinaCluster cluster;
-
-    /**
-     * The string manager for this package.
-     */
-    protected StringManager sm = StringManager.getManager(Constants.Package);
-
-    /**
-     * Has this component been started yet?
-     */
-    protected boolean started = false;
-
-    /**
-     * enabled this component
-     */
-    protected boolean enabled = true;
-
-    /**
-     * number of session that no at this tomcat instanz hosted
-     */
-    protected long numberOfSessions = 0;
-
-    protected String sessionIdAttribute = "org.apache.catalina.ha.session.JvmRouteOrignalSessionID";
-
-    /**
-     * The lifecycle event support for this component.
-     */
-    protected LifecycleSupport lifecycle = new LifecycleSupport(this);
-
-    /*--Logic---------------------------------------------------*/
-
-    /**
-     * Return descriptive information about this implementation.
-     */
-    public String getInfo() {
-
-        return (info);
-
-    }
-
-    /**
-     * set session id attribute to failed node for request.
-     * 
-     * @return Returns the sessionIdAttribute.
-     */
-    public String getSessionIdAttribute() {
-        return sessionIdAttribute;
-    }
-
-    /**
-     * get name of failed reqeust session attribute
-     * 
-     * @param sessionIdAttribute
-     *            The sessionIdAttribute to set.
-     */
-    public void setSessionIdAttribute(String sessionIdAttribute) {
-        this.sessionIdAttribute = sessionIdAttribute;
-    }
-
-    /**
-     * @return Returns the number of migrated sessions.
-     */
-    public long getNumberOfSessions() {
-        return numberOfSessions;
-    }
-
-    /**
-     * @return Returns the enabled.
-     */
-    public boolean getEnabled() {
-        return enabled;
-    }
-
-    /**
-     * @param enabled
-     *            The enabled to set.
-     */
-    public void setEnabled(boolean enabled) {
-        this.enabled = enabled;
-    }
-
-    /**
-     * Detect possible the JVMRoute change at cluster backup node..
-     * 
-     * @param request
-     *            tomcat request being processed
-     * @param response
-     *            tomcat response being processed
-     * @exception IOException
-     *                if an input/output error has occurred
-     * @exception ServletException
-     *                if a servlet error has occurred
-     */
-    public void invoke(Request request, Response response) throws IOException,
-            ServletException {
-
-         if (getEnabled() 
-             && getCluster() != null
-             && request.getContext() != null
-             && request.getContext().getDistributable() ) {
-             // valve cluster can access manager - other cluster handle turnover 
-             // at host level - hopefully!
-             Manager manager = request.getContext().getManager();
-             if (manager != null && manager instanceof ClusterManager
-                     && getCluster().getManager(((ClusterManager)manager).getName()) != null)
-                 handlePossibleTurnover(request, response);
-        }
-        // Pass this request on to the next valve in our pipeline
-        getNext().invoke(request, response);
-    }
-
-    /**
-     * handle possible session turn over.
-     * 
-     * @see JvmRouteBinderValve#handleJvmRoute(Request, Response, String, String)
-     * @param request current request
-     * @param response current response
-     */
-    protected void handlePossibleTurnover(Request request, Response response) {
-        Session session = request.getSessionInternal(false);
-        if (session != null) {
-            long t1 = System.currentTimeMillis();
-            String jvmRoute = getLocalJvmRoute(request);
-            if (jvmRoute == null) {
-                if (log.isDebugEnabled())
-                    log.debug(sm.getString("jvmRoute.missingJvmRouteAttribute"));
-                return;
-            }
-            handleJvmRoute( request, response,session.getIdInternal(), jvmRoute);
-            if (log.isDebugEnabled()) {
-                long t2 = System.currentTimeMillis();
-                long time = t2 - t1;
-                log.debug(sm.getString("jvmRoute.turnoverInfo", new Long(time)));
-            }
-        }
-    }
-
-    /**
-     * get jvmroute from engine
-     * 
-     * @param request current request
-     * @return return jvmRoute from ManagerBase or null
-     */
-    protected String getLocalJvmRoute(Request request) {
-        Manager manager = getManager(request);
-        if(manager instanceof ManagerBase)
-            return ((ManagerBase) manager).getJvmRoute();
-        return null ;
-    }
-
-    /**
-     * get Cluster DeltaManager
-     * 
-     * @param request current request
-     * @return manager or null
-     */
-    protected Manager getManager(Request request) {
-        Manager manager = request.getContext().getManager();
-        if (log.isDebugEnabled()) {
-            if(manager != null)
-                log.debug(sm.getString("jvmRoute.foundManager", manager,  request.getContext().getName()));
-            else 
-                log.debug(sm.getString("jvmRoute.notFoundManager", manager,  request.getContext().getName()));
-        }
-        return manager;
-    }
-
-    /**
-     * @return Returns the cluster.
-     */
-    public CatalinaCluster getCluster() {
-        return cluster;
-    }
-    
-    /**
-     * @param cluster The cluster to set.
-     */
-    public void setCluster(CatalinaCluster cluster) {
-        this.cluster = cluster;
-    }
-    
-    /**
-     * Handle jvmRoute stickyness after tomcat instance failed. After this
-     * correction a new Cookie send to client with new jvmRoute and the
-     * SessionID change propage to the other cluster nodes.
-     * 
-     * @param request current request
-     * @param response
-     *            Tomcat Response
-     * @param sessionId
-     *            request SessionID from Cookie
-     * @param localJvmRoute
-     *            local jvmRoute
-     */
-    protected void handleJvmRoute(
-            Request request, Response response,String sessionId, String localJvmRoute) {
-        // get requested jvmRoute.
-        String requestJvmRoute = null;
-        int index = sessionId.indexOf(".");
-        if (index > 0) {
-            requestJvmRoute = sessionId
-                    .substring(index + 1, sessionId.length());
-        }
-        if (requestJvmRoute != null && !requestJvmRoute.equals(localJvmRoute)) {
-            if (log.isDebugEnabled()) {
-                log.debug(sm.getString("jvmRoute.failover", requestJvmRoute,
-                        localJvmRoute, sessionId));
-            }
-            // OK - turnover the session ?
-            String newSessionID = sessionId.substring(0, index) + "."
-                    + localJvmRoute;
-            Session catalinaSession = null;
-            try {
-                catalinaSession = getManager(request).findSession(sessionId);
-            } catch (IOException e) {
-                // Hups!
-            }
-            if (catalinaSession != null) {
-                changeSessionID(request, response, sessionId, newSessionID,
-                        catalinaSession);
-                numberOfSessions++;
-            } else {
-                if (log.isDebugEnabled()) {
-                    log.debug(sm.getString("jvmRoute.cannotFindSession",
-                            sessionId));
-                }
-            }
-        }
-    }
-
-    /**
-     * change session id and send to all cluster nodes
-     * 
-     * @param request current request
-     * @param response current response
-     * @param sessionId
-     *            original session id
-     * @param newSessionID
-     *            new session id for node migration
-     * @param catalinaSession
-     *            current session with original session id
-     */
-    protected void changeSessionID(Request request,
-            Response response, String sessionId, String newSessionID, Session catalinaSession) {
-        lifecycle.fireLifecycleEvent("Before session migration",
-                catalinaSession);
-        request.setRequestedSessionId(newSessionID);
-        catalinaSession.setId(newSessionID);
-        if (catalinaSession instanceof DeltaSession)
-            ((DeltaSession) catalinaSession).resetDeltaRequest();
-        if(request.isRequestedSessionIdFromCookie()) setNewSessionCookie(request, response,newSessionID);
-        // set orginal sessionid at request, to allow application detect the
-        // change
-        if (sessionIdAttribute != null && !"".equals(sessionIdAttribute)) {
-            if (log.isDebugEnabled()) {
-                log.debug(sm.getString("jvmRoute.set.orignalsessionid",sessionIdAttribute,sessionId));
-            }
-            request.setAttribute(sessionIdAttribute, sessionId);
-        }
-        // now sending the change to all other clusternode!
-        ClusterManager manager = (ClusterManager)catalinaSession.getManager();
-        sendSessionIDClusterBackup(manager,request,sessionId, newSessionID);
-        lifecycle
-                .fireLifecycleEvent("After session migration", catalinaSession);
-        if (log.isDebugEnabled()) {
-            log.debug(sm.getString("jvmRoute.changeSession", sessionId,
-                    newSessionID));
-        }
-    }
-
-    /**
-     * Send the changed Sessionid to all clusternodes.
-     * 
-     * @see JvmRouteSessionIDBinderListener#messageReceived(ClusterMessage)
-     * @param manager
-     *            ClusterManager
-     * @param sessionId
-     *            current failed sessionid
-     * @param newSessionID
-     *            new session id, bind to the new cluster node
-     */
-    protected void sendSessionIDClusterBackup(ClusterManager manager,Request request,String sessionId,
-            String newSessionID) {
-        SessionIDMessage msg = new SessionIDMessage();
-        msg.setOrignalSessionID(sessionId);
-        msg.setBackupSessionID(newSessionID);
-        Context context = request.getContext();
-        msg.setContextPath(context.getPath());
-        msg.setHost(context.getParent().getName());
-        if(manager.doDomainReplication())
-            cluster.sendClusterDomain(msg);
-        else
-            cluster.send(msg);
-    }
-
-    /**
-     * Sets a new cookie for the given session id and response and see
-     * {@link org.apache.catalina.connector.Request#configureSessionCookie(javax.servlet.http.Cookie)}
-     * 
-     * @param request current request
-     * @param response Tomcat Response
-     * @param sessionId The session id
-     */
-    protected void setNewSessionCookie(Request request,
-                                       Response response, String sessionId) {
-        if (response != null) {
-            Context context = request.getContext();
-            if (context.getCookies()) {
-                // set a new session cookie
-                Cookie newCookie = new Cookie(Globals.SESSION_COOKIE_NAME,
-                        sessionId);
-                newCookie.setMaxAge(-1);
-                String contextPath = null;
-                if (!response.getConnector().getEmptySessionPath()
-                        && (context != null)) {
-                    contextPath = context.getEncodedPath();
-                }
-                if ((contextPath != null) && (contextPath.length() > 0)) {
-                    newCookie.setPath(contextPath);
-                } else {
-                    newCookie.setPath("/");
-                }
-                if (request.isSecure()) {
-                    newCookie.setSecure(true);
-                }
-                if (log.isDebugEnabled()) {
-                    log.debug(sm.getString("jvmRoute.newSessionCookie",
-                            sessionId, Globals.SESSION_COOKIE_NAME, newCookie
-                                    .getPath(), new Boolean(newCookie
-                                    .getSecure())));
-                }
-                response.addCookie(newCookie);
-            }
-        }
-    }
-
-    // ------------------------------------------------------ Lifecycle Methods
-
-    /**
-     * Add a lifecycle event listener to this component.
-     * 
-     * @param listener
-     *            The listener to add
-     */
-    public void addLifecycleListener(LifecycleListener listener) {
-
-        lifecycle.addLifecycleListener(listener);
-
-    }
-
-    /**
-     * Get the lifecycle listeners associated with this lifecycle. If this
-     * Lifecycle has no listeners registered, a zero-length array is returned.
-     */
-    public LifecycleListener[] findLifecycleListeners() {
-
-        return lifecycle.findLifecycleListeners();
-
-    }
-
-    /**
-     * Remove a lifecycle event listener from this component.
-     * 
-     * @param listener
-     *            The listener to add
-     */
-    public void removeLifecycleListener(LifecycleListener listener) {
-
-        lifecycle.removeLifecycleListener(listener);
-
-    }
-
-    /**
-     * Prepare for the beginning of active use of the public methods of this
-     * component. This method should be called after <code>configure()</code>,
-     * and before any of the public methods of the component are utilized.
-     * 
-     * @exception LifecycleException
-     *                if this component detects a fatal error that prevents this
-     *                component from being used
-     */
-    public void start() throws LifecycleException {
-
-        // Validate and update our current component state
-        if (started)
-            throw new LifecycleException(sm
-                    .getString("jvmRoute.valve.alreadyStarted"));
-        lifecycle.fireLifecycleEvent(START_EVENT, null);
-        started = true;
-        if (cluster == null) {
-            Container hostContainer = getContainer();
-            // compatibility with JvmRouteBinderValve version 1.1
-            // ( setup at context.xml or context.xml.default )
-            if (!(hostContainer instanceof Host)) {
-                if (log.isWarnEnabled())
-                    log.warn(sm.getString("jvmRoute.configure.warn"));
-                hostContainer = hostContainer.getParent();
-            }
-            if (hostContainer instanceof Host
-                    && ((Host) hostContainer).getCluster() != null) {
-                cluster = (CatalinaCluster) ((Host) hostContainer).getCluster();
-            } else {
-                Container engine = hostContainer.getParent() ;
-                if (engine instanceof Engine
-                        && ((Engine) engine).getCluster() != null) {
-                    cluster = (CatalinaCluster) ((Engine) engine).getCluster();
-                }
-            }
-        }
-        if (cluster == null) {
-            throw new RuntimeException("No clustering support at container "
-                    + container.getName());
-        }
-        
-        if (log.isInfoEnabled())
-            log.info(sm.getString("jvmRoute.valve.started"));
-
-    }
-
-    /**
-     * Gracefully terminate the active use of the public methods of this
-     * component. This method should be the last one called on a given instance
-     * of this component.
-     * 
-     * @exception LifecycleException
-     *                if this component detects a fatal error that needs to be
-     *                reported
-     */
-    public void stop() throws LifecycleException {
-
-        // Validate and update our current component state
-        if (!started)
-            throw new LifecycleException(sm
-                    .getString("jvmRoute.valve.notStarted"));
-        lifecycle.fireLifecycleEvent(STOP_EVENT, null);
-        started = false;
-        cluster = null;
-        numberOfSessions = 0;
-        if (log.isInfoEnabled())
-            log.info(sm.getString("jvmRoute.valve.stopped"));
-
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.ha.session;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.Cookie;
+
+import org.apache.catalina.Container;
+import org.apache.catalina.Context;
+import org.apache.catalina.Engine;
+import org.apache.catalina.Globals;
+import org.apache.catalina.Host;
+import org.apache.catalina.Lifecycle;
+import org.apache.catalina.LifecycleException;
+import org.apache.catalina.LifecycleListener;
+import org.apache.catalina.Manager;
+import org.apache.catalina.Session;
+import org.apache.catalina.ha.CatalinaCluster;
+import org.apache.catalina.ha.ClusterManager;
+import org.apache.catalina.ha.ClusterMessage;
+import org.apache.catalina.ha.ClusterValve;
+import org.apache.catalina.connector.Request;
+import org.apache.catalina.connector.Response;
+import org.apache.catalina.session.ManagerBase;
+import org.apache.catalina.util.LifecycleSupport;
+import org.apache.catalina.util.StringManager;
+import org.apache.catalina.valves.ValveBase;
+
+/**
+ * Valve to handle Tomcat jvmRoute takeover using mod_jk module after node
+ * failure. After a node crashed the next request going to other cluster node.
+ * Now the answering from apache is slower ( make some error handshaking. Very
+ * bad with apache at my windows.). We rewrite now the cookie jsessionid
+ * information to the backup cluster node. After the next response all client
+ * request goes direct to the backup node. The change sessionid send also to all
+ * other cluster nodes. Well, now the session stickyness work directly to the
+ * backup node and traffic don't go back too restarted cluster nodes!
+ * 
+ * At all cluster node you must configure the as ClusterListener since 5.5.10
+ * {@link org.apache.catalina.ha.session.JvmRouteSessionIDBinderListener JvmRouteSessionIDBinderListener}
+ * or before with
+ * org.apache.catalina.ha.session.JvmRouteSessionIDBinderListenerLifecycle.
+ * 
+ * Add this Valve to your host definition at conf/server.xml .
+ * 
+ * Since 5.5.10 as direct cluster valve:<br/>
+ * <pre>
+ *  &lt;Cluster&gt;
+ *  &lt;Valve className=&quot;org.apache.catalina.ha.session.JvmRouteBinderValve&quot; /&gt;  
+ *  &lt;/Cluster&gt;
+ * </pre>
+ * <br />
+ * Before 5.5.10 as Host element:<br/>
+ * <pre>
+ *  &lt;Hostr&gt;
+ *  &lt;Valve className=&quot;org.apache.catalina.ha.session.JvmRouteBinderValve&quot; /&gt;  
+ *  &lt;/Hostr&gt;
+ * </pre>
+ * 
+ * Trick:<br/>
+ * You can enable this mod_jk turnover mode via JMX before you drop a node to all backup nodes!
+ * Set enable true on all JvmRouteBinderValve backups, disable worker at mod_jk 
+ * and then drop node and restart it! Then enable mod_jk Worker and disable JvmRouteBinderValves again. 
+ * This use case means that only requested session are migrated.
+ * 
+ * @author Peter Rossbach
+ * @version $Revision$ $Date$
+ */
+public class JvmRouteBinderValve extends ValveBase implements ClusterValve, Lifecycle {
+
+    /*--Static Variables----------------------------------------*/
+    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory
+            .getLog(JvmRouteBinderValve.class);
+
+    /**
+     * The descriptive information about this implementation.
+     */
+    protected static final String info = "org.apache.catalina.ha.session.JvmRouteBinderValve/1.2";
+
+    /*--Instance Variables--------------------------------------*/
+
+    /**
+     * the cluster
+     */
+    protected CatalinaCluster cluster;
+
+    /**
+     * The string manager for this package.
+     */
+    protected StringManager sm = StringManager.getManager(Constants.Package);
+
+    /**
+     * Has this component been started yet?
+     */
+    protected boolean started = false;
+
+    /**
+     * enabled this component
+     */
+    protected boolean enabled = true;
+
+    /**
+     * number of session that no at this tomcat instanz hosted
+     */
+    protected long numberOfSessions = 0;
+
+    protected String sessionIdAttribute = "org.apache.catalina.ha.session.JvmRouteOrignalSessionID";
+
+    /**
+     * The lifecycle event support for this component.
+     */
+    protected LifecycleSupport lifecycle = new LifecycleSupport(this);
+
+    /*--Logic---------------------------------------------------*/
+
+    /**
+     * Return descriptive information about this implementation.
+     */
+    public String getInfo() {
+
+        return (info);
+
+    }
+
+    /**
+     * set session id attribute to failed node for request.
+     * 
+     * @return Returns the sessionIdAttribute.
+     */
+    public String getSessionIdAttribute() {
+        return sessionIdAttribute;
+    }
+
+    /**
+     * get name of failed reqeust session attribute
+     * 
+     * @param sessionIdAttribute
+     *            The sessionIdAttribute to set.
+     */
+    public void setSessionIdAttribute(String sessionIdAttribute) {
+        this.sessionIdAttribute = sessionIdAttribute;
+    }
+
+    /**
+     * @return Returns the number of migrated sessions.
+     */
+    public long getNumberOfSessions() {
+        return numberOfSessions;
+    }
+
+    /**
+     * @return Returns the enabled.
+     */
+    public boolean getEnabled() {
+        return enabled;
+    }
+
+    /**
+     * @param enabled
+     *            The enabled to set.
+     */
+    public void setEnabled(boolean enabled) {
+        this.enabled = enabled;
+    }
+
+    /**
+     * Detect possible the JVMRoute change at cluster backup node..
+     * 
+     * @param request
+     *            tomcat request being processed
+     * @param response
+     *            tomcat response being processed
+     * @exception IOException
+     *                if an input/output error has occurred
+     * @exception ServletException
+     *                if a servlet error has occurred
+     */
+    public void invoke(Request request, Response response) throws IOException,
+            ServletException {
+
+         if (getEnabled() 
+             && getCluster() != null
+             && request.getContext() != null
+             && request.getContext().getDistributable() ) {
+             // valve cluster can access manager - other cluster handle turnover 
+             // at host level - hopefully!
+             Manager manager = request.getContext().getManager();
+             if (manager != null && manager instanceof ClusterManager
+                     && getCluster().getManager(((ClusterManager)manager).getName()) != null)
+                 handlePossibleTurnover(request, response);
+        }
+        // Pass this request on to the next valve in our pipeline
+        getNext().invoke(request, response);
+    }
+
+    /**
+     * handle possible session turn over.
+     * 
+     * @see JvmRouteBinderValve#handleJvmRoute(Request, Response, String, String)
+     * @param request current request
+     * @param response current response
+     */
+    protected void handlePossibleTurnover(Request request, Response response) {
+        Session session = request.getSessionInternal(false);
+        if (session != null) {
+            long t1 = System.currentTimeMillis();
+            String jvmRoute = getLocalJvmRoute(request);
+            if (jvmRoute == null) {
+                if (log.isDebugEnabled())
+                    log.debug(sm.getString("jvmRoute.missingJvmRouteAttribute"));
+                return;
+            }
+            handleJvmRoute( request, response,session.getIdInternal(), jvmRoute);
+            if (log.isDebugEnabled()) {
+                long t2 = System.currentTimeMillis();
+                long time = t2 - t1;
+                log.debug(sm.getString("jvmRoute.turnoverInfo", new Long(time)));
+            }
+        }
+    }
+
+    /**
+     * get jvmroute from engine
+     * 
+     * @param request current request
+     * @return return jvmRoute from ManagerBase or null
+     */
+    protected String getLocalJvmRoute(Request request) {
+        Manager manager = getManager(request);
+        if(manager instanceof ManagerBase)
+            return ((ManagerBase) manager).getJvmRoute();
+        return null ;
+    }
+
+    /**
+     * get Cluster DeltaManager
+     * 
+     * @param request current request
+     * @return manager or null
+     */
+    protected Manager getManager(Request request) {
+        Manager manager = request.getContext().getManager();
+        if (log.isDebugEnabled()) {
+            if(manager != null)
+                log.debug(sm.getString("jvmRoute.foundManager", manager,  request.getContext().getName()));
+            else 
+                log.debug(sm.getString("jvmRoute.notFoundManager", manager,  request.getContext().getName()));
+        }
+        return manager;
+    }
+
+    /**
+     * @return Returns the cluster.
+     */
+    public CatalinaCluster getCluster() {
+        return cluster;
+    }
+    
+    /**
+     * @param cluster The cluster to set.
+     */
+    public void setCluster(CatalinaCluster cluster) {
+        this.cluster = cluster;
+    }
+    
+    /**
+     * Handle jvmRoute stickyness after tomcat instance failed. After this
+     * correction a new Cookie send to client with new jvmRoute and the
+     * SessionID change propage to the other cluster nodes.
+     * 
+     * @param request current request
+     * @param response
+     *            Tomcat Response
+     * @param sessionId
+     *            request SessionID from Cookie
+     * @param localJvmRoute
+     *            local jvmRoute
+     */
+    protected void handleJvmRoute(
+            Request request, Response response,String sessionId, String localJvmRoute) {
+        // get requested jvmRoute.
+        String requestJvmRoute = null;
+        int index = sessionId.indexOf(".");
+        if (index > 0) {
+            requestJvmRoute = sessionId
+                    .substring(index + 1, sessionId.length());
+        }
+        if (requestJvmRoute != null && !requestJvmRoute.equals(localJvmRoute)) {
+            if (log.isDebugEnabled()) {
+                log.debug(sm.getString("jvmRoute.failover", requestJvmRoute,
+                        localJvmRoute, sessionId));
+            }
+            // OK - turnover the session ?
+            String newSessionID = sessionId.substring(0, index) + "."
+                    + localJvmRoute;
+            Session catalinaSession = null;
+            try {
+                catalinaSession = getManager(request).findSession(sessionId);
+            } catch (IOException e) {
+                // Hups!
+            }
+            if (catalinaSession != null) {
+                changeSessionID(request, response, sessionId, newSessionID,
+                        catalinaSession);
+                numberOfSessions++;
+            } else {
+                if (log.isDebugEnabled()) {
+                    log.debug(sm.getString("jvmRoute.cannotFindSession",
+                            sessionId));
+                }
+            }
+        }
+    }
+
+    /**
+     * change session id and send to all cluster nodes
+     * 
+     * @param request current request
+     * @param response current response
+     * @param sessionId
+     *            original session id
+     * @param newSessionID
+     *            new session id for node migration
+     * @param catalinaSession
+     *            current session with original session id
+     */
+    protected void changeSessionID(Request request,
+            Response response, String sessionId, String newSessionID, Session catalinaSession) {
+        lifecycle.fireLifecycleEvent("Before session migration",
+                catalinaSession);
+        request.setRequestedSessionId(newSessionID);
+        catalinaSession.setId(newSessionID);
+        if (catalinaSession instanceof DeltaSession)
+            ((DeltaSession) catalinaSession).resetDeltaRequest();
+        if(request.isRequestedSessionIdFromCookie()) setNewSessionCookie(request, response,newSessionID);
+        // set orginal sessionid at request, to allow application detect the
+        // change
+        if (sessionIdAttribute != null && !"".equals(sessionIdAttribute)) {
+            if (log.isDebugEnabled()) {
+                log.debug(sm.getString("jvmRoute.set.orignalsessionid",sessionIdAttribute,sessionId));
+            }
+            request.setAttribute(sessionIdAttribute, sessionId);
+        }
+        // now sending the change to all other clusternode!
+        ClusterManager manager = (ClusterManager)catalinaSession.getManager();
+        sendSessionIDClusterBackup(manager,request,sessionId, newSessionID);
+        lifecycle
+                .fireLifecycleEvent("After session migration", catalinaSession);
+        if (log.isDebugEnabled()) {
+            log.debug(sm.getString("jvmRoute.changeSession", sessionId,
+                    newSessionID));
+        }
+    }
+
+    /**
+     * Send the changed Sessionid to all clusternodes.
+     * 
+     * @see JvmRouteSessionIDBinderListener#messageReceived(ClusterMessage)
+     * @param manager
+     *            ClusterManager
+     * @param sessionId
+     *            current failed sessionid
+     * @param newSessionID
+     *            new session id, bind to the new cluster node
+     */
+    protected void sendSessionIDClusterBackup(ClusterManager manager,Request request,String sessionId,
+            String newSessionID) {
+        SessionIDMessage msg = new SessionIDMessage();
+        msg.setOrignalSessionID(sessionId);
+        msg.setBackupSessionID(newSessionID);
+        Context context = request.getContext();
+        msg.setContextPath(context.getPath());
+        msg.setHost(context.getParent().getName());
+        if(manager.doDomainReplication())
+            cluster.sendClusterDomain(msg);
+        else
+            cluster.send(msg);
+    }
+
+    /**
+     * Sets a new cookie for the given session id and response and see
+     * {@link org.apache.catalina.connector.Request#configureSessionCookie(javax.servlet.http.Cookie)}
+     * 
+     * @param request current request
+     * @param response Tomcat Response
+     * @param sessionId The session id
+     */
+    protected void setNewSessionCookie(Request request,
+                                       Response response, String sessionId) {
+        if (response != null) {
+            Context context = request.getContext();
+            if (context.getCookies()) {
+                // set a new session cookie
+                Cookie newCookie = new Cookie(Globals.SESSION_COOKIE_NAME,
+                        sessionId);
+                newCookie.setMaxAge(-1);
+                String contextPath = null;
+                if (!response.getConnector().getEmptySessionPath()
+                        && (context != null)) {
+                    contextPath = context.getEncodedPath();
+                }
+                if ((contextPath != null) && (contextPath.length() > 0)) {
+                    newCookie.setPath(contextPath);
+                } else {
+                    newCookie.setPath("/");
+                }
+                if (request.isSecure()) {
+                    newCookie.setSecure(true);
+                }
+                if (log.isDebugEnabled()) {
+                    log.debug(sm.getString("jvmRoute.newSessionCookie",
+                            sessionId, Globals.SESSION_COOKIE_NAME, newCookie
+                                    .getPath(), new Boolean(newCookie
+                                    .getSecure())));
+                }
+                response.addCookie(newCookie);
+            }
+        }
+    }
+
+    // ------------------------------------------------------ Lifecycle Methods
+
+    /**
+     * Add a lifecycle event listener to this component.
+     * 
+     * @param listener
+     *            The listener to add
+     */
+    public void addLifecycleListener(LifecycleListener listener) {
+
+        lifecycle.addLifecycleListener(listener);
+
+    }
+
+    /**
+     * Get the lifecycle listeners associated with this lifecycle. If this
+     * Lifecycle has no listeners registered, a zero-length array is returned.
+     */
+    public LifecycleListener[] findLifecycleListeners() {
+
+        return lifecycle.findLifecycleListeners();
+
+    }
+
+    /**
+     * Remove a lifecycle event listener from this component.
+     * 
+     * @param listener
+     *            The listener to add
+     */
+    public void removeLifecycleListener(LifecycleListener listener) {
+
+        lifecycle.removeLifecycleListener(listener);
+
+    }
+
+    /**
+     * Prepare for the beginning of active use of the public methods of this
+     * component. This method should be called after <code>configure()</code>,
+     * and before any of the public methods of the component are utilized.
+     * 
+     * @exception LifecycleException
+     *                if this component detects a fatal error that prevents this
+     *                component from being used
+     */
+    public void start() throws LifecycleException {
+
+        // Validate and update our current component state
+        if (started)
+            throw new LifecycleException(sm
+                    .getString("jvmRoute.valve.alreadyStarted"));
+        lifecycle.fireLifecycleEvent(START_EVENT, null);
+        started = true;
+        if (cluster == null) {
+            Container hostContainer = getContainer();
+            // compatibility with JvmRouteBinderValve version 1.1
+            // ( setup at context.xml or context.xml.default )
+            if (!(hostContainer instanceof Host)) {
+                if (log.isWarnEnabled())
+                    log.warn(sm.getString("jvmRoute.configure.warn"));
+                hostContainer = hostContainer.getParent();
+            }
+            if (hostContainer instanceof Host
+                    && ((Host) hostContainer).getCluster() != null) {
+                cluster = (CatalinaCluster) ((Host) hostContainer).getCluster();
+            } else {
+                Container engine = hostContainer.getParent() ;
+                if (engine instanceof Engine
+                        && ((Engine) engine).getCluster() != null) {
+                    cluster = (CatalinaCluster) ((Engine) engine).getCluster();
+                }
+            }
+        }
+        if (cluster == null) {
+            throw new RuntimeException("No clustering support at container "
+                    + container.getName());
+        }
+        
+        if (log.isInfoEnabled())
+            log.info(sm.getString("jvmRoute.valve.started"));
+
+    }
+
+    /**
+     * Gracefully terminate the active use of the public methods of this
+     * component. This method should be the last one called on a given instance
+     * of this component.
+     * 
+     * @exception LifecycleException
+     *                if this component detects a fatal error that needs to be
+     *                reported
+     */
+    public void stop() throws LifecycleException {
+
+        // Validate and update our current component state
+        if (!started)
+            throw new LifecycleException(sm
+                    .getString("jvmRoute.valve.notStarted"));
+        lifecycle.fireLifecycleEvent(STOP_EVENT, null);
+        started = false;
+        cluster = null;
+        numberOfSessions = 0;
+        if (log.isInfoEnabled())
+            log.info(sm.getString("jvmRoute.valve.stopped"));
+
+    }
+
+}

==================================================
ReplicatedSession.java
index 509a136400..6157f80cb6 100644
--- a/java/org/apache/catalina/ha/session/JvmRouteSessionIDBinderListener.java
+++ b/java/org/apache/catalina/ha/session/JvmRouteSessionIDBinderListener.java
@@ -1,167 +1,167 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha.session;
-
-import java.io.IOException;
-
-import org.apache.catalina.Container;
-import org.apache.catalina.Context;
-import org.apache.catalina.Engine;
-import org.apache.catalina.LifecycleException;
-import org.apache.catalina.Session;
-import org.apache.catalina.ha.ClusterMessage;
-import org.apache.catalina.core.StandardEngine;
-import org.apache.catalina.ha.*;
-
-/**
- * Receive SessionID cluster change from other backup node after primary session
- * node is failed.
- * 
- * @author Peter Rossbach
- * @version $Revision: 378258 $ $Date: 2006-02-16 08:42:35 -0600 (Thu, 16 Feb 2006) $
- */
-public class JvmRouteSessionIDBinderListener extends ClusterListener {
- 
-    /**
-     * The descriptive information about this implementation.
-     */
-    protected static final String info = "org.apache.catalina.ha.session.JvmRouteSessionIDBinderListener/1.1";
-
-    //--Instance Variables--------------------------------------
-
-
-    protected boolean started = false;
-
-    /**
-     * number of session that goes to this cluster node
-     */
-    private long numberOfSessions = 0;
-
-    //--Constructor---------------------------------------------
-
-    public JvmRouteSessionIDBinderListener() {
-    }
-
-    //--Logic---------------------------------------------------
-
-    /**
-     * Return descriptive information about this implementation.
-     */
-    public String getInfo() {
-
-        return (info);
-
-    }
-
-    /**
-     * @return Returns the numberOfSessions.
-     */
-    public long getNumberOfSessions() {
-        return numberOfSessions;
-    }
-
-    /**
-     * Add this Mover as Cluster Listener ( receiver)
-     * 
-     * @throws LifecycleException
-     */
-    public void start() throws LifecycleException {
-        if (started)
-            return;
-        getCluster().addClusterListener(this);
-        started = true;
-        if (log.isInfoEnabled())
-            log.info(sm.getString("jvmRoute.clusterListener.started"));
-    }
-
-    /**
-     * Remove this from Cluster Listener
-     * 
-     * @throws LifecycleException
-     */
-    public void stop() throws LifecycleException {
-        started = false;
-        getCluster().removeClusterListener(this);
-        if (log.isInfoEnabled())
-            log.info(sm.getString("jvmRoute.clusterListener.stopped"));
-    }
-
-    /**
-     * Callback from the cluster, when a message is received, The cluster will
-     * broadcast it invoking the messageReceived on the receiver.
-     * 
-     * @param msg
-     *            ClusterMessage - the message received from the cluster
-     */
-    public void messageReceived(ClusterMessage msg) {
-        if (msg instanceof SessionIDMessage && msg != null) {
-            SessionIDMessage sessionmsg = (SessionIDMessage) msg;
-            if (log.isDebugEnabled())
-                log.debug(sm.getString(
-                        "jvmRoute.receiveMessage.sessionIDChanged", sessionmsg
-                                .getOrignalSessionID(), sessionmsg
-                                .getBackupSessionID(), sessionmsg
-                                .getContextPath()));
-            Container container = getCluster().getContainer();
-            Container host = null ;
-            if(container instanceof Engine) {
-                host = container.findChild(sessionmsg.getHost());
-            } else {
-                host = container ;
-            }
-            if (host != null) {
-                Context context = (Context) host.findChild(sessionmsg
-                        .getContextPath());
-                if (context != null) {
-                    try {
-                        Session session = context.getManager().findSession(
-                                sessionmsg.getOrignalSessionID());
-                        if (session != null) {
-                            session.setId(sessionmsg.getBackupSessionID());
-                        } else if (log.isInfoEnabled())
-                            log.info(sm.getString("jvmRoute.lostSession",
-                                    sessionmsg.getOrignalSessionID(),
-                                    sessionmsg.getContextPath()));
-                    } catch (IOException e) {
-                        log.error(e);
-                    }
-
-                } else if (log.isErrorEnabled())
-                    log.error(sm.getString("jvmRoute.contextNotFound",
-                            sessionmsg.getContextPath(), ((StandardEngine) host
-                                    .getParent()).getJvmRoute()));
-            } else if (log.isErrorEnabled())
-                log.error(sm.getString("jvmRoute.hostNotFound", sessionmsg.getContextPath()));
-        }
-        return;
-    }
-
-    /**
-     * Accept only SessionIDMessages
-     * 
-     * @param msg
-     *            ClusterMessage
-     * @return boolean - returns true to indicate that messageReceived should be
-     *         invoked. If false is returned, the messageReceived method will
-     *         not be invoked.
-     */
-    public boolean accept(ClusterMessage msg) {
-        return (msg instanceof SessionIDMessage);
-    }
-}
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha.session;
+
+import java.io.IOException;
+
+import org.apache.catalina.Container;
+import org.apache.catalina.Context;
+import org.apache.catalina.Engine;
+import org.apache.catalina.LifecycleException;
+import org.apache.catalina.Session;
+import org.apache.catalina.ha.ClusterMessage;
+import org.apache.catalina.core.StandardEngine;
+import org.apache.catalina.ha.*;
+
+/**
+ * Receive SessionID cluster change from other backup node after primary session
+ * node is failed.
+ * 
+ * @author Peter Rossbach
+ * @version $Revision$ $Date$
+ */
+public class JvmRouteSessionIDBinderListener extends ClusterListener {
+ 
+    /**
+     * The descriptive information about this implementation.
+     */
+    protected static final String info = "org.apache.catalina.ha.session.JvmRouteSessionIDBinderListener/1.1";
+
+    //--Instance Variables--------------------------------------
+
+
+    protected boolean started = false;
+
+    /**
+     * number of session that goes to this cluster node
+     */
+    private long numberOfSessions = 0;
+
+    //--Constructor---------------------------------------------
+
+    public JvmRouteSessionIDBinderListener() {
+    }
+
+    //--Logic---------------------------------------------------
+
+    /**
+     * Return descriptive information about this implementation.
+     */
+    public String getInfo() {
+
+        return (info);
+
+    }
+
+    /**
+     * @return Returns the numberOfSessions.
+     */
+    public long getNumberOfSessions() {
+        return numberOfSessions;
+    }
+
+    /**
+     * Add this Mover as Cluster Listener ( receiver)
+     * 
+     * @throws LifecycleException
+     */
+    public void start() throws LifecycleException {
+        if (started)
+            return;
+        getCluster().addClusterListener(this);
+        started = true;
+        if (log.isInfoEnabled())
+            log.info(sm.getString("jvmRoute.clusterListener.started"));
+    }
+
+    /**
+     * Remove this from Cluster Listener
+     * 
+     * @throws LifecycleException
+     */
+    public void stop() throws LifecycleException {
+        started = false;
+        getCluster().removeClusterListener(this);
+        if (log.isInfoEnabled())
+            log.info(sm.getString("jvmRoute.clusterListener.stopped"));
+    }
+
+    /**
+     * Callback from the cluster, when a message is received, The cluster will
+     * broadcast it invoking the messageReceived on the receiver.
+     * 
+     * @param msg
+     *            ClusterMessage - the message received from the cluster
+     */
+    public void messageReceived(ClusterMessage msg) {
+        if (msg instanceof SessionIDMessage && msg != null) {
+            SessionIDMessage sessionmsg = (SessionIDMessage) msg;
+            if (log.isDebugEnabled())
+                log.debug(sm.getString(
+                        "jvmRoute.receiveMessage.sessionIDChanged", sessionmsg
+                                .getOrignalSessionID(), sessionmsg
+                                .getBackupSessionID(), sessionmsg
+                                .getContextPath()));
+            Container container = getCluster().getContainer();
+            Container host = null ;
+            if(container instanceof Engine) {
+                host = container.findChild(sessionmsg.getHost());
+            } else {
+                host = container ;
+            }
+            if (host != null) {
+                Context context = (Context) host.findChild(sessionmsg
+                        .getContextPath());
+                if (context != null) {
+                    try {
+                        Session session = context.getManager().findSession(
+                                sessionmsg.getOrignalSessionID());
+                        if (session != null) {
+                            session.setId(sessionmsg.getBackupSessionID());
+                        } else if (log.isInfoEnabled())
+                            log.info(sm.getString("jvmRoute.lostSession",
+                                    sessionmsg.getOrignalSessionID(),
+                                    sessionmsg.getContextPath()));
+                    } catch (IOException e) {
+                        log.error(e);
+                    }
+
+                } else if (log.isErrorEnabled())
+                    log.error(sm.getString("jvmRoute.contextNotFound",
+                            sessionmsg.getContextPath(), ((StandardEngine) host
+                                    .getParent()).getJvmRoute()));
+            } else if (log.isErrorEnabled())
+                log.error(sm.getString("jvmRoute.hostNotFound", sessionmsg.getContextPath()));
+        }
+        return;
+    }
+
+    /**
+     * Accept only SessionIDMessages
+     * 
+     * @param msg
+     *            ClusterMessage
+     * @return boolean - returns true to indicate that messageReceived should be
+     *         invoked. If false is returned, the messageReceived method will
+     *         not be invoked.
+     */
+    public boolean accept(ClusterMessage msg) {
+        return (msg instanceof SessionIDMessage);
+    }
+}
+

==================================================
SerializablePrincipal.java
index 33d9ca4a98..2fe1d708f2 100644
--- a/java/org/apache/catalina/ha/session/ReplicatedSession.java
+++ b/java/org/apache/catalina/ha/session/ReplicatedSession.java
@@ -1,286 +1,286 @@
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha.session;
-
-/**
- * Title:        Tomcat Session Replication for Tomcat 4.0 <BR>
- * Description:  A very simple straight forward implementation of
- *               session replication of servers in a cluster.<BR>
- *               This session replication is implemented "live". By live
- *               I mean, when a session attribute is added into a session on Node A
- *               a message is broadcasted to other messages and setAttribute is called on the replicated
- *               sessions.<BR>
- *               A full description of this implementation can be found under
- *               <href="http://www.filip.net/tomcat/">Filip's Tomcat Page</a><BR>
- *
- * Copyright:    See apache license
- * @author  Filip Hanik
- * @version $Revision: 303842 $ $Date: 2005-04-10 11:20:46 -0500 (Sun, 10 Apr 2005) $
- * Description:<BR>
- * The ReplicatedSession class is a simple extension of the StandardSession class
- * It overrides a few methods (setAttribute, removeAttribute, expire, access) and has
- * hooks into the InMemoryReplicationManager to broadcast and receive events from the cluster.<BR>
- * This class inherits the readObjectData and writeObject data methods from the StandardSession
- * and does not contain any serializable elements in addition to the inherited ones from the StandardSession
- *
- */
-import org.apache.catalina.Manager;
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.security.Principal;
-
-public class ReplicatedSession extends org.apache.catalina.session.StandardSession
-implements org.apache.catalina.ha.ClusterSession{
-
-    private transient Manager mManager = null;
-    protected boolean isDirty = false;
-    private transient long lastAccessWasDistributed = System.currentTimeMillis();
-    private boolean isPrimarySession=true;
-    
-
-    public ReplicatedSession(Manager manager) {
-        super(manager);
-        mManager = manager;
-    }
-
-
-    public boolean isDirty()
-    {
-        return isDirty;
-    }
-
-    public void setIsDirty(boolean dirty)
-    {
-        isDirty = dirty;
-    }
-
-
-    public void setLastAccessWasDistributed(long time) {
-        lastAccessWasDistributed = time;
-    }
-
-    public long getLastAccessWasDistributed() {
-        return lastAccessWasDistributed;
-    }
-
-
-    public void removeAttribute(String name) {
-        setIsDirty(true);
-        super.removeAttribute(name);
-    }
-
-    /**
-     * see parent description,
-     * plus we also notify other nodes in the cluster
-     */
-    public void removeAttribute(String name, boolean notify) {
-        setIsDirty(true);
-        super.removeAttribute(name,notify);
-    }
-
-
-    /**
-     * Sets an attribute and notifies the other nodes in the cluster
-     */
-    public void setAttribute(String name, Object value)
-    {
-        if ( value == null ) {
-          removeAttribute(name);
-          return;
-        }
-        if (!(value instanceof java.io.Serializable))
-            throw new java.lang.IllegalArgumentException("Value for attribute "+name+" is not serializable.");
-        setIsDirty(true);
-        super.setAttribute(name,value);
-    }
-
-    public void setMaxInactiveInterval(int interval) {
-        setIsDirty(true);
-        super.setMaxInactiveInterval(interval);
-    }
-
-
-    /**
-     * Sets the manager for this session
-     * @param mgr - the servers InMemoryReplicationManager
-     */
-    public void setManager(SimpleTcpReplicationManager mgr)
-    {
-        mManager = mgr;
-        super.setManager(mgr);
-    }
-
-
-    /**
-     * Set the authenticated Principal that is associated with this Session.
-     * This provides an <code>Authenticator</code> with a means to cache a
-     * previously authenticated Principal, and avoid potentially expensive
-     * <code>Realm.authenticate()</code> calls on every request.
-     *
-     * @param principal The new Principal, or <code>null</code> if none
-     */
-    public void setPrincipal(Principal principal) {
-        super.setPrincipal(principal);
-        setIsDirty(true);
-    }
-
-    public void expire() {
-        SimpleTcpReplicationManager mgr =(SimpleTcpReplicationManager)getManager();
-        mgr.sessionInvalidated(getIdInternal());
-        setIsDirty(true);
-        super.expire();
-    }
-
-    public void invalidate() {
-        SimpleTcpReplicationManager mgr =(SimpleTcpReplicationManager)getManager();
-        mgr.sessionInvalidated(getIdInternal());
-        setIsDirty(true);
-        super.invalidate();
-    }
-
-
-    /**
-     * Read a serialized version of the contents of this session object from
-     * the specified object input stream, without requiring that the
-     * StandardSession itself have been serialized.
-     *
-     * @param stream The object input stream to read from
-     *
-     * @exception ClassNotFoundException if an unknown class is specified
-     * @exception IOException if an input/output error occurs
-     */
-    public void readObjectData(ObjectInputStream stream)
-        throws ClassNotFoundException, IOException {
-
-        super.readObjectData(stream);
-
-    }
-
-
-    /**
-     * Write a serialized version of the contents of this session object to
-     * the specified object output stream, without requiring that the
-     * StandardSession itself have been serialized.
-     *
-     * @param stream The object output stream to write to
-     *
-     * @exception IOException if an input/output error occurs
-     */
-    public void writeObjectData(ObjectOutputStream stream)
-        throws IOException {
-
-        super.writeObjectData(stream);
-
-    }
-    
-    public void setId(String id, boolean tellNew) {
-
-        if ((this.id != null) && (manager != null))
-            manager.remove(this);
-
-        this.id = id;
-
-        if (manager != null)
-            manager.add(this);
-        if (tellNew) tellNew();
-    }
-    
-    
-
-
-
-
-
-
-    /**
-     * returns true if this session is the primary session, if that is the
-     * case, the manager can expire it upon timeout.
-     */
-    public boolean isPrimarySession() {
-        return isPrimarySession;
-    }
-
-    /**
-     * Sets whether this is the primary session or not.
-     * @param primarySession Flag value
-     */
-    public void setPrimarySession(boolean primarySession) {
-        this.isPrimarySession=primarySession;
-    }
-
-
-
-
-    /**
-     * Implements a log method to log through the manager
-     */
-    protected void log(String message) {
-
-        if ((mManager != null) && (mManager instanceof SimpleTcpReplicationManager)) {
-            ((SimpleTcpReplicationManager) mManager).log.debug("ReplicatedSession: " + message);
-        } else {
-            System.out.println("ReplicatedSession: " + message);
-        }
-
-    }
-
-    protected void log(String message, Throwable x) {
-
-        if ((mManager != null) && (mManager instanceof SimpleTcpReplicationManager)) {
-            ((SimpleTcpReplicationManager) mManager).log.error("ReplicatedSession: " + message,x);
-        } else {
-            System.out.println("ReplicatedSession: " + message);
-            x.printStackTrace();
-        }
-
-    }
-
-    public String toString() {
-        StringBuffer buf = new StringBuffer("ReplicatedSession id=");
-        buf.append(getIdInternal()).append(" ref=").append(super.toString()).append("\n");
-        java.util.Enumeration e = getAttributeNames();
-        while ( e.hasMoreElements() ) {
-            String name = (String)e.nextElement();
-            Object value = getAttribute(name);
-            buf.append("\tname=").append(name).append("; value=").append(value).append("\n");
-        }
-        buf.append("\tLastAccess=").append(getLastAccessedTime()).append("\n");
-        return buf.toString();
-    }
-    public int getAccessCount() {
-        return accessCount.get();
-    }
-    public void setAccessCount(int accessCount) {
-        this.accessCount.set(accessCount);
-    }
-    public long getLastAccessedTime() {
-        return lastAccessedTime;
-    }
-    public void setLastAccessedTime(long lastAccessedTime) {
-        this.lastAccessedTime = lastAccessedTime;
-    }
-    public long getThisAccessedTime() {
-        return thisAccessedTime;
-    }
-    public void setThisAccessedTime(long thisAccessedTime) {
-        this.thisAccessedTime = thisAccessedTime;
-    }
-
-}
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha.session;
+
+/**
+ * Title:        Tomcat Session Replication for Tomcat 4.0 <BR>
+ * Description:  A very simple straight forward implementation of
+ *               session replication of servers in a cluster.<BR>
+ *               This session replication is implemented "live". By live
+ *               I mean, when a session attribute is added into a session on Node A
+ *               a message is broadcasted to other messages and setAttribute is called on the replicated
+ *               sessions.<BR>
+ *               A full description of this implementation can be found under
+ *               <href="http://www.filip.net/tomcat/">Filip's Tomcat Page</a><BR>
+ *
+ * Copyright:    See apache license
+ * @author  Filip Hanik
+ * @version $Revision$ $Date$
+ * Description:<BR>
+ * The ReplicatedSession class is a simple extension of the StandardSession class
+ * It overrides a few methods (setAttribute, removeAttribute, expire, access) and has
+ * hooks into the InMemoryReplicationManager to broadcast and receive events from the cluster.<BR>
+ * This class inherits the readObjectData and writeObject data methods from the StandardSession
+ * and does not contain any serializable elements in addition to the inherited ones from the StandardSession
+ *
+ */
+import org.apache.catalina.Manager;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.security.Principal;
+
+public class ReplicatedSession extends org.apache.catalina.session.StandardSession
+implements org.apache.catalina.ha.ClusterSession{
+
+    private transient Manager mManager = null;
+    protected boolean isDirty = false;
+    private transient long lastAccessWasDistributed = System.currentTimeMillis();
+    private boolean isPrimarySession=true;
+    
+
+    public ReplicatedSession(Manager manager) {
+        super(manager);
+        mManager = manager;
+    }
+
+
+    public boolean isDirty()
+    {
+        return isDirty;
+    }
+
+    public void setIsDirty(boolean dirty)
+    {
+        isDirty = dirty;
+    }
+
+
+    public void setLastAccessWasDistributed(long time) {
+        lastAccessWasDistributed = time;
+    }
+
+    public long getLastAccessWasDistributed() {
+        return lastAccessWasDistributed;
+    }
+
+
+    public void removeAttribute(String name) {
+        setIsDirty(true);
+        super.removeAttribute(name);
+    }
+
+    /**
+     * see parent description,
+     * plus we also notify other nodes in the cluster
+     */
+    public void removeAttribute(String name, boolean notify) {
+        setIsDirty(true);
+        super.removeAttribute(name,notify);
+    }
+
+
+    /**
+     * Sets an attribute and notifies the other nodes in the cluster
+     */
+    public void setAttribute(String name, Object value)
+    {
+        if ( value == null ) {
+          removeAttribute(name);
+          return;
+        }
+        if (!(value instanceof java.io.Serializable))
+            throw new java.lang.IllegalArgumentException("Value for attribute "+name+" is not serializable.");
+        setIsDirty(true);
+        super.setAttribute(name,value);
+    }
+
+    public void setMaxInactiveInterval(int interval) {
+        setIsDirty(true);
+        super.setMaxInactiveInterval(interval);
+    }
+
+
+    /**
+     * Sets the manager for this session
+     * @param mgr - the servers InMemoryReplicationManager
+     */
+    public void setManager(SimpleTcpReplicationManager mgr)
+    {
+        mManager = mgr;
+        super.setManager(mgr);
+    }
+
+
+    /**
+     * Set the authenticated Principal that is associated with this Session.
+     * This provides an <code>Authenticator</code> with a means to cache a
+     * previously authenticated Principal, and avoid potentially expensive
+     * <code>Realm.authenticate()</code> calls on every request.
+     *
+     * @param principal The new Principal, or <code>null</code> if none
+     */
+    public void setPrincipal(Principal principal) {
+        super.setPrincipal(principal);
+        setIsDirty(true);
+    }
+
+    public void expire() {
+        SimpleTcpReplicationManager mgr =(SimpleTcpReplicationManager)getManager();
+        mgr.sessionInvalidated(getIdInternal());
+        setIsDirty(true);
+        super.expire();
+    }
+
+    public void invalidate() {
+        SimpleTcpReplicationManager mgr =(SimpleTcpReplicationManager)getManager();
+        mgr.sessionInvalidated(getIdInternal());
+        setIsDirty(true);
+        super.invalidate();
+    }
+
+
+    /**
+     * Read a serialized version of the contents of this session object from
+     * the specified object input stream, without requiring that the
+     * StandardSession itself have been serialized.
+     *
+     * @param stream The object input stream to read from
+     *
+     * @exception ClassNotFoundException if an unknown class is specified
+     * @exception IOException if an input/output error occurs
+     */
+    public void readObjectData(ObjectInputStream stream)
+        throws ClassNotFoundException, IOException {
+
+        super.readObjectData(stream);
+
+    }
+
+
+    /**
+     * Write a serialized version of the contents of this session object to
+     * the specified object output stream, without requiring that the
+     * StandardSession itself have been serialized.
+     *
+     * @param stream The object output stream to write to
+     *
+     * @exception IOException if an input/output error occurs
+     */
+    public void writeObjectData(ObjectOutputStream stream)
+        throws IOException {
+
+        super.writeObjectData(stream);
+
+    }
+    
+    public void setId(String id, boolean tellNew) {
+
+        if ((this.id != null) && (manager != null))
+            manager.remove(this);
+
+        this.id = id;
+
+        if (manager != null)
+            manager.add(this);
+        if (tellNew) tellNew();
+    }
+    
+    
+
+
+
+
+
+
+    /**
+     * returns true if this session is the primary session, if that is the
+     * case, the manager can expire it upon timeout.
+     */
+    public boolean isPrimarySession() {
+        return isPrimarySession;
+    }
+
+    /**
+     * Sets whether this is the primary session or not.
+     * @param primarySession Flag value
+     */
+    public void setPrimarySession(boolean primarySession) {
+        this.isPrimarySession=primarySession;
+    }
+
+
+
+
+    /**
+     * Implements a log method to log through the manager
+     */
+    protected void log(String message) {
+
+        if ((mManager != null) && (mManager instanceof SimpleTcpReplicationManager)) {
+            ((SimpleTcpReplicationManager) mManager).log.debug("ReplicatedSession: " + message);
+        } else {
+            System.out.println("ReplicatedSession: " + message);
+        }
+
+    }
+
+    protected void log(String message, Throwable x) {
+
+        if ((mManager != null) && (mManager instanceof SimpleTcpReplicationManager)) {
+            ((SimpleTcpReplicationManager) mManager).log.error("ReplicatedSession: " + message,x);
+        } else {
+            System.out.println("ReplicatedSession: " + message);
+            x.printStackTrace();
+        }
+
+    }
+
+    public String toString() {
+        StringBuffer buf = new StringBuffer("ReplicatedSession id=");
+        buf.append(getIdInternal()).append(" ref=").append(super.toString()).append("\n");
+        java.util.Enumeration e = getAttributeNames();
+        while ( e.hasMoreElements() ) {
+            String name = (String)e.nextElement();
+            Object value = getAttribute(name);
+            buf.append("\tname=").append(name).append("; value=").append(value).append("\n");
+        }
+        buf.append("\tLastAccess=").append(getLastAccessedTime()).append("\n");
+        return buf.toString();
+    }
+    public int getAccessCount() {
+        return accessCount.get();
+    }
+    public void setAccessCount(int accessCount) {
+        this.accessCount.set(accessCount);
+    }
+    public long getLastAccessedTime() {
+        return lastAccessedTime;
+    }
+    public void setLastAccessedTime(long lastAccessedTime) {
+        this.lastAccessedTime = lastAccessedTime;
+    }
+    public long getThisAccessedTime() {
+        return thisAccessedTime;
+    }
+    public void setThisAccessedTime(long thisAccessedTime) {
+        this.thisAccessedTime = thisAccessedTime;
+    }
+
+}

==================================================
SessionIDMessage.java
index 7e3d223e6d..a2240f96da 100644
--- a/java/org/apache/catalina/ha/session/SerializablePrincipal.java
+++ b/java/org/apache/catalina/ha/session/SerializablePrincipal.java
@@ -1,193 +1,193 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina.ha.session;
-
-
-import java.util.Arrays;
-import java.util.List;
-import org.apache.catalina.Realm;
-
-
-/**
- * Generic implementation of <strong>java.security.Principal</strong> that
- * is available for use by <code>Realm</code> implementations.
- * The GenericPrincipal does NOT implement serializable and I didn't want to change that implementation
- * hence I implemented this one instead.
- * @author Filip Hanik
- * @version $Revision: 303587 $ $Date: 2004-12-09 08:36:43 -0600 (Thu, 09 Dec 2004) $
- */
-import org.apache.catalina.realm.GenericPrincipal;
-import java.io.ObjectInput;
-import java.io.ObjectOutput;
-public class SerializablePrincipal  implements java.io.Serializable {
-
-
-    // ----------------------------------------------------------- Constructors
-
-    public SerializablePrincipal()
-    {
-        super();
-    }
-    /**
-     * Construct a new Principal, associated with the specified Realm, for the
-     * specified username and password.
-     *
-     * @param realm The Realm that owns this Principal
-     * @param name The username of the user represented by this Principal
-     * @param password Credentials used to authenticate this user
-     */
-    public SerializablePrincipal(Realm realm, String name, String password) {
-
-        this(realm, name, password, null);
-
-    }
-
-
-    /**
-     * Construct a new Principal, associated with the specified Realm, for the
-     * specified username and password, with the specified role names
-     * (as Strings).
-     *
-     * @param realm The Realm that owns this principal
-     * @param name The username of the user represented by this Principal
-     * @param password Credentials used to authenticate this user
-     * @param roles List of roles (must be Strings) possessed by this user
-     */
-    public SerializablePrincipal(Realm realm, String name, String password,
-                            List roles) {
-
-        super();
-        this.realm = realm;
-        this.name = name;
-        this.password = password;
-        if (roles != null) {
-            this.roles = new String[roles.size()];
-            this.roles = (String[]) roles.toArray(this.roles);
-            if (this.roles.length > 0)
-                Arrays.sort(this.roles);
-        }
-
-    }
-
-
-    // ------------------------------------------------------------- Properties
-
-
-    /**
-     * The username of the user represented by this Principal.
-     */
-    protected String name = null;
-
-    public String getName() {
-        return (this.name);
-    }
-
-
-    /**
-     * The authentication credentials for the user represented by
-     * this Principal.
-     */
-    protected String password = null;
-
-    public String getPassword() {
-        return (this.password);
-    }
-
-
-    /**
-     * The Realm with which this Principal is associated.
-     */
-    protected transient Realm realm = null;
-
-    public Realm getRealm() {
-        return (this.realm);
-    }
-
-    public void setRealm(Realm realm) {
-        this.realm = realm;
-    }
-
-
-
-
-    /**
-     * The set of roles associated with this user.
-     */
-    protected String roles[] = new String[0];
-
-    public String[] getRoles() {
-        return (this.roles);
-    }
-
-
-    // --------------------------------------------------------- Public Methods
-
-
-
-
-    /**
-     * Return a String representation of this object, which exposes only
-     * information that should be public.
-     */
-    public String toString() {
-
-        StringBuffer sb = new StringBuffer("SerializablePrincipal[");
-        sb.append(this.name);
-        sb.append("]");
-        return (sb.toString());
-
-    }
-
-    public static SerializablePrincipal createPrincipal(GenericPrincipal principal)
-    {
-        if ( principal==null) return null;
-        return new SerializablePrincipal(principal.getRealm(),
-                                         principal.getName(),
-                                         principal.getPassword(),
-                                         principal.getRoles()!=null?Arrays.asList(principal.getRoles()):null);
-    }
-
-    public GenericPrincipal getPrincipal( Realm realm )
-    {
-        return new GenericPrincipal(realm,name,password,getRoles()!=null?Arrays.asList(getRoles()):null);
-    }
-    
-    public static GenericPrincipal readPrincipal(ObjectInput in, Realm realm) throws java.io.IOException{
-        String name = in.readUTF();
-        boolean hasPwd = in.readBoolean();
-        String pwd = null;
-        if ( hasPwd ) pwd = in.readUTF();
-        int size = in.readInt();
-        String[] roles = new String[size];
-        for ( int i=0; i<size; i++ ) roles[i] = in.readUTF();
-        return new GenericPrincipal(realm,name,pwd,Arrays.asList(roles));
-    }
-    
-    public static void writePrincipal(GenericPrincipal p, ObjectOutput out) throws java.io.IOException {
-        out.writeUTF(p.getName());
-        out.writeBoolean(p.getPassword()!=null);
-        if ( p.getPassword()!= null ) out.writeUTF(p.getPassword());
-        String[] roles = p.getRoles();
-        if ( roles == null ) roles = new String[0];
-        out.writeInt(roles.length);
-        for ( int i=0; i<roles.length; i++ ) out.writeUTF(roles[i]);
-    }
-
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.catalina.ha.session;
+
+
+import java.util.Arrays;
+import java.util.List;
+import org.apache.catalina.Realm;
+
+
+/**
+ * Generic implementation of <strong>java.security.Principal</strong> that
+ * is available for use by <code>Realm</code> implementations.
+ * The GenericPrincipal does NOT implement serializable and I didn't want to change that implementation
+ * hence I implemented this one instead.
+ * @author Filip Hanik
+ * @version $Revision$ $Date$
+ */
+import org.apache.catalina.realm.GenericPrincipal;
+import java.io.ObjectInput;
+import java.io.ObjectOutput;
+public class SerializablePrincipal  implements java.io.Serializable {
+
+
+    // ----------------------------------------------------------- Constructors
+
+    public SerializablePrincipal()
+    {
+        super();
+    }
+    /**
+     * Construct a new Principal, associated with the specified Realm, for the
+     * specified username and password.
+     *
+     * @param realm The Realm that owns this Principal
+     * @param name The username of the user represented by this Principal
+     * @param password Credentials used to authenticate this user
+     */
+    public SerializablePrincipal(Realm realm, String name, String password) {
+
+        this(realm, name, password, null);
+
+    }
+
+
+    /**
+     * Construct a new Principal, associated with the specified Realm, for the
+     * specified username and password, with the specified role names
+     * (as Strings).
+     *
+     * @param realm The Realm that owns this principal
+     * @param name The username of the user represented by this Principal
+     * @param password Credentials used to authenticate this user
+     * @param roles List of roles (must be Strings) possessed by this user
+     */
+    public SerializablePrincipal(Realm realm, String name, String password,
+                            List roles) {
+
+        super();
+        this.realm = realm;
+        this.name = name;
+        this.password = password;
+        if (roles != null) {
+            this.roles = new String[roles.size()];
+            this.roles = (String[]) roles.toArray(this.roles);
+            if (this.roles.length > 0)
+                Arrays.sort(this.roles);
+        }
+
+    }
+
+
+    // ------------------------------------------------------------- Properties
+
+
+    /**
+     * The username of the user represented by this Principal.
+     */
+    protected String name = null;
+
+    public String getName() {
+        return (this.name);
+    }
+
+
+    /**
+     * The authentication credentials for the user represented by
+     * this Principal.
+     */
+    protected String password = null;
+
+    public String getPassword() {
+        return (this.password);
+    }
+
+
+    /**
+     * The Realm with which this Principal is associated.
+     */
+    protected transient Realm realm = null;
+
+    public Realm getRealm() {
+        return (this.realm);
+    }
+
+    public void setRealm(Realm realm) {
+        this.realm = realm;
+    }
+
+
+
+
+    /**
+     * The set of roles associated with this user.
+     */
+    protected String roles[] = new String[0];
+
+    public String[] getRoles() {
+        return (this.roles);
+    }
+
+
+    // --------------------------------------------------------- Public Methods
+
+
+
+
+    /**
+     * Return a String representation of this object, which exposes only
+     * information that should be public.
+     */
+    public String toString() {
+
+        StringBuffer sb = new StringBuffer("SerializablePrincipal[");
+        sb.append(this.name);
+        sb.append("]");
+        return (sb.toString());
+
+    }
+
+    public static SerializablePrincipal createPrincipal(GenericPrincipal principal)
+    {
+        if ( principal==null) return null;
+        return new SerializablePrincipal(principal.getRealm(),
+                                         principal.getName(),
+                                         principal.getPassword(),
+                                         principal.getRoles()!=null?Arrays.asList(principal.getRoles()):null);
+    }
+
+    public GenericPrincipal getPrincipal( Realm realm )
+    {
+        return new GenericPrincipal(realm,name,password,getRoles()!=null?Arrays.asList(getRoles()):null);
+    }
+    
+    public static GenericPrincipal readPrincipal(ObjectInput in, Realm realm) throws java.io.IOException{
+        String name = in.readUTF();
+        boolean hasPwd = in.readBoolean();
+        String pwd = null;
+        if ( hasPwd ) pwd = in.readUTF();
+        int size = in.readInt();
+        String[] roles = new String[size];
+        for ( int i=0; i<size; i++ ) roles[i] = in.readUTF();
+        return new GenericPrincipal(realm,name,pwd,Arrays.asList(roles));
+    }
+    
+    public static void writePrincipal(GenericPrincipal p, ObjectOutput out) throws java.io.IOException {
+        out.writeUTF(p.getName());
+        out.writeBoolean(p.getPassword()!=null);
+        if ( p.getPassword()!= null ) out.writeUTF(p.getPassword());
+        String[] roles = p.getRoles();
+        if ( roles == null ) roles = new String[0];
+        out.writeInt(roles.length);
+        for ( int i=0; i<roles.length; i++ ) out.writeUTF(roles[i]);
+    }
+
+
+}

==================================================
SessionMessage.java
index e03cf5ec66..ecd3e03e7c 100644
--- a/java/org/apache/catalina/ha/session/SessionIDMessage.java
+++ b/java/org/apache/catalina/ha/session/SessionIDMessage.java
@@ -1,129 +1,129 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.ha.session;
-
-import org.apache.catalina.ha.ClusterMessage;
-import org.apache.catalina.ha.ClusterMessageBase;
-
-/**
- * Session id change cluster message
- * 
- * @author Peter Rossbach
- * 
- * @version $Revision: 326110 $ $Date: 2005-10-18 09:08:36 -0500 (Tue, 18 Oct 2005) $
- */
-public class SessionIDMessage extends ClusterMessageBase implements ClusterMessage {
-
-	private int messageNumber;
-
-	private String orignalSessionID;
-
-	private String backupSessionID;
-
-	private String host ;
-	private String contextPath;
-
-	public String getUniqueId() {
-		StringBuffer result = new StringBuffer(getOrignalSessionID());
-		result.append("#-#");
-		result.append(getHost());
-                result.append("#-#");
-                result.append(getContextPath());
-		result.append("#-#");
-		result.append(getMessageNumber());
-		result.append("#-#");
-		result.append(System.currentTimeMillis());
-		return result.toString();
-	}
-
-    /**
-     * @return Returns the host.
-     */
-    public String getHost() {
-        return host;
-    }
-
-    /**
-     * @param host The host to set.
-     */
-    public void setHost(String host) {
-        this.host = host;
-    }
-    
-	/**
-	 * @return Returns the contextPath.
-	 */
-	public String getContextPath() {
-		return contextPath;
-	}
-	/**
-	 * @param contextPath The contextPath to set.
-	 */
-	public void setContextPath(String contextPath) {
-		this.contextPath = contextPath;
-	}
-	/**
-	 * @return Returns the messageNumber.
-	 */
-	public int getMessageNumber() {
-		return messageNumber;
-	}
-
-	/**
-	 * @param messageNumber
-	 *            The messageNumber to set.
-	 */
-	public void setMessageNumber(int messageNumber) {
-		this.messageNumber = messageNumber;
-	}
-
-	
-	/**
-	 * @return Returns the backupSessionID.
-	 */
-	public String getBackupSessionID() {
-		return backupSessionID;
-	}
-
-	/**
-	 * @param backupSessionID
-	 *            The backupSessionID to set.
-	 */
-	public void setBackupSessionID(String backupSessionID) {
-		this.backupSessionID = backupSessionID;
-	}
-
-	/**
-	 * @return Returns the orignalSessionID.
-	 */
-	public String getOrignalSessionID() {
-		return orignalSessionID;
-	}
-
-	/**
-	 * @param orignalSessionID
-	 *            The orignalSessionID to set.
-	 */
-	public void setOrignalSessionID(String orignalSessionID) {
-		this.orignalSessionID = orignalSessionID;
-	}
-
-    
-
-
-}
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.ha.session;
+
+import org.apache.catalina.ha.ClusterMessage;
+import org.apache.catalina.ha.ClusterMessageBase;
+
+/**
+ * Session id change cluster message
+ * 
+ * @author Peter Rossbach
+ * 
+ * @version $Revision$ $Date$
+ */
+public class SessionIDMessage extends ClusterMessageBase implements ClusterMessage {
+
+	private int messageNumber;
+
+	private String orignalSessionID;
+
+	private String backupSessionID;
+
+	private String host ;
+	private String contextPath;
+
+	public String getUniqueId() {
+		StringBuffer result = new StringBuffer(getOrignalSessionID());
+		result.append("#-#");
+		result.append(getHost());
+                result.append("#-#");
+                result.append(getContextPath());
+		result.append("#-#");
+		result.append(getMessageNumber());
+		result.append("#-#");
+		result.append(System.currentTimeMillis());
+		return result.toString();
+	}
+
+    /**
+     * @return Returns the host.
+     */
+    public String getHost() {
+        return host;
+    }
+
+    /**
+     * @param host The host to set.
+     */
+    public void setHost(String host) {
+        this.host = host;
+    }
+    
+	/**
+	 * @return Returns the contextPath.
+	 */
+	public String getContextPath() {
+		return contextPath;
+	}
+	/**
+	 * @param contextPath The contextPath to set.
+	 */
+	public void setContextPath(String contextPath) {
+		this.contextPath = contextPath;
+	}
+	/**
+	 * @return Returns the messageNumber.
+	 */
+	public int getMessageNumber() {
+		return messageNumber;
+	}
+
+	/**
+	 * @param messageNumber
+	 *            The messageNumber to set.
+	 */
+	public void setMessageNumber(int messageNumber) {
+		this.messageNumber = messageNumber;
+	}
+
+	
+	/**
+	 * @return Returns the backupSessionID.
+	 */
+	public String getBackupSessionID() {
+		return backupSessionID;
+	}
+
+	/**
+	 * @param backupSessionID
+	 *            The backupSessionID to set.
+	 */
+	public void setBackupSessionID(String backupSessionID) {
+		this.backupSessionID = backupSessionID;
+	}
+
+	/**
+	 * @return Returns the orignalSessionID.
+	 */
+	public String getOrignalSessionID() {
+		return orignalSessionID;
+	}
+
+	/**
+	 * @param orignalSessionID
+	 *            The orignalSessionID to set.
+	 */
+	public void setOrignalSessionID(String orignalSessionID) {
+		this.orignalSessionID = orignalSessionID;
+	}
+
+    
+
+
+}
+

==================================================
SessionMessageImpl.java
index ab28acf283..3408657291 100644
--- a/java/org/apache/catalina/ha/session/SessionMessage.java
+++ b/java/org/apache/catalina/ha/session/SessionMessage.java
@@ -1,104 +1,104 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.ha.session;
-import org.apache.catalina.ha.ClusterMessage;
-
-/**
- *
- * <B>Class Description:</B><BR>
- * The SessionMessage class is a class that is used when a session has been
- * created, modified, expired in a Tomcat cluster node.<BR>
- *
- * The following events are currently available:
- * <ul>
- *   <li><pre>public static final int EVT_SESSION_CREATED</pre><li>
- *   <li><pre>public static final int EVT_SESSION_ACCESSED</pre><li>
- *   <li><pre>public static final int EVT_ATTRIBUTE_ADDED</pre><li>
- *   <li><pre>public static final int EVT_ATTRIBUTE_REMOVED</pre><li>
- *   <li><pre>public static final int EVT_SESSION_EXPIRED_WONOTIFY</pre><li>
- *   <li><pre>public static final int EVT_SESSION_EXPIRED_WNOTIFY</pre><li>
- *   <li><pre>public static final int EVT_GET_ALL_SESSIONS</pre><li>
- *   <li><pre>public static final int EVT_SET_USER_PRINCIPAL</pre><li>
- *   <li><pre>public static final int EVT_SET_SESSION_NOTE</pre><li>
- *   <li><pre>public static final int EVT_REMOVE_SESSION_NOTE</pre><li>
- * </ul>
- *
- */
-
-public interface SessionMessage extends ClusterMessage, java.io.Serializable
-{
-
-    /**
-     * Event type used when a session has been created on a node
-     */
-    public static final int EVT_SESSION_CREATED = 1;
-    /**
-     * Event type used when a session has expired
-     */
-    public static final int EVT_SESSION_EXPIRED = 2;
-
-    /**
-     * Event type used when a session has been accessed (ie, last access time
-     * has been updated. This is used so that the replicated sessions will not expire
-     * on the network
-     */
-    public static final int EVT_SESSION_ACCESSED = 3;
-    /**
-     * Event type used when a server comes online for the first time.
-     * The first thing the newly started server wants to do is to grab the
-     * all the sessions from one of the nodes and keep the same state in there
-     */
-    public static final int EVT_GET_ALL_SESSIONS = 4;
-    /**
-     * Event type used when an attribute has been added to a session,
-     * the attribute will be sent to all the other nodes in the cluster
-     */
-    public static final int EVT_SESSION_DELTA  = 13;
-
-    /**
-     * When a session state is transferred, this is the event.
-     */
-    public static final int EVT_ALL_SESSION_DATA = 12;
-    
-    /**
-     * When a session state is complete transferred, this is the event.
-     */
-    public static final int EVT_ALL_SESSION_TRANSFERCOMPLETE = 14;
-    
-
-    
-    public String getContextName();
-    
-    public String getEventTypeString();
-    
-    /**
-     * returns the event type
-     * @return one of the event types EVT_XXXX
-     */
-    public int getEventType(); 
-    /**
-     * @return the serialized data for the session
-     */
-    public byte[] getSession();
-    /**
-     * @return the session ID for the session
-     */
-    public String getSessionID();
-    
-
-
-}//SessionMessage
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.ha.session;
+import org.apache.catalina.ha.ClusterMessage;
+
+/**
+ *
+ * <B>Class Description:</B><BR>
+ * The SessionMessage class is a class that is used when a session has been
+ * created, modified, expired in a Tomcat cluster node.<BR>
+ *
+ * The following events are currently available:
+ * <ul>
+ *   <li><pre>public static final int EVT_SESSION_CREATED</pre><li>
+ *   <li><pre>public static final int EVT_SESSION_ACCESSED</pre><li>
+ *   <li><pre>public static final int EVT_ATTRIBUTE_ADDED</pre><li>
+ *   <li><pre>public static final int EVT_ATTRIBUTE_REMOVED</pre><li>
+ *   <li><pre>public static final int EVT_SESSION_EXPIRED_WONOTIFY</pre><li>
+ *   <li><pre>public static final int EVT_SESSION_EXPIRED_WNOTIFY</pre><li>
+ *   <li><pre>public static final int EVT_GET_ALL_SESSIONS</pre><li>
+ *   <li><pre>public static final int EVT_SET_USER_PRINCIPAL</pre><li>
+ *   <li><pre>public static final int EVT_SET_SESSION_NOTE</pre><li>
+ *   <li><pre>public static final int EVT_REMOVE_SESSION_NOTE</pre><li>
+ * </ul>
+ *
+ */
+
+public interface SessionMessage extends ClusterMessage, java.io.Serializable
+{
+
+    /**
+     * Event type used when a session has been created on a node
+     */
+    public static final int EVT_SESSION_CREATED = 1;
+    /**
+     * Event type used when a session has expired
+     */
+    public static final int EVT_SESSION_EXPIRED = 2;
+
+    /**
+     * Event type used when a session has been accessed (ie, last access time
+     * has been updated. This is used so that the replicated sessions will not expire
+     * on the network
+     */
+    public static final int EVT_SESSION_ACCESSED = 3;
+    /**
+     * Event type used when a server comes online for the first time.
+     * The first thing the newly started server wants to do is to grab the
+     * all the sessions from one of the nodes and keep the same state in there
+     */
+    public static final int EVT_GET_ALL_SESSIONS = 4;
+    /**
+     * Event type used when an attribute has been added to a session,
+     * the attribute will be sent to all the other nodes in the cluster
+     */
+    public static final int EVT_SESSION_DELTA  = 13;
+
+    /**
+     * When a session state is transferred, this is the event.
+     */
+    public static final int EVT_ALL_SESSION_DATA = 12;
+    
+    /**
+     * When a session state is complete transferred, this is the event.
+     */
+    public static final int EVT_ALL_SESSION_TRANSFERCOMPLETE = 14;
+    
+
+    
+    public String getContextName();
+    
+    public String getEventTypeString();
+    
+    /**
+     * returns the event type
+     * @return one of the event types EVT_XXXX
+     */
+    public int getEventType(); 
+    /**
+     * @return the serialized data for the session
+     */
+    public byte[] getSession();
+    /**
+     * @return the session ID for the session
+     */
+    public String getSessionID();
+    
+
+
+}//SessionMessage

==================================================
SimpleTcpReplicationManager.java
index 137a9e199a..cf89664485 100644
--- a/java/org/apache/catalina/ha/session/SessionMessageImpl.java
+++ b/java/org/apache/catalina/ha/session/SessionMessageImpl.java
@@ -1,158 +1,158 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.ha.session;
-
-
-import org.apache.catalina.ha.ClusterMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.ha.ClusterMessageBase;
-
-/**
- * Session cluster message
- * 
- * @author Filip Hanik
- * @author Peter Rossbach
- * 
- * @version $Revision: 326110 $ $Date: 2005-10-18 09:08:36 -0500 (Tue, 18 Oct 2005) $
- */
-public class SessionMessageImpl extends ClusterMessageBase implements SessionMessage, java.io.Serializable {
-    
-    public SessionMessageImpl() {
-    }
-    
-    
-    /*
-
-     * Private serializable variables to keep the messages state
-     */
-    private int mEvtType = -1;
-    private byte[] mSession;
-    private String mSessionID;
-
-    private String mContextName;
-    private long serializationTimestamp;
-    private boolean timestampSet = false ;
-    private String uniqueId;
-
-
-    private SessionMessageImpl( String contextName,
-                           int eventtype,
-                           byte[] session,
-                           String sessionID)
-    {
-        mEvtType = eventtype;
-        mSession = session;
-        mSessionID = sessionID;
-        mContextName = contextName;
-        uniqueId = sessionID;
-    }
-
-    /**
-     * Creates a session message. Depending on what event type you want this
-     * message to represent, you populate the different parameters in the constructor<BR>
-      * The following rules apply dependent on what event type argument you use:<BR>
-     * <B>EVT_SESSION_CREATED</B><BR>
-     *    The parameters: session, sessionID must be set.<BR>
-     * <B>EVT_SESSION_EXPIRED</B><BR>
-     *    The parameters: sessionID must be set.<BR>
-     * <B>EVT_SESSION_ACCESSED</B><BR>
-     *    The parameters: sessionID must be set.<BR>
-     * <B>EVT_SESSION_EXPIRED_XXXX</B><BR>
-     *    The parameters: sessionID must be set.<BR>
-     * <B>EVT_SESSION_DELTA</B><BR>
-     *    Send attribute delta (add,update,remove attribute or principal, ...).<BR>
-     * <B>EVT_ALL_SESSION_DATA</B><BR>
-     *    Send complete serializes session list<BR>
-     * <B>EVT_ALL_SESSION_TRANSFERCOMPLETE</B><BR>
-     *    send that all session state information are transfered
-     *    after GET_ALL_SESSION received from this sender.<BR>
-     * @param contextName - the name of the context (application
-     * @param eventtype - one of the 8 event type defined in this class
-     * @param session - the serialized byte array of the session itself
-     * @param sessionID - the id that identifies this session
-     * @param uniqueID - the id that identifies this message
-     */
-    public SessionMessageImpl( String contextName,
-                           int eventtype,
-                           byte[] session,
-                           String sessionID,
-                           String uniqueID)
-    {
-        this(contextName,eventtype,session,sessionID);
-        uniqueId = uniqueID;
-    }
-
-    /**
-     * returns the event type
-     * @return one of the event types EVT_XXXX
-     */
-    public int getEventType() { return mEvtType; }
-
-    /**
-     * @return the serialized data for the session
-     */
-    public byte[] getSession() { return mSession;}
-
-    /**
-     * @return the session ID for the session
-     */
-    public String getSessionID(){ return mSessionID; }
-    
-    /**
-     * set message send time but only the first setting works (one shot)
-     */
-    public void setTimestamp(long time) {
-        synchronized(this) {
-            if(!timestampSet) {
-                serializationTimestamp=time;
-                timestampSet = true ;
-            }
-        }
-    }
-    
-    public long getTimestamp() { return serializationTimestamp;}
-    
-    /**
-     * clear text event type name (for logging purpose only) 
-     * @return the event type in a string representating, useful for debugging
-     */
-    public String getEventTypeString()
-    {
-        switch (mEvtType)
-        {
-            case EVT_SESSION_CREATED : return "SESSION-MODIFIED";
-            case EVT_SESSION_EXPIRED : return "SESSION-EXPIRED";
-            case EVT_SESSION_ACCESSED : return "SESSION-ACCESSED";
-            case EVT_GET_ALL_SESSIONS : return "SESSION-GET-ALL";
-            case EVT_SESSION_DELTA : return "SESSION-DELTA";
-            case EVT_ALL_SESSION_DATA : return "ALL-SESSION-DATA";
-            case EVT_ALL_SESSION_TRANSFERCOMPLETE : return "SESSION-STATE-TRANSFERED";
-            default : return "UNKNOWN-EVENT-TYPE";
-        }
-    }
-
-    public String getContextName() {
-       return mContextName;
-    }
-    public String getUniqueId() {
-        return uniqueId;
-    }
-    public void setUniqueId(String uniqueId) {
-        this.uniqueId = uniqueId;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.ha.session;
+
+
+import org.apache.catalina.ha.ClusterMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.ha.ClusterMessageBase;
+
+/**
+ * Session cluster message
+ * 
+ * @author Filip Hanik
+ * @author Peter Rossbach
+ * 
+ * @version $Revision$ $Date$
+ */
+public class SessionMessageImpl extends ClusterMessageBase implements SessionMessage, java.io.Serializable {
+    
+    public SessionMessageImpl() {
+    }
+    
+    
+    /*
+
+     * Private serializable variables to keep the messages state
+     */
+    private int mEvtType = -1;
+    private byte[] mSession;
+    private String mSessionID;
+
+    private String mContextName;
+    private long serializationTimestamp;
+    private boolean timestampSet = false ;
+    private String uniqueId;
+
+
+    private SessionMessageImpl( String contextName,
+                           int eventtype,
+                           byte[] session,
+                           String sessionID)
+    {
+        mEvtType = eventtype;
+        mSession = session;
+        mSessionID = sessionID;
+        mContextName = contextName;
+        uniqueId = sessionID;
+    }
+
+    /**
+     * Creates a session message. Depending on what event type you want this
+     * message to represent, you populate the different parameters in the constructor<BR>
+      * The following rules apply dependent on what event type argument you use:<BR>
+     * <B>EVT_SESSION_CREATED</B><BR>
+     *    The parameters: session, sessionID must be set.<BR>
+     * <B>EVT_SESSION_EXPIRED</B><BR>
+     *    The parameters: sessionID must be set.<BR>
+     * <B>EVT_SESSION_ACCESSED</B><BR>
+     *    The parameters: sessionID must be set.<BR>
+     * <B>EVT_SESSION_EXPIRED_XXXX</B><BR>
+     *    The parameters: sessionID must be set.<BR>
+     * <B>EVT_SESSION_DELTA</B><BR>
+     *    Send attribute delta (add,update,remove attribute or principal, ...).<BR>
+     * <B>EVT_ALL_SESSION_DATA</B><BR>
+     *    Send complete serializes session list<BR>
+     * <B>EVT_ALL_SESSION_TRANSFERCOMPLETE</B><BR>
+     *    send that all session state information are transfered
+     *    after GET_ALL_SESSION received from this sender.<BR>
+     * @param contextName - the name of the context (application
+     * @param eventtype - one of the 8 event type defined in this class
+     * @param session - the serialized byte array of the session itself
+     * @param sessionID - the id that identifies this session
+     * @param uniqueID - the id that identifies this message
+     */
+    public SessionMessageImpl( String contextName,
+                           int eventtype,
+                           byte[] session,
+                           String sessionID,
+                           String uniqueID)
+    {
+        this(contextName,eventtype,session,sessionID);
+        uniqueId = uniqueID;
+    }
+
+    /**
+     * returns the event type
+     * @return one of the event types EVT_XXXX
+     */
+    public int getEventType() { return mEvtType; }
+
+    /**
+     * @return the serialized data for the session
+     */
+    public byte[] getSession() { return mSession;}
+
+    /**
+     * @return the session ID for the session
+     */
+    public String getSessionID(){ return mSessionID; }
+    
+    /**
+     * set message send time but only the first setting works (one shot)
+     */
+    public void setTimestamp(long time) {
+        synchronized(this) {
+            if(!timestampSet) {
+                serializationTimestamp=time;
+                timestampSet = true ;
+            }
+        }
+    }
+    
+    public long getTimestamp() { return serializationTimestamp;}
+    
+    /**
+     * clear text event type name (for logging purpose only) 
+     * @return the event type in a string representating, useful for debugging
+     */
+    public String getEventTypeString()
+    {
+        switch (mEvtType)
+        {
+            case EVT_SESSION_CREATED : return "SESSION-MODIFIED";
+            case EVT_SESSION_EXPIRED : return "SESSION-EXPIRED";
+            case EVT_SESSION_ACCESSED : return "SESSION-ACCESSED";
+            case EVT_GET_ALL_SESSIONS : return "SESSION-GET-ALL";
+            case EVT_SESSION_DELTA : return "SESSION-DELTA";
+            case EVT_ALL_SESSION_DATA : return "ALL-SESSION-DATA";
+            case EVT_ALL_SESSION_TRANSFERCOMPLETE : return "SESSION-STATE-TRANSFERED";
+            default : return "UNKNOWN-EVENT-TYPE";
+        }
+    }
+
+    public String getContextName() {
+       return mContextName;
+    }
+    public String getUniqueId() {
+        return uniqueId;
+    }
+    public void setUniqueId(String uniqueId) {
+        this.uniqueId = uniqueId;
+    }
+
+}

==================================================
Constants.java
index b4e89cd982..2360d66e03 100644
--- a/java/org/apache/catalina/ha/session/SimpleTcpReplicationManager.java
+++ b/java/org/apache/catalina/ha/session/SimpleTcpReplicationManager.java
@@ -1,685 +1,685 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.ha.session;
-
-import java.io.IOException;
-
-import org.apache.catalina.LifecycleException;
-import org.apache.catalina.Session;
-import org.apache.catalina.ha.CatalinaCluster;
-import org.apache.catalina.ha.ClusterManager;
-import org.apache.catalina.ha.ClusterMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.realm.GenericPrincipal;
-import org.apache.catalina.session.StandardManager;
-import org.apache.catalina.tribes.io.ReplicationStream;
-import java.io.ByteArrayInputStream;
-import org.apache.catalina.Loader;
-
-/**
- * Title:        Tomcat Session Replication for Tomcat 4.0 <BR>
- * Description:  A very simple straight forward implementation of
- *               session replication of servers in a cluster.<BR>
- *               This session replication is implemented "live". By live
- *               I mean, when a session attribute is added into a session on Node A
- *               a message is broadcasted to other messages and setAttribute is called on the
- *               replicated sessions.<BR>
- *               A full description of this implementation can be found under
- *               <href="http://www.filip.net/tomcat/">Filip's Tomcat Page</a><BR>
- *
- * Copyright:    See apache license
- * Company:      www.filip.net
- * @author  <a href="mailto:mail@filip.net">Filip Hanik</a>
- * @author Bela Ban (modifications for synchronous replication)
- * @version 1.0 for TC 4.0
- * Description: The InMemoryReplicationManager is a session manager that replicated
- * session information in memory. 
- * <BR><BR>
- * The InMemoryReplicationManager extends the StandardManager hence it allows for us
- * to inherit all the basic session management features like expiration, session listeners etc
- * <BR><BR>
- * To communicate with other nodes in the cluster, the InMemoryReplicationManager sends out 7 different type of multicast messages
- * all defined in the SessionMessage class.<BR>
- * When a session is replicated (not an attribute added/removed) the session is serialized into
- * a byte array using the StandardSession.readObjectData, StandardSession.writeObjectData methods.
- */
-public class SimpleTcpReplicationManager extends StandardManager implements ClusterManager
-{
-    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( SimpleTcpReplicationManager.class );
-
-    //the channel configuration
-    protected String mChannelConfig = null;
-
-    //the group name
-    protected String mGroupName = "TomcatReplication";
-
-    //somehow start() gets called more than once
-    protected boolean mChannelStarted = false;
-
-    //log to screen
-    protected boolean mPrintToScreen = true;
-
-    protected boolean defaultMode = false;
-
-    protected boolean mManagerRunning = false;
-
-    /** Use synchronous rather than asynchronous replication. Every session modification (creation, change, removal etc)
-     * will be sent to all members. The call will then wait for max milliseconds, or forever (if timeout is 0) for
-     * all responses.
-     */
-    protected boolean synchronousReplication=true;
-
-    /** Set to true if we don't want the sessions to expire on shutdown */
-    protected boolean mExpireSessionsOnShutdown = true;
-
-    protected boolean useDirtyFlag = false;
-
-    protected String name;
-
-    protected boolean distributable = true;
-
-    protected CatalinaCluster cluster;
-
-    protected java.util.HashMap invalidatedSessions = new java.util.HashMap();
-
-    /**
-     * Flag to keep track if the state has been transferred or not
-     * Assumes false.
-     */
-    protected boolean stateTransferred = false;
-    private boolean notifyListenersOnReplication;
-    private boolean sendClusterDomainOnly = true ;
-
-    /**
-     * Constructor, just calls super()
-     *
-     */
-    public SimpleTcpReplicationManager()
-    {
-        super();
-    }
-
-    public boolean doDomainReplication() {
-        return sendClusterDomainOnly;
-    }
-    
-    /**
-     * @param sendClusterDomainOnly The sendClusterDomainOnly to set.
-     */
-    public void setDomainReplication(boolean sendClusterDomainOnly) {
-        this.sendClusterDomainOnly = sendClusterDomainOnly;
-    }
-  
-    /**
-     * @return Returns the defaultMode.
-     */
-    public boolean isDefaultMode() {
-        return defaultMode;
-    }
-    /**
-     * @param defaultMode The defaultMode to set.
-     */
-    public void setDefaultMode(boolean defaultMode) {
-        this.defaultMode = defaultMode;
-    }
-    
-    public boolean isManagerRunning()
-    {
-        return mManagerRunning;
-    }
-
-    public void setUseDirtyFlag(boolean usedirtyflag)
-    {
-        this.useDirtyFlag = usedirtyflag;
-    }
-
-    public void setExpireSessionsOnShutdown(boolean expireSessionsOnShutdown)
-    {
-        mExpireSessionsOnShutdown = expireSessionsOnShutdown;
-    }
-
-    public void setCluster(CatalinaCluster cluster) {
-        if(log.isDebugEnabled())
-            log.debug("Cluster associated with SimpleTcpReplicationManager");
-        this.cluster = cluster;
-    }
-
-    public boolean getExpireSessionsOnShutdown()
-    {
-        return mExpireSessionsOnShutdown;
-    }
-
-    public void setPrintToScreen(boolean printtoscreen)
-    {
-        if(log.isDebugEnabled())
-            log.debug("Setting screen debug to:"+printtoscreen);
-        mPrintToScreen = printtoscreen;
-    }
-
-    public void setSynchronousReplication(boolean flag)
-    {
-        synchronousReplication=flag;
-    }
-
-    /**
-     * Override persistence since they don't go hand in hand with replication for now.
-     */
-    public void unload() throws IOException {
-        if ( !getDistributable() ) {
-            super.unload();
-        }
-    }
-
-    /**
-     * Creates a HTTP session.
-     * Most of the code in here is copied from the StandardManager.
-     * This is not pretty, yeah I know, but it was necessary since the
-     * StandardManager had hard coded the session instantiation to the a
-     * StandardSession, when we actually want to instantiate a ReplicatedSession<BR>
-     * If the call comes from the Tomcat servlet engine, a SessionMessage goes out to the other
-     * nodes in the cluster that this session has been created.
-     * @param notify - if set to true the other nodes in the cluster will be notified.
-     *                 This flag is needed so that we can create a session before we deserialize
-     *                 a replicated one
-     *
-     * @see ReplicatedSession
-     */
-    protected Session createSession(String sessionId, boolean notify, boolean setId)
-    {
-
-        //inherited from the basic manager
-        if ((getMaxActiveSessions() >= 0) &&
-           (sessions.size() >= getMaxActiveSessions()))
-            throw new IllegalStateException(sm.getString("standardManager.createSession.ise"));
-
-
-        Session session = new ReplicatedSession(this);
-
-        // Initialize the properties of the new session and return it
-        session.setNew(true);
-        session.setValid(true);
-        session.setCreationTime(System.currentTimeMillis());
-        session.setMaxInactiveInterval(this.maxInactiveInterval);
-        if(sessionId == null)
-            sessionId = generateSessionId();
-        if ( setId ) session.setId(sessionId);
-        if ( notify && (cluster!=null) ) {
-            ((ReplicatedSession)session).setIsDirty(true);
-        }
-        return (session);
-    }//createSession
-
-    //=========================================================================
-    // OVERRIDE THESE METHODS TO IMPLEMENT THE REPLICATION
-    //=========================================================================
-
-    /**
-     * Construct and return a new session object, based on the default
-     * settings specified by this Manager's properties.  The session
-     * id will be assigned by this method, and available via the getId()
-     * method of the returned session.  If a new session cannot be created
-     * for any reason, return <code>null</code>.
-     *
-     * @exception IllegalStateException if a new session cannot be
-     *  instantiated for any reason
-     */
-    public Session createSession(String sessionId)
-    {
-        //create a session and notify the other nodes in the cluster
-        Session session =  createSession(sessionId,getDistributable(),true);
-        add(session);
-        return session;
-    }
-
-    public void sessionInvalidated(String sessionId) {
-        synchronized ( invalidatedSessions ) {
-            invalidatedSessions.put(sessionId, sessionId);
-        }
-    }
-
-    public String[] getInvalidatedSessions() {
-        synchronized ( invalidatedSessions ) {
-            String[] result = new String[invalidatedSessions.size()];
-            invalidatedSessions.values().toArray(result);
-            return result;
-        }
-
-    }
-
-    public ClusterMessage requestCompleted(String sessionId)
-    {
-        if (  !getDistributable() ) {
-            log.warn("Received requestCompleted message, although this context["+
-                     getName()+"] is not distributable. Ignoring message");
-            return null;
-        }
-        try
-        {
-            if ( invalidatedSessions.get(sessionId) != null ) {
-                synchronized ( invalidatedSessions ) {
-                    invalidatedSessions.remove(sessionId);
-                    SessionMessage msg = new SessionMessageImpl(name,
-                    SessionMessage.EVT_SESSION_EXPIRED,
-                    null,
-                    sessionId,
-                    sessionId);
-                return msg;
-                }
-            } else {
-                ReplicatedSession session = (ReplicatedSession) findSession(
-                    sessionId);
-                if (session != null) {
-                    //return immediately if the session is not dirty
-                    if (useDirtyFlag && (!session.isDirty())) {
-                        //but before we return doing nothing,
-                        //see if we should send
-                        //an updated last access message so that
-                        //sessions across cluster dont expire
-                        long interval = session.getMaxInactiveInterval();
-                        long lastaccdist = System.currentTimeMillis() -
-                            session.getLastAccessWasDistributed();
-                        if ( ((interval*1000) / lastaccdist)< 3 ) {
-                            SessionMessage accmsg = new SessionMessageImpl(name,
-                                SessionMessage.EVT_SESSION_ACCESSED,
-                                null,
-                                sessionId,
-                                sessionId);
-                            session.setLastAccessWasDistributed(System.currentTimeMillis());
-                            return accmsg;
-                        }
-                        return null;
-                    }
-
-                    session.setIsDirty(false);
-                    if (log.isDebugEnabled()) {
-                        try {
-                            log.debug("Sending session to cluster=" + session);
-                        }
-                        catch (Exception ignore) {}
-                    }
-                    SessionMessage msg = new SessionMessageImpl(name,
-                        SessionMessage.EVT_SESSION_CREATED,
-                        writeSession(session),
-                        session.getIdInternal(),
-                        session.getIdInternal());
-                    return msg;
-                } //end if
-            }//end if
-        }
-        catch (Exception x )
-        {
-            log.error("Unable to replicate session",x);
-        }
-        return null;
-    }
-
-    /**
-     * Serialize a session into a byte array<BR>
-     * This method simple calls the writeObjectData method on the session
-     * and returns the byte data from that call
-     * @param session - the session to be serialized
-     * @return a byte array containing the session data, null if the serialization failed
-     */
-    protected byte[] writeSession( Session session )
-    {
-        try
-        {
-            java.io.ByteArrayOutputStream session_data = new java.io.ByteArrayOutputStream();
-            java.io.ObjectOutputStream session_out = new java.io.ObjectOutputStream(session_data);
-            session_out.flush();
-            boolean hasPrincipal = session.getPrincipal() != null;
-            session_out.writeBoolean(hasPrincipal);
-            if ( hasPrincipal )
-            {
-                session_out.writeObject(SerializablePrincipal.createPrincipal((GenericPrincipal)session.getPrincipal()));
-            }//end if
-            ((ReplicatedSession)session).writeObjectData(session_out);
-            return session_data.toByteArray();
-
-        }
-        catch ( Exception x )
-        {
-            log.error("Failed to serialize the session!",x);
-        }
-        return null;
-    }
-    
-    /**
-     * Open Stream and use correct ClassLoader (Container) Switch
-     * ThreadClassLoader
-     * 
-     * @param data
-     * @return The object input stream
-     * @throws IOException
-     */
-    public ReplicationStream getReplicationStream(byte[] data) throws IOException {
-        return getReplicationStream(data,0,data.length);
-    }
-    
-    public ReplicationStream getReplicationStream(byte[] data, int offset, int length) throws IOException {
-        ByteArrayInputStream fis =null;
-        ReplicationStream ois = null;
-        Loader loader = null;
-        ClassLoader classLoader = null;
-        //fix to be able to run the DeltaManager
-        //stand alone without a container.
-        //use the Threads context class loader
-        if (container != null)
-            loader = container.getLoader();
-        if (loader != null)
-            classLoader = loader.getClassLoader();
-        else
-            classLoader = Thread.currentThread().getContextClassLoader();
-        //end fix
-        fis = new ByteArrayInputStream(data, offset, length);
-        if ( classLoader == Thread.currentThread().getContextClassLoader() ) {
-            ois = new ReplicationStream(fis, new ClassLoader[] {classLoader});
-        } else {
-            ois = new ReplicationStream(fis, new ClassLoader[] {classLoader,Thread.currentThread().getContextClassLoader()});
-        }
-        return ois;
-    }    
-
-
-    
-
-    /**
-     * Reinstantiates a serialized session from the data passed in.
-     * This will first call createSession() so that we get a fresh instance with all
-     * the managers set and all the transient fields validated.
-     * Then it calls Session.readObjectData(byte[]) to deserialize the object
-     * @param data - a byte array containing session data
-     * @return a valid Session object, null if an error occurs
-     *
-     */
-    protected Session readSession( byte[] data, String sessionId )
-    {
-        try
-        {
-            ReplicationStream session_in = getReplicationStream(data);
-
-            Session session = sessionId!=null?this.findSession(sessionId):null;
-            boolean isNew = (session==null);
-            //clear the old values from the existing session
-            if ( session!=null ) {
-                ReplicatedSession rs = (ReplicatedSession)session;
-                rs.expire(false);  //cleans up the previous values, since we are not doing removes
-                session = null;
-            }//end if
-
-            if (session==null) {
-                session = createSession(null,false, false);
-                sessions.remove(session.getIdInternal());
-            }
-            
-            
-            boolean hasPrincipal = session_in.readBoolean();
-            SerializablePrincipal p = null;
-            if ( hasPrincipal )
-                p = (SerializablePrincipal)session_in.readObject();
-            ((ReplicatedSession)session).readObjectData(session_in);
-            if ( hasPrincipal )
-                session.setPrincipal(p.getPrincipal(getContainer().getRealm()));
-            ((ReplicatedSession)session).setId(sessionId,isNew);
-            ReplicatedSession rsession = (ReplicatedSession)session; 
-            rsession.setAccessCount(1);
-            session.setManager(this);
-            session.setValid(true);
-            rsession.setLastAccessedTime(System.currentTimeMillis());
-            rsession.setThisAccessedTime(System.currentTimeMillis());
-            ((ReplicatedSession)session).setAccessCount(0);
-            session.setNew(false);
-            if(log.isTraceEnabled())
-                 log.trace("Session loaded id="+sessionId +
-                               " actualId="+session.getId()+ 
-                               " exists="+this.sessions.containsKey(sessionId)+
-                               " valid="+rsession.isValid());
-            return session;
-
-        }
-        catch ( Exception x )
-        {
-            log.error("Failed to deserialize the session!",x);
-        }
-        return null;
-    }
-
-    public String getName() {
-        return this.name;
-    }
-    /**
-     * Prepare for the beginning of active use of the public methods of this
-     * component.  This method should be called after <code>configure()</code>,
-     * and before any of the public methods of the component are utilized.<BR>
-     * Starts the cluster communication channel, this will connect with the other nodes
-     * in the cluster, and request the current session state to be transferred to this node.
-     * @exception IllegalStateException if this component has already been
-     *  started
-     * @exception LifecycleException if this component detects a fatal error
-     *  that prevents this component from being used
-     */
-    public void start() throws LifecycleException {
-        mManagerRunning = true;
-        super.start();
-        try {
-            //the channel is already running
-            if ( mChannelStarted ) return;
-            if(log.isInfoEnabled())
-                log.info("Starting clustering manager...:"+getName());
-            if ( cluster == null ) {
-                log.error("Starting... no cluster associated with this context:"+getName());
-                return;
-            }
-            cluster.registerManager(this);
-
-            if (cluster.getMembers().length > 0) {
-                Member mbr = cluster.getMembers()[0];
-                SessionMessage msg =
-                    new SessionMessageImpl(this.getName(),
-                                       SessionMessage.EVT_GET_ALL_SESSIONS,
-                                       null,
-                                       "GET-ALL",
-                                       "GET-ALL-"+this.getName());
-                cluster.send(msg, mbr);
-                if(log.isWarnEnabled())
-                     log.warn("Manager["+getName()+"], requesting session state from "+mbr+
-                         ". This operation will timeout if no session state has been received within "+
-                         "60 seconds");
-                long reqStart = System.currentTimeMillis();
-                long reqNow = 0;
-                boolean isTimeout=false;
-                do {
-                    try {
-                        Thread.sleep(100);
-                    }catch ( Exception sleep) {}
-                    reqNow = System.currentTimeMillis();
-                    isTimeout=((reqNow-reqStart)>(1000*60));
-                } while ( (!isStateTransferred()) && (!isTimeout));
-                if ( isTimeout || (!isStateTransferred()) ) {
-                    log.error("Manager["+getName()+"], No session state received, timing out.");
-                }else {
-                    if(log.isInfoEnabled())
-                        log.info("Manager["+getName()+"], session state received in "+(reqNow-reqStart)+" ms.");
-                }
-            } else {
-                if(log.isInfoEnabled())
-                    log.info("Manager["+getName()+"], skipping state transfer. No members active in cluster group.");
-            }//end if
-            mChannelStarted = true;
-        }  catch ( Exception x ) {
-            log.error("Unable to start SimpleTcpReplicationManager",x);
-        }
-    }
-
-    /**
-     * Gracefully terminate the active use of the public methods of this
-     * component.  This method should be the last one called on a given
-     * instance of this component.<BR>
-     * This will disconnect the cluster communication channel and stop the listener thread.
-     * @exception IllegalStateException if this component has not been started
-     * @exception LifecycleException if this component detects a fatal error
-     *  that needs to be reported
-     */
-    public void stop() throws LifecycleException
-    {
-        mManagerRunning = false;
-        mChannelStarted = false;
-        super.stop();
-        try
-        {
-            this.sessions.clear();
-            cluster.removeManager(this);
-        }
-        catch ( Exception x )
-        {
-            log.error("Unable to stop SimpleTcpReplicationManager",x);
-        }
-    }
-
-    public void setDistributable(boolean dist) {
-        this.distributable = dist;
-    }
-
-    public boolean getDistributable() {
-        return distributable;
-    }
-
-    /**
-     * This method is called by the received thread when a SessionMessage has
-     * been received from one of the other nodes in the cluster.
-     * @param msg - the message received
-     * @param sender - the sender of the message, this is used if we receive a
-     *                 EVT_GET_ALL_SESSION message, so that we only reply to
-     *                 the requesting node
-     */
-    protected void messageReceived( SessionMessage msg, Member sender ) {
-        try  {
-            if(log.isInfoEnabled()) {
-                log.debug("Received SessionMessage of type="+msg.getEventTypeString());
-                log.debug("Received SessionMessage sender="+sender);
-            }
-            switch ( msg.getEventType() ) {
-                case SessionMessage.EVT_GET_ALL_SESSIONS: {
-                    //get a list of all the session from this manager
-                    Object[] sessions = findSessions();
-                    java.io.ByteArrayOutputStream bout = new java.io.ByteArrayOutputStream();
-                    java.io.ObjectOutputStream oout = new java.io.ObjectOutputStream(bout);
-                    oout.writeInt(sessions.length);
-                    for (int i=0; i<sessions.length; i++){
-                        ReplicatedSession ses = (ReplicatedSession)sessions[i];
-                        oout.writeUTF(ses.getIdInternal());
-                        byte[] data = writeSession(ses);
-                        oout.writeObject(data);
-                    }//for
-                    //don't send a message if we don't have to
-                    oout.flush();
-                    oout.close();
-                    byte[] data = bout.toByteArray();
-                    SessionMessage newmsg = new SessionMessageImpl(name,
-                        SessionMessage.EVT_ALL_SESSION_DATA,
-                        data, "SESSION-STATE","SESSION-STATE-"+getName());
-                    cluster.send(newmsg, sender);
-                    break;
-                }
-                case SessionMessage.EVT_ALL_SESSION_DATA: {
-                    java.io.ByteArrayInputStream bin =
-                        new java.io.ByteArrayInputStream(msg.getSession());
-                    java.io.ObjectInputStream oin = new java.io.ObjectInputStream(bin);
-                    int size = oin.readInt();
-                    for ( int i=0; i<size; i++) {
-                        String id = oin.readUTF();
-                        byte[] data = (byte[])oin.readObject();
-                        Session session = readSession(data,id);
-                    }//for
-                    stateTransferred=true;
-                    break;
-                }
-                case SessionMessage.EVT_SESSION_CREATED: {
-                    Session session = this.readSession(msg.getSession(),msg.getSessionID());
-                    if ( log.isDebugEnabled() ) {
-                        log.debug("Received replicated session=" + session +
-                            " isValid=" + session.isValid());
-                    }
-                    break;
-                }
-                case SessionMessage.EVT_SESSION_EXPIRED: {
-                    Session session = findSession(msg.getSessionID());
-                    if ( session != null ) {
-                        session.expire();
-                        this.remove(session);
-                    }//end if
-                    break;
-                }
-                case SessionMessage.EVT_SESSION_ACCESSED :{
-                    Session session = findSession(msg.getSessionID());
-                    if ( session != null ) {
-                        session.access();
-                        session.endAccess();
-                    }
-                    break;
-                }
-                default:  {
-                    //we didn't recognize the message type, do nothing
-                    break;
-                }
-            }//switch
-        }
-        catch ( Exception x )
-        {
-            log.error("Unable to receive message through TCP channel",x);
-        }
-    }
-
-    public void messageDataReceived(ClusterMessage cmsg) {
-        try {
-            if ( cmsg instanceof SessionMessage ) {
-                SessionMessage msg = (SessionMessage)cmsg;
-                messageReceived(msg,
-                                msg.getAddress() != null ? (Member) msg.getAddress() : null);
-            }
-        } catch(Throwable ex){
-            log.error("InMemoryReplicationManager.messageDataReceived()", ex);
-        }//catch
-    }
-
-    public boolean isStateTransferred() {
-        return stateTransferred;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-    public boolean isNotifyListenersOnReplication() {
-        return notifyListenersOnReplication;
-    }
-    public void setNotifyListenersOnReplication(boolean notifyListenersOnReplication) {
-        this.notifyListenersOnReplication = notifyListenersOnReplication;
-    }
-
-
-    /* 
-     * @see org.apache.catalina.ha.ClusterManager#getCluster()
-     */
-    public CatalinaCluster getCluster() {
-        return cluster;
-    }
-
-    public ClusterManager cloneFromTemplate() {
-        throw new UnsupportedOperationException();
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.ha.session;
+
+import java.io.IOException;
+
+import org.apache.catalina.LifecycleException;
+import org.apache.catalina.Session;
+import org.apache.catalina.ha.CatalinaCluster;
+import org.apache.catalina.ha.ClusterManager;
+import org.apache.catalina.ha.ClusterMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.realm.GenericPrincipal;
+import org.apache.catalina.session.StandardManager;
+import org.apache.catalina.tribes.io.ReplicationStream;
+import java.io.ByteArrayInputStream;
+import org.apache.catalina.Loader;
+
+/**
+ * Title:        Tomcat Session Replication for Tomcat 4.0 <BR>
+ * Description:  A very simple straight forward implementation of
+ *               session replication of servers in a cluster.<BR>
+ *               This session replication is implemented "live". By live
+ *               I mean, when a session attribute is added into a session on Node A
+ *               a message is broadcasted to other messages and setAttribute is called on the
+ *               replicated sessions.<BR>
+ *               A full description of this implementation can be found under
+ *               <href="http://www.filip.net/tomcat/">Filip's Tomcat Page</a><BR>
+ *
+ * Copyright:    See apache license
+ * Company:      www.filip.net
+ * @author  <a href="mailto:mail@filip.net">Filip Hanik</a>
+ * @author Bela Ban (modifications for synchronous replication)
+ * @version 1.0 for TC 4.0
+ * Description: The InMemoryReplicationManager is a session manager that replicated
+ * session information in memory. 
+ * <BR><BR>
+ * The InMemoryReplicationManager extends the StandardManager hence it allows for us
+ * to inherit all the basic session management features like expiration, session listeners etc
+ * <BR><BR>
+ * To communicate with other nodes in the cluster, the InMemoryReplicationManager sends out 7 different type of multicast messages
+ * all defined in the SessionMessage class.<BR>
+ * When a session is replicated (not an attribute added/removed) the session is serialized into
+ * a byte array using the StandardSession.readObjectData, StandardSession.writeObjectData methods.
+ */
+public class SimpleTcpReplicationManager extends StandardManager implements ClusterManager
+{
+    public static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( SimpleTcpReplicationManager.class );
+
+    //the channel configuration
+    protected String mChannelConfig = null;
+
+    //the group name
+    protected String mGroupName = "TomcatReplication";
+
+    //somehow start() gets called more than once
+    protected boolean mChannelStarted = false;
+
+    //log to screen
+    protected boolean mPrintToScreen = true;
+
+    protected boolean defaultMode = false;
+
+    protected boolean mManagerRunning = false;
+
+    /** Use synchronous rather than asynchronous replication. Every session modification (creation, change, removal etc)
+     * will be sent to all members. The call will then wait for max milliseconds, or forever (if timeout is 0) for
+     * all responses.
+     */
+    protected boolean synchronousReplication=true;
+
+    /** Set to true if we don't want the sessions to expire on shutdown */
+    protected boolean mExpireSessionsOnShutdown = true;
+
+    protected boolean useDirtyFlag = false;
+
+    protected String name;
+
+    protected boolean distributable = true;
+
+    protected CatalinaCluster cluster;
+
+    protected java.util.HashMap invalidatedSessions = new java.util.HashMap();
+
+    /**
+     * Flag to keep track if the state has been transferred or not
+     * Assumes false.
+     */
+    protected boolean stateTransferred = false;
+    private boolean notifyListenersOnReplication;
+    private boolean sendClusterDomainOnly = true ;
+
+    /**
+     * Constructor, just calls super()
+     *
+     */
+    public SimpleTcpReplicationManager()
+    {
+        super();
+    }
+
+    public boolean doDomainReplication() {
+        return sendClusterDomainOnly;
+    }
+    
+    /**
+     * @param sendClusterDomainOnly The sendClusterDomainOnly to set.
+     */
+    public void setDomainReplication(boolean sendClusterDomainOnly) {
+        this.sendClusterDomainOnly = sendClusterDomainOnly;
+    }
+  
+    /**
+     * @return Returns the defaultMode.
+     */
+    public boolean isDefaultMode() {
+        return defaultMode;
+    }
+    /**
+     * @param defaultMode The defaultMode to set.
+     */
+    public void setDefaultMode(boolean defaultMode) {
+        this.defaultMode = defaultMode;
+    }
+    
+    public boolean isManagerRunning()
+    {
+        return mManagerRunning;
+    }
+
+    public void setUseDirtyFlag(boolean usedirtyflag)
+    {
+        this.useDirtyFlag = usedirtyflag;
+    }
+
+    public void setExpireSessionsOnShutdown(boolean expireSessionsOnShutdown)
+    {
+        mExpireSessionsOnShutdown = expireSessionsOnShutdown;
+    }
+
+    public void setCluster(CatalinaCluster cluster) {
+        if(log.isDebugEnabled())
+            log.debug("Cluster associated with SimpleTcpReplicationManager");
+        this.cluster = cluster;
+    }
+
+    public boolean getExpireSessionsOnShutdown()
+    {
+        return mExpireSessionsOnShutdown;
+    }
+
+    public void setPrintToScreen(boolean printtoscreen)
+    {
+        if(log.isDebugEnabled())
+            log.debug("Setting screen debug to:"+printtoscreen);
+        mPrintToScreen = printtoscreen;
+    }
+
+    public void setSynchronousReplication(boolean flag)
+    {
+        synchronousReplication=flag;
+    }
+
+    /**
+     * Override persistence since they don't go hand in hand with replication for now.
+     */
+    public void unload() throws IOException {
+        if ( !getDistributable() ) {
+            super.unload();
+        }
+    }
+
+    /**
+     * Creates a HTTP session.
+     * Most of the code in here is copied from the StandardManager.
+     * This is not pretty, yeah I know, but it was necessary since the
+     * StandardManager had hard coded the session instantiation to the a
+     * StandardSession, when we actually want to instantiate a ReplicatedSession<BR>
+     * If the call comes from the Tomcat servlet engine, a SessionMessage goes out to the other
+     * nodes in the cluster that this session has been created.
+     * @param notify - if set to true the other nodes in the cluster will be notified.
+     *                 This flag is needed so that we can create a session before we deserialize
+     *                 a replicated one
+     *
+     * @see ReplicatedSession
+     */
+    protected Session createSession(String sessionId, boolean notify, boolean setId)
+    {
+
+        //inherited from the basic manager
+        if ((getMaxActiveSessions() >= 0) &&
+           (sessions.size() >= getMaxActiveSessions()))
+            throw new IllegalStateException(sm.getString("standardManager.createSession.ise"));
+
+
+        Session session = new ReplicatedSession(this);
+
+        // Initialize the properties of the new session and return it
+        session.setNew(true);
+        session.setValid(true);
+        session.setCreationTime(System.currentTimeMillis());
+        session.setMaxInactiveInterval(this.maxInactiveInterval);
+        if(sessionId == null)
+            sessionId = generateSessionId();
+        if ( setId ) session.setId(sessionId);
+        if ( notify && (cluster!=null) ) {
+            ((ReplicatedSession)session).setIsDirty(true);
+        }
+        return (session);
+    }//createSession
+
+    //=========================================================================
+    // OVERRIDE THESE METHODS TO IMPLEMENT THE REPLICATION
+    //=========================================================================
+
+    /**
+     * Construct and return a new session object, based on the default
+     * settings specified by this Manager's properties.  The session
+     * id will be assigned by this method, and available via the getId()
+     * method of the returned session.  If a new session cannot be created
+     * for any reason, return <code>null</code>.
+     *
+     * @exception IllegalStateException if a new session cannot be
+     *  instantiated for any reason
+     */
+    public Session createSession(String sessionId)
+    {
+        //create a session and notify the other nodes in the cluster
+        Session session =  createSession(sessionId,getDistributable(),true);
+        add(session);
+        return session;
+    }
+
+    public void sessionInvalidated(String sessionId) {
+        synchronized ( invalidatedSessions ) {
+            invalidatedSessions.put(sessionId, sessionId);
+        }
+    }
+
+    public String[] getInvalidatedSessions() {
+        synchronized ( invalidatedSessions ) {
+            String[] result = new String[invalidatedSessions.size()];
+            invalidatedSessions.values().toArray(result);
+            return result;
+        }
+
+    }
+
+    public ClusterMessage requestCompleted(String sessionId)
+    {
+        if (  !getDistributable() ) {
+            log.warn("Received requestCompleted message, although this context["+
+                     getName()+"] is not distributable. Ignoring message");
+            return null;
+        }
+        try
+        {
+            if ( invalidatedSessions.get(sessionId) != null ) {
+                synchronized ( invalidatedSessions ) {
+                    invalidatedSessions.remove(sessionId);
+                    SessionMessage msg = new SessionMessageImpl(name,
+                    SessionMessage.EVT_SESSION_EXPIRED,
+                    null,
+                    sessionId,
+                    sessionId);
+                return msg;
+                }
+            } else {
+                ReplicatedSession session = (ReplicatedSession) findSession(
+                    sessionId);
+                if (session != null) {
+                    //return immediately if the session is not dirty
+                    if (useDirtyFlag && (!session.isDirty())) {
+                        //but before we return doing nothing,
+                        //see if we should send
+                        //an updated last access message so that
+                        //sessions across cluster dont expire
+                        long interval = session.getMaxInactiveInterval();
+                        long lastaccdist = System.currentTimeMillis() -
+                            session.getLastAccessWasDistributed();
+                        if ( ((interval*1000) / lastaccdist)< 3 ) {
+                            SessionMessage accmsg = new SessionMessageImpl(name,
+                                SessionMessage.EVT_SESSION_ACCESSED,
+                                null,
+                                sessionId,
+                                sessionId);
+                            session.setLastAccessWasDistributed(System.currentTimeMillis());
+                            return accmsg;
+                        }
+                        return null;
+                    }
+
+                    session.setIsDirty(false);
+                    if (log.isDebugEnabled()) {
+                        try {
+                            log.debug("Sending session to cluster=" + session);
+                        }
+                        catch (Exception ignore) {}
+                    }
+                    SessionMessage msg = new SessionMessageImpl(name,
+                        SessionMessage.EVT_SESSION_CREATED,
+                        writeSession(session),
+                        session.getIdInternal(),
+                        session.getIdInternal());
+                    return msg;
+                } //end if
+            }//end if
+        }
+        catch (Exception x )
+        {
+            log.error("Unable to replicate session",x);
+        }
+        return null;
+    }
+
+    /**
+     * Serialize a session into a byte array<BR>
+     * This method simple calls the writeObjectData method on the session
+     * and returns the byte data from that call
+     * @param session - the session to be serialized
+     * @return a byte array containing the session data, null if the serialization failed
+     */
+    protected byte[] writeSession( Session session )
+    {
+        try
+        {
+            java.io.ByteArrayOutputStream session_data = new java.io.ByteArrayOutputStream();
+            java.io.ObjectOutputStream session_out = new java.io.ObjectOutputStream(session_data);
+            session_out.flush();
+            boolean hasPrincipal = session.getPrincipal() != null;
+            session_out.writeBoolean(hasPrincipal);
+            if ( hasPrincipal )
+            {
+                session_out.writeObject(SerializablePrincipal.createPrincipal((GenericPrincipal)session.getPrincipal()));
+            }//end if
+            ((ReplicatedSession)session).writeObjectData(session_out);
+            return session_data.toByteArray();
+
+        }
+        catch ( Exception x )
+        {
+            log.error("Failed to serialize the session!",x);
+        }
+        return null;
+    }
+    
+    /**
+     * Open Stream and use correct ClassLoader (Container) Switch
+     * ThreadClassLoader
+     * 
+     * @param data
+     * @return The object input stream
+     * @throws IOException
+     */
+    public ReplicationStream getReplicationStream(byte[] data) throws IOException {
+        return getReplicationStream(data,0,data.length);
+    }
+    
+    public ReplicationStream getReplicationStream(byte[] data, int offset, int length) throws IOException {
+        ByteArrayInputStream fis =null;
+        ReplicationStream ois = null;
+        Loader loader = null;
+        ClassLoader classLoader = null;
+        //fix to be able to run the DeltaManager
+        //stand alone without a container.
+        //use the Threads context class loader
+        if (container != null)
+            loader = container.getLoader();
+        if (loader != null)
+            classLoader = loader.getClassLoader();
+        else
+            classLoader = Thread.currentThread().getContextClassLoader();
+        //end fix
+        fis = new ByteArrayInputStream(data, offset, length);
+        if ( classLoader == Thread.currentThread().getContextClassLoader() ) {
+            ois = new ReplicationStream(fis, new ClassLoader[] {classLoader});
+        } else {
+            ois = new ReplicationStream(fis, new ClassLoader[] {classLoader,Thread.currentThread().getContextClassLoader()});
+        }
+        return ois;
+    }    
+
+
+    
+
+    /**
+     * Reinstantiates a serialized session from the data passed in.
+     * This will first call createSession() so that we get a fresh instance with all
+     * the managers set and all the transient fields validated.
+     * Then it calls Session.readObjectData(byte[]) to deserialize the object
+     * @param data - a byte array containing session data
+     * @return a valid Session object, null if an error occurs
+     *
+     */
+    protected Session readSession( byte[] data, String sessionId )
+    {
+        try
+        {
+            ReplicationStream session_in = getReplicationStream(data);
+
+            Session session = sessionId!=null?this.findSession(sessionId):null;
+            boolean isNew = (session==null);
+            //clear the old values from the existing session
+            if ( session!=null ) {
+                ReplicatedSession rs = (ReplicatedSession)session;
+                rs.expire(false);  //cleans up the previous values, since we are not doing removes
+                session = null;
+            }//end if
+
+            if (session==null) {
+                session = createSession(null,false, false);
+                sessions.remove(session.getIdInternal());
+            }
+            
+            
+            boolean hasPrincipal = session_in.readBoolean();
+            SerializablePrincipal p = null;
+            if ( hasPrincipal )
+                p = (SerializablePrincipal)session_in.readObject();
+            ((ReplicatedSession)session).readObjectData(session_in);
+            if ( hasPrincipal )
+                session.setPrincipal(p.getPrincipal(getContainer().getRealm()));
+            ((ReplicatedSession)session).setId(sessionId,isNew);
+            ReplicatedSession rsession = (ReplicatedSession)session; 
+            rsession.setAccessCount(1);
+            session.setManager(this);
+            session.setValid(true);
+            rsession.setLastAccessedTime(System.currentTimeMillis());
+            rsession.setThisAccessedTime(System.currentTimeMillis());
+            ((ReplicatedSession)session).setAccessCount(0);
+            session.setNew(false);
+            if(log.isTraceEnabled())
+                 log.trace("Session loaded id="+sessionId +
+                               " actualId="+session.getId()+ 
+                               " exists="+this.sessions.containsKey(sessionId)+
+                               " valid="+rsession.isValid());
+            return session;
+
+        }
+        catch ( Exception x )
+        {
+            log.error("Failed to deserialize the session!",x);
+        }
+        return null;
+    }
+
+    public String getName() {
+        return this.name;
+    }
+    /**
+     * Prepare for the beginning of active use of the public methods of this
+     * component.  This method should be called after <code>configure()</code>,
+     * and before any of the public methods of the component are utilized.<BR>
+     * Starts the cluster communication channel, this will connect with the other nodes
+     * in the cluster, and request the current session state to be transferred to this node.
+     * @exception IllegalStateException if this component has already been
+     *  started
+     * @exception LifecycleException if this component detects a fatal error
+     *  that prevents this component from being used
+     */
+    public void start() throws LifecycleException {
+        mManagerRunning = true;
+        super.start();
+        try {
+            //the channel is already running
+            if ( mChannelStarted ) return;
+            if(log.isInfoEnabled())
+                log.info("Starting clustering manager...:"+getName());
+            if ( cluster == null ) {
+                log.error("Starting... no cluster associated with this context:"+getName());
+                return;
+            }
+            cluster.registerManager(this);
+
+            if (cluster.getMembers().length > 0) {
+                Member mbr = cluster.getMembers()[0];
+                SessionMessage msg =
+                    new SessionMessageImpl(this.getName(),
+                                       SessionMessage.EVT_GET_ALL_SESSIONS,
+                                       null,
+                                       "GET-ALL",
+                                       "GET-ALL-"+this.getName());
+                cluster.send(msg, mbr);
+                if(log.isWarnEnabled())
+                     log.warn("Manager["+getName()+"], requesting session state from "+mbr+
+                         ". This operation will timeout if no session state has been received within "+
+                         "60 seconds");
+                long reqStart = System.currentTimeMillis();
+                long reqNow = 0;
+                boolean isTimeout=false;
+                do {
+                    try {
+                        Thread.sleep(100);
+                    }catch ( Exception sleep) {}
+                    reqNow = System.currentTimeMillis();
+                    isTimeout=((reqNow-reqStart)>(1000*60));
+                } while ( (!isStateTransferred()) && (!isTimeout));
+                if ( isTimeout || (!isStateTransferred()) ) {
+                    log.error("Manager["+getName()+"], No session state received, timing out.");
+                }else {
+                    if(log.isInfoEnabled())
+                        log.info("Manager["+getName()+"], session state received in "+(reqNow-reqStart)+" ms.");
+                }
+            } else {
+                if(log.isInfoEnabled())
+                    log.info("Manager["+getName()+"], skipping state transfer. No members active in cluster group.");
+            }//end if
+            mChannelStarted = true;
+        }  catch ( Exception x ) {
+            log.error("Unable to start SimpleTcpReplicationManager",x);
+        }
+    }
+
+    /**
+     * Gracefully terminate the active use of the public methods of this
+     * component.  This method should be the last one called on a given
+     * instance of this component.<BR>
+     * This will disconnect the cluster communication channel and stop the listener thread.
+     * @exception IllegalStateException if this component has not been started
+     * @exception LifecycleException if this component detects a fatal error
+     *  that needs to be reported
+     */
+    public void stop() throws LifecycleException
+    {
+        mManagerRunning = false;
+        mChannelStarted = false;
+        super.stop();
+        try
+        {
+            this.sessions.clear();
+            cluster.removeManager(this);
+        }
+        catch ( Exception x )
+        {
+            log.error("Unable to stop SimpleTcpReplicationManager",x);
+        }
+    }
+
+    public void setDistributable(boolean dist) {
+        this.distributable = dist;
+    }
+
+    public boolean getDistributable() {
+        return distributable;
+    }
+
+    /**
+     * This method is called by the received thread when a SessionMessage has
+     * been received from one of the other nodes in the cluster.
+     * @param msg - the message received
+     * @param sender - the sender of the message, this is used if we receive a
+     *                 EVT_GET_ALL_SESSION message, so that we only reply to
+     *                 the requesting node
+     */
+    protected void messageReceived( SessionMessage msg, Member sender ) {
+        try  {
+            if(log.isInfoEnabled()) {
+                log.debug("Received SessionMessage of type="+msg.getEventTypeString());
+                log.debug("Received SessionMessage sender="+sender);
+            }
+            switch ( msg.getEventType() ) {
+                case SessionMessage.EVT_GET_ALL_SESSIONS: {
+                    //get a list of all the session from this manager
+                    Object[] sessions = findSessions();
+                    java.io.ByteArrayOutputStream bout = new java.io.ByteArrayOutputStream();
+                    java.io.ObjectOutputStream oout = new java.io.ObjectOutputStream(bout);
+                    oout.writeInt(sessions.length);
+                    for (int i=0; i<sessions.length; i++){
+                        ReplicatedSession ses = (ReplicatedSession)sessions[i];
+                        oout.writeUTF(ses.getIdInternal());
+                        byte[] data = writeSession(ses);
+                        oout.writeObject(data);
+                    }//for
+                    //don't send a message if we don't have to
+                    oout.flush();
+                    oout.close();
+                    byte[] data = bout.toByteArray();
+                    SessionMessage newmsg = new SessionMessageImpl(name,
+                        SessionMessage.EVT_ALL_SESSION_DATA,
+                        data, "SESSION-STATE","SESSION-STATE-"+getName());
+                    cluster.send(newmsg, sender);
+                    break;
+                }
+                case SessionMessage.EVT_ALL_SESSION_DATA: {
+                    java.io.ByteArrayInputStream bin =
+                        new java.io.ByteArrayInputStream(msg.getSession());
+                    java.io.ObjectInputStream oin = new java.io.ObjectInputStream(bin);
+                    int size = oin.readInt();
+                    for ( int i=0; i<size; i++) {
+                        String id = oin.readUTF();
+                        byte[] data = (byte[])oin.readObject();
+                        Session session = readSession(data,id);
+                    }//for
+                    stateTransferred=true;
+                    break;
+                }
+                case SessionMessage.EVT_SESSION_CREATED: {
+                    Session session = this.readSession(msg.getSession(),msg.getSessionID());
+                    if ( log.isDebugEnabled() ) {
+                        log.debug("Received replicated session=" + session +
+                            " isValid=" + session.isValid());
+                    }
+                    break;
+                }
+                case SessionMessage.EVT_SESSION_EXPIRED: {
+                    Session session = findSession(msg.getSessionID());
+                    if ( session != null ) {
+                        session.expire();
+                        this.remove(session);
+                    }//end if
+                    break;
+                }
+                case SessionMessage.EVT_SESSION_ACCESSED :{
+                    Session session = findSession(msg.getSessionID());
+                    if ( session != null ) {
+                        session.access();
+                        session.endAccess();
+                    }
+                    break;
+                }
+                default:  {
+                    //we didn't recognize the message type, do nothing
+                    break;
+                }
+            }//switch
+        }
+        catch ( Exception x )
+        {
+            log.error("Unable to receive message through TCP channel",x);
+        }
+    }
+
+    public void messageDataReceived(ClusterMessage cmsg) {
+        try {
+            if ( cmsg instanceof SessionMessage ) {
+                SessionMessage msg = (SessionMessage)cmsg;
+                messageReceived(msg,
+                                msg.getAddress() != null ? (Member) msg.getAddress() : null);
+            }
+        } catch(Throwable ex){
+            log.error("InMemoryReplicationManager.messageDataReceived()", ex);
+        }//catch
+    }
+
+    public boolean isStateTransferred() {
+        return stateTransferred;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+    public boolean isNotifyListenersOnReplication() {
+        return notifyListenersOnReplication;
+    }
+    public void setNotifyListenersOnReplication(boolean notifyListenersOnReplication) {
+        this.notifyListenersOnReplication = notifyListenersOnReplication;
+    }
+
+
+    /* 
+     * @see org.apache.catalina.ha.ClusterManager#getCluster()
+     */
+    public CatalinaCluster getCluster() {
+        return cluster;
+    }
+
+    public ClusterManager cloneFromTemplate() {
+        throw new UnsupportedOperationException();
+    }
+
+}

==================================================
ReplicationValve.java
index 01fa2571d4..6d3f7a6ac6 100644
--- a/java/org/apache/catalina/ha/tcp/Constants.java
+++ b/java/org/apache/catalina/ha/tcp/Constants.java
@@ -1,33 +1,33 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina.ha.tcp;
-
-/**
- * Manifest constants for the <code>org.apache.catalina.ha.tcp</code>
- * package.
- *
- * @author Peter Rossbach
- * @version $Revision: 303753 $ $Date: 2005-03-14 15:24:30 -0600 (Mon, 14 Mar 2005) $
- */
-
-public class Constants {
-
-    public static final String Package = "org.apache.catalina.ha.tcp";
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.catalina.ha.tcp;
+
+/**
+ * Manifest constants for the <code>org.apache.catalina.ha.tcp</code>
+ * package.
+ *
+ * @author Peter Rossbach
+ * @version $Revision$ $Date$
+ */
+
+public class Constants {
+
+    public static final String Package = "org.apache.catalina.ha.tcp";
+
+}

==================================================
SendMessageData.java
index 733dae4fc2..524680b5fd 100644
--- a/java/org/apache/catalina/ha/tcp/ReplicationValve.java
+++ b/java/org/apache/catalina/ha/tcp/ReplicationValve.java
@@ -1,658 +1,658 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha.tcp;
-
-import java.io.IOException;
-import java.util.StringTokenizer;
-import java.util.regex.Pattern;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Iterator;
-import javax.servlet.ServletException;
-
-import org.apache.catalina.Manager;
-import org.apache.catalina.Session;
-import org.apache.catalina.Context;
-import org.apache.catalina.core.StandardContext;
-import org.apache.catalina.ha.CatalinaCluster;
-import org.apache.catalina.ha.ClusterManager;
-import org.apache.catalina.ha.ClusterMessage;
-import org.apache.catalina.ha.ClusterSession;
-import org.apache.catalina.ha.ClusterValve;
-import org.apache.catalina.ha.session.DeltaManager;
-import org.apache.catalina.ha.session.DeltaSession;
-import org.apache.catalina.connector.Request;
-import org.apache.catalina.connector.Response;
-import org.apache.catalina.util.StringManager;
-import org.apache.catalina.valves.ValveBase;
-
-/**
- * <p>Implementation of a Valve that logs interesting contents from the
- * specified Request (before processing) and the corresponding Response
- * (after processing).  It is especially useful in debugging problems
- * related to headers and cookies.</p>
- *
- * <p>This Valve may be attached to any Container, depending on the granularity
- * of the logging you wish to perform.</p>
- *
- * <p>primaryIndicator=true, then the request attribute <i>org.apache.catalina.ha.tcp.isPrimarySession.</i>
- * is set true, when request processing is at sessions primary node.
- * </p>
- *
- * @author Craig R. McClanahan
- * @author Filip Hanik
- * @author Peter Rossbach
- * @version $Revision: 375709 $ $Date: 2006-02-07 15:13:25 -0600 (Tue, 07 Feb 2006) $
- */
-
-public class ReplicationValve
-    extends ValveBase implements ClusterValve {
-    
-    private static org.apache.juli.logging.Log log =
-        org.apache.juli.logging.LogFactory.getLog( ReplicationValve.class );
-
-    // ----------------------------------------------------- Instance Variables
-
-    /**
-     * The descriptive information related to this implementation.
-     */
-    private static final String info =
-        "org.apache.catalina.ha.tcp.ReplicationValve/2.0";
-
-
-    /**
-     * The StringManager for this package.
-     */
-    protected static StringManager sm =
-        StringManager.getManager(Constants.Package);
-
-    private CatalinaCluster cluster = null ;
-
-    /**
-     * holds file endings to not call for like images and others
-     */
-    protected java.util.regex.Pattern[] reqFilters = new java.util.regex.Pattern[0];
-    
-    /**
-     * Orginal filter 
-     */
-    protected String filter ;
-    
-    /**
-     * crossContext session container 
-     */
-    protected ThreadLocal crossContextSessions = new ThreadLocal() ;
-    
-    /**
-     * doProcessingStats (default = off)
-     */
-    protected boolean doProcessingStats = false;
-    
-    protected long totalRequestTime = 0;
-    protected long totalSendTime = 0;
-    protected long nrOfRequests = 0;
-    protected long lastSendTime = 0;
-    protected long nrOfFilterRequests = 0;
-    protected long nrOfSendRequests = 0;
-    protected long nrOfCrossContextSendRequests = 0;
-    
-    /**
-     * must primary change indicator set 
-     */
-    protected boolean primaryIndicator = false ;
-    
-    /**
-     * Name of primary change indicator as request attribute
-     */
-    protected String primaryIndicatorName = "org.apache.catalina.ha.tcp.isPrimarySession";
-   
-    // ------------------------------------------------------------- Properties
-
-    public ReplicationValve() {
-    }
-    
-    /**
-     * Return descriptive information about this Valve implementation.
-     */
-    public String getInfo() {
-
-        return (info);
-
-    }
-    
-    /**
-     * @return Returns the cluster.
-     */
-    public CatalinaCluster getCluster() {
-        return cluster;
-    }
-    
-    /**
-     * @param cluster The cluster to set.
-     */
-    public void setCluster(CatalinaCluster cluster) {
-        this.cluster = cluster;
-    }
- 
-    /**
-     * @return Returns the filter
-     */
-    public String getFilter() {
-       return filter ;
-    }
-
-    /**
-     * compile filter string to regular expressions
-     * @see Pattern#compile(java.lang.String)
-     * @param filter
-     *            The filter to set.
-     */
-    public void setFilter(String filter) {
-        if (log.isDebugEnabled())
-            log.debug(sm.getString("ReplicationValve.filter.loading", filter));
-        this.filter = filter;
-        StringTokenizer t = new StringTokenizer(filter, ";");
-        this.reqFilters = new Pattern[t.countTokens()];
-        int i = 0;
-        while (t.hasMoreTokens()) {
-            String s = t.nextToken();
-            if (log.isTraceEnabled())
-                log.trace(sm.getString("ReplicationValve.filter.token", s));
-            try {
-                reqFilters[i++] = Pattern.compile(s);
-            } catch (Exception x) {
-                log.error(sm.getString("ReplicationValve.filter.token.failure",
-                        s), x);
-            }
-        }
-    }
-
-    /**
-     * @return Returns the primaryIndicator.
-     */
-    public boolean isPrimaryIndicator() {
-        return primaryIndicator;
-    }
-
-    /**
-     * @param primaryIndicator The primaryIndicator to set.
-     */
-    public void setPrimaryIndicator(boolean primaryIndicator) {
-        this.primaryIndicator = primaryIndicator;
-    }
-    
-    /**
-     * @return Returns the primaryIndicatorName.
-     */
-    public String getPrimaryIndicatorName() {
-        return primaryIndicatorName;
-    }
-    
-    /**
-     * @param primaryIndicatorName The primaryIndicatorName to set.
-     */
-    public void setPrimaryIndicatorName(String primaryIndicatorName) {
-        this.primaryIndicatorName = primaryIndicatorName;
-    }
-    
-    /**
-     * Calc processing stats
-     */
-    public boolean doStatistics() {
-        return doProcessingStats;
-    }
-
-    /**
-     * Set Calc processing stats
-     * @see #resetStatistics()
-     */
-    public void setStatistics(boolean doProcessingStats) {
-        this.doProcessingStats = doProcessingStats;
-    }
-
-    /**
-     * @return Returns the lastSendTime.
-     */
-    public long getLastSendTime() {
-        return lastSendTime;
-    }
-    
-    /**
-     * @return Returns the nrOfRequests.
-     */
-    public long getNrOfRequests() {
-        return nrOfRequests;
-    }
-    
-    /**
-     * @return Returns the nrOfFilterRequests.
-     */
-    public long getNrOfFilterRequests() {
-        return nrOfFilterRequests;
-    }
-
-    /**
-     * @return Returns the nrOfCrossContextSendRequests.
-     */
-    public long getNrOfCrossContextSendRequests() {
-        return nrOfCrossContextSendRequests;
-    }
-
-    /**
-     * @return Returns the nrOfSendRequests.
-     */
-    public long getNrOfSendRequests() {
-        return nrOfSendRequests;
-    }
-
-    /**
-     * @return Returns the totalRequestTime.
-     */
-    public long getTotalRequestTime() {
-        return totalRequestTime;
-    }
-    
-    /**
-     * @return Returns the totalSendTime.
-     */
-    public long getTotalSendTime() {
-        return totalSendTime;
-    }
-
-    /**
-     * @return Returns the reqFilters.
-     */
-    protected java.util.regex.Pattern[] getReqFilters() {
-        return reqFilters;
-    }
-    
-    /**
-     * @param reqFilters The reqFilters to set.
-     */
-    protected void setReqFilters(java.util.regex.Pattern[] reqFilters) {
-        this.reqFilters = reqFilters;
-    }
-    
-    
-    // --------------------------------------------------------- Public Methods
-    
-    /**
-     * Register all cross context sessions inside endAccess.
-     * Use a list with contains check, that the Portlet API can include a lot of fragments from same or
-     * different applications with session changes.
-     *
-     * @param session cross context session
-     */
-    public void registerReplicationSession(DeltaSession session) {
-        List sessions = (List)crossContextSessions.get();
-        if(sessions != null) {
-            if(!sessions.contains(session)) {
-                if(log.isDebugEnabled())
-                    log.debug(sm.getString("ReplicationValve.crossContext.registerSession",
-                        session.getIdInternal(),
-                        session.getManager().getContainer().getName()));
-                sessions.add(session);
-            }
-        }
-    }
-
-    /**
-     * Log the interesting request parameters, invoke the next Valve in the
-     * sequence, and log the interesting response parameters.
-     *
-     * @param request The servlet request to be processed
-     * @param response The servlet response to be created
-     *
-     * @exception IOException if an input/output error occurs
-     * @exception ServletException if a servlet error occurs
-     */
-    public void invoke(Request request, Response response)
-        throws IOException, ServletException
-    {
-        long totalstart = 0;
-
-        //this happens before the request
-        if(doStatistics()) {
-            totalstart = System.currentTimeMillis();
-        }
-        if (primaryIndicator) {
-            createPrimaryIndicator(request) ;
-        }
-        Context context = request.getContext();
-        boolean isCrossContext = context != null
-                && context instanceof StandardContext
-                && ((StandardContext) context).getCrossContext();
-        try {
-            if(isCrossContext) {
-                if(log.isDebugEnabled())
-                    log.debug(sm.getString("ReplicationValve.crossContext.add"));
-                //FIXME add Pool of Arraylists
-                crossContextSessions.set(new ArrayList());
-            }
-            getNext().invoke(request, response);
-            Manager manager = request.getContext().getManager();
-            if (manager != null && manager instanceof ClusterManager) {
-                ClusterManager clusterManager = (ClusterManager) manager;
-                CatalinaCluster containerCluster = (CatalinaCluster) getContainer().getCluster();
-                if (containerCluster == null) {
-                    if (log.isWarnEnabled())
-                        log.warn(sm.getString("ReplicationValve.nocluster"));
-                    return;
-                }
-                // valve cluster can access manager - other cluster handle replication 
-                // at host level - hopefully!
-                if(containerCluster.getManager(clusterManager.getName()) == null)
-                    return ;
-                if(containerCluster.hasMembers()) {
-                    sendReplicationMessage(request, totalstart, isCrossContext, clusterManager, containerCluster);
-                } else {
-                    resetReplicationRequest(request,isCrossContext);
-                }        
-            }
-        } finally {
-            // Array must be remove: Current master request send endAccess at recycle. 
-            // Don't register this request session again!
-            if(isCrossContext) {
-                if(log.isDebugEnabled())
-                    log.debug(sm.getString("ReplicationValve.crossContext.remove"));
-                // crossContextSessions.remove() only exist at Java 5
-                // register ArrayList at a pool
-                crossContextSessions.set(null);
-            }
-        }
-    }
-
-    
-    /**
-     * reset the active statitics 
-     */
-    public void resetStatistics() {
-        totalRequestTime = 0 ;
-        totalSendTime = 0 ;
-        lastSendTime = 0 ;
-        nrOfFilterRequests = 0 ;
-        nrOfRequests = 0 ;
-        nrOfSendRequests = 0;
-        nrOfCrossContextSendRequests = 0;
-    }
-    
-    /**
-     * Return a String rendering of this object.
-     */
-    public String toString() {
-
-        StringBuffer sb = new StringBuffer("ReplicationValve[");
-        if (container != null)
-            sb.append(container.getName());
-        sb.append("]");
-        return (sb.toString());
-
-    }
-
-    // --------------------------------------------------------- Protected Methods
-
-    /**
-     * @param request
-     * @param totalstart
-     * @param isCrossContext
-     * @param clusterManager
-     * @param containerCluster
-     */
-    protected void sendReplicationMessage(Request request, long totalstart, boolean isCrossContext, ClusterManager clusterManager, CatalinaCluster containerCluster) {
-        //this happens after the request
-        long start = 0;
-        if(doStatistics()) {
-            start = System.currentTimeMillis();
-        }
-        try {
-            // send invalid sessions
-            // DeltaManager returns String[0]
-            if (!(clusterManager instanceof DeltaManager))
-                sendInvalidSessions(clusterManager, containerCluster);
-            // send replication
-            sendSessionReplicationMessage(request, clusterManager, containerCluster);
-            if(isCrossContext)
-                sendCrossContextSession(containerCluster);
-        } catch (Exception x) {
-            // FIXME we have a lot of sends, but the trouble with one node stops the correct replication to other nodes!
-            log.error(sm.getString("ReplicationValve.send.failure"), x);
-        } finally {
-            // FIXME this stats update are not cheap!!
-            if(doStatistics()) {
-                updateStats(totalstart,start);
-            }
-        }
-    }
-
-    /**
-     * Send all changed cross context sessions to backups
-     * @param containerCluster
-     */
-    protected void sendCrossContextSession(CatalinaCluster containerCluster) {
-        Object sessions = crossContextSessions.get();
-        if(sessions != null && sessions instanceof List
-                && ((List)sessions).size() >0) {
-            for(Iterator iter = ((List)sessions).iterator(); iter.hasNext() ;) {          
-                Session session = (Session)iter.next();
-                if(log.isDebugEnabled())
-                    log.debug(sm.getString("ReplicationValve.crossContext.sendDelta",  
-                            session.getManager().getContainer().getName() ));
-                sendMessage(session,(ClusterManager)session.getManager(),containerCluster);
-                if(doStatistics()) {
-                    nrOfCrossContextSendRequests++;
-                }
-            }
-        }
-    }
-  
-    /**
-     * Fix memory leak for long sessions with many changes, when no backup member exists!
-     * @param request current request after responce is generated
-     * @param isCrossContext check crosscontext threadlocal
-     */
-    protected void resetReplicationRequest(Request request, boolean isCrossContext) {
-        Session contextSession = request.getSessionInternal(false);
-        if(contextSession != null & contextSession instanceof DeltaSession){
-            resetDeltaRequest(contextSession);
-            ((DeltaSession)contextSession).setPrimarySession(true);
-        }
-        if(isCrossContext) {
-            Object sessions = crossContextSessions.get();
-            if(sessions != null && sessions instanceof List
-               && ((List)sessions).size() >0) {
-                Iterator iter = ((List)sessions).iterator();
-                for(; iter.hasNext() ;) {          
-                    Session session = (Session)iter.next();
-                    resetDeltaRequest(session);
-                    if(session instanceof DeltaSession)
-                        ((DeltaSession)contextSession).setPrimarySession(true);
-
-                }
-            }
-        }                     
-    }
-
-    /**
-     * Reset DeltaRequest from session
-     * @param session HttpSession from current request or cross context session
-     */
-    protected void resetDeltaRequest(Session session) {
-        if(log.isDebugEnabled()) {
-            log.debug(sm.getString("ReplicationValve.resetDeltaRequest" , 
-                session.getManager().getContainer().getName() ));
-        }
-        ((DeltaSession)session).resetDeltaRequest();
-    }
-
-    /**
-     * Send Cluster Replication Request
-     * @param request current request
-     * @param manager session manager
-     * @param cluster replication cluster
-     */
-    protected void sendSessionReplicationMessage(Request request,
-            ClusterManager manager, CatalinaCluster cluster) {
-        Session session = request.getSessionInternal(false);
-        if (session != null) {
-            String uri = request.getDecodedRequestURI();
-            // request without session change
-            if (!isRequestWithoutSessionChange(uri)) {
-                if (log.isDebugEnabled())
-                    log.debug(sm.getString("ReplicationValve.invoke.uri", uri));
-                sendMessage(session,manager,cluster);
-            } else
-                if(doStatistics())
-                    nrOfFilterRequests++;
-        }
-
-    }
-
-   /**
-    * Send message delta message from request session 
-    * @param request current request
-    * @param manager session manager
-    * @param cluster replication cluster
-    */
-    protected void sendMessage(Session session,
-             ClusterManager manager, CatalinaCluster cluster) {
-        String id = session.getIdInternal();
-        if (id != null) {
-            send(manager, cluster, id);
-        }
-    }
-
-    /**
-     * send manager requestCompleted message to cluster
-     * @param manager SessionManager
-     * @param cluster replication cluster
-     * @param sessionId sessionid from the manager
-     * @see DeltaManager#requestCompleted(String)
-     * @see SimpleTcpCluster#send(ClusterMessage)
-     */
-    protected void send(ClusterManager manager, CatalinaCluster cluster, String sessionId) {
-        ClusterMessage msg = manager.requestCompleted(sessionId);
-        if (msg != null) {
-            if(manager.doDomainReplication()) {
-                cluster.sendClusterDomain(msg);
-            } else {
-                cluster.send(msg);
-            }
-            if(doStatistics())
-                nrOfSendRequests++;
-        }
-    }
-    
-    /**
-     * check for session invalidations
-     * @param manager
-     * @param cluster
-     */
-    protected void sendInvalidSessions(ClusterManager manager, CatalinaCluster cluster) {
-        String[] invalidIds=manager.getInvalidatedSessions();
-        if ( invalidIds.length > 0 ) {
-            for ( int i=0;i<invalidIds.length; i++ ) {
-                try {
-                    send(manager,cluster,invalidIds[i]);
-                } catch ( Exception x ) {
-                    log.error(sm.getString("ReplicationValve.send.invalid.failure",invalidIds[i]),x);
-                }
-            }
-        }
-    }
-    
-    /**
-     * is request without possible session change
-     * @param uri The request uri
-     * @return True if no session change
-     */
-    protected boolean isRequestWithoutSessionChange(String uri) {
-
-        boolean filterfound = false;
-
-        for (int i = 0; (i < reqFilters.length) && (!filterfound); i++) {
-            java.util.regex.Matcher matcher = reqFilters[i].matcher(uri);
-            filterfound = matcher.matches();
-        }
-        return filterfound;
-    }
-
-    /**
-     * protocol cluster replications stats
-     * @param requestTime
-     * @param clusterTime
-     */
-    protected  void updateStats(long requestTime, long clusterTime) {
-        synchronized(this) {
-            lastSendTime=System.currentTimeMillis();
-            totalSendTime+=lastSendTime - clusterTime;
-            totalRequestTime+=lastSendTime - requestTime;
-            nrOfRequests++;
-        }
-        if(log.isInfoEnabled()) {
-            if ( (nrOfRequests % 100) == 0 ) {
-                 log.info(sm.getString("ReplicationValve.stats",
-                     new Object[]{
-                         new Long(totalRequestTime/nrOfRequests),
-                         new Long(totalSendTime/nrOfRequests),
-                         new Long(nrOfRequests),
-                         new Long(nrOfSendRequests),
-                         new Long(nrOfCrossContextSendRequests),
-                         new Long(nrOfFilterRequests),
-                         new Long(totalRequestTime),
-                         new Long(totalSendTime)}));
-             }
-        }
-    }
-
-
-    /**
-     * Mark Request that processed at primary node with attribute
-     * primaryIndicatorName
-     * 
-     * @param request
-     * @throws IOException
-     */
-    protected void createPrimaryIndicator(Request request) throws IOException {
-        String id = request.getRequestedSessionId();
-        if ((id != null) && (id.length() > 0)) {
-            Manager manager = request.getContext().getManager();
-            Session session = manager.findSession(id);
-            if (session instanceof ClusterSession) {
-                ClusterSession cses = (ClusterSession) session;
-                if (cses != null) {
-                    if (log.isDebugEnabled())
-                        log.debug(sm.getString(
-                                "ReplicationValve.session.indicator", request.getContext().getName(),id,
-                                primaryIndicatorName, cses.isPrimarySession()));
-                    request.setAttribute(primaryIndicatorName, cses.isPrimarySession()?Boolean.TRUE:Boolean.FALSE);
-                }
-            } else {
-                if (log.isDebugEnabled()) {
-                    if (session != null) {
-                        log.debug(sm.getString(
-                                "ReplicationValve.session.found", request.getContext().getName(),id));
-                    } else {
-                        log.debug(sm.getString(
-                                "ReplicationValve.session.invalid", request.getContext().getName(),id));
-                    }
-                }
-            }
-        }
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha.tcp;
+
+import java.io.IOException;
+import java.util.StringTokenizer;
+import java.util.regex.Pattern;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Iterator;
+import javax.servlet.ServletException;
+
+import org.apache.catalina.Manager;
+import org.apache.catalina.Session;
+import org.apache.catalina.Context;
+import org.apache.catalina.core.StandardContext;
+import org.apache.catalina.ha.CatalinaCluster;
+import org.apache.catalina.ha.ClusterManager;
+import org.apache.catalina.ha.ClusterMessage;
+import org.apache.catalina.ha.ClusterSession;
+import org.apache.catalina.ha.ClusterValve;
+import org.apache.catalina.ha.session.DeltaManager;
+import org.apache.catalina.ha.session.DeltaSession;
+import org.apache.catalina.connector.Request;
+import org.apache.catalina.connector.Response;
+import org.apache.catalina.util.StringManager;
+import org.apache.catalina.valves.ValveBase;
+
+/**
+ * <p>Implementation of a Valve that logs interesting contents from the
+ * specified Request (before processing) and the corresponding Response
+ * (after processing).  It is especially useful in debugging problems
+ * related to headers and cookies.</p>
+ *
+ * <p>This Valve may be attached to any Container, depending on the granularity
+ * of the logging you wish to perform.</p>
+ *
+ * <p>primaryIndicator=true, then the request attribute <i>org.apache.catalina.ha.tcp.isPrimarySession.</i>
+ * is set true, when request processing is at sessions primary node.
+ * </p>
+ *
+ * @author Craig R. McClanahan
+ * @author Filip Hanik
+ * @author Peter Rossbach
+ * @version $Revision$ $Date$
+ */
+
+public class ReplicationValve
+    extends ValveBase implements ClusterValve {
+    
+    private static org.apache.juli.logging.Log log =
+        org.apache.juli.logging.LogFactory.getLog( ReplicationValve.class );
+
+    // ----------------------------------------------------- Instance Variables
+
+    /**
+     * The descriptive information related to this implementation.
+     */
+    private static final String info =
+        "org.apache.catalina.ha.tcp.ReplicationValve/2.0";
+
+
+    /**
+     * The StringManager for this package.
+     */
+    protected static StringManager sm =
+        StringManager.getManager(Constants.Package);
+
+    private CatalinaCluster cluster = null ;
+
+    /**
+     * holds file endings to not call for like images and others
+     */
+    protected java.util.regex.Pattern[] reqFilters = new java.util.regex.Pattern[0];
+    
+    /**
+     * Orginal filter 
+     */
+    protected String filter ;
+    
+    /**
+     * crossContext session container 
+     */
+    protected ThreadLocal crossContextSessions = new ThreadLocal() ;
+    
+    /**
+     * doProcessingStats (default = off)
+     */
+    protected boolean doProcessingStats = false;
+    
+    protected long totalRequestTime = 0;
+    protected long totalSendTime = 0;
+    protected long nrOfRequests = 0;
+    protected long lastSendTime = 0;
+    protected long nrOfFilterRequests = 0;
+    protected long nrOfSendRequests = 0;
+    protected long nrOfCrossContextSendRequests = 0;
+    
+    /**
+     * must primary change indicator set 
+     */
+    protected boolean primaryIndicator = false ;
+    
+    /**
+     * Name of primary change indicator as request attribute
+     */
+    protected String primaryIndicatorName = "org.apache.catalina.ha.tcp.isPrimarySession";
+   
+    // ------------------------------------------------------------- Properties
+
+    public ReplicationValve() {
+    }
+    
+    /**
+     * Return descriptive information about this Valve implementation.
+     */
+    public String getInfo() {
+
+        return (info);
+
+    }
+    
+    /**
+     * @return Returns the cluster.
+     */
+    public CatalinaCluster getCluster() {
+        return cluster;
+    }
+    
+    /**
+     * @param cluster The cluster to set.
+     */
+    public void setCluster(CatalinaCluster cluster) {
+        this.cluster = cluster;
+    }
+ 
+    /**
+     * @return Returns the filter
+     */
+    public String getFilter() {
+       return filter ;
+    }
+
+    /**
+     * compile filter string to regular expressions
+     * @see Pattern#compile(java.lang.String)
+     * @param filter
+     *            The filter to set.
+     */
+    public void setFilter(String filter) {
+        if (log.isDebugEnabled())
+            log.debug(sm.getString("ReplicationValve.filter.loading", filter));
+        this.filter = filter;
+        StringTokenizer t = new StringTokenizer(filter, ";");
+        this.reqFilters = new Pattern[t.countTokens()];
+        int i = 0;
+        while (t.hasMoreTokens()) {
+            String s = t.nextToken();
+            if (log.isTraceEnabled())
+                log.trace(sm.getString("ReplicationValve.filter.token", s));
+            try {
+                reqFilters[i++] = Pattern.compile(s);
+            } catch (Exception x) {
+                log.error(sm.getString("ReplicationValve.filter.token.failure",
+                        s), x);
+            }
+        }
+    }
+
+    /**
+     * @return Returns the primaryIndicator.
+     */
+    public boolean isPrimaryIndicator() {
+        return primaryIndicator;
+    }
+
+    /**
+     * @param primaryIndicator The primaryIndicator to set.
+     */
+    public void setPrimaryIndicator(boolean primaryIndicator) {
+        this.primaryIndicator = primaryIndicator;
+    }
+    
+    /**
+     * @return Returns the primaryIndicatorName.
+     */
+    public String getPrimaryIndicatorName() {
+        return primaryIndicatorName;
+    }
+    
+    /**
+     * @param primaryIndicatorName The primaryIndicatorName to set.
+     */
+    public void setPrimaryIndicatorName(String primaryIndicatorName) {
+        this.primaryIndicatorName = primaryIndicatorName;
+    }
+    
+    /**
+     * Calc processing stats
+     */
+    public boolean doStatistics() {
+        return doProcessingStats;
+    }
+
+    /**
+     * Set Calc processing stats
+     * @see #resetStatistics()
+     */
+    public void setStatistics(boolean doProcessingStats) {
+        this.doProcessingStats = doProcessingStats;
+    }
+
+    /**
+     * @return Returns the lastSendTime.
+     */
+    public long getLastSendTime() {
+        return lastSendTime;
+    }
+    
+    /**
+     * @return Returns the nrOfRequests.
+     */
+    public long getNrOfRequests() {
+        return nrOfRequests;
+    }
+    
+    /**
+     * @return Returns the nrOfFilterRequests.
+     */
+    public long getNrOfFilterRequests() {
+        return nrOfFilterRequests;
+    }
+
+    /**
+     * @return Returns the nrOfCrossContextSendRequests.
+     */
+    public long getNrOfCrossContextSendRequests() {
+        return nrOfCrossContextSendRequests;
+    }
+
+    /**
+     * @return Returns the nrOfSendRequests.
+     */
+    public long getNrOfSendRequests() {
+        return nrOfSendRequests;
+    }
+
+    /**
+     * @return Returns the totalRequestTime.
+     */
+    public long getTotalRequestTime() {
+        return totalRequestTime;
+    }
+    
+    /**
+     * @return Returns the totalSendTime.
+     */
+    public long getTotalSendTime() {
+        return totalSendTime;
+    }
+
+    /**
+     * @return Returns the reqFilters.
+     */
+    protected java.util.regex.Pattern[] getReqFilters() {
+        return reqFilters;
+    }
+    
+    /**
+     * @param reqFilters The reqFilters to set.
+     */
+    protected void setReqFilters(java.util.regex.Pattern[] reqFilters) {
+        this.reqFilters = reqFilters;
+    }
+    
+    
+    // --------------------------------------------------------- Public Methods
+    
+    /**
+     * Register all cross context sessions inside endAccess.
+     * Use a list with contains check, that the Portlet API can include a lot of fragments from same or
+     * different applications with session changes.
+     *
+     * @param session cross context session
+     */
+    public void registerReplicationSession(DeltaSession session) {
+        List sessions = (List)crossContextSessions.get();
+        if(sessions != null) {
+            if(!sessions.contains(session)) {
+                if(log.isDebugEnabled())
+                    log.debug(sm.getString("ReplicationValve.crossContext.registerSession",
+                        session.getIdInternal(),
+                        session.getManager().getContainer().getName()));
+                sessions.add(session);
+            }
+        }
+    }
+
+    /**
+     * Log the interesting request parameters, invoke the next Valve in the
+     * sequence, and log the interesting response parameters.
+     *
+     * @param request The servlet request to be processed
+     * @param response The servlet response to be created
+     *
+     * @exception IOException if an input/output error occurs
+     * @exception ServletException if a servlet error occurs
+     */
+    public void invoke(Request request, Response response)
+        throws IOException, ServletException
+    {
+        long totalstart = 0;
+
+        //this happens before the request
+        if(doStatistics()) {
+            totalstart = System.currentTimeMillis();
+        }
+        if (primaryIndicator) {
+            createPrimaryIndicator(request) ;
+        }
+        Context context = request.getContext();
+        boolean isCrossContext = context != null
+                && context instanceof StandardContext
+                && ((StandardContext) context).getCrossContext();
+        try {
+            if(isCrossContext) {
+                if(log.isDebugEnabled())
+                    log.debug(sm.getString("ReplicationValve.crossContext.add"));
+                //FIXME add Pool of Arraylists
+                crossContextSessions.set(new ArrayList());
+            }
+            getNext().invoke(request, response);
+            Manager manager = request.getContext().getManager();
+            if (manager != null && manager instanceof ClusterManager) {
+                ClusterManager clusterManager = (ClusterManager) manager;
+                CatalinaCluster containerCluster = (CatalinaCluster) getContainer().getCluster();
+                if (containerCluster == null) {
+                    if (log.isWarnEnabled())
+                        log.warn(sm.getString("ReplicationValve.nocluster"));
+                    return;
+                }
+                // valve cluster can access manager - other cluster handle replication 
+                // at host level - hopefully!
+                if(containerCluster.getManager(clusterManager.getName()) == null)
+                    return ;
+                if(containerCluster.hasMembers()) {
+                    sendReplicationMessage(request, totalstart, isCrossContext, clusterManager, containerCluster);
+                } else {
+                    resetReplicationRequest(request,isCrossContext);
+                }        
+            }
+        } finally {
+            // Array must be remove: Current master request send endAccess at recycle. 
+            // Don't register this request session again!
+            if(isCrossContext) {
+                if(log.isDebugEnabled())
+                    log.debug(sm.getString("ReplicationValve.crossContext.remove"));
+                // crossContextSessions.remove() only exist at Java 5
+                // register ArrayList at a pool
+                crossContextSessions.set(null);
+            }
+        }
+    }
+
+    
+    /**
+     * reset the active statitics 
+     */
+    public void resetStatistics() {
+        totalRequestTime = 0 ;
+        totalSendTime = 0 ;
+        lastSendTime = 0 ;
+        nrOfFilterRequests = 0 ;
+        nrOfRequests = 0 ;
+        nrOfSendRequests = 0;
+        nrOfCrossContextSendRequests = 0;
+    }
+    
+    /**
+     * Return a String rendering of this object.
+     */
+    public String toString() {
+
+        StringBuffer sb = new StringBuffer("ReplicationValve[");
+        if (container != null)
+            sb.append(container.getName());
+        sb.append("]");
+        return (sb.toString());
+
+    }
+
+    // --------------------------------------------------------- Protected Methods
+
+    /**
+     * @param request
+     * @param totalstart
+     * @param isCrossContext
+     * @param clusterManager
+     * @param containerCluster
+     */
+    protected void sendReplicationMessage(Request request, long totalstart, boolean isCrossContext, ClusterManager clusterManager, CatalinaCluster containerCluster) {
+        //this happens after the request
+        long start = 0;
+        if(doStatistics()) {
+            start = System.currentTimeMillis();
+        }
+        try {
+            // send invalid sessions
+            // DeltaManager returns String[0]
+            if (!(clusterManager instanceof DeltaManager))
+                sendInvalidSessions(clusterManager, containerCluster);
+            // send replication
+            sendSessionReplicationMessage(request, clusterManager, containerCluster);
+            if(isCrossContext)
+                sendCrossContextSession(containerCluster);
+        } catch (Exception x) {
+            // FIXME we have a lot of sends, but the trouble with one node stops the correct replication to other nodes!
+            log.error(sm.getString("ReplicationValve.send.failure"), x);
+        } finally {
+            // FIXME this stats update are not cheap!!
+            if(doStatistics()) {
+                updateStats(totalstart,start);
+            }
+        }
+    }
+
+    /**
+     * Send all changed cross context sessions to backups
+     * @param containerCluster
+     */
+    protected void sendCrossContextSession(CatalinaCluster containerCluster) {
+        Object sessions = crossContextSessions.get();
+        if(sessions != null && sessions instanceof List
+                && ((List)sessions).size() >0) {
+            for(Iterator iter = ((List)sessions).iterator(); iter.hasNext() ;) {          
+                Session session = (Session)iter.next();
+                if(log.isDebugEnabled())
+                    log.debug(sm.getString("ReplicationValve.crossContext.sendDelta",  
+                            session.getManager().getContainer().getName() ));
+                sendMessage(session,(ClusterManager)session.getManager(),containerCluster);
+                if(doStatistics()) {
+                    nrOfCrossContextSendRequests++;
+                }
+            }
+        }
+    }
+  
+    /**
+     * Fix memory leak for long sessions with many changes, when no backup member exists!
+     * @param request current request after responce is generated
+     * @param isCrossContext check crosscontext threadlocal
+     */
+    protected void resetReplicationRequest(Request request, boolean isCrossContext) {
+        Session contextSession = request.getSessionInternal(false);
+        if(contextSession != null & contextSession instanceof DeltaSession){
+            resetDeltaRequest(contextSession);
+            ((DeltaSession)contextSession).setPrimarySession(true);
+        }
+        if(isCrossContext) {
+            Object sessions = crossContextSessions.get();
+            if(sessions != null && sessions instanceof List
+               && ((List)sessions).size() >0) {
+                Iterator iter = ((List)sessions).iterator();
+                for(; iter.hasNext() ;) {          
+                    Session session = (Session)iter.next();
+                    resetDeltaRequest(session);
+                    if(session instanceof DeltaSession)
+                        ((DeltaSession)contextSession).setPrimarySession(true);
+
+                }
+            }
+        }                     
+    }
+
+    /**
+     * Reset DeltaRequest from session
+     * @param session HttpSession from current request or cross context session
+     */
+    protected void resetDeltaRequest(Session session) {
+        if(log.isDebugEnabled()) {
+            log.debug(sm.getString("ReplicationValve.resetDeltaRequest" , 
+                session.getManager().getContainer().getName() ));
+        }
+        ((DeltaSession)session).resetDeltaRequest();
+    }
+
+    /**
+     * Send Cluster Replication Request
+     * @param request current request
+     * @param manager session manager
+     * @param cluster replication cluster
+     */
+    protected void sendSessionReplicationMessage(Request request,
+            ClusterManager manager, CatalinaCluster cluster) {
+        Session session = request.getSessionInternal(false);
+        if (session != null) {
+            String uri = request.getDecodedRequestURI();
+            // request without session change
+            if (!isRequestWithoutSessionChange(uri)) {
+                if (log.isDebugEnabled())
+                    log.debug(sm.getString("ReplicationValve.invoke.uri", uri));
+                sendMessage(session,manager,cluster);
+            } else
+                if(doStatistics())
+                    nrOfFilterRequests++;
+        }
+
+    }
+
+   /**
+    * Send message delta message from request session 
+    * @param request current request
+    * @param manager session manager
+    * @param cluster replication cluster
+    */
+    protected void sendMessage(Session session,
+             ClusterManager manager, CatalinaCluster cluster) {
+        String id = session.getIdInternal();
+        if (id != null) {
+            send(manager, cluster, id);
+        }
+    }
+
+    /**
+     * send manager requestCompleted message to cluster
+     * @param manager SessionManager
+     * @param cluster replication cluster
+     * @param sessionId sessionid from the manager
+     * @see DeltaManager#requestCompleted(String)
+     * @see SimpleTcpCluster#send(ClusterMessage)
+     */
+    protected void send(ClusterManager manager, CatalinaCluster cluster, String sessionId) {
+        ClusterMessage msg = manager.requestCompleted(sessionId);
+        if (msg != null) {
+            if(manager.doDomainReplication()) {
+                cluster.sendClusterDomain(msg);
+            } else {
+                cluster.send(msg);
+            }
+            if(doStatistics())
+                nrOfSendRequests++;
+        }
+    }
+    
+    /**
+     * check for session invalidations
+     * @param manager
+     * @param cluster
+     */
+    protected void sendInvalidSessions(ClusterManager manager, CatalinaCluster cluster) {
+        String[] invalidIds=manager.getInvalidatedSessions();
+        if ( invalidIds.length > 0 ) {
+            for ( int i=0;i<invalidIds.length; i++ ) {
+                try {
+                    send(manager,cluster,invalidIds[i]);
+                } catch ( Exception x ) {
+                    log.error(sm.getString("ReplicationValve.send.invalid.failure",invalidIds[i]),x);
+                }
+            }
+        }
+    }
+    
+    /**
+     * is request without possible session change
+     * @param uri The request uri
+     * @return True if no session change
+     */
+    protected boolean isRequestWithoutSessionChange(String uri) {
+
+        boolean filterfound = false;
+
+        for (int i = 0; (i < reqFilters.length) && (!filterfound); i++) {
+            java.util.regex.Matcher matcher = reqFilters[i].matcher(uri);
+            filterfound = matcher.matches();
+        }
+        return filterfound;
+    }
+
+    /**
+     * protocol cluster replications stats
+     * @param requestTime
+     * @param clusterTime
+     */
+    protected  void updateStats(long requestTime, long clusterTime) {
+        synchronized(this) {
+            lastSendTime=System.currentTimeMillis();
+            totalSendTime+=lastSendTime - clusterTime;
+            totalRequestTime+=lastSendTime - requestTime;
+            nrOfRequests++;
+        }
+        if(log.isInfoEnabled()) {
+            if ( (nrOfRequests % 100) == 0 ) {
+                 log.info(sm.getString("ReplicationValve.stats",
+                     new Object[]{
+                         new Long(totalRequestTime/nrOfRequests),
+                         new Long(totalSendTime/nrOfRequests),
+                         new Long(nrOfRequests),
+                         new Long(nrOfSendRequests),
+                         new Long(nrOfCrossContextSendRequests),
+                         new Long(nrOfFilterRequests),
+                         new Long(totalRequestTime),
+                         new Long(totalSendTime)}));
+             }
+        }
+    }
+
+
+    /**
+     * Mark Request that processed at primary node with attribute
+     * primaryIndicatorName
+     * 
+     * @param request
+     * @throws IOException
+     */
+    protected void createPrimaryIndicator(Request request) throws IOException {
+        String id = request.getRequestedSessionId();
+        if ((id != null) && (id.length() > 0)) {
+            Manager manager = request.getContext().getManager();
+            Session session = manager.findSession(id);
+            if (session instanceof ClusterSession) {
+                ClusterSession cses = (ClusterSession) session;
+                if (cses != null) {
+                    if (log.isDebugEnabled())
+                        log.debug(sm.getString(
+                                "ReplicationValve.session.indicator", request.getContext().getName(),id,
+                                primaryIndicatorName, cses.isPrimarySession()));
+                    request.setAttribute(primaryIndicatorName, cses.isPrimarySession()?Boolean.TRUE:Boolean.FALSE);
+                }
+            } else {
+                if (log.isDebugEnabled()) {
+                    if (session != null) {
+                        log.debug(sm.getString(
+                                "ReplicationValve.session.found", request.getContext().getName(),id));
+                    } else {
+                        log.debug(sm.getString(
+                                "ReplicationValve.session.invalid", request.getContext().getName(),id));
+                    }
+                }
+            }
+        }
+    }
+
+}

==================================================
SimpleTcpCluster.java
index 4fa914f44a..79f5cc4d50 100644
--- a/java/org/apache/catalina/ha/tcp/SendMessageData.java
+++ b/java/org/apache/catalina/ha/tcp/SendMessageData.java
@@ -20,7 +20,7 @@ import org.apache.catalina.tribes.Member;
 
 /**
  * @author Peter Rossbach
- * @version $Revision: 303987 $ $Date: 2005-07-08 15:50:30 -0500 (Fri, 08 Jul 2005) $
+ * @version $Revision$ $Date$
  */
 public class SendMessageData {
 

==================================================
IDynamicProperty.java
index be8c8fc244..ae5e342e25 100644
--- a/java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java
+++ b/java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java
@@ -1,956 +1,956 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha.tcp;
-
-import java.beans.PropertyChangeSupport;
-import java.io.IOException;
-import java.io.Serializable;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-import org.apache.catalina.Container;
-import org.apache.catalina.Context;
-import org.apache.catalina.Engine;
-import org.apache.catalina.Host;
-import org.apache.catalina.Lifecycle;
-import org.apache.catalina.LifecycleEvent;
-import org.apache.catalina.LifecycleException;
-import org.apache.catalina.LifecycleListener;
-import org.apache.catalina.Manager;
-import org.apache.catalina.Valve;
-import org.apache.catalina.ha.CatalinaCluster;
-import org.apache.catalina.ha.ClusterListener;
-import org.apache.catalina.ha.ClusterManager;
-import org.apache.catalina.ha.ClusterMessage;
-import org.apache.catalina.ha.ClusterValve;
-import org.apache.catalina.ha.session.DeltaManager;
-import org.apache.catalina.ha.util.IDynamicProperty;
-import org.apache.catalina.tribes.Channel;
-import org.apache.catalina.tribes.ChannelListener;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.MembershipListener;
-import org.apache.catalina.tribes.group.GroupChannel;
-import org.apache.catalina.util.LifecycleSupport;
-import org.apache.catalina.util.StringManager;
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-import org.apache.tomcat.util.IntrospectionUtils;
-import org.apache.catalina.ha.session.ClusterSessionListener;
-import org.apache.catalina.tribes.group.interceptors.MessageDispatch15Interceptor;
-import org.apache.catalina.tribes.group.interceptors.TcpFailureDetector;
-import org.apache.catalina.ha.session.JvmRouteBinderValve;
-import org.apache.catalina.ha.session.JvmRouteSessionIDBinderListener;
-
-/**
- * A <b>Cluster </b> implementation using simple multicast. Responsible for
- * setting up a cluster and provides callers with a valid multicast
- * receiver/sender.
- * 
- * FIXME remove install/remove/start/stop context dummys
- * FIXME wrote testcases 
- * 
- * @author Filip Hanik
- * @author Remy Maucherat
- * @author Peter Rossbach
- * @version $Revision: 379550 $, $Date: 2006-02-21 12:06:35 -0600 (Tue, 21 Feb 2006) $
- */
-public class SimpleTcpCluster 
-    implements CatalinaCluster, Lifecycle, LifecycleListener, IDynamicProperty,
-               MembershipListener, ChannelListener{
-
-    public static Log log = LogFactory.getLog(SimpleTcpCluster.class);
-
-    // ----------------------------------------------------- Instance Variables
-
-    /**
-     * Descriptive information about this component implementation.
-     */
-    protected static final String info = "SimpleTcpCluster/2.2";
-
-    public static final String BEFORE_MEMBERREGISTER_EVENT = "before_member_register";
-
-    public static final String AFTER_MEMBERREGISTER_EVENT = "after_member_register";
-
-    public static final String BEFORE_MANAGERREGISTER_EVENT = "before_manager_register";
-
-    public static final String AFTER_MANAGERREGISTER_EVENT = "after_manager_register";
-
-    public static final String BEFORE_MANAGERUNREGISTER_EVENT = "before_manager_unregister";
-
-    public static final String AFTER_MANAGERUNREGISTER_EVENT = "after_manager_unregister";
-
-    public static final String BEFORE_MEMBERUNREGISTER_EVENT = "before_member_unregister";
-
-    public static final String AFTER_MEMBERUNREGISTER_EVENT = "after_member_unregister";
-
-    public static final String SEND_MESSAGE_FAILURE_EVENT = "send_message_failure";
-
-    public static final String RECEIVE_MESSAGE_FAILURE_EVENT = "receive_message_failure";
-    
-    /**
-     * Group channel.
-     */
-    protected Channel channel = new GroupChannel();
-
-
-    /**
-     * Name for logging purpose
-     */
-    protected String clusterImpName = "SimpleTcpCluster";
-
-    /**
-     * The string manager for this package.
-     */
-    protected StringManager sm = StringManager.getManager(Constants.Package);
-
-    /**
-     * The cluster name to join
-     */
-    protected String clusterName ;
-
-    /**
-     * The Container associated with this Cluster.
-     */
-    protected Container container = null;
-
-    /**
-     * The lifecycle event support for this component.
-     */
-    protected LifecycleSupport lifecycle = new LifecycleSupport(this);
-
-    /**
-     * Has this component been started?
-     */
-    protected boolean started = false;
-
-    /**
-     * The property change support for this component.
-     */
-    protected PropertyChangeSupport support = new PropertyChangeSupport(this);
-
-    /**
-     * The context name <->manager association for distributed contexts.
-     */
-    protected Map managers = new HashMap();
-
-    protected ClusterManager managerTemplate = new DeltaManager();
-
-    private List valves = new ArrayList();
-
-    private org.apache.catalina.ha.ClusterDeployer clusterDeployer;
-
-    /**
-     * Listeners of messages
-     */
-    protected List clusterListeners = new ArrayList();
-
-    /**
-     * Comment for <code>notifyLifecycleListenerOnFailure</code>
-     */
-    private boolean notifyLifecycleListenerOnFailure = false;
-
-    /**
-     * dynamic sender <code>properties</code>
-     */
-    private Map properties = new HashMap();
-    
-    private int channelSendOptions = Channel.SEND_OPTIONS_ASYNCHRONOUS;
-
-    // ------------------------------------------------------------- Properties
-
-    public SimpleTcpCluster() {
-    }
-
-    /**
-     * Return descriptive information about this Cluster implementation and the
-     * corresponding version number, in the format
-     * <code>&lt;description&gt;/&lt;version&gt;</code>.
-     */
-    public String getInfo() {
-        return (info);
-    }
-
-    /**
-     * Set the name of the cluster to join, if no cluster with this name is
-     * present create one.
-     * 
-     * @param clusterName
-     *            The clustername to join
-     */
-    public void setClusterName(String clusterName) {
-        this.clusterName = clusterName;
-    }
-
-    /**
-     * Return the name of the cluster that this Server is currently configured
-     * to operate within.
-     * 
-     * @return The name of the cluster associated with this server
-     */
-    public String getClusterName() {
-        if(clusterName == null && container != null)
-            return container.getName() ;
-        return clusterName;
-    }
-
-    /**
-     * Set the Container associated with our Cluster
-     * 
-     * @param container
-     *            The Container to use
-     */
-    public void setContainer(Container container) {
-        Container oldContainer = this.container;
-        this.container = container;
-        support.firePropertyChange("container", oldContainer, this.container);
-    }
-
-    /**
-     * Get the Container associated with our Cluster
-     * 
-     * @return The Container associated with our Cluster
-     */
-    public Container getContainer() {
-        return (this.container);
-    }
-
-    /**
-     * @return Returns the notifyLifecycleListenerOnFailure.
-     */
-    public boolean isNotifyLifecycleListenerOnFailure() {
-        return notifyLifecycleListenerOnFailure;
-    }
-
-    /**
-     * @param notifyListenerOnFailure
-     *            The notifyLifecycleListenerOnFailure to set.
-     */
-    public void setNotifyLifecycleListenerOnFailure(
-            boolean notifyListenerOnFailure) {
-        boolean oldNotifyListenerOnFailure = this.notifyLifecycleListenerOnFailure;
-        this.notifyLifecycleListenerOnFailure = notifyListenerOnFailure;
-        support.firePropertyChange("notifyLifecycleListenerOnFailure",
-                oldNotifyListenerOnFailure,
-                this.notifyLifecycleListenerOnFailure);
-    }
-
-    /**
-     * @deprecated use getManagerTemplate().getClass().getName() instead.
-     * @return String
-     */
-    public String getManagerClassName() {
-        return managerTemplate.getClass().getName();
-    }
-
-    /**
-     * @deprecated use nested &lt;Manager&gt; element inside the cluster config instead.
-     * @param managerClassName String
-     */
-    public void setManagerClassName(String managerClassName) {
-        log.warn("setManagerClassName is deprecated, use nested <Manager> element inside the <Cluster> element instead, this request will be ignored.");
-    }
-
-    /**
-     * Add cluster valve 
-     * Cluster Valves are only add to container when cluster is started!
-     * @param valve The new cluster Valve.
-     */
-    public void addValve(Valve valve) {
-        if (valve instanceof ClusterValve && (!valves.contains(valve)))
-            valves.add(valve);
-    }
-
-    /**
-     * get all cluster valves
-     * @return current cluster valves
-     */
-    public Valve[] getValves() {
-        return (Valve[]) valves.toArray(new Valve[valves.size()]);
-    }
-
-    /**
-     * Get the cluster listeners associated with this cluster. If this Array has
-     * no listeners registered, a zero-length array is returned.
-     */
-    public ClusterListener[] findClusterListeners() {
-        if (clusterListeners.size() > 0) {
-            ClusterListener[] listener = new ClusterListener[clusterListeners.size()];
-            clusterListeners.toArray(listener);
-            return listener;
-        } else
-            return new ClusterListener[0];
-
-    }
-
-    /**
-     * add cluster message listener and register cluster to this listener
-     * 
-     * @see org.apache.catalina.ha.CatalinaCluster#addClusterListener(org.apache.catalina.ha.MessageListener)
-     */
-    public void addClusterListener(ClusterListener listener) {
-        if (listener != null && !clusterListeners.contains(listener)) {
-            clusterListeners.add(listener);
-            listener.setCluster(this);
-        }
-    }
-
-    /**
-     * remove message listener and deregister Cluster from listener
-     * 
-     * @see org.apache.catalina.ha.CatalinaCluster#removeClusterListener(org.apache.catalina.ha.MessageListener)
-     */
-    public void removeClusterListener(ClusterListener listener) {
-        if (listener != null) {
-            clusterListeners.remove(listener);
-            listener.setCluster(null);
-        }
-    }
-
-    /**
-     * get current Deployer
-     */
-    public org.apache.catalina.ha.ClusterDeployer getClusterDeployer() {
-        return clusterDeployer;
-    }
-
-    /**
-     * set a new Deployer, must be set before cluster started!
-     */
-    public void setClusterDeployer(
-            org.apache.catalina.ha.ClusterDeployer clusterDeployer) {
-        this.clusterDeployer = clusterDeployer;
-    }
-
-    public void setChannel(Channel channel) {
-        this.channel = channel;
-    }
-
-    public void setManagerTemplate(ClusterManager managerTemplate) {
-        this.managerTemplate = managerTemplate;
-    }
-
-    public void setChannelSendOptions(int channelSendOptions) {
-        this.channelSendOptions = channelSendOptions;
-    }
-
-    /**
-     * has members
-     */
-    protected boolean hasMembers = false;
-    public boolean hasMembers() {
-        return hasMembers;
-    }
-    
-    /**
-     * Get all current cluster members
-     * @return all members or empty array 
-     */
-    public Member[] getMembers() {
-        return channel.getMembers();
-    }
-
-    /**
-     * Return the member that represents this node.
-     * 
-     * @return Member
-     */
-    public Member getLocalMember() {
-        return channel.getLocalMember(true);
-    }
-
-    // ------------------------------------------------------------- dynamic
-    // manager property handling
-
-    /**
-     * JMX hack to direct use at jconsole
-     * 
-     * @param name
-     * @param value
-     */
-    public void setProperty(String name, String value) {
-        setProperty(name, (Object) value);
-    }
-
-    /**
-     * set config attributes with reflect and propagate to all managers
-     * 
-     * @param name
-     * @param value
-     */
-    public void setProperty(String name, Object value) {
-        if (log.isTraceEnabled())
-            log.trace(sm.getString("SimpleTcpCluster.setProperty", name, value,properties.get(name)));
-        properties.put(name, value);
-        //using a dynamic way of setting properties is nice, but a security risk
-        //if exposed through JMX. This way you can sit and try to guess property names,
-        //we will only allow explicit property names
-        log.warn("Dynamic setProperty("+name+",value) has been disabled, please use explicit properties for the element you are trying to identify");
-        if(started) {
-            // FIXME Hmm, is that correct when some DeltaManagers are direct configured inside Context?
-            // Why we not support it for other elements, like sender, receiver or membership?
-            // Must we restart element after change?
-//            if (name.startsWith("manager")) {
-//                String key = name.substring("manager".length() + 1);
-//                String pvalue = value.toString();
-//                for (Iterator iter = managers.values().iterator(); iter.hasNext();) {
-//                    Manager manager = (Manager) iter.next();
-//                    if(manager instanceof DeltaManager && ((ClusterManager) manager).isDefaultMode()) {
-//                        IntrospectionUtils.setProperty(manager, key, pvalue );
-//                    }
-//                }
-//            } 
-        }
-    }
-
-    /**
-     * get current config
-     * 
-     * @param key
-     * @return The property
-     */
-    public Object getProperty(String key) {
-        if (log.isTraceEnabled())
-            log.trace(sm.getString("SimpleTcpCluster.getProperty", key));
-        return properties.get(key);
-    }
-
-    /**
-     * Get all properties keys
-     * 
-     * @return An iterator over the property names.
-     */
-    public Iterator getPropertyNames() {
-        return properties.keySet().iterator();
-    }
-
-    /**
-     * remove a configured property.
-     * 
-     * @param key
-     */
-    public void removeProperty(String key) {
-        properties.remove(key);
-    }
-
-    /**
-     * transfer properties from cluster configuration to subelement bean.
-     * @param prefix
-     * @param bean
-     */
-    protected void transferProperty(String prefix, Object bean) {
-        if (prefix != null) {
-            for (Iterator iter = getPropertyNames(); iter.hasNext();) {
-                String pkey = (String) iter.next();
-                if (pkey.startsWith(prefix)) {
-                    String key = pkey.substring(prefix.length() + 1);
-                    Object value = getProperty(pkey);
-                    IntrospectionUtils.setProperty(bean, key, value.toString());
-                }
-            }
-        }
-    }
-
-    // --------------------------------------------------------- Public Methods
-
-    /**
-     * @return Returns the managers.
-     */
-    public Map getManagers() {
-        return managers;
-    }
-
-    public Channel getChannel() {
-        return channel;
-    }
-
-    public ClusterManager getManagerTemplate() {
-        return managerTemplate;
-    }
-
-    public int getChannelSendOptions() {
-        return channelSendOptions;
-    }
-
-    /**
-     * Create new Manager without add to cluster (comes with start the manager)
-     * 
-     * @param name
-     *            Context Name of this manager
-     * @see org.apache.catalina.Cluster#createManager(java.lang.String)
-     * @see #addManager(String, Manager)
-     * @see DeltaManager#start()
-     */
-    public synchronized Manager createManager(String name) {
-        if (log.isDebugEnabled()) log.debug("Creating ClusterManager for context " + name + " using class " + getManagerClassName());
-        Manager manager = null;
-        try {
-            manager = managerTemplate.cloneFromTemplate();
-            ((ClusterManager)manager).setName(name);
-        } catch (Exception x) {
-            log.error("Unable to clone cluster manager, defaulting to org.apache.catalina.ha.session.DeltaManager", x);
-            manager = new org.apache.catalina.ha.session.DeltaManager();
-        } finally {
-            if ( manager != null && (manager instanceof ClusterManager)) ((ClusterManager)manager).setCluster(this);
-        }
-        return manager;
-    }
-    
-    public void registerManager(Manager manager) {
-    
-        if (! (manager instanceof ClusterManager)) {
-            log.warn("Manager [ " + manager + "] does not implement ClusterManager, addition to cluster has been aborted.");
-            return;
-        }
-        ClusterManager cmanager = (ClusterManager) manager ;
-        cmanager.setDistributable(true);
-        // Notify our interested LifecycleListeners
-        lifecycle.fireLifecycleEvent(BEFORE_MANAGERREGISTER_EVENT, manager);
-        String clusterName = getManagerName(cmanager.getName(), manager);
-        cmanager.setName(clusterName);
-        cmanager.setCluster(this);
-        cmanager.setDefaultMode(false);
-    
-        managers.put(clusterName, manager);
-        // Notify our interested LifecycleListeners
-        lifecycle.fireLifecycleEvent(AFTER_MANAGERREGISTER_EVENT, manager);    
-    }
-
-    /**
-     * remove an application form cluster replication bus
-     * 
-     * @see org.apache.catalina.ha.CatalinaCluster#removeManager(java.lang.String,Manager)
-     */
-    public void removeManager(Manager manager) {
-        if (manager != null && manager instanceof ClusterManager ) {
-            ClusterManager cmgr = (ClusterManager) manager;
-            // Notify our interested LifecycleListeners
-            lifecycle.fireLifecycleEvent(BEFORE_MANAGERUNREGISTER_EVENT,manager);
-            managers.remove(getManagerName(cmgr.getName(),manager));
-            cmgr.setCluster(null);
-            // Notify our interested LifecycleListeners
-            lifecycle.fireLifecycleEvent(AFTER_MANAGERUNREGISTER_EVENT, manager);
-        }
-    }
-
-    /**
-     * @param name
-     * @param manager
-     * @return
-     */
-    public String getManagerName(String name, Manager manager) {
-        String clusterName = name ;
-        if ( clusterName == null ) clusterName = manager.getContainer().getName();
-        if(getContainer() instanceof Engine) {
-            Container context = manager.getContainer() ;
-            if(context != null && context instanceof Context) {
-                Container host = ((Context)context).getParent();
-                if(host != null && host instanceof Host && clusterName!=null && !(clusterName.indexOf("#")>=0))
-                    clusterName = host.getName() +"#" + clusterName ;
-            }
-        }
-        return clusterName;
-    }
-
-    /*
-     * Get Manager
-     * 
-     * @see org.apache.catalina.ha.CatalinaCluster#getManager(java.lang.String)
-     */
-    public Manager getManager(String name) {
-        return (Manager) managers.get(name);
-    }
-    
-    // ------------------------------------------------------ Lifecycle Methods
-
-    /**
-     * Execute a periodic task, such as reloading, etc. This method will be
-     * invoked inside the classloading context of this container. Unexpected
-     * throwables will be caught and logged.
-     * @see org.apache.catalina.ha.deploy.FarmWarDeployer#backgroundProcess()
-     * @see ReplicationTransmitter#backgroundProcess()
-     */
-    public void backgroundProcess() {
-        if (clusterDeployer != null) clusterDeployer.backgroundProcess();
-        //send a heartbeat through the channel
-        if ( channel !=null ) channel.heartbeat();
-    }
-
-    /**
-     * Add a lifecycle event listener to this component.
-     * 
-     * @param listener
-     *            The listener to add
-     */
-    public void addLifecycleListener(LifecycleListener listener) {
-        lifecycle.addLifecycleListener(listener);
-    }
-
-    /**
-     * Get the lifecycle listeners associated with this lifecycle. If this
-     * Lifecycle has no listeners registered, a zero-length array is returned.
-     */
-    public LifecycleListener[] findLifecycleListeners() {
-
-        return lifecycle.findLifecycleListeners();
-
-    }
-
-    /**
-     * Remove a lifecycle event listener from this component.
-     * 
-     * @param listener
-     *            The listener to remove
-     */
-    public void removeLifecycleListener(LifecycleListener listener) {
-        lifecycle.removeLifecycleListener(listener);
-    }
-
-    /**
-     * Use as base to handle start/stop/periodic Events from host. Currently
-     * only log the messages as trace level.
-     * 
-     * @see org.apache.catalina.LifecycleListener#lifecycleEvent(org.apache.catalina.LifecycleEvent)
-     */
-    public void lifecycleEvent(LifecycleEvent lifecycleEvent) {
-        if (log.isTraceEnabled())
-            log.trace(sm.getString("SimpleTcpCluster.event.log", lifecycleEvent.getType(), lifecycleEvent.getData()));
-    }
-
-    // ------------------------------------------------------ public
-
-    /**
-     * Prepare for the beginning of active use of the public methods of this
-     * component. This method should be called after <code>configure()</code>,
-     * and before any of the public methods of the component are utilized. <BR>
-     * Starts the cluster communication channel, this will connect with the
-     * other nodes in the cluster, and request the current session state to be
-     * transferred to this node.
-     * 
-     * @exception IllegalStateException
-     *                if this component has already been started
-     * @exception LifecycleException
-     *                if this component detects a fatal error that prevents this
-     *                component from being used
-     */
-    public void start() throws LifecycleException {
-        if (started)
-            throw new LifecycleException(sm.getString("cluster.alreadyStarted"));
-        if (log.isInfoEnabled()) log.info("Cluster is about to start");
-
-        // Notify our interested LifecycleListeners
-        lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, this);
-        try {
-            checkDefaults();
-            registerClusterValve();
-            channel.addMembershipListener(this);
-            channel.addChannelListener(this);
-            channel.start(channel.DEFAULT);
-            if (clusterDeployer != null) clusterDeployer.start();
-            this.started = true;
-            // Notify our interested LifecycleListeners
-            lifecycle.fireLifecycleEvent(AFTER_START_EVENT, this);
-        } catch (Exception x) {
-            log.error("Unable to start cluster.", x);
-            throw new LifecycleException(x);
-        }
-    }
-
-    protected void checkDefaults() {
-        if ( clusterListeners.size() == 0 ) {
-            addClusterListener(new JvmRouteSessionIDBinderListener()); 
-            addClusterListener(new ClusterSessionListener());
-        }
-        if ( valves.size() == 0 ) {
-            addValve(new JvmRouteBinderValve());
-            addValve(new ReplicationValve());
-        }
-        if ( clusterDeployer != null ) clusterDeployer.setCluster(this);
-        if ( channel == null ) channel = new GroupChannel();
-        if ( channel instanceof GroupChannel && !((GroupChannel)channel).getInterceptors().hasNext()) {
-            channel.addInterceptor(new MessageDispatch15Interceptor());
-            channel.addInterceptor(new TcpFailureDetector());
-        }
-    }
-
-    /**
-     * register all cluster valve to host or engine
-     * @throws Exception
-     * @throws ClassNotFoundException
-     */
-    protected void registerClusterValve() throws Exception {
-        if(container != null ) {
-            for (Iterator iter = valves.iterator(); iter.hasNext();) {
-                ClusterValve valve = (ClusterValve) iter.next();
-                if (log.isDebugEnabled())
-                    log.debug("Invoking addValve on " + getContainer()
-                            + " with class=" + valve.getClass().getName());
-                if (valve != null) {
-                    IntrospectionUtils.callMethodN(getContainer(), "addValve",
-                            new Object[] { valve },
-                            new Class[] { org.apache.catalina.Valve.class });
-
-                }
-                valve.setCluster(this);
-            }
-        }
-    }
-
-    /**
-     * unregister all cluster valve to host or engine
-     * @throws Exception
-     * @throws ClassNotFoundException
-     */
-    protected void unregisterClusterValve() throws Exception {
-        for (Iterator iter = valves.iterator(); iter.hasNext();) {
-            ClusterValve valve = (ClusterValve) iter.next();
-            if (log.isDebugEnabled())
-                log.debug("Invoking removeValve on " + getContainer()
-                        + " with class=" + valve.getClass().getName());
-            if (valve != null) {
-                    IntrospectionUtils.callMethodN(getContainer(), "removeValve",
-                        new Object[] { valve }, new Class[] { org.apache.catalina.Valve.class });
-            }
-            valve.setCluster(this);
-        }
-    }
-
-    /**
-     * Gracefully terminate the active cluster component.<br/>
-     * This will disconnect the cluster communication channel, stop the
-     * listener and deregister the valves from host or engine.<br/><br/>
-     * <b>Note:</b><br/>The sub elements receiver, sender, membership,
-     * listener or valves are not removed. You can easily start the cluster again.
-     * 
-     * @exception IllegalStateException
-     *                if this component has not been started
-     * @exception LifecycleException
-     *                if this component detects a fatal error that needs to be
-     *                reported
-     */
-    public void stop() throws LifecycleException {
-
-        if (!started)
-            throw new IllegalStateException(sm.getString("cluster.notStarted"));
-        // Notify our interested LifecycleListeners
-        lifecycle.fireLifecycleEvent(BEFORE_STOP_EVENT, this);
-
-        if (clusterDeployer != null) clusterDeployer.stop();
-        this.managers.clear();
-        try {
-            if ( clusterDeployer != null ) clusterDeployer.setCluster(null);
-            channel.stop(Channel.DEFAULT);
-            channel.removeChannelListener(this);
-            channel.removeMembershipListener(this);
-            this.unregisterClusterValve();
-        } catch (Exception x) {
-            log.error("Unable to stop cluster valve.", x);
-        }
-        started = false;
-        // Notify our interested LifecycleListeners
-        lifecycle.fireLifecycleEvent(AFTER_STOP_EVENT, this);
-   }
-
-    
-
-
-    /**
-     * send message to all cluster members
-     * @param msg message to transfer
-     * 
-     * @see org.apache.catalina.ha.CatalinaCluster#send(org.apache.catalina.ha.ClusterMessage)
-     */
-    public void send(ClusterMessage msg) {
-        send(msg, null);
-    }
-
-    /**
-     * send message to all cluster members same cluster domain
-     * 
-     * @see org.apache.catalina.ha.CatalinaCluster#send(org.apache.catalina.ha.ClusterMessage)
-     */
-    public void sendClusterDomain(ClusterMessage msg) {
-        send(msg,null);
-    } 
-
-    
-    /**
-     * send a cluster message to one member
-     * 
-     * @param msg message to transfer
-     * @param dest Receiver member
-     * @see org.apache.catalina.ha.CatalinaCluster#send(org.apache.catalina.ha.ClusterMessage,
-     *      org.apache.catalina.ha.Member)
-     */
-    public void send(ClusterMessage msg, Member dest) {
-        try {
-            msg.setAddress(getLocalMember());
-            if (dest != null) {
-                if (!getLocalMember().equals(dest)) {
-                    channel.send(new Member[] {dest}, msg,channelSendOptions);
-                } else
-                    log.error("Unable to send message to local member " + msg);
-            } else {
-                channel.send(channel.getMembers(),msg,channelSendOptions);
-            }
-        } catch (Exception x) {
-            log.error("Unable to send message through cluster sender.", x);
-        }
-    }
-
-    /**
-     * New cluster member is registered
-     * 
-     * @see org.apache.catalina.ha.MembershipListener#memberAdded(org.apache.catalina.ha.Member)
-     */
-    public void memberAdded(Member member) {
-        try {
-            hasMembers = channel.hasMembers();
-            if (log.isInfoEnabled()) log.info("Replication member added:" + member);
-            // Notify our interested LifecycleListeners
-            lifecycle.fireLifecycleEvent(BEFORE_MEMBERREGISTER_EVENT, member);
-            // Notify our interested LifecycleListeners
-            lifecycle.fireLifecycleEvent(AFTER_MEMBERREGISTER_EVENT, member);
-        } catch (Exception x) {
-            log.error("Unable to connect to replication system.", x);
-        }
-
-    }
-
-    /**
-     * Cluster member is gone
-     * 
-     * @see org.apache.catalina.ha.MembershipListener#memberDisappeared(org.apache.catalina.ha.Member)
-     */
-    public void memberDisappeared(Member member) {
-        try {
-            hasMembers = channel.hasMembers();            
-            if (log.isInfoEnabled()) log.info("Received member disappeared:" + member);
-            // Notify our interested LifecycleListeners
-            lifecycle.fireLifecycleEvent(BEFORE_MEMBERUNREGISTER_EVENT, member);
-            // Notify our interested LifecycleListeners
-            lifecycle.fireLifecycleEvent(AFTER_MEMBERUNREGISTER_EVENT, member);
-        } catch (Exception x) {
-            log.error("Unable remove cluster node from replication system.", x);
-        }
-    }
-
-    // --------------------------------------------------------- receiver
-    // messages
-
-    /**
-     * notify all listeners from receiving a new message is not ClusterMessage
-     * emitt Failure Event to LifecylceListener
-     * 
-     * @param message
-     *            receveived Message
-     */
-    public boolean accept(Serializable msg, Member sender) {
-        return (msg instanceof ClusterMessage);
-    }
-    
-    
-    public void messageReceived(Serializable message, Member sender) {
-        ClusterMessage fwd = (ClusterMessage)message;
-        fwd.setAddress(sender);
-        messageReceived(fwd);
-    }
-
-    public void messageReceived(ClusterMessage message) {
-
-        long start = 0;
-        if (log.isDebugEnabled() && message != null)
-            log.debug("Assuming clocks are synched: Replication for "
-                    + message.getUniqueId() + " took="
-                    + (System.currentTimeMillis() - (message).getTimestamp())
-                    + " ms.");
-
-        //invoke all the listeners
-        boolean accepted = false;
-        if (message != null) {
-            for (Iterator iter = clusterListeners.iterator(); iter.hasNext();) {
-                ClusterListener listener = (ClusterListener) iter.next();
-                if (listener.accept(message)) {
-                    accepted = true;
-                    listener.messageReceived(message);
-                }
-            }
-        }
-        if (!accepted && log.isDebugEnabled()) {
-            if (notifyLifecycleListenerOnFailure) {
-                Member dest = message.getAddress();
-                // Notify our interested LifecycleListeners
-                lifecycle.fireLifecycleEvent(RECEIVE_MESSAGE_FAILURE_EVENT,
-                        new SendMessageData(message, dest, null));
-            }
-            log.debug("Message " + message.toString() + " from type "
-                    + message.getClass().getName()
-                    + " transfered but no listener registered");
-        }
-        return;
-    }
-
-    // --------------------------------------------------------- Logger
-
-    public Log getLogger() {
-        return log;
-    }
-
-
-
-    
-    // ------------------------------------------------------------- deprecated
-
-    /**
-     * 
-     * @see org.apache.catalina.Cluster#setProtocol(java.lang.String)
-     */
-    public void setProtocol(String protocol) {
-    }
-
-    /**
-     * @see org.apache.catalina.Cluster#getProtocol()
-     */
-    public String getProtocol() {
-        return null;
-    }
-
-    /**
-     * @see org.apache.catalina.Cluster#startContext(java.lang.String)
-     */
-    public void startContext(String contextPath) throws IOException {
-        
-    }
-
-    /**
-     * @see org.apache.catalina.Cluster#installContext(java.lang.String, java.net.URL)
-     */
-    public void installContext(String contextPath, URL war) {
-        
-    }
-
-    /**
-     * @see org.apache.catalina.Cluster#stop(java.lang.String)
-     */
-    public void stop(String contextPath) throws IOException {
-        
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha.tcp;
+
+import java.beans.PropertyChangeSupport;
+import java.io.IOException;
+import java.io.Serializable;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.catalina.Container;
+import org.apache.catalina.Context;
+import org.apache.catalina.Engine;
+import org.apache.catalina.Host;
+import org.apache.catalina.Lifecycle;
+import org.apache.catalina.LifecycleEvent;
+import org.apache.catalina.LifecycleException;
+import org.apache.catalina.LifecycleListener;
+import org.apache.catalina.Manager;
+import org.apache.catalina.Valve;
+import org.apache.catalina.ha.CatalinaCluster;
+import org.apache.catalina.ha.ClusterListener;
+import org.apache.catalina.ha.ClusterManager;
+import org.apache.catalina.ha.ClusterMessage;
+import org.apache.catalina.ha.ClusterValve;
+import org.apache.catalina.ha.session.DeltaManager;
+import org.apache.catalina.ha.util.IDynamicProperty;
+import org.apache.catalina.tribes.Channel;
+import org.apache.catalina.tribes.ChannelListener;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.MembershipListener;
+import org.apache.catalina.tribes.group.GroupChannel;
+import org.apache.catalina.util.LifecycleSupport;
+import org.apache.catalina.util.StringManager;
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+import org.apache.tomcat.util.IntrospectionUtils;
+import org.apache.catalina.ha.session.ClusterSessionListener;
+import org.apache.catalina.tribes.group.interceptors.MessageDispatch15Interceptor;
+import org.apache.catalina.tribes.group.interceptors.TcpFailureDetector;
+import org.apache.catalina.ha.session.JvmRouteBinderValve;
+import org.apache.catalina.ha.session.JvmRouteSessionIDBinderListener;
+
+/**
+ * A <b>Cluster </b> implementation using simple multicast. Responsible for
+ * setting up a cluster and provides callers with a valid multicast
+ * receiver/sender.
+ * 
+ * FIXME remove install/remove/start/stop context dummys
+ * FIXME wrote testcases 
+ * 
+ * @author Filip Hanik
+ * @author Remy Maucherat
+ * @author Peter Rossbach
+ * @version $Revision$, $Date$
+ */
+public class SimpleTcpCluster 
+    implements CatalinaCluster, Lifecycle, LifecycleListener, IDynamicProperty,
+               MembershipListener, ChannelListener{
+
+    public static Log log = LogFactory.getLog(SimpleTcpCluster.class);
+
+    // ----------------------------------------------------- Instance Variables
+
+    /**
+     * Descriptive information about this component implementation.
+     */
+    protected static final String info = "SimpleTcpCluster/2.2";
+
+    public static final String BEFORE_MEMBERREGISTER_EVENT = "before_member_register";
+
+    public static final String AFTER_MEMBERREGISTER_EVENT = "after_member_register";
+
+    public static final String BEFORE_MANAGERREGISTER_EVENT = "before_manager_register";
+
+    public static final String AFTER_MANAGERREGISTER_EVENT = "after_manager_register";
+
+    public static final String BEFORE_MANAGERUNREGISTER_EVENT = "before_manager_unregister";
+
+    public static final String AFTER_MANAGERUNREGISTER_EVENT = "after_manager_unregister";
+
+    public static final String BEFORE_MEMBERUNREGISTER_EVENT = "before_member_unregister";
+
+    public static final String AFTER_MEMBERUNREGISTER_EVENT = "after_member_unregister";
+
+    public static final String SEND_MESSAGE_FAILURE_EVENT = "send_message_failure";
+
+    public static final String RECEIVE_MESSAGE_FAILURE_EVENT = "receive_message_failure";
+    
+    /**
+     * Group channel.
+     */
+    protected Channel channel = new GroupChannel();
+
+
+    /**
+     * Name for logging purpose
+     */
+    protected String clusterImpName = "SimpleTcpCluster";
+
+    /**
+     * The string manager for this package.
+     */
+    protected StringManager sm = StringManager.getManager(Constants.Package);
+
+    /**
+     * The cluster name to join
+     */
+    protected String clusterName ;
+
+    /**
+     * The Container associated with this Cluster.
+     */
+    protected Container container = null;
+
+    /**
+     * The lifecycle event support for this component.
+     */
+    protected LifecycleSupport lifecycle = new LifecycleSupport(this);
+
+    /**
+     * Has this component been started?
+     */
+    protected boolean started = false;
+
+    /**
+     * The property change support for this component.
+     */
+    protected PropertyChangeSupport support = new PropertyChangeSupport(this);
+
+    /**
+     * The context name <->manager association for distributed contexts.
+     */
+    protected Map managers = new HashMap();
+
+    protected ClusterManager managerTemplate = new DeltaManager();
+
+    private List valves = new ArrayList();
+
+    private org.apache.catalina.ha.ClusterDeployer clusterDeployer;
+
+    /**
+     * Listeners of messages
+     */
+    protected List clusterListeners = new ArrayList();
+
+    /**
+     * Comment for <code>notifyLifecycleListenerOnFailure</code>
+     */
+    private boolean notifyLifecycleListenerOnFailure = false;
+
+    /**
+     * dynamic sender <code>properties</code>
+     */
+    private Map properties = new HashMap();
+    
+    private int channelSendOptions = Channel.SEND_OPTIONS_ASYNCHRONOUS;
+
+    // ------------------------------------------------------------- Properties
+
+    public SimpleTcpCluster() {
+    }
+
+    /**
+     * Return descriptive information about this Cluster implementation and the
+     * corresponding version number, in the format
+     * <code>&lt;description&gt;/&lt;version&gt;</code>.
+     */
+    public String getInfo() {
+        return (info);
+    }
+
+    /**
+     * Set the name of the cluster to join, if no cluster with this name is
+     * present create one.
+     * 
+     * @param clusterName
+     *            The clustername to join
+     */
+    public void setClusterName(String clusterName) {
+        this.clusterName = clusterName;
+    }
+
+    /**
+     * Return the name of the cluster that this Server is currently configured
+     * to operate within.
+     * 
+     * @return The name of the cluster associated with this server
+     */
+    public String getClusterName() {
+        if(clusterName == null && container != null)
+            return container.getName() ;
+        return clusterName;
+    }
+
+    /**
+     * Set the Container associated with our Cluster
+     * 
+     * @param container
+     *            The Container to use
+     */
+    public void setContainer(Container container) {
+        Container oldContainer = this.container;
+        this.container = container;
+        support.firePropertyChange("container", oldContainer, this.container);
+    }
+
+    /**
+     * Get the Container associated with our Cluster
+     * 
+     * @return The Container associated with our Cluster
+     */
+    public Container getContainer() {
+        return (this.container);
+    }
+
+    /**
+     * @return Returns the notifyLifecycleListenerOnFailure.
+     */
+    public boolean isNotifyLifecycleListenerOnFailure() {
+        return notifyLifecycleListenerOnFailure;
+    }
+
+    /**
+     * @param notifyListenerOnFailure
+     *            The notifyLifecycleListenerOnFailure to set.
+     */
+    public void setNotifyLifecycleListenerOnFailure(
+            boolean notifyListenerOnFailure) {
+        boolean oldNotifyListenerOnFailure = this.notifyLifecycleListenerOnFailure;
+        this.notifyLifecycleListenerOnFailure = notifyListenerOnFailure;
+        support.firePropertyChange("notifyLifecycleListenerOnFailure",
+                oldNotifyListenerOnFailure,
+                this.notifyLifecycleListenerOnFailure);
+    }
+
+    /**
+     * @deprecated use getManagerTemplate().getClass().getName() instead.
+     * @return String
+     */
+    public String getManagerClassName() {
+        return managerTemplate.getClass().getName();
+    }
+
+    /**
+     * @deprecated use nested &lt;Manager&gt; element inside the cluster config instead.
+     * @param managerClassName String
+     */
+    public void setManagerClassName(String managerClassName) {
+        log.warn("setManagerClassName is deprecated, use nested <Manager> element inside the <Cluster> element instead, this request will be ignored.");
+    }
+
+    /**
+     * Add cluster valve 
+     * Cluster Valves are only add to container when cluster is started!
+     * @param valve The new cluster Valve.
+     */
+    public void addValve(Valve valve) {
+        if (valve instanceof ClusterValve && (!valves.contains(valve)))
+            valves.add(valve);
+    }
+
+    /**
+     * get all cluster valves
+     * @return current cluster valves
+     */
+    public Valve[] getValves() {
+        return (Valve[]) valves.toArray(new Valve[valves.size()]);
+    }
+
+    /**
+     * Get the cluster listeners associated with this cluster. If this Array has
+     * no listeners registered, a zero-length array is returned.
+     */
+    public ClusterListener[] findClusterListeners() {
+        if (clusterListeners.size() > 0) {
+            ClusterListener[] listener = new ClusterListener[clusterListeners.size()];
+            clusterListeners.toArray(listener);
+            return listener;
+        } else
+            return new ClusterListener[0];
+
+    }
+
+    /**
+     * add cluster message listener and register cluster to this listener
+     * 
+     * @see org.apache.catalina.ha.CatalinaCluster#addClusterListener(org.apache.catalina.ha.MessageListener)
+     */
+    public void addClusterListener(ClusterListener listener) {
+        if (listener != null && !clusterListeners.contains(listener)) {
+            clusterListeners.add(listener);
+            listener.setCluster(this);
+        }
+    }
+
+    /**
+     * remove message listener and deregister Cluster from listener
+     * 
+     * @see org.apache.catalina.ha.CatalinaCluster#removeClusterListener(org.apache.catalina.ha.MessageListener)
+     */
+    public void removeClusterListener(ClusterListener listener) {
+        if (listener != null) {
+            clusterListeners.remove(listener);
+            listener.setCluster(null);
+        }
+    }
+
+    /**
+     * get current Deployer
+     */
+    public org.apache.catalina.ha.ClusterDeployer getClusterDeployer() {
+        return clusterDeployer;
+    }
+
+    /**
+     * set a new Deployer, must be set before cluster started!
+     */
+    public void setClusterDeployer(
+            org.apache.catalina.ha.ClusterDeployer clusterDeployer) {
+        this.clusterDeployer = clusterDeployer;
+    }
+
+    public void setChannel(Channel channel) {
+        this.channel = channel;
+    }
+
+    public void setManagerTemplate(ClusterManager managerTemplate) {
+        this.managerTemplate = managerTemplate;
+    }
+
+    public void setChannelSendOptions(int channelSendOptions) {
+        this.channelSendOptions = channelSendOptions;
+    }
+
+    /**
+     * has members
+     */
+    protected boolean hasMembers = false;
+    public boolean hasMembers() {
+        return hasMembers;
+    }
+    
+    /**
+     * Get all current cluster members
+     * @return all members or empty array 
+     */
+    public Member[] getMembers() {
+        return channel.getMembers();
+    }
+
+    /**
+     * Return the member that represents this node.
+     * 
+     * @return Member
+     */
+    public Member getLocalMember() {
+        return channel.getLocalMember(true);
+    }
+
+    // ------------------------------------------------------------- dynamic
+    // manager property handling
+
+    /**
+     * JMX hack to direct use at jconsole
+     * 
+     * @param name
+     * @param value
+     */
+    public void setProperty(String name, String value) {
+        setProperty(name, (Object) value);
+    }
+
+    /**
+     * set config attributes with reflect and propagate to all managers
+     * 
+     * @param name
+     * @param value
+     */
+    public void setProperty(String name, Object value) {
+        if (log.isTraceEnabled())
+            log.trace(sm.getString("SimpleTcpCluster.setProperty", name, value,properties.get(name)));
+        properties.put(name, value);
+        //using a dynamic way of setting properties is nice, but a security risk
+        //if exposed through JMX. This way you can sit and try to guess property names,
+        //we will only allow explicit property names
+        log.warn("Dynamic setProperty("+name+",value) has been disabled, please use explicit properties for the element you are trying to identify");
+        if(started) {
+            // FIXME Hmm, is that correct when some DeltaManagers are direct configured inside Context?
+            // Why we not support it for other elements, like sender, receiver or membership?
+            // Must we restart element after change?
+//            if (name.startsWith("manager")) {
+//                String key = name.substring("manager".length() + 1);
+//                String pvalue = value.toString();
+//                for (Iterator iter = managers.values().iterator(); iter.hasNext();) {
+//                    Manager manager = (Manager) iter.next();
+//                    if(manager instanceof DeltaManager && ((ClusterManager) manager).isDefaultMode()) {
+//                        IntrospectionUtils.setProperty(manager, key, pvalue );
+//                    }
+//                }
+//            } 
+        }
+    }
+
+    /**
+     * get current config
+     * 
+     * @param key
+     * @return The property
+     */
+    public Object getProperty(String key) {
+        if (log.isTraceEnabled())
+            log.trace(sm.getString("SimpleTcpCluster.getProperty", key));
+        return properties.get(key);
+    }
+
+    /**
+     * Get all properties keys
+     * 
+     * @return An iterator over the property names.
+     */
+    public Iterator getPropertyNames() {
+        return properties.keySet().iterator();
+    }
+
+    /**
+     * remove a configured property.
+     * 
+     * @param key
+     */
+    public void removeProperty(String key) {
+        properties.remove(key);
+    }
+
+    /**
+     * transfer properties from cluster configuration to subelement bean.
+     * @param prefix
+     * @param bean
+     */
+    protected void transferProperty(String prefix, Object bean) {
+        if (prefix != null) {
+            for (Iterator iter = getPropertyNames(); iter.hasNext();) {
+                String pkey = (String) iter.next();
+                if (pkey.startsWith(prefix)) {
+                    String key = pkey.substring(prefix.length() + 1);
+                    Object value = getProperty(pkey);
+                    IntrospectionUtils.setProperty(bean, key, value.toString());
+                }
+            }
+        }
+    }
+
+    // --------------------------------------------------------- Public Methods
+
+    /**
+     * @return Returns the managers.
+     */
+    public Map getManagers() {
+        return managers;
+    }
+
+    public Channel getChannel() {
+        return channel;
+    }
+
+    public ClusterManager getManagerTemplate() {
+        return managerTemplate;
+    }
+
+    public int getChannelSendOptions() {
+        return channelSendOptions;
+    }
+
+    /**
+     * Create new Manager without add to cluster (comes with start the manager)
+     * 
+     * @param name
+     *            Context Name of this manager
+     * @see org.apache.catalina.Cluster#createManager(java.lang.String)
+     * @see #addManager(String, Manager)
+     * @see DeltaManager#start()
+     */
+    public synchronized Manager createManager(String name) {
+        if (log.isDebugEnabled()) log.debug("Creating ClusterManager for context " + name + " using class " + getManagerClassName());
+        Manager manager = null;
+        try {
+            manager = managerTemplate.cloneFromTemplate();
+            ((ClusterManager)manager).setName(name);
+        } catch (Exception x) {
+            log.error("Unable to clone cluster manager, defaulting to org.apache.catalina.ha.session.DeltaManager", x);
+            manager = new org.apache.catalina.ha.session.DeltaManager();
+        } finally {
+            if ( manager != null && (manager instanceof ClusterManager)) ((ClusterManager)manager).setCluster(this);
+        }
+        return manager;
+    }
+    
+    public void registerManager(Manager manager) {
+    
+        if (! (manager instanceof ClusterManager)) {
+            log.warn("Manager [ " + manager + "] does not implement ClusterManager, addition to cluster has been aborted.");
+            return;
+        }
+        ClusterManager cmanager = (ClusterManager) manager ;
+        cmanager.setDistributable(true);
+        // Notify our interested LifecycleListeners
+        lifecycle.fireLifecycleEvent(BEFORE_MANAGERREGISTER_EVENT, manager);
+        String clusterName = getManagerName(cmanager.getName(), manager);
+        cmanager.setName(clusterName);
+        cmanager.setCluster(this);
+        cmanager.setDefaultMode(false);
+    
+        managers.put(clusterName, manager);
+        // Notify our interested LifecycleListeners
+        lifecycle.fireLifecycleEvent(AFTER_MANAGERREGISTER_EVENT, manager);    
+    }
+
+    /**
+     * remove an application form cluster replication bus
+     * 
+     * @see org.apache.catalina.ha.CatalinaCluster#removeManager(java.lang.String,Manager)
+     */
+    public void removeManager(Manager manager) {
+        if (manager != null && manager instanceof ClusterManager ) {
+            ClusterManager cmgr = (ClusterManager) manager;
+            // Notify our interested LifecycleListeners
+            lifecycle.fireLifecycleEvent(BEFORE_MANAGERUNREGISTER_EVENT,manager);
+            managers.remove(getManagerName(cmgr.getName(),manager));
+            cmgr.setCluster(null);
+            // Notify our interested LifecycleListeners
+            lifecycle.fireLifecycleEvent(AFTER_MANAGERUNREGISTER_EVENT, manager);
+        }
+    }
+
+    /**
+     * @param name
+     * @param manager
+     * @return
+     */
+    public String getManagerName(String name, Manager manager) {
+        String clusterName = name ;
+        if ( clusterName == null ) clusterName = manager.getContainer().getName();
+        if(getContainer() instanceof Engine) {
+            Container context = manager.getContainer() ;
+            if(context != null && context instanceof Context) {
+                Container host = ((Context)context).getParent();
+                if(host != null && host instanceof Host && clusterName!=null && !(clusterName.indexOf("#")>=0))
+                    clusterName = host.getName() +"#" + clusterName ;
+            }
+        }
+        return clusterName;
+    }
+
+    /*
+     * Get Manager
+     * 
+     * @see org.apache.catalina.ha.CatalinaCluster#getManager(java.lang.String)
+     */
+    public Manager getManager(String name) {
+        return (Manager) managers.get(name);
+    }
+    
+    // ------------------------------------------------------ Lifecycle Methods
+
+    /**
+     * Execute a periodic task, such as reloading, etc. This method will be
+     * invoked inside the classloading context of this container. Unexpected
+     * throwables will be caught and logged.
+     * @see org.apache.catalina.ha.deploy.FarmWarDeployer#backgroundProcess()
+     * @see ReplicationTransmitter#backgroundProcess()
+     */
+    public void backgroundProcess() {
+        if (clusterDeployer != null) clusterDeployer.backgroundProcess();
+        //send a heartbeat through the channel
+        if ( channel !=null ) channel.heartbeat();
+    }
+
+    /**
+     * Add a lifecycle event listener to this component.
+     * 
+     * @param listener
+     *            The listener to add
+     */
+    public void addLifecycleListener(LifecycleListener listener) {
+        lifecycle.addLifecycleListener(listener);
+    }
+
+    /**
+     * Get the lifecycle listeners associated with this lifecycle. If this
+     * Lifecycle has no listeners registered, a zero-length array is returned.
+     */
+    public LifecycleListener[] findLifecycleListeners() {
+
+        return lifecycle.findLifecycleListeners();
+
+    }
+
+    /**
+     * Remove a lifecycle event listener from this component.
+     * 
+     * @param listener
+     *            The listener to remove
+     */
+    public void removeLifecycleListener(LifecycleListener listener) {
+        lifecycle.removeLifecycleListener(listener);
+    }
+
+    /**
+     * Use as base to handle start/stop/periodic Events from host. Currently
+     * only log the messages as trace level.
+     * 
+     * @see org.apache.catalina.LifecycleListener#lifecycleEvent(org.apache.catalina.LifecycleEvent)
+     */
+    public void lifecycleEvent(LifecycleEvent lifecycleEvent) {
+        if (log.isTraceEnabled())
+            log.trace(sm.getString("SimpleTcpCluster.event.log", lifecycleEvent.getType(), lifecycleEvent.getData()));
+    }
+
+    // ------------------------------------------------------ public
+
+    /**
+     * Prepare for the beginning of active use of the public methods of this
+     * component. This method should be called after <code>configure()</code>,
+     * and before any of the public methods of the component are utilized. <BR>
+     * Starts the cluster communication channel, this will connect with the
+     * other nodes in the cluster, and request the current session state to be
+     * transferred to this node.
+     * 
+     * @exception IllegalStateException
+     *                if this component has already been started
+     * @exception LifecycleException
+     *                if this component detects a fatal error that prevents this
+     *                component from being used
+     */
+    public void start() throws LifecycleException {
+        if (started)
+            throw new LifecycleException(sm.getString("cluster.alreadyStarted"));
+        if (log.isInfoEnabled()) log.info("Cluster is about to start");
+
+        // Notify our interested LifecycleListeners
+        lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, this);
+        try {
+            checkDefaults();
+            registerClusterValve();
+            channel.addMembershipListener(this);
+            channel.addChannelListener(this);
+            channel.start(channel.DEFAULT);
+            if (clusterDeployer != null) clusterDeployer.start();
+            this.started = true;
+            // Notify our interested LifecycleListeners
+            lifecycle.fireLifecycleEvent(AFTER_START_EVENT, this);
+        } catch (Exception x) {
+            log.error("Unable to start cluster.", x);
+            throw new LifecycleException(x);
+        }
+    }
+
+    protected void checkDefaults() {
+        if ( clusterListeners.size() == 0 ) {
+            addClusterListener(new JvmRouteSessionIDBinderListener()); 
+            addClusterListener(new ClusterSessionListener());
+        }
+        if ( valves.size() == 0 ) {
+            addValve(new JvmRouteBinderValve());
+            addValve(new ReplicationValve());
+        }
+        if ( clusterDeployer != null ) clusterDeployer.setCluster(this);
+        if ( channel == null ) channel = new GroupChannel();
+        if ( channel instanceof GroupChannel && !((GroupChannel)channel).getInterceptors().hasNext()) {
+            channel.addInterceptor(new MessageDispatch15Interceptor());
+            channel.addInterceptor(new TcpFailureDetector());
+        }
+    }
+
+    /**
+     * register all cluster valve to host or engine
+     * @throws Exception
+     * @throws ClassNotFoundException
+     */
+    protected void registerClusterValve() throws Exception {
+        if(container != null ) {
+            for (Iterator iter = valves.iterator(); iter.hasNext();) {
+                ClusterValve valve = (ClusterValve) iter.next();
+                if (log.isDebugEnabled())
+                    log.debug("Invoking addValve on " + getContainer()
+                            + " with class=" + valve.getClass().getName());
+                if (valve != null) {
+                    IntrospectionUtils.callMethodN(getContainer(), "addValve",
+                            new Object[] { valve },
+                            new Class[] { org.apache.catalina.Valve.class });
+
+                }
+                valve.setCluster(this);
+            }
+        }
+    }
+
+    /**
+     * unregister all cluster valve to host or engine
+     * @throws Exception
+     * @throws ClassNotFoundException
+     */
+    protected void unregisterClusterValve() throws Exception {
+        for (Iterator iter = valves.iterator(); iter.hasNext();) {
+            ClusterValve valve = (ClusterValve) iter.next();
+            if (log.isDebugEnabled())
+                log.debug("Invoking removeValve on " + getContainer()
+                        + " with class=" + valve.getClass().getName());
+            if (valve != null) {
+                    IntrospectionUtils.callMethodN(getContainer(), "removeValve",
+                        new Object[] { valve }, new Class[] { org.apache.catalina.Valve.class });
+            }
+            valve.setCluster(this);
+        }
+    }
+
+    /**
+     * Gracefully terminate the active cluster component.<br/>
+     * This will disconnect the cluster communication channel, stop the
+     * listener and deregister the valves from host or engine.<br/><br/>
+     * <b>Note:</b><br/>The sub elements receiver, sender, membership,
+     * listener or valves are not removed. You can easily start the cluster again.
+     * 
+     * @exception IllegalStateException
+     *                if this component has not been started
+     * @exception LifecycleException
+     *                if this component detects a fatal error that needs to be
+     *                reported
+     */
+    public void stop() throws LifecycleException {
+
+        if (!started)
+            throw new IllegalStateException(sm.getString("cluster.notStarted"));
+        // Notify our interested LifecycleListeners
+        lifecycle.fireLifecycleEvent(BEFORE_STOP_EVENT, this);
+
+        if (clusterDeployer != null) clusterDeployer.stop();
+        this.managers.clear();
+        try {
+            if ( clusterDeployer != null ) clusterDeployer.setCluster(null);
+            channel.stop(Channel.DEFAULT);
+            channel.removeChannelListener(this);
+            channel.removeMembershipListener(this);
+            this.unregisterClusterValve();
+        } catch (Exception x) {
+            log.error("Unable to stop cluster valve.", x);
+        }
+        started = false;
+        // Notify our interested LifecycleListeners
+        lifecycle.fireLifecycleEvent(AFTER_STOP_EVENT, this);
+   }
+
+    
+
+
+    /**
+     * send message to all cluster members
+     * @param msg message to transfer
+     * 
+     * @see org.apache.catalina.ha.CatalinaCluster#send(org.apache.catalina.ha.ClusterMessage)
+     */
+    public void send(ClusterMessage msg) {
+        send(msg, null);
+    }
+
+    /**
+     * send message to all cluster members same cluster domain
+     * 
+     * @see org.apache.catalina.ha.CatalinaCluster#send(org.apache.catalina.ha.ClusterMessage)
+     */
+    public void sendClusterDomain(ClusterMessage msg) {
+        send(msg,null);
+    } 
+
+    
+    /**
+     * send a cluster message to one member
+     * 
+     * @param msg message to transfer
+     * @param dest Receiver member
+     * @see org.apache.catalina.ha.CatalinaCluster#send(org.apache.catalina.ha.ClusterMessage,
+     *      org.apache.catalina.ha.Member)
+     */
+    public void send(ClusterMessage msg, Member dest) {
+        try {
+            msg.setAddress(getLocalMember());
+            if (dest != null) {
+                if (!getLocalMember().equals(dest)) {
+                    channel.send(new Member[] {dest}, msg,channelSendOptions);
+                } else
+                    log.error("Unable to send message to local member " + msg);
+            } else {
+                channel.send(channel.getMembers(),msg,channelSendOptions);
+            }
+        } catch (Exception x) {
+            log.error("Unable to send message through cluster sender.", x);
+        }
+    }
+
+    /**
+     * New cluster member is registered
+     * 
+     * @see org.apache.catalina.ha.MembershipListener#memberAdded(org.apache.catalina.ha.Member)
+     */
+    public void memberAdded(Member member) {
+        try {
+            hasMembers = channel.hasMembers();
+            if (log.isInfoEnabled()) log.info("Replication member added:" + member);
+            // Notify our interested LifecycleListeners
+            lifecycle.fireLifecycleEvent(BEFORE_MEMBERREGISTER_EVENT, member);
+            // Notify our interested LifecycleListeners
+            lifecycle.fireLifecycleEvent(AFTER_MEMBERREGISTER_EVENT, member);
+        } catch (Exception x) {
+            log.error("Unable to connect to replication system.", x);
+        }
+
+    }
+
+    /**
+     * Cluster member is gone
+     * 
+     * @see org.apache.catalina.ha.MembershipListener#memberDisappeared(org.apache.catalina.ha.Member)
+     */
+    public void memberDisappeared(Member member) {
+        try {
+            hasMembers = channel.hasMembers();            
+            if (log.isInfoEnabled()) log.info("Received member disappeared:" + member);
+            // Notify our interested LifecycleListeners
+            lifecycle.fireLifecycleEvent(BEFORE_MEMBERUNREGISTER_EVENT, member);
+            // Notify our interested LifecycleListeners
+            lifecycle.fireLifecycleEvent(AFTER_MEMBERUNREGISTER_EVENT, member);
+        } catch (Exception x) {
+            log.error("Unable remove cluster node from replication system.", x);
+        }
+    }
+
+    // --------------------------------------------------------- receiver
+    // messages
+
+    /**
+     * notify all listeners from receiving a new message is not ClusterMessage
+     * emitt Failure Event to LifecylceListener
+     * 
+     * @param message
+     *            receveived Message
+     */
+    public boolean accept(Serializable msg, Member sender) {
+        return (msg instanceof ClusterMessage);
+    }
+    
+    
+    public void messageReceived(Serializable message, Member sender) {
+        ClusterMessage fwd = (ClusterMessage)message;
+        fwd.setAddress(sender);
+        messageReceived(fwd);
+    }
+
+    public void messageReceived(ClusterMessage message) {
+
+        long start = 0;
+        if (log.isDebugEnabled() && message != null)
+            log.debug("Assuming clocks are synched: Replication for "
+                    + message.getUniqueId() + " took="
+                    + (System.currentTimeMillis() - (message).getTimestamp())
+                    + " ms.");
+
+        //invoke all the listeners
+        boolean accepted = false;
+        if (message != null) {
+            for (Iterator iter = clusterListeners.iterator(); iter.hasNext();) {
+                ClusterListener listener = (ClusterListener) iter.next();
+                if (listener.accept(message)) {
+                    accepted = true;
+                    listener.messageReceived(message);
+                }
+            }
+        }
+        if (!accepted && log.isDebugEnabled()) {
+            if (notifyLifecycleListenerOnFailure) {
+                Member dest = message.getAddress();
+                // Notify our interested LifecycleListeners
+                lifecycle.fireLifecycleEvent(RECEIVE_MESSAGE_FAILURE_EVENT,
+                        new SendMessageData(message, dest, null));
+            }
+            log.debug("Message " + message.toString() + " from type "
+                    + message.getClass().getName()
+                    + " transfered but no listener registered");
+        }
+        return;
+    }
+
+    // --------------------------------------------------------- Logger
+
+    public Log getLogger() {
+        return log;
+    }
+
+
+
+    
+    // ------------------------------------------------------------- deprecated
+
+    /**
+     * 
+     * @see org.apache.catalina.Cluster#setProtocol(java.lang.String)
+     */
+    public void setProtocol(String protocol) {
+    }
+
+    /**
+     * @see org.apache.catalina.Cluster#getProtocol()
+     */
+    public String getProtocol() {
+        return null;
+    }
+
+    /**
+     * @see org.apache.catalina.Cluster#startContext(java.lang.String)
+     */
+    public void startContext(String contextPath) throws IOException {
+        
+    }
+
+    /**
+     * @see org.apache.catalina.Cluster#installContext(java.lang.String, java.net.URL)
+     */
+    public void installContext(String contextPath, URL war) {
+        
+    }
+
+    /**
+     * @see org.apache.catalina.Cluster#stop(java.lang.String)
+     */
+    public void stop(String contextPath) throws IOException {
+        
+    }
+}

==================================================
Reloader.java
index 645f349ad2..f88d66b483 100644
--- a/java/org/apache/catalina/ha/util/IDynamicProperty.java
+++ b/java/org/apache/catalina/ha/util/IDynamicProperty.java
@@ -1,58 +1,58 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.ha.util;
-
-import java.util.Iterator;
-
-/**
- * @author Peter Rossbach
- * @version $Revision: 304032 $, $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
- */
-
-public interface IDynamicProperty {
-
-    /**
-     * set config attributes with reflect
-     * 
-     * @param name
-     * @param value
-     */
-    public void setProperty(String name, Object value) ;
-
-    /**
-     * get current config
-     * 
-     * @param key
-     * @return The property
-     */
-    public Object getProperty(String key) ;
-    /**
-     * Get all properties keys
-     * 
-     * @return An iterator over the property names
-     */
-    public Iterator getPropertyNames() ;
-
-    /**
-     * remove a configured property.
-     * 
-     * @param key
-     */
-    public void removeProperty(String key) ;
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.ha.util;
+
+import java.util.Iterator;
+
+/**
+ * @author Peter Rossbach
+ * @version $Revision$, $Date$
+ */
+
+public interface IDynamicProperty {
+
+    /**
+     * set config attributes with reflect
+     * 
+     * @param name
+     * @param value
+     */
+    public void setProperty(String name, Object value) ;
+
+    /**
+     * get current config
+     * 
+     * @param key
+     * @return The property
+     */
+    public Object getProperty(String key) ;
+    /**
+     * Get all properties keys
+     * 
+     * @return An iterator over the property names
+     */
+    public Iterator getPropertyNames() ;
+
+    /**
+     * remove a configured property.
+     * 
+     * @param key
+     */
+    public void removeProperty(String key) ;
+
+}

==================================================
ResourceEntry.java
index 0711062358..d6c58b5faa 100644
--- a/java/org/apache/catalina/loader/Reloader.java
+++ b/java/org/apache/catalina/loader/Reloader.java
@@ -25,7 +25,7 @@ package org.apache.catalina.loader;
  * the classloader associated with the context.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public interface Reloader {

==================================================
StandardClassLoader.java
index 2817f2c513..6449d1cc0f 100644
--- a/java/org/apache/catalina/loader/ResourceEntry.java
+++ b/java/org/apache/catalina/loader/ResourceEntry.java
@@ -26,7 +26,7 @@ import java.util.jar.Manifest;
  * Resource entry.
  *
  * @author Remy Maucherat
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 public class ResourceEntry {
 

==================================================
StandardClassLoaderMBean.java
index 2c80459f3b..b569a5d4c6 100644
--- a/java/org/apache/catalina/loader/StandardClassLoader.java
+++ b/java/org/apache/catalina/loader/StandardClassLoader.java
@@ -42,7 +42,7 @@ import java.net.URLClassLoader;
  *
  * @author Craig R. McClanahan
  * @author Remy Maucherat
- * @version $Revision: 303071 $ $Date: 2004-08-05 12:54:43 +0200 (jeu., 05 août 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class StandardClassLoader

==================================================
WebappClassLoader.java
index c5ea26a5e3..db9a884a0f 100644
--- a/java/org/apache/catalina/loader/StandardClassLoaderMBean.java
+++ b/java/org/apache/catalina/loader/StandardClassLoaderMBean.java
@@ -22,7 +22,7 @@ package org.apache.catalina.loader;
  * MBean interface for StandardClassLoader, to allow JMX remote management.
  *
  * @author Remy Maucherat
- * @version $Revision: 302740 $ $Date: 2004-03-02 13:32:19 +0100 (mar., 02 mars 2004) $
+ * @version $Revision$ $Date$
  */
 public interface StandardClassLoaderMBean {
 }

==================================================
WebappLoader.java
index 2001dd2e1c..a7648da032 100644
--- a/java/org/apache/catalina/loader/WebappClassLoader.java
+++ b/java/org/apache/catalina/loader/WebappClassLoader.java
@@ -99,7 +99,7 @@ import org.apache.tomcat.util.IntrospectionUtils;
  *
  * @author Remy Maucherat
  * @author Craig R. McClanahan
- * @version $Revision$ $Date: 2006-05-19 19:52:46 -0700 (Fri, 19 May 2006) $
+ * @version $Revision$ $Date$
  */
 public class WebappClassLoader
     extends URLClassLoader

==================================================
HTMLManagerServlet.java
index 554ddc8058..08f233c364 100644
--- a/java/org/apache/catalina/loader/WebappLoader.java
+++ b/java/org/apache/catalina/loader/WebappLoader.java
@@ -79,7 +79,7 @@ import org.apache.tomcat.util.modeler.Registry;
  *
  * @author Craig R. McClanahan
  * @author Remy Maucherat
- * @version $Revision: 303352 $ $Date: 2004-10-05 19:12:52 +0200 (mar., 05 oct. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class WebappLoader

==================================================
ManagerServlet.java
index 7deea1dccd..b267f44b48 100644
--- a/java/org/apache/catalina/manager/HTMLManagerServlet.java
+++ b/java/org/apache/catalina/manager/HTMLManagerServlet.java
@@ -57,7 +57,7 @@ import org.apache.tomcat.util.http.fileupload.FileItem;
 * @author Bip Thelin
 * @author Malcolm Edgar
 * @author Glenn L. Nielsen
-* @version $Revision: 326772 $, $Date: 2005-10-20 03:37:02 +0200 (jeu., 20 oct. 2005) $
+* @version $Revision$, $Date$
 * @see ManagerServlet
 */
 

==================================================
StatusManagerServlet.java
index bad0c69bd3..fce3393830 100644
--- a/java/org/apache/catalina/manager/ManagerServlet.java
+++ b/java/org/apache/catalina/manager/ManagerServlet.java
@@ -152,7 +152,7 @@ import org.apache.tomcat.util.modeler.Registry;
  *
  * @author Craig R. McClanahan
  * @author Remy Maucherat
- * @version $Revision: 393613 $ $Date: 2006-04-12 23:08:01 +0200 (mer., 12 avr. 2006) $
+ * @version $Revision$ $Date$
  */
 
 public class ManagerServlet

==================================================
StatusTransformer.java
index de557805e4..51596a1844 100644
--- a/java/org/apache/catalina/manager/StatusManagerServlet.java
+++ b/java/org/apache/catalina/manager/StatusManagerServlet.java
@@ -45,7 +45,7 @@ import org.apache.tomcat.util.modeler.Registry;
  * This servlet will display a complete status of the HTTP/1.1 connector.
  *
  * @author Remy Maucherat
- * @version $Revision: 303870 $ $Date: 2005-04-19 00:50:24 +0200 (mar., 19 avr. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class StatusManagerServlet

==================================================
HTMLHostManagerServlet.java
index ddf2e98459..63c2b3cca0 100644
--- a/java/org/apache/catalina/manager/StatusTransformer.java
+++ b/java/org/apache/catalina/manager/StatusTransformer.java
@@ -42,7 +42,7 @@ import org.apache.catalina.util.RequestUtil;
  * use XSLT, that is unnecessarily complex.
  *
  * @author Peter Lin
- * @version $Revision: 303967 $ $Date: 2005-06-29 19:31:56 +0200 (mer., 29 juin 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class StatusTransformer {

==================================================
HostManagerServlet.java
index effea1deca..55fc94beae 100644
--- a/java/org/apache/catalina/manager/host/HTMLHostManagerServlet.java
+++ b/java/org/apache/catalina/manager/host/HTMLHostManagerServlet.java
@@ -53,7 +53,7 @@ import org.apache.catalina.util.ServerInfo;
 * @author Malcolm Edgar
 * @author Glenn L. Nielsen
 * @author Peter Rossbach
-* @version $Revision: 384293 $, $Date: 2006-03-08 19:09:36 +0100 (mer., 08 mars 2006) $
+* @version $Revision$, $Date$
 * @see ManagerServlet
 */
 

==================================================
ClassNameMBean.java
index 3cfdc2aaaa..3912018276 100644
--- a/java/org/apache/catalina/manager/host/HostManagerServlet.java
+++ b/java/org/apache/catalina/manager/host/HostManagerServlet.java
@@ -94,7 +94,7 @@ import org.apache.catalina.core.ContainerBase;
  *
  * @author Craig R. McClanahan
  * @author Remy Maucherat
- * @version $Revision: 447499 $ $Date: 2006-09-18 20:47:54 +0200 (lun., 18 sept. 2006) $
+ * @version $Revision$ $Date$
  */
 
 public class HostManagerServlet

==================================================
ConnectorMBean.java
index 1b55d3ad2b..8cab9de747 100644
--- a/java/org/apache/catalina/mbeans/ClassNameMBean.java
+++ b/java/org/apache/catalina/mbeans/ClassNameMBean.java
@@ -34,7 +34,7 @@ import org.apache.tomcat.util.modeler.BaseModelMBean;
  * qualified class name of the managed object as its value.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class ClassNameMBean extends BaseModelMBean {

==================================================
ContextEnvironmentMBean.java
index b97ec379c0..17cc794b16 100644
--- a/java/org/apache/catalina/mbeans/ConnectorMBean.java
+++ b/java/org/apache/catalina/mbeans/ConnectorMBean.java
@@ -34,7 +34,7 @@ import org.apache.tomcat.util.IntrospectionUtils;
  * <code>org.apache.coyote.tomcat5.CoyoteConnector</code> component.</p>
  *
  * @author Amy Roh
- * @version $Revision: 303320 $ $Date: 2004-10-04 11:25:55 +0200 (lun., 04 oct. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class ConnectorMBean extends ClassNameMBean {

==================================================
ContextResourceLinkMBean.java
index bda039f502..e5825ff31f 100644
--- a/java/org/apache/catalina/mbeans/ContextEnvironmentMBean.java
+++ b/java/org/apache/catalina/mbeans/ContextEnvironmentMBean.java
@@ -36,7 +36,7 @@ import org.apache.tomcat.util.modeler.BaseModelMBean;
  * <code>org.apache.catalina.deploy.ContextEnvironment</code> component.</p>
  *
  * @author Amy Roh
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class ContextEnvironmentMBean extends BaseModelMBean {

==================================================
ContextResourceMBean.java
index c79ef9b5ac..3449a6b2ba 100644
--- a/java/org/apache/catalina/mbeans/ContextResourceLinkMBean.java
+++ b/java/org/apache/catalina/mbeans/ContextResourceLinkMBean.java
@@ -36,7 +36,7 @@ import org.apache.tomcat.util.modeler.BaseModelMBean;
  * <code>org.apache.catalina.deploy.ContextResourceLink</code> component.</p>
  *
  * @author Amy Roh
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class ContextResourceLinkMBean extends BaseModelMBean {

==================================================
DefaultContextMBean.java
index 651ba1473e..8329e71386 100644
--- a/java/org/apache/catalina/mbeans/ContextResourceMBean.java
+++ b/java/org/apache/catalina/mbeans/ContextResourceMBean.java
@@ -36,7 +36,7 @@ import org.apache.tomcat.util.modeler.BaseModelMBean;
  * <code>org.apache.catalina.deploy.ContextResource</code> component.</p>
  *
  * @author Amy Roh
- * @version $Revision: 303032 $ $Date: 2004-07-26 18:04:02 +0200 (lun., 26 juil. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class ContextResourceMBean extends BaseModelMBean {

==================================================
GlobalResourcesLifecycleListener.java
index 69cf7bcece..303105e11e 100644
--- a/java/org/apache/catalina/mbeans/DefaultContextMBean.java
+++ b/java/org/apache/catalina/mbeans/DefaultContextMBean.java
@@ -38,7 +38,7 @@ import org.apache.tomcat.util.modeler.Registry;
  * <code>org.apache.catalina.core.StandardDefaultContext</code> component.</p>
  *
  * @author Amy Roh
- * @version $Revision: 303133 $ $Date: 2004-08-29 18:46:15 +0200 (dim., 29 août 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class DefaultContextMBean extends BaseModelMBean {

==================================================
GroupMBean.java
index 765d160b6c..ef66366e97 100644
--- a/java/org/apache/catalina/mbeans/GlobalResourcesLifecycleListener.java
+++ b/java/org/apache/catalina/mbeans/GlobalResourcesLifecycleListener.java
@@ -43,7 +43,7 @@ import org.apache.tomcat.util.modeler.Registry;
  * management.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302983 $ $Date: 2004-06-26 01:56:25 +0200 (sam., 26 juin 2004) $
+ * @version $Revision$ $Date$
  * @since 4.1
  */
 

==================================================
MBeanFactory.java
index 6cad755f52..bb92e5bd62 100644
--- a/java/org/apache/catalina/mbeans/GroupMBean.java
+++ b/java/org/apache/catalina/mbeans/GroupMBean.java
@@ -39,7 +39,7 @@ import org.apache.tomcat.util.modeler.Registry;
  * <code>org.apache.catalina.Group</code> component.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302833 $ $Date: 2004-04-15 03:44:09 +0200 (jeu., 15 avr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class GroupMBean extends BaseModelMBean {

==================================================
MBeanUtils.java
index 8c00ed5a8b..43f213b01f 100644
--- a/java/org/apache/catalina/mbeans/MBeanFactory.java
+++ b/java/org/apache/catalina/mbeans/MBeanFactory.java
@@ -62,7 +62,7 @@ import org.apache.tomcat.util.modeler.Registry;
  * <code>org.apache.catalina.core.StandardServer</code> component.</p>
  *
  * @author Amy Roh
- * @version $Revision: 304032 $ $Date: 2005-07-27 17:11:55 +0200 (mer., 27 juil. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class MBeanFactory extends BaseModelMBean {

==================================================
MemoryUserDatabaseMBean.java
index 2b83206999..94501eec6f 100644
--- a/java/org/apache/catalina/mbeans/MBeanUtils.java
+++ b/java/org/apache/catalina/mbeans/MBeanUtils.java
@@ -60,7 +60,7 @@ import org.apache.tomcat.util.modeler.Registry;
  *
  * @author Craig R. McClanahan
  * @author Amy Roh
- * @version $Revision: 303558 $ $Date: 2004-12-01 12:17:34 +0100 (mer., 01 déc. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class MBeanUtils {

==================================================
NamingResourcesMBean.java
index 08be635798..20e7a9d3ca 100644
--- a/java/org/apache/catalina/mbeans/MemoryUserDatabaseMBean.java
+++ b/java/org/apache/catalina/mbeans/MemoryUserDatabaseMBean.java
@@ -40,7 +40,7 @@ import org.apache.tomcat.util.modeler.Registry;
  * <code>org.apache.catalina.users.MemoryUserDatabase</code> component.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302833 $ $Date: 2004-04-15 03:44:09 +0200 (jeu., 15 avr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class MemoryUserDatabaseMBean extends BaseModelMBean {

==================================================
RoleMBean.java
index 29215d1180..c3e6d6f789 100644
--- a/java/org/apache/catalina/mbeans/NamingResourcesMBean.java
+++ b/java/org/apache/catalina/mbeans/NamingResourcesMBean.java
@@ -37,7 +37,7 @@ import org.apache.tomcat.util.modeler.Registry;
  * <code>org.apache.catalina.deploy.NamingResources</code> component.</p>
  *
  * @author Amy Roh
- * @version $Revision: 303133 $ $Date: 2004-08-29 18:46:15 +0200 (dim., 29 août 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class NamingResourcesMBean extends BaseModelMBean {

==================================================
ServerLifecycleListener.java
index 18967be6b0..ca2e430679 100644
--- a/java/org/apache/catalina/mbeans/RoleMBean.java
+++ b/java/org/apache/catalina/mbeans/RoleMBean.java
@@ -32,7 +32,7 @@ import org.apache.tomcat.util.modeler.Registry;
  * <code>org.apache.catalina.Role</code> component.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class RoleMBean extends BaseModelMBean {

==================================================
StandardContextMBean.java
index 2a9120c618..1a2d7614a5 100644
--- a/java/org/apache/catalina/mbeans/ServerLifecycleListener.java
+++ b/java/org/apache/catalina/mbeans/ServerLifecycleListener.java
@@ -59,7 +59,7 @@ import org.apache.juli.logging.LogFactory;
  *
  * @author Craig R. McClanahan
  * @author Amy Roh
- * @version $Revision: 303365 $ $Date: 2004-10-06 18:10:57 +0200 (mer., 06 oct. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class ServerLifecycleListener

==================================================
StandardEngineMBean.java
index b10eb1f753..0971646df3 100644
--- a/java/org/apache/catalina/mbeans/StandardContextMBean.java
+++ b/java/org/apache/catalina/mbeans/StandardContextMBean.java
@@ -38,7 +38,7 @@ import org.apache.tomcat.util.modeler.Registry;
  * <code>org.apache.catalina.core.StandardContext</code> component.</p>
  *
  * @author Amy Roh
- * @version $Revision: 303133 $ $Date: 2004-08-29 18:46:15 +0200 (dim., 29 août 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class StandardContextMBean extends BaseModelMBean {

==================================================
StandardHostMBean.java
index b303219c60..0e0d7e9442 100644
--- a/java/org/apache/catalina/mbeans/StandardEngineMBean.java
+++ b/java/org/apache/catalina/mbeans/StandardEngineMBean.java
@@ -30,7 +30,7 @@ import org.apache.tomcat.util.modeler.BaseModelMBean;
  * <code>org.apache.catalina.core.StandardEngine</code> component.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class StandardEngineMBean extends BaseModelMBean {

==================================================
StandardServerMBean.java
index 7692a3283d..cb9002415b 100644
--- a/java/org/apache/catalina/mbeans/StandardHostMBean.java
+++ b/java/org/apache/catalina/mbeans/StandardHostMBean.java
@@ -34,7 +34,7 @@ import org.apache.tomcat.util.modeler.Registry;
  * <code>org.apache.catalina.core.StandardHost</code> component.</p>
  *
  * @author Amy Roh
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class StandardHostMBean extends BaseModelMBean {

==================================================
StandardServiceMBean.java
index 0463bd4c52..3599da32a0 100644
--- a/java/org/apache/catalina/mbeans/StandardServerMBean.java
+++ b/java/org/apache/catalina/mbeans/StandardServerMBean.java
@@ -33,7 +33,7 @@ import org.apache.tomcat.util.modeler.BaseModelMBean;
  * <code>org.apache.catalina.core.StandardServer</code> component.</p>
  *
  * @author Amy Roh
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class StandardServerMBean extends BaseModelMBean {

==================================================
UserMBean.java
index d6e53e09fb..1d57460dce 100644
--- a/java/org/apache/catalina/mbeans/StandardServiceMBean.java
+++ b/java/org/apache/catalina/mbeans/StandardServiceMBean.java
@@ -30,7 +30,7 @@ import org.apache.tomcat.util.modeler.BaseModelMBean;
  * <code>org.apache.catalina.core.StandardService</code> component.</p>
  *
  * @author Amy Roh
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class StandardServiceMBean extends BaseModelMBean {

==================================================
Constants.java
index adcd02b1c7..104f25a62c 100644
--- a/java/org/apache/catalina/mbeans/UserMBean.java
+++ b/java/org/apache/catalina/mbeans/UserMBean.java
@@ -39,7 +39,7 @@ import org.apache.tomcat.util.modeler.Registry;
  * <code>org.apache.catalina.User</code> component.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302833 $ $Date: 2004-04-15 03:44:09 +0200 (jeu., 15 avr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class UserMBean extends BaseModelMBean {

==================================================
DataSourceRealm.java
index eb29ad2385..6507c42453 100644
--- a/java/org/apache/catalina/realm/Constants.java
+++ b/java/org/apache/catalina/realm/Constants.java
@@ -24,7 +24,7 @@ package org.apache.catalina.realm;
  *
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public final class Constants {

==================================================
GenericPrincipal.java
index 9766641a8f..b2f0c4ae38 100644
--- a/java/org/apache/catalina/realm/DataSourceRealm.java
+++ b/java/org/apache/catalina/realm/DataSourceRealm.java
@@ -45,7 +45,7 @@ import org.apache.catalina.util.StringManager;
 * @author Craig R. McClanahan
 * @author Carson McDonald
 * @author Ignacio Ortega
-* @version $Revision: 394121 $
+* @version $Revision$
 */
 
 public class DataSourceRealm

==================================================
JAASCallbackHandler.java
index d181af4bbc..f66c08205b 100644
--- a/java/org/apache/catalina/realm/GenericPrincipal.java
+++ b/java/org/apache/catalina/realm/GenericPrincipal.java
@@ -30,7 +30,7 @@ import org.apache.catalina.Realm;
  * is available for use by <code>Realm</code> implementations.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303827 $ $Date: 2005-04-01 13:36:52 +0200 (ven., 01 avr. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class GenericPrincipal implements Principal {

==================================================
JAASMemoryLoginModule.java
index bee4ede256..0a7c434b81 100644
--- a/java/org/apache/catalina/realm/JAASCallbackHandler.java
+++ b/java/org/apache/catalina/realm/JAASCallbackHandler.java
@@ -45,7 +45,7 @@ import org.apache.juli.logging.LogFactory;
  *
  * @author Craig R. McClanahan
  * @author Andrew R. Jaquith
- * @version $Revision: 303719 $ $Date: 2005-02-19 00:43:20 +0100 (sam., 19 févr. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class JAASCallbackHandler implements CallbackHandler {

==================================================
JAASRealm.java
index 5db1296d96..c4255f9e54 100644
--- a/java/org/apache/catalina/realm/JAASMemoryLoginModule.java
+++ b/java/org/apache/catalina/realm/JAASMemoryLoginModule.java
@@ -73,7 +73,7 @@ import org.apache.tomcat.util.digester.Digester;
  * the functionality required of a <code>Realm</code> implementation.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303719 $ $Date: 2005-02-19 00:43:20 +0100 (sam., 19 févr. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class JAASMemoryLoginModule extends MemoryRealm implements LoginModule, Realm {

==================================================
JDBCRealm.java
index 28ccb4bf5b..530a911f3e 100644
--- a/java/org/apache/catalina/realm/JAASRealm.java
+++ b/java/org/apache/catalina/realm/JAASRealm.java
@@ -120,7 +120,7 @@ org.foobar.auth.DatabaseLoginModule REQUIRED
 *
 * @author Craig R. McClanahan
 * @author Yoav Shapira
- * @version $Revision: 303827 $ $Date: 2005-04-01 13:36:52 +0200 (ven., 01 avr. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class JAASRealm

==================================================
JNDIRealm.java
index ab9573b34b..df1b56d98b 100644
--- a/java/org/apache/catalina/realm/JDBCRealm.java
+++ b/java/org/apache/catalina/realm/JDBCRealm.java
@@ -45,7 +45,7 @@ import org.apache.catalina.util.StringManager;
 * @author Craig R. McClanahan
 * @author Carson McDonald
 * @author Ignacio Ortega
-* @version $Revision: 373023 $ $Date: 2006-01-28 00:17:43 +0100 (sam., 28 janv. 2006) $
+* @version $Revision$ $Date$
 */
 
 public class JDBCRealm

==================================================
MemoryRealm.java
index b4868f11fb..7dcf2092b3 100644
--- a/java/org/apache/catalina/realm/LocalStrings_ja.properties
+++ b/java/org/apache/catalina/realm/LocalStrings_ja.properties
@@ -1,4 +1,4 @@
-# $Id: LocalStrings_ja.properties 302991 2004-07-03 04:16:41Z billbarker $
+# $Id$
 
 # language ja
 

==================================================
MemoryRuleSet.java
index 274e0e55c3..88b491938a 100644
--- a/java/org/apache/catalina/realm/MemoryRealm.java
+++ b/java/org/apache/catalina/realm/MemoryRealm.java
@@ -43,7 +43,7 @@ import org.apache.tomcat.util.digester.Digester;
  * synchronization is performed around accesses to the principals collection.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 373023 $ $Date: 2006-01-28 00:17:43 +0100 (sam., 28 janv. 2006) $
+ * @version $Revision$ $Date$
  */
 
 public class MemoryRealm  extends RealmBase {

==================================================
RealmBase.java
index 66512be822..788cefcbbd 100644
--- a/java/org/apache/catalina/realm/MemoryRuleSet.java
+++ b/java/org/apache/catalina/realm/MemoryRuleSet.java
@@ -30,7 +30,7 @@ import org.xml.sax.Attributes;
  * XML file processed by <code>MemoryRealm</code>.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302984 $ $Date: 2004-06-26 19:41:33 +0200 (sam., 26 juin 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class MemoryRuleSet extends RuleSetBase {

==================================================
UserDatabaseRealm.java
index 8e763a0f21..a184f52578 100644
--- a/java/org/apache/catalina/realm/RealmBase.java
+++ b/java/org/apache/catalina/realm/RealmBase.java
@@ -61,7 +61,7 @@ import org.apache.tomcat.util.modeler.Registry;
  * location) are identical to those currently supported by Tomcat 3.X.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 388949 $ $Date: 2006-03-26 21:55:03 +0200 (dim., 26 mars 2006) $
+ * @version $Revision$ $Date$
  */
 
 public abstract class RealmBase

==================================================
SecurityClassLoad.java
index 2fef268551..18a242d955 100644
--- a/java/org/apache/catalina/realm/UserDatabaseRealm.java
+++ b/java/org/apache/catalina/realm/UserDatabaseRealm.java
@@ -45,7 +45,7 @@ import org.apache.catalina.util.StringManager;
  * of <code>UserDatabase</code> that we should consult.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 373023 $ $Date: 2006-01-28 00:17:43 +0100 (sam., 28 janv. 2006) $
+ * @version $Revision$ $Date$
  * @since 4.1
  */
 

==================================================
CGIServlet.java
index 98fd56d40f..71c644d0d3 100644
--- a/java/org/apache/catalina/security/SecurityClassLoad.java
+++ b/java/org/apache/catalina/security/SecurityClassLoad.java
@@ -25,7 +25,7 @@ package org.apache.catalina.security;
  *
  * @author Glenn L. Nielsen
  * @author Jean-Francois Arcand
- * @version $Revision: 304042 $ $Date: 2005-08-04 08:07:46 +0200 (jeu., 04 août 2005) $
+ * @version $Revision$ $Date$
  */
 
 public final class SecurityClassLoad {

==================================================
DefaultServlet.java
index 31742eb1db..b685fea908 100644
--- a/java/org/apache/catalina/servlets/CGIServlet.java
+++ b/java/org/apache/catalina/servlets/CGIServlet.java
@@ -235,7 +235,7 @@ import org.apache.catalina.util.IOTools;
  *
  * @author Martin T Dengler [root@martindengler.com]
  * @author Amy Roh
- * @version $Revision: 421476 $, $Date: 2006-07-12 22:08:28 -0400 (Wed, 12 Jul 2006) $
+ * @version $Revision$, $Date$
  * @since Tomcat 4.0
  *
  */
@@ -694,7 +694,7 @@ public final class CGIServlet extends HttpServlet {
      * <p>
      * </p>
      *
-     * @version  $Revision: 421476 $, $Date: 2006-07-12 22:08:28 -0400 (Wed, 12 Jul 2006) $
+     * @version  $Revision$, $Date$
      * @since    Tomcat 4.0
      *
      */
@@ -1421,7 +1421,7 @@ public final class CGIServlet extends HttpServlet {
      * and <code>setResponse</code> methods, respectively.
      * </p>
      *
-     * @version   $Revision: 421476 $, $Date: 2006-07-12 22:08:28 -0400 (Wed, 12 Jul 2006) $
+     * @version   $Revision$, $Date$
      */
 
     protected class CGIRunner {

==================================================
InvokerHttpRequest.java
index ffba049222..46bb7e8fe8 100644
--- a/java/org/apache/catalina/servlets/DefaultServlet.java
+++ b/java/org/apache/catalina/servlets/DefaultServlet.java
@@ -71,7 +71,7 @@ import org.apache.naming.resources.ResourceAttributes;
  *
  * @author Craig R. McClanahan
  * @author Remy Maucherat
- * @version $Revision: 332127 $ $Date: 2005-11-09 20:50:47 +0100 (mer., 09 nov. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class DefaultServlet

==================================================
InvokerServlet.java
index 3138db5588..71f14316aa 100644
--- a/java/org/apache/catalina/servlets/InvokerHttpRequest.java
+++ b/java/org/apache/catalina/servlets/InvokerHttpRequest.java
@@ -30,7 +30,7 @@ import javax.servlet.http.HttpServletRequestWrapper;
  * to the servlet, because a new servlet mapping will have been created.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303211 $ $Date: 2004-09-08 12:38:14 +0200 (mer., 08 sept. 2004) $
+ * @version $Revision$ $Date$
  */
 
 class InvokerHttpRequest extends HttpServletRequestWrapper {

==================================================
WebdavServlet.java
index a21a1b65ae..de498ef48a 100644
--- a/java/org/apache/catalina/servlets/InvokerServlet.java
+++ b/java/org/apache/catalina/servlets/InvokerServlet.java
@@ -41,7 +41,7 @@ import org.apache.catalina.util.StringManager;
  * in the web application deployment descriptor.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public final class InvokerServlet

==================================================
FileStore.java
index 44ae4ac30b..0483a08051 100644
--- a/java/org/apache/catalina/servlets/WebdavServlet.java
+++ b/java/org/apache/catalina/servlets/WebdavServlet.java
@@ -66,7 +66,7 @@ import org.xml.sax.SAXException;
  * are handled by the DefaultServlet.
  *
  * @author Remy Maucherat
- * @version $Revision: 303599 $ $Date: 2004-12-20 19:54:14 +0100 (lun., 20 déc. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class WebdavServlet

==================================================
JDBCStore.java
index 3a63630847..9ce457cb56 100644
--- a/java/org/apache/catalina/session/FileStore.java
+++ b/java/org/apache/catalina/session/FileStore.java
@@ -47,7 +47,7 @@ import org.apache.catalina.util.CustomObjectInputStream;
  * saved are still subject to being expired based on inactivity.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303826 $ $Date: 2005-03-31 12:31:54 +0200 (jeu., 31 mars 2005) $
+ * @version $Revision$ $Date$
  */
 
 public final class FileStore

==================================================
ManagerBase.java
index c33c1edb5e..685f85e585 100644
--- a/java/org/apache/catalina/session/JDBCStore.java
+++ b/java/org/apache/catalina/session/JDBCStore.java
@@ -45,7 +45,7 @@ import java.util.Properties;
  * saved are still subject to being expired based on inactivity.
  *
  * @author Bip Thelin
- * @version $Revision: 303826 $, $Date: 2005-03-31 12:31:54 +0200 (jeu., 31 mars 2005) $
+ * @version $Revision$, $Date$
  */
 
 public class JDBCStore

==================================================
PersistentManager.java
index a2fa69cd75..eeaf1cb7ea 100644
--- a/java/org/apache/catalina/session/ManagerBase.java
+++ b/java/org/apache/catalina/session/ManagerBase.java
@@ -60,7 +60,7 @@ import org.apache.tomcat.util.modeler.Registry;
  * be subclassed to create more sophisticated Manager implementations.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 388112 $ $Date: 2006-03-23 10:00:30 +0100 (jeu., 23 mars 2006) $
+ * @version $Revision$ $Date$
  */
 
 public abstract class ManagerBase implements Manager, MBeanRegistration {

==================================================
PersistentManagerBase.java
index 29a8a9dd48..0959c7d1dc 100644
--- a/java/org/apache/catalina/session/PersistentManager.java
+++ b/java/org/apache/catalina/session/PersistentManager.java
@@ -29,7 +29,7 @@ package org.apache.catalina.session;
  * <li>Limit the number of active sessions kept in memory by
  *     swapping less active sessions out to disk.</li>
  *
- * @version $Revision: 302726 $
+ * @version $Revision$
  * @author Kief Morris (kief@kief.com)
  */
 

==================================================
StandardManager.java
index ff078671e2..9fc44864a8 100644
--- a/java/org/apache/catalina/session/PersistentManagerBase.java
+++ b/java/org/apache/catalina/session/PersistentManagerBase.java
@@ -47,7 +47,7 @@ import org.apache.juli.logging.LogFactory;
  *
  * @author Craig R. McClanahan
  * @author Jean-Francois Arcand
- * @version $Revision: 303826 $ $Date: 2005-03-31 12:31:54 +0200 (jeu., 31 mars 2005) $
+ * @version $Revision$ $Date$
  */
 
 public abstract class PersistentManagerBase

==================================================
StandardSession.java
index 490bc8f35e..23dea937dc 100644
--- a/java/org/apache/catalina/session/StandardManager.java
+++ b/java/org/apache/catalina/session/StandardManager.java
@@ -59,7 +59,7 @@ import org.apache.catalina.security.SecurityUtil;
  *
  * @author Craig R. McClanahan
  * @author Jean-Francois Arcand
- * @version $Revision: 387590 $ $Date: 2006-03-21 18:55:07 +0100 (mar., 21 mars 2006) $
+ * @version $Revision$ $Date$
  */
 
 public class StandardManager

==================================================
StandardSessionFacade.java
index 22e1b6a2e7..6b29c7404a 100644
--- a/java/org/apache/catalina/session/StandardSession.java
+++ b/java/org/apache/catalina/session/StandardSession.java
@@ -77,7 +77,7 @@ import org.apache.catalina.security.SecurityUtil;
  * @author Craig R. McClanahan
  * @author Sean Legassick
  * @author <a href="mailto:jon@latchkey.com">Jon S. Stevens</a>
- * @version $Revision: 384817 $ $Date: 2006-03-10 16:27:43 +0100 (ven., 10 mars 2006) $
+ * @version $Revision$ $Date$
  */
 
 public class StandardSession

==================================================
StoreBase.java
index 4a42b7a377..3c94f3e147 100644
--- a/java/org/apache/catalina/session/StandardSessionFacade.java
+++ b/java/org/apache/catalina/session/StandardSessionFacade.java
@@ -30,7 +30,7 @@ import javax.servlet.http.HttpSessionContext;
  * Facade for the StandardSession object.
  *
  * @author Remy Maucherat
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class StandardSessionFacade

==================================================
ByteArrayServletOutputStream.java
index 526eb9a243..0eddfd6a2b 100644
--- a/java/org/apache/catalina/session/StoreBase.java
+++ b/java/org/apache/catalina/session/StoreBase.java
@@ -34,7 +34,7 @@ import org.apache.catalina.util.StringManager;
  * support most of the functionality required by a Store.
  *
  * @author Bip Thelin
- * @version $Revision: 303826 $, $Date: 2005-03-31 12:31:54 +0200 (jeu., 31 mars 2005) $
+ * @version $Revision$, $Date$
  */
 
 public abstract class StoreBase

==================================================
ExpressionParseTree.java
index ace4911107..f16c335ebc 100644
--- a/java/org/apache/catalina/ssi/ByteArrayServletOutputStream.java
+++ b/java/org/apache/catalina/ssi/ByteArrayServletOutputStream.java
@@ -26,7 +26,7 @@ import javax.servlet.ServletOutputStream;
  * <code>SsiInclude</code>
  *
  * @author Bip Thelin
- * @version $Revision: 304045 $, $Date: 2005-08-04 14:18:30 +0200 (jeu., 04 août 2005) $
+ * @version $Revision$, $Date$
  * @see ServletOutputStream and ByteArrayOutputStream
  */
 public class ByteArrayServletOutputStream extends ServletOutputStream {

==================================================
ExpressionTokenizer.java
index 903b076992..6328f430a8 100644
--- a/java/org/apache/catalina/ssi/ExpressionParseTree.java
+++ b/java/org/apache/catalina/ssi/ExpressionParseTree.java
@@ -17,7 +17,7 @@ import java.util.List;
 /**
  * Represents a parsed expression.
  * 
- * @version $Revision: 303166 $
+ * @version $Revision$
  * @author Paul Speed
  */
 public class ExpressionParseTree {

==================================================
ResponseIncludeWrapper.java
index 9e006c3dec..242736196b 100644
--- a/java/org/apache/catalina/ssi/ExpressionTokenizer.java
+++ b/java/org/apache/catalina/ssi/ExpressionTokenizer.java
@@ -16,7 +16,7 @@ package org.apache.catalina.ssi;
  * patterned similar to the StreamTokenizer in the JDK but customized for SSI
  * conditional expression parsing.
  * 
- * @version $Revision: 304061 $
+ * @version $Revision$
  * @author Paul Speed
  */
 public class ExpressionTokenizer {

==================================================
SSICommand.java
index e6bfb78e6e..f214c7abc6 100644
--- a/java/org/apache/catalina/ssi/ResponseIncludeWrapper.java
+++ b/java/org/apache/catalina/ssi/ResponseIncludeWrapper.java
@@ -34,7 +34,7 @@ import org.apache.catalina.util.DateTool;
  * 
  * @author Bip Thelin
  * @author David Becker
- * @version $Revision: 304032 $, $Date: 2005-07-27 17:11:55 +0200 (mer., 27 juil. 2005) $
+ * @version $Revision$, $Date$
  */
 public class ResponseIncludeWrapper extends HttpServletResponseWrapper {
     /**

==================================================
SSIConditional.java
index 1b0557de67..d0cbbd9e78 100644
--- a/java/org/apache/catalina/ssi/SSICommand.java
+++ b/java/org/apache/catalina/ssi/SSICommand.java
@@ -19,7 +19,7 @@ import java.io.PrintWriter;
  * @author Bip Thelin
  * @author Dan Sandberg
  * @author David Becker
- * @version $Revision: 303882 $, $Date: 2005-04-23 12:22:37 +0200 (sam., 23 avr. 2005) $
+ * @version $Revision$, $Date$
  */
 public interface SSICommand {
     /**

==================================================
SSIConditionalState.java
index 3febc7f712..6a2664d11a 100644
--- a/java/org/apache/catalina/ssi/SSIConditional.java
+++ b/java/org/apache/catalina/ssi/SSIConditional.java
@@ -16,7 +16,7 @@ import java.text.ParseException;
 /**
  * SSI command that handles all conditional directives.
  * 
- * @version $Revision: 303882 $
+ * @version $Revision$
  * @author Paul Speed
  * @author David Becker
  */

==================================================
SSIConfig.java
index cb8df77ad8..31c1db6163 100644
--- a/java/org/apache/catalina/ssi/SSIConditionalState.java
+++ b/java/org/apache/catalina/ssi/SSIConditionalState.java
@@ -16,7 +16,7 @@ package org.apache.catalina.ssi;
  * information necessary to process the nested conditional commands ( if, elif,
  * else, endif ).
  * 
- * @version $Revision: 303166 $
+ * @version $Revision$
  * @author Dan Sandberg
  * @author Paul Speed
  */

==================================================
SSIEcho.java
index 8205db0923..6ef561e689 100644
--- a/java/org/apache/catalina/ssi/SSIConfig.java
+++ b/java/org/apache/catalina/ssi/SSIConfig.java
@@ -19,7 +19,7 @@ import java.io.PrintWriter;
  * @author Paul Speed
  * @author Dan Sandberg
  * @author David Becker
- * @version $Revision: 303882 $, $Date: 2005-04-23 12:22:37 +0200 (sam., 23 avr. 2005) $
+ * @version $Revision$, $Date$
  */
 public final class SSIConfig implements SSICommand {
     /**

==================================================
SSIExec.java
index 605f984470..8df9441bc4 100644
--- a/java/org/apache/catalina/ssi/SSIEcho.java
+++ b/java/org/apache/catalina/ssi/SSIEcho.java
@@ -19,7 +19,7 @@ import java.io.PrintWriter;
  * @author Paul Speed
  * @author Dan Sandberg
  * @author David Becker
- * @version $Revision: 303882 $, $Date: 2005-04-23 12:22:37 +0200 (sam., 23 avr. 2005) $
+ * @version $Revision$, $Date$
  */
 public class SSIEcho implements SSICommand {
     protected final static String DEFAULT_ENCODING = "entity";

==================================================
SSIExternalResolver.java
index c0c4f9cb40..aa4064504f 100644
--- a/java/org/apache/catalina/ssi/SSIExec.java
+++ b/java/org/apache/catalina/ssi/SSIExec.java
@@ -24,7 +24,7 @@ import org.apache.catalina.util.IOTools;
  * @author Paul Speed
  * @author Dan Sandberg
  * @author David Becker
- * @version $Revision: 303882 $, $Date: 2005-04-23 12:22:37 +0200 (sam., 23 avr. 2005) $
+ * @version $Revision$, $Date$
  */
 public class SSIExec implements SSICommand {
     protected SSIInclude ssiInclude = new SSIInclude();

==================================================
SSIFilter.java
index f944d39bcc..9364d8dedd 100644
--- a/java/org/apache/catalina/ssi/SSIExternalResolver.java
+++ b/java/org/apache/catalina/ssi/SSIExternalResolver.java
@@ -19,7 +19,7 @@ import java.util.Date;
  * servlet )
  * 
  * @author Dan Sandberg
- * @version $Revision: 303166 $, $Date: 2004-09-01 20:33:33 +0200 (mer., 01 sept. 2004) $
+ * @version $Revision$, $Date$
  */
 public interface SSIExternalResolver {
     /**

==================================================
SSIFlastmod.java
index 57b73e5b44..d4231fd2b3 100644
--- a/java/org/apache/catalina/ssi/SSIFilter.java
+++ b/java/org/apache/catalina/ssi/SSIFilter.java
@@ -38,7 +38,7 @@ import org.apache.catalina.Globals;
  * from within web.xml.
  * 
  * @author David Becker
- * @version $Revision: 303920 $, $Date: 2005-05-05 22:52:37 +0200 (jeu., 05 mai 2005) $
+ * @version $Revision$, $Date$
  * @see org.apache.catalina.ssi.SSIServlet
  */
 public class SSIFilter implements Filter {

==================================================
SSIFsize.java
index 16ba362be5..2d3bef579d 100644
--- a/java/org/apache/catalina/ssi/SSIFlastmod.java
+++ b/java/org/apache/catalina/ssi/SSIFlastmod.java
@@ -23,7 +23,7 @@ import org.apache.catalina.util.Strftime;
  * @author Paul Speed
  * @author Dan Sandberg
  * @author David Becker
- * @version $Revision: 304061 $, $Date: 2005-08-17 23:21:37 +0200 (mer., 17 août 2005) $
+ * @version $Revision$, $Date$
  */
 public final class SSIFlastmod implements SSICommand {
     /**

==================================================
SSIInclude.java
index 157ed18a5e..683c2b81c3 100644
--- a/java/org/apache/catalina/ssi/SSIFsize.java
+++ b/java/org/apache/catalina/ssi/SSIFsize.java
@@ -21,7 +21,7 @@ import java.text.DecimalFormat;
  * @author Paul Speed
  * @author Dan Sandberg
  * @author David Becker
- * @version $Revision: 303882 $, $Date: 2005-04-23 12:22:37 +0200 (sam., 23 avr. 2005) $
+ * @version $Revision$, $Date$
  */
 public final class SSIFsize implements SSICommand {
     protected final static int ONE_KILOBYTE = 1024;

==================================================
SSIMediator.java
index 991be71a8d..4e2568368c 100644
--- a/java/org/apache/catalina/ssi/SSIInclude.java
+++ b/java/org/apache/catalina/ssi/SSIInclude.java
@@ -20,7 +20,7 @@ import java.io.PrintWriter;
  * @author Paul Speed
  * @author Dan Sandberg
  * @author David Becker
- * @version $Revision: 303882 $, $Date: 2005-04-23 12:22:37 +0200 (sam., 23 avr. 2005) $
+ * @version $Revision$, $Date$
  */
 public final class SSIInclude implements SSICommand {
     /**

==================================================
SSIPrintenv.java
index e585e4f668..18f4e87489 100644
--- a/java/org/apache/catalina/ssi/SSIMediator.java
+++ b/java/org/apache/catalina/ssi/SSIMediator.java
@@ -30,7 +30,7 @@ import org.apache.catalina.util.URLEncoder;
  * @author Paul Speed
  * @author Dan Sandberg
  * @author David Becker
- * @version $Revision: 303882 $, $Date: 2005-04-23 12:22:37 +0200 (sam., 23 avr. 2005) $
+ * @version $Revision$, $Date$
  */
 public class SSIMediator {
     protected final static String DEFAULT_CONFIG_ERR_MSG = "[an error occurred while processing this directive]";

==================================================
SSIProcessor.java
index 68b7b5c872..772097db6c 100644
--- a/java/org/apache/catalina/ssi/SSIPrintenv.java
+++ b/java/org/apache/catalina/ssi/SSIPrintenv.java
@@ -19,7 +19,7 @@ import java.util.Iterator;
  * 
  * @author Dan Sandberg
  * @author David Becker
- * @version $Revision: 303882 $, $Date: 2005-04-23 12:22:37 +0200 (sam., 23 avr. 2005) $
+ * @version $Revision$, $Date$
  */
 public class SSIPrintenv implements SSICommand {
     /**

==================================================
SSIServlet.java
index dfeb8e01f3..0476ccd62a 100644
--- a/java/org/apache/catalina/ssi/SSIProcessor.java
+++ b/java/org/apache/catalina/ssi/SSIProcessor.java
@@ -25,7 +25,7 @@ import org.apache.catalina.util.IOTools;
  * 
  * @author Dan Sandberg
  * @author David Becker
- * @version $Revision: 303882 $, $Date: 2005-04-23 12:22:37 +0200 (sam., 23 avr. 2005) $
+ * @version $Revision$, $Date$
  */
 public class SSIProcessor {
     /** The start pattern */

==================================================
SSIServletExternalResolver.java
index e28a94ccb1..2e03d1e2b3 100644
--- a/java/org/apache/catalina/ssi/SSIServlet.java
+++ b/java/org/apache/catalina/ssi/SSIServlet.java
@@ -33,7 +33,7 @@ import org.apache.catalina.Globals;
  * @author Amy Roh
  * @author Dan Sandberg
  * @author David Becker
- * @version $Revision: 303882 $, $Date: 2005-04-23 12:22:37 +0200 (sam., 23 avr. 2005) $
+ * @version $Revision$, $Date$
  */
 public class SSIServlet extends HttpServlet {
     /** Debug level for this servlet. */

==================================================
SSISet.java
index 9b0c764e91..eefbd59a3c 100644
--- a/java/org/apache/catalina/ssi/SSIServletExternalResolver.java
+++ b/java/org/apache/catalina/ssi/SSIServletExternalResolver.java
@@ -32,7 +32,7 @@ import org.apache.coyote.Constants;
  * 
  * @author Dan Sandberg
  * @author David Becker
- * @version $Revision: 349308 $, $Date: 2005-11-27 21:52:55 +0100 (dim., 27 nov. 2005) $
+ * @version $Revision$, $Date$
  */
 public class SSIServletExternalResolver implements SSIExternalResolver {
     protected final String VARIABLE_NAMES[] = {"AUTH_TYPE", "CONTENT_LENGTH",

==================================================
SSIStopProcessingException.java
index b1250176b0..ea9f871f6f 100644
--- a/java/org/apache/catalina/ssi/SSISet.java
+++ b/java/org/apache/catalina/ssi/SSISet.java
@@ -18,7 +18,7 @@ import java.io.PrintWriter;
  * @author Paul Speed
  * @author Dan Sandberg
  * @author David Becker
- * @version $Revision: 303882 $, $Date: 2005-04-23 12:22:37 +0200 (sam., 23 avr. 2005) $
+ * @version $Revision$, $Date$
  */
 public class SSISet implements SSICommand {
     /**

==================================================
Bootstrap.java
index 8a8a50ebe8..3f62bca694 100644
--- a/java/org/apache/catalina/ssi/SSIStopProcessingException.java
+++ b/java/org/apache/catalina/ssi/SSIStopProcessingException.java
@@ -18,7 +18,7 @@ package org.apache.catalina.ssi;
  * 
  * @author Paul Speed
  * @author Dan Sandberg
- * @version $Revision: 303166 $, $Date: 2004-09-01 20:33:33 +0200 (mer., 01 sept. 2004) $
+ * @version $Revision$, $Date$
  */
 public class SSIStopProcessingException extends Exception {
 }
\ No newline at end of file

==================================================
Catalina.java
index 28bc37b861..b775f0aba5 100644
--- a/java/org/apache/catalina/startup/Bootstrap.java
+++ b/java/org/apache/catalina/startup/Bootstrap.java
@@ -46,7 +46,7 @@ import org.apache.juli.logging.LogFactory;
  *
  * @author Craig R. McClanahan
  * @author Remy Maucherat
- * @version $Revision: 304108 $ $Date: 2005-09-29 07:55:15 +0200 (jeu., 29 sept. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public final class Bootstrap {

==================================================
CatalinaProperties.java
index 1f9b76d6e6..ae2692b010 100644
--- a/java/org/apache/catalina/startup/Catalina.java
+++ b/java/org/apache/catalina/startup/Catalina.java
@@ -52,7 +52,7 @@ import org.xml.sax.InputSource;
  *
  * @author Craig R. McClanahan
  * @author Remy Maucherat
- * @version $Revision: 380229 $ $Date: 2006-02-23 22:28:29 +0100 (jeu., 23 févr. 2006) $
+ * @version $Revision$ $Date$
  */
 
 public class Catalina extends Embedded {

==================================================
ClassLoaderFactory.java
index 1e0bd15029..a3bc76529a 100644
--- a/java/org/apache/catalina/startup/CatalinaProperties.java
+++ b/java/org/apache/catalina/startup/CatalinaProperties.java
@@ -30,7 +30,7 @@ import java.util.Properties;
  * Utility class to read the bootstrap Catalina configuration.
  *
  * @author Remy Maucherat
- * @version $Revision: 304109 $ $Date: 2005-09-29 16:36:25 +0200 (jeu., 29 sept. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class CatalinaProperties {

==================================================
ClusterRuleSetFactory.java
index 6d83660066..a9d36b717d 100644
--- a/java/org/apache/catalina/startup/ClassLoaderFactory.java
+++ b/java/org/apache/catalina/startup/ClassLoaderFactory.java
@@ -44,7 +44,7 @@ import org.apache.juli.logging.LogFactory;
  * </ul>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303210 $ $Date: 2004-09-08 01:13:01 +0200 (mer., 08 sept. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public final class ClassLoaderFactory {

==================================================
ConnectorCreateRule.java
index f3589f37a2..ea1494d588 100644
--- a/java/org/apache/catalina/startup/ClusterRuleSetFactory.java
+++ b/java/org/apache/catalina/startup/ClusterRuleSetFactory.java
@@ -85,7 +85,7 @@ public class ClusterRuleSetFactory {
      *
      * @author Filip Hanik
      * @author Peter Rossbach
-     * @version $Revision: 379550 $ $Date: 2006-02-21 12:06:35 -0600 (Tue, 21 Feb 2006) $
+     * @version $Revision$ $Date$
      */
 
     public static class DefaultClusterRuleSet extends RuleSetBase {

==================================================
Constants.java
index 7e4cbb67f3..308b3dd7e4 100644
--- a/java/org/apache/catalina/startup/ConnectorCreateRule.java
+++ b/java/org/apache/catalina/startup/ConnectorCreateRule.java
@@ -1,4 +1,4 @@
-/* $Id: ConnectorCreateRule.java 303287 2004-09-29 09:55:39Z remm $
+/* $Id$
  *
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with

==================================================
ContextConfig.java
index c7c67766d2..2cc9ba5455 100644
--- a/java/org/apache/catalina/startup/Constants.java
+++ b/java/org/apache/catalina/startup/Constants.java
@@ -24,7 +24,7 @@ package org.apache.catalina.startup;
  *
  * @author Craig R. McClanahan
  * @author Jean-Francois Arcand
- * @version $Revision: 303179 $ $Date: 2004-09-02 12:28:00 +0200 (jeu., 02 sept. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public final class Constants {

==================================================
ContextRuleSet.java
index 73df31c38e..27328a08a4 100644
--- a/java/org/apache/catalina/startup/ContextConfig.java
+++ b/java/org/apache/catalina/startup/ContextConfig.java
@@ -64,7 +64,7 @@ import org.xml.sax.SAXParseException;
  *
  * @author Craig R. McClanahan
  * @author Jean-Francois Arcand
- * @version $Revision: 379614 $ $Date: 2006-02-22 00:02:57 +0100 (mer., 22 févr. 2006) $
+ * @version $Revision$ $Date$
  */
 
 public class ContextConfig

==================================================
CopyParentClassLoaderRule.java
index 490b1ddb28..62edc9826e 100644
--- a/java/org/apache/catalina/startup/ContextRuleSet.java
+++ b/java/org/apache/catalina/startup/ContextRuleSet.java
@@ -35,7 +35,7 @@ import org.xml.sax.Attributes;
  * DefaultContext, be sure to specify a prefix that ends with "/Default".</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 345090 $ $Date: 2005-11-16 19:51:09 +0100 (mer., 16 nov. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class ContextRuleSet extends RuleSetBase {

==================================================
Embedded.java
index 51544321ac..7804608631 100644
--- a/java/org/apache/catalina/startup/CopyParentClassLoaderRule.java
+++ b/java/org/apache/catalina/startup/CopyParentClassLoaderRule.java
@@ -32,7 +32,7 @@ import org.xml.sax.Attributes;
  * <code>Container</code>).</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302984 $ $Date: 2004-06-26 19:41:33 +0200 (sam., 26 juin 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class CopyParentClassLoaderRule extends Rule {

==================================================
EngineConfig.java
index 9be97480c3..30f3b819f7 100644
--- a/java/org/apache/catalina/startup/Embedded.java
+++ b/java/org/apache/catalina/startup/Embedded.java
@@ -98,7 +98,7 @@ import org.apache.tomcat.util.log.SystemLogHandler;
  * of how Tomcat is set up and launched as an Embedded application.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 304107 $ $Date: 2005-09-29 07:52:48 +0200 (jeu., 29 sept. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class Embedded  extends StandardService implements Lifecycle {

==================================================
EngineRuleSet.java
index 683f38f062..a29d008509 100644
--- a/java/org/apache/catalina/startup/EngineConfig.java
+++ b/java/org/apache/catalina/startup/EngineConfig.java
@@ -31,7 +31,7 @@ import org.apache.catalina.util.StringManager;
  * of that Engine, and the associated defined contexts.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 349922 $ $Date: 2005-11-30 12:10:55 +0100 (mer., 30 nov. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class EngineConfig

==================================================
ExpandWar.java
index 545c4a6705..1e95b8fa8e 100644
--- a/java/org/apache/catalina/startup/EngineRuleSet.java
+++ b/java/org/apache/catalina/startup/EngineRuleSet.java
@@ -31,7 +31,7 @@ import org.apache.tomcat.util.digester.RuleSetBase;
  * <code>ContextRuleSet</code>, respectively.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303970 $ $Date: 2005-06-30 15:08:14 +0200 (jeu., 30 juin 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class EngineRuleSet extends RuleSetBase {

==================================================
HomesUserDatabase.java
index 5a22a2f1b9..a091268af5 100644
--- a/java/org/apache/catalina/startup/ExpandWar.java
+++ b/java/org/apache/catalina/startup/ExpandWar.java
@@ -42,7 +42,7 @@ import org.apache.juli.logging.LogFactory;
  * @author Craig R. McClanahan
  * @author Remy Maucherat
  * @author Glenn L. Nielsen
- * @version $Revision: 303769 $
+ * @version $Revision$
  */
 
 public class ExpandWar {

==================================================
HostConfig.java
index 663e7df846..0707123a0a 100644
--- a/java/org/apache/catalina/startup/HomesUserDatabase.java
+++ b/java/org/apache/catalina/startup/HomesUserDatabase.java
@@ -30,7 +30,7 @@ import java.util.Enumeration;
  * to our constructor to be "home" directories for those users.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public final class HomesUserDatabase

==================================================
HostRuleSet.java
index 2f5fe37fba..dbdf82e0e1 100644
--- a/java/org/apache/catalina/startup/HostConfig.java
+++ b/java/org/apache/catalina/startup/HostConfig.java
@@ -52,7 +52,7 @@ import org.apache.tomcat.util.modeler.Registry;
  *
  * @author Craig R. McClanahan
  * @author Remy Maucherat
- * @version $Revision: 386336 $ $Date: 2006-03-16 15:13:00 +0100 (jeu., 16 mars 2006) $
+ * @version $Revision$ $Date$
  */
 public class HostConfig
     implements LifecycleListener {

==================================================
NamingRuleSet.java
index 2b533f1a3a..c3b594d1fc 100644
--- a/java/org/apache/catalina/startup/HostRuleSet.java
+++ b/java/org/apache/catalina/startup/HostRuleSet.java
@@ -30,7 +30,7 @@ import org.apache.tomcat.util.digester.RuleSetBase;
  * be added via instances of <code>ContextRuleSet</code>.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302984 $ $Date: 2004-06-26 19:41:33 +0200 (sam., 26 juin 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class HostRuleSet extends RuleSetBase {

==================================================
PasswdUserDatabase.java
index 76d902c234..10fdd69f4d 100644
--- a/java/org/apache/catalina/startup/NamingRuleSet.java
+++ b/java/org/apache/catalina/startup/NamingRuleSet.java
@@ -29,7 +29,7 @@ import org.apache.tomcat.util.digester.RuleSetBase;
  *
  * @author Craig R. McClanahan
  * @author Remy Maucherat
- * @version $Revision: 303177 $ $Date: 2004-09-02 12:05:00 +0200 (jeu., 02 sept. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class NamingRuleSet extends RuleSetBase {

==================================================
SetNextNamingRule.java
index 4ad7041fbb..82e6ec81e7 100644
--- a/java/org/apache/catalina/startup/PasswdUserDatabase.java
+++ b/java/org/apache/catalina/startup/PasswdUserDatabase.java
@@ -31,7 +31,7 @@ import java.util.Enumeration;
  * that processes the <code>/etc/passwd</code> file on a Unix system.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public final class PasswdUserDatabase

==================================================
TldRuleSet.java
index 9e3b1f767e..253d576042 100644
--- a/java/org/apache/catalina/startup/SetNextNamingRule.java
+++ b/java/org/apache/catalina/startup/SetNextNamingRule.java
@@ -1,4 +1,4 @@
-/* $Id: SetNextNamingRule.java 303133 2004-08-29 16:46:15Z yoavs $
+/* $Id$
  *
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with

==================================================
Tool.java
index b24b540db8..e11ea99633 100644
--- a/java/org/apache/catalina/startup/TldRuleSet.java
+++ b/java/org/apache/catalina/startup/TldRuleSet.java
@@ -28,7 +28,7 @@ import org.apache.tomcat.util.digester.RuleSetBase;
  * descriptor resource.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302984 $ $Date: 2004-06-26 19:41:33 +0200 (sam., 26 juin 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class TldRuleSet extends RuleSetBase {

==================================================
UserConfig.java
index 9faee0c17f..91c52c2445 100644
--- a/java/org/apache/catalina/startup/Tool.java
+++ b/java/org/apache/catalina/startup/Tool.java
@@ -67,7 +67,7 @@ import org.apache.juli.logging.LogFactory;
  * </ul>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302983 $ $Date: 2004-06-26 01:56:25 +0200 (sam., 26 juin 2004) $
+ * @version $Revision$ $Date$
  */
 
 public final class Tool {

==================================================
UserDatabase.java
index 994dbe313a..5889cab0e6 100644
--- a/java/org/apache/catalina/startup/UserConfig.java
+++ b/java/org/apache/catalina/startup/UserConfig.java
@@ -38,7 +38,7 @@ import org.apache.catalina.util.StringManager;
  * xxxxx is the username of the owning user for that web application
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302976 $ $Date: 2004-06-23 15:51:38 +0200 (mer., 23 juin 2004) $
+ * @version $Revision$ $Date$
  */
 
 public final class UserConfig

==================================================
WebAnnotationSet.java
index 8cc0b543bf..580143ac26 100644
--- a/java/org/apache/catalina/startup/UserDatabase.java
+++ b/java/org/apache/catalina/startup/UserDatabase.java
@@ -27,7 +27,7 @@ import java.util.Enumeration;
  * current server platform.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public interface UserDatabase {

==================================================
WebRuleSet.java
index b1fa073796..18e57cb2c8 100644
--- a/java/org/apache/catalina/startup/WebAnnotationSet.java
+++ b/java/org/apache/catalina/startup/WebAnnotationSet.java
@@ -39,7 +39,7 @@ import org.apache.catalina.deploy.MessageDestinationRef;
  * classes (<code>/WEB-INF/classes</code> and <code>/WEB-INF/lib</code>).</p>
  *
  * @author Fabien Carrion
- * @version $Revision: 304108 $ $Date: 2006-03-01 10:39:15 -0700 (Wed, 03 Mar 2006) $
+ * @version $Revision$ $Date$
  */
 
 public class WebAnnotationSet {

==================================================
ByteMessage.java
index 38d6da5ad6..cc4f631c1a 100644
--- a/java/org/apache/catalina/startup/WebRuleSet.java
+++ b/java/org/apache/catalina/startup/WebRuleSet.java
@@ -39,7 +39,7 @@ import org.xml.sax.Attributes;
  * deployment descriptor (<code>/WEB-INF/web.xml</code>) resource.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 304108 $ $Date: 2005-09-29 07:55:15 +0200 (jeu., 29 sept. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class WebRuleSet extends RuleSetBase {

==================================================
Channel.java
index ee356777dd..14181798f3 100644
--- a/java/org/apache/catalina/tribes/ByteMessage.java
+++ b/java/org/apache/catalina/tribes/ByteMessage.java
@@ -1,102 +1,102 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes;
-
-import java.io.Serializable;
-import java.io.Externalizable;
-import java.io.ObjectInput;
-import java.io.IOException;
-import java.io.ObjectOutput;
-
-/**
- * A byte message is not serialized and deserialized by the channel
- * instead it is sent as a byte array<br>
- * By default Tribes uses java serialization when it receives an object
- * to be sent over the wire. Java serialization is not the most
- * efficient of serializing data, and Tribes might not even
- * have access to the correct class loaders to deserialize the object properly.
- * <br>
- * The ByteMessage class is a class where the channel when it receives it will
- * not attempt to perform serialization, instead it will simply stream the <code>getMessage()</code>
- * bytes.<br>
- * If you are using multiple applications on top of Tribes you should add some sort of header
- * so that you can decide with the <code>ChannelListener.accept()</code> whether this message was intended
- * for you.
- * @author Filip Hanik
- * @version $Revision: 304032 $, $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
- */
-
-public class ByteMessage implements Serializable, Externalizable {
-    /**
-     * Storage for the message to be sent
-     */
-    private byte[] message;
-
-
-    /**
-     * Creates an empty byte message
-     * Constructor also for deserialization
-     */
-    public ByteMessage() {
-    }
-
-    /**
-     * Creates a byte message wit h
-     * @param data byte[] - the message contents
-     */
-    public ByteMessage(byte[] data) {
-        message = data;
-    }
-
-    /**
-     * Returns the message contents of this byte message
-     * @return byte[] - message contents, can be null
-     */
-    public byte[] getMessage() {
-        return message;
-    }
-
-    /**
-     * Sets the message contents of this byte message
-     * @param message byte[]
-     */
-    public void setMessage(byte[] message) {
-        this.message = message;
-    }
-
-    /**
-     * @see java.io.Externalizable#readExternal
-     * @param in ObjectInput
-     * @throws IOException
-     */
-    public void readExternal(ObjectInput in ) throws IOException {
-        int length = in.readInt();
-        message = new byte[length];
-        in.read(message,0,length);
-    }
-
-    /**
-     * @see java.io.Externalizable#writeExternal
-     * @param out ObjectOutput
-     * @throws IOException
-     */
-    public void writeExternal(ObjectOutput out) throws IOException {
-        out.writeInt(message!=null?message.length:0);
-        if ( message!=null ) out.write(message,0,message.length);
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes;
+
+import java.io.Serializable;
+import java.io.Externalizable;
+import java.io.ObjectInput;
+import java.io.IOException;
+import java.io.ObjectOutput;
+
+/**
+ * A byte message is not serialized and deserialized by the channel
+ * instead it is sent as a byte array<br>
+ * By default Tribes uses java serialization when it receives an object
+ * to be sent over the wire. Java serialization is not the most
+ * efficient of serializing data, and Tribes might not even
+ * have access to the correct class loaders to deserialize the object properly.
+ * <br>
+ * The ByteMessage class is a class where the channel when it receives it will
+ * not attempt to perform serialization, instead it will simply stream the <code>getMessage()</code>
+ * bytes.<br>
+ * If you are using multiple applications on top of Tribes you should add some sort of header
+ * so that you can decide with the <code>ChannelListener.accept()</code> whether this message was intended
+ * for you.
+ * @author Filip Hanik
+ * @version $Revision$, $Date$
+ */
+
+public class ByteMessage implements Serializable, Externalizable {
+    /**
+     * Storage for the message to be sent
+     */
+    private byte[] message;
+
+
+    /**
+     * Creates an empty byte message
+     * Constructor also for deserialization
+     */
+    public ByteMessage() {
+    }
+
+    /**
+     * Creates a byte message wit h
+     * @param data byte[] - the message contents
+     */
+    public ByteMessage(byte[] data) {
+        message = data;
+    }
+
+    /**
+     * Returns the message contents of this byte message
+     * @return byte[] - message contents, can be null
+     */
+    public byte[] getMessage() {
+        return message;
+    }
+
+    /**
+     * Sets the message contents of this byte message
+     * @param message byte[]
+     */
+    public void setMessage(byte[] message) {
+        this.message = message;
+    }
+
+    /**
+     * @see java.io.Externalizable#readExternal
+     * @param in ObjectInput
+     * @throws IOException
+     */
+    public void readExternal(ObjectInput in ) throws IOException {
+        int length = in.readInt();
+        message = new byte[length];
+        in.read(message,0,length);
+    }
+
+    /**
+     * @see java.io.Externalizable#writeExternal
+     * @param out ObjectOutput
+     * @throws IOException
+     */
+    public void writeExternal(ObjectOutput out) throws IOException {
+        out.writeInt(message!=null?message.length:0);
+        if ( message!=null ) out.write(message,0,message.length);
+    }
+
+}

==================================================
ChannelException.java
index c0859187e1..73760d2bf9 100644
--- a/java/org/apache/catalina/tribes/Channel.java
+++ b/java/org/apache/catalina/tribes/Channel.java
@@ -1,347 +1,347 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes;
-
-import java.io.Serializable;
-
-/**
- * Channel interface<br>
- * A channel is a representation of a group of nodes all participating in some sort of
- * communication with each other.<br>
- * The channel is the main API class for Tribes, this is essentially the only class
- * that an application needs to be aware of. Through the channel the application can:<br>
- * 1. send messages<br>
- * 2. receive message (by registering a <code>ChannelListener</code><br>
- * 3. get all members of the group <code>getMembers()</code><br>
- * 4. receive notifications of members added and members disappeared by
- *    registerering a <code>MembershipListener</code><br>
- * <br>
- * The channel has 5 major components:<br>
- * 1. Data receiver, with a built in thread pool to receive messages from other peers<br>
- * 2. Data sender, an implementation for sending data using NIO or java.io<br>
- * 3. Membership listener,listens for membership broadcasts<br>
- * 4. Membership broadcaster, broadcasts membership pings.<br>
- * 5. Channel interceptors, the ability to manipulate messages as they are sent or arrive<br><br>
- * The channel layout is:
- * <pre><code>
- *  ChannelListener_1..ChannelListener_N MembershipListener_1..MembershipListener_N [Application Layer]
- *            \          \                  /                   /
- *             \          \                /                   /
- *              \          \              /                   /
- *               \          \            /                   /
- *                \          \          /                   /
- *                 \          \        /                   /
- *                  ---------------------------------------
- *                                  |
- *                                  |
- *                               Channel
- *                                  |
- *                         ChannelInterceptor_1
- *                                  |                                               [Channel stack]
- *                         ChannelInterceptor_N
- *                                  |
- *                             Coordinator (implements MessageListener,MembershipListener,ChannelInterceptor)
- *                          --------------------
- *                         /        |           \ 
- *                        /         |            \
- *                       /          |             \
- *                      /           |              \
- *                     /            |               \
- *           MembershipService ChannelSender ChannelReceiver                        [IO layer]
- * </code></pre>
- * 
- * For example usage @see org.apache.catalina.tribes.group.GroupChannel
- * @author Filip Hanik
- * @version $Revision: 304032 $, $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
- */
-public interface Channel {
-    
-    /**
-     * Start and stop sequences can be controlled by these constants
-     * This allows you to start separate components of the channel <br>
-     * DEFAULT - starts or stops all components in the channel
-     * @see #start(int)
-     * @see #stop(int)
-     */
-    public static final int DEFAULT = 15;
-
-    /**
-     * Start and stop sequences can be controlled by these constants
-     * This allows you to start separate components of the channel <br>
-     * SND_RX_SEQ - starts or stops the data receiver. Start means opening a server socket
-     * in case of a TCP implementation
-     * @see #start(int)
-     * @see #stop(int)
-     */
-    public static final int SND_RX_SEQ = 1;
-
-    /**
-     * Start and stop sequences can be controlled by these constants
-     * This allows you to start separate components of the channel <br>
-     * SND_TX_SEQ - starts or stops the data sender. This should not open any sockets,
-     * as sockets are opened on demand when a message is being sent
-     * @see #start(int)
-     * @see #stop(int)
-     */
-    public static final int SND_TX_SEQ = 2;
-
-    /**
-     * Start and stop sequences can be controlled by these constants
-     * This allows you to start separate components of the channel <br>
-     * MBR_RX_SEQ - starts or stops the membership listener. In a multicast implementation
-     * this will open a datagram socket and join a group and listen for membership messages
-     * members joining
-     * @see #start(int)
-     * @see #stop(int)
-     */
-    public static final int MBR_RX_SEQ = 4;
-
-    /**
-     * Start and stop sequences can be controlled by these constants
-     * This allows you to start separate components of the channel <br>
-     * MBR_TX_SEQ - starts or stops the membership broadcaster. In a multicast implementation
-     * this will open a datagram socket and join a group and broadcast the local member information
-     * @see #start(int)
-     * @see #stop(int)
-     */
-    public static final int MBR_TX_SEQ = 8;
-    
-    /**
-     * Send options, when a message is sent, it can have an option flag
-     * to trigger certain behavior. Most flags are used to trigger channel interceptors
-     * as the message passes through the channel stack. <br>
-     * However, there are five default flags that every channel implementation must implement<br>
-     * SEND_OPTIONS_BYTE_MESSAGE - The message is a pure byte message and no marshalling or unmarshalling will
-     * be performed.<br>
-     * 
-     * @see #send(Member[], Serializable , int)
-     * @see #send(Member[], Serializable, int, ErrorHandler)
-     */
-    public static final int SEND_OPTIONS_BYTE_MESSAGE = 0x0001;
-
-    /**
-     * Send options, when a message is sent, it can have an option flag
-     * to trigger certain behavior. Most flags are used to trigger channel interceptors
-     * as the message passes through the channel stack. <br>
-     * However, there are five default flags that every channel implementation must implement<br>
-     * SEND_OPTIONS_USE_ACK - Message is sent and an ACK is received when the message has been received by the recipient<br>
-     * If no ack is received, the message is not considered successful<br>
-     * @see #send(Member[], Serializable , int)
-     * @see #send(Member[], Serializable, int, ErrorHandler)
-     */
-    public static final int SEND_OPTIONS_USE_ACK = 0x0002;
-
-    /**
-     * Send options, when a message is sent, it can have an option flag
-     * to trigger certain behavior. Most flags are used to trigger channel interceptors
-     * as the message passes through the channel stack. <br>
-     * However, there are five default flags that every channel implementation must implement<br>
-     * SEND_OPTIONS_SYNCHRONIZED_ACK - Message is sent and an ACK is received when the message has been received and 
-     * processed by the recipient<br>
-     * If no ack is received, the message is not considered successful<br>
-     * @see #send(Member[], Serializable , int)
-     * @see #send(Member[], Serializable, int, ErrorHandler)
-     */
-    public static final int SEND_OPTIONS_SYNCHRONIZED_ACK = 0x0004;
-    
-    /**
-     * Send options, when a message is sent, it can have an option flag
-     * to trigger certain behavior. Most flags are used to trigger channel interceptors
-     * as the message passes through the channel stack. <br>
-     * However, there are five default flags that every channel implementation must implement<br>
-     * SEND_OPTIONS_ASYNCHRONOUS - Message is sent and an ACK is received when the message has been received and 
-     * processed by the recipient<br>
-     * If no ack is received, the message is not considered successful<br>
-     * @see #send(Member[], Serializable , int)
-     * @see #send(Member[], Serializable, int, ErrorHandler)
-     */
-    public static final int SEND_OPTIONS_ASYNCHRONOUS = 0x0008;
-    
-    /**
-     * Send options, when a message is sent, it can have an option flag
-     * to trigger certain behavior. Most flags are used to trigger channel interceptors
-     * as the message passes through the channel stack. <br>
-     * However, there are five default flags that every channel implementation must implement<br>
-     * SEND_OPTIONS_SECURE - Message is sent over an encrypted channel<br>
-     * @see #send(Member[], Serializable , int)
-     * @see #send(Member[], Serializable, int, ErrorHandler)
-     */
-    public static final int SEND_OPTIONS_SECURE = 0x0010;
-    
-
-    /**
-     * Send options, when a message is sent, it can have an option flag
-     * to trigger certain behavior. Most flags are used to trigger channel interceptors
-     * as the message passes through the channel stack. <br>
-     * However, there are five default flags that every channel implementation must implement<br>
-     * SEND_OPTIONS_DEFAULT - the default sending options, just a helper variable. <br>
-     * The default is <code>int SEND_OPTIONS_DEFAULT = SEND_OPTIONS_USE_ACK;</code><br>
-     * @see #SEND_OPTIONS_USE_ACK
-     * @see #send(Member[], Serializable , int)
-     * @see #send(Member[], Serializable, int, ErrorHandler)
-     */
-    public static final int SEND_OPTIONS_DEFAULT = SEND_OPTIONS_USE_ACK;
-
-    
-    /**
-     * Adds an interceptor to the channel message chain.
-     * @param interceptor ChannelInterceptor
-     */
-    public void addInterceptor(ChannelInterceptor interceptor);
-    
-    /**
-     * Starts up the channel. This can be called multiple times for individual services to start
-     * The svc parameter can be the logical or value of any constants
-     * @param svc int value of <BR>
-     * DEFAULT - will start all services <BR>
-     * MBR_RX_SEQ - starts the membership receiver <BR>
-     * MBR_TX_SEQ - starts the membership broadcaster <BR>
-     * SND_TX_SEQ - starts the replication transmitter<BR>
-     * SND_RX_SEQ - starts the replication receiver<BR>
-     * <b>Note:</b> In order for the membership broadcaster to 
-     * transmit the correct information, it has to be started after the replication receiver.
-     * @throws ChannelException if a startup error occurs or the service is already started or an error occurs.
-     */
-    public void start(int svc) throws ChannelException;
-
-    /**
-     * Shuts down the channel. This can be called multiple times for individual services to shutdown
-     * The svc parameter can be the logical or value of any constants
-     * @param svc int value of <BR>
-     * DEFAULT - will shutdown all services <BR>
-     * MBR_RX_SEQ - stops the membership receiver <BR>
-     * MBR_TX_SEQ - stops the membership broadcaster <BR>
-     * SND_TX_SEQ - stops the replication transmitter<BR>
-     * SND_RX_SEQ - stops the replication receiver<BR>
-     * @throws ChannelException if a startup error occurs or the service is already stopped or an error occurs.
-     */
-    public void stop(int svc) throws ChannelException;    
-    
-    /**
-     * Send a message to one or more members in the cluster
-     * @param destination Member[] - the destinations, can not be null or zero length, the reason for that
-     * is that a membership change can occur and at that time the application is uncertain what group the message
-     * actually got sent to.
-     * @param msg Serializable - the message to send, has to be serializable, or a <code>ByteMessage</code> to 
-     * send a pure byte array
-     * @param options int - sender options, see class documentation for each interceptor that is configured in order to trigger interceptors
-     * @return a unique Id that identifies the message that is sent
-     * @see ByteMessage
-     * @see #SEND_OPTIONS_USE_ACK
-     * @see #SEND_OPTIONS_ASYNCHRONOUS
-     * @see #SEND_OPTIONS_SYNCHRONIZED_ACK
-     */
-    public UniqueId send(Member[] destination, Serializable msg, int options) throws ChannelException;
-
-    /**
-     * Send a message to one or more members in the cluster
-     * @param destination Member[] - the destinations, null or zero length means all
-     * @param msg ClusterMessage - the message to send
-     * @param options int - sender options, see class documentation
-     * @param handler ErrorHandler - handle errors through a callback, rather than throw it
-     * @return a unique Id that identifies the message that is sent
-     * @exception ChannelException - if a serialization error happens.
-     */
-    public UniqueId send(Member[] destination, Serializable msg, int options, ErrorHandler handler) throws ChannelException;
-    
-    /**
-     * Sends a heart beat through the interceptor stacks
-     * Use this method to alert interceptors and other components to 
-     * clean up garbage, timed out messages etc.<br>
-     * If you application has a background thread, then you can save one thread,
-     * by configuring your channel to not use an internal heartbeat thread
-     * and invoking this method.
-     * @see #setHeartbeat(boolean)
-     */
-    public void heartbeat();
-    
-    /**
-     * Enables or disables internal heartbeat.
-     * @param enable boolean - default value is implementation specific
-     * @see #heartbeat()
-     */
-    public void setHeartbeat(boolean enable);
-    
-    /**
-     * Add a membership listener, will get notified when a new member joins, leaves or crashes
-     * <br>If the membership listener implements the Heartbeat interface
-     * the <code>heartbeat()</code> method will be invoked when the heartbeat runs on the channel
-     * @param listener MembershipListener
-     * @see MembershipListener
-     */
-    public void addMembershipListener(MembershipListener listener);
-    
-    /**
-     * Add a channel listener, this is a callback object when messages are received
-     * <br>If the channel listener implements the Heartbeat interface
-     * the <code>heartbeat()</code> method will be invoked when the heartbeat runs on the channel
-     * @param listener ChannelListener
-     * @see ChannelListener
-     * @see Heartbeat
-     */
-    public void addChannelListener(ChannelListener listener);
-
-    /**
-     * remove a membership listener, listeners are removed based on Object.hashCode and Object.equals
-     * @param listener MembershipListener
-     * @see MembershipListener
-     */
-    public void removeMembershipListener(MembershipListener listener);
-    /**
-     * remove a channel listener, listeners are removed based on Object.hashCode and Object.equals
-     * @param listener ChannelListener
-     * @see ChannelListener
-     */
-    public void removeChannelListener(ChannelListener listener);
-    
-    /**
-     * Returns true if there are any members in the group,
-     * this call is the same as <code>getMembers().length>0</code>
-     * @return boolean - true if there are any members automatically discovered
-     */
-    public boolean hasMembers() ;
-
-    /**
-     * Get all current group members
-     * @return all members or empty array, never null 
-     */
-    public Member[] getMembers() ;
-
-    /**
-     * Return the member that represents this node. This is also the data
-     * that gets broadcasted through the membership broadcaster component
-     * @param incAlive - optimization, true if you want it to calculate alive time
-     * since the membership service started.
-     * @return Member
-     */
-    public Member getLocalMember(boolean incAlive);
-    
-    /**
-     * Returns the member from the membership service with complete and 
-     * recent data. Some implementations might serialize and send 
-     * membership information along with a message, and instead of sending
-     * complete membership details, only send the primary identifier for the member
-     * but not the payload or other information. When such message is received
-     * the application can retrieve the cached member through this call.<br>
-     * In most cases, this is not necessary.
-     * @param mbr Member
-     * @return Member
-     */
-    public Member getMember(Member mbr);
-
-    
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes;
+
+import java.io.Serializable;
+
+/**
+ * Channel interface<br>
+ * A channel is a representation of a group of nodes all participating in some sort of
+ * communication with each other.<br>
+ * The channel is the main API class for Tribes, this is essentially the only class
+ * that an application needs to be aware of. Through the channel the application can:<br>
+ * 1. send messages<br>
+ * 2. receive message (by registering a <code>ChannelListener</code><br>
+ * 3. get all members of the group <code>getMembers()</code><br>
+ * 4. receive notifications of members added and members disappeared by
+ *    registerering a <code>MembershipListener</code><br>
+ * <br>
+ * The channel has 5 major components:<br>
+ * 1. Data receiver, with a built in thread pool to receive messages from other peers<br>
+ * 2. Data sender, an implementation for sending data using NIO or java.io<br>
+ * 3. Membership listener,listens for membership broadcasts<br>
+ * 4. Membership broadcaster, broadcasts membership pings.<br>
+ * 5. Channel interceptors, the ability to manipulate messages as they are sent or arrive<br><br>
+ * The channel layout is:
+ * <pre><code>
+ *  ChannelListener_1..ChannelListener_N MembershipListener_1..MembershipListener_N [Application Layer]
+ *            \          \                  /                   /
+ *             \          \                /                   /
+ *              \          \              /                   /
+ *               \          \            /                   /
+ *                \          \          /                   /
+ *                 \          \        /                   /
+ *                  ---------------------------------------
+ *                                  |
+ *                                  |
+ *                               Channel
+ *                                  |
+ *                         ChannelInterceptor_1
+ *                                  |                                               [Channel stack]
+ *                         ChannelInterceptor_N
+ *                                  |
+ *                             Coordinator (implements MessageListener,MembershipListener,ChannelInterceptor)
+ *                          --------------------
+ *                         /        |           \ 
+ *                        /         |            \
+ *                       /          |             \
+ *                      /           |              \
+ *                     /            |               \
+ *           MembershipService ChannelSender ChannelReceiver                        [IO layer]
+ * </code></pre>
+ * 
+ * For example usage @see org.apache.catalina.tribes.group.GroupChannel
+ * @author Filip Hanik
+ * @version $Revision$, $Date$
+ */
+public interface Channel {
+    
+    /**
+     * Start and stop sequences can be controlled by these constants
+     * This allows you to start separate components of the channel <br>
+     * DEFAULT - starts or stops all components in the channel
+     * @see #start(int)
+     * @see #stop(int)
+     */
+    public static final int DEFAULT = 15;
+
+    /**
+     * Start and stop sequences can be controlled by these constants
+     * This allows you to start separate components of the channel <br>
+     * SND_RX_SEQ - starts or stops the data receiver. Start means opening a server socket
+     * in case of a TCP implementation
+     * @see #start(int)
+     * @see #stop(int)
+     */
+    public static final int SND_RX_SEQ = 1;
+
+    /**
+     * Start and stop sequences can be controlled by these constants
+     * This allows you to start separate components of the channel <br>
+     * SND_TX_SEQ - starts or stops the data sender. This should not open any sockets,
+     * as sockets are opened on demand when a message is being sent
+     * @see #start(int)
+     * @see #stop(int)
+     */
+    public static final int SND_TX_SEQ = 2;
+
+    /**
+     * Start and stop sequences can be controlled by these constants
+     * This allows you to start separate components of the channel <br>
+     * MBR_RX_SEQ - starts or stops the membership listener. In a multicast implementation
+     * this will open a datagram socket and join a group and listen for membership messages
+     * members joining
+     * @see #start(int)
+     * @see #stop(int)
+     */
+    public static final int MBR_RX_SEQ = 4;
+
+    /**
+     * Start and stop sequences can be controlled by these constants
+     * This allows you to start separate components of the channel <br>
+     * MBR_TX_SEQ - starts or stops the membership broadcaster. In a multicast implementation
+     * this will open a datagram socket and join a group and broadcast the local member information
+     * @see #start(int)
+     * @see #stop(int)
+     */
+    public static final int MBR_TX_SEQ = 8;
+    
+    /**
+     * Send options, when a message is sent, it can have an option flag
+     * to trigger certain behavior. Most flags are used to trigger channel interceptors
+     * as the message passes through the channel stack. <br>
+     * However, there are five default flags that every channel implementation must implement<br>
+     * SEND_OPTIONS_BYTE_MESSAGE - The message is a pure byte message and no marshalling or unmarshalling will
+     * be performed.<br>
+     * 
+     * @see #send(Member[], Serializable , int)
+     * @see #send(Member[], Serializable, int, ErrorHandler)
+     */
+    public static final int SEND_OPTIONS_BYTE_MESSAGE = 0x0001;
+
+    /**
+     * Send options, when a message is sent, it can have an option flag
+     * to trigger certain behavior. Most flags are used to trigger channel interceptors
+     * as the message passes through the channel stack. <br>
+     * However, there are five default flags that every channel implementation must implement<br>
+     * SEND_OPTIONS_USE_ACK - Message is sent and an ACK is received when the message has been received by the recipient<br>
+     * If no ack is received, the message is not considered successful<br>
+     * @see #send(Member[], Serializable , int)
+     * @see #send(Member[], Serializable, int, ErrorHandler)
+     */
+    public static final int SEND_OPTIONS_USE_ACK = 0x0002;
+
+    /**
+     * Send options, when a message is sent, it can have an option flag
+     * to trigger certain behavior. Most flags are used to trigger channel interceptors
+     * as the message passes through the channel stack. <br>
+     * However, there are five default flags that every channel implementation must implement<br>
+     * SEND_OPTIONS_SYNCHRONIZED_ACK - Message is sent and an ACK is received when the message has been received and 
+     * processed by the recipient<br>
+     * If no ack is received, the message is not considered successful<br>
+     * @see #send(Member[], Serializable , int)
+     * @see #send(Member[], Serializable, int, ErrorHandler)
+     */
+    public static final int SEND_OPTIONS_SYNCHRONIZED_ACK = 0x0004;
+    
+    /**
+     * Send options, when a message is sent, it can have an option flag
+     * to trigger certain behavior. Most flags are used to trigger channel interceptors
+     * as the message passes through the channel stack. <br>
+     * However, there are five default flags that every channel implementation must implement<br>
+     * SEND_OPTIONS_ASYNCHRONOUS - Message is sent and an ACK is received when the message has been received and 
+     * processed by the recipient<br>
+     * If no ack is received, the message is not considered successful<br>
+     * @see #send(Member[], Serializable , int)
+     * @see #send(Member[], Serializable, int, ErrorHandler)
+     */
+    public static final int SEND_OPTIONS_ASYNCHRONOUS = 0x0008;
+    
+    /**
+     * Send options, when a message is sent, it can have an option flag
+     * to trigger certain behavior. Most flags are used to trigger channel interceptors
+     * as the message passes through the channel stack. <br>
+     * However, there are five default flags that every channel implementation must implement<br>
+     * SEND_OPTIONS_SECURE - Message is sent over an encrypted channel<br>
+     * @see #send(Member[], Serializable , int)
+     * @see #send(Member[], Serializable, int, ErrorHandler)
+     */
+    public static final int SEND_OPTIONS_SECURE = 0x0010;
+    
+
+    /**
+     * Send options, when a message is sent, it can have an option flag
+     * to trigger certain behavior. Most flags are used to trigger channel interceptors
+     * as the message passes through the channel stack. <br>
+     * However, there are five default flags that every channel implementation must implement<br>
+     * SEND_OPTIONS_DEFAULT - the default sending options, just a helper variable. <br>
+     * The default is <code>int SEND_OPTIONS_DEFAULT = SEND_OPTIONS_USE_ACK;</code><br>
+     * @see #SEND_OPTIONS_USE_ACK
+     * @see #send(Member[], Serializable , int)
+     * @see #send(Member[], Serializable, int, ErrorHandler)
+     */
+    public static final int SEND_OPTIONS_DEFAULT = SEND_OPTIONS_USE_ACK;
+
+    
+    /**
+     * Adds an interceptor to the channel message chain.
+     * @param interceptor ChannelInterceptor
+     */
+    public void addInterceptor(ChannelInterceptor interceptor);
+    
+    /**
+     * Starts up the channel. This can be called multiple times for individual services to start
+     * The svc parameter can be the logical or value of any constants
+     * @param svc int value of <BR>
+     * DEFAULT - will start all services <BR>
+     * MBR_RX_SEQ - starts the membership receiver <BR>
+     * MBR_TX_SEQ - starts the membership broadcaster <BR>
+     * SND_TX_SEQ - starts the replication transmitter<BR>
+     * SND_RX_SEQ - starts the replication receiver<BR>
+     * <b>Note:</b> In order for the membership broadcaster to 
+     * transmit the correct information, it has to be started after the replication receiver.
+     * @throws ChannelException if a startup error occurs or the service is already started or an error occurs.
+     */
+    public void start(int svc) throws ChannelException;
+
+    /**
+     * Shuts down the channel. This can be called multiple times for individual services to shutdown
+     * The svc parameter can be the logical or value of any constants
+     * @param svc int value of <BR>
+     * DEFAULT - will shutdown all services <BR>
+     * MBR_RX_SEQ - stops the membership receiver <BR>
+     * MBR_TX_SEQ - stops the membership broadcaster <BR>
+     * SND_TX_SEQ - stops the replication transmitter<BR>
+     * SND_RX_SEQ - stops the replication receiver<BR>
+     * @throws ChannelException if a startup error occurs or the service is already stopped or an error occurs.
+     */
+    public void stop(int svc) throws ChannelException;    
+    
+    /**
+     * Send a message to one or more members in the cluster
+     * @param destination Member[] - the destinations, can not be null or zero length, the reason for that
+     * is that a membership change can occur and at that time the application is uncertain what group the message
+     * actually got sent to.
+     * @param msg Serializable - the message to send, has to be serializable, or a <code>ByteMessage</code> to 
+     * send a pure byte array
+     * @param options int - sender options, see class documentation for each interceptor that is configured in order to trigger interceptors
+     * @return a unique Id that identifies the message that is sent
+     * @see ByteMessage
+     * @see #SEND_OPTIONS_USE_ACK
+     * @see #SEND_OPTIONS_ASYNCHRONOUS
+     * @see #SEND_OPTIONS_SYNCHRONIZED_ACK
+     */
+    public UniqueId send(Member[] destination, Serializable msg, int options) throws ChannelException;
+
+    /**
+     * Send a message to one or more members in the cluster
+     * @param destination Member[] - the destinations, null or zero length means all
+     * @param msg ClusterMessage - the message to send
+     * @param options int - sender options, see class documentation
+     * @param handler ErrorHandler - handle errors through a callback, rather than throw it
+     * @return a unique Id that identifies the message that is sent
+     * @exception ChannelException - if a serialization error happens.
+     */
+    public UniqueId send(Member[] destination, Serializable msg, int options, ErrorHandler handler) throws ChannelException;
+    
+    /**
+     * Sends a heart beat through the interceptor stacks
+     * Use this method to alert interceptors and other components to 
+     * clean up garbage, timed out messages etc.<br>
+     * If you application has a background thread, then you can save one thread,
+     * by configuring your channel to not use an internal heartbeat thread
+     * and invoking this method.
+     * @see #setHeartbeat(boolean)
+     */
+    public void heartbeat();
+    
+    /**
+     * Enables or disables internal heartbeat.
+     * @param enable boolean - default value is implementation specific
+     * @see #heartbeat()
+     */
+    public void setHeartbeat(boolean enable);
+    
+    /**
+     * Add a membership listener, will get notified when a new member joins, leaves or crashes
+     * <br>If the membership listener implements the Heartbeat interface
+     * the <code>heartbeat()</code> method will be invoked when the heartbeat runs on the channel
+     * @param listener MembershipListener
+     * @see MembershipListener
+     */
+    public void addMembershipListener(MembershipListener listener);
+    
+    /**
+     * Add a channel listener, this is a callback object when messages are received
+     * <br>If the channel listener implements the Heartbeat interface
+     * the <code>heartbeat()</code> method will be invoked when the heartbeat runs on the channel
+     * @param listener ChannelListener
+     * @see ChannelListener
+     * @see Heartbeat
+     */
+    public void addChannelListener(ChannelListener listener);
+
+    /**
+     * remove a membership listener, listeners are removed based on Object.hashCode and Object.equals
+     * @param listener MembershipListener
+     * @see MembershipListener
+     */
+    public void removeMembershipListener(MembershipListener listener);
+    /**
+     * remove a channel listener, listeners are removed based on Object.hashCode and Object.equals
+     * @param listener ChannelListener
+     * @see ChannelListener
+     */
+    public void removeChannelListener(ChannelListener listener);
+    
+    /**
+     * Returns true if there are any members in the group,
+     * this call is the same as <code>getMembers().length>0</code>
+     * @return boolean - true if there are any members automatically discovered
+     */
+    public boolean hasMembers() ;
+
+    /**
+     * Get all current group members
+     * @return all members or empty array, never null 
+     */
+    public Member[] getMembers() ;
+
+    /**
+     * Return the member that represents this node. This is also the data
+     * that gets broadcasted through the membership broadcaster component
+     * @param incAlive - optimization, true if you want it to calculate alive time
+     * since the membership service started.
+     * @return Member
+     */
+    public Member getLocalMember(boolean incAlive);
+    
+    /**
+     * Returns the member from the membership service with complete and 
+     * recent data. Some implementations might serialize and send 
+     * membership information along with a message, and instead of sending
+     * complete membership details, only send the primary identifier for the member
+     * but not the payload or other information. When such message is received
+     * the application can retrieve the cached member through this call.<br>
+     * In most cases, this is not necessary.
+     * @param mbr Member
+     * @return Member
+     */
+    public Member getMember(Member mbr);
+
+    
+}

==================================================
ChannelInterceptor.java
index d7a885f6ab..8519daafbe 100644
--- a/java/org/apache/catalina/tribes/ChannelException.java
+++ b/java/org/apache/catalina/tribes/ChannelException.java
@@ -1,162 +1,162 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes;
-
-import java.util.ArrayList;
-
-/**
- * Channel Exception<br>
- * A channel exception is thrown when an internal error happens
- * somewhere in the channel. <br>
- * When a global error happens, the cause can be retrieved using <code>getCause()</code><br><br>
- * If an application is sending a message and some of the recipients fail to receive it,
- * the application can retrieve what recipients failed by using the <code>getFaultyMembers()</code>
- * method. This way, an application will always know if a message was delivered successfully or not.
- * @author Filip Hanik
- * @version $Revision: 304032 $, $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
- */
-
-public class ChannelException extends Exception {
-    /*
-     * Holds a list of faulty members
-     */
-    private ArrayList faultyMembers=null;
-    
-    /**
-     * Constructor, creates a ChannelException
-     * @see java.lang.Exception#Exception()
-     */
-    public ChannelException() {
-        super();
-    }
-
-    /**
-     * Constructor, creates a ChannelException with an error message
-     * @see java.lang.Exception#Exception(String)
-     */
-    public ChannelException(String message) {
-        super(message);
-    }
-
-    /**
-     * Constructor, creates a ChannelException with an error message and a cause
-     * @param message String
-     * @param cause Throwable
-     * @see java.lang.Exception#Exception(String,Throwable)
-     */
-    public ChannelException(String message, Throwable cause) {
-        super(message, cause);
-    }
-
-    /**
-     * Constructor, creates a ChannelException with a cause
-     * @param cause Throwable
-     * @see java.lang.Exception#Exception(Throwable)
-     */
-    public ChannelException(Throwable cause) {
-        super(cause);
-    }
-    
-    /**
-     * Returns the message for this exception
-     * @return String
-     * @see java.lang.Exception#getMessage()
-     */
-    public String getMessage() {
-        StringBuffer buf = new StringBuffer(super.getMessage());
-        if (faultyMembers==null || faultyMembers.size() == 0 ) {
-            buf.append("; No faulty members identified.");
-        } else {
-            buf.append("; Faulty members:");
-            for ( int i=0; i<faultyMembers.size(); i++ ) {
-                FaultyMember mbr = (FaultyMember)faultyMembers.get(i);
-                buf.append(mbr.getMember().getName());
-                buf.append("; ");
-            }
-        }
-        return buf.toString();
-    }
-    
-    /**
-     * Adds a faulty member, and the reason the member failed.
-     * @param mbr Member
-     * @param x Exception
-     */
-    public void addFaultyMember(Member mbr, Exception x ) {
-        addFaultyMember(new FaultyMember(mbr,x));
-    }
-    
-    /**
-     * Adds a list of faulty members
-     * @param mbrs FaultyMember[]
-     */
-    public void addFaultyMember(FaultyMember[] mbrs) {
-        for (int i=0; mbrs!=null && i<mbrs.length; i++ ) {
-            addFaultyMember(mbrs[i]);
-        }
-    }
-
-    /**
-     * Adds a faulty member
-     * @param mbr FaultyMember
-     */
-    public void addFaultyMember(FaultyMember mbr) {
-        if ( this.faultyMembers==null ) this.faultyMembers = new ArrayList();
-        faultyMembers.add(mbr);
-    }
-    
-    /**
-     * Returns an array of members that failed and the reason they failed.
-     * @return FaultyMember[]
-     */
-    public FaultyMember[] getFaultyMembers() {
-        if ( this.faultyMembers==null ) return new FaultyMember[0];
-        return (FaultyMember[])faultyMembers.toArray(new FaultyMember[faultyMembers.size()]);
-    }
-    
-    /**
-     * 
-     * <p>Title: FaultyMember class</p> 
-     * 
-     * <p>Description: Represent a failure to a specific member when a message was sent
-     * to more than one member</p> 
-     * 
-     * @author Filip Hanik
-     * @version 1.0
-     */
-    public static class FaultyMember {
-        protected Exception cause;
-        protected Member member;
-        public FaultyMember(Member mbr, Exception x) { 
-            this.member = mbr;
-            this.cause = x;
-        }
-        
-        public Member getMember() {
-            return member;
-        }
-        
-        public Exception getCause() {
-            return cause;
-        }
-        
-        public String toString() {
-            return "FaultyMember:"+member.toString();
-        }
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes;
+
+import java.util.ArrayList;
+
+/**
+ * Channel Exception<br>
+ * A channel exception is thrown when an internal error happens
+ * somewhere in the channel. <br>
+ * When a global error happens, the cause can be retrieved using <code>getCause()</code><br><br>
+ * If an application is sending a message and some of the recipients fail to receive it,
+ * the application can retrieve what recipients failed by using the <code>getFaultyMembers()</code>
+ * method. This way, an application will always know if a message was delivered successfully or not.
+ * @author Filip Hanik
+ * @version $Revision$, $Date$
+ */
+
+public class ChannelException extends Exception {
+    /*
+     * Holds a list of faulty members
+     */
+    private ArrayList faultyMembers=null;
+    
+    /**
+     * Constructor, creates a ChannelException
+     * @see java.lang.Exception#Exception()
+     */
+    public ChannelException() {
+        super();
+    }
+
+    /**
+     * Constructor, creates a ChannelException with an error message
+     * @see java.lang.Exception#Exception(String)
+     */
+    public ChannelException(String message) {
+        super(message);
+    }
+
+    /**
+     * Constructor, creates a ChannelException with an error message and a cause
+     * @param message String
+     * @param cause Throwable
+     * @see java.lang.Exception#Exception(String,Throwable)
+     */
+    public ChannelException(String message, Throwable cause) {
+        super(message, cause);
+    }
+
+    /**
+     * Constructor, creates a ChannelException with a cause
+     * @param cause Throwable
+     * @see java.lang.Exception#Exception(Throwable)
+     */
+    public ChannelException(Throwable cause) {
+        super(cause);
+    }
+    
+    /**
+     * Returns the message for this exception
+     * @return String
+     * @see java.lang.Exception#getMessage()
+     */
+    public String getMessage() {
+        StringBuffer buf = new StringBuffer(super.getMessage());
+        if (faultyMembers==null || faultyMembers.size() == 0 ) {
+            buf.append("; No faulty members identified.");
+        } else {
+            buf.append("; Faulty members:");
+            for ( int i=0; i<faultyMembers.size(); i++ ) {
+                FaultyMember mbr = (FaultyMember)faultyMembers.get(i);
+                buf.append(mbr.getMember().getName());
+                buf.append("; ");
+            }
+        }
+        return buf.toString();
+    }
+    
+    /**
+     * Adds a faulty member, and the reason the member failed.
+     * @param mbr Member
+     * @param x Exception
+     */
+    public void addFaultyMember(Member mbr, Exception x ) {
+        addFaultyMember(new FaultyMember(mbr,x));
+    }
+    
+    /**
+     * Adds a list of faulty members
+     * @param mbrs FaultyMember[]
+     */
+    public void addFaultyMember(FaultyMember[] mbrs) {
+        for (int i=0; mbrs!=null && i<mbrs.length; i++ ) {
+            addFaultyMember(mbrs[i]);
+        }
+    }
+
+    /**
+     * Adds a faulty member
+     * @param mbr FaultyMember
+     */
+    public void addFaultyMember(FaultyMember mbr) {
+        if ( this.faultyMembers==null ) this.faultyMembers = new ArrayList();
+        faultyMembers.add(mbr);
+    }
+    
+    /**
+     * Returns an array of members that failed and the reason they failed.
+     * @return FaultyMember[]
+     */
+    public FaultyMember[] getFaultyMembers() {
+        if ( this.faultyMembers==null ) return new FaultyMember[0];
+        return (FaultyMember[])faultyMembers.toArray(new FaultyMember[faultyMembers.size()]);
+    }
+    
+    /**
+     * 
+     * <p>Title: FaultyMember class</p> 
+     * 
+     * <p>Description: Represent a failure to a specific member when a message was sent
+     * to more than one member</p> 
+     * 
+     * @author Filip Hanik
+     * @version 1.0
+     */
+    public static class FaultyMember {
+        protected Exception cause;
+        protected Member member;
+        public FaultyMember(Member mbr, Exception x) { 
+            this.member = mbr;
+            this.cause = x;
+        }
+        
+        public Member getMember() {
+            return member;
+        }
+        
+        public Exception getCause() {
+            return cause;
+        }
+        
+        public String toString() {
+            return "FaultyMember:"+member.toString();
+        }
+    }
+
+}

==================================================
ChannelListener.java
index b457ef122f..b5c8514907 100644
--- a/java/org/apache/catalina/tribes/ChannelInterceptor.java
+++ b/java/org/apache/catalina/tribes/ChannelInterceptor.java
@@ -1,180 +1,180 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes;
-
-import org.apache.catalina.tribes.group.InterceptorPayload;
-
-/**
- * A ChannelInterceptor is an interceptor that intercepts 
- * messages and membership messages in the channel stack.
- * This allows interceptors to modify the message or perform
- * other actions when a message is sent or received.<br>
- * Interceptors are tied together in a linked list.
- * @see org.apache.catalina.tribes.group.ChannelInterceptorBase
- * @author Filip Hanik
- * @version $Revision: 304032 $, $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
- */   
-
-public interface ChannelInterceptor extends MembershipListener, Heartbeat {
-
-    /**
-     * An interceptor can react to a message based on a set bit on the 
-     * message options. <br>
-     * When a message is sent, the options can be retrieved from ChannelMessage.getOptions()
-     * and if the bit is set, this interceptor will react to it.<br>
-     * A simple evaluation if an interceptor should react to the message would be:<br>
-     * <code>boolean react = (getOptionFlag() == (getOptionFlag() & ChannelMessage.getOptions()));</code><br>
-     * The default option is 0, meaning there is no way for the application to trigger the
-     * interceptor. The interceptor itself will decide.<br>
-     * @return int
-     * @see ChannelMessage#getOptions()
-     */
-    public int getOptionFlag();
-    
-    /**
-     * Sets the option flag
-     * @param flag int
-     * @see #getOptionFlag()
-     */
-    public void setOptionFlag(int flag);
-
-    /**
-     * Set the next interceptor in the list of interceptors
-     * @param next ChannelInterceptor
-     */
-    public void setNext(ChannelInterceptor next) ;
-
-    /**
-     * Retrieve the next interceptor in the list
-     * @return ChannelInterceptor - returns the next interceptor in the list or null if no more interceptors exist
-     */
-    public ChannelInterceptor getNext();
-
-    /**
-     * Set the previous interceptor in the list
-     * @param previous ChannelInterceptor
-     */
-    public void setPrevious(ChannelInterceptor previous);
-
-    /**
-     * Retrieve the previous interceptor in the list
-     * @return ChannelInterceptor - returns the previous interceptor in the list or null if no more interceptors exist
-     */
-    public ChannelInterceptor getPrevious();
-
-    /**
-     * The <code>sendMessage</code> method is called when a message is being sent to one more destinations.
-     * The interceptor can modify any of the parameters and then pass on the message down the stack by
-     * invoking <code>getNext().sendMessage(destination,msg,payload)</code><br>
-     * Alternatively the interceptor can stop the message from being sent by not invoking 
-     * <code>getNext().sendMessage(destination,msg,payload)</code><br>
-     * If the message is to be sent asynchronous the application can be notified of completion and 
-     * errors by passing in an error handler attached to a payload object.<br>
-     * The ChannelMessage.getAddress contains Channel.getLocalMember, and can be overwritten 
-     * to simulate a message sent from another node.<br>
-     * @param destination Member[] - the destination for this message
-     * @param msg ChannelMessage - the message to be sent
-     * @param payload InterceptorPayload - the payload, carrying an error handler and future useful data, can be null
-     * @throws ChannelException
-     * @see ErrorHandler
-     * @see InterceptorPayload
-     */
-    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException;
-    
-    /**
-     * the <code>messageReceived</code> is invoked when a message is received.
-     * <code>ChannelMessage.getAddress()</code> is the sender, or the reply-to address
-     * if it has been overwritten.
-     * @param data ChannelMessage
-     */
-    public void messageReceived(ChannelMessage data);
-    
-    /**
-     * The <code>heartbeat()</code> method gets invoked periodically
-     * to allow interceptors to clean up resources, time out object and 
-     * perform actions that are unrelated to sending/receiving data.
-     */
-    public void heartbeat();
-    
-    /**
-     * Intercepts the <code>Channel.hasMembers()</code> method
-     * @return boolean - if the channel has members in its membership group
-     * @see Channel#hasMembers()
-     */
-    public boolean hasMembers() ;
-
-    /**
-     * Intercepts the code>Channel.getMembers()</code> method
-     * @return Member[]
-     * @see Channel#getMembers()
-     */
-    public Member[] getMembers() ;
-
-    /**
-     * Intercepts the code>Channel.getLocalMember(boolean)</code> method
-     * @param incAliveTime boolean
-     * @return Member
-     * @see Channel#getLocalMember(boolean)
-     */
-    public Member getLocalMember(boolean incAliveTime) ;
-
-    /**
-     * Intercepts the code>Channel.getMember(Member)</code> method
-     * @param mbr Member
-     * @return Member - the actual member information, including stay alive
-     * @see Channel#getMember(Member)
-     */
-    public Member getMember(Member mbr);
-    
-    /**
-     * Starts up the channel. This can be called multiple times for individual services to start
-     * The svc parameter can be the logical or value of any constants
-     * @param svc int value of <BR>
-     * Channel.DEFAULT - will start all services <BR>
-     * Channel.MBR_RX_SEQ - starts the membership receiver <BR>
-     * Channel.MBR_TX_SEQ - starts the membership broadcaster <BR>
-     * Channel.SND_TX_SEQ - starts the replication transmitter<BR>
-     * Channel.SND_RX_SEQ - starts the replication receiver<BR>
-     * @throws ChannelException if a startup error occurs or the service is already started.
-     * @see Channel
-     */
-    public void start(int svc) throws ChannelException;
-
-    /**
-     * Shuts down the channel. This can be called multiple times for individual services to shutdown
-     * The svc parameter can be the logical or value of any constants
-     * @param svc int value of <BR>
-     * Channel.DEFAULT - will shutdown all services <BR>
-     * Channel.MBR_RX_SEQ - stops the membership receiver <BR>
-     * Channel.MBR_TX_SEQ - stops the membership broadcaster <BR>
-     * Channel.SND_TX_SEQ - stops the replication transmitter<BR>
-     * Channel.SND_RX_SEQ - stops the replication receiver<BR>
-     * @throws ChannelException if a startup error occurs or the service is already started.
-     * @see Channel
-     */
-    public void stop(int svc) throws ChannelException;
-    
-    public void fireInterceptorEvent(InterceptorEvent event);
-
-    interface InterceptorEvent {
-        int getEventType();
-        String getEventTypeDesc();
-        ChannelInterceptor getInterceptor();
-    }
-    
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes;
+
+import org.apache.catalina.tribes.group.InterceptorPayload;
+
+/**
+ * A ChannelInterceptor is an interceptor that intercepts 
+ * messages and membership messages in the channel stack.
+ * This allows interceptors to modify the message or perform
+ * other actions when a message is sent or received.<br>
+ * Interceptors are tied together in a linked list.
+ * @see org.apache.catalina.tribes.group.ChannelInterceptorBase
+ * @author Filip Hanik
+ * @version $Revision$, $Date$
+ */   
+
+public interface ChannelInterceptor extends MembershipListener, Heartbeat {
+
+    /**
+     * An interceptor can react to a message based on a set bit on the 
+     * message options. <br>
+     * When a message is sent, the options can be retrieved from ChannelMessage.getOptions()
+     * and if the bit is set, this interceptor will react to it.<br>
+     * A simple evaluation if an interceptor should react to the message would be:<br>
+     * <code>boolean react = (getOptionFlag() == (getOptionFlag() & ChannelMessage.getOptions()));</code><br>
+     * The default option is 0, meaning there is no way for the application to trigger the
+     * interceptor. The interceptor itself will decide.<br>
+     * @return int
+     * @see ChannelMessage#getOptions()
+     */
+    public int getOptionFlag();
+    
+    /**
+     * Sets the option flag
+     * @param flag int
+     * @see #getOptionFlag()
+     */
+    public void setOptionFlag(int flag);
+
+    /**
+     * Set the next interceptor in the list of interceptors
+     * @param next ChannelInterceptor
+     */
+    public void setNext(ChannelInterceptor next) ;
+
+    /**
+     * Retrieve the next interceptor in the list
+     * @return ChannelInterceptor - returns the next interceptor in the list or null if no more interceptors exist
+     */
+    public ChannelInterceptor getNext();
+
+    /**
+     * Set the previous interceptor in the list
+     * @param previous ChannelInterceptor
+     */
+    public void setPrevious(ChannelInterceptor previous);
+
+    /**
+     * Retrieve the previous interceptor in the list
+     * @return ChannelInterceptor - returns the previous interceptor in the list or null if no more interceptors exist
+     */
+    public ChannelInterceptor getPrevious();
+
+    /**
+     * The <code>sendMessage</code> method is called when a message is being sent to one more destinations.
+     * The interceptor can modify any of the parameters and then pass on the message down the stack by
+     * invoking <code>getNext().sendMessage(destination,msg,payload)</code><br>
+     * Alternatively the interceptor can stop the message from being sent by not invoking 
+     * <code>getNext().sendMessage(destination,msg,payload)</code><br>
+     * If the message is to be sent asynchronous the application can be notified of completion and 
+     * errors by passing in an error handler attached to a payload object.<br>
+     * The ChannelMessage.getAddress contains Channel.getLocalMember, and can be overwritten 
+     * to simulate a message sent from another node.<br>
+     * @param destination Member[] - the destination for this message
+     * @param msg ChannelMessage - the message to be sent
+     * @param payload InterceptorPayload - the payload, carrying an error handler and future useful data, can be null
+     * @throws ChannelException
+     * @see ErrorHandler
+     * @see InterceptorPayload
+     */
+    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException;
+    
+    /**
+     * the <code>messageReceived</code> is invoked when a message is received.
+     * <code>ChannelMessage.getAddress()</code> is the sender, or the reply-to address
+     * if it has been overwritten.
+     * @param data ChannelMessage
+     */
+    public void messageReceived(ChannelMessage data);
+    
+    /**
+     * The <code>heartbeat()</code> method gets invoked periodically
+     * to allow interceptors to clean up resources, time out object and 
+     * perform actions that are unrelated to sending/receiving data.
+     */
+    public void heartbeat();
+    
+    /**
+     * Intercepts the <code>Channel.hasMembers()</code> method
+     * @return boolean - if the channel has members in its membership group
+     * @see Channel#hasMembers()
+     */
+    public boolean hasMembers() ;
+
+    /**
+     * Intercepts the code>Channel.getMembers()</code> method
+     * @return Member[]
+     * @see Channel#getMembers()
+     */
+    public Member[] getMembers() ;
+
+    /**
+     * Intercepts the code>Channel.getLocalMember(boolean)</code> method
+     * @param incAliveTime boolean
+     * @return Member
+     * @see Channel#getLocalMember(boolean)
+     */
+    public Member getLocalMember(boolean incAliveTime) ;
+
+    /**
+     * Intercepts the code>Channel.getMember(Member)</code> method
+     * @param mbr Member
+     * @return Member - the actual member information, including stay alive
+     * @see Channel#getMember(Member)
+     */
+    public Member getMember(Member mbr);
+    
+    /**
+     * Starts up the channel. This can be called multiple times for individual services to start
+     * The svc parameter can be the logical or value of any constants
+     * @param svc int value of <BR>
+     * Channel.DEFAULT - will start all services <BR>
+     * Channel.MBR_RX_SEQ - starts the membership receiver <BR>
+     * Channel.MBR_TX_SEQ - starts the membership broadcaster <BR>
+     * Channel.SND_TX_SEQ - starts the replication transmitter<BR>
+     * Channel.SND_RX_SEQ - starts the replication receiver<BR>
+     * @throws ChannelException if a startup error occurs or the service is already started.
+     * @see Channel
+     */
+    public void start(int svc) throws ChannelException;
+
+    /**
+     * Shuts down the channel. This can be called multiple times for individual services to shutdown
+     * The svc parameter can be the logical or value of any constants
+     * @param svc int value of <BR>
+     * Channel.DEFAULT - will shutdown all services <BR>
+     * Channel.MBR_RX_SEQ - stops the membership receiver <BR>
+     * Channel.MBR_TX_SEQ - stops the membership broadcaster <BR>
+     * Channel.SND_TX_SEQ - stops the replication transmitter<BR>
+     * Channel.SND_RX_SEQ - stops the replication receiver<BR>
+     * @throws ChannelException if a startup error occurs or the service is already started.
+     * @see Channel
+     */
+    public void stop(int svc) throws ChannelException;
+    
+    public void fireInterceptorEvent(InterceptorEvent event);
+
+    interface InterceptorEvent {
+        int getEventType();
+        String getEventTypeDesc();
+        ChannelInterceptor getInterceptor();
+    }
+    
+
+}

==================================================
ChannelMessage.java
index ad29211a0f..8d97777d76 100644
--- a/java/org/apache/catalina/tribes/ChannelListener.java
+++ b/java/org/apache/catalina/tribes/ChannelListener.java
@@ -1,68 +1,68 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes;
-
-import java.io.Serializable;
-/**
- * 
- * <p>Title: ChannelListener</p> 
- * 
- * <p>Description: An interface to listens to incoming messages from a channel </p> 
- * When a message is received, the Channel will invoke the channel listener in a conditional sequence.
- * <code>if ( listener.accept(msg,sender) ) listener.messageReceived(msg,sender);</code><br>
- * A ChannelListener implementation MUST NOT return true on <code>accept(Serializable, Member)</code>
- * if it doesn't intend to process the message. The channel can this way track whether a message
- * was processed by an above application or if it was just received and forgot about, a featuer required
- * to support message-response(RPC) calls<br>
- * 
- * @author Filip Hanik
- * @version 1.0
- */
-
-public interface ChannelListener {
-
-    /**
-     * Receive a message from the channel
-     * @param msg Serializable
-     * @param sender - the source of the message
-     */
-    public void messageReceived(Serializable msg, Member sender);
-
-    /**
-     * Invoked by the channel to determine if the listener will process this message or not.
-     * @param msg Serializable
-     * @param sender Member
-     * @return boolean
-     */
-    public boolean accept(Serializable msg, Member sender);
-
-    /**
-     * 
-     * @param listener Object
-     * @return boolean
-     * @see Object#equals(Object)
-     */
-    public boolean equals(Object listener);
-
-    /**
-     * 
-     * @return int
-     * @see Object#hashCode(int)
-     */
-    public int hashCode();
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes;
+
+import java.io.Serializable;
+/**
+ * 
+ * <p>Title: ChannelListener</p> 
+ * 
+ * <p>Description: An interface to listens to incoming messages from a channel </p> 
+ * When a message is received, the Channel will invoke the channel listener in a conditional sequence.
+ * <code>if ( listener.accept(msg,sender) ) listener.messageReceived(msg,sender);</code><br>
+ * A ChannelListener implementation MUST NOT return true on <code>accept(Serializable, Member)</code>
+ * if it doesn't intend to process the message. The channel can this way track whether a message
+ * was processed by an above application or if it was just received and forgot about, a featuer required
+ * to support message-response(RPC) calls<br>
+ * 
+ * @author Filip Hanik
+ * @version 1.0
+ */
+
+public interface ChannelListener {
+
+    /**
+     * Receive a message from the channel
+     * @param msg Serializable
+     * @param sender - the source of the message
+     */
+    public void messageReceived(Serializable msg, Member sender);
+
+    /**
+     * Invoked by the channel to determine if the listener will process this message or not.
+     * @param msg Serializable
+     * @param sender Member
+     * @return boolean
+     */
+    public boolean accept(Serializable msg, Member sender);
+
+    /**
+     * 
+     * @param listener Object
+     * @return boolean
+     * @see Object#equals(Object)
+     */
+    public boolean equals(Object listener);
+
+    /**
+     * 
+     * @return int
+     * @see Object#hashCode(int)
+     */
+    public int hashCode();
+
+}

==================================================
ChannelReceiver.java
index 98a438cbbf..1efedd95cb 100644
--- a/java/org/apache/catalina/tribes/ChannelMessage.java
+++ b/java/org/apache/catalina/tribes/ChannelMessage.java
@@ -1,109 +1,109 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes;
-
-import java.io.Serializable;
-import org.apache.catalina.tribes.io.XByteBuffer;
-
-/**
- * Message that is passed through the interceptor stack after the 
- * data serialized in the Channel object and then passed down to the 
- * interceptor and eventually down to the ChannelSender component
- * @author Filip Hanik
- * 
- */
-public interface ChannelMessage extends Serializable {
-    
-    
-    
-    
-    /**
-     * Get the address that this message originated from.  
-     * Almost always <code>Channel.getLocalMember(boolean)</code><br>
-     * This would be set to a different address 
-     * if the message was being relayed from a host other than the one
-     * that originally sent it.
-     * @return the source or reply-to address of this message
-     */
-    public Member getAddress();
-
-    /**
-     * Sets the source or reply-to address of this message
-     * @param member Member
-     */
-    public void setAddress(Member member);
-
-    /**
-     * Timestamp of when the message was created.
-     * @return long timestamp in milliseconds
-     */
-    public long getTimestamp();
-
-    /**
-     *
-     * Sets the timestamp of this message
-     * @param timestamp The timestamp
-     */
-    public void setTimestamp(long timestamp);
-
-    /**
-     * Each message must have a globally unique Id.
-     * interceptors heavily depend on this id for message processing
-     * @return byte
-     */
-    public byte[] getUniqueId();
-    
-    /**
-     * The byte buffer that contains the actual message payload
-     * @param buf XByteBuffer
-     */
-    public void setMessage(XByteBuffer buf);
-    
-    /**
-     * returns the byte buffer that contains the actual message payload
-     * @return XByteBuffer
-     */
-    public XByteBuffer getMessage();
-    
-    /**
-     * The message options is a 32 bit flag set
-     * that triggers interceptors and message behavior.
-     * @see Channel#send(Member[], Serializable, int) 
-     * @see ChannelInterceptor#getOptionFlag
-     * @return int - the option bits set for this message
-     */
-    public int getOptions();
-    
-    /**
-     * sets the option bits for this message
-     * @param options int
-     * @see #getOptions()
-     */
-    public void setOptions(int options);
-    
-    /**
-     * Shallow clone, what gets cloned depends on the implementation
-     * @return ChannelMessage
-     */
-    public Object clone();
-
-    /**
-     * Deep clone, all fields MUST get cloned
-     * @return ChannelMessage
-     */
-    public Object deepclone();
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes;
+
+import java.io.Serializable;
+import org.apache.catalina.tribes.io.XByteBuffer;
+
+/**
+ * Message that is passed through the interceptor stack after the 
+ * data serialized in the Channel object and then passed down to the 
+ * interceptor and eventually down to the ChannelSender component
+ * @author Filip Hanik
+ * 
+ */
+public interface ChannelMessage extends Serializable {
+    
+    
+    
+    
+    /**
+     * Get the address that this message originated from.  
+     * Almost always <code>Channel.getLocalMember(boolean)</code><br>
+     * This would be set to a different address 
+     * if the message was being relayed from a host other than the one
+     * that originally sent it.
+     * @return the source or reply-to address of this message
+     */
+    public Member getAddress();
+
+    /**
+     * Sets the source or reply-to address of this message
+     * @param member Member
+     */
+    public void setAddress(Member member);
+
+    /**
+     * Timestamp of when the message was created.
+     * @return long timestamp in milliseconds
+     */
+    public long getTimestamp();
+
+    /**
+     *
+     * Sets the timestamp of this message
+     * @param timestamp The timestamp
+     */
+    public void setTimestamp(long timestamp);
+
+    /**
+     * Each message must have a globally unique Id.
+     * interceptors heavily depend on this id for message processing
+     * @return byte
+     */
+    public byte[] getUniqueId();
+    
+    /**
+     * The byte buffer that contains the actual message payload
+     * @param buf XByteBuffer
+     */
+    public void setMessage(XByteBuffer buf);
+    
+    /**
+     * returns the byte buffer that contains the actual message payload
+     * @return XByteBuffer
+     */
+    public XByteBuffer getMessage();
+    
+    /**
+     * The message options is a 32 bit flag set
+     * that triggers interceptors and message behavior.
+     * @see Channel#send(Member[], Serializable, int) 
+     * @see ChannelInterceptor#getOptionFlag
+     * @return int - the option bits set for this message
+     */
+    public int getOptions();
+    
+    /**
+     * sets the option bits for this message
+     * @param options int
+     * @see #getOptions()
+     */
+    public void setOptions(int options);
+    
+    /**
+     * Shallow clone, what gets cloned depends on the implementation
+     * @return ChannelMessage
+     */
+    public Object clone();
+
+    /**
+     * Deep clone, all fields MUST get cloned
+     * @return ChannelMessage
+     */
+    public Object deepclone();
+}

==================================================
ChannelSender.java
index 3aaae9cd90..36c77da297 100644
--- a/java/org/apache/catalina/tribes/ChannelReceiver.java
+++ b/java/org/apache/catalina/tribes/ChannelReceiver.java
@@ -1,75 +1,75 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes;
-
-
-/**
- * ChannelReceiver Interface<br>
- * The <code>ChannelReceiver</code> interface is the data receiver component 
- * at the bottom layer, the IO layer (for layers see the javadoc for the {@link Channel} interface).
- * This class may optionally implement a thread pool for parallel processing of incoming messages.
- * @author Filip Hanik
- * @version $Revision: 379904 $, $Date: 2006-02-22 15:16:25 -0600 (Wed, 22 Feb 2006) $
- */
-public interface ChannelReceiver extends Heartbeat {
-    /**
-     * Start listening for incoming messages on the host/port
-     * @throws java.io.IOException
-     */
-    public void start() throws java.io.IOException;
-
-    /**
-     * Stop listening for messages
-     */
-    public void stop();
-
-    /**
-     * String representation of the IPv4 or IPv6 address that this host is listening
-     * to.
-     * @return the host that this receiver is listening to
-     */
-    public String getHost();
-    
-    
-    /**
-     * Returns the listening port
-     * @return port
-     */
-    public int getPort();
-    
-    /**
-     * Returns the secure listening port
-     * @return port, -1 if a secure port is not activated
-     */
-    public int getSecurePort();
-    
-    /**
-     * Sets the message listener to receive notification of incoming
-     * @param listener MessageListener
-     * @see MessageListener
-     */
-    public void setMessageListener(MessageListener listener);
-    
-    /**
-     * Returns the message listener that is associated with this receiver
-     * @return MessageListener
-     * @see MessageListener
-     */
-    public MessageListener getMessageListener();
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes;
+
+
+/**
+ * ChannelReceiver Interface<br>
+ * The <code>ChannelReceiver</code> interface is the data receiver component 
+ * at the bottom layer, the IO layer (for layers see the javadoc for the {@link Channel} interface).
+ * This class may optionally implement a thread pool for parallel processing of incoming messages.
+ * @author Filip Hanik
+ * @version $Revision$, $Date$
+ */
+public interface ChannelReceiver extends Heartbeat {
+    /**
+     * Start listening for incoming messages on the host/port
+     * @throws java.io.IOException
+     */
+    public void start() throws java.io.IOException;
+
+    /**
+     * Stop listening for messages
+     */
+    public void stop();
+
+    /**
+     * String representation of the IPv4 or IPv6 address that this host is listening
+     * to.
+     * @return the host that this receiver is listening to
+     */
+    public String getHost();
+    
+    
+    /**
+     * Returns the listening port
+     * @return port
+     */
+    public int getPort();
+    
+    /**
+     * Returns the secure listening port
+     * @return port, -1 if a secure port is not activated
+     */
+    public int getSecurePort();
+    
+    /**
+     * Sets the message listener to receive notification of incoming
+     * @param listener MessageListener
+     * @see MessageListener
+     */
+    public void setMessageListener(MessageListener listener);
+    
+    /**
+     * Returns the message listener that is associated with this receiver
+     * @return MessageListener
+     * @see MessageListener
+     */
+    public MessageListener getMessageListener();
+
+}

==================================================
Constants.java
index 1dea5f8d67..815bc0852d 100644
--- a/java/org/apache/catalina/tribes/ChannelSender.java
+++ b/java/org/apache/catalina/tribes/ChannelSender.java
@@ -1,69 +1,69 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes;
-
-
-/**
- * ChannelReceiver Interface<br>
- * The <code>ChannelSender</code> interface is the data sender component 
- * at the bottom layer, the IO layer (for layers see the javadoc for the {@link Channel} interface).<br>
- * The channel sender must support "silent" members, ie, be able to send a message to a member
- * that is not in the membership, but is part of the destination parameter
- * @author Filip Hanik
- * @version $Revision: 379904 $, $Date: 2006-02-22 15:16:25 -0600 (Wed, 22 Feb 2006) $
- */
-public interface ChannelSender extends Heartbeat
-{
-    /**
-     * Notify the sender of a member being added to the group.<br>
-     * Optional. This can be an empty implementation, that does nothing
-     * @param member Member
-     */
-    public void add(Member member);
-    /**
-     * Notification that a member has been removed or crashed.
-     * Can be used to clean up open connections etc
-     * @param member Member
-     */
-    public void remove(Member member);
-    
-    /**
-     * Start the channel sender
-     * @throws IOException if preprocessing takes place and an error happens
-     */
-    public void start() throws java.io.IOException;
-    /**
-     * Stop the channel sender
-     */
-    public void stop();
-    
-    /**
-     * A channel heartbeat, use this method to clean up resources
-     */
-    public void heartbeat() ;
-    
-    /**
-     * Send a message to one or more recipients.
-     * @param message ChannelMessage - the message to be sent
-     * @param destination Member[] - the destinations
-     * @throws ChannelException - if an error happens, the ChannelSender MUST report
-     * individual send failures on a per member basis, using ChannelException.addFaultyMember
-     * @see ChannelException#addFaultyMember(Member,java.lang.Exception)
-     */
-    public void sendMessage(ChannelMessage message, Member[] destination) throws ChannelException;
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes;
+
+
+/**
+ * ChannelReceiver Interface<br>
+ * The <code>ChannelSender</code> interface is the data sender component 
+ * at the bottom layer, the IO layer (for layers see the javadoc for the {@link Channel} interface).<br>
+ * The channel sender must support "silent" members, ie, be able to send a message to a member
+ * that is not in the membership, but is part of the destination parameter
+ * @author Filip Hanik
+ * @version $Revision$, $Date$
+ */
+public interface ChannelSender extends Heartbeat
+{
+    /**
+     * Notify the sender of a member being added to the group.<br>
+     * Optional. This can be an empty implementation, that does nothing
+     * @param member Member
+     */
+    public void add(Member member);
+    /**
+     * Notification that a member has been removed or crashed.
+     * Can be used to clean up open connections etc
+     * @param member Member
+     */
+    public void remove(Member member);
+    
+    /**
+     * Start the channel sender
+     * @throws IOException if preprocessing takes place and an error happens
+     */
+    public void start() throws java.io.IOException;
+    /**
+     * Stop the channel sender
+     */
+    public void stop();
+    
+    /**
+     * A channel heartbeat, use this method to clean up resources
+     */
+    public void heartbeat() ;
+    
+    /**
+     * Send a message to one or more recipients.
+     * @param message ChannelMessage - the message to be sent
+     * @param destination Member[] - the destinations
+     * @throws ChannelException - if an error happens, the ChannelSender MUST report
+     * individual send failures on a per member basis, using ChannelException.addFaultyMember
+     * @see ChannelException#addFaultyMember(Member,java.lang.Exception)
+     */
+    public void sendMessage(ChannelMessage message, Member[] destination) throws ChannelException;
+}

==================================================
ErrorHandler.java
index 8e7feb2aea..57ccb8ea9f 100644
--- a/java/org/apache/catalina/tribes/Constants.java
+++ b/java/org/apache/catalina/tribes/Constants.java
@@ -1,32 +1,32 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina.tribes;
-
-/**
- * Manifest constants for the <code>org.apache.catalina.tribes</code>
- * package.
- *
- * @author Bip Thelin
- * @author Filip Hanik
- * @version $Revision: 302726 $, $Date: 2004-02-27 08:59:07 -0600 (Fri, 27 Feb 2004) $
- */
-
-public final class Constants {
-    public static final String Package = "org.apache.catalina.tribes";
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.catalina.tribes;
+
+/**
+ * Manifest constants for the <code>org.apache.catalina.tribes</code>
+ * package.
+ *
+ * @author Bip Thelin
+ * @author Filip Hanik
+ * @version $Revision$, $Date$
+ */
+
+public final class Constants {
+    public static final String Package = "org.apache.catalina.tribes";
+}

==================================================
Heartbeat.java
index 4b79be0fc4..db5de4f31c 100644
--- a/java/org/apache/catalina/tribes/ErrorHandler.java
+++ b/java/org/apache/catalina/tribes/ErrorHandler.java
@@ -1,46 +1,46 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes;
-
-
-
-/**
- * The <code>ErrorHandler</code> class is used when sending messages
- * that are sent asynchronously and the application still needs to get 
- * confirmation when the message was sent successfully or when a message errored out.
- * @author Filip Hanik
- * @version 1.0
- */
-public interface ErrorHandler {
-    
-    /**
-     * Invoked if the message is dispatched asynch, and an error occurs
-     * @param x ChannelException - the error that happened
-     * @param id - the unique id for the message
-     * @see Channel#send(Member[], Serializable, int, ErrorHandler)
-     */
-    public void handleError(ChannelException x, UniqueId id);
-    
-    /**
-     * Invoked when the message has been sent successfully.
-     * @param id - the unique id for the message
-     * @see Channel#send(Member[], Serializable, int, ErrorHandler)
-     */
-    public void handleCompletion(UniqueId id);
-    
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes;
+
+
+
+/**
+ * The <code>ErrorHandler</code> class is used when sending messages
+ * that are sent asynchronously and the application still needs to get 
+ * confirmation when the message was sent successfully or when a message errored out.
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public interface ErrorHandler {
+    
+    /**
+     * Invoked if the message is dispatched asynch, and an error occurs
+     * @param x ChannelException - the error that happened
+     * @param id - the unique id for the message
+     * @see Channel#send(Member[], Serializable, int, ErrorHandler)
+     */
+    public void handleError(ChannelException x, UniqueId id);
+    
+    /**
+     * Invoked when the message has been sent successfully.
+     * @param id - the unique id for the message
+     * @see Channel#send(Member[], Serializable, int, ErrorHandler)
+     */
+    public void handleCompletion(UniqueId id);
+    
 }
\ No newline at end of file

==================================================
ManagedChannel.java
index 21277309b8..7cd91e4ec0 100644
--- a/java/org/apache/catalina/tribes/Heartbeat.java
+++ b/java/org/apache/catalina/tribes/Heartbeat.java
@@ -1,34 +1,34 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes;
-
-/**
- * Can be implemented by the ChannelListener and Membership listeners to receive heartbeat
- * notifications from the Channel
- * @author Filip Hanik
- * @version 1.0
- * @see Channel
- * @see Channel#heartbeat()
- */
-public interface Heartbeat {
-    
-    /**
-     * Heartbeat invokation for resources cleanup etc
-     */
-    public void heartbeat();
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes;
+
+/**
+ * Can be implemented by the ChannelListener and Membership listeners to receive heartbeat
+ * notifications from the Channel
+ * @author Filip Hanik
+ * @version 1.0
+ * @see Channel
+ * @see Channel#heartbeat()
+ */
+public interface Heartbeat {
+    
+    /**
+     * Heartbeat invokation for resources cleanup etc
+     */
+    public void heartbeat();
+
 }
\ No newline at end of file

==================================================
Member.java
index 98d7e2c5cb..79ae9a8449 100644
--- a/java/org/apache/catalina/tribes/ManagedChannel.java
+++ b/java/org/apache/catalina/tribes/ManagedChannel.java
@@ -1,78 +1,78 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes;
-
-import java.util.Iterator;
-
-/**
- * Channel interface
- * A managed channel interface gives you access to the components of the channels
- * such as senders, receivers, interceptors etc for configurations purposes
- * @author Filip Hanik
- * @version $Revision: 304032 $, $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
- */
-public interface ManagedChannel extends Channel {
-
-    /**
-     * Sets the channel sender
-     * @param sender ChannelSender
-     * @see ChannelSender
-     */
-    public void setChannelSender(ChannelSender sender);
-
-    /**
-     * Sets the channel receiver
-     * @param receiver ChannelReceiver
-     * @see ChannelReceiver
-     */
-    public void setChannelReceiver(ChannelReceiver receiver);
-    
-    /**
-     * Sets the membership service
-     * @param service MembershipService
-     * @see MembershipService
-     */
-    public void setMembershipService(MembershipService service);
-
-    /**
-     * returns the channel sender
-     * @return ChannelSender
-     * @see ChannelSender
-     */
-    public ChannelSender getChannelSender();
-    
-    /**
-     * returns the channel receiver
-     * @return ChannelReceiver
-     * @see ChannelReceiver
-     */
-    public ChannelReceiver getChannelReceiver();
-    
-    /**
-     * Returns the membership service
-     * @return MembershipService
-     * @see MembershipService
-     */
-    public MembershipService getMembershipService();
-
-    /**
-     * Returns the interceptor stack
-     * @return Iterator
-     * @see Channel#addInterceptor(ChannelInterceptor)
-     */
-    public Iterator getInterceptors();
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes;
+
+import java.util.Iterator;
+
+/**
+ * Channel interface
+ * A managed channel interface gives you access to the components of the channels
+ * such as senders, receivers, interceptors etc for configurations purposes
+ * @author Filip Hanik
+ * @version $Revision$, $Date$
+ */
+public interface ManagedChannel extends Channel {
+
+    /**
+     * Sets the channel sender
+     * @param sender ChannelSender
+     * @see ChannelSender
+     */
+    public void setChannelSender(ChannelSender sender);
+
+    /**
+     * Sets the channel receiver
+     * @param receiver ChannelReceiver
+     * @see ChannelReceiver
+     */
+    public void setChannelReceiver(ChannelReceiver receiver);
+    
+    /**
+     * Sets the membership service
+     * @param service MembershipService
+     * @see MembershipService
+     */
+    public void setMembershipService(MembershipService service);
+
+    /**
+     * returns the channel sender
+     * @return ChannelSender
+     * @see ChannelSender
+     */
+    public ChannelSender getChannelSender();
+    
+    /**
+     * returns the channel receiver
+     * @return ChannelReceiver
+     * @see ChannelReceiver
+     */
+    public ChannelReceiver getChannelReceiver();
+    
+    /**
+     * Returns the membership service
+     * @return MembershipService
+     * @see MembershipService
+     */
+    public MembershipService getMembershipService();
+
+    /**
+     * Returns the interceptor stack
+     * @return Iterator
+     * @see Channel#addInterceptor(ChannelInterceptor)
+     */
+    public Iterator getInterceptors();
+}

==================================================
MembershipListener.java
index 351aa77d96..149a546a63 100644
--- a/java/org/apache/catalina/tribes/Member.java
+++ b/java/org/apache/catalina/tribes/Member.java
@@ -1,119 +1,119 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes;
-
-/**
- * The Member interface, defines a member in the group.
- * Each member can carry a set of properties, defined by the actual implementation.<BR>
- * A member is identified by the host/ip/uniqueId<br>
- * The host is what interface the member is listening to, to receive data<br>
- * The port is what port the member is listening to, to receive data<br>
- * The uniqueId defines the session id for the member. This is an important feature
- * since a member that has crashed and the starts up again on the same port/host is 
- * not guaranteed to be the same member, so no state transfers will ever be confused
- * @author Filip Hanik
- * @version $Revision: 303950 $, $Date: 2005-06-09 15:38:30 -0500 (Thu, 09 Jun 2005) $
- */
-
-
-public interface Member {
-    
-    /**
-     * When a member leaves the cluster, the payload of the memberDisappeared member
-     * will be the following bytes. This indicates a soft shutdown, and not a crash
-     */
-    public static final byte[] SHUTDOWN_PAYLOAD = new byte[] {66, 65, 66, 89, 45, 65, 76, 69, 88};
-    
-    /**
-     * Returns the name of this node, should be unique within the group.
-     */
-    public String getName();
-  
-    /**
-     * Returns the listen host for the ChannelReceiver implementation
-     * @return IPv4 or IPv6 representation of the host address this member listens to incoming data
-     * @see ChannelReceiver
-     */
-    public byte[] getHost();
-
-    /**
-     * Returns the listen port for the ChannelReceiver implementation
-     * @return the listen port for this member, -1 if its not listening on an unsecure port
-     * @see ChannelReceiver
-     */
-    public int getPort();
-    
-    /**
-     * Returns the secure listen port for the ChannelReceiver implementation.
-     * Returns -1 if its not listening to a secure port.
-     * @return the listen port for this member, -1 if its not listening on a secure port
-     * @see ChannelReceiver
-     */
-    public int getSecurePort();
-    
-
-    /**
-     * Contains information on how long this member has been online.
-     * The result is the number of milli seconds this member has been
-     * broadcasting its membership to the group.
-     * @return nr of milliseconds since this member started.
-     */
-    public long getMemberAliveTime();
-    
-    /**
-     * The current state of the member
-     * @return boolean - true if the member is functioning correctly
-     */
-    public boolean isReady();
-    /**
-     * The current state of the member
-     * @return boolean - true if the member is suspect, but the crash has not been confirmed
-     */
-    public boolean isSuspect();
-    
-    /**
-     * 
-     * @return boolean - true if the member has been confirmed to malfunction 
-     */
-    public boolean isFailing();
-    
-    /**
-     * returns a UUID unique for this member over all sessions.
-     * If the member crashes and restarts, the uniqueId will be different.
-     * @return byte[]
-     */
-    public byte[] getUniqueId();
-    
-    /**
-     * returns the payload associated with this member
-     * @return byte[]
-     */
-    public byte[] getPayload();
-    
-    /**
-     * returns the command associated with this member
-     * @return byte[]
-     */
-    public byte[] getCommand();
-    
-    /**
-     * Domain for this cluster
-     * @return byte[]
-     */
-    public byte[] getDomain();
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes;
+
+/**
+ * The Member interface, defines a member in the group.
+ * Each member can carry a set of properties, defined by the actual implementation.<BR>
+ * A member is identified by the host/ip/uniqueId<br>
+ * The host is what interface the member is listening to, to receive data<br>
+ * The port is what port the member is listening to, to receive data<br>
+ * The uniqueId defines the session id for the member. This is an important feature
+ * since a member that has crashed and the starts up again on the same port/host is 
+ * not guaranteed to be the same member, so no state transfers will ever be confused
+ * @author Filip Hanik
+ * @version $Revision$, $Date$
+ */
+
+
+public interface Member {
+    
+    /**
+     * When a member leaves the cluster, the payload of the memberDisappeared member
+     * will be the following bytes. This indicates a soft shutdown, and not a crash
+     */
+    public static final byte[] SHUTDOWN_PAYLOAD = new byte[] {66, 65, 66, 89, 45, 65, 76, 69, 88};
+    
+    /**
+     * Returns the name of this node, should be unique within the group.
+     */
+    public String getName();
+  
+    /**
+     * Returns the listen host for the ChannelReceiver implementation
+     * @return IPv4 or IPv6 representation of the host address this member listens to incoming data
+     * @see ChannelReceiver
+     */
+    public byte[] getHost();
+
+    /**
+     * Returns the listen port for the ChannelReceiver implementation
+     * @return the listen port for this member, -1 if its not listening on an unsecure port
+     * @see ChannelReceiver
+     */
+    public int getPort();
+    
+    /**
+     * Returns the secure listen port for the ChannelReceiver implementation.
+     * Returns -1 if its not listening to a secure port.
+     * @return the listen port for this member, -1 if its not listening on a secure port
+     * @see ChannelReceiver
+     */
+    public int getSecurePort();
+    
+
+    /**
+     * Contains information on how long this member has been online.
+     * The result is the number of milli seconds this member has been
+     * broadcasting its membership to the group.
+     * @return nr of milliseconds since this member started.
+     */
+    public long getMemberAliveTime();
+    
+    /**
+     * The current state of the member
+     * @return boolean - true if the member is functioning correctly
+     */
+    public boolean isReady();
+    /**
+     * The current state of the member
+     * @return boolean - true if the member is suspect, but the crash has not been confirmed
+     */
+    public boolean isSuspect();
+    
+    /**
+     * 
+     * @return boolean - true if the member has been confirmed to malfunction 
+     */
+    public boolean isFailing();
+    
+    /**
+     * returns a UUID unique for this member over all sessions.
+     * If the member crashes and restarts, the uniqueId will be different.
+     * @return byte[]
+     */
+    public byte[] getUniqueId();
+    
+    /**
+     * returns the payload associated with this member
+     * @return byte[]
+     */
+    public byte[] getPayload();
+    
+    /**
+     * returns the command associated with this member
+     * @return byte[]
+     */
+    public byte[] getCommand();
+    
+    /**
+     * Domain for this cluster
+     * @return byte[]
+     */
+    public byte[] getDomain();
+}

==================================================
MembershipService.java
index 50e34bc9a3..be320190e0 100644
--- a/java/org/apache/catalina/tribes/MembershipListener.java
+++ b/java/org/apache/catalina/tribes/MembershipListener.java
@@ -1,45 +1,45 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes;
-
-/**
- * The MembershipListener interface is used as a callback to the
- * membership service. It has two methods that will notify the listener
- * when a member has joined the group and when a member has disappeared (crashed)
- *
- * @author Filip Hanik
- * @version $Revision: 302726 $, $Date: 2004-02-27 08:59:07 -0600 (Fri, 27 Feb 2004) $
- */
-
-
-public interface MembershipListener {
-    /**
-     * A member was added to the group
-     * @param member Member - the member that was added
-     */
-    public void memberAdded(Member member);
-    
-    /**
-     * A member was removed from the group<br>
-     * If the member left voluntarily, the Member.getCommand will contain the Member.SHUTDOWN_PAYLOAD data
-     * @param member Member
-     * @see Member#SHUTDOWN_PAYLOAD
-     */
-    public void memberDisappeared(Member member);
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes;
+
+/**
+ * The MembershipListener interface is used as a callback to the
+ * membership service. It has two methods that will notify the listener
+ * when a member has joined the group and when a member has disappeared (crashed)
+ *
+ * @author Filip Hanik
+ * @version $Revision$, $Date$
+ */
+
+
+public interface MembershipListener {
+    /**
+     * A member was added to the group
+     * @param member Member - the member that was added
+     */
+    public void memberAdded(Member member);
+    
+    /**
+     * A member was removed from the group<br>
+     * If the member left voluntarily, the Member.getCommand will contain the Member.SHUTDOWN_PAYLOAD data
+     * @param member Member
+     * @see Member#SHUTDOWN_PAYLOAD
+     */
+    public void memberDisappeared(Member member);
+
 }
\ No newline at end of file

==================================================
MessageListener.java
index 95256de2dc..ff2da42117 100644
--- a/java/org/apache/catalina/tribes/MembershipService.java
+++ b/java/org/apache/catalina/tribes/MembershipService.java
@@ -1,135 +1,135 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes;
-
-
-/**
- * MembershipService Interface<br>
- * The <code>MembershipService</code> interface is the membership component 
- * at the bottom layer, the IO layer (for layers see the javadoc for the {@link Channel} interface).<br>
- * @author Filip Hanik
- * @version $Revision: 378093 $, $Date: 2006-02-15 15:13:45 -0600 (Wed, 15 Feb 2006) $
- */
-
-
-public interface MembershipService {
-    
-    public static final int MBR_RX = Channel.MBR_RX_SEQ;
-    public static final int MBR_TX = Channel.MBR_TX_SEQ;
-    
-    /**
-     * Sets the properties for the membership service. This must be called before
-     * the <code>start()</code> method is called.
-     * The properties are implementation specific.
-     * @param properties - to be used to configure the membership service.
-     */
-    public void setProperties(java.util.Properties properties);
-    /**
-     * Returns the properties for the configuration used.
-     */
-    public java.util.Properties getProperties();
-    /**
-     * Starts the membership service. If a membership listeners is added
-     * the listener will start to receive membership events.
-     * Performs a start level 1 and 2
-     * @throws java.lang.Exception if the service fails to start.
-     */
-    public void start() throws java.lang.Exception;
-
-    /**
-     * Starts the membership service. If a membership listeners is added
-     * the listener will start to receive membership events.
-     * @param level - level MBR_RX starts listening for members, level MBR_TX 
-     * starts broad casting the server
-     * @throws java.lang.Exception if the service fails to start.
-     * @throws java.lang.IllegalArgumentException if the level is incorrect.
-     */
-    public void start(int level) throws java.lang.Exception;
-
-
-    /**
-     * Starts the membership service. If a membership listeners is added
-     * the listener will start to receive membership events.
-     * @param level - level MBR_RX stops listening for members, level MBR_TX 
-     * stops broad casting the server
-     * @throws java.lang.Exception if the service fails to stop
-     * @throws java.lang.IllegalArgumentException if the level is incorrect.
-     */
-
-    public void stop(int level);
-    
-    /**
-     * @return true if the the group contains members
-     */
-    public boolean hasMembers();
-    
-    
-    /**
-     * 
-     * @param mbr Member
-     * @return Member
-     */
-    public Member getMember(Member mbr);
-    /**
-     * Returns a list of all the members in the cluster.
-     */
-    
-    public Member[] getMembers();
-    
-    /**
-     * Returns the member object that defines this member
-     */
-    public Member getLocalMember(boolean incAliveTime);
-
-    /**
-     * Return all members by name
-     */
-    public String[] getMembersByName() ; 
-    
-    /**
-     * Return the member by name
-     */
-    public Member findMemberByName(String name) ;
-
-    /**
-     * Sets the local member properties for broadcasting
-     */
-    public void setLocalMemberProperties(String listenHost, int listenPort);
-    
-    /**
-     * Sets the membership listener, only one listener can be added.
-     * If you call this method twice, the last listener will be used.
-     * @param listener The listener
-     */
-    public void setMembershipListener(MembershipListener listener);
-    
-    /**
-     * removes the membership listener.
-     */
-    public void removeMembershipListener();
-    
-    /**
-     * Set a payload to be broadcasted with each membership 
-     * broadcast.
-     * @param payload byte[]
-     */
-    public void setPayload(byte[] payload);
-    
-    public void setDomain(byte[] domain);
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes;
+
+
+/**
+ * MembershipService Interface<br>
+ * The <code>MembershipService</code> interface is the membership component 
+ * at the bottom layer, the IO layer (for layers see the javadoc for the {@link Channel} interface).<br>
+ * @author Filip Hanik
+ * @version $Revision$, $Date$
+ */
+
+
+public interface MembershipService {
+    
+    public static final int MBR_RX = Channel.MBR_RX_SEQ;
+    public static final int MBR_TX = Channel.MBR_TX_SEQ;
+    
+    /**
+     * Sets the properties for the membership service. This must be called before
+     * the <code>start()</code> method is called.
+     * The properties are implementation specific.
+     * @param properties - to be used to configure the membership service.
+     */
+    public void setProperties(java.util.Properties properties);
+    /**
+     * Returns the properties for the configuration used.
+     */
+    public java.util.Properties getProperties();
+    /**
+     * Starts the membership service. If a membership listeners is added
+     * the listener will start to receive membership events.
+     * Performs a start level 1 and 2
+     * @throws java.lang.Exception if the service fails to start.
+     */
+    public void start() throws java.lang.Exception;
+
+    /**
+     * Starts the membership service. If a membership listeners is added
+     * the listener will start to receive membership events.
+     * @param level - level MBR_RX starts listening for members, level MBR_TX 
+     * starts broad casting the server
+     * @throws java.lang.Exception if the service fails to start.
+     * @throws java.lang.IllegalArgumentException if the level is incorrect.
+     */
+    public void start(int level) throws java.lang.Exception;
+
+
+    /**
+     * Starts the membership service. If a membership listeners is added
+     * the listener will start to receive membership events.
+     * @param level - level MBR_RX stops listening for members, level MBR_TX 
+     * stops broad casting the server
+     * @throws java.lang.Exception if the service fails to stop
+     * @throws java.lang.IllegalArgumentException if the level is incorrect.
+     */
+
+    public void stop(int level);
+    
+    /**
+     * @return true if the the group contains members
+     */
+    public boolean hasMembers();
+    
+    
+    /**
+     * 
+     * @param mbr Member
+     * @return Member
+     */
+    public Member getMember(Member mbr);
+    /**
+     * Returns a list of all the members in the cluster.
+     */
+    
+    public Member[] getMembers();
+    
+    /**
+     * Returns the member object that defines this member
+     */
+    public Member getLocalMember(boolean incAliveTime);
+
+    /**
+     * Return all members by name
+     */
+    public String[] getMembersByName() ; 
+    
+    /**
+     * Return the member by name
+     */
+    public Member findMemberByName(String name) ;
+
+    /**
+     * Sets the local member properties for broadcasting
+     */
+    public void setLocalMemberProperties(String listenHost, int listenPort);
+    
+    /**
+     * Sets the membership listener, only one listener can be added.
+     * If you call this method twice, the last listener will be used.
+     * @param listener The listener
+     */
+    public void setMembershipListener(MembershipListener listener);
+    
+    /**
+     * removes the membership listener.
+     */
+    public void removeMembershipListener();
+    
+    /**
+     * Set a payload to be broadcasted with each membership 
+     * broadcast.
+     * @param payload byte[]
+     */
+    public void setPayload(byte[] payload);
+    
+    public void setDomain(byte[] domain);
+
+}

==================================================
UniqueId.java
index d9458f6594..02adf5a329 100644
--- a/java/org/apache/catalina/tribes/MessageListener.java
+++ b/java/org/apache/catalina/tribes/MessageListener.java
@@ -1,43 +1,43 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes;
-
-/**
- * 
- * <p>Title: MessageListener</p> 
- * 
- * <p>Description: The listener to be registered with the ChannelReceiver, internal Tribes component</p> 
- * 
- * @author Filip Hanik
- * @version 1.0
- */
-
-public interface MessageListener {
-    
-    /**
-     * Receive a message from the IO components in the Channel stack
-     * @param msg ChannelMessage
-     */
-    public void messageReceived(ChannelMessage msg);
-    
-    public boolean accept(ChannelMessage msg);
-    
-    public boolean equals(Object listener);
-    
-    public int hashCode();
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes;
+
+/**
+ * 
+ * <p>Title: MessageListener</p> 
+ * 
+ * <p>Description: The listener to be registered with the ChannelReceiver, internal Tribes component</p> 
+ * 
+ * @author Filip Hanik
+ * @version 1.0
+ */
+
+public interface MessageListener {
+    
+    /**
+     * Receive a message from the IO components in the Channel stack
+     * @param msg ChannelMessage
+     */
+    public void messageReceived(ChannelMessage msg);
+    
+    public boolean accept(ChannelMessage msg);
+    
+    public boolean equals(Object listener);
+    
+    public int hashCode();
+
+}

==================================================
ChannelCoordinator.java
index 4be5c43168..db69de0f37 100644
--- a/java/org/apache/catalina/tribes/UniqueId.java
+++ b/java/org/apache/catalina/tribes/UniqueId.java
@@ -1,72 +1,72 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes;
-
-import org.apache.catalina.tribes.util.Arrays;
-import java.io.Serializable;
-
-/**
- * <p>Title: Represents a globabally unique Id</p>
- *
- * <p>Company: </p>
- *
- * @author Filip Hanik
- * @version 1.0
- */
-public final class UniqueId implements Serializable{
-    protected byte[] id;
-    
-    public UniqueId() {
-    }
-
-    public UniqueId(byte[] id) {
-        this.id = id;
-    }
-    
-    public UniqueId(byte[] id, int offset, int length) {
-        this.id = new byte[length];
-        System.arraycopy(id,offset,this.id,0,length);
-    }
-    
-    public int hashCode() {
-        if ( id == null ) return 0;
-        return Arrays.hashCode(id);
-    }
-    
-    public boolean equals(Object other) {
-        boolean result = (other instanceof UniqueId);
-        if ( result ) {
-            UniqueId uid = (UniqueId)other;
-            if ( this.id == null && uid.id == null ) result = true;
-            else if ( this.id == null && uid.id != null ) result = false;
-            else if ( this.id != null && uid.id == null ) result = false;
-            else result = Arrays.equals(this.id,uid.id);
-        }//end if
-        return result;
-    }
-    
-    public byte[] getBytes() {
-        return id;
-    }
-    
-    public String toString() {
-        StringBuffer buf = new StringBuffer("UniqueId");
-        buf.append(org.apache.catalina.tribes.util.Arrays.toString(id));
-        return buf.toString();
-    }
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes;
+
+import org.apache.catalina.tribes.util.Arrays;
+import java.io.Serializable;
+
+/**
+ * <p>Title: Represents a globabally unique Id</p>
+ *
+ * <p>Company: </p>
+ *
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public final class UniqueId implements Serializable{
+    protected byte[] id;
+    
+    public UniqueId() {
+    }
+
+    public UniqueId(byte[] id) {
+        this.id = id;
+    }
+    
+    public UniqueId(byte[] id, int offset, int length) {
+        this.id = new byte[length];
+        System.arraycopy(id,offset,this.id,0,length);
+    }
+    
+    public int hashCode() {
+        if ( id == null ) return 0;
+        return Arrays.hashCode(id);
+    }
+    
+    public boolean equals(Object other) {
+        boolean result = (other instanceof UniqueId);
+        if ( result ) {
+            UniqueId uid = (UniqueId)other;
+            if ( this.id == null && uid.id == null ) result = true;
+            else if ( this.id == null && uid.id != null ) result = false;
+            else if ( this.id != null && uid.id == null ) result = false;
+            else result = Arrays.equals(this.id,uid.id);
+        }//end if
+        return result;
+    }
+    
+    public byte[] getBytes() {
+        return id;
+    }
+    
+    public String toString() {
+        StringBuffer buf = new StringBuffer("UniqueId");
+        buf.append(org.apache.catalina.tribes.util.Arrays.toString(id));
+        return buf.toString();
+    }
+
 }
\ No newline at end of file

==================================================
ChannelInterceptorBase.java
index b3634dd16c..c185f4e741 100644
--- a/java/org/apache/catalina/tribes/group/ChannelCoordinator.java
+++ b/java/org/apache/catalina/tribes/group/ChannelCoordinator.java
@@ -1,318 +1,318 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.group;
-
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.ChannelReceiver;
-import org.apache.catalina.tribes.ChannelSender;
-
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.MembershipService;
-import org.apache.catalina.tribes.MessageListener;
-import org.apache.catalina.tribes.transport.SenderState;
-import org.apache.catalina.tribes.transport.ReplicationTransmitter;
-import org.apache.catalina.tribes.membership.McastService;
-import org.apache.catalina.tribes.transport.nio.NioReceiver;
-import org.apache.catalina.tribes.Channel;
-import org.apache.catalina.tribes.util.Logs;
-import org.apache.catalina.tribes.UniqueId;
-import org.apache.catalina.tribes.util.Arrays;
-
-
-/**
- * The channel coordinator object coordinates the membership service,
- * the sender and the receiver.
- * This is the last interceptor in the chain.
- * @author Filip Hanik
- * @version $Revision: 304032 $, $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
- */
-public class ChannelCoordinator extends ChannelInterceptorBase implements MessageListener {
-    private ChannelReceiver clusterReceiver = new NioReceiver();
-    private ChannelSender clusterSender = new ReplicationTransmitter();
-    private MembershipService membershipService = new McastService();
-    
-    //override optionflag
-    protected int optionFlag = Channel.SEND_OPTIONS_BYTE_MESSAGE|Channel.SEND_OPTIONS_USE_ACK|Channel.SEND_OPTIONS_SYNCHRONIZED_ACK;
-    public int getOptionFlag() {return optionFlag;}
-    public void setOptionFlag(int flag) {optionFlag=flag;}
-    
-    private int startLevel = 0;
-
-    public ChannelCoordinator() {
-        
-    }
-    
-    public ChannelCoordinator(ChannelReceiver receiver,
-                              ChannelSender sender,
-                              MembershipService service) {
-        this();
-        this.setClusterReceiver(receiver);
-        this.setClusterSender(sender);
-        this.setMembershipService(service);
-    }
-    
-    /**
-     * Send a message to one or more members in the cluster
-     * @param destination Member[] - the destinations, null or zero length means all
-     * @param msg ClusterMessage - the message to send
-     * @param options int - sender options, see class documentation
-     * @return ClusterMessage[] - the replies from the members, if any.
-     */
-    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
-        if ( destination == null ) destination = membershipService.getMembers();
-        clusterSender.sendMessage(msg,destination);
-        if ( Logs.MESSAGES.isTraceEnabled() ) {
-            Logs.MESSAGES.trace("ChannelCoordinator - Sent msg:" + new UniqueId(msg.getUniqueId()) + " at " +new java.sql.Timestamp(System.currentTimeMillis())+ " to "+Arrays.toNameString(destination));
-        }
-    }
-    
-
-    /**
-     * Starts up the channel. This can be called multiple times for individual services to start
-     * The svc parameter can be the logical or value of any constants
-     * @param svc int value of <BR>
-     * DEFAULT - will start all services <BR>
-     * MBR_RX_SEQ - starts the membership receiver <BR>
-     * MBR_TX_SEQ - starts the membership broadcaster <BR>
-     * SND_TX_SEQ - starts the replication transmitter<BR>
-     * SND_RX_SEQ - starts the replication receiver<BR>
-     * @throws ChannelException if a startup error occurs or the service is already started.
-     */
-    public void start(int svc) throws ChannelException {
-        this.internalStart(svc);
-    }
-
-    /**
-     * Shuts down the channel. This can be called multiple times for individual services to shutdown
-     * The svc parameter can be the logical or value of any constants
-     * @param svc int value of <BR>
-     * DEFAULT - will shutdown all services <BR>
-     * MBR_RX_SEQ - stops the membership receiver <BR>
-     * MBR_TX_SEQ - stops the membership broadcaster <BR>
-     * SND_TX_SEQ - stops the replication transmitter<BR>
-     * SND_RX_SEQ - stops the replication receiver<BR>
-     * @throws ChannelException if a startup error occurs or the service is already started.
-     */
-    public void stop(int svc) throws ChannelException {
-        this.internalStop(svc);
-    }    
-
-
-    /**
-     * Starts up the channel. This can be called multiple times for individual services to start
-     * The svc parameter can be the logical or value of any constants
-     * @param svc int value of <BR>
-     * DEFAULT - will start all services <BR>
-     * MBR_RX_SEQ - starts the membership receiver <BR>
-     * MBR_TX_SEQ - starts the membership broadcaster <BR>
-     * SND_TX_SEQ - starts the replication transmitter<BR>
-     * SND_RX_SEQ - starts the replication receiver<BR>
-     * @throws ChannelException if a startup error occurs or the service is already started.
-     */
-    protected synchronized void internalStart(int svc) throws ChannelException {
-        try {
-            boolean valid = false;
-            //make sure we don't pass down any flags that are unrelated to the bottom layer
-            svc = svc & Channel.DEFAULT;
-
-            if (startLevel == Channel.DEFAULT) return; //we have already started up all components
-            if (svc == 0 ) return;//nothing to start
-            
-            if (svc == (svc & startLevel)) throw new ChannelException("Channel already started for level:"+svc);
-
-            //must start the receiver first so that we can coordinate the port it
-            //listens to with the local membership settings
-            if ( Channel.SND_RX_SEQ==(svc & Channel.SND_RX_SEQ) ) {
-                clusterReceiver.setMessageListener(this);
-                clusterReceiver.start();
-                //synchronize, big time FIXME
-                membershipService.setLocalMemberProperties(getClusterReceiver().getHost(), getClusterReceiver().getPort());
-                valid = true;
-            }
-            if ( Channel.SND_TX_SEQ==(svc & Channel.SND_TX_SEQ) ) {
-                clusterSender.start();
-                valid = true;
-            }
-            
-            if ( Channel.MBR_RX_SEQ==(svc & Channel.MBR_RX_SEQ) ) {
-                membershipService.setMembershipListener(this);
-                membershipService.start(MembershipService.MBR_RX);
-                valid = true;
-            }
-            if ( Channel.MBR_TX_SEQ==(svc & Channel.MBR_TX_SEQ) ) {
-                membershipService.start(MembershipService.MBR_TX);
-                valid = true;
-            }
-            
-            if ( !valid) {
-                throw new IllegalArgumentException("Invalid start level, valid levels are:SND_RX_SEQ,SND_TX_SEQ,MBR_TX_SEQ,MBR_RX_SEQ");
-            }
-            startLevel = (startLevel | svc);
-        }catch ( ChannelException cx ) {
-            throw cx;
-        }catch ( Exception x ) {
-            throw new ChannelException(x);
-        }
-    }
-
-    /**
-     * Shuts down the channel. This can be called multiple times for individual services to shutdown
-     * The svc parameter can be the logical or value of any constants
-     * @param svc int value of <BR>
-     * DEFAULT - will shutdown all services <BR>
-     * MBR_RX_SEQ - starts the membership receiver <BR>
-     * MBR_TX_SEQ - starts the membership broadcaster <BR>
-     * SND_TX_SEQ - starts the replication transmitter<BR>
-     * SND_RX_SEQ - starts the replication receiver<BR>
-     * @throws ChannelException if a startup error occurs or the service is already started.
-     */
-    protected synchronized void internalStop(int svc) throws ChannelException {
-        try {
-            //make sure we don't pass down any flags that are unrelated to the bottom layer
-            svc = svc & Channel.DEFAULT;
-
-            if (startLevel == 0) return; //we have already stopped up all components
-            if (svc == 0 ) return;//nothing to stop
-
-            boolean valid = false;
-            if ( Channel.SND_RX_SEQ==(svc & Channel.SND_RX_SEQ) ) {
-                clusterReceiver.stop();
-                clusterReceiver.setMessageListener(null);
-                valid = true;
-            }
-            if ( Channel.SND_TX_SEQ==(svc & Channel.SND_TX_SEQ) ) {
-                clusterSender.stop();
-                valid = true;
-            }
-
-            if ( Channel.MBR_RX_SEQ==(svc & Channel.MBR_RX_SEQ) ) {
-                membershipService.stop(MembershipService.MBR_RX);
-                membershipService.setMembershipListener(null);
-                valid = true;
-                
-            }
-            if ( Channel.MBR_TX_SEQ==(svc & Channel.MBR_TX_SEQ) ) {
-                valid = true;
-                membershipService.stop(MembershipService.MBR_TX);
-            }            
-            if ( !valid) {
-                throw new IllegalArgumentException("Invalid start level, valid levels are:SND_RX_SEQ,SND_TX_SEQ,MBR_TX_SEQ,MBR_RX_SEQ");
-            }
-
-            startLevel = (startLevel & (~svc));
-            
-        }catch ( Exception x ) {
-            throw new ChannelException(x);
-        } finally {
-            
-        }
-
-    }
-    
-    public void memberAdded(Member member){
-        SenderState.getSenderState(member);
-        if ( clusterSender!=null ) clusterSender.add(member);
-        super.memberAdded(member);
-    }
-    
-    public void memberDisappeared(Member member){
-        SenderState.removeSenderState(member);
-        if ( clusterSender!=null ) clusterSender.remove(member);
-        super.memberDisappeared(member);
-    }
-    
-    public void messageReceived(ChannelMessage msg) {
-        if ( Logs.MESSAGES.isTraceEnabled() ) {
-            Logs.MESSAGES.trace("ChannelCoordinator - Received msg:" + new UniqueId(msg.getUniqueId()) + " at " +new java.sql.Timestamp(System.currentTimeMillis())+ " from "+msg.getAddress().getName());
-        }
-        super.messageReceived(msg);
-    }
-
-
-    public ChannelReceiver getClusterReceiver() {
-        return clusterReceiver;
-    }
-
-    public ChannelSender getClusterSender() {
-        return clusterSender;
-    }
-
-    public MembershipService getMembershipService() {
-        return membershipService;
-    }
-
-    public void setClusterReceiver(ChannelReceiver clusterReceiver) {
-        if ( clusterReceiver != null ) {
-            this.clusterReceiver = clusterReceiver;
-            this.clusterReceiver.setMessageListener(this);
-        } else {
-            if  (this.clusterReceiver!=null ) this.clusterReceiver.setMessageListener(null);
-            this.clusterReceiver = null;
-        }
-    }
-
-    public void setClusterSender(ChannelSender clusterSender) {
-        this.clusterSender = clusterSender;
-    }
-
-    public void setMembershipService(MembershipService membershipService) {
-        this.membershipService = membershipService;
-        this.membershipService.setMembershipListener(this);
-    }
-    
-    public void hearbeat() {
-        if ( clusterSender!=null ) clusterSender.heartbeat();
-        super.heartbeat();
-    }
-    
-    /**
-     * has members
-     */
-    public boolean hasMembers() {
-        return this.getMembershipService().hasMembers();
-    }
-
-    /**
-     * Get all current cluster members
-     * @return all members or empty array
-     */
-    public Member[] getMembers() {
-        return this.getMembershipService().getMembers();
-    }
-
-    /**
-     * 
-     * @param mbr Member
-     * @return Member
-     */
-    public Member getMember(Member mbr){
-        return this.getMembershipService().getMember(mbr);
-    }
-
-
-    /**
-     * Return the member that represents this node.
-     *
-     * @return Member
-     */
-    public Member getLocalMember(boolean incAlive) {
-        return this.getMembershipService().getLocalMember(incAlive);
-    }
-
-   
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.group;
+
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.ChannelReceiver;
+import org.apache.catalina.tribes.ChannelSender;
+
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.MembershipService;
+import org.apache.catalina.tribes.MessageListener;
+import org.apache.catalina.tribes.transport.SenderState;
+import org.apache.catalina.tribes.transport.ReplicationTransmitter;
+import org.apache.catalina.tribes.membership.McastService;
+import org.apache.catalina.tribes.transport.nio.NioReceiver;
+import org.apache.catalina.tribes.Channel;
+import org.apache.catalina.tribes.util.Logs;
+import org.apache.catalina.tribes.UniqueId;
+import org.apache.catalina.tribes.util.Arrays;
+
+
+/**
+ * The channel coordinator object coordinates the membership service,
+ * the sender and the receiver.
+ * This is the last interceptor in the chain.
+ * @author Filip Hanik
+ * @version $Revision$, $Date$
+ */
+public class ChannelCoordinator extends ChannelInterceptorBase implements MessageListener {
+    private ChannelReceiver clusterReceiver = new NioReceiver();
+    private ChannelSender clusterSender = new ReplicationTransmitter();
+    private MembershipService membershipService = new McastService();
+    
+    //override optionflag
+    protected int optionFlag = Channel.SEND_OPTIONS_BYTE_MESSAGE|Channel.SEND_OPTIONS_USE_ACK|Channel.SEND_OPTIONS_SYNCHRONIZED_ACK;
+    public int getOptionFlag() {return optionFlag;}
+    public void setOptionFlag(int flag) {optionFlag=flag;}
+    
+    private int startLevel = 0;
+
+    public ChannelCoordinator() {
+        
+    }
+    
+    public ChannelCoordinator(ChannelReceiver receiver,
+                              ChannelSender sender,
+                              MembershipService service) {
+        this();
+        this.setClusterReceiver(receiver);
+        this.setClusterSender(sender);
+        this.setMembershipService(service);
+    }
+    
+    /**
+     * Send a message to one or more members in the cluster
+     * @param destination Member[] - the destinations, null or zero length means all
+     * @param msg ClusterMessage - the message to send
+     * @param options int - sender options, see class documentation
+     * @return ClusterMessage[] - the replies from the members, if any.
+     */
+    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
+        if ( destination == null ) destination = membershipService.getMembers();
+        clusterSender.sendMessage(msg,destination);
+        if ( Logs.MESSAGES.isTraceEnabled() ) {
+            Logs.MESSAGES.trace("ChannelCoordinator - Sent msg:" + new UniqueId(msg.getUniqueId()) + " at " +new java.sql.Timestamp(System.currentTimeMillis())+ " to "+Arrays.toNameString(destination));
+        }
+    }
+    
+
+    /**
+     * Starts up the channel. This can be called multiple times for individual services to start
+     * The svc parameter can be the logical or value of any constants
+     * @param svc int value of <BR>
+     * DEFAULT - will start all services <BR>
+     * MBR_RX_SEQ - starts the membership receiver <BR>
+     * MBR_TX_SEQ - starts the membership broadcaster <BR>
+     * SND_TX_SEQ - starts the replication transmitter<BR>
+     * SND_RX_SEQ - starts the replication receiver<BR>
+     * @throws ChannelException if a startup error occurs or the service is already started.
+     */
+    public void start(int svc) throws ChannelException {
+        this.internalStart(svc);
+    }
+
+    /**
+     * Shuts down the channel. This can be called multiple times for individual services to shutdown
+     * The svc parameter can be the logical or value of any constants
+     * @param svc int value of <BR>
+     * DEFAULT - will shutdown all services <BR>
+     * MBR_RX_SEQ - stops the membership receiver <BR>
+     * MBR_TX_SEQ - stops the membership broadcaster <BR>
+     * SND_TX_SEQ - stops the replication transmitter<BR>
+     * SND_RX_SEQ - stops the replication receiver<BR>
+     * @throws ChannelException if a startup error occurs or the service is already started.
+     */
+    public void stop(int svc) throws ChannelException {
+        this.internalStop(svc);
+    }    
+
+
+    /**
+     * Starts up the channel. This can be called multiple times for individual services to start
+     * The svc parameter can be the logical or value of any constants
+     * @param svc int value of <BR>
+     * DEFAULT - will start all services <BR>
+     * MBR_RX_SEQ - starts the membership receiver <BR>
+     * MBR_TX_SEQ - starts the membership broadcaster <BR>
+     * SND_TX_SEQ - starts the replication transmitter<BR>
+     * SND_RX_SEQ - starts the replication receiver<BR>
+     * @throws ChannelException if a startup error occurs or the service is already started.
+     */
+    protected synchronized void internalStart(int svc) throws ChannelException {
+        try {
+            boolean valid = false;
+            //make sure we don't pass down any flags that are unrelated to the bottom layer
+            svc = svc & Channel.DEFAULT;
+
+            if (startLevel == Channel.DEFAULT) return; //we have already started up all components
+            if (svc == 0 ) return;//nothing to start
+            
+            if (svc == (svc & startLevel)) throw new ChannelException("Channel already started for level:"+svc);
+
+            //must start the receiver first so that we can coordinate the port it
+            //listens to with the local membership settings
+            if ( Channel.SND_RX_SEQ==(svc & Channel.SND_RX_SEQ) ) {
+                clusterReceiver.setMessageListener(this);
+                clusterReceiver.start();
+                //synchronize, big time FIXME
+                membershipService.setLocalMemberProperties(getClusterReceiver().getHost(), getClusterReceiver().getPort());
+                valid = true;
+            }
+            if ( Channel.SND_TX_SEQ==(svc & Channel.SND_TX_SEQ) ) {
+                clusterSender.start();
+                valid = true;
+            }
+            
+            if ( Channel.MBR_RX_SEQ==(svc & Channel.MBR_RX_SEQ) ) {
+                membershipService.setMembershipListener(this);
+                membershipService.start(MembershipService.MBR_RX);
+                valid = true;
+            }
+            if ( Channel.MBR_TX_SEQ==(svc & Channel.MBR_TX_SEQ) ) {
+                membershipService.start(MembershipService.MBR_TX);
+                valid = true;
+            }
+            
+            if ( !valid) {
+                throw new IllegalArgumentException("Invalid start level, valid levels are:SND_RX_SEQ,SND_TX_SEQ,MBR_TX_SEQ,MBR_RX_SEQ");
+            }
+            startLevel = (startLevel | svc);
+        }catch ( ChannelException cx ) {
+            throw cx;
+        }catch ( Exception x ) {
+            throw new ChannelException(x);
+        }
+    }
+
+    /**
+     * Shuts down the channel. This can be called multiple times for individual services to shutdown
+     * The svc parameter can be the logical or value of any constants
+     * @param svc int value of <BR>
+     * DEFAULT - will shutdown all services <BR>
+     * MBR_RX_SEQ - starts the membership receiver <BR>
+     * MBR_TX_SEQ - starts the membership broadcaster <BR>
+     * SND_TX_SEQ - starts the replication transmitter<BR>
+     * SND_RX_SEQ - starts the replication receiver<BR>
+     * @throws ChannelException if a startup error occurs or the service is already started.
+     */
+    protected synchronized void internalStop(int svc) throws ChannelException {
+        try {
+            //make sure we don't pass down any flags that are unrelated to the bottom layer
+            svc = svc & Channel.DEFAULT;
+
+            if (startLevel == 0) return; //we have already stopped up all components
+            if (svc == 0 ) return;//nothing to stop
+
+            boolean valid = false;
+            if ( Channel.SND_RX_SEQ==(svc & Channel.SND_RX_SEQ) ) {
+                clusterReceiver.stop();
+                clusterReceiver.setMessageListener(null);
+                valid = true;
+            }
+            if ( Channel.SND_TX_SEQ==(svc & Channel.SND_TX_SEQ) ) {
+                clusterSender.stop();
+                valid = true;
+            }
+
+            if ( Channel.MBR_RX_SEQ==(svc & Channel.MBR_RX_SEQ) ) {
+                membershipService.stop(MembershipService.MBR_RX);
+                membershipService.setMembershipListener(null);
+                valid = true;
+                
+            }
+            if ( Channel.MBR_TX_SEQ==(svc & Channel.MBR_TX_SEQ) ) {
+                valid = true;
+                membershipService.stop(MembershipService.MBR_TX);
+            }            
+            if ( !valid) {
+                throw new IllegalArgumentException("Invalid start level, valid levels are:SND_RX_SEQ,SND_TX_SEQ,MBR_TX_SEQ,MBR_RX_SEQ");
+            }
+
+            startLevel = (startLevel & (~svc));
+            
+        }catch ( Exception x ) {
+            throw new ChannelException(x);
+        } finally {
+            
+        }
+
+    }
+    
+    public void memberAdded(Member member){
+        SenderState.getSenderState(member);
+        if ( clusterSender!=null ) clusterSender.add(member);
+        super.memberAdded(member);
+    }
+    
+    public void memberDisappeared(Member member){
+        SenderState.removeSenderState(member);
+        if ( clusterSender!=null ) clusterSender.remove(member);
+        super.memberDisappeared(member);
+    }
+    
+    public void messageReceived(ChannelMessage msg) {
+        if ( Logs.MESSAGES.isTraceEnabled() ) {
+            Logs.MESSAGES.trace("ChannelCoordinator - Received msg:" + new UniqueId(msg.getUniqueId()) + " at " +new java.sql.Timestamp(System.currentTimeMillis())+ " from "+msg.getAddress().getName());
+        }
+        super.messageReceived(msg);
+    }
+
+
+    public ChannelReceiver getClusterReceiver() {
+        return clusterReceiver;
+    }
+
+    public ChannelSender getClusterSender() {
+        return clusterSender;
+    }
+
+    public MembershipService getMembershipService() {
+        return membershipService;
+    }
+
+    public void setClusterReceiver(ChannelReceiver clusterReceiver) {
+        if ( clusterReceiver != null ) {
+            this.clusterReceiver = clusterReceiver;
+            this.clusterReceiver.setMessageListener(this);
+        } else {
+            if  (this.clusterReceiver!=null ) this.clusterReceiver.setMessageListener(null);
+            this.clusterReceiver = null;
+        }
+    }
+
+    public void setClusterSender(ChannelSender clusterSender) {
+        this.clusterSender = clusterSender;
+    }
+
+    public void setMembershipService(MembershipService membershipService) {
+        this.membershipService = membershipService;
+        this.membershipService.setMembershipListener(this);
+    }
+    
+    public void hearbeat() {
+        if ( clusterSender!=null ) clusterSender.heartbeat();
+        super.heartbeat();
+    }
+    
+    /**
+     * has members
+     */
+    public boolean hasMembers() {
+        return this.getMembershipService().hasMembers();
+    }
+
+    /**
+     * Get all current cluster members
+     * @return all members or empty array
+     */
+    public Member[] getMembers() {
+        return this.getMembershipService().getMembers();
+    }
+
+    /**
+     * 
+     * @param mbr Member
+     * @return Member
+     */
+    public Member getMember(Member mbr){
+        return this.getMembershipService().getMember(mbr);
+    }
+
+
+    /**
+     * Return the member that represents this node.
+     *
+     * @return Member
+     */
+    public Member getLocalMember(boolean incAlive) {
+        return this.getMembershipService().getLocalMember(incAlive);
+    }
+
+   
+}

==================================================
GroupChannel.java
index 3c1b6d63c3..53596664a2 100644
--- a/java/org/apache/catalina/tribes/group/ChannelInterceptorBase.java
+++ b/java/org/apache/catalina/tribes/group/ChannelInterceptorBase.java
@@ -1,172 +1,172 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.group;
-
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelInterceptor;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.Member;
-
-/**
- * Abstract class for the interceptor base class.
- * @author Filip Hanik
- * @version $Revision: 304032 $, $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
- */
-
-public abstract class ChannelInterceptorBase implements ChannelInterceptor {
-
-    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(
-        ChannelInterceptorBase.class);
-
-    private ChannelInterceptor next;
-    private ChannelInterceptor previous;
-    //default value, always process
-    protected int optionFlag = 0;
-
-    public ChannelInterceptorBase() {
-
-    }
-    
-    public boolean okToProcess(int messageFlags) { 
-        if (this.optionFlag == 0 ) return true;
-        return ((optionFlag&messageFlags) == optionFlag);
-    }
-
-    public final void setNext(ChannelInterceptor next) {
-        this.next = next;
-    }
-
-    public final ChannelInterceptor getNext() {
-        return next;
-    }
-
-    public final void setPrevious(ChannelInterceptor previous) {
-        this.previous = previous;
-    }
-
-    public void setOptionFlag(int optionFlag) {
-        this.optionFlag = optionFlag;
-    }
-
-    public final ChannelInterceptor getPrevious() {
-        return previous;
-    }
-
-    public int getOptionFlag() {
-        return optionFlag;
-    }
-
-    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws
-        ChannelException {
-        if (getNext() != null) getNext().sendMessage(destination, msg, payload);
-    }
-
-    public void messageReceived(ChannelMessage msg) {
-        if (getPrevious() != null) getPrevious().messageReceived(msg);
-    }
-
-    public boolean accept(ChannelMessage msg) {
-        return true;
-    }
-
-    public void memberAdded(Member member) {
-        //notify upwards
-        if (getPrevious() != null) getPrevious().memberAdded(member);
-    }
-
-    public void memberDisappeared(Member member) {
-        //notify upwards
-        if (getPrevious() != null) getPrevious().memberDisappeared(member);
-    }
-
-    public void heartbeat() {
-        if (getNext() != null) getNext().heartbeat();
-    }
-
-    /**
-     * has members
-     */
-    public boolean hasMembers() {
-        if ( getNext()!=null )return getNext().hasMembers();
-        else return false;
-    }
-
-    /**
-     * Get all current cluster members
-     * @return all members or empty array
-     */
-    public Member[] getMembers() {
-        if ( getNext()!=null ) return getNext().getMembers();
-        else return null;
-    }
-
-    /**
-     *
-     * @param mbr Member
-     * @return Member
-     */
-    public Member getMember(Member mbr) {
-        if ( getNext()!=null) return getNext().getMember(mbr);
-        else return null;
-    }
-
-    /**
-     * Return the member that represents this node.
-     *
-     * @return Member
-     */
-    public Member getLocalMember(boolean incAlive) {
-        if ( getNext()!=null ) return getNext().getLocalMember(incAlive);
-        else return null;
-    }
-    
-    /**
-     * Starts up the channel. This can be called multiple times for individual services to start
-     * The svc parameter can be the logical or value of any constants
-     * @param svc int value of <BR>
-     * DEFAULT - will start all services <BR>
-     * MBR_RX_SEQ - starts the membership receiver <BR>
-     * MBR_TX_SEQ - starts the membership broadcaster <BR>
-     * SND_TX_SEQ - starts the replication transmitter<BR>
-     * SND_RX_SEQ - starts the replication receiver<BR>
-     * @throws ChannelException if a startup error occurs or the service is already started.
-     */
-    public void start(int svc) throws ChannelException {
-        if ( getNext()!=null ) getNext().start(svc);
-    }
-
-    /**
-     * Shuts down the channel. This can be called multiple times for individual services to shutdown
-     * The svc parameter can be the logical or value of any constants
-     * @param svc int value of <BR>
-     * DEFAULT - will shutdown all services <BR>
-     * MBR_RX_SEQ - stops the membership receiver <BR>
-     * MBR_TX_SEQ - stops the membership broadcaster <BR>
-     * SND_TX_SEQ - stops the replication transmitter<BR>
-     * SND_RX_SEQ - stops the replication receiver<BR>
-     * @throws ChannelException if a startup error occurs or the service is already started.
-     */
-    public void stop(int svc) throws ChannelException {
-        if (getNext() != null) getNext().stop(svc);
-    }
-    
-    public void fireInterceptorEvent(InterceptorEvent event) {
-        //empty operation
-    }
-
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.group;
+
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelInterceptor;
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.Member;
+
+/**
+ * Abstract class for the interceptor base class.
+ * @author Filip Hanik
+ * @version $Revision$, $Date$
+ */
+
+public abstract class ChannelInterceptorBase implements ChannelInterceptor {
+
+    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(
+        ChannelInterceptorBase.class);
+
+    private ChannelInterceptor next;
+    private ChannelInterceptor previous;
+    //default value, always process
+    protected int optionFlag = 0;
+
+    public ChannelInterceptorBase() {
+
+    }
+    
+    public boolean okToProcess(int messageFlags) { 
+        if (this.optionFlag == 0 ) return true;
+        return ((optionFlag&messageFlags) == optionFlag);
+    }
+
+    public final void setNext(ChannelInterceptor next) {
+        this.next = next;
+    }
+
+    public final ChannelInterceptor getNext() {
+        return next;
+    }
+
+    public final void setPrevious(ChannelInterceptor previous) {
+        this.previous = previous;
+    }
+
+    public void setOptionFlag(int optionFlag) {
+        this.optionFlag = optionFlag;
+    }
+
+    public final ChannelInterceptor getPrevious() {
+        return previous;
+    }
+
+    public int getOptionFlag() {
+        return optionFlag;
+    }
+
+    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws
+        ChannelException {
+        if (getNext() != null) getNext().sendMessage(destination, msg, payload);
+    }
+
+    public void messageReceived(ChannelMessage msg) {
+        if (getPrevious() != null) getPrevious().messageReceived(msg);
+    }
+
+    public boolean accept(ChannelMessage msg) {
+        return true;
+    }
+
+    public void memberAdded(Member member) {
+        //notify upwards
+        if (getPrevious() != null) getPrevious().memberAdded(member);
+    }
+
+    public void memberDisappeared(Member member) {
+        //notify upwards
+        if (getPrevious() != null) getPrevious().memberDisappeared(member);
+    }
+
+    public void heartbeat() {
+        if (getNext() != null) getNext().heartbeat();
+    }
+
+    /**
+     * has members
+     */
+    public boolean hasMembers() {
+        if ( getNext()!=null )return getNext().hasMembers();
+        else return false;
+    }
+
+    /**
+     * Get all current cluster members
+     * @return all members or empty array
+     */
+    public Member[] getMembers() {
+        if ( getNext()!=null ) return getNext().getMembers();
+        else return null;
+    }
+
+    /**
+     *
+     * @param mbr Member
+     * @return Member
+     */
+    public Member getMember(Member mbr) {
+        if ( getNext()!=null) return getNext().getMember(mbr);
+        else return null;
+    }
+
+    /**
+     * Return the member that represents this node.
+     *
+     * @return Member
+     */
+    public Member getLocalMember(boolean incAlive) {
+        if ( getNext()!=null ) return getNext().getLocalMember(incAlive);
+        else return null;
+    }
+    
+    /**
+     * Starts up the channel. This can be called multiple times for individual services to start
+     * The svc parameter can be the logical or value of any constants
+     * @param svc int value of <BR>
+     * DEFAULT - will start all services <BR>
+     * MBR_RX_SEQ - starts the membership receiver <BR>
+     * MBR_TX_SEQ - starts the membership broadcaster <BR>
+     * SND_TX_SEQ - starts the replication transmitter<BR>
+     * SND_RX_SEQ - starts the replication receiver<BR>
+     * @throws ChannelException if a startup error occurs or the service is already started.
+     */
+    public void start(int svc) throws ChannelException {
+        if ( getNext()!=null ) getNext().start(svc);
+    }
+
+    /**
+     * Shuts down the channel. This can be called multiple times for individual services to shutdown
+     * The svc parameter can be the logical or value of any constants
+     * @param svc int value of <BR>
+     * DEFAULT - will shutdown all services <BR>
+     * MBR_RX_SEQ - stops the membership receiver <BR>
+     * MBR_TX_SEQ - stops the membership broadcaster <BR>
+     * SND_TX_SEQ - stops the replication transmitter<BR>
+     * SND_RX_SEQ - stops the replication receiver<BR>
+     * @throws ChannelException if a startup error occurs or the service is already started.
+     */
+    public void stop(int svc) throws ChannelException {
+        if (getNext() != null) getNext().stop(svc);
+    }
+    
+    public void fireInterceptorEvent(InterceptorEvent event) {
+        //empty operation
+    }
+
+
+}

==================================================
InterceptorPayload.java
index c12529e44c..251f13a838 100644
--- a/java/org/apache/catalina/tribes/group/GroupChannel.java
+++ b/java/org/apache/catalina/tribes/group/GroupChannel.java
@@ -1,667 +1,667 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.group;
-
-
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.Iterator;
-
-import org.apache.catalina.tribes.ByteMessage;
-import org.apache.catalina.tribes.Channel;
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelInterceptor;
-import org.apache.catalina.tribes.ChannelListener;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.ChannelReceiver;
-import org.apache.catalina.tribes.ChannelSender;
-import org.apache.catalina.tribes.ErrorHandler;
-import org.apache.catalina.tribes.ManagedChannel;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.MembershipListener;
-import org.apache.catalina.tribes.MembershipService;
-import org.apache.catalina.tribes.group.interceptors.MessageDispatchInterceptor;
-import org.apache.catalina.tribes.io.ChannelData;
-import org.apache.catalina.tribes.io.XByteBuffer;
-import org.apache.catalina.tribes.UniqueId;
-import org.apache.catalina.tribes.Heartbeat;
-import org.apache.catalina.tribes.io.BufferPool;
-import java.io.IOException;
-import org.apache.catalina.tribes.RemoteProcessException;
-import org.apache.catalina.tribes.util.Logs;
-import org.apache.catalina.tribes.util.Arrays;
-
-/**
- * The default implementation of a Channel.<br>
- * The GroupChannel manages the replication channel. It coordinates
- * message being sent and received with membership announcements.
- * The channel has an chain of interceptors that can modify the message or perform other logic.<br>
- * It manages a complete group, both membership and replication.
- * @author Filip Hanik
- * @version $Revision: 304032 $, $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
- */
-public class GroupChannel extends ChannelInterceptorBase implements ManagedChannel {
-    /**
-     * Flag to determine if the channel manages its own heartbeat
-     * If set to true, the channel will start a local thread for the heart beat.
-     */
-    protected boolean heartbeat = true;
-    /**
-     * If <code>heartbeat == true</code> then how often do we want this
-     * heartbeat to run. default is one minute
-     */
-    protected long heartbeatSleeptime = 5*1000;//every 5 seconds
-
-    /**
-     * Internal heartbeat thread
-     */
-    protected HeartbeatThread hbthread = null;
-
-    /**
-     * The  <code>ChannelCoordinator</code> coordinates the bottom layer components:<br>
-     * - MembershipService<br>
-     * - ChannelSender <br>
-     * - ChannelReceiver<br>
-     */
-    protected ChannelCoordinator coordinator = new ChannelCoordinator();
-
-    /**
-     * The first interceptor in the inteceptor stack.
-     * The interceptors are chained in a linked list, so we only need a reference to the
-     * first one
-     */
-    protected ChannelInterceptor interceptors = null;
-
-    /**
-     * A list of membership listeners that subscribe to membership announcements
-     */
-    protected ArrayList membershipListeners = new ArrayList();
-
-    /**
-     * A list of channel listeners that subscribe to incoming messages
-     */
-    protected ArrayList channelListeners = new ArrayList();
-
-    /**
-     * If set to true, the GroupChannel will check to make sure that
-     */
-    protected boolean optionCheck = false;
-
-    /**
-     * Creates a GroupChannel. This constructor will also
-     * add the first interceptor in the GroupChannel.<br>
-     * The first interceptor is always the channel itself.
-     */
-    public GroupChannel() {
-        addInterceptor(this);
-    }
-
-
-    /**
-     * Adds an interceptor to the stack for message processing<br>
-     * Interceptors are ordered in the way they are added.<br>
-     * <code>channel.addInterceptor(A);</code><br>
-     * <code>channel.addInterceptor(C);</code><br>
-     * <code>channel.addInterceptor(B);</code><br>
-     * Will result in a interceptor stack like this:<br>
-     * <code>A -> C -> B</code><br>
-     * The complete stack will look like this:<br>
-     * <code>Channel -> A -> C -> B -> ChannelCoordinator</code><br>
-     * @param interceptor ChannelInterceptorBase
-     */
-    public void addInterceptor(ChannelInterceptor interceptor) {
-        if ( interceptors == null ) {
-            interceptors = interceptor;
-            interceptors.setNext(coordinator);
-            interceptors.setPrevious(null);
-            coordinator.setPrevious(interceptors);
-        } else {
-            ChannelInterceptor last = interceptors;
-            while ( last.getNext() != coordinator ) {
-                last = last.getNext();
-            }
-            last.setNext(interceptor);
-            interceptor.setNext(coordinator);
-            interceptor.setPrevious(last);
-            coordinator.setPrevious(interceptor);
-        }
-    }
-
-    /**
-     * Sends a heartbeat through the interceptor stack.<br>
-     * Invoke this method from the application on a periodic basis if
-     * you have turned off internal heartbeats <code>channel.setHeartbeat(false)</code>
-     */
-    public void heartbeat() {
-        super.heartbeat();
-        Iterator i = membershipListeners.iterator();
-        while ( i.hasNext() ) {
-            Object o = i.next();
-            if ( o instanceof Heartbeat ) ((Heartbeat)o).heartbeat();
-        }
-        i = channelListeners.iterator();
-        while ( i.hasNext() ) {
-            Object o = i.next();
-            if ( o instanceof Heartbeat ) ((Heartbeat)o).heartbeat();
-        }
-
-    }
-
-
-    /**
-     * Send a message to the destinations specified
-     * @param destination Member[] - destination.length > 1
-     * @param msg Serializable - the message to send
-     * @param options int - sender options, options can trigger guarantee levels and different interceptors to
-     * react to the message see class documentation for the <code>Channel</code> object.<br>
-     * @return UniqueId - the unique Id that was assigned to this message
-     * @throws ChannelException - if an error occurs processing the message
-     * @see org.apache.catalina.tribes.Channel
-     */
-    public UniqueId send(Member[] destination, Serializable msg, int options) throws ChannelException {
-        return send(destination,msg,options,null);
-    }
-
-    /**
-     *
-     * @param destination Member[] - destination.length > 1
-     * @param msg Serializable - the message to send
-     * @param options int - sender options, options can trigger guarantee levels and different interceptors to
-     * react to the message see class documentation for the <code>Channel</code> object.<br>
-     * @param handler - callback object for error handling and completion notification, used when a message is
-     * sent asynchronously using the <code>Channel.SEND_OPTIONS_ASYNCHRONOUS</code> flag enabled.
-     * @return UniqueId - the unique Id that was assigned to this message
-     * @throws ChannelException - if an error occurs processing the message
-     * @see org.apache.catalina.tribes.Channel
-     */
-    public UniqueId send(Member[] destination, Serializable msg, int options, ErrorHandler handler) throws ChannelException {
-        if ( msg == null ) throw new ChannelException("Cant send a NULL message");
-        XByteBuffer buffer = null;
-        try {
-            if ( destination == null || destination.length == 0) throw new ChannelException("No destination given");
-            ChannelData data = new ChannelData(true);//generates a unique Id
-            data.setAddress(getLocalMember(false));
-            data.setTimestamp(System.currentTimeMillis());
-            byte[] b = null;
-            if ( msg instanceof ByteMessage ){
-                b = ((ByteMessage)msg).getMessage();
-                options = options | SEND_OPTIONS_BYTE_MESSAGE;
-            } else {
-                b = XByteBuffer.serialize(msg);
-                options = options & (~SEND_OPTIONS_BYTE_MESSAGE);
-            }
-            data.setOptions(options);
-            //XByteBuffer buffer = new XByteBuffer(b.length+128,false);
-            buffer = BufferPool.getBufferPool().getBuffer(b.length+128, false);
-            buffer.append(b,0,b.length);
-            data.setMessage(buffer);
-            InterceptorPayload payload = null;
-            if ( handler != null ) {
-                payload = new InterceptorPayload();
-                payload.setErrorHandler(handler);
-            }
-            getFirstInterceptor().sendMessage(destination, data, payload);
-            if ( Logs.MESSAGES.isTraceEnabled() ) {
-                Logs.MESSAGES.trace("GroupChannel - Sent msg:" + new UniqueId(data.getUniqueId()) + " at " +new java.sql.Timestamp(System.currentTimeMillis())+ " to "+Arrays.toNameString(destination));
-                Logs.MESSAGES.trace("GroupChannel - Send Message:" + new UniqueId(data.getUniqueId()) + " is " +msg);
-            }
-
-            return new UniqueId(data.getUniqueId());
-        }catch ( Exception x ) {
-            if ( x instanceof ChannelException ) throw (ChannelException)x;
-            throw new ChannelException(x);
-        } finally {
-            if ( buffer != null ) BufferPool.getBufferPool().returnBuffer(buffer);
-        }
-    }
-
-
-    /**
-     * Callback from the interceptor stack. <br>
-     * When a message is received from a remote node, this method will be invoked by
-     * the previous interceptor.<br>
-     * This method can also be used to send a message to other components within the same application,
-     * but its an extreme case, and you're probably better off doing that logic between the applications itself.
-     * @param msg ChannelMessage
-     */
-    public void messageReceived(ChannelMessage msg) {
-        if ( msg == null ) return;
-        try {
-            if ( Logs.MESSAGES.isTraceEnabled() ) {
-                Logs.MESSAGES.trace("GroupChannel - Received msg:" + new UniqueId(msg.getUniqueId()) + " at " +new java.sql.Timestamp(System.currentTimeMillis())+ " from "+msg.getAddress().getName());
-            }
-
-            Serializable fwd = null;
-            if ( (msg.getOptions() & SEND_OPTIONS_BYTE_MESSAGE) == SEND_OPTIONS_BYTE_MESSAGE ) {
-                fwd = new ByteMessage(msg.getMessage().getBytes());
-            } else {
-                fwd = XByteBuffer.deserialize(msg.getMessage().getBytesDirect(),0,msg.getMessage().getLength());
-            }
-            if ( Logs.MESSAGES.isTraceEnabled() ) {
-                Logs.MESSAGES.trace("GroupChannel - Receive Message:" + new UniqueId(msg.getUniqueId()) + " is " +fwd);
-            }
-
-            //get the actual member with the correct alive time
-            Member source = msg.getAddress();
-            boolean rx = false;
-            boolean delivered = false;
-            for ( int i=0; i<channelListeners.size(); i++ ) {
-                ChannelListener channelListener = (ChannelListener)channelListeners.get(i);
-                if (channelListener != null && channelListener.accept(fwd, source)) {
-                    channelListener.messageReceived(fwd, source);
-                    delivered = true;
-                    //if the message was accepted by an RPC channel, that channel
-                    //is responsible for returning the reply, otherwise we send an absence reply
-                    if ( channelListener instanceof RpcChannel ) rx = true;
-                }
-            }//for
-            if ((!rx) && (fwd instanceof RpcMessage)) {
-                //if we have a message that requires a response,
-                //but none was given, send back an immediate one
-                sendNoRpcChannelReply((RpcMessage)fwd,source);
-            }
-            if ( Logs.MESSAGES.isTraceEnabled() ) {
-                Logs.MESSAGES.trace("GroupChannel delivered["+delivered+"] id:"+new UniqueId(msg.getUniqueId()));
-            }
-
-        } catch ( Exception x ) {
-            if ( log.isDebugEnabled() ) log.error("Unable to process channel:IOException.",x);
-            throw new RemoteProcessException("IOException:"+x.getMessage(),x);
-        }
-    }
-
-    /**
-     * Sends a <code>NoRpcChannelReply</code> message to a member<br>
-     * This method gets invoked by the channel if a RPC message comes in
-     * and no channel listener accepts the message. This avoids timeout
-     * @param msg RpcMessage
-     * @param destination Member - the destination for the reply
-     */
-    protected void sendNoRpcChannelReply(RpcMessage msg, Member destination) {
-        try {
-            //avoid circular loop
-            if ( msg instanceof RpcMessage.NoRpcChannelReply) return;
-            RpcMessage.NoRpcChannelReply reply = new RpcMessage.NoRpcChannelReply(msg.rpcId,msg.uuid);
-            send(new Member[]{destination},reply,Channel.SEND_OPTIONS_ASYNCHRONOUS);
-        } catch ( Exception x ) {
-            log.error("Unable to find rpc channel, failed to send NoRpcChannelReply.",x);
-        }
-    }
-
-    /**
-     * memberAdded gets invoked by the interceptor below the channel
-     * and the channel will broadcast it to the membership listeners
-     * @param member Member - the new member
-     */
-    public void memberAdded(Member member) {
-        //notify upwards
-        for (int i=0; i<membershipListeners.size(); i++ ) {
-            MembershipListener membershipListener = (MembershipListener)membershipListeners.get(i);
-            if (membershipListener != null) membershipListener.memberAdded(member);
-        }
-    }
-
-    /**
-     * memberDisappeared gets invoked by the interceptor below the channel
-     * and the channel will broadcast it to the membership listeners
-     * @param member Member - the member that left or crashed
-     */
-    public void memberDisappeared(Member member) {
-        //notify upwards
-        for (int i=0; i<membershipListeners.size(); i++ ) {
-            MembershipListener membershipListener = (MembershipListener)membershipListeners.get(i);
-            if (membershipListener != null) membershipListener.memberDisappeared(member);
-        }
-    }
-
-    /**
-     * Sets up the default implementation interceptor stack
-     * if no interceptors have been added
-     * @throws ChannelException
-     */
-    protected synchronized void setupDefaultStack() throws ChannelException {
-
-        if ( getFirstInterceptor() != null &&
-             ((getFirstInterceptor().getNext() instanceof ChannelCoordinator))) {
-            ChannelInterceptor interceptor = null;
-            Class clazz = null;
-            try {
-                clazz = Class.forName("org.apache.catalina.tribes.group.interceptors.MessageDispatch15Interceptor",
-                                      true,GroupChannel.class.getClassLoader());
-                clazz.newInstance();
-            } catch ( Throwable x ) {
-                clazz = MessageDispatchInterceptor.class;
-            }//catch
-            try {
-                interceptor = (ChannelInterceptor) clazz.newInstance();
-            } catch (Exception x) {
-                throw new ChannelException("Unable to add MessageDispatchInterceptor to interceptor chain.",x);
-            }
-            this.addInterceptor(interceptor);
-        }
-    }
-
-    /**
-     * Validates the option flags that each interceptor is using and reports
-     * an error if two interceptor share the same flag.
-     * @throws ChannelException
-     */
-    protected void checkOptionFlags() throws ChannelException {
-        StringBuffer conflicts = new StringBuffer();
-        ChannelInterceptor first = interceptors;
-        while ( first != null ) {
-            int flag = first.getOptionFlag();
-            if ( flag != 0 ) {
-                ChannelInterceptor next = first.getNext();
-                while ( next != null ) {
-                    int nflag = next.getOptionFlag();
-                    if (nflag!=0 && (((flag & nflag) == flag ) || ((flag & nflag) == nflag)) ) {
-                        conflicts.append("[");
-                        conflicts.append(first.getClass().getName());
-                        conflicts.append(":");
-                        conflicts.append(flag);
-                        conflicts.append(" == ");
-                        conflicts.append(next.getClass().getName());
-                        conflicts.append(":");
-                        conflicts.append(nflag);
-                        conflicts.append("] ");
-                    }//end if
-                    next = next.getNext();
-                }//while
-            }//end if
-            first = first.getNext();
-        }//while
-        if ( conflicts.length() > 0 ) throw new ChannelException("Interceptor option flag conflict: "+conflicts.toString());
-
-    }
-
-    /**
-     * Starts the channel
-     * @param svc int - what service to start
-     * @throws ChannelException
-     * @see org.apache.catalina.tribes.Channel#start(int)
-     */
-    public synchronized void start(int svc) throws ChannelException {
-        setupDefaultStack();
-        if (optionCheck) checkOptionFlags();
-        super.start(svc);
-        if ( hbthread == null && heartbeat ) {
-            hbthread = new HeartbeatThread(this,heartbeatSleeptime);
-            hbthread.start();
-        }
-    }
-
-    /**
-     * Stops the channel
-     * @param svc int
-     * @throws ChannelException
-     * @see org.apache.catalina.tribes.Channel#stop(int)
-     */
-    public synchronized void stop(int svc) throws ChannelException {
-        if (hbthread != null) {
-            hbthread.stopHeartbeat();
-            hbthread = null;
-        }
-        super.stop(svc);
-    }
-
-    /**
-     * Returns the first interceptor of the stack. Useful for traversal.
-     * @return ChannelInterceptor
-     */
-    public ChannelInterceptor getFirstInterceptor() {
-        if (interceptors != null) return interceptors;
-        else return coordinator;
-    }
-
-    /**
-     * Returns the channel receiver component
-     * @return ChannelReceiver
-     */
-    public ChannelReceiver getChannelReceiver() {
-        return coordinator.getClusterReceiver();
-    }
-
-    /**
-     * Returns the channel sender component
-     * @return ChannelSender
-     */
-    public ChannelSender getChannelSender() {
-        return coordinator.getClusterSender();
-    }
-
-    /**
-     * Returns the membership service component
-     * @return MembershipService
-     */
-    public MembershipService getMembershipService() {
-        return coordinator.getMembershipService();
-    }
-
-    /**
-     * Sets the channel receiver component
-     * @param clusterReceiver ChannelReceiver
-     */
-    public void setChannelReceiver(ChannelReceiver clusterReceiver) {
-        coordinator.setClusterReceiver(clusterReceiver);
-    }
-
-    /**
-     * Sets the channel sender component
-     * @param clusterSender ChannelSender
-     */
-    public void setChannelSender(ChannelSender clusterSender) {
-        coordinator.setClusterSender(clusterSender);
-    }
-
-    /**
-     * Sets the membership component
-     * @param membershipService MembershipService
-     */
-    public void setMembershipService(MembershipService membershipService) {
-        coordinator.setMembershipService(membershipService);
-    }
-
-    /**
-     * Adds a membership listener to the channel.<br>
-     * Membership listeners are uniquely identified using the equals(Object) method
-     * @param membershipListener MembershipListener
-     */
-    public void addMembershipListener(MembershipListener membershipListener) {
-        if (!this.membershipListeners.contains(membershipListener) )
-            this.membershipListeners.add(membershipListener);
-    }
-
-    /**
-     * Removes a membership listener from the channel.<br>
-     * Membership listeners are uniquely identified using the equals(Object) method
-     * @param membershipListener MembershipListener
-     */
-
-    public void removeMembershipListener(MembershipListener membershipListener) {
-        membershipListeners.remove(membershipListener);
-    }
-
-    /**
-     * Adds a channel listener to the channel.<br>
-     * Channel listeners are uniquely identified using the equals(Object) method
-     * @param channelListener ChannelListener
-     */
-    public void addChannelListener(ChannelListener channelListener) {
-        if (!this.channelListeners.contains(channelListener) ) {
-            this.channelListeners.add(channelListener);
-        } else {
-            throw new IllegalArgumentException("Listener already exists:"+channelListener+"["+channelListener.getClass().getName()+"]");
-        }
-    }
-
-    /**
-     *
-     * Removes a channel listener from the channel.<br>
-     * Channel listeners are uniquely identified using the equals(Object) method
-     * @param channelListener ChannelListener
-     */
-    public void removeChannelListener(ChannelListener channelListener) {
-        channelListeners.remove(channelListener);
-    }
-
-    /**
-     * Returns an iterator of all the interceptors in this stack
-     * @return Iterator
-     */
-    public Iterator getInterceptors() {
-        return new InterceptorIterator(this.getNext(),this.coordinator);
-    }
-
-    /**
-     * Enables/disables the option check<br>
-     * Setting this to true, will make the GroupChannel perform a conflict check
-     * on the interceptors. If two interceptors are using the same option flag
-     * and throw an error upon start.
-     * @param optionCheck boolean
-     */
-    public void setOptionCheck(boolean optionCheck) {
-        this.optionCheck = optionCheck;
-    }
-
-    /**
-     * Configure local heartbeat sleep time<br>
-     * Only used when <code>getHeartbeat()==true</code>
-     * @param heartbeatSleeptime long - time in milliseconds to sleep between heartbeats
-     */
-    public void setHeartbeatSleeptime(long heartbeatSleeptime) {
-        this.heartbeatSleeptime = heartbeatSleeptime;
-    }
-
-    /**
-     * Enables or disables local heartbeat.
-     * if <code>setHeartbeat(true)</code> is invoked then the channel will start an internal
-     * thread to invoke <code>Channel.heartbeat()</code> every <code>getHeartbeatSleeptime</code> milliseconds
-     * @param heartbeat boolean
-     */
-    public void setHeartbeat(boolean heartbeat) {
-        this.heartbeat = heartbeat;
-    }
-
-    /**
-     * @see #setOptionCheck(boolean)
-     * @return boolean
-     */
-    public boolean getOptionCheck() {
-        return optionCheck;
-    }
-
-    /**
-     * @see #setHeartbeat(boolean)
-     * @return boolean
-     */
-    public boolean getHeartbeat() {
-        return heartbeat;
-    }
-
-    /**
-     * Returns the sleep time in milliseconds that the internal heartbeat will
-     * sleep in between invokations of <code>Channel.heartbeat()</code>
-     * @return long
-     */
-    public long getHeartbeatSleeptime() {
-        return heartbeatSleeptime;
-    }
-
-    /**
-     *
-     * <p>Title: Interceptor Iterator</p>
-     *
-     * <p>Description: An iterator to loop through the interceptors in a channel</p>
-     *
-     * @version 1.0
-     */
-    public static class InterceptorIterator implements Iterator {
-        private ChannelInterceptor end;
-        private ChannelInterceptor start;
-        public InterceptorIterator(ChannelInterceptor start, ChannelInterceptor end) {
-            this.end = end;
-            this.start = start;
-        }
-
-        public boolean hasNext() {
-            return start!=null && start != end;
-        }
-
-        public Object next() {
-            Object result = null;
-            if ( hasNext() ) {
-                result = start;
-                start = start.getNext();
-            }
-            return result;
-        }
-
-        public void remove() {
-            //empty operation
-        }
-    }
-
-    /**
-     *
-     * <p>Title: Internal heartbeat thread</p>
-     *
-     * <p>Description: if <code>Channel.getHeartbeat()==true</code> then a thread of this class
-     * is created</p>
-     *
-     * @version 1.0
-     */
-    public static class HeartbeatThread extends Thread {
-        protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(HeartbeatThread.class);
-        protected static int counter = 1;
-        protected static synchronized int inc() {
-            return counter++;
-        }
-
-        protected boolean doRun = true;
-        protected GroupChannel channel;
-        protected long sleepTime;
-        public HeartbeatThread(GroupChannel channel, long sleepTime) {
-            super();
-            this.setPriority(MIN_PRIORITY);
-            setName("GroupChannel-Heartbeat-"+inc());
-            setDaemon(true);
-            this.channel = channel;
-            this.sleepTime = sleepTime;
-        }
-        public void stopHeartbeat() {
-            doRun = false;
-            interrupt();
-        }
-
-        public void run() {
-            while (doRun) {
-                try {
-                    Thread.sleep(sleepTime);
-                    channel.heartbeat();
-                } catch ( InterruptedException x ) {
-                    interrupted();
-                } catch ( Exception x ) {
-                    log.error("Unable to send heartbeat through Tribes interceptor stack. Will try to sleep again.",x);
-                }//catch
-            }//while
-        }//run
-    }//HeartbeatThread
-
-
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.group;
+
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Iterator;
+
+import org.apache.catalina.tribes.ByteMessage;
+import org.apache.catalina.tribes.Channel;
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelInterceptor;
+import org.apache.catalina.tribes.ChannelListener;
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.ChannelReceiver;
+import org.apache.catalina.tribes.ChannelSender;
+import org.apache.catalina.tribes.ErrorHandler;
+import org.apache.catalina.tribes.ManagedChannel;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.MembershipListener;
+import org.apache.catalina.tribes.MembershipService;
+import org.apache.catalina.tribes.group.interceptors.MessageDispatchInterceptor;
+import org.apache.catalina.tribes.io.ChannelData;
+import org.apache.catalina.tribes.io.XByteBuffer;
+import org.apache.catalina.tribes.UniqueId;
+import org.apache.catalina.tribes.Heartbeat;
+import org.apache.catalina.tribes.io.BufferPool;
+import java.io.IOException;
+import org.apache.catalina.tribes.RemoteProcessException;
+import org.apache.catalina.tribes.util.Logs;
+import org.apache.catalina.tribes.util.Arrays;
+
+/**
+ * The default implementation of a Channel.<br>
+ * The GroupChannel manages the replication channel. It coordinates
+ * message being sent and received with membership announcements.
+ * The channel has an chain of interceptors that can modify the message or perform other logic.<br>
+ * It manages a complete group, both membership and replication.
+ * @author Filip Hanik
+ * @version $Revision$, $Date$
+ */
+public class GroupChannel extends ChannelInterceptorBase implements ManagedChannel {
+    /**
+     * Flag to determine if the channel manages its own heartbeat
+     * If set to true, the channel will start a local thread for the heart beat.
+     */
+    protected boolean heartbeat = true;
+    /**
+     * If <code>heartbeat == true</code> then how often do we want this
+     * heartbeat to run. default is one minute
+     */
+    protected long heartbeatSleeptime = 5*1000;//every 5 seconds
+
+    /**
+     * Internal heartbeat thread
+     */
+    protected HeartbeatThread hbthread = null;
+
+    /**
+     * The  <code>ChannelCoordinator</code> coordinates the bottom layer components:<br>
+     * - MembershipService<br>
+     * - ChannelSender <br>
+     * - ChannelReceiver<br>
+     */
+    protected ChannelCoordinator coordinator = new ChannelCoordinator();
+
+    /**
+     * The first interceptor in the inteceptor stack.
+     * The interceptors are chained in a linked list, so we only need a reference to the
+     * first one
+     */
+    protected ChannelInterceptor interceptors = null;
+
+    /**
+     * A list of membership listeners that subscribe to membership announcements
+     */
+    protected ArrayList membershipListeners = new ArrayList();
+
+    /**
+     * A list of channel listeners that subscribe to incoming messages
+     */
+    protected ArrayList channelListeners = new ArrayList();
+
+    /**
+     * If set to true, the GroupChannel will check to make sure that
+     */
+    protected boolean optionCheck = false;
+
+    /**
+     * Creates a GroupChannel. This constructor will also
+     * add the first interceptor in the GroupChannel.<br>
+     * The first interceptor is always the channel itself.
+     */
+    public GroupChannel() {
+        addInterceptor(this);
+    }
+
+
+    /**
+     * Adds an interceptor to the stack for message processing<br>
+     * Interceptors are ordered in the way they are added.<br>
+     * <code>channel.addInterceptor(A);</code><br>
+     * <code>channel.addInterceptor(C);</code><br>
+     * <code>channel.addInterceptor(B);</code><br>
+     * Will result in a interceptor stack like this:<br>
+     * <code>A -> C -> B</code><br>
+     * The complete stack will look like this:<br>
+     * <code>Channel -> A -> C -> B -> ChannelCoordinator</code><br>
+     * @param interceptor ChannelInterceptorBase
+     */
+    public void addInterceptor(ChannelInterceptor interceptor) {
+        if ( interceptors == null ) {
+            interceptors = interceptor;
+            interceptors.setNext(coordinator);
+            interceptors.setPrevious(null);
+            coordinator.setPrevious(interceptors);
+        } else {
+            ChannelInterceptor last = interceptors;
+            while ( last.getNext() != coordinator ) {
+                last = last.getNext();
+            }
+            last.setNext(interceptor);
+            interceptor.setNext(coordinator);
+            interceptor.setPrevious(last);
+            coordinator.setPrevious(interceptor);
+        }
+    }
+
+    /**
+     * Sends a heartbeat through the interceptor stack.<br>
+     * Invoke this method from the application on a periodic basis if
+     * you have turned off internal heartbeats <code>channel.setHeartbeat(false)</code>
+     */
+    public void heartbeat() {
+        super.heartbeat();
+        Iterator i = membershipListeners.iterator();
+        while ( i.hasNext() ) {
+            Object o = i.next();
+            if ( o instanceof Heartbeat ) ((Heartbeat)o).heartbeat();
+        }
+        i = channelListeners.iterator();
+        while ( i.hasNext() ) {
+            Object o = i.next();
+            if ( o instanceof Heartbeat ) ((Heartbeat)o).heartbeat();
+        }
+
+    }
+
+
+    /**
+     * Send a message to the destinations specified
+     * @param destination Member[] - destination.length > 1
+     * @param msg Serializable - the message to send
+     * @param options int - sender options, options can trigger guarantee levels and different interceptors to
+     * react to the message see class documentation for the <code>Channel</code> object.<br>
+     * @return UniqueId - the unique Id that was assigned to this message
+     * @throws ChannelException - if an error occurs processing the message
+     * @see org.apache.catalina.tribes.Channel
+     */
+    public UniqueId send(Member[] destination, Serializable msg, int options) throws ChannelException {
+        return send(destination,msg,options,null);
+    }
+
+    /**
+     *
+     * @param destination Member[] - destination.length > 1
+     * @param msg Serializable - the message to send
+     * @param options int - sender options, options can trigger guarantee levels and different interceptors to
+     * react to the message see class documentation for the <code>Channel</code> object.<br>
+     * @param handler - callback object for error handling and completion notification, used when a message is
+     * sent asynchronously using the <code>Channel.SEND_OPTIONS_ASYNCHRONOUS</code> flag enabled.
+     * @return UniqueId - the unique Id that was assigned to this message
+     * @throws ChannelException - if an error occurs processing the message
+     * @see org.apache.catalina.tribes.Channel
+     */
+    public UniqueId send(Member[] destination, Serializable msg, int options, ErrorHandler handler) throws ChannelException {
+        if ( msg == null ) throw new ChannelException("Cant send a NULL message");
+        XByteBuffer buffer = null;
+        try {
+            if ( destination == null || destination.length == 0) throw new ChannelException("No destination given");
+            ChannelData data = new ChannelData(true);//generates a unique Id
+            data.setAddress(getLocalMember(false));
+            data.setTimestamp(System.currentTimeMillis());
+            byte[] b = null;
+            if ( msg instanceof ByteMessage ){
+                b = ((ByteMessage)msg).getMessage();
+                options = options | SEND_OPTIONS_BYTE_MESSAGE;
+            } else {
+                b = XByteBuffer.serialize(msg);
+                options = options & (~SEND_OPTIONS_BYTE_MESSAGE);
+            }
+            data.setOptions(options);
+            //XByteBuffer buffer = new XByteBuffer(b.length+128,false);
+            buffer = BufferPool.getBufferPool().getBuffer(b.length+128, false);
+            buffer.append(b,0,b.length);
+            data.setMessage(buffer);
+            InterceptorPayload payload = null;
+            if ( handler != null ) {
+                payload = new InterceptorPayload();
+                payload.setErrorHandler(handler);
+            }
+            getFirstInterceptor().sendMessage(destination, data, payload);
+            if ( Logs.MESSAGES.isTraceEnabled() ) {
+                Logs.MESSAGES.trace("GroupChannel - Sent msg:" + new UniqueId(data.getUniqueId()) + " at " +new java.sql.Timestamp(System.currentTimeMillis())+ " to "+Arrays.toNameString(destination));
+                Logs.MESSAGES.trace("GroupChannel - Send Message:" + new UniqueId(data.getUniqueId()) + " is " +msg);
+            }
+
+            return new UniqueId(data.getUniqueId());
+        }catch ( Exception x ) {
+            if ( x instanceof ChannelException ) throw (ChannelException)x;
+            throw new ChannelException(x);
+        } finally {
+            if ( buffer != null ) BufferPool.getBufferPool().returnBuffer(buffer);
+        }
+    }
+
+
+    /**
+     * Callback from the interceptor stack. <br>
+     * When a message is received from a remote node, this method will be invoked by
+     * the previous interceptor.<br>
+     * This method can also be used to send a message to other components within the same application,
+     * but its an extreme case, and you're probably better off doing that logic between the applications itself.
+     * @param msg ChannelMessage
+     */
+    public void messageReceived(ChannelMessage msg) {
+        if ( msg == null ) return;
+        try {
+            if ( Logs.MESSAGES.isTraceEnabled() ) {
+                Logs.MESSAGES.trace("GroupChannel - Received msg:" + new UniqueId(msg.getUniqueId()) + " at " +new java.sql.Timestamp(System.currentTimeMillis())+ " from "+msg.getAddress().getName());
+            }
+
+            Serializable fwd = null;
+            if ( (msg.getOptions() & SEND_OPTIONS_BYTE_MESSAGE) == SEND_OPTIONS_BYTE_MESSAGE ) {
+                fwd = new ByteMessage(msg.getMessage().getBytes());
+            } else {
+                fwd = XByteBuffer.deserialize(msg.getMessage().getBytesDirect(),0,msg.getMessage().getLength());
+            }
+            if ( Logs.MESSAGES.isTraceEnabled() ) {
+                Logs.MESSAGES.trace("GroupChannel - Receive Message:" + new UniqueId(msg.getUniqueId()) + " is " +fwd);
+            }
+
+            //get the actual member with the correct alive time
+            Member source = msg.getAddress();
+            boolean rx = false;
+            boolean delivered = false;
+            for ( int i=0; i<channelListeners.size(); i++ ) {
+                ChannelListener channelListener = (ChannelListener)channelListeners.get(i);
+                if (channelListener != null && channelListener.accept(fwd, source)) {
+                    channelListener.messageReceived(fwd, source);
+                    delivered = true;
+                    //if the message was accepted by an RPC channel, that channel
+                    //is responsible for returning the reply, otherwise we send an absence reply
+                    if ( channelListener instanceof RpcChannel ) rx = true;
+                }
+            }//for
+            if ((!rx) && (fwd instanceof RpcMessage)) {
+                //if we have a message that requires a response,
+                //but none was given, send back an immediate one
+                sendNoRpcChannelReply((RpcMessage)fwd,source);
+            }
+            if ( Logs.MESSAGES.isTraceEnabled() ) {
+                Logs.MESSAGES.trace("GroupChannel delivered["+delivered+"] id:"+new UniqueId(msg.getUniqueId()));
+            }
+
+        } catch ( Exception x ) {
+            if ( log.isDebugEnabled() ) log.error("Unable to process channel:IOException.",x);
+            throw new RemoteProcessException("IOException:"+x.getMessage(),x);
+        }
+    }
+
+    /**
+     * Sends a <code>NoRpcChannelReply</code> message to a member<br>
+     * This method gets invoked by the channel if a RPC message comes in
+     * and no channel listener accepts the message. This avoids timeout
+     * @param msg RpcMessage
+     * @param destination Member - the destination for the reply
+     */
+    protected void sendNoRpcChannelReply(RpcMessage msg, Member destination) {
+        try {
+            //avoid circular loop
+            if ( msg instanceof RpcMessage.NoRpcChannelReply) return;
+            RpcMessage.NoRpcChannelReply reply = new RpcMessage.NoRpcChannelReply(msg.rpcId,msg.uuid);
+            send(new Member[]{destination},reply,Channel.SEND_OPTIONS_ASYNCHRONOUS);
+        } catch ( Exception x ) {
+            log.error("Unable to find rpc channel, failed to send NoRpcChannelReply.",x);
+        }
+    }
+
+    /**
+     * memberAdded gets invoked by the interceptor below the channel
+     * and the channel will broadcast it to the membership listeners
+     * @param member Member - the new member
+     */
+    public void memberAdded(Member member) {
+        //notify upwards
+        for (int i=0; i<membershipListeners.size(); i++ ) {
+            MembershipListener membershipListener = (MembershipListener)membershipListeners.get(i);
+            if (membershipListener != null) membershipListener.memberAdded(member);
+        }
+    }
+
+    /**
+     * memberDisappeared gets invoked by the interceptor below the channel
+     * and the channel will broadcast it to the membership listeners
+     * @param member Member - the member that left or crashed
+     */
+    public void memberDisappeared(Member member) {
+        //notify upwards
+        for (int i=0; i<membershipListeners.size(); i++ ) {
+            MembershipListener membershipListener = (MembershipListener)membershipListeners.get(i);
+            if (membershipListener != null) membershipListener.memberDisappeared(member);
+        }
+    }
+
+    /**
+     * Sets up the default implementation interceptor stack
+     * if no interceptors have been added
+     * @throws ChannelException
+     */
+    protected synchronized void setupDefaultStack() throws ChannelException {
+
+        if ( getFirstInterceptor() != null &&
+             ((getFirstInterceptor().getNext() instanceof ChannelCoordinator))) {
+            ChannelInterceptor interceptor = null;
+            Class clazz = null;
+            try {
+                clazz = Class.forName("org.apache.catalina.tribes.group.interceptors.MessageDispatch15Interceptor",
+                                      true,GroupChannel.class.getClassLoader());
+                clazz.newInstance();
+            } catch ( Throwable x ) {
+                clazz = MessageDispatchInterceptor.class;
+            }//catch
+            try {
+                interceptor = (ChannelInterceptor) clazz.newInstance();
+            } catch (Exception x) {
+                throw new ChannelException("Unable to add MessageDispatchInterceptor to interceptor chain.",x);
+            }
+            this.addInterceptor(interceptor);
+        }
+    }
+
+    /**
+     * Validates the option flags that each interceptor is using and reports
+     * an error if two interceptor share the same flag.
+     * @throws ChannelException
+     */
+    protected void checkOptionFlags() throws ChannelException {
+        StringBuffer conflicts = new StringBuffer();
+        ChannelInterceptor first = interceptors;
+        while ( first != null ) {
+            int flag = first.getOptionFlag();
+            if ( flag != 0 ) {
+                ChannelInterceptor next = first.getNext();
+                while ( next != null ) {
+                    int nflag = next.getOptionFlag();
+                    if (nflag!=0 && (((flag & nflag) == flag ) || ((flag & nflag) == nflag)) ) {
+                        conflicts.append("[");
+                        conflicts.append(first.getClass().getName());
+                        conflicts.append(":");
+                        conflicts.append(flag);
+                        conflicts.append(" == ");
+                        conflicts.append(next.getClass().getName());
+                        conflicts.append(":");
+                        conflicts.append(nflag);
+                        conflicts.append("] ");
+                    }//end if
+                    next = next.getNext();
+                }//while
+            }//end if
+            first = first.getNext();
+        }//while
+        if ( conflicts.length() > 0 ) throw new ChannelException("Interceptor option flag conflict: "+conflicts.toString());
+
+    }
+
+    /**
+     * Starts the channel
+     * @param svc int - what service to start
+     * @throws ChannelException
+     * @see org.apache.catalina.tribes.Channel#start(int)
+     */
+    public synchronized void start(int svc) throws ChannelException {
+        setupDefaultStack();
+        if (optionCheck) checkOptionFlags();
+        super.start(svc);
+        if ( hbthread == null && heartbeat ) {
+            hbthread = new HeartbeatThread(this,heartbeatSleeptime);
+            hbthread.start();
+        }
+    }
+
+    /**
+     * Stops the channel
+     * @param svc int
+     * @throws ChannelException
+     * @see org.apache.catalina.tribes.Channel#stop(int)
+     */
+    public synchronized void stop(int svc) throws ChannelException {
+        if (hbthread != null) {
+            hbthread.stopHeartbeat();
+            hbthread = null;
+        }
+        super.stop(svc);
+    }
+
+    /**
+     * Returns the first interceptor of the stack. Useful for traversal.
+     * @return ChannelInterceptor
+     */
+    public ChannelInterceptor getFirstInterceptor() {
+        if (interceptors != null) return interceptors;
+        else return coordinator;
+    }
+
+    /**
+     * Returns the channel receiver component
+     * @return ChannelReceiver
+     */
+    public ChannelReceiver getChannelReceiver() {
+        return coordinator.getClusterReceiver();
+    }
+
+    /**
+     * Returns the channel sender component
+     * @return ChannelSender
+     */
+    public ChannelSender getChannelSender() {
+        return coordinator.getClusterSender();
+    }
+
+    /**
+     * Returns the membership service component
+     * @return MembershipService
+     */
+    public MembershipService getMembershipService() {
+        return coordinator.getMembershipService();
+    }
+
+    /**
+     * Sets the channel receiver component
+     * @param clusterReceiver ChannelReceiver
+     */
+    public void setChannelReceiver(ChannelReceiver clusterReceiver) {
+        coordinator.setClusterReceiver(clusterReceiver);
+    }
+
+    /**
+     * Sets the channel sender component
+     * @param clusterSender ChannelSender
+     */
+    public void setChannelSender(ChannelSender clusterSender) {
+        coordinator.setClusterSender(clusterSender);
+    }
+
+    /**
+     * Sets the membership component
+     * @param membershipService MembershipService
+     */
+    public void setMembershipService(MembershipService membershipService) {
+        coordinator.setMembershipService(membershipService);
+    }
+
+    /**
+     * Adds a membership listener to the channel.<br>
+     * Membership listeners are uniquely identified using the equals(Object) method
+     * @param membershipListener MembershipListener
+     */
+    public void addMembershipListener(MembershipListener membershipListener) {
+        if (!this.membershipListeners.contains(membershipListener) )
+            this.membershipListeners.add(membershipListener);
+    }
+
+    /**
+     * Removes a membership listener from the channel.<br>
+     * Membership listeners are uniquely identified using the equals(Object) method
+     * @param membershipListener MembershipListener
+     */
+
+    public void removeMembershipListener(MembershipListener membershipListener) {
+        membershipListeners.remove(membershipListener);
+    }
+
+    /**
+     * Adds a channel listener to the channel.<br>
+     * Channel listeners are uniquely identified using the equals(Object) method
+     * @param channelListener ChannelListener
+     */
+    public void addChannelListener(ChannelListener channelListener) {
+        if (!this.channelListeners.contains(channelListener) ) {
+            this.channelListeners.add(channelListener);
+        } else {
+            throw new IllegalArgumentException("Listener already exists:"+channelListener+"["+channelListener.getClass().getName()+"]");
+        }
+    }
+
+    /**
+     *
+     * Removes a channel listener from the channel.<br>
+     * Channel listeners are uniquely identified using the equals(Object) method
+     * @param channelListener ChannelListener
+     */
+    public void removeChannelListener(ChannelListener channelListener) {
+        channelListeners.remove(channelListener);
+    }
+
+    /**
+     * Returns an iterator of all the interceptors in this stack
+     * @return Iterator
+     */
+    public Iterator getInterceptors() {
+        return new InterceptorIterator(this.getNext(),this.coordinator);
+    }
+
+    /**
+     * Enables/disables the option check<br>
+     * Setting this to true, will make the GroupChannel perform a conflict check
+     * on the interceptors. If two interceptors are using the same option flag
+     * and throw an error upon start.
+     * @param optionCheck boolean
+     */
+    public void setOptionCheck(boolean optionCheck) {
+        this.optionCheck = optionCheck;
+    }
+
+    /**
+     * Configure local heartbeat sleep time<br>
+     * Only used when <code>getHeartbeat()==true</code>
+     * @param heartbeatSleeptime long - time in milliseconds to sleep between heartbeats
+     */
+    public void setHeartbeatSleeptime(long heartbeatSleeptime) {
+        this.heartbeatSleeptime = heartbeatSleeptime;
+    }
+
+    /**
+     * Enables or disables local heartbeat.
+     * if <code>setHeartbeat(true)</code> is invoked then the channel will start an internal
+     * thread to invoke <code>Channel.heartbeat()</code> every <code>getHeartbeatSleeptime</code> milliseconds
+     * @param heartbeat boolean
+     */
+    public void setHeartbeat(boolean heartbeat) {
+        this.heartbeat = heartbeat;
+    }
+
+    /**
+     * @see #setOptionCheck(boolean)
+     * @return boolean
+     */
+    public boolean getOptionCheck() {
+        return optionCheck;
+    }
+
+    /**
+     * @see #setHeartbeat(boolean)
+     * @return boolean
+     */
+    public boolean getHeartbeat() {
+        return heartbeat;
+    }
+
+    /**
+     * Returns the sleep time in milliseconds that the internal heartbeat will
+     * sleep in between invokations of <code>Channel.heartbeat()</code>
+     * @return long
+     */
+    public long getHeartbeatSleeptime() {
+        return heartbeatSleeptime;
+    }
+
+    /**
+     *
+     * <p>Title: Interceptor Iterator</p>
+     *
+     * <p>Description: An iterator to loop through the interceptors in a channel</p>
+     *
+     * @version 1.0
+     */
+    public static class InterceptorIterator implements Iterator {
+        private ChannelInterceptor end;
+        private ChannelInterceptor start;
+        public InterceptorIterator(ChannelInterceptor start, ChannelInterceptor end) {
+            this.end = end;
+            this.start = start;
+        }
+
+        public boolean hasNext() {
+            return start!=null && start != end;
+        }
+
+        public Object next() {
+            Object result = null;
+            if ( hasNext() ) {
+                result = start;
+                start = start.getNext();
+            }
+            return result;
+        }
+
+        public void remove() {
+            //empty operation
+        }
+    }
+
+    /**
+     *
+     * <p>Title: Internal heartbeat thread</p>
+     *
+     * <p>Description: if <code>Channel.getHeartbeat()==true</code> then a thread of this class
+     * is created</p>
+     *
+     * @version 1.0
+     */
+    public static class HeartbeatThread extends Thread {
+        protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(HeartbeatThread.class);
+        protected static int counter = 1;
+        protected static synchronized int inc() {
+            return counter++;
+        }
+
+        protected boolean doRun = true;
+        protected GroupChannel channel;
+        protected long sleepTime;
+        public HeartbeatThread(GroupChannel channel, long sleepTime) {
+            super();
+            this.setPriority(MIN_PRIORITY);
+            setName("GroupChannel-Heartbeat-"+inc());
+            setDaemon(true);
+            this.channel = channel;
+            this.sleepTime = sleepTime;
+        }
+        public void stopHeartbeat() {
+            doRun = false;
+            interrupt();
+        }
+
+        public void run() {
+            while (doRun) {
+                try {
+                    Thread.sleep(sleepTime);
+                    channel.heartbeat();
+                } catch ( InterruptedException x ) {
+                    interrupted();
+                } catch ( Exception x ) {
+                    log.error("Unable to send heartbeat through Tribes interceptor stack. Will try to sleep again.",x);
+                }//catch
+            }//while
+        }//run
+    }//HeartbeatThread
+
+
+
+}

==================================================
Response.java
index 61b7bcf7d0..27ef3e8c47 100644
--- a/java/org/apache/catalina/tribes/group/InterceptorPayload.java
+++ b/java/org/apache/catalina/tribes/group/InterceptorPayload.java
@@ -1,35 +1,35 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.group;
-
-import org.apache.catalina.tribes.ErrorHandler;
-
-/**
- * @author Filip Hanik
- * @version 1.0
- */
-public class InterceptorPayload  {
-    private ErrorHandler errorHandler;
-    
-    public ErrorHandler getErrorHandler() {
-        return errorHandler;
-    }
-
-    public void setErrorHandler(ErrorHandler errorHandler) {
-        this.errorHandler = errorHandler;
-    }
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.group;
+
+import org.apache.catalina.tribes.ErrorHandler;
+
+/**
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class InterceptorPayload  {
+    private ErrorHandler errorHandler;
+    
+    public ErrorHandler getErrorHandler() {
+        return errorHandler;
+    }
+
+    public void setErrorHandler(ErrorHandler errorHandler) {
+        this.errorHandler = errorHandler;
+    }
 }
\ No newline at end of file

==================================================
RpcCallback.java
index 03ee1d0b80..16e01a8155 100644
--- a/java/org/apache/catalina/tribes/group/Response.java
+++ b/java/org/apache/catalina/tribes/group/Response.java
@@ -1,54 +1,54 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.group;
-
-import java.io.Serializable;
-
-import org.apache.catalina.tribes.Member;
-
-/**
- * A response object holds a message from a responding partner.
- * @author Filip Hanik
- * @version 1.0
- */
-public class Response {
-    private Member source;
-    private Serializable message;
-    public Response() {
-    }
-    
-    public Response(Member source, Serializable message) {
-        this.source = source;
-        this.message = message;
-    }
-
-    public void setSource(Member source) {
-        this.source = source;
-    }
-
-    public void setMessage(Serializable message) {
-        this.message = message;
-    }
-
-    public Member getSource() {
-        return source;
-    }
-
-    public Serializable getMessage() {
-        return message;
-    }
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.group;
+
+import java.io.Serializable;
+
+import org.apache.catalina.tribes.Member;
+
+/**
+ * A response object holds a message from a responding partner.
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class Response {
+    private Member source;
+    private Serializable message;
+    public Response() {
+    }
+    
+    public Response(Member source, Serializable message) {
+        this.source = source;
+        this.message = message;
+    }
+
+    public void setSource(Member source) {
+        this.source = source;
+    }
+
+    public void setMessage(Serializable message) {
+        this.message = message;
+    }
+
+    public Member getSource() {
+        return source;
+    }
+
+    public Serializable getMessage() {
+        return message;
+    }
 }
\ No newline at end of file

==================================================
RpcChannel.java
index e19eea36b4..93140db044 100644
--- a/java/org/apache/catalina/tribes/group/RpcCallback.java
+++ b/java/org/apache/catalina/tribes/group/RpcCallback.java
@@ -1,46 +1,46 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.group;
-
-import java.io.Serializable;
-
-import org.apache.catalina.tribes.Member;
-
-/**
- * The RpcCallback interface is an interface for the Tribes channel to request a
- * response object to a request that came in.
- * @author not attributable
- * @version 1.0
- */
-public interface RpcCallback {
-    
-    /**
-     * 
-     * @param msg Serializable
-     * @return Serializable - null if no reply should be sent
-     */
-    public Serializable replyRequest(Serializable msg, Member sender);
-    
-    /**
-     * If the reply has already been sent to the requesting thread,
-     * the rpc callback can handle any data that comes in after the fact.
-     * @param msg Serializable
-     * @param sender Member
-     */
-    public void leftOver(Serializable msg, Member sender);
-    
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.group;
+
+import java.io.Serializable;
+
+import org.apache.catalina.tribes.Member;
+
+/**
+ * The RpcCallback interface is an interface for the Tribes channel to request a
+ * response object to a request that came in.
+ * @author not attributable
+ * @version 1.0
+ */
+public interface RpcCallback {
+    
+    /**
+     * 
+     * @param msg Serializable
+     * @return Serializable - null if no reply should be sent
+     */
+    public Serializable replyRequest(Serializable msg, Member sender);
+    
+    /**
+     * If the reply has already been sent to the requesting thread,
+     * the rpc callback can handle any data that comes in after the fact.
+     * @param msg Serializable
+     * @param sender Member
+     */
+    public void leftOver(Serializable msg, Member sender);
+    
 }
\ No newline at end of file

==================================================
RpcMessage.java
index 2fb35ab700..2239e35ceb 100644
--- a/java/org/apache/catalina/tribes/group/RpcChannel.java
+++ b/java/org/apache/catalina/tribes/group/RpcChannel.java
@@ -1,262 +1,262 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.group;
-
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-
-import org.apache.catalina.tribes.Channel;
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelListener;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.util.UUIDGenerator;
-
-/**
- * A channel to handle RPC messaging
- * @author Filip Hanik
- */
-public class RpcChannel implements ChannelListener{
-    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(RpcChannel.class);
-    
-    public static final int FIRST_REPLY = 1;
-    public static final int MAJORITY_REPLY = 2;
-    public static final int ALL_REPLY = 3;
-    public static final int NO_REPLY = 4;
-    
-    private Channel channel;
-    private RpcCallback callback;
-    private byte[] rpcId;
-    
-    private HashMap responseMap = new HashMap();
-
-    /**
-     * Create an RPC channel. You can have several RPC channels attached to a group
-     * all separated out by the uniqueness
-     * @param rpcId - the unique Id for this RPC group
-     * @param channel Channel
-     * @param callback RpcCallback
-     */
-    public RpcChannel(byte[] rpcId, Channel channel, RpcCallback callback) {
-        this.channel = channel;
-        this.callback = callback;
-        this.rpcId = rpcId;
-        channel.addChannelListener(this);
-    }
-    
-    
-    /**
-     * Send a message and wait for the response.
-     * @param destination Member[] - the destination for the message, and the members you request a reply from
-     * @param message Serializable - the message you are sending out
-     * @param options int - FIRST_REPLY, MAJORITY_REPLY or ALL_REPLY
-     * @param timeout long - timeout in milliseconds, if no reply is received within this time null is returned
-     * @return Response[] - an array of response objects.
-     * @throws ChannelException
-     */
-    public Response[] send(Member[] destination, 
-                           Serializable message,
-                           int rpcOptions, 
-                           int channelOptions,
-                           long timeout) throws ChannelException {
-        
-        if ( destination==null || destination.length == 0 ) return new Response[0];
-        
-        //avoid dead lock
-        channelOptions = channelOptions & ~Channel.SEND_OPTIONS_SYNCHRONIZED_ACK;
-        
-        RpcCollectorKey key = new RpcCollectorKey(UUIDGenerator.randomUUID(false));
-        RpcCollector collector = new RpcCollector(key,rpcOptions,destination.length,timeout);
-        try {
-            synchronized (collector) {
-                if ( rpcOptions != NO_REPLY ) responseMap.put(key, collector);
-                RpcMessage rmsg = new RpcMessage(rpcId, key.id, message);
-                channel.send(destination, rmsg, channelOptions);
-                if ( rpcOptions != NO_REPLY ) collector.wait(timeout);
-            }
-        } catch ( InterruptedException ix ) {
-            Thread.currentThread().interrupted();
-            //throw new ChannelException(ix);
-        }finally {
-            responseMap.remove(key);
-        }
-        return collector.getResponses();
-    }
-    
-    public void messageReceived(Serializable msg, Member sender) {
-        RpcMessage rmsg = (RpcMessage)msg;
-        RpcCollectorKey key = new RpcCollectorKey(rmsg.uuid);
-        if ( rmsg.reply ) {
-            RpcCollector collector = (RpcCollector)responseMap.get(key);
-            if (collector == null) {
-                callback.leftOver(rmsg.message, sender);
-            } else {
-                synchronized (collector) {
-                    //make sure it hasn't been removed
-                    if ( responseMap.containsKey(key) ) {
-                        if ( (rmsg instanceof RpcMessage.NoRpcChannelReply) ) 
-                            collector.destcnt--;
-                        else 
-                            collector.addResponse(rmsg.message, sender);
-                        if (collector.isComplete()) collector.notifyAll();
-                    } else {
-                        if (! (rmsg instanceof RpcMessage.NoRpcChannelReply) ) 
-                            callback.leftOver(rmsg.message, sender);
-                    }
-                }//synchronized
-            }//end if
-        } else{
-            Serializable reply = callback.replyRequest(rmsg.message,sender);
-            rmsg.reply = true;
-            rmsg.message = reply;
-            try {
-                channel.send(new Member[] {sender}, rmsg,0);
-            }catch ( Exception x )  {
-                log.error("Unable to send back reply in RpcChannel.",x);
-            }
-        }//end if
-    }
-    
-    public void breakdown() {
-        channel.removeChannelListener(this);
-    }
-    
-    public void finalize() {
-        breakdown();
-    }
-    
-    public boolean accept(Serializable msg, Member sender) {
-        if ( msg instanceof RpcMessage ) {
-            RpcMessage rmsg = (RpcMessage)msg;
-            return Arrays.equals(rmsg.rpcId,rpcId);
-        }else return false;
-    }
-    
-    public Channel getChannel() {
-        return channel;
-    }
-
-    public RpcCallback getCallback() {
-        return callback;
-    }
-
-    public byte[] getRpcId() {
-        return rpcId;
-    }
-
-    public void setChannel(Channel channel) {
-        this.channel = channel;
-    }
-
-    public void setCallback(RpcCallback callback) {
-        this.callback = callback;
-    }
-
-    public void setRpcId(byte[] rpcId) {
-        this.rpcId = rpcId;
-    }
-    
-
-
-    /**
-     * 
-     * Class that holds all response.
-     * @author not attributable
-     * @version 1.0
-     */
-    public static class RpcCollector {
-        public ArrayList responses = new ArrayList(); 
-        public RpcCollectorKey key;
-        public int options;
-        public int destcnt;
-        public long timeout;
-        
-        public RpcCollector(RpcCollectorKey key, int options, int destcnt, long timeout) {
-            this.key = key;
-            this.options = options;
-            this.destcnt = destcnt;
-            this.timeout = timeout;
-        }
-        
-        public void addResponse(Serializable message, Member sender){
-            Response resp = new Response(sender,message);
-            responses.add(resp);
-        }
-        
-        public boolean isComplete() {
-            if ( destcnt <= 0 ) return true;
-            switch (options) {
-                case ALL_REPLY:
-                    return destcnt == responses.size();
-                case MAJORITY_REPLY:
-                {
-                    float perc = ((float)responses.size()) / ((float)destcnt);
-                    return perc >= 0.50f;
-                }
-                case FIRST_REPLY:
-                    return responses.size()>0;
-                default:
-                    return false;
-            }
-        }
-        
-        public int hashCode() {
-            return key.hashCode();
-        }
-        
-        public boolean equals(Object o) {
-            if ( o instanceof RpcCollector ) {
-                RpcCollector r = (RpcCollector)o;
-                return r.key.equals(this.key);
-            } else return false;
-        }
-        
-        public Response[] getResponses() {
-            return (Response[])responses.toArray(new Response[responses.size()]);
-        }
-    }
-    
-    public static class RpcCollectorKey {
-        byte[] id;
-        public RpcCollectorKey(byte[] id) {
-            this.id = id;
-        }
-        
-        public int hashCode() {
-            return id[0]+id[1]+id[2]+id[3];
-        }
-
-        public boolean equals(Object o) {
-            if ( o instanceof RpcCollectorKey ) {
-                RpcCollectorKey r = (RpcCollectorKey)o;
-                return Arrays.equals(id,r.id);
-            } else return false;
-        }
-        
-    }
-    
-    protected static String bToS(byte[] data) {
-        StringBuffer buf = new StringBuffer(4*16);
-        buf.append("{");
-        for (int i=0; data!=null && i<data.length; i++ ) buf.append(String.valueOf(data[i])).append(" ");
-        buf.append("}");
-        return buf.toString();
-    }
-
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.group;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+
+import org.apache.catalina.tribes.Channel;
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelListener;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.util.UUIDGenerator;
+
+/**
+ * A channel to handle RPC messaging
+ * @author Filip Hanik
+ */
+public class RpcChannel implements ChannelListener{
+    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(RpcChannel.class);
+    
+    public static final int FIRST_REPLY = 1;
+    public static final int MAJORITY_REPLY = 2;
+    public static final int ALL_REPLY = 3;
+    public static final int NO_REPLY = 4;
+    
+    private Channel channel;
+    private RpcCallback callback;
+    private byte[] rpcId;
+    
+    private HashMap responseMap = new HashMap();
+
+    /**
+     * Create an RPC channel. You can have several RPC channels attached to a group
+     * all separated out by the uniqueness
+     * @param rpcId - the unique Id for this RPC group
+     * @param channel Channel
+     * @param callback RpcCallback
+     */
+    public RpcChannel(byte[] rpcId, Channel channel, RpcCallback callback) {
+        this.channel = channel;
+        this.callback = callback;
+        this.rpcId = rpcId;
+        channel.addChannelListener(this);
+    }
+    
+    
+    /**
+     * Send a message and wait for the response.
+     * @param destination Member[] - the destination for the message, and the members you request a reply from
+     * @param message Serializable - the message you are sending out
+     * @param options int - FIRST_REPLY, MAJORITY_REPLY or ALL_REPLY
+     * @param timeout long - timeout in milliseconds, if no reply is received within this time null is returned
+     * @return Response[] - an array of response objects.
+     * @throws ChannelException
+     */
+    public Response[] send(Member[] destination, 
+                           Serializable message,
+                           int rpcOptions, 
+                           int channelOptions,
+                           long timeout) throws ChannelException {
+        
+        if ( destination==null || destination.length == 0 ) return new Response[0];
+        
+        //avoid dead lock
+        channelOptions = channelOptions & ~Channel.SEND_OPTIONS_SYNCHRONIZED_ACK;
+        
+        RpcCollectorKey key = new RpcCollectorKey(UUIDGenerator.randomUUID(false));
+        RpcCollector collector = new RpcCollector(key,rpcOptions,destination.length,timeout);
+        try {
+            synchronized (collector) {
+                if ( rpcOptions != NO_REPLY ) responseMap.put(key, collector);
+                RpcMessage rmsg = new RpcMessage(rpcId, key.id, message);
+                channel.send(destination, rmsg, channelOptions);
+                if ( rpcOptions != NO_REPLY ) collector.wait(timeout);
+            }
+        } catch ( InterruptedException ix ) {
+            Thread.currentThread().interrupted();
+            //throw new ChannelException(ix);
+        }finally {
+            responseMap.remove(key);
+        }
+        return collector.getResponses();
+    }
+    
+    public void messageReceived(Serializable msg, Member sender) {
+        RpcMessage rmsg = (RpcMessage)msg;
+        RpcCollectorKey key = new RpcCollectorKey(rmsg.uuid);
+        if ( rmsg.reply ) {
+            RpcCollector collector = (RpcCollector)responseMap.get(key);
+            if (collector == null) {
+                callback.leftOver(rmsg.message, sender);
+            } else {
+                synchronized (collector) {
+                    //make sure it hasn't been removed
+                    if ( responseMap.containsKey(key) ) {
+                        if ( (rmsg instanceof RpcMessage.NoRpcChannelReply) ) 
+                            collector.destcnt--;
+                        else 
+                            collector.addResponse(rmsg.message, sender);
+                        if (collector.isComplete()) collector.notifyAll();
+                    } else {
+                        if (! (rmsg instanceof RpcMessage.NoRpcChannelReply) ) 
+                            callback.leftOver(rmsg.message, sender);
+                    }
+                }//synchronized
+            }//end if
+        } else{
+            Serializable reply = callback.replyRequest(rmsg.message,sender);
+            rmsg.reply = true;
+            rmsg.message = reply;
+            try {
+                channel.send(new Member[] {sender}, rmsg,0);
+            }catch ( Exception x )  {
+                log.error("Unable to send back reply in RpcChannel.",x);
+            }
+        }//end if
+    }
+    
+    public void breakdown() {
+        channel.removeChannelListener(this);
+    }
+    
+    public void finalize() {
+        breakdown();
+    }
+    
+    public boolean accept(Serializable msg, Member sender) {
+        if ( msg instanceof RpcMessage ) {
+            RpcMessage rmsg = (RpcMessage)msg;
+            return Arrays.equals(rmsg.rpcId,rpcId);
+        }else return false;
+    }
+    
+    public Channel getChannel() {
+        return channel;
+    }
+
+    public RpcCallback getCallback() {
+        return callback;
+    }
+
+    public byte[] getRpcId() {
+        return rpcId;
+    }
+
+    public void setChannel(Channel channel) {
+        this.channel = channel;
+    }
+
+    public void setCallback(RpcCallback callback) {
+        this.callback = callback;
+    }
+
+    public void setRpcId(byte[] rpcId) {
+        this.rpcId = rpcId;
+    }
+    
+
+
+    /**
+     * 
+     * Class that holds all response.
+     * @author not attributable
+     * @version 1.0
+     */
+    public static class RpcCollector {
+        public ArrayList responses = new ArrayList(); 
+        public RpcCollectorKey key;
+        public int options;
+        public int destcnt;
+        public long timeout;
+        
+        public RpcCollector(RpcCollectorKey key, int options, int destcnt, long timeout) {
+            this.key = key;
+            this.options = options;
+            this.destcnt = destcnt;
+            this.timeout = timeout;
+        }
+        
+        public void addResponse(Serializable message, Member sender){
+            Response resp = new Response(sender,message);
+            responses.add(resp);
+        }
+        
+        public boolean isComplete() {
+            if ( destcnt <= 0 ) return true;
+            switch (options) {
+                case ALL_REPLY:
+                    return destcnt == responses.size();
+                case MAJORITY_REPLY:
+                {
+                    float perc = ((float)responses.size()) / ((float)destcnt);
+                    return perc >= 0.50f;
+                }
+                case FIRST_REPLY:
+                    return responses.size()>0;
+                default:
+                    return false;
+            }
+        }
+        
+        public int hashCode() {
+            return key.hashCode();
+        }
+        
+        public boolean equals(Object o) {
+            if ( o instanceof RpcCollector ) {
+                RpcCollector r = (RpcCollector)o;
+                return r.key.equals(this.key);
+            } else return false;
+        }
+        
+        public Response[] getResponses() {
+            return (Response[])responses.toArray(new Response[responses.size()]);
+        }
+    }
+    
+    public static class RpcCollectorKey {
+        byte[] id;
+        public RpcCollectorKey(byte[] id) {
+            this.id = id;
+        }
+        
+        public int hashCode() {
+            return id[0]+id[1]+id[2]+id[3];
+        }
+
+        public boolean equals(Object o) {
+            if ( o instanceof RpcCollectorKey ) {
+                RpcCollectorKey r = (RpcCollectorKey)o;
+                return Arrays.equals(id,r.id);
+            } else return false;
+        }
+        
+    }
+    
+    protected static String bToS(byte[] data) {
+        StringBuffer buf = new StringBuffer(4*16);
+        buf.append("{");
+        for (int i=0; data!=null && i<data.length; i++ ) buf.append(String.valueOf(data[i])).append(" ");
+        buf.append("}");
+        return buf.toString();
+    }
+
+
 }
\ No newline at end of file

==================================================
DomainFilterInterceptor.java
index 53db66eb43..0bf1eb8ac5 100644
--- a/java/org/apache/catalina/tribes/group/RpcMessage.java
+++ b/java/org/apache/catalina/tribes/group/RpcMessage.java
@@ -1,117 +1,117 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.group;
-
-import java.io.ObjectInput;
-import java.io.Serializable;
-import java.io.Externalizable;
-import java.io.IOException;
-import java.io.ObjectOutput;
-import org.apache.catalina.tribes.util.Arrays;
-
-/**
- * <p>Title: </p>
- *
- * <p>Description: </p>
- *
- * <p>Copyright: Copyright (c) 2005</p>
- *
- * <p>Company: </p>
- *
- * @author not attributable
- * @version 1.0
- */
-public class RpcMessage implements Externalizable {
-
-    protected Serializable message;
-    protected byte[] uuid;
-    protected byte[] rpcId;
-    protected boolean reply = false;
-
-    public RpcMessage() {
-        //for serialization
-    }
-
-    public RpcMessage(byte[] rpcId, byte[] uuid, Serializable message) {
-        this.rpcId = rpcId;
-        this.uuid = uuid;
-        this.message = message;
-    }
-
-    public void readExternal(ObjectInput in) throws IOException,ClassNotFoundException {
-        reply = in.readBoolean();
-        int length = in.readInt();
-        uuid = new byte[length];
-        in.read(uuid, 0, length);
-        length = in.readInt();
-        rpcId = new byte[length];
-        in.read(rpcId, 0, length);
-        message = (Serializable)in.readObject();
-    }
-
-    public void writeExternal(ObjectOutput out) throws IOException {
-        out.writeBoolean(reply);
-        out.writeInt(uuid.length);
-        out.write(uuid, 0, uuid.length);
-        out.writeInt(rpcId.length);
-        out.write(rpcId, 0, rpcId.length);
-        out.writeObject(message);
-    }
-    
-    public String toString() {
-        StringBuffer buf = new StringBuffer("RpcMessage[");
-        buf.append(super.toString());
-        buf.append("] rpcId=");
-        buf.append(Arrays.toString(rpcId));
-        buf.append("; uuid=");
-        buf.append(Arrays.toString(uuid));
-        buf.append("; msg=");
-        buf.append(message);
-        return buf.toString();
-    }
-    
-    public static class NoRpcChannelReply extends RpcMessage {
-        public NoRpcChannelReply() {
-            
-        }
-
-        public NoRpcChannelReply(byte[] rpcid, byte[] uuid) {
-            super(rpcid,uuid,null);
-            reply = true;
-        }
-
-        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
-            reply = true;
-            int length = in.readInt();
-            uuid = new byte[length];
-            in.read(uuid, 0, length);
-            length = in.readInt();
-            rpcId = new byte[length];
-            in.read(rpcId, 0, length);
-        }
-
-        public void writeExternal(ObjectOutput out) throws IOException {
-            out.writeInt(uuid.length);
-            out.write(uuid, 0, uuid.length);
-            out.writeInt(rpcId.length);
-            out.write(rpcId, 0, rpcId.length);
-        }
-    }    
-
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.group;
+
+import java.io.ObjectInput;
+import java.io.Serializable;
+import java.io.Externalizable;
+import java.io.IOException;
+import java.io.ObjectOutput;
+import org.apache.catalina.tribes.util.Arrays;
+
+/**
+ * <p>Title: </p>
+ *
+ * <p>Description: </p>
+ *
+ * <p>Copyright: Copyright (c) 2005</p>
+ *
+ * <p>Company: </p>
+ *
+ * @author not attributable
+ * @version 1.0
+ */
+public class RpcMessage implements Externalizable {
+
+    protected Serializable message;
+    protected byte[] uuid;
+    protected byte[] rpcId;
+    protected boolean reply = false;
+
+    public RpcMessage() {
+        //for serialization
+    }
+
+    public RpcMessage(byte[] rpcId, byte[] uuid, Serializable message) {
+        this.rpcId = rpcId;
+        this.uuid = uuid;
+        this.message = message;
+    }
+
+    public void readExternal(ObjectInput in) throws IOException,ClassNotFoundException {
+        reply = in.readBoolean();
+        int length = in.readInt();
+        uuid = new byte[length];
+        in.read(uuid, 0, length);
+        length = in.readInt();
+        rpcId = new byte[length];
+        in.read(rpcId, 0, length);
+        message = (Serializable)in.readObject();
+    }
+
+    public void writeExternal(ObjectOutput out) throws IOException {
+        out.writeBoolean(reply);
+        out.writeInt(uuid.length);
+        out.write(uuid, 0, uuid.length);
+        out.writeInt(rpcId.length);
+        out.write(rpcId, 0, rpcId.length);
+        out.writeObject(message);
+    }
+    
+    public String toString() {
+        StringBuffer buf = new StringBuffer("RpcMessage[");
+        buf.append(super.toString());
+        buf.append("] rpcId=");
+        buf.append(Arrays.toString(rpcId));
+        buf.append("; uuid=");
+        buf.append(Arrays.toString(uuid));
+        buf.append("; msg=");
+        buf.append(message);
+        return buf.toString();
+    }
+    
+    public static class NoRpcChannelReply extends RpcMessage {
+        public NoRpcChannelReply() {
+            
+        }
+
+        public NoRpcChannelReply(byte[] rpcid, byte[] uuid) {
+            super(rpcid,uuid,null);
+            reply = true;
+        }
+
+        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
+            reply = true;
+            int length = in.readInt();
+            uuid = new byte[length];
+            in.read(uuid, 0, length);
+            length = in.readInt();
+            rpcId = new byte[length];
+            in.read(rpcId, 0, length);
+        }
+
+        public void writeExternal(ObjectOutput out) throws IOException {
+            out.writeInt(uuid.length);
+            out.write(uuid, 0, uuid.length);
+            out.writeInt(rpcId.length);
+            out.write(rpcId, 0, rpcId.length);
+        }
+    }    
+
+
+}

==================================================
FragmentationInterceptor.java
index 5ccd5bff20..f2e898fd0d 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/DomainFilterInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/DomainFilterInterceptor.java
@@ -1,102 +1,102 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- */
-package org.apache.catalina.tribes.group.interceptors;
-
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.group.ChannelInterceptorBase;
-import org.apache.catalina.tribes.membership.MemberImpl;
-import org.apache.catalina.tribes.membership.Membership;
-import java.util.Arrays;
-
-/**
- * <p>Title: Member domain filter interceptor </p>
- *
- * <p>Description: Filters membership based on domain.
- * </p>
- *
- * @author Filip Hanik
- * @version 1.0
- */
-public class DomainFilterInterceptor extends ChannelInterceptorBase {
-
-    private static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( DomainFilterInterceptor.class );
-
-    protected Membership membership = null;
-    
-    protected byte[] domain = new byte[0];
-
-    public void messageReceived(ChannelMessage msg) {
-        //should we filter incoming based on domain?
-        super.messageReceived(msg);
-    }//messageReceived
-
-
-    public void memberAdded(Member member) {
-        if ( membership == null ) setupMembership();
-        boolean notify = false;
-        synchronized (membership) {
-            notify = Arrays.equals(domain,member.getDomain());
-            if ( notify ) notify = membership.memberAlive((MemberImpl)member);
-        }
-        if ( notify ) super.memberAdded(member);
-    }
-
-    public void memberDisappeared(Member member) {
-        if ( membership == null ) setupMembership();
-        boolean notify = false;
-        synchronized (membership) {
-            notify = Arrays.equals(domain,member.getDomain());
-            membership.removeMember((MemberImpl)member);
-        }
-        if ( notify ) super.memberDisappeared(member);
-    }
-
-    public boolean hasMembers() {
-        if ( membership == null ) setupMembership();
-        return membership.hasMembers();
-    }
-
-    public Member[] getMembers() {
-        if ( membership == null ) setupMembership();
-        return membership.getMembers();
-    }
-
-    public Member getMember(Member mbr) {
-        if ( membership == null ) setupMembership();
-        return membership.getMember(mbr);
-    }
-
-    public Member getLocalMember(boolean incAlive) {
-        return super.getLocalMember(incAlive);
-    }
-
-
-    protected synchronized void setupMembership() {
-        if ( membership == null ) {
-            membership = new Membership((MemberImpl)super.getLocalMember(true));
-        }
-
-    }
-
-    public byte[] getDomain() {
-        return domain;
-    }
-
-    public void setDomain(byte[] domain) {
-        this.domain = domain;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ */
+package org.apache.catalina.tribes.group.interceptors;
+
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.group.ChannelInterceptorBase;
+import org.apache.catalina.tribes.membership.MemberImpl;
+import org.apache.catalina.tribes.membership.Membership;
+import java.util.Arrays;
+
+/**
+ * <p>Title: Member domain filter interceptor </p>
+ *
+ * <p>Description: Filters membership based on domain.
+ * </p>
+ *
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class DomainFilterInterceptor extends ChannelInterceptorBase {
+
+    private static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( DomainFilterInterceptor.class );
+
+    protected Membership membership = null;
+    
+    protected byte[] domain = new byte[0];
+
+    public void messageReceived(ChannelMessage msg) {
+        //should we filter incoming based on domain?
+        super.messageReceived(msg);
+    }//messageReceived
+
+
+    public void memberAdded(Member member) {
+        if ( membership == null ) setupMembership();
+        boolean notify = false;
+        synchronized (membership) {
+            notify = Arrays.equals(domain,member.getDomain());
+            if ( notify ) notify = membership.memberAlive((MemberImpl)member);
+        }
+        if ( notify ) super.memberAdded(member);
+    }
+
+    public void memberDisappeared(Member member) {
+        if ( membership == null ) setupMembership();
+        boolean notify = false;
+        synchronized (membership) {
+            notify = Arrays.equals(domain,member.getDomain());
+            membership.removeMember((MemberImpl)member);
+        }
+        if ( notify ) super.memberDisappeared(member);
+    }
+
+    public boolean hasMembers() {
+        if ( membership == null ) setupMembership();
+        return membership.hasMembers();
+    }
+
+    public Member[] getMembers() {
+        if ( membership == null ) setupMembership();
+        return membership.getMembers();
+    }
+
+    public Member getMember(Member mbr) {
+        if ( membership == null ) setupMembership();
+        return membership.getMember(mbr);
+    }
+
+    public Member getLocalMember(boolean incAlive) {
+        return super.getLocalMember(incAlive);
+    }
+
+
+    protected synchronized void setupMembership() {
+        if ( membership == null ) {
+            membership = new Membership((MemberImpl)super.getLocalMember(true));
+        }
+
+    }
+
+    public byte[] getDomain() {
+        return domain;
+    }
+
+    public void setDomain(byte[] domain) {
+        this.domain = domain;
+    }
+}

==================================================
GzipInterceptor.java
index cf8e673e5f..cee3955a33 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/FragmentationInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/FragmentationInterceptor.java
@@ -1,242 +1,242 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- */
-
-package org.apache.catalina.tribes.group.interceptors;
-
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.Set;
-
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.group.ChannelInterceptorBase;
-import org.apache.catalina.tribes.group.InterceptorPayload;
-import org.apache.catalina.tribes.io.XByteBuffer;
-
-/**
- *
- * The fragmentation interceptor splits up large messages into smaller messages and assembles them on the other end.
- * This is very useful when you don't want large messages hogging the sending sockets
- * and smaller messages can make it through.
- * 
- * <br><b>Configuration Options</b><br>
- * OrderInteceptor.expire=<milliseconds> - how long do we keep the fragments in memory and wait for the rest to arrive<b>default=60,000ms -> 60seconds</b>
- * This setting is useful to avoid OutOfMemoryErrors<br>
- * OrderInteceptor.maxSize=<max message size> - message size in bytes <b>default=1024*100 (around a tenth of a MB)</b><br>
- * @author Filip Hanik
- * @version 1.0
- */
-public class FragmentationInterceptor extends ChannelInterceptorBase {
-    private static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( FragmentationInterceptor.class );
-    
-    protected HashMap fragpieces = new HashMap();
-    private int maxSize = 1024*100;
-    private long expire = 1000 * 60; //one minute expiration
-    protected boolean deepclone = true;
-
-
-    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
-        int size = msg.getMessage().getLength();
-        boolean frag = (size>maxSize) && okToProcess(msg.getOptions());
-        if ( frag ) {
-            frag(destination, msg, payload);
-        } else {
-            msg.getMessage().append(frag);
-            super.sendMessage(destination, msg, payload);
-        }
-    }
-    
-    public void messageReceived(ChannelMessage msg) {
-        boolean isFrag = XByteBuffer.toBoolean(msg.getMessage().getBytesDirect(),msg.getMessage().getLength()-1);
-        msg.getMessage().trim(1);
-        if ( isFrag ) {
-            defrag(msg);
-        } else {
-            super.messageReceived(msg);
-        }
-    }
-
-    
-    public FragCollection getFragCollection(FragKey key, ChannelMessage msg) {
-        FragCollection coll = (FragCollection)fragpieces.get(key);
-        if ( coll == null ) {
-            synchronized (fragpieces) {
-                coll = (FragCollection)fragpieces.get(key);
-                if ( coll == null ) {
-                    coll = new FragCollection(msg);
-                    fragpieces.put(key, coll);
-                }
-            }
-        } 
-        return coll;
-    }
-    
-    public void removeFragCollection(FragKey key) {
-        fragpieces.remove(key);
-    }
-    
-    public void defrag(ChannelMessage msg ) { 
-        FragKey key = new FragKey(msg.getUniqueId());
-        FragCollection coll = getFragCollection(key,msg);
-        coll.addMessage((ChannelMessage)msg.deepclone());
-
-        if ( coll.complete() ) {
-            removeFragCollection(key);
-            ChannelMessage complete = coll.assemble();
-            super.messageReceived(complete);
-            
-        }
-    }
-
-    public void frag(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
-        int size = msg.getMessage().getLength();
-
-        int count = ((size / maxSize )+(size%maxSize==0?0:1));
-        ChannelMessage[] messages = new ChannelMessage[count];
-        int remaining = size;
-        for ( int i=0; i<count; i++ ) {
-            ChannelMessage tmp = (ChannelMessage)msg.clone();
-            int offset = (i*maxSize);
-            int length = Math.min(remaining,maxSize);
-            tmp.getMessage().clear();
-            tmp.getMessage().append(msg.getMessage().getBytesDirect(),offset,length);
-            //add the msg nr
-            //tmp.getMessage().append(XByteBuffer.toBytes(i),0,4);
-            tmp.getMessage().append(i);
-            //add the total nr of messages
-            //tmp.getMessage().append(XByteBuffer.toBytes(count),0,4);
-            tmp.getMessage().append(count);
-            //add true as the frag flag
-            //byte[] flag = XByteBuffer.toBytes(true);
-            //tmp.getMessage().append(flag,0,flag.length);
-            tmp.getMessage().append(true);
-            messages[i] = tmp;
-            remaining -= length;
-            
-        }
-        for ( int i=0; i<messages.length; i++ ) {
-            super.sendMessage(destination,messages[i],payload);
-        }
-    }
-    
-    public void heartbeat() {
-        try {
-            Set set = fragpieces.keySet(); 
-            Object[] keys = set.toArray();
-            for ( int i=0; i<keys.length; i++ ) {
-                FragKey key = (FragKey)keys[i];
-                if ( key != null && key.expired(getExpire()) ) 
-                    removeFragCollection(key);
-            }
-        }catch ( Exception x ) {
-            if ( log.isErrorEnabled() ) {
-                log.error("Unable to perform heartbeat clean up in the frag interceptor",x);
-            }
-        }
-        super.heartbeat();
-    }
-
-    
-
-    public int getMaxSize() {
-        return maxSize;
-    }
-
-    public long getExpire() {
-        return expire;
-    }
-
-    public void setMaxSize(int maxSize) {
-        this.maxSize = maxSize;
-    }
-
-    public void setExpire(long expire) {
-        this.expire = expire;
-    }
-
-    public static class FragCollection {
-        private long received = System.currentTimeMillis();
-        private ChannelMessage msg;
-        private XByteBuffer[] frags;
-        public FragCollection(ChannelMessage msg) {
-            //get the total messages
-            int count = XByteBuffer.toInt(msg.getMessage().getBytesDirect(),msg.getMessage().getLength()-4);
-            frags = new XByteBuffer[count];
-            this.msg = msg;
-        }
-        
-        public void addMessage(ChannelMessage msg) {
-            //remove the total messages
-            msg.getMessage().trim(4);
-            //get the msg nr
-            int nr = XByteBuffer.toInt(msg.getMessage().getBytesDirect(),msg.getMessage().getLength()-4);
-            //remove the msg nr
-            msg.getMessage().trim(4);
-            frags[nr] = msg.getMessage();
-            
-        }
-        
-        public boolean complete() {
-            boolean result = true;
-            for ( int i=0; (i<frags.length) && (result); i++ ) result = (frags[i] != null);
-            return result;
-        }
-        
-        public ChannelMessage assemble() {
-            if ( !complete() ) throw new IllegalStateException("Fragments are missing.");
-            int buffersize = 0;
-            for (int i=0; i<frags.length; i++ ) buffersize += frags[i].getLength();
-            XByteBuffer buf = new XByteBuffer(buffersize,false);
-            msg.setMessage(buf);
-            for ( int i=0; i<frags.length; i++ ) {
-                msg.getMessage().append(frags[i].getBytesDirect(),0,frags[i].getLength());
-            }
-            return msg;
-        }
-        
-        public boolean expired(long expire) {
-            return (System.currentTimeMillis()-received)>expire;
-        }
-
-        
-        
-    }
-    
-    public static class FragKey {
-        private byte[] uniqueId;
-        private long received = System.currentTimeMillis();
-        public FragKey(byte[] id ) {
-            this.uniqueId = id;
-        }
-        public int hashCode() {
-            return XByteBuffer.toInt(uniqueId,0);
-        }
-        
-        public boolean equals(Object o ) {
-            if ( o instanceof FragKey ) {
-            return Arrays.equals(uniqueId,((FragKey)o).uniqueId);
-        } else return false;
-
-        }
-        
-        public boolean expired(long expire) {
-            return (System.currentTimeMillis()-received)>expire;
-        }
-
-    }
-    
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ */
+
+package org.apache.catalina.tribes.group.interceptors;
+
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Set;
+
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.group.ChannelInterceptorBase;
+import org.apache.catalina.tribes.group.InterceptorPayload;
+import org.apache.catalina.tribes.io.XByteBuffer;
+
+/**
+ *
+ * The fragmentation interceptor splits up large messages into smaller messages and assembles them on the other end.
+ * This is very useful when you don't want large messages hogging the sending sockets
+ * and smaller messages can make it through.
+ * 
+ * <br><b>Configuration Options</b><br>
+ * OrderInteceptor.expire=<milliseconds> - how long do we keep the fragments in memory and wait for the rest to arrive<b>default=60,000ms -> 60seconds</b>
+ * This setting is useful to avoid OutOfMemoryErrors<br>
+ * OrderInteceptor.maxSize=<max message size> - message size in bytes <b>default=1024*100 (around a tenth of a MB)</b><br>
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class FragmentationInterceptor extends ChannelInterceptorBase {
+    private static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( FragmentationInterceptor.class );
+    
+    protected HashMap fragpieces = new HashMap();
+    private int maxSize = 1024*100;
+    private long expire = 1000 * 60; //one minute expiration
+    protected boolean deepclone = true;
+
+
+    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
+        int size = msg.getMessage().getLength();
+        boolean frag = (size>maxSize) && okToProcess(msg.getOptions());
+        if ( frag ) {
+            frag(destination, msg, payload);
+        } else {
+            msg.getMessage().append(frag);
+            super.sendMessage(destination, msg, payload);
+        }
+    }
+    
+    public void messageReceived(ChannelMessage msg) {
+        boolean isFrag = XByteBuffer.toBoolean(msg.getMessage().getBytesDirect(),msg.getMessage().getLength()-1);
+        msg.getMessage().trim(1);
+        if ( isFrag ) {
+            defrag(msg);
+        } else {
+            super.messageReceived(msg);
+        }
+    }
+
+    
+    public FragCollection getFragCollection(FragKey key, ChannelMessage msg) {
+        FragCollection coll = (FragCollection)fragpieces.get(key);
+        if ( coll == null ) {
+            synchronized (fragpieces) {
+                coll = (FragCollection)fragpieces.get(key);
+                if ( coll == null ) {
+                    coll = new FragCollection(msg);
+                    fragpieces.put(key, coll);
+                }
+            }
+        } 
+        return coll;
+    }
+    
+    public void removeFragCollection(FragKey key) {
+        fragpieces.remove(key);
+    }
+    
+    public void defrag(ChannelMessage msg ) { 
+        FragKey key = new FragKey(msg.getUniqueId());
+        FragCollection coll = getFragCollection(key,msg);
+        coll.addMessage((ChannelMessage)msg.deepclone());
+
+        if ( coll.complete() ) {
+            removeFragCollection(key);
+            ChannelMessage complete = coll.assemble();
+            super.messageReceived(complete);
+            
+        }
+    }
+
+    public void frag(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
+        int size = msg.getMessage().getLength();
+
+        int count = ((size / maxSize )+(size%maxSize==0?0:1));
+        ChannelMessage[] messages = new ChannelMessage[count];
+        int remaining = size;
+        for ( int i=0; i<count; i++ ) {
+            ChannelMessage tmp = (ChannelMessage)msg.clone();
+            int offset = (i*maxSize);
+            int length = Math.min(remaining,maxSize);
+            tmp.getMessage().clear();
+            tmp.getMessage().append(msg.getMessage().getBytesDirect(),offset,length);
+            //add the msg nr
+            //tmp.getMessage().append(XByteBuffer.toBytes(i),0,4);
+            tmp.getMessage().append(i);
+            //add the total nr of messages
+            //tmp.getMessage().append(XByteBuffer.toBytes(count),0,4);
+            tmp.getMessage().append(count);
+            //add true as the frag flag
+            //byte[] flag = XByteBuffer.toBytes(true);
+            //tmp.getMessage().append(flag,0,flag.length);
+            tmp.getMessage().append(true);
+            messages[i] = tmp;
+            remaining -= length;
+            
+        }
+        for ( int i=0; i<messages.length; i++ ) {
+            super.sendMessage(destination,messages[i],payload);
+        }
+    }
+    
+    public void heartbeat() {
+        try {
+            Set set = fragpieces.keySet(); 
+            Object[] keys = set.toArray();
+            for ( int i=0; i<keys.length; i++ ) {
+                FragKey key = (FragKey)keys[i];
+                if ( key != null && key.expired(getExpire()) ) 
+                    removeFragCollection(key);
+            }
+        }catch ( Exception x ) {
+            if ( log.isErrorEnabled() ) {
+                log.error("Unable to perform heartbeat clean up in the frag interceptor",x);
+            }
+        }
+        super.heartbeat();
+    }
+
+    
+
+    public int getMaxSize() {
+        return maxSize;
+    }
+
+    public long getExpire() {
+        return expire;
+    }
+
+    public void setMaxSize(int maxSize) {
+        this.maxSize = maxSize;
+    }
+
+    public void setExpire(long expire) {
+        this.expire = expire;
+    }
+
+    public static class FragCollection {
+        private long received = System.currentTimeMillis();
+        private ChannelMessage msg;
+        private XByteBuffer[] frags;
+        public FragCollection(ChannelMessage msg) {
+            //get the total messages
+            int count = XByteBuffer.toInt(msg.getMessage().getBytesDirect(),msg.getMessage().getLength()-4);
+            frags = new XByteBuffer[count];
+            this.msg = msg;
+        }
+        
+        public void addMessage(ChannelMessage msg) {
+            //remove the total messages
+            msg.getMessage().trim(4);
+            //get the msg nr
+            int nr = XByteBuffer.toInt(msg.getMessage().getBytesDirect(),msg.getMessage().getLength()-4);
+            //remove the msg nr
+            msg.getMessage().trim(4);
+            frags[nr] = msg.getMessage();
+            
+        }
+        
+        public boolean complete() {
+            boolean result = true;
+            for ( int i=0; (i<frags.length) && (result); i++ ) result = (frags[i] != null);
+            return result;
+        }
+        
+        public ChannelMessage assemble() {
+            if ( !complete() ) throw new IllegalStateException("Fragments are missing.");
+            int buffersize = 0;
+            for (int i=0; i<frags.length; i++ ) buffersize += frags[i].getLength();
+            XByteBuffer buf = new XByteBuffer(buffersize,false);
+            msg.setMessage(buf);
+            for ( int i=0; i<frags.length; i++ ) {
+                msg.getMessage().append(frags[i].getBytesDirect(),0,frags[i].getLength());
+            }
+            return msg;
+        }
+        
+        public boolean expired(long expire) {
+            return (System.currentTimeMillis()-received)>expire;
+        }
+
+        
+        
+    }
+    
+    public static class FragKey {
+        private byte[] uniqueId;
+        private long received = System.currentTimeMillis();
+        public FragKey(byte[] id ) {
+            this.uniqueId = id;
+        }
+        public int hashCode() {
+            return XByteBuffer.toInt(uniqueId,0);
+        }
+        
+        public boolean equals(Object o ) {
+            if ( o instanceof FragKey ) {
+            return Arrays.equals(uniqueId,((FragKey)o).uniqueId);
+        } else return false;
+
+        }
+        
+        public boolean expired(long expire) {
+            return (System.currentTimeMillis()-received)>expire;
+        }
+
+    }
+    
 }
\ No newline at end of file

==================================================
MessageDispatch15Interceptor.java
index de69869e19..2515d5913f 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/GzipInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/GzipInterceptor.java
@@ -1,100 +1,100 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- */
-
-package org.apache.catalina.tribes.group.interceptors;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.zip.GZIPInputStream;
-import java.util.zip.GZIPOutputStream;
-
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.group.ChannelInterceptorBase;
-import org.apache.catalina.tribes.group.InterceptorPayload;
-
-
-
-/**
- *
- *
- * @author Filip Hanik
- * @version 1.0
- */
-public class GzipInterceptor extends ChannelInterceptorBase {
-    public static final int DEFAULT_BUFFER_SIZE = 2048;
-    
-    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
-        try {
-            byte[] data = compress(msg.getMessage().getBytes());
-            msg.getMessage().trim(msg.getMessage().getLength());
-            msg.getMessage().append(data,0,data.length);
-            getNext().sendMessage(destination, msg, payload);
-        } catch ( IOException x ) {
-            log.error("Unable to compress byte contents");
-            throw new ChannelException(x);
-        }
-    }
-
-    public void messageReceived(ChannelMessage msg) {
-        try {
-            byte[] data = decompress(msg.getMessage().getBytes());
-            msg.getMessage().trim(msg.getMessage().getLength());
-            msg.getMessage().append(data,0,data.length);
-            getPrevious().messageReceived(msg);
-        } catch ( IOException x ) {
-            log.error("Unable to decompress byte contents",x);
-        }
-    }
-    
-    public static byte[] compress(byte[] data) throws IOException {
-        ByteArrayOutputStream bout = new ByteArrayOutputStream();
-        GZIPOutputStream gout = new GZIPOutputStream(bout);
-        gout.write(data);
-        gout.flush();
-        gout.close();
-        return bout.toByteArray();
-    }
-    
-    /**
-     * @todo Fix to create an automatically growing buffer.
-     * @param data byte[]
-     * @return byte[]
-     * @throws IOException
-     */
-    public static byte[] decompress(byte[] data) throws IOException {
-        ByteArrayInputStream bin = new ByteArrayInputStream(data);
-        GZIPInputStream gin = new GZIPInputStream(bin);
-        byte[] tmp = new byte[DEFAULT_BUFFER_SIZE];
-        int length = gin.read(tmp);
-        byte[] result = new byte[length];
-        System.arraycopy(tmp,0,result,0,length);
-        return result;
-    }
-    
-    public static void main(String[] arg) throws Exception {
-        byte[] data = new byte[1024];
-        Arrays.fill(data,(byte)1);
-        byte[] compress = compress(data);
-        byte[] decompress = decompress(compress);
-        System.out.println("Debug test");
-        
-    }
-    
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ */
+
+package org.apache.catalina.tribes.group.interceptors;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.zip.GZIPInputStream;
+import java.util.zip.GZIPOutputStream;
+
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.group.ChannelInterceptorBase;
+import org.apache.catalina.tribes.group.InterceptorPayload;
+
+
+
+/**
+ *
+ *
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class GzipInterceptor extends ChannelInterceptorBase {
+    public static final int DEFAULT_BUFFER_SIZE = 2048;
+    
+    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
+        try {
+            byte[] data = compress(msg.getMessage().getBytes());
+            msg.getMessage().trim(msg.getMessage().getLength());
+            msg.getMessage().append(data,0,data.length);
+            getNext().sendMessage(destination, msg, payload);
+        } catch ( IOException x ) {
+            log.error("Unable to compress byte contents");
+            throw new ChannelException(x);
+        }
+    }
+
+    public void messageReceived(ChannelMessage msg) {
+        try {
+            byte[] data = decompress(msg.getMessage().getBytes());
+            msg.getMessage().trim(msg.getMessage().getLength());
+            msg.getMessage().append(data,0,data.length);
+            getPrevious().messageReceived(msg);
+        } catch ( IOException x ) {
+            log.error("Unable to decompress byte contents",x);
+        }
+    }
+    
+    public static byte[] compress(byte[] data) throws IOException {
+        ByteArrayOutputStream bout = new ByteArrayOutputStream();
+        GZIPOutputStream gout = new GZIPOutputStream(bout);
+        gout.write(data);
+        gout.flush();
+        gout.close();
+        return bout.toByteArray();
+    }
+    
+    /**
+     * @todo Fix to create an automatically growing buffer.
+     * @param data byte[]
+     * @return byte[]
+     * @throws IOException
+     */
+    public static byte[] decompress(byte[] data) throws IOException {
+        ByteArrayInputStream bin = new ByteArrayInputStream(data);
+        GZIPInputStream gin = new GZIPInputStream(bin);
+        byte[] tmp = new byte[DEFAULT_BUFFER_SIZE];
+        int length = gin.read(tmp);
+        byte[] result = new byte[length];
+        System.arraycopy(tmp,0,result,0,length);
+        return result;
+    }
+    
+    public static void main(String[] arg) throws Exception {
+        byte[] data = new byte[1024];
+        Arrays.fill(data,(byte)1);
+        byte[] compress = compress(data);
+        byte[] decompress = decompress(compress);
+        System.out.println("Debug test");
+        
+    }
+    
+}

==================================================
MessageDispatchInterceptor.java
index 0510218509..03104e29e8 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/MessageDispatch15Interceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/MessageDispatch15Interceptor.java
@@ -1,112 +1,112 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- */
-package org.apache.catalina.tribes.group.interceptors;
-
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.atomic.AtomicLong;
-
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.group.InterceptorPayload;
-import org.apache.catalina.tribes.transport.bio.util.LinkObject;
-import java.util.concurrent.TimeUnit;
-
-/**
- * 
- * Same implementation as the MessageDispatchInterceptor
- * except is ues an atomic long for the currentSize calculation
- * and uses a thread pool for message sending.
- * 
- * @author Filip Hanik
- * @version 1.0
- */
-
-public class MessageDispatch15Interceptor extends MessageDispatchInterceptor {
-
-    protected AtomicLong currentSize = new AtomicLong(0);
-    protected ThreadPoolExecutor executor = null;
-    protected int maxThreads = 10;
-    protected int maxSpareThreads = 2;
-    protected long keepAliveTime = 5000;
-    protected LinkedBlockingQueue<Runnable> runnablequeue = new LinkedBlockingQueue<Runnable>();
-
-    public long getCurrentSize() {
-        return currentSize.get();
-    }
-
-    public long addAndGetCurrentSize(long inc) {
-        return currentSize.addAndGet(inc);
-    }
-
-    public long setAndGetCurrentSize(long value) {
-        currentSize.set(value);
-        return value;
-    }
-    
-    public boolean addToQueue(ChannelMessage msg, Member[] destination, InterceptorPayload payload) {
-        final LinkObject obj = new LinkObject(msg,destination,payload);
-        Runnable r = new Runnable() {
-            public void run() {
-                sendAsyncData(obj);
-            }
-        };
-        executor.execute(r);
-        return true;
-    }
-
-    public LinkObject removeFromQueue() {
-        return null; //not used, thread pool contains its own queue.
-    }
-
-    public void startQueue() {
-        if ( run ) return;
-        executor = new ThreadPoolExecutor(maxSpareThreads,maxThreads,keepAliveTime,TimeUnit.MILLISECONDS,runnablequeue);
-        run = true;
-    }
-
-    public void stopQueue() {
-        run = false;
-        executor.shutdownNow();
-        setAndGetCurrentSize(0);
-        runnablequeue.clear();
-    }
-
-    public long getKeepAliveTime() {
-        return keepAliveTime;
-    }
-
-    public int getMaxSpareThreads() {
-        return maxSpareThreads;
-    }
-
-    public int getMaxThreads() {
-        return maxThreads;
-    }
-
-    public void setKeepAliveTime(long keepAliveTime) {
-        this.keepAliveTime = keepAliveTime;
-    }
-
-    public void setMaxSpareThreads(int maxSpareThreads) {
-        this.maxSpareThreads = maxSpareThreads;
-    }
-
-    public void setMaxThreads(int maxThreads) {
-        this.maxThreads = maxThreads;
-    }
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ */
+package org.apache.catalina.tribes.group.interceptors;
+
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.atomic.AtomicLong;
+
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.group.InterceptorPayload;
+import org.apache.catalina.tribes.transport.bio.util.LinkObject;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * 
+ * Same implementation as the MessageDispatchInterceptor
+ * except is ues an atomic long for the currentSize calculation
+ * and uses a thread pool for message sending.
+ * 
+ * @author Filip Hanik
+ * @version 1.0
+ */
+
+public class MessageDispatch15Interceptor extends MessageDispatchInterceptor {
+
+    protected AtomicLong currentSize = new AtomicLong(0);
+    protected ThreadPoolExecutor executor = null;
+    protected int maxThreads = 10;
+    protected int maxSpareThreads = 2;
+    protected long keepAliveTime = 5000;
+    protected LinkedBlockingQueue<Runnable> runnablequeue = new LinkedBlockingQueue<Runnable>();
+
+    public long getCurrentSize() {
+        return currentSize.get();
+    }
+
+    public long addAndGetCurrentSize(long inc) {
+        return currentSize.addAndGet(inc);
+    }
+
+    public long setAndGetCurrentSize(long value) {
+        currentSize.set(value);
+        return value;
+    }
+    
+    public boolean addToQueue(ChannelMessage msg, Member[] destination, InterceptorPayload payload) {
+        final LinkObject obj = new LinkObject(msg,destination,payload);
+        Runnable r = new Runnable() {
+            public void run() {
+                sendAsyncData(obj);
+            }
+        };
+        executor.execute(r);
+        return true;
+    }
+
+    public LinkObject removeFromQueue() {
+        return null; //not used, thread pool contains its own queue.
+    }
+
+    public void startQueue() {
+        if ( run ) return;
+        executor = new ThreadPoolExecutor(maxSpareThreads,maxThreads,keepAliveTime,TimeUnit.MILLISECONDS,runnablequeue);
+        run = true;
+    }
+
+    public void stopQueue() {
+        run = false;
+        executor.shutdownNow();
+        setAndGetCurrentSize(0);
+        runnablequeue.clear();
+    }
+
+    public long getKeepAliveTime() {
+        return keepAliveTime;
+    }
+
+    public int getMaxSpareThreads() {
+        return maxSpareThreads;
+    }
+
+    public int getMaxThreads() {
+        return maxThreads;
+    }
+
+    public void setKeepAliveTime(long keepAliveTime) {
+        this.keepAliveTime = keepAliveTime;
+    }
+
+    public void setMaxSpareThreads(int maxSpareThreads) {
+        this.maxSpareThreads = maxSpareThreads;
+    }
+
+    public void setMaxThreads(int maxThreads) {
+        this.maxThreads = maxThreads;
+    }
+
 }
\ No newline at end of file

==================================================
NonBlockingCoordinator.java
index fa75355a2b..afcda25db2 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/MessageDispatchInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/MessageDispatchInterceptor.java
@@ -1,202 +1,202 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- */
-
-package org.apache.catalina.tribes.group.interceptors;
-
-import org.apache.catalina.tribes.Channel;
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.group.ChannelInterceptorBase;
-import org.apache.catalina.tribes.group.InterceptorPayload;
-import org.apache.catalina.tribes.transport.bio.util.FastQueue;
-import org.apache.catalina.tribes.transport.bio.util.LinkObject;
-import org.apache.catalina.tribes.UniqueId;
-
-/**
- *
- * The message dispatcher is a way to enable asynchronous communication
- * through a channel. The dispatcher will look for the <code>Channel.SEND_OPTIONS_ASYNCHRONOUS</code>
- * flag to be set, if it is, it will queue the message for delivery and immediately return to the sender.
- * 
- * 
- * 
- * @author Filip Hanik
- * @version 1.0
- */
-public class MessageDispatchInterceptor extends ChannelInterceptorBase implements Runnable {
-    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(MessageDispatchInterceptor.class);
-
-    protected long maxQueueSize = 1024*1024*64; //64MB
-    protected FastQueue queue = new FastQueue();
-    protected boolean run = false;
-    protected Thread msgDispatchThread = null;
-    protected long currentSize = 0;
-    protected boolean useDeepClone = true;
-    protected boolean alwaysSend = true;
-
-    public MessageDispatchInterceptor() {
-        setOptionFlag(Channel.SEND_OPTIONS_ASYNCHRONOUS);
-    }
-
-    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
-        boolean async = (msg.getOptions() & Channel.SEND_OPTIONS_ASYNCHRONOUS) == Channel.SEND_OPTIONS_ASYNCHRONOUS;
-        if ( async && run ) {
-            if ( (getCurrentSize()+msg.getMessage().getLength()) > maxQueueSize ) {
-                if ( alwaysSend ) {
-                    super.sendMessage(destination,msg,payload);
-                    return;
-                } else {
-                    throw new ChannelException("Asynchronous queue is full, reached its limit of " + maxQueueSize +" bytes, current:" + getCurrentSize() + " bytes.");
-                }//end if
-            }//end if
-            //add to queue
-            if ( useDeepClone ) msg = (ChannelMessage)msg.deepclone();
-            if (!addToQueue(msg, destination, payload) ) {
-                throw new ChannelException("Unable to add the message to the async queue, queue bug?");
-            }
-            addAndGetCurrentSize(msg.getMessage().getLength());
-        } else {
-            super.sendMessage(destination, msg, payload);
-        }
-    }
-    
-    public boolean addToQueue(ChannelMessage msg, Member[] destination, InterceptorPayload payload) {
-        return queue.add(msg,destination,payload);
-    }
-    
-    public LinkObject removeFromQueue() {
-        return queue.remove();
-    }
-    
-    public void startQueue() {
-        msgDispatchThread = new Thread(this);
-        msgDispatchThread.setName("MessageDispatchInterceptor.MessageDispatchThread");
-        msgDispatchThread.setDaemon(true);
-        msgDispatchThread.setPriority(Thread.MAX_PRIORITY);
-        queue.setEnabled(true);
-        run = true;
-        msgDispatchThread.start();
-    }
-    
-    public void stopQueue() {
-        run = false;
-        msgDispatchThread.interrupt();
-        queue.setEnabled(false);
-        setAndGetCurrentSize(0);
-    }
-    
-    
-    public void setOptionFlag(int flag) {
-        if ( flag != Channel.SEND_OPTIONS_ASYNCHRONOUS ) log.warn("Warning, you are overriding the asynchronous option flag, this will disable the Channel.SEND_OPTIONS_ASYNCHRONOUS that other apps might use.");
-        super.setOptionFlag(flag);
-    }
-
-    public void setMaxQueueSize(long maxQueueSize) {
-        this.maxQueueSize = maxQueueSize;
-    }
-
-    public void setUseDeepClone(boolean useDeepClone) {
-        this.useDeepClone = useDeepClone;
-    }
-
-    public long getMaxQueueSize() {
-        return maxQueueSize;
-    }
-
-    public boolean getUseDeepClone() {
-        return useDeepClone;
-    }
-    
-    public long getCurrentSize() {
-        return currentSize;
-    }
-    
-    public synchronized long addAndGetCurrentSize(long inc) {
-        currentSize += inc;
-        return currentSize;
-    }
-    
-    public synchronized long setAndGetCurrentSize(long value) {
-        currentSize = value;
-        return value;
-    }
-
-    public void start(int svc) throws ChannelException {
-        //start the thread
-        if (!run ) {
-            synchronized (this) {
-                if ( !run && ((svc & Channel.SND_TX_SEQ)==Channel.SND_TX_SEQ) ) {//only start with the sender
-                    startQueue();
-                }//end if
-            }//sync
-        }//end if
-        super.start(svc);
-    }
-
-    
-    public void stop(int svc) throws ChannelException {
-        //stop the thread
-        if ( run ) {
-            synchronized (this) {
-                if ( run && ((svc & Channel.SND_TX_SEQ)==Channel.SND_TX_SEQ)) {
-                    stopQueue();
-                }//end if
-            }//sync
-        }//end if
-
-        super.stop(svc);
-    }
-    
-    public void run() {
-        while ( run ) {
-            LinkObject link = removeFromQueue();
-            if ( link == null ) continue; //should not happen unless we exceed wait time
-            while ( link != null && run ) {
-                link = sendAsyncData(link);
-            }//while
-        }//while
-    }//run
-
-    protected LinkObject sendAsyncData(LinkObject link) {
-        ChannelMessage msg = link.data();
-        Member[] destination = link.getDestination();
-        try {
-            super.sendMessage(destination,msg,null);
-            try {
-                if ( link.getHandler() != null ) link.getHandler().handleCompletion(new UniqueId(msg.getUniqueId())); 
-            } catch ( Exception ex ) {
-                log.error("Unable to report back completed message.",ex);
-            }
-        } catch ( Exception x ) {
-            ChannelException cx = null;
-            if ( x instanceof ChannelException ) cx = (ChannelException)x;
-            else cx = new ChannelException(x);
-            if ( log.isDebugEnabled() ) log.debug("Error while processing async message.",x);
-            try {
-                if (link.getHandler() != null) link.getHandler().handleError(cx, new UniqueId(msg.getUniqueId()));
-            } catch ( Exception ex ) {
-                log.error("Unable to report back error message.",ex);
-            }
-        } finally {
-            addAndGetCurrentSize(-msg.getMessage().getLength());
-            link = link.next();
-        }//try
-        return link;
-    }
-
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ */
+
+package org.apache.catalina.tribes.group.interceptors;
+
+import org.apache.catalina.tribes.Channel;
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.group.ChannelInterceptorBase;
+import org.apache.catalina.tribes.group.InterceptorPayload;
+import org.apache.catalina.tribes.transport.bio.util.FastQueue;
+import org.apache.catalina.tribes.transport.bio.util.LinkObject;
+import org.apache.catalina.tribes.UniqueId;
+
+/**
+ *
+ * The message dispatcher is a way to enable asynchronous communication
+ * through a channel. The dispatcher will look for the <code>Channel.SEND_OPTIONS_ASYNCHRONOUS</code>
+ * flag to be set, if it is, it will queue the message for delivery and immediately return to the sender.
+ * 
+ * 
+ * 
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class MessageDispatchInterceptor extends ChannelInterceptorBase implements Runnable {
+    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(MessageDispatchInterceptor.class);
+
+    protected long maxQueueSize = 1024*1024*64; //64MB
+    protected FastQueue queue = new FastQueue();
+    protected boolean run = false;
+    protected Thread msgDispatchThread = null;
+    protected long currentSize = 0;
+    protected boolean useDeepClone = true;
+    protected boolean alwaysSend = true;
+
+    public MessageDispatchInterceptor() {
+        setOptionFlag(Channel.SEND_OPTIONS_ASYNCHRONOUS);
+    }
+
+    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
+        boolean async = (msg.getOptions() & Channel.SEND_OPTIONS_ASYNCHRONOUS) == Channel.SEND_OPTIONS_ASYNCHRONOUS;
+        if ( async && run ) {
+            if ( (getCurrentSize()+msg.getMessage().getLength()) > maxQueueSize ) {
+                if ( alwaysSend ) {
+                    super.sendMessage(destination,msg,payload);
+                    return;
+                } else {
+                    throw new ChannelException("Asynchronous queue is full, reached its limit of " + maxQueueSize +" bytes, current:" + getCurrentSize() + " bytes.");
+                }//end if
+            }//end if
+            //add to queue
+            if ( useDeepClone ) msg = (ChannelMessage)msg.deepclone();
+            if (!addToQueue(msg, destination, payload) ) {
+                throw new ChannelException("Unable to add the message to the async queue, queue bug?");
+            }
+            addAndGetCurrentSize(msg.getMessage().getLength());
+        } else {
+            super.sendMessage(destination, msg, payload);
+        }
+    }
+    
+    public boolean addToQueue(ChannelMessage msg, Member[] destination, InterceptorPayload payload) {
+        return queue.add(msg,destination,payload);
+    }
+    
+    public LinkObject removeFromQueue() {
+        return queue.remove();
+    }
+    
+    public void startQueue() {
+        msgDispatchThread = new Thread(this);
+        msgDispatchThread.setName("MessageDispatchInterceptor.MessageDispatchThread");
+        msgDispatchThread.setDaemon(true);
+        msgDispatchThread.setPriority(Thread.MAX_PRIORITY);
+        queue.setEnabled(true);
+        run = true;
+        msgDispatchThread.start();
+    }
+    
+    public void stopQueue() {
+        run = false;
+        msgDispatchThread.interrupt();
+        queue.setEnabled(false);
+        setAndGetCurrentSize(0);
+    }
+    
+    
+    public void setOptionFlag(int flag) {
+        if ( flag != Channel.SEND_OPTIONS_ASYNCHRONOUS ) log.warn("Warning, you are overriding the asynchronous option flag, this will disable the Channel.SEND_OPTIONS_ASYNCHRONOUS that other apps might use.");
+        super.setOptionFlag(flag);
+    }
+
+    public void setMaxQueueSize(long maxQueueSize) {
+        this.maxQueueSize = maxQueueSize;
+    }
+
+    public void setUseDeepClone(boolean useDeepClone) {
+        this.useDeepClone = useDeepClone;
+    }
+
+    public long getMaxQueueSize() {
+        return maxQueueSize;
+    }
+
+    public boolean getUseDeepClone() {
+        return useDeepClone;
+    }
+    
+    public long getCurrentSize() {
+        return currentSize;
+    }
+    
+    public synchronized long addAndGetCurrentSize(long inc) {
+        currentSize += inc;
+        return currentSize;
+    }
+    
+    public synchronized long setAndGetCurrentSize(long value) {
+        currentSize = value;
+        return value;
+    }
+
+    public void start(int svc) throws ChannelException {
+        //start the thread
+        if (!run ) {
+            synchronized (this) {
+                if ( !run && ((svc & Channel.SND_TX_SEQ)==Channel.SND_TX_SEQ) ) {//only start with the sender
+                    startQueue();
+                }//end if
+            }//sync
+        }//end if
+        super.start(svc);
+    }
+
+    
+    public void stop(int svc) throws ChannelException {
+        //stop the thread
+        if ( run ) {
+            synchronized (this) {
+                if ( run && ((svc & Channel.SND_TX_SEQ)==Channel.SND_TX_SEQ)) {
+                    stopQueue();
+                }//end if
+            }//sync
+        }//end if
+
+        super.stop(svc);
+    }
+    
+    public void run() {
+        while ( run ) {
+            LinkObject link = removeFromQueue();
+            if ( link == null ) continue; //should not happen unless we exceed wait time
+            while ( link != null && run ) {
+                link = sendAsyncData(link);
+            }//while
+        }//while
+    }//run
+
+    protected LinkObject sendAsyncData(LinkObject link) {
+        ChannelMessage msg = link.data();
+        Member[] destination = link.getDestination();
+        try {
+            super.sendMessage(destination,msg,null);
+            try {
+                if ( link.getHandler() != null ) link.getHandler().handleCompletion(new UniqueId(msg.getUniqueId())); 
+            } catch ( Exception ex ) {
+                log.error("Unable to report back completed message.",ex);
+            }
+        } catch ( Exception x ) {
+            ChannelException cx = null;
+            if ( x instanceof ChannelException ) cx = (ChannelException)x;
+            else cx = new ChannelException(x);
+            if ( log.isDebugEnabled() ) log.debug("Error while processing async message.",x);
+            try {
+                if (link.getHandler() != null) link.getHandler().handleError(cx, new UniqueId(msg.getUniqueId()));
+            } catch ( Exception ex ) {
+                log.error("Unable to report back error message.",ex);
+            }
+        } finally {
+            addAndGetCurrentSize(-msg.getMessage().getLength());
+            link = link.next();
+        }//try
+        return link;
+    }
+
+
+}

==================================================
OrderInterceptor.java
index 3e0b24494d..8052842b3d 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java
@@ -1,840 +1,840 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- */
-package org.apache.catalina.tribes.group.interceptors;
-
-import java.util.concurrent.atomic.AtomicBoolean;
-
-import org.apache.catalina.tribes.Channel;
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelInterceptor;
-import org.apache.catalina.tribes.ChannelInterceptor.InterceptorEvent;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.UniqueId;
-import org.apache.catalina.tribes.group.AbsoluteOrder;
-import org.apache.catalina.tribes.group.ChannelInterceptorBase;
-import org.apache.catalina.tribes.group.InterceptorPayload;
-import org.apache.catalina.tribes.io.ChannelData;
-import org.apache.catalina.tribes.io.XByteBuffer;
-import org.apache.catalina.tribes.membership.MemberImpl;
-import org.apache.catalina.tribes.membership.Membership;
-import org.apache.catalina.tribes.util.Arrays;
-import org.apache.catalina.tribes.util.UUIDGenerator;
-
-/**
- * <p>Title: Auto merging leader election algorithm</p>
- *
- * <p>Description: Implementation of a simple coordinator algorithm that not only selects a coordinator,
- *    it also merges groups automatically when members are discovered that werent part of the 
- *    </p>
- * <p>This algorithm is non blocking meaning it allows for transactions while the coordination phase is going on
- * </p>
- * <p>This implementation is based on a home brewed algorithm that uses the AbsoluteOrder of a membership
- * to pass a token ring of the current membership.<br>
- * This is not the same as just using AbsoluteOrder! Consider the following scenario:<br>
- * Nodes, A,B,C,D,E on a network, in that priority. AbsoluteOrder will only work if all
- * nodes are receiving pings from all the other nodes. 
- * meaning, that node{i} receives pings from node{all}-node{i}<br>
- * but the following could happen if a multicast problem occurs.
- * A has members {B,C,D}<br>
- * B has members {A,C}<br>
- * C has members {D,E}<br>
- * D has members {A,B,C,E}<br>
- * E has members {A,C,D}<br>
- * Because the default Tribes membership implementation, relies on the multicast packets to 
- * arrive at all nodes correctly, there is nothing guaranteeing that it will.<br>
- * <br>
- * To best explain how this algorithm works, lets take the above example:
- * For simplicity we assume that a send operation is O(1) for all nodes, although this algorithm will work
- * where messages overlap, as they all depend on absolute order<br>
- * Scenario 1: A,B,C,D,E all come online at the same time
- * Eval phase, A thinks of itself as leader, B thinks of A as leader,
- * C thinks of itself as leader, D,E think of A as leader<br>
- * Token phase:<br>
- * (1) A sends out a message X{A-ldr, A-src, mbrs-A,B,C,D} to B where X is the id for the message(and the view)<br>
- * (1) C sends out a message Y{C-ldr, C-src, mbrs-C,D,E} to D where Y is the id for the message(and the view)<br>
- * (2) B receives X{A-ldr, A-src, mbrs-A,B,C,D}, sends X{A-ldr, A-src, mbrs-A,B,C,D} to C <br>
- * (2) D receives Y{C-ldr, C-src, mbrs-C,D,E} D is aware of A,B, sends Y{A-ldr, C-src, mbrs-A,B,C,D,E} to E<br>
- * (3) C receives X{A-ldr, A-src, mbrs-A,B,C,D}, sends X{A-ldr, A-src, mbrs-A,B,C,D,E} to D<br>
- * (3) E receives Y{A-ldr, C-src, mbrs-A,B,C,D,E} sends Y{A-ldr, C-src, mbrs-A,B,C,D,E} to A<br>
- * (4) D receives X{A-ldr, A-src, mbrs-A,B,C,D,E} sends sends X{A-ldr, A-src, mbrs-A,B,C,D,E} to A<br>
- * (4) A receives Y{A-ldr, C-src, mbrs-A,B,C,D,E}, holds the message, add E to its list of members<br>
- * (5) A receives X{A-ldr, A-src, mbrs-A,B,C,D,E} <br>
- * At this point, the state looks like<br>
- * A - {A-ldr, mbrs-A,B,C,D,E, id=X}<br>
- * B - {A-ldr, mbrs-A,B,C,D, id=X}<br>
- * C - {A-ldr, mbrs-A,B,C,D,E, id=X}<br>
- * D - {A-ldr, mbrs-A,B,C,D,E, id=X}<br>
- * E - {A-ldr, mbrs-A,B,C,D,E, id=Y}<br>
- * <br>
- * A message doesn't stop until it reaches its original sender, unless its dropped by a higher leader.
- * As you can see, E still thinks the viewId=Y, which is not correct. But at this point we have 
- * arrived at the same membership and all nodes are informed of each other.<br>
- * To synchronize the rest we simply perform the following check at A when A receives X:<br>
- * Original X{A-ldr, A-src, mbrs-A,B,C,D} == Arrived X{A-ldr, A-src, mbrs-A,B,C,D,E}<br>
- * Since the condition is false, A, will resend the token, and A sends X{A-ldr, A-src, mbrs-A,B,C,D,E} to B
- * When A receives X again, the token is complete. <br>
- * Optionally, A can send a message X{A-ldr, A-src, mbrs-A,B,C,D,E confirmed} to A,B,C,D,E who then
- * install and accept the view.
- * </p>
- * <p>
- * Lets assume that C1 arrives, C1 has lower priority than C, but higher priority than D.<br>
- * Lets also assume that C1 sees the following view {B,D,E}<br>
- * C1 waits for a token to arrive. When the token arrives, the same scenario as above will happen.<br>
- * In the scenario where C1 sees {D,E} and A,B,C can not see C1, no token will ever arrive.<br>
- * In this case, C1 sends a Z{C1-ldr, C1-src, mbrs-C1,D,E} to D<br>
- * D receives Z{C1-ldr, C1-src, mbrs-C1,D,E} and sends Z{A-ldr, C1-src, mbrs-A,B,C,C1,D,E} to E<br>
- * E receives Z{A-ldr, C1-src, mbrs-A,B,C,C1,D,E} and sends it to A<br>
- * A sends Z{A-ldr, A-src, mbrs-A,B,C,C1,D,E} to B and the chain continues until A receives the token again.
- * At that time A optionally sends out Z{A-ldr, A-src, mbrs-A,B,C,C1,D,E, confirmed} to A,B,C,C1,D,E
- * </p>
- * <p>To ensure that the view gets implemented at all nodes at the same time, 
- *    A will send out a VIEW_CONF message, this is the 'confirmed' message that is optional above.
- * <p>Ideally, the interceptor below this one would be the TcpFailureDetector to ensure correct memberships</p>
- *
- * <p>The example above, of course can be simplified with a finite statemachine:<br>
- * But I suck at writing state machines, my head gets all confused. One day I will document this algorithm though.<br>
- * Maybe I'll do a state diagram :)
- * </p>
- * <h2>State Diagrams</h2>
- * <a href="http://people.apache.org/~fhanik/tribes/docs/leader-election-initiate-election.jpg">Initiate an election</a><br><br>
- * <a href="http://people.apache.org/~fhanik/tribes/docs/leader-election-message-arrives.jpg">Receive an election message</a><br><br>
- * 
- * @author Filip Hanik
- * @version 1.0
- * 
- * 
- * 
- */
-public class NonBlockingCoordinator extends ChannelInterceptorBase {
-    
-    /**
-     * header for a coordination message
-     */
-    protected static final byte[] COORD_HEADER = new byte[] {-86, 38, -34, -29, -98, 90, 65, 63, -81, -122, -6, -110, 99, -54, 13, 63};
-    /**
-     * Coordination request
-     */
-    protected static final byte[] COORD_REQUEST = new byte[] {104, -95, -92, -42, 114, -36, 71, -19, -79, 20, 122, 101, -1, -48, -49, 30};
-    /**
-     * Coordination confirmation, for blocking installations
-     */
-    protected static final byte[] COORD_CONF = new byte[] {67, 88, 107, -86, 69, 23, 76, -70, -91, -23, -87, -25, -125, 86, 75, 20};
-    
-    /**
-     * Alive message
-     */
-    protected static final byte[] COORD_ALIVE = new byte[] {79, -121, -25, -15, -59, 5, 64, 94, -77, 113, -119, -88, 52, 114, -56, -46,
-                                                            -18, 102, 10, 34, -127, -9, 71, 115, -70, 72, -101, 88, 72, -124, 127, 111,
-                                                            74, 76, -116, 50, 111, 103, 65, 3, -77, 51, -35, 0, 119, 117, 9, -26,
-                                                            119, 50, -75, -105, -102, 36, 79, 37, -68, -84, -123, 15, -22, -109, 106, -55};
-    /**
-     * Time to wait for coordination timeout
-     */
-    protected long waitForCoordMsgTimeout = 15000;
-    /**
-     * Our current view
-     */
-    protected Membership view = null;
-    /**
-     * Out current viewId
-     */
-    protected UniqueId viewId;
-
-    /**
-     * Our nonblocking membership
-     */
-    protected Membership membership = null;
-    
-    /**
-     * indicates that we are running an election 
-     * and this is the one we are running
-     */
-    protected UniqueId suggestedviewId;
-    protected Membership suggestedView;
-    
-    protected boolean started = false;
-    protected final int startsvc = 0xFFFF;
-    
-    protected Object electionMutex = new Object();
-    
-    protected AtomicBoolean coordMsgReceived = new AtomicBoolean(false);
-    
-    public NonBlockingCoordinator() {
-        super();
-    }
-    
-//============================================================================================================    
-//              COORDINATION HANDLING
-//============================================================================================================
-    
-    public void startElection(boolean force) throws ChannelException {
-        synchronized (electionMutex) {
-            MemberImpl local = (MemberImpl)getLocalMember(false);
-            MemberImpl[] others = (MemberImpl[])membership.getMembers();
-            fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_START_ELECT,this,"Election initated"));
-            if ( others.length == 0 ) {
-                this.viewId = new UniqueId(UUIDGenerator.randomUUID(false));
-                this.view = new Membership(local,AbsoluteOrder.comp, true);
-                this.handleViewConf(this.createElectionMsg(local,others,local),local,view);
-                return; //the only member, no need for an election
-            }
-            if ( suggestedviewId != null ) {
-                
-                if ( view != null && Arrays.diff(view,suggestedView,local).length == 0 &&  Arrays.diff(suggestedView,view,local).length == 0) {
-                    suggestedviewId = null;
-                    suggestedView = null;
-                    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED,this,"Election abandoned, running election matches view"));
-                } else {
-                    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED,this,"Election abandoned, election running"));
-                }
-                return; //election already running, I'm not allowed to have two of them
-            }
-            if ( view != null && Arrays.diff(view,membership,local).length == 0 &&  Arrays.diff(membership,view,local).length == 0) {
-                fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED,this,"Election abandoned, view matches membership"));
-                return; //already have this view installed
-            }            
-            int prio = AbsoluteOrder.comp.compare(local,others[0]);
-            MemberImpl leader = ( prio < 0 )?local:others[0];//am I the leader in my view?
-            if ( local.equals(leader) || force ) {
-                CoordinationMessage msg = createElectionMsg(local, others, leader);
-                suggestedviewId = msg.getId();
-                suggestedView = new Membership(local,AbsoluteOrder.comp,true);
-                Arrays.fill(suggestedView,msg.getMembers());
-                fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_PROCESS_ELECT,this,"Election, sending request"));
-                sendElectionMsg(local,others[0],msg);
-            } else {
-                try {
-                    coordMsgReceived.set(false);
-                    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_WAIT_FOR_MSG,this,"Election, waiting for request"));
-                    electionMutex.wait(waitForCoordMsgTimeout);
-                }catch ( InterruptedException x ) {
-                    Thread.currentThread().interrupted();
-                }
-                if ( suggestedviewId == null && (!coordMsgReceived.get())) {
-                    //no message arrived, send the coord msg
-//                    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_WAIT_FOR_MSG,this,"Election, waiting timed out."));
-//                    startElection(true);
-                    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED,this,"Election abandoned, waiting timed out."));
-                } else {
-                    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED,this,"Election abandoned, received a message"));
-                }
-            }//end if
-            
-        }
-    }
-
-    private CoordinationMessage createElectionMsg(MemberImpl local, MemberImpl[] others, MemberImpl leader) {
-        Membership m = new Membership(local,AbsoluteOrder.comp,true);
-        Arrays.fill(m,others);
-        MemberImpl[] mbrs = m.getMembers();
-        m.reset(); 
-        CoordinationMessage msg = new CoordinationMessage(leader, local, mbrs,new UniqueId(UUIDGenerator.randomUUID(true)), this.COORD_REQUEST);
-        return msg;
-    }
-
-    protected void sendElectionMsg(MemberImpl local, MemberImpl next, CoordinationMessage msg) throws ChannelException {
-        fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_SEND_MSG,this,"Sending election message to("+next.getName()+")"));
-        super.sendMessage(new Member[] {next}, createData(msg, local), null);
-    }
-    
-    protected void sendElectionMsgToNextInline(MemberImpl local, CoordinationMessage msg) throws ChannelException { 
-        int next = Arrays.nextIndex(local,msg.getMembers());
-        int current = next;
-        msg.leader = msg.getMembers()[0];
-        boolean sent =  false;
-        while ( !sent && current >= 0 ) {
-            try {
-                sendElectionMsg(local, (MemberImpl) msg.getMembers()[current], msg);
-                sent = true;
-            }catch ( ChannelException x  ) {
-                log.warn("Unable to send election message to:"+msg.getMembers()[current]);
-                current = Arrays.nextIndex(msg.getMembers()[current],msg.getMembers());
-                if ( current == next ) throw x;
-            }
-        }
-    }
-    
-    public Member getNextInLine(MemberImpl local, MemberImpl[] others) {
-        MemberImpl result = null;
-        for ( int i=0; i<others.length; i++ ) {
-            
-        }
-        return result;
-    }
-    
-    public ChannelData createData(CoordinationMessage msg, MemberImpl local) {
-        msg.write();
-        ChannelData data = new ChannelData(true);
-        data.setAddress(local);
-        data.setMessage(msg.getBuffer());
-        data.setOptions(Channel.SEND_OPTIONS_USE_ACK);
-        data.setTimestamp(System.currentTimeMillis());
-        return data;
-    }
-    
-    protected void viewChange(UniqueId viewId, Member[] view) {
-        //invoke any listeners
-    }
-    
-    protected boolean alive(Member mbr) {
-        return TcpFailureDetector.memberAlive(mbr,
-                                              COORD_ALIVE,
-                                              false,
-                                              false,
-                                              waitForCoordMsgTimeout,
-                                              waitForCoordMsgTimeout,
-                                              getOptionFlag());
-    }
-    
-    protected Membership mergeOnArrive(CoordinationMessage msg, Member sender) {
-        fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_PRE_MERGE,this,"Pre merge"));
-        MemberImpl local = (MemberImpl)getLocalMember(false);
-        Membership merged = new Membership(local,AbsoluteOrder.comp,true);
-        Arrays.fill(merged,msg.getMembers());
-        Arrays.fill(merged,getMembers());
-        Member[] diff = Arrays.diff(merged,membership,local);
-        for ( int i=0; i<diff.length; i++ ) {
-            if (!alive(diff[i])) merged.removeMember((MemberImpl)diff[i]);
-            else memberAdded(diff[i],false);
-        }
-        fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_POST_MERGE,this,"Post merge"));
-        return merged;
-    }
-    
-    protected void processCoordMessage(CoordinationMessage msg, Member sender) throws ChannelException {
-        if ( !coordMsgReceived.get() ) {
-            coordMsgReceived.set(true);
-            synchronized (electionMutex) { electionMutex.notifyAll();}
-        } 
-        msg.timestamp = System.currentTimeMillis();
-        Membership merged = mergeOnArrive(msg, sender);
-        if (isViewConf(msg)) handleViewConf(msg, sender, merged);
-        else handleToken(msg, sender, merged);
-        ClassLoader loader;
-
-    }
-    
-    protected void handleToken(CoordinationMessage msg, Member sender,Membership merged) throws ChannelException {
-        MemberImpl local = (MemberImpl)getLocalMember(false);
-        if ( local.equals(msg.getSource()) ) {
-            //my message msg.src=local
-            handleMyToken(local, msg, sender,merged);
-        } else {
-            handleOtherToken(local, msg, sender,merged);
-        }
-    }
-    
-    protected void handleMyToken(MemberImpl local, CoordinationMessage msg, Member sender,Membership merged) throws ChannelException {
-        if ( local.equals(msg.getLeader()) ) {
-            //no leadership change
-            if ( Arrays.sameMembers(msg.getMembers(),merged.getMembers()) ) {
-                msg.type = COORD_CONF;
-                super.sendMessage(Arrays.remove(msg.getMembers(),local),createData(msg,local),null);
-                handleViewConf(msg,local,merged);
-            } else {
-                //membership change
-                suggestedView = new Membership(local,AbsoluteOrder.comp,true);
-                suggestedviewId = msg.getId();
-                Arrays.fill(suggestedView,merged.getMembers());
-                msg.view = (MemberImpl[])merged.getMembers();
-                sendElectionMsgToNextInline(local,msg);
-            }
-        } else {
-            //leadership change
-            suggestedView = null;
-            suggestedviewId = null;
-            msg.view = (MemberImpl[])merged.getMembers();
-            sendElectionMsgToNextInline(local,msg);
-        }
-    }
-    
-    protected void handleOtherToken(MemberImpl local, CoordinationMessage msg, Member sender,Membership merged) throws ChannelException {
-        if ( local.equals(msg.getLeader()) ) {
-            //I am the new leader
-            //startElection(false);
-        } else {
-            msg.view = (MemberImpl[])merged.getMembers();
-            sendElectionMsgToNextInline(local,msg);
-        }
-    }
-    
-    protected void handleViewConf(CoordinationMessage msg, Member sender,Membership merged) throws ChannelException {
-        if ( viewId != null && msg.getId().equals(viewId) ) return;//we already have this view
-        view = new Membership((MemberImpl)getLocalMember(false),AbsoluteOrder.comp,true);
-        Arrays.fill(view,msg.getMembers());
-        viewId = msg.getId();
-        
-        if ( viewId.equals(suggestedviewId) ) {
-            suggestedView = null;
-            suggestedviewId = null;
-        }
-        
-        if (suggestedView != null && AbsoluteOrder.comp.compare(suggestedView.getMembers()[0],merged.getMembers()[0])<0 ) {
-            suggestedView = null;
-            suggestedviewId = null;
-        }
-        
-        viewChange(viewId,view.getMembers());
-        fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_CONF_RX,this,"Accepted View"));
-        
-        if ( suggestedviewId == null && hasHigherPriority(merged.getMembers(),membership.getMembers()) ) {
-            startElection(false);
-        }
-    }
-    
-    protected boolean isViewConf(CoordinationMessage msg) {
-        return Arrays.contains(msg.getType(),0,COORD_CONF,0,COORD_CONF.length);
-    }
-    
-    protected boolean hasHigherPriority(Member[] complete, Member[] local) {
-        if ( local == null || local.length == 0 ) return false;
-        if ( complete == null || complete.length == 0 ) return true;
-        AbsoluteOrder.absoluteOrder(complete);
-        AbsoluteOrder.absoluteOrder(local);
-        return (AbsoluteOrder.comp.compare(complete[0],local[0]) > 0);
-        
-    }
-
-    
-    /**
-     * Returns coordinator if one is available
-     * @return Member
-     */
-    public Member getCoordinator() {
-        return (view != null && view.hasMembers()) ? view.getMembers()[0] : null;
-    }
-    
-    public Member[] getView() {
-        return (view != null && view.hasMembers()) ? view.getMembers() : new Member[0];
-    }
-    
-    public UniqueId getViewId() {
-        return viewId;
-    }
-    
-    /**
-    * Block in/out messages while a election is going on
-    */
-   protected void halt() {
-
-   }
-
-   /**
-    * Release lock for in/out messages election is completed
-    */
-   protected void release() {
-
-   }
-
-   /**
-    * Wait for an election to end
-    */
-   protected void waitForRelease() {
-
-   }
-
-    
-//============================================================================================================    
-//              OVERRIDDEN METHODS FROM CHANNEL INTERCEPTOR BASE    
-//============================================================================================================
-    public void start(int svc) throws ChannelException {
-            if (membership == null) setupMembership();
-            if (started)return;
-            fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_START, this, "Before start"));
-            super.start(startsvc);
-            started = true;
-            if (view == null) view = new Membership( (MemberImpl)super.getLocalMember(true), AbsoluteOrder.comp, true);
-            fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_START, this, "After start"));
-            startElection(false);
-    }
-
-    public void stop(int svc) throws ChannelException {
-        try {
-            halt();
-            synchronized (electionMutex) {
-                if (!started)return;
-                started = false;
-                fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_STOP, this, "Before stop"));
-                super.stop(startsvc);
-                this.view = null;
-                this.viewId = null;
-                this.suggestedView = null;
-                this.suggestedviewId = null;
-                this.membership.reset();
-                fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_STOP, this, "After stop"));
-            }
-        }finally {
-            release();
-        }
-    }
-    
-    
-    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
-        waitForRelease();
-        super.sendMessage(destination, msg, payload);
-    }
-
-    public void messageReceived(ChannelMessage msg) {
-        if ( Arrays.contains(msg.getMessage().getBytesDirect(),0,COORD_ALIVE,0,COORD_ALIVE.length) ) {
-            //ignore message, its an alive message
-            fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_MSG_ARRIVE,this,"Alive Message"));
-
-        } else if ( Arrays.contains(msg.getMessage().getBytesDirect(),0,COORD_HEADER,0,COORD_HEADER.length) ) {
-            try {
-                CoordinationMessage cmsg = new CoordinationMessage(msg.getMessage());
-                Member[] cmbr = cmsg.getMembers();
-                fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_MSG_ARRIVE,this,"Coord Msg Arrived("+Arrays.toNameString(cmbr)+")"));
-                processCoordMessage(cmsg, msg.getAddress());
-            }catch ( ChannelException x ) {
-                log.error("Error processing coordination message. Could be fatal.",x);
-            }
-        } else {
-            super.messageReceived(msg);
-        }
-    }
-
-    public boolean accept(ChannelMessage msg) {
-        return super.accept(msg);
-    }
-
-    public void memberAdded(Member member) {
-        memberAdded(member,true);
-    }
-
-    public void memberAdded(Member member,boolean elect) {
-        try {
-            if ( membership == null ) setupMembership();
-            if ( membership.memberAlive((MemberImpl)member) ) super.memberAdded(member);
-            try {
-                fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_MBR_ADD,this,"Member add("+member.getName()+")"));
-                if (started && elect) startElection(false);
-            }catch ( ChannelException x ) {
-                log.error("Unable to start election when member was added.",x);
-            }
-        }finally {
-        }
-        
-    }
-
-    public void memberDisappeared(Member member) {
-        try {
-            
-            membership.removeMember((MemberImpl)member);
-            super.memberDisappeared(member);
-            try {
-                fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_MBR_DEL,this,"Member remove("+member.getName()+")"));
-                if ( started && (isCoordinator() || isHighest()) ) 
-                    startElection(true); //to do, if a member disappears, only the coordinator can start
-            }catch ( ChannelException x ) {
-                log.error("Unable to start election when member was removed.",x);
-            }
-        }finally {
-        }
-    }
-    
-    public boolean isHighest() {
-        Member local = getLocalMember(false);
-        if ( membership.getMembers().length == 0 ) return true;
-        else return AbsoluteOrder.comp.compare(local,membership.getMembers()[0])<=0;
-    }
-    
-    public boolean isCoordinator() {
-        Member coord = getCoordinator();
-        return coord != null && getLocalMember(false).equals(coord);
-    }
-
-    public void heartbeat() {
-        try {
-            MemberImpl local = (MemberImpl)getLocalMember(false);
-            if ( view != null && (Arrays.diff(view,membership,local).length != 0 ||  Arrays.diff(membership,view,local).length != 0) ) {
-                if ( isHighest() ) {
-                    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_START_ELECT, this,
-                                                               "Heartbeat found inconsistency, restart election"));
-                    startElection(true);
-                }            
-            }
-        } catch ( Exception x  ){
-            log.error("Unable to perform heartbeat.",x);
-        } finally {
-            super.heartbeat();
-        }
-    }
-
-    /**
-     * has members
-     */
-    public boolean hasMembers() {
-        
-        return membership.hasMembers();
-    }
-
-    /**
-     * Get all current cluster members
-     * @return all members or empty array
-     */
-    public Member[] getMembers() {
-        
-        return membership.getMembers();
-    }
-
-    /**
-     *
-     * @param mbr Member
-     * @return Member
-     */
-    public Member getMember(Member mbr) {
-        
-        return membership.getMember(mbr);
-    }
-
-    /**
-     * Return the member that represents this node.
-     *
-     * @return Member
-     */
-    public Member getLocalMember(boolean incAlive) {
-        Member local = super.getLocalMember(incAlive);
-        if ( view == null && (local != null)) setupMembership();
-        return local;
-    }
-    
-    protected synchronized void setupMembership() {
-        if ( membership == null ) {
-            membership  = new Membership((MemberImpl)super.getLocalMember(true),AbsoluteOrder.comp,false);
-        }
-    }
-    
-    
-//============================================================================================================    
-//              HELPER CLASSES FOR COORDINATION
-//============================================================================================================
-    
-    
-   
-    
-    public static class CoordinationMessage {
-        //X{A-ldr, A-src, mbrs-A,B,C,D}
-        protected XByteBuffer buf;
-        protected MemberImpl leader;
-        protected MemberImpl source;
-        protected MemberImpl[] view;
-        protected UniqueId id;
-        protected byte[] type;
-        protected long timestamp = System.currentTimeMillis();
-        
-        public CoordinationMessage(XByteBuffer buf) {
-            this.buf = buf;
-            parse();
-        }
-
-        public CoordinationMessage(MemberImpl leader,
-                                   MemberImpl source, 
-                                   MemberImpl[] view,
-                                   UniqueId id,
-                                   byte[] type) {
-            this.buf = new XByteBuffer(4096,false);
-            this.leader = leader;
-            this.source = source;
-            this.view = view;
-            this.id = id;
-            this.type = type;
-            this.write();
-        }
-        
-
-        public byte[] getHeader() {
-            return NonBlockingCoordinator.COORD_HEADER;
-        }
-        
-        public MemberImpl getLeader() {
-            if ( leader == null ) parse();
-            return leader;
-        }
-        
-        public MemberImpl getSource() {
-            if ( source == null ) parse();
-            return source;
-        }
-        
-        public UniqueId getId() {
-            if ( id == null ) parse();
-            return id;
-        }
-        
-        public MemberImpl[] getMembers() {
-            if ( view == null ) parse();
-            return view;
-        }
-        
-        public byte[] getType() {
-            if (type == null ) parse();
-            return type;
-        }
-        
-        public XByteBuffer getBuffer() {
-            return this.buf;
-        }
-        
-        public void parse() {
-            //header
-            int offset = 16;
-            //leader
-            int ldrLen = buf.toInt(buf.getBytesDirect(),offset);
-            offset += 4;
-            byte[] ldr = new byte[ldrLen];
-            System.arraycopy(buf.getBytesDirect(),offset,ldr,0,ldrLen);
-            leader = MemberImpl.getMember(ldr);
-            offset += ldrLen;
-            //source
-            int srcLen = buf.toInt(buf.getBytesDirect(),offset);
-            offset += 4;
-            byte[] src = new byte[srcLen];
-            System.arraycopy(buf.getBytesDirect(),offset,src,0,srcLen);
-            source = MemberImpl.getMember(src);
-            offset += srcLen;
-            //view
-            int mbrCount = buf.toInt(buf.getBytesDirect(),offset);
-            offset += 4;
-            view = new MemberImpl[mbrCount];
-            for (int i=0; i<view.length; i++ ) {
-                int mbrLen = buf.toInt(buf.getBytesDirect(),offset);
-                offset += 4;
-                byte[] mbr = new byte[mbrLen];
-                System.arraycopy(buf.getBytesDirect(), offset, mbr, 0, mbrLen);
-                view[i] = MemberImpl.getMember(mbr);
-                offset += mbrLen;
-            }
-            //id
-            this.id = new UniqueId(buf.getBytesDirect(),offset,16);
-            offset += 16;
-            type = new byte[16];
-            System.arraycopy(buf.getBytesDirect(), offset, type, 0, type.length);
-            offset += 16;
-            
-        }
-        
-        public void write() {
-            buf.reset();
-            //header
-            buf.append(COORD_HEADER,0,COORD_HEADER.length);
-            //leader
-            byte[] ldr = leader.getData(false,false);
-            buf.append(ldr.length);
-            buf.append(ldr,0,ldr.length);
-            ldr = null;
-            //source
-            byte[] src = source.getData(false,false);
-            buf.append(src.length);
-            buf.append(src,0,src.length);
-            src = null;
-            //view
-            buf.append(view.length);
-            for (int i=0; i<view.length; i++ ) {
-                byte[] mbr = view[i].getData(false,false);
-                buf.append(mbr.length);
-                buf.append(mbr,0,mbr.length);
-            }
-            //id
-            buf.append(id.getBytes(),0,id.getBytes().length);
-            buf.append(type,0,type.length);
-        }
-    }
-    
-    public void fireInterceptorEvent(InterceptorEvent event) {
-        if (event instanceof CoordinationEvent &&
-            ((CoordinationEvent)event).type == CoordinationEvent.EVT_CONF_RX) 
-            log.info(event);
-    }
-    
-    public static class CoordinationEvent implements InterceptorEvent {
-        public static final int EVT_START = 1;
-        public static final int EVT_MBR_ADD = 2;
-        public static final int EVT_MBR_DEL = 3;
-        public static final int EVT_START_ELECT = 4;
-        public static final int EVT_PROCESS_ELECT = 5;
-        public static final int EVT_MSG_ARRIVE = 6;
-        public static final int EVT_PRE_MERGE = 7;
-        public static final int EVT_POST_MERGE = 8;
-        public static final int EVT_WAIT_FOR_MSG = 9;
-        public static final int EVT_SEND_MSG = 10;
-        public static final int EVT_STOP = 11;
-        public static final int EVT_CONF_RX = 12;
-        public static final int EVT_ELECT_ABANDONED = 13;
-        
-        int type;
-        ChannelInterceptor interceptor;
-        Member coord; 
-        Member[] mbrs;
-        String info;
-        Membership view;
-        Membership suggestedView;
-        public CoordinationEvent(int type,ChannelInterceptor interceptor, String info) {
-            this.type = type;
-            this.interceptor = interceptor;
-            this.coord = ((NonBlockingCoordinator)interceptor).getCoordinator();
-            this.mbrs = ((NonBlockingCoordinator)interceptor).membership.getMembers();
-            this.info = info;
-            this.view = ((NonBlockingCoordinator)interceptor).view;
-            this.suggestedView = ((NonBlockingCoordinator)interceptor).suggestedView;
-        }
-        
-        public int getEventType() {
-            return type;
-        }
-        
-        public String getEventTypeDesc() {
-            switch (type) {
-                case  EVT_START: return "EVT_START:"+info;
-                case  EVT_MBR_ADD: return "EVT_MBR_ADD:"+info;
-                case  EVT_MBR_DEL: return "EVT_MBR_DEL:"+info;
-                case  EVT_START_ELECT: return "EVT_START_ELECT:"+info;
-                case  EVT_PROCESS_ELECT: return "EVT_PROCESS_ELECT:"+info;
-                case  EVT_MSG_ARRIVE: return "EVT_MSG_ARRIVE:"+info;
-                case  EVT_PRE_MERGE: return "EVT_PRE_MERGE:"+info;
-                case  EVT_POST_MERGE: return "EVT_POST_MERGE:"+info;
-                case  EVT_WAIT_FOR_MSG: return "EVT_WAIT_FOR_MSG:"+info;
-                case  EVT_SEND_MSG: return "EVT_SEND_MSG:"+info;
-                case  EVT_STOP: return "EVT_STOP:"+info;
-                case  EVT_CONF_RX: return "EVT_CONF_RX:"+info;
-                case EVT_ELECT_ABANDONED: return "EVT_ELECT_ABANDONED:"+info;
-                default: return "Unknown";
-            }
-        }
-        
-        public ChannelInterceptor getInterceptor() {
-            return interceptor;
-        }
-        
-        public String toString() {
-            StringBuffer buf = new StringBuffer("CoordinationEvent[type=");
-            buf.append(type).append("\n\tLocal:");
-            Member local = interceptor.getLocalMember(false);
-            buf.append(local!=null?local.getName():"").append("\n\tCoord:");
-            buf.append(coord!=null?coord.getName():"").append("\n\tView:");
-            buf.append(Arrays.toNameString(view!=null?view.getMembers():null)).append("\n\tSuggested View:");
-            buf.append(Arrays.toNameString(suggestedView!=null?suggestedView.getMembers():null)).append("\n\tMembers:");
-            buf.append(Arrays.toNameString(mbrs)).append("\n\tInfo:");
-            buf.append(info).append("]");
-            return buf.toString();
-        }
-    }
-
-    
-
-
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ */
+package org.apache.catalina.tribes.group.interceptors;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.apache.catalina.tribes.Channel;
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelInterceptor;
+import org.apache.catalina.tribes.ChannelInterceptor.InterceptorEvent;
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.UniqueId;
+import org.apache.catalina.tribes.group.AbsoluteOrder;
+import org.apache.catalina.tribes.group.ChannelInterceptorBase;
+import org.apache.catalina.tribes.group.InterceptorPayload;
+import org.apache.catalina.tribes.io.ChannelData;
+import org.apache.catalina.tribes.io.XByteBuffer;
+import org.apache.catalina.tribes.membership.MemberImpl;
+import org.apache.catalina.tribes.membership.Membership;
+import org.apache.catalina.tribes.util.Arrays;
+import org.apache.catalina.tribes.util.UUIDGenerator;
+
+/**
+ * <p>Title: Auto merging leader election algorithm</p>
+ *
+ * <p>Description: Implementation of a simple coordinator algorithm that not only selects a coordinator,
+ *    it also merges groups automatically when members are discovered that werent part of the 
+ *    </p>
+ * <p>This algorithm is non blocking meaning it allows for transactions while the coordination phase is going on
+ * </p>
+ * <p>This implementation is based on a home brewed algorithm that uses the AbsoluteOrder of a membership
+ * to pass a token ring of the current membership.<br>
+ * This is not the same as just using AbsoluteOrder! Consider the following scenario:<br>
+ * Nodes, A,B,C,D,E on a network, in that priority. AbsoluteOrder will only work if all
+ * nodes are receiving pings from all the other nodes. 
+ * meaning, that node{i} receives pings from node{all}-node{i}<br>
+ * but the following could happen if a multicast problem occurs.
+ * A has members {B,C,D}<br>
+ * B has members {A,C}<br>
+ * C has members {D,E}<br>
+ * D has members {A,B,C,E}<br>
+ * E has members {A,C,D}<br>
+ * Because the default Tribes membership implementation, relies on the multicast packets to 
+ * arrive at all nodes correctly, there is nothing guaranteeing that it will.<br>
+ * <br>
+ * To best explain how this algorithm works, lets take the above example:
+ * For simplicity we assume that a send operation is O(1) for all nodes, although this algorithm will work
+ * where messages overlap, as they all depend on absolute order<br>
+ * Scenario 1: A,B,C,D,E all come online at the same time
+ * Eval phase, A thinks of itself as leader, B thinks of A as leader,
+ * C thinks of itself as leader, D,E think of A as leader<br>
+ * Token phase:<br>
+ * (1) A sends out a message X{A-ldr, A-src, mbrs-A,B,C,D} to B where X is the id for the message(and the view)<br>
+ * (1) C sends out a message Y{C-ldr, C-src, mbrs-C,D,E} to D where Y is the id for the message(and the view)<br>
+ * (2) B receives X{A-ldr, A-src, mbrs-A,B,C,D}, sends X{A-ldr, A-src, mbrs-A,B,C,D} to C <br>
+ * (2) D receives Y{C-ldr, C-src, mbrs-C,D,E} D is aware of A,B, sends Y{A-ldr, C-src, mbrs-A,B,C,D,E} to E<br>
+ * (3) C receives X{A-ldr, A-src, mbrs-A,B,C,D}, sends X{A-ldr, A-src, mbrs-A,B,C,D,E} to D<br>
+ * (3) E receives Y{A-ldr, C-src, mbrs-A,B,C,D,E} sends Y{A-ldr, C-src, mbrs-A,B,C,D,E} to A<br>
+ * (4) D receives X{A-ldr, A-src, mbrs-A,B,C,D,E} sends sends X{A-ldr, A-src, mbrs-A,B,C,D,E} to A<br>
+ * (4) A receives Y{A-ldr, C-src, mbrs-A,B,C,D,E}, holds the message, add E to its list of members<br>
+ * (5) A receives X{A-ldr, A-src, mbrs-A,B,C,D,E} <br>
+ * At this point, the state looks like<br>
+ * A - {A-ldr, mbrs-A,B,C,D,E, id=X}<br>
+ * B - {A-ldr, mbrs-A,B,C,D, id=X}<br>
+ * C - {A-ldr, mbrs-A,B,C,D,E, id=X}<br>
+ * D - {A-ldr, mbrs-A,B,C,D,E, id=X}<br>
+ * E - {A-ldr, mbrs-A,B,C,D,E, id=Y}<br>
+ * <br>
+ * A message doesn't stop until it reaches its original sender, unless its dropped by a higher leader.
+ * As you can see, E still thinks the viewId=Y, which is not correct. But at this point we have 
+ * arrived at the same membership and all nodes are informed of each other.<br>
+ * To synchronize the rest we simply perform the following check at A when A receives X:<br>
+ * Original X{A-ldr, A-src, mbrs-A,B,C,D} == Arrived X{A-ldr, A-src, mbrs-A,B,C,D,E}<br>
+ * Since the condition is false, A, will resend the token, and A sends X{A-ldr, A-src, mbrs-A,B,C,D,E} to B
+ * When A receives X again, the token is complete. <br>
+ * Optionally, A can send a message X{A-ldr, A-src, mbrs-A,B,C,D,E confirmed} to A,B,C,D,E who then
+ * install and accept the view.
+ * </p>
+ * <p>
+ * Lets assume that C1 arrives, C1 has lower priority than C, but higher priority than D.<br>
+ * Lets also assume that C1 sees the following view {B,D,E}<br>
+ * C1 waits for a token to arrive. When the token arrives, the same scenario as above will happen.<br>
+ * In the scenario where C1 sees {D,E} and A,B,C can not see C1, no token will ever arrive.<br>
+ * In this case, C1 sends a Z{C1-ldr, C1-src, mbrs-C1,D,E} to D<br>
+ * D receives Z{C1-ldr, C1-src, mbrs-C1,D,E} and sends Z{A-ldr, C1-src, mbrs-A,B,C,C1,D,E} to E<br>
+ * E receives Z{A-ldr, C1-src, mbrs-A,B,C,C1,D,E} and sends it to A<br>
+ * A sends Z{A-ldr, A-src, mbrs-A,B,C,C1,D,E} to B and the chain continues until A receives the token again.
+ * At that time A optionally sends out Z{A-ldr, A-src, mbrs-A,B,C,C1,D,E, confirmed} to A,B,C,C1,D,E
+ * </p>
+ * <p>To ensure that the view gets implemented at all nodes at the same time, 
+ *    A will send out a VIEW_CONF message, this is the 'confirmed' message that is optional above.
+ * <p>Ideally, the interceptor below this one would be the TcpFailureDetector to ensure correct memberships</p>
+ *
+ * <p>The example above, of course can be simplified with a finite statemachine:<br>
+ * But I suck at writing state machines, my head gets all confused. One day I will document this algorithm though.<br>
+ * Maybe I'll do a state diagram :)
+ * </p>
+ * <h2>State Diagrams</h2>
+ * <a href="http://people.apache.org/~fhanik/tribes/docs/leader-election-initiate-election.jpg">Initiate an election</a><br><br>
+ * <a href="http://people.apache.org/~fhanik/tribes/docs/leader-election-message-arrives.jpg">Receive an election message</a><br><br>
+ * 
+ * @author Filip Hanik
+ * @version 1.0
+ * 
+ * 
+ * 
+ */
+public class NonBlockingCoordinator extends ChannelInterceptorBase {
+    
+    /**
+     * header for a coordination message
+     */
+    protected static final byte[] COORD_HEADER = new byte[] {-86, 38, -34, -29, -98, 90, 65, 63, -81, -122, -6, -110, 99, -54, 13, 63};
+    /**
+     * Coordination request
+     */
+    protected static final byte[] COORD_REQUEST = new byte[] {104, -95, -92, -42, 114, -36, 71, -19, -79, 20, 122, 101, -1, -48, -49, 30};
+    /**
+     * Coordination confirmation, for blocking installations
+     */
+    protected static final byte[] COORD_CONF = new byte[] {67, 88, 107, -86, 69, 23, 76, -70, -91, -23, -87, -25, -125, 86, 75, 20};
+    
+    /**
+     * Alive message
+     */
+    protected static final byte[] COORD_ALIVE = new byte[] {79, -121, -25, -15, -59, 5, 64, 94, -77, 113, -119, -88, 52, 114, -56, -46,
+                                                            -18, 102, 10, 34, -127, -9, 71, 115, -70, 72, -101, 88, 72, -124, 127, 111,
+                                                            74, 76, -116, 50, 111, 103, 65, 3, -77, 51, -35, 0, 119, 117, 9, -26,
+                                                            119, 50, -75, -105, -102, 36, 79, 37, -68, -84, -123, 15, -22, -109, 106, -55};
+    /**
+     * Time to wait for coordination timeout
+     */
+    protected long waitForCoordMsgTimeout = 15000;
+    /**
+     * Our current view
+     */
+    protected Membership view = null;
+    /**
+     * Out current viewId
+     */
+    protected UniqueId viewId;
+
+    /**
+     * Our nonblocking membership
+     */
+    protected Membership membership = null;
+    
+    /**
+     * indicates that we are running an election 
+     * and this is the one we are running
+     */
+    protected UniqueId suggestedviewId;
+    protected Membership suggestedView;
+    
+    protected boolean started = false;
+    protected final int startsvc = 0xFFFF;
+    
+    protected Object electionMutex = new Object();
+    
+    protected AtomicBoolean coordMsgReceived = new AtomicBoolean(false);
+    
+    public NonBlockingCoordinator() {
+        super();
+    }
+    
+//============================================================================================================    
+//              COORDINATION HANDLING
+//============================================================================================================
+    
+    public void startElection(boolean force) throws ChannelException {
+        synchronized (electionMutex) {
+            MemberImpl local = (MemberImpl)getLocalMember(false);
+            MemberImpl[] others = (MemberImpl[])membership.getMembers();
+            fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_START_ELECT,this,"Election initated"));
+            if ( others.length == 0 ) {
+                this.viewId = new UniqueId(UUIDGenerator.randomUUID(false));
+                this.view = new Membership(local,AbsoluteOrder.comp, true);
+                this.handleViewConf(this.createElectionMsg(local,others,local),local,view);
+                return; //the only member, no need for an election
+            }
+            if ( suggestedviewId != null ) {
+                
+                if ( view != null && Arrays.diff(view,suggestedView,local).length == 0 &&  Arrays.diff(suggestedView,view,local).length == 0) {
+                    suggestedviewId = null;
+                    suggestedView = null;
+                    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED,this,"Election abandoned, running election matches view"));
+                } else {
+                    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED,this,"Election abandoned, election running"));
+                }
+                return; //election already running, I'm not allowed to have two of them
+            }
+            if ( view != null && Arrays.diff(view,membership,local).length == 0 &&  Arrays.diff(membership,view,local).length == 0) {
+                fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED,this,"Election abandoned, view matches membership"));
+                return; //already have this view installed
+            }            
+            int prio = AbsoluteOrder.comp.compare(local,others[0]);
+            MemberImpl leader = ( prio < 0 )?local:others[0];//am I the leader in my view?
+            if ( local.equals(leader) || force ) {
+                CoordinationMessage msg = createElectionMsg(local, others, leader);
+                suggestedviewId = msg.getId();
+                suggestedView = new Membership(local,AbsoluteOrder.comp,true);
+                Arrays.fill(suggestedView,msg.getMembers());
+                fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_PROCESS_ELECT,this,"Election, sending request"));
+                sendElectionMsg(local,others[0],msg);
+            } else {
+                try {
+                    coordMsgReceived.set(false);
+                    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_WAIT_FOR_MSG,this,"Election, waiting for request"));
+                    electionMutex.wait(waitForCoordMsgTimeout);
+                }catch ( InterruptedException x ) {
+                    Thread.currentThread().interrupted();
+                }
+                if ( suggestedviewId == null && (!coordMsgReceived.get())) {
+                    //no message arrived, send the coord msg
+//                    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_WAIT_FOR_MSG,this,"Election, waiting timed out."));
+//                    startElection(true);
+                    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED,this,"Election abandoned, waiting timed out."));
+                } else {
+                    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED,this,"Election abandoned, received a message"));
+                }
+            }//end if
+            
+        }
+    }
+
+    private CoordinationMessage createElectionMsg(MemberImpl local, MemberImpl[] others, MemberImpl leader) {
+        Membership m = new Membership(local,AbsoluteOrder.comp,true);
+        Arrays.fill(m,others);
+        MemberImpl[] mbrs = m.getMembers();
+        m.reset(); 
+        CoordinationMessage msg = new CoordinationMessage(leader, local, mbrs,new UniqueId(UUIDGenerator.randomUUID(true)), this.COORD_REQUEST);
+        return msg;
+    }
+
+    protected void sendElectionMsg(MemberImpl local, MemberImpl next, CoordinationMessage msg) throws ChannelException {
+        fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_SEND_MSG,this,"Sending election message to("+next.getName()+")"));
+        super.sendMessage(new Member[] {next}, createData(msg, local), null);
+    }
+    
+    protected void sendElectionMsgToNextInline(MemberImpl local, CoordinationMessage msg) throws ChannelException { 
+        int next = Arrays.nextIndex(local,msg.getMembers());
+        int current = next;
+        msg.leader = msg.getMembers()[0];
+        boolean sent =  false;
+        while ( !sent && current >= 0 ) {
+            try {
+                sendElectionMsg(local, (MemberImpl) msg.getMembers()[current], msg);
+                sent = true;
+            }catch ( ChannelException x  ) {
+                log.warn("Unable to send election message to:"+msg.getMembers()[current]);
+                current = Arrays.nextIndex(msg.getMembers()[current],msg.getMembers());
+                if ( current == next ) throw x;
+            }
+        }
+    }
+    
+    public Member getNextInLine(MemberImpl local, MemberImpl[] others) {
+        MemberImpl result = null;
+        for ( int i=0; i<others.length; i++ ) {
+            
+        }
+        return result;
+    }
+    
+    public ChannelData createData(CoordinationMessage msg, MemberImpl local) {
+        msg.write();
+        ChannelData data = new ChannelData(true);
+        data.setAddress(local);
+        data.setMessage(msg.getBuffer());
+        data.setOptions(Channel.SEND_OPTIONS_USE_ACK);
+        data.setTimestamp(System.currentTimeMillis());
+        return data;
+    }
+    
+    protected void viewChange(UniqueId viewId, Member[] view) {
+        //invoke any listeners
+    }
+    
+    protected boolean alive(Member mbr) {
+        return TcpFailureDetector.memberAlive(mbr,
+                                              COORD_ALIVE,
+                                              false,
+                                              false,
+                                              waitForCoordMsgTimeout,
+                                              waitForCoordMsgTimeout,
+                                              getOptionFlag());
+    }
+    
+    protected Membership mergeOnArrive(CoordinationMessage msg, Member sender) {
+        fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_PRE_MERGE,this,"Pre merge"));
+        MemberImpl local = (MemberImpl)getLocalMember(false);
+        Membership merged = new Membership(local,AbsoluteOrder.comp,true);
+        Arrays.fill(merged,msg.getMembers());
+        Arrays.fill(merged,getMembers());
+        Member[] diff = Arrays.diff(merged,membership,local);
+        for ( int i=0; i<diff.length; i++ ) {
+            if (!alive(diff[i])) merged.removeMember((MemberImpl)diff[i]);
+            else memberAdded(diff[i],false);
+        }
+        fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_POST_MERGE,this,"Post merge"));
+        return merged;
+    }
+    
+    protected void processCoordMessage(CoordinationMessage msg, Member sender) throws ChannelException {
+        if ( !coordMsgReceived.get() ) {
+            coordMsgReceived.set(true);
+            synchronized (electionMutex) { electionMutex.notifyAll();}
+        } 
+        msg.timestamp = System.currentTimeMillis();
+        Membership merged = mergeOnArrive(msg, sender);
+        if (isViewConf(msg)) handleViewConf(msg, sender, merged);
+        else handleToken(msg, sender, merged);
+        ClassLoader loader;
+
+    }
+    
+    protected void handleToken(CoordinationMessage msg, Member sender,Membership merged) throws ChannelException {
+        MemberImpl local = (MemberImpl)getLocalMember(false);
+        if ( local.equals(msg.getSource()) ) {
+            //my message msg.src=local
+            handleMyToken(local, msg, sender,merged);
+        } else {
+            handleOtherToken(local, msg, sender,merged);
+        }
+    }
+    
+    protected void handleMyToken(MemberImpl local, CoordinationMessage msg, Member sender,Membership merged) throws ChannelException {
+        if ( local.equals(msg.getLeader()) ) {
+            //no leadership change
+            if ( Arrays.sameMembers(msg.getMembers(),merged.getMembers()) ) {
+                msg.type = COORD_CONF;
+                super.sendMessage(Arrays.remove(msg.getMembers(),local),createData(msg,local),null);
+                handleViewConf(msg,local,merged);
+            } else {
+                //membership change
+                suggestedView = new Membership(local,AbsoluteOrder.comp,true);
+                suggestedviewId = msg.getId();
+                Arrays.fill(suggestedView,merged.getMembers());
+                msg.view = (MemberImpl[])merged.getMembers();
+                sendElectionMsgToNextInline(local,msg);
+            }
+        } else {
+            //leadership change
+            suggestedView = null;
+            suggestedviewId = null;
+            msg.view = (MemberImpl[])merged.getMembers();
+            sendElectionMsgToNextInline(local,msg);
+        }
+    }
+    
+    protected void handleOtherToken(MemberImpl local, CoordinationMessage msg, Member sender,Membership merged) throws ChannelException {
+        if ( local.equals(msg.getLeader()) ) {
+            //I am the new leader
+            //startElection(false);
+        } else {
+            msg.view = (MemberImpl[])merged.getMembers();
+            sendElectionMsgToNextInline(local,msg);
+        }
+    }
+    
+    protected void handleViewConf(CoordinationMessage msg, Member sender,Membership merged) throws ChannelException {
+        if ( viewId != null && msg.getId().equals(viewId) ) return;//we already have this view
+        view = new Membership((MemberImpl)getLocalMember(false),AbsoluteOrder.comp,true);
+        Arrays.fill(view,msg.getMembers());
+        viewId = msg.getId();
+        
+        if ( viewId.equals(suggestedviewId) ) {
+            suggestedView = null;
+            suggestedviewId = null;
+        }
+        
+        if (suggestedView != null && AbsoluteOrder.comp.compare(suggestedView.getMembers()[0],merged.getMembers()[0])<0 ) {
+            suggestedView = null;
+            suggestedviewId = null;
+        }
+        
+        viewChange(viewId,view.getMembers());
+        fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_CONF_RX,this,"Accepted View"));
+        
+        if ( suggestedviewId == null && hasHigherPriority(merged.getMembers(),membership.getMembers()) ) {
+            startElection(false);
+        }
+    }
+    
+    protected boolean isViewConf(CoordinationMessage msg) {
+        return Arrays.contains(msg.getType(),0,COORD_CONF,0,COORD_CONF.length);
+    }
+    
+    protected boolean hasHigherPriority(Member[] complete, Member[] local) {
+        if ( local == null || local.length == 0 ) return false;
+        if ( complete == null || complete.length == 0 ) return true;
+        AbsoluteOrder.absoluteOrder(complete);
+        AbsoluteOrder.absoluteOrder(local);
+        return (AbsoluteOrder.comp.compare(complete[0],local[0]) > 0);
+        
+    }
+
+    
+    /**
+     * Returns coordinator if one is available
+     * @return Member
+     */
+    public Member getCoordinator() {
+        return (view != null && view.hasMembers()) ? view.getMembers()[0] : null;
+    }
+    
+    public Member[] getView() {
+        return (view != null && view.hasMembers()) ? view.getMembers() : new Member[0];
+    }
+    
+    public UniqueId getViewId() {
+        return viewId;
+    }
+    
+    /**
+    * Block in/out messages while a election is going on
+    */
+   protected void halt() {
+
+   }
+
+   /**
+    * Release lock for in/out messages election is completed
+    */
+   protected void release() {
+
+   }
+
+   /**
+    * Wait for an election to end
+    */
+   protected void waitForRelease() {
+
+   }
+
+    
+//============================================================================================================    
+//              OVERRIDDEN METHODS FROM CHANNEL INTERCEPTOR BASE    
+//============================================================================================================
+    public void start(int svc) throws ChannelException {
+            if (membership == null) setupMembership();
+            if (started)return;
+            fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_START, this, "Before start"));
+            super.start(startsvc);
+            started = true;
+            if (view == null) view = new Membership( (MemberImpl)super.getLocalMember(true), AbsoluteOrder.comp, true);
+            fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_START, this, "After start"));
+            startElection(false);
+    }
+
+    public void stop(int svc) throws ChannelException {
+        try {
+            halt();
+            synchronized (electionMutex) {
+                if (!started)return;
+                started = false;
+                fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_STOP, this, "Before stop"));
+                super.stop(startsvc);
+                this.view = null;
+                this.viewId = null;
+                this.suggestedView = null;
+                this.suggestedviewId = null;
+                this.membership.reset();
+                fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_STOP, this, "After stop"));
+            }
+        }finally {
+            release();
+        }
+    }
+    
+    
+    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
+        waitForRelease();
+        super.sendMessage(destination, msg, payload);
+    }
+
+    public void messageReceived(ChannelMessage msg) {
+        if ( Arrays.contains(msg.getMessage().getBytesDirect(),0,COORD_ALIVE,0,COORD_ALIVE.length) ) {
+            //ignore message, its an alive message
+            fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_MSG_ARRIVE,this,"Alive Message"));
+
+        } else if ( Arrays.contains(msg.getMessage().getBytesDirect(),0,COORD_HEADER,0,COORD_HEADER.length) ) {
+            try {
+                CoordinationMessage cmsg = new CoordinationMessage(msg.getMessage());
+                Member[] cmbr = cmsg.getMembers();
+                fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_MSG_ARRIVE,this,"Coord Msg Arrived("+Arrays.toNameString(cmbr)+")"));
+                processCoordMessage(cmsg, msg.getAddress());
+            }catch ( ChannelException x ) {
+                log.error("Error processing coordination message. Could be fatal.",x);
+            }
+        } else {
+            super.messageReceived(msg);
+        }
+    }
+
+    public boolean accept(ChannelMessage msg) {
+        return super.accept(msg);
+    }
+
+    public void memberAdded(Member member) {
+        memberAdded(member,true);
+    }
+
+    public void memberAdded(Member member,boolean elect) {
+        try {
+            if ( membership == null ) setupMembership();
+            if ( membership.memberAlive((MemberImpl)member) ) super.memberAdded(member);
+            try {
+                fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_MBR_ADD,this,"Member add("+member.getName()+")"));
+                if (started && elect) startElection(false);
+            }catch ( ChannelException x ) {
+                log.error("Unable to start election when member was added.",x);
+            }
+        }finally {
+        }
+        
+    }
+
+    public void memberDisappeared(Member member) {
+        try {
+            
+            membership.removeMember((MemberImpl)member);
+            super.memberDisappeared(member);
+            try {
+                fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_MBR_DEL,this,"Member remove("+member.getName()+")"));
+                if ( started && (isCoordinator() || isHighest()) ) 
+                    startElection(true); //to do, if a member disappears, only the coordinator can start
+            }catch ( ChannelException x ) {
+                log.error("Unable to start election when member was removed.",x);
+            }
+        }finally {
+        }
+    }
+    
+    public boolean isHighest() {
+        Member local = getLocalMember(false);
+        if ( membership.getMembers().length == 0 ) return true;
+        else return AbsoluteOrder.comp.compare(local,membership.getMembers()[0])<=0;
+    }
+    
+    public boolean isCoordinator() {
+        Member coord = getCoordinator();
+        return coord != null && getLocalMember(false).equals(coord);
+    }
+
+    public void heartbeat() {
+        try {
+            MemberImpl local = (MemberImpl)getLocalMember(false);
+            if ( view != null && (Arrays.diff(view,membership,local).length != 0 ||  Arrays.diff(membership,view,local).length != 0) ) {
+                if ( isHighest() ) {
+                    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_START_ELECT, this,
+                                                               "Heartbeat found inconsistency, restart election"));
+                    startElection(true);
+                }            
+            }
+        } catch ( Exception x  ){
+            log.error("Unable to perform heartbeat.",x);
+        } finally {
+            super.heartbeat();
+        }
+    }
+
+    /**
+     * has members
+     */
+    public boolean hasMembers() {
+        
+        return membership.hasMembers();
+    }
+
+    /**
+     * Get all current cluster members
+     * @return all members or empty array
+     */
+    public Member[] getMembers() {
+        
+        return membership.getMembers();
+    }
+
+    /**
+     *
+     * @param mbr Member
+     * @return Member
+     */
+    public Member getMember(Member mbr) {
+        
+        return membership.getMember(mbr);
+    }
+
+    /**
+     * Return the member that represents this node.
+     *
+     * @return Member
+     */
+    public Member getLocalMember(boolean incAlive) {
+        Member local = super.getLocalMember(incAlive);
+        if ( view == null && (local != null)) setupMembership();
+        return local;
+    }
+    
+    protected synchronized void setupMembership() {
+        if ( membership == null ) {
+            membership  = new Membership((MemberImpl)super.getLocalMember(true),AbsoluteOrder.comp,false);
+        }
+    }
+    
+    
+//============================================================================================================    
+//              HELPER CLASSES FOR COORDINATION
+//============================================================================================================
+    
+    
+   
+    
+    public static class CoordinationMessage {
+        //X{A-ldr, A-src, mbrs-A,B,C,D}
+        protected XByteBuffer buf;
+        protected MemberImpl leader;
+        protected MemberImpl source;
+        protected MemberImpl[] view;
+        protected UniqueId id;
+        protected byte[] type;
+        protected long timestamp = System.currentTimeMillis();
+        
+        public CoordinationMessage(XByteBuffer buf) {
+            this.buf = buf;
+            parse();
+        }
+
+        public CoordinationMessage(MemberImpl leader,
+                                   MemberImpl source, 
+                                   MemberImpl[] view,
+                                   UniqueId id,
+                                   byte[] type) {
+            this.buf = new XByteBuffer(4096,false);
+            this.leader = leader;
+            this.source = source;
+            this.view = view;
+            this.id = id;
+            this.type = type;
+            this.write();
+        }
+        
+
+        public byte[] getHeader() {
+            return NonBlockingCoordinator.COORD_HEADER;
+        }
+        
+        public MemberImpl getLeader() {
+            if ( leader == null ) parse();
+            return leader;
+        }
+        
+        public MemberImpl getSource() {
+            if ( source == null ) parse();
+            return source;
+        }
+        
+        public UniqueId getId() {
+            if ( id == null ) parse();
+            return id;
+        }
+        
+        public MemberImpl[] getMembers() {
+            if ( view == null ) parse();
+            return view;
+        }
+        
+        public byte[] getType() {
+            if (type == null ) parse();
+            return type;
+        }
+        
+        public XByteBuffer getBuffer() {
+            return this.buf;
+        }
+        
+        public void parse() {
+            //header
+            int offset = 16;
+            //leader
+            int ldrLen = buf.toInt(buf.getBytesDirect(),offset);
+            offset += 4;
+            byte[] ldr = new byte[ldrLen];
+            System.arraycopy(buf.getBytesDirect(),offset,ldr,0,ldrLen);
+            leader = MemberImpl.getMember(ldr);
+            offset += ldrLen;
+            //source
+            int srcLen = buf.toInt(buf.getBytesDirect(),offset);
+            offset += 4;
+            byte[] src = new byte[srcLen];
+            System.arraycopy(buf.getBytesDirect(),offset,src,0,srcLen);
+            source = MemberImpl.getMember(src);
+            offset += srcLen;
+            //view
+            int mbrCount = buf.toInt(buf.getBytesDirect(),offset);
+            offset += 4;
+            view = new MemberImpl[mbrCount];
+            for (int i=0; i<view.length; i++ ) {
+                int mbrLen = buf.toInt(buf.getBytesDirect(),offset);
+                offset += 4;
+                byte[] mbr = new byte[mbrLen];
+                System.arraycopy(buf.getBytesDirect(), offset, mbr, 0, mbrLen);
+                view[i] = MemberImpl.getMember(mbr);
+                offset += mbrLen;
+            }
+            //id
+            this.id = new UniqueId(buf.getBytesDirect(),offset,16);
+            offset += 16;
+            type = new byte[16];
+            System.arraycopy(buf.getBytesDirect(), offset, type, 0, type.length);
+            offset += 16;
+            
+        }
+        
+        public void write() {
+            buf.reset();
+            //header
+            buf.append(COORD_HEADER,0,COORD_HEADER.length);
+            //leader
+            byte[] ldr = leader.getData(false,false);
+            buf.append(ldr.length);
+            buf.append(ldr,0,ldr.length);
+            ldr = null;
+            //source
+            byte[] src = source.getData(false,false);
+            buf.append(src.length);
+            buf.append(src,0,src.length);
+            src = null;
+            //view
+            buf.append(view.length);
+            for (int i=0; i<view.length; i++ ) {
+                byte[] mbr = view[i].getData(false,false);
+                buf.append(mbr.length);
+                buf.append(mbr,0,mbr.length);
+            }
+            //id
+            buf.append(id.getBytes(),0,id.getBytes().length);
+            buf.append(type,0,type.length);
+        }
+    }
+    
+    public void fireInterceptorEvent(InterceptorEvent event) {
+        if (event instanceof CoordinationEvent &&
+            ((CoordinationEvent)event).type == CoordinationEvent.EVT_CONF_RX) 
+            log.info(event);
+    }
+    
+    public static class CoordinationEvent implements InterceptorEvent {
+        public static final int EVT_START = 1;
+        public static final int EVT_MBR_ADD = 2;
+        public static final int EVT_MBR_DEL = 3;
+        public static final int EVT_START_ELECT = 4;
+        public static final int EVT_PROCESS_ELECT = 5;
+        public static final int EVT_MSG_ARRIVE = 6;
+        public static final int EVT_PRE_MERGE = 7;
+        public static final int EVT_POST_MERGE = 8;
+        public static final int EVT_WAIT_FOR_MSG = 9;
+        public static final int EVT_SEND_MSG = 10;
+        public static final int EVT_STOP = 11;
+        public static final int EVT_CONF_RX = 12;
+        public static final int EVT_ELECT_ABANDONED = 13;
+        
+        int type;
+        ChannelInterceptor interceptor;
+        Member coord; 
+        Member[] mbrs;
+        String info;
+        Membership view;
+        Membership suggestedView;
+        public CoordinationEvent(int type,ChannelInterceptor interceptor, String info) {
+            this.type = type;
+            this.interceptor = interceptor;
+            this.coord = ((NonBlockingCoordinator)interceptor).getCoordinator();
+            this.mbrs = ((NonBlockingCoordinator)interceptor).membership.getMembers();
+            this.info = info;
+            this.view = ((NonBlockingCoordinator)interceptor).view;
+            this.suggestedView = ((NonBlockingCoordinator)interceptor).suggestedView;
+        }
+        
+        public int getEventType() {
+            return type;
+        }
+        
+        public String getEventTypeDesc() {
+            switch (type) {
+                case  EVT_START: return "EVT_START:"+info;
+                case  EVT_MBR_ADD: return "EVT_MBR_ADD:"+info;
+                case  EVT_MBR_DEL: return "EVT_MBR_DEL:"+info;
+                case  EVT_START_ELECT: return "EVT_START_ELECT:"+info;
+                case  EVT_PROCESS_ELECT: return "EVT_PROCESS_ELECT:"+info;
+                case  EVT_MSG_ARRIVE: return "EVT_MSG_ARRIVE:"+info;
+                case  EVT_PRE_MERGE: return "EVT_PRE_MERGE:"+info;
+                case  EVT_POST_MERGE: return "EVT_POST_MERGE:"+info;
+                case  EVT_WAIT_FOR_MSG: return "EVT_WAIT_FOR_MSG:"+info;
+                case  EVT_SEND_MSG: return "EVT_SEND_MSG:"+info;
+                case  EVT_STOP: return "EVT_STOP:"+info;
+                case  EVT_CONF_RX: return "EVT_CONF_RX:"+info;
+                case EVT_ELECT_ABANDONED: return "EVT_ELECT_ABANDONED:"+info;
+                default: return "Unknown";
+            }
+        }
+        
+        public ChannelInterceptor getInterceptor() {
+            return interceptor;
+        }
+        
+        public String toString() {
+            StringBuffer buf = new StringBuffer("CoordinationEvent[type=");
+            buf.append(type).append("\n\tLocal:");
+            Member local = interceptor.getLocalMember(false);
+            buf.append(local!=null?local.getName():"").append("\n\tCoord:");
+            buf.append(coord!=null?coord.getName():"").append("\n\tView:");
+            buf.append(Arrays.toNameString(view!=null?view.getMembers():null)).append("\n\tSuggested View:");
+            buf.append(Arrays.toNameString(suggestedView!=null?suggestedView.getMembers():null)).append("\n\tMembers:");
+            buf.append(Arrays.toNameString(mbrs)).append("\n\tInfo:");
+            buf.append(info).append("]");
+            return buf.toString();
+        }
+    }
+
+    
+
+
+
 }
\ No newline at end of file

==================================================
TcpFailureDetector.java
index c0610c419b..5f6626f5c8 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/OrderInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/OrderInterceptor.java
@@ -1,299 +1,299 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- */
-
-package org.apache.catalina.tribes.group.interceptors;
-
-import java.util.HashMap;
-
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.group.ChannelInterceptorBase;
-import org.apache.catalina.tribes.group.InterceptorPayload;
-import org.apache.catalina.tribes.io.XByteBuffer;
-
-
-
-/**
- *
- * The order interceptor guarantees that messages are received in the same order they were 
- * sent.
- * This interceptor works best with the ack=true setting. <br>
- * There is no point in 
- * using this with the replicationMode="fastasynchqueue" as this mode guarantees ordering.<BR>
- * If you are using the mode ack=false replicationMode=pooled, and have a lot of concurrent threads,
- * this interceptor can really slow you down, as many messages will be completely out of order
- * and the queue might become rather large. If this is the case, then you might want to set 
- * the value OrderInterceptor.maxQueue = 25 (meaning that we will never keep more than 25 messages in our queue)
- * <br><b>Configuration Options</b><br>
- * OrderInteceptor.expire=<milliseconds> - if a message arrives out of order, how long before we act on it <b>default=3000ms</b><br>
- * OrderInteceptor.maxQueue=<max queue size> - how much can the queue grow to ensure ordering. 
- *   This setting is useful to avoid OutOfMemoryErrors<b>default=Integer.MAX_VALUE</b><br>
- * OrderInterceptor.forwardExpired=<boolean> - this flag tells the interceptor what to 
- * do when a message has expired or the queue has grown larger than the maxQueue value.
- * true means that the message is sent up the stack to the receiver that will receive and out of order message
- * false means, forget the message and reset the message counter. <b>default=true</b>
- * 
- * 
- * @author Filip Hanik
- * @version 1.0
- */
-public class OrderInterceptor extends ChannelInterceptorBase {
-    private HashMap outcounter = new HashMap();
-    private HashMap incounter = new HashMap();
-    private HashMap incoming = new HashMap();
-    private long expire = 3000;
-    private boolean forwardExpired = true;
-    private int maxQueue = Integer.MAX_VALUE;
-
-    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
-        for ( int i=0; i<destination.length; i++ ) {
-            int nr = incCounter(destination[i]);
-            //reduce byte copy
-            msg.getMessage().append(nr);
-            try {
-                getNext().sendMessage(new Member[] {destination[i]}, msg, payload);
-            }finally {
-                msg.getMessage().trim(4);
-            }
-        }
-    }
-
-    public void messageReceived(ChannelMessage msg) {
-        int msgnr = XByteBuffer.toInt(msg.getMessage().getBytesDirect(),msg.getMessage().getLength()-4);
-        msg.getMessage().trim(4);
-        MessageOrder order = new MessageOrder(msgnr,(ChannelMessage)msg.deepclone());
-        if ( processIncoming(order) ) processLeftOvers(msg.getAddress(),false);
-    }
-    
-    public synchronized void processLeftOvers(Member member, boolean force) {
-        MessageOrder tmp = (MessageOrder)incoming.get(member);
-        if ( force ) {
-            Counter cnt = getInCounter(member);
-            cnt.setCounter(Integer.MAX_VALUE);
-        }
-        if ( tmp!= null ) processIncoming(tmp);
-    }
-    /**
-     * 
-     * @param order MessageOrder
-     * @return boolean - true if a message expired and was processed
-     */
-    public synchronized boolean processIncoming(MessageOrder order) {
-        boolean result = false;
-        Member member = order.getMessage().getAddress();
-        Counter cnt = getInCounter(member);
-        
-        MessageOrder tmp = (MessageOrder)incoming.get(member);
-        if ( tmp != null ) {
-            order = MessageOrder.add(tmp,order);
-        }
-        
-        
-        while ( (order!=null) && (order.getMsgNr() <= cnt.getCounter())  ) {
-            //we are right on target. process orders
-            if ( order.getMsgNr() == cnt.getCounter() ) cnt.inc();
-            else if ( order.getMsgNr() > cnt.getCounter() ) cnt.setCounter(order.getMsgNr());
-            super.messageReceived(order.getMessage());
-            order.setMessage(null);
-            order = order.next;
-        }
-        MessageOrder head = order;
-        MessageOrder prev = null;
-        tmp = order;
-        //flag to empty out the queue when it larger than maxQueue
-        boolean empty = order!=null?order.getCount()>=maxQueue:false;
-        while ( tmp != null ) {
-            //process expired messages or empty out the queue
-            if ( tmp.isExpired(expire) || empty ) {
-                //reset the head
-                if ( tmp == head ) head = tmp.next;
-                cnt.setCounter(tmp.getMsgNr()+1);
-                if ( getForwardExpired() ) super.messageReceived(tmp.getMessage());
-                tmp.setMessage(null);
-                tmp = tmp.next;
-                if ( prev != null ) prev.next = tmp;  
-                result = true;
-            } else {
-                prev = tmp;
-                tmp = tmp.next;
-            }
-        }
-        if ( head == null ) incoming.remove(member);
-        else incoming.put(member, head);
-        return result;
-    }
-    
-    public void memberAdded(Member member) {
-        //notify upwards
-        getInCounter(member);
-        getOutCounter(member);
-        super.memberAdded(member);
-    }
-
-    public void memberDisappeared(Member member) {
-        //notify upwards
-        outcounter.remove(member);
-        incounter.remove(member);
-        //clear the remaining queue
-        processLeftOvers(member,true);
-        super.memberDisappeared(member);
-    }
-    
-    public int incCounter(Member mbr) { 
-        Counter cnt = getOutCounter(mbr);
-        return cnt.inc();
-    }
-    
-    public synchronized Counter getInCounter(Member mbr) {
-        Counter cnt = (Counter)incounter.get(mbr);
-        if ( cnt == null ) {
-            cnt = new Counter();
-            cnt.inc(); //always start at 1 for incoming
-            incounter.put(mbr,cnt);
-        }
-        return cnt;
-    }
-
-    public synchronized Counter getOutCounter(Member mbr) {
-        Counter cnt = (Counter)outcounter.get(mbr);
-        if ( cnt == null ) {
-            cnt = new Counter();
-            outcounter.put(mbr,cnt);
-        }
-        return cnt;
-    }
-
-    public static class Counter {
-        private int value = 0;
-        
-        public int getCounter() {
-            return value;
-        }
-        
-        public synchronized void setCounter(int counter) {
-            this.value = counter;
-        }
-        
-        public synchronized int inc() {
-            return ++value;
-        }
-    }
-    
-    public static class MessageOrder {
-        private long received = System.currentTimeMillis();
-        private MessageOrder next;
-        private int msgNr;
-        private ChannelMessage msg = null;
-        public MessageOrder(int msgNr,ChannelMessage msg) {
-            this.msgNr = msgNr;
-            this.msg = msg;
-        }
-        
-        public boolean isExpired(long expireTime) {
-            return (System.currentTimeMillis()-received) > expireTime;
-        }
-        
-        public ChannelMessage getMessage() {
-            return msg;
-        }
-        
-        public void setMessage(ChannelMessage msg) {
-            this.msg = msg;
-        }
-        
-        public void setNext(MessageOrder order) {
-            this.next = order;
-        }
-        public MessageOrder getNext() {
-            return next;
-        }
-        
-        public int getCount() {
-            int counter = 1;
-            MessageOrder tmp = next;
-            while ( tmp != null ) {
-                counter++;
-                tmp = tmp.next;
-            }
-            return counter;
-        }
-        
-        public static MessageOrder add(MessageOrder head, MessageOrder add) {
-            if ( head == null ) return add;
-            if ( add == null ) return head;
-            if ( head == add ) return add;
-
-            if ( head.getMsgNr() > add.getMsgNr() ) {
-                add.next = head;
-                return add;
-            }
-            
-            MessageOrder iter = head;
-            MessageOrder prev = null;
-            while ( iter.getMsgNr() < add.getMsgNr() && (iter.next !=null ) ) {
-                prev = iter;
-                iter = iter.next;
-            }
-            if ( iter.getMsgNr() < add.getMsgNr() ) {
-                //add after
-                add.next = iter.next;
-                iter.next = add;
-            } else if (iter.getMsgNr() > add.getMsgNr()) {
-                //add before
-                prev.next = add;
-                add.next = iter;
-                
-            } else {
-                throw new ArithmeticException("Message added has the same counter, synchronization bug. Disable the order interceptor");
-            }
-            
-            return head;
-        }
-        
-        public int getMsgNr() {
-            return msgNr;
-        }
-        
-        
-        
-    }
-
-    public void setExpire(long expire) {
-        this.expire = expire;
-    }
-
-    public void setForwardExpired(boolean forwardExpired) {
-        this.forwardExpired = forwardExpired;
-    }
-
-    public void setMaxQueue(int maxQueue) {
-        this.maxQueue = maxQueue;
-    }
-
-    public long getExpire() {
-        return expire;
-    }
-
-    public boolean getForwardExpired() {
-        return forwardExpired;
-    }
-
-    public int getMaxQueue() {
-        return maxQueue;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ */
+
+package org.apache.catalina.tribes.group.interceptors;
+
+import java.util.HashMap;
+
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.group.ChannelInterceptorBase;
+import org.apache.catalina.tribes.group.InterceptorPayload;
+import org.apache.catalina.tribes.io.XByteBuffer;
+
+
+
+/**
+ *
+ * The order interceptor guarantees that messages are received in the same order they were 
+ * sent.
+ * This interceptor works best with the ack=true setting. <br>
+ * There is no point in 
+ * using this with the replicationMode="fastasynchqueue" as this mode guarantees ordering.<BR>
+ * If you are using the mode ack=false replicationMode=pooled, and have a lot of concurrent threads,
+ * this interceptor can really slow you down, as many messages will be completely out of order
+ * and the queue might become rather large. If this is the case, then you might want to set 
+ * the value OrderInterceptor.maxQueue = 25 (meaning that we will never keep more than 25 messages in our queue)
+ * <br><b>Configuration Options</b><br>
+ * OrderInteceptor.expire=<milliseconds> - if a message arrives out of order, how long before we act on it <b>default=3000ms</b><br>
+ * OrderInteceptor.maxQueue=<max queue size> - how much can the queue grow to ensure ordering. 
+ *   This setting is useful to avoid OutOfMemoryErrors<b>default=Integer.MAX_VALUE</b><br>
+ * OrderInterceptor.forwardExpired=<boolean> - this flag tells the interceptor what to 
+ * do when a message has expired or the queue has grown larger than the maxQueue value.
+ * true means that the message is sent up the stack to the receiver that will receive and out of order message
+ * false means, forget the message and reset the message counter. <b>default=true</b>
+ * 
+ * 
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class OrderInterceptor extends ChannelInterceptorBase {
+    private HashMap outcounter = new HashMap();
+    private HashMap incounter = new HashMap();
+    private HashMap incoming = new HashMap();
+    private long expire = 3000;
+    private boolean forwardExpired = true;
+    private int maxQueue = Integer.MAX_VALUE;
+
+    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
+        for ( int i=0; i<destination.length; i++ ) {
+            int nr = incCounter(destination[i]);
+            //reduce byte copy
+            msg.getMessage().append(nr);
+            try {
+                getNext().sendMessage(new Member[] {destination[i]}, msg, payload);
+            }finally {
+                msg.getMessage().trim(4);
+            }
+        }
+    }
+
+    public void messageReceived(ChannelMessage msg) {
+        int msgnr = XByteBuffer.toInt(msg.getMessage().getBytesDirect(),msg.getMessage().getLength()-4);
+        msg.getMessage().trim(4);
+        MessageOrder order = new MessageOrder(msgnr,(ChannelMessage)msg.deepclone());
+        if ( processIncoming(order) ) processLeftOvers(msg.getAddress(),false);
+    }
+    
+    public synchronized void processLeftOvers(Member member, boolean force) {
+        MessageOrder tmp = (MessageOrder)incoming.get(member);
+        if ( force ) {
+            Counter cnt = getInCounter(member);
+            cnt.setCounter(Integer.MAX_VALUE);
+        }
+        if ( tmp!= null ) processIncoming(tmp);
+    }
+    /**
+     * 
+     * @param order MessageOrder
+     * @return boolean - true if a message expired and was processed
+     */
+    public synchronized boolean processIncoming(MessageOrder order) {
+        boolean result = false;
+        Member member = order.getMessage().getAddress();
+        Counter cnt = getInCounter(member);
+        
+        MessageOrder tmp = (MessageOrder)incoming.get(member);
+        if ( tmp != null ) {
+            order = MessageOrder.add(tmp,order);
+        }
+        
+        
+        while ( (order!=null) && (order.getMsgNr() <= cnt.getCounter())  ) {
+            //we are right on target. process orders
+            if ( order.getMsgNr() == cnt.getCounter() ) cnt.inc();
+            else if ( order.getMsgNr() > cnt.getCounter() ) cnt.setCounter(order.getMsgNr());
+            super.messageReceived(order.getMessage());
+            order.setMessage(null);
+            order = order.next;
+        }
+        MessageOrder head = order;
+        MessageOrder prev = null;
+        tmp = order;
+        //flag to empty out the queue when it larger than maxQueue
+        boolean empty = order!=null?order.getCount()>=maxQueue:false;
+        while ( tmp != null ) {
+            //process expired messages or empty out the queue
+            if ( tmp.isExpired(expire) || empty ) {
+                //reset the head
+                if ( tmp == head ) head = tmp.next;
+                cnt.setCounter(tmp.getMsgNr()+1);
+                if ( getForwardExpired() ) super.messageReceived(tmp.getMessage());
+                tmp.setMessage(null);
+                tmp = tmp.next;
+                if ( prev != null ) prev.next = tmp;  
+                result = true;
+            } else {
+                prev = tmp;
+                tmp = tmp.next;
+            }
+        }
+        if ( head == null ) incoming.remove(member);
+        else incoming.put(member, head);
+        return result;
+    }
+    
+    public void memberAdded(Member member) {
+        //notify upwards
+        getInCounter(member);
+        getOutCounter(member);
+        super.memberAdded(member);
+    }
+
+    public void memberDisappeared(Member member) {
+        //notify upwards
+        outcounter.remove(member);
+        incounter.remove(member);
+        //clear the remaining queue
+        processLeftOvers(member,true);
+        super.memberDisappeared(member);
+    }
+    
+    public int incCounter(Member mbr) { 
+        Counter cnt = getOutCounter(mbr);
+        return cnt.inc();
+    }
+    
+    public synchronized Counter getInCounter(Member mbr) {
+        Counter cnt = (Counter)incounter.get(mbr);
+        if ( cnt == null ) {
+            cnt = new Counter();
+            cnt.inc(); //always start at 1 for incoming
+            incounter.put(mbr,cnt);
+        }
+        return cnt;
+    }
+
+    public synchronized Counter getOutCounter(Member mbr) {
+        Counter cnt = (Counter)outcounter.get(mbr);
+        if ( cnt == null ) {
+            cnt = new Counter();
+            outcounter.put(mbr,cnt);
+        }
+        return cnt;
+    }
+
+    public static class Counter {
+        private int value = 0;
+        
+        public int getCounter() {
+            return value;
+        }
+        
+        public synchronized void setCounter(int counter) {
+            this.value = counter;
+        }
+        
+        public synchronized int inc() {
+            return ++value;
+        }
+    }
+    
+    public static class MessageOrder {
+        private long received = System.currentTimeMillis();
+        private MessageOrder next;
+        private int msgNr;
+        private ChannelMessage msg = null;
+        public MessageOrder(int msgNr,ChannelMessage msg) {
+            this.msgNr = msgNr;
+            this.msg = msg;
+        }
+        
+        public boolean isExpired(long expireTime) {
+            return (System.currentTimeMillis()-received) > expireTime;
+        }
+        
+        public ChannelMessage getMessage() {
+            return msg;
+        }
+        
+        public void setMessage(ChannelMessage msg) {
+            this.msg = msg;
+        }
+        
+        public void setNext(MessageOrder order) {
+            this.next = order;
+        }
+        public MessageOrder getNext() {
+            return next;
+        }
+        
+        public int getCount() {
+            int counter = 1;
+            MessageOrder tmp = next;
+            while ( tmp != null ) {
+                counter++;
+                tmp = tmp.next;
+            }
+            return counter;
+        }
+        
+        public static MessageOrder add(MessageOrder head, MessageOrder add) {
+            if ( head == null ) return add;
+            if ( add == null ) return head;
+            if ( head == add ) return add;
+
+            if ( head.getMsgNr() > add.getMsgNr() ) {
+                add.next = head;
+                return add;
+            }
+            
+            MessageOrder iter = head;
+            MessageOrder prev = null;
+            while ( iter.getMsgNr() < add.getMsgNr() && (iter.next !=null ) ) {
+                prev = iter;
+                iter = iter.next;
+            }
+            if ( iter.getMsgNr() < add.getMsgNr() ) {
+                //add after
+                add.next = iter.next;
+                iter.next = add;
+            } else if (iter.getMsgNr() > add.getMsgNr()) {
+                //add before
+                prev.next = add;
+                add.next = iter;
+                
+            } else {
+                throw new ArithmeticException("Message added has the same counter, synchronization bug. Disable the order interceptor");
+            }
+            
+            return head;
+        }
+        
+        public int getMsgNr() {
+            return msgNr;
+        }
+        
+        
+        
+    }
+
+    public void setExpire(long expire) {
+        this.expire = expire;
+    }
+
+    public void setForwardExpired(boolean forwardExpired) {
+        this.forwardExpired = forwardExpired;
+    }
+
+    public void setMaxQueue(int maxQueue) {
+        this.maxQueue = maxQueue;
+    }
+
+    public long getExpire() {
+        return expire;
+    }
+
+    public boolean getForwardExpired() {
+        return forwardExpired;
+    }
+
+    public int getMaxQueue() {
+        return maxQueue;
+    }
+
+}

==================================================
ThroughputInterceptor.java
index 2169c51d3b..59c1fea384 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java
@@ -1,289 +1,289 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- */
-package org.apache.catalina.tribes.group.interceptors;
-
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Socket;
-import java.net.SocketTimeoutException;
-import java.util.Arrays;
-import java.util.HashMap;
-
-import org.apache.catalina.tribes.Channel;
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelException.FaultyMember;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.RemoteProcessException;
-import org.apache.catalina.tribes.group.ChannelInterceptorBase;
-import org.apache.catalina.tribes.group.InterceptorPayload;
-import org.apache.catalina.tribes.io.ChannelData;
-import org.apache.catalina.tribes.io.XByteBuffer;
-import org.apache.catalina.tribes.membership.MemberImpl;
-import org.apache.catalina.tribes.membership.Membership;
-import java.net.ConnectException;
-
-/**
- * <p>Title: A perfect failure detector </p>
- *
- * <p>Description: The TcpFailureDetector is a useful interceptor
- * that adds reliability to the membership layer.</p>
- * <p>
- * If the network is busy, or the system is busy so that the membership receiver thread
- * is not getting enough time to update its table, members can be &quot;timed out&quot;
- * This failure detector will intercept the memberDisappeared message(unless its a true shutdown message)
- * and connect to the member using TCP.
- * </p>
- * <p>
- * The TcpFailureDetector works in two ways. <br>
- * 1. It intercepts memberDisappeared events
- * 2. It catches send errors 
- * </p>
- *
- * @author Filip Hanik
- * @version 1.0
- */
-public class TcpFailureDetector extends ChannelInterceptorBase {
-    
-    private static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( TcpFailureDetector.class );
-    
-    protected static byte[] TCP_FAIL_DETECT = new byte[] {
-        79, -89, 115, 72, 121, -126, 67, -55, -97, 111, -119, -128, -95, 91, 7, 20,
-        125, -39, 82, 91, -21, -15, 67, -102, -73, 126, -66, -113, -127, 103, 30, -74,
-        55, 21, -66, -121, 69, 126, 76, -88, -65, 10, 77, 19, 83, 56, 21, 50,
-        85, -10, -108, -73, 58, -6, 64, 120, -111, 4, 125, -41, 114, -124, -64, -43};      
-    
-    protected boolean performConnectTest = true;
-
-    protected long connectTimeout = 1000;//1 second default
-    
-    protected boolean performSendTest = true;
-
-    protected boolean performReadTest = false;
-    
-    protected long readTestTimeout = 5000;//5 seconds
-    
-    protected Membership membership = null;
-    
-    protected HashMap removeSuspects = new HashMap();
-    
-    protected HashMap addSuspects = new HashMap();
-    
-    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
-        try {
-            super.sendMessage(destination, msg, payload);
-        }catch ( ChannelException cx ) {
-            FaultyMember[] mbrs = cx.getFaultyMembers();
-            for ( int i=0; i<mbrs.length; i++ ) {
-                if ( mbrs[i].getCause()!=null &&  
-                     (!(mbrs[i].getCause() instanceof RemoteProcessException)) ) {//RemoteProcessException's are ok
-                    this.memberDisappeared(mbrs[i].getMember());
-                }//end if
-            }//for
-            throw cx;
-        }
-    }
-
-    public void messageReceived(ChannelMessage msg) {
-        //catch incoming 
-        boolean process = true;
-        if ( okToProcess(msg.getOptions()) ) {
-            //check to see if it is a testMessage, if so, process = false
-            process = ( (msg.getMessage().getLength() != TCP_FAIL_DETECT.length) ||
-                        (!Arrays.equals(TCP_FAIL_DETECT,msg.getMessage().getBytes()) ) );
-        }//end if
-            
-        //ignore the message, it doesnt have the flag set
-        if ( process ) super.messageReceived(msg);
-        else if ( log.isDebugEnabled() ) log.debug("Received a failure detector packet:"+msg);
-    }//messageReceived
-    
-    
-    public void memberAdded(Member member) {
-        if ( membership == null ) setupMembership();
-        boolean notify = false;
-        synchronized (membership) {
-            if (removeSuspects.containsKey(member)) {
-                //previously marked suspect, system below picked up the member again
-                removeSuspects.remove(member);
-            } else if (membership.getMember( (MemberImpl) member) == null){
-                //if we add it here, then add it upwards too
-                //check to see if it is alive
-                if (memberAlive(member)) {
-                    membership.memberAlive( (MemberImpl) member);
-                    notify = true;
-                } else {
-                    addSuspects.put(member, new Long(System.currentTimeMillis()));
-                }
-            }
-        }
-        if ( notify ) super.memberAdded(member);
-    }
-
-    public void memberDisappeared(Member member) {
-        if ( membership == null ) setupMembership();
-        boolean notify = false;
-        boolean shutdown = Arrays.equals(member.getCommand(),Member.SHUTDOWN_PAYLOAD);
-        if ( !shutdown ) log.info("Received memberDisappeared["+member+"] message. Will verify.");
-        synchronized (membership) {
-            //check to see if the member really is gone
-            //if the payload is not a shutdown message
-            if (shutdown || !memberAlive(member)) {
-                //not correct, we need to maintain the map
-                membership.removeMember( (MemberImpl) member);
-                removeSuspects.remove(member);
-                notify = true;
-            } else {
-                //add the member as suspect
-                removeSuspects.put(member, new Long(System.currentTimeMillis()));
-            }
-        }
-        if ( notify ) {
-            log.info("Verification complete. Member disappeared["+member+"]");
-            super.memberDisappeared(member);
-        } else {
-            log.info("Verification complete. Member still alive["+member+"]");
-
-        }
-    }
-    
-    public boolean hasMembers() {
-        if ( membership == null ) setupMembership();
-        return membership.hasMembers();
-    }
-
-    public Member[] getMembers() {
-        if ( membership == null ) setupMembership();
-        return membership.getMembers();
-    }
-
-    public Member getMember(Member mbr) {
-        if ( membership == null ) setupMembership();
-        return membership.getMember(mbr);
-    }
-
-    public Member getLocalMember(boolean incAlive) {
-        return super.getLocalMember(incAlive);
-    }
-    
-    public void heartbeat() {
-        try {
-            if (membership == null) setupMembership();
-            synchronized (membership) {
-                //update all alive times
-                Member[] members = super.getMembers();
-                for (int i = 0; members != null && i < members.length; i++) {
-                    if (membership.memberAlive( (MemberImpl) members[i])) {
-                        //we don't have this one in our membership, check to see if he/she is alive
-                        if (memberAlive(members[i])) {
-                            log.warn("Member added, even though we werent notified:" + members[i]);
-                            super.memberAdded(members[i]);
-                        } else {
-                            membership.removeMember( (MemberImpl) members[i]);
-                        } //end if
-                    } //end if
-                } //for
-
-                //check suspect members if they are still alive,
-                //if not, simply issue the memberDisappeared message
-                MemberImpl[] keys = (MemberImpl[]) removeSuspects.keySet().toArray(new MemberImpl[removeSuspects.size()]);
-                for (int i = 0; i < keys.length; i++) {
-                    MemberImpl m = (MemberImpl) keys[i];
-                    if (membership.getMember(m) != null && (!memberAlive(m))) {
-                        membership.removeMember(m);
-                        super.memberDisappeared(m);
-                        removeSuspects.remove(m);
-                        log.info("Suspect member, confirmed dead.["+m+"]");
-                    } //end if
-                }
-
-                //check add suspects members if they are alive now,
-                //if they are, simply issue the memberAdded message
-                keys = (MemberImpl[]) addSuspects.keySet().toArray(new MemberImpl[addSuspects.size()]);
-                for (int i = 0; i < keys.length; i++) {
-                    MemberImpl m = (MemberImpl) keys[i];
-                    if ( membership.getMember(m) == null && (memberAlive(m))) {
-                        membership.memberAlive(m);
-                        super.memberAdded(m);
-                        addSuspects.remove(m);
-                        log.info("Suspect member, confirmed alive.["+m+"]");
-                    } //end if
-                }
-            }
-        }catch ( Exception x ) {
-            log.warn("Unable to perform heartbeat on the TcpFailureDetector.",x);
-        } finally {
-            super.heartbeat();
-        }
-    }
-    
-    protected synchronized void setupMembership() {
-        if ( membership == null ) {
-            membership = new Membership((MemberImpl)super.getLocalMember(true));
-        }
-        
-    }
-    
-    protected boolean memberAlive(Member mbr) {
-        return memberAlive(mbr,TCP_FAIL_DETECT,performSendTest,performReadTest,readTestTimeout,connectTimeout,getOptionFlag());
-    }
-    
-    protected static boolean memberAlive(Member mbr, byte[] msgData, 
-                                         boolean sendTest, boolean readTest,
-                                         long readTimeout, long conTimeout,
-                                         int optionFlag) {
-        //could be a shutdown notification
-        if ( Arrays.equals(mbr.getCommand(),Member.SHUTDOWN_PAYLOAD) ) return false;
-        
-        Socket socket = new Socket();        
-        try {
-            InetAddress ia = InetAddress.getByAddress(mbr.getHost());
-            InetSocketAddress addr = new InetSocketAddress(ia, mbr.getPort());
-            socket.setSoTimeout((int)readTimeout);
-            socket.connect(addr, (int) conTimeout);
-            if ( sendTest ) {
-                ChannelData data = new ChannelData(true);
-                data.setAddress(mbr);
-                data.setMessage(new XByteBuffer(msgData,false));
-                data.setTimestamp(System.currentTimeMillis());
-                int options = optionFlag | Channel.SEND_OPTIONS_BYTE_MESSAGE;
-                if ( readTest ) options = (options | Channel.SEND_OPTIONS_USE_ACK);
-                else options = (options & (~Channel.SEND_OPTIONS_USE_ACK));
-                data.setOptions(options);
-                byte[] message = XByteBuffer.createDataPackage(data);
-                socket.getOutputStream().write(message);
-                if ( readTest ) {
-                    int length = socket.getInputStream().read(message);
-                    return length > 0;
-                }
-            }//end if
-            return true;
-        } catch ( SocketTimeoutException sx) {
-            //do nothing, we couldn't connect
-        } catch ( ConnectException cx) {
-            //do nothing, we couldn't connect
-        }catch (Exception x ) {
-            log.error("Unable to perform failure detection check, assuming member down.",x);
-        } finally {
-            try {socket.close(); } catch ( Exception ignore ){}
-        }
-        return false;
-    }
-
-
-
-    
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ */
+package org.apache.catalina.tribes.group.interceptors;
+
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Socket;
+import java.net.SocketTimeoutException;
+import java.util.Arrays;
+import java.util.HashMap;
+
+import org.apache.catalina.tribes.Channel;
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelException.FaultyMember;
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.RemoteProcessException;
+import org.apache.catalina.tribes.group.ChannelInterceptorBase;
+import org.apache.catalina.tribes.group.InterceptorPayload;
+import org.apache.catalina.tribes.io.ChannelData;
+import org.apache.catalina.tribes.io.XByteBuffer;
+import org.apache.catalina.tribes.membership.MemberImpl;
+import org.apache.catalina.tribes.membership.Membership;
+import java.net.ConnectException;
+
+/**
+ * <p>Title: A perfect failure detector </p>
+ *
+ * <p>Description: The TcpFailureDetector is a useful interceptor
+ * that adds reliability to the membership layer.</p>
+ * <p>
+ * If the network is busy, or the system is busy so that the membership receiver thread
+ * is not getting enough time to update its table, members can be &quot;timed out&quot;
+ * This failure detector will intercept the memberDisappeared message(unless its a true shutdown message)
+ * and connect to the member using TCP.
+ * </p>
+ * <p>
+ * The TcpFailureDetector works in two ways. <br>
+ * 1. It intercepts memberDisappeared events
+ * 2. It catches send errors 
+ * </p>
+ *
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class TcpFailureDetector extends ChannelInterceptorBase {
+    
+    private static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( TcpFailureDetector.class );
+    
+    protected static byte[] TCP_FAIL_DETECT = new byte[] {
+        79, -89, 115, 72, 121, -126, 67, -55, -97, 111, -119, -128, -95, 91, 7, 20,
+        125, -39, 82, 91, -21, -15, 67, -102, -73, 126, -66, -113, -127, 103, 30, -74,
+        55, 21, -66, -121, 69, 126, 76, -88, -65, 10, 77, 19, 83, 56, 21, 50,
+        85, -10, -108, -73, 58, -6, 64, 120, -111, 4, 125, -41, 114, -124, -64, -43};      
+    
+    protected boolean performConnectTest = true;
+
+    protected long connectTimeout = 1000;//1 second default
+    
+    protected boolean performSendTest = true;
+
+    protected boolean performReadTest = false;
+    
+    protected long readTestTimeout = 5000;//5 seconds
+    
+    protected Membership membership = null;
+    
+    protected HashMap removeSuspects = new HashMap();
+    
+    protected HashMap addSuspects = new HashMap();
+    
+    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
+        try {
+            super.sendMessage(destination, msg, payload);
+        }catch ( ChannelException cx ) {
+            FaultyMember[] mbrs = cx.getFaultyMembers();
+            for ( int i=0; i<mbrs.length; i++ ) {
+                if ( mbrs[i].getCause()!=null &&  
+                     (!(mbrs[i].getCause() instanceof RemoteProcessException)) ) {//RemoteProcessException's are ok
+                    this.memberDisappeared(mbrs[i].getMember());
+                }//end if
+            }//for
+            throw cx;
+        }
+    }
+
+    public void messageReceived(ChannelMessage msg) {
+        //catch incoming 
+        boolean process = true;
+        if ( okToProcess(msg.getOptions()) ) {
+            //check to see if it is a testMessage, if so, process = false
+            process = ( (msg.getMessage().getLength() != TCP_FAIL_DETECT.length) ||
+                        (!Arrays.equals(TCP_FAIL_DETECT,msg.getMessage().getBytes()) ) );
+        }//end if
+            
+        //ignore the message, it doesnt have the flag set
+        if ( process ) super.messageReceived(msg);
+        else if ( log.isDebugEnabled() ) log.debug("Received a failure detector packet:"+msg);
+    }//messageReceived
+    
+    
+    public void memberAdded(Member member) {
+        if ( membership == null ) setupMembership();
+        boolean notify = false;
+        synchronized (membership) {
+            if (removeSuspects.containsKey(member)) {
+                //previously marked suspect, system below picked up the member again
+                removeSuspects.remove(member);
+            } else if (membership.getMember( (MemberImpl) member) == null){
+                //if we add it here, then add it upwards too
+                //check to see if it is alive
+                if (memberAlive(member)) {
+                    membership.memberAlive( (MemberImpl) member);
+                    notify = true;
+                } else {
+                    addSuspects.put(member, new Long(System.currentTimeMillis()));
+                }
+            }
+        }
+        if ( notify ) super.memberAdded(member);
+    }
+
+    public void memberDisappeared(Member member) {
+        if ( membership == null ) setupMembership();
+        boolean notify = false;
+        boolean shutdown = Arrays.equals(member.getCommand(),Member.SHUTDOWN_PAYLOAD);
+        if ( !shutdown ) log.info("Received memberDisappeared["+member+"] message. Will verify.");
+        synchronized (membership) {
+            //check to see if the member really is gone
+            //if the payload is not a shutdown message
+            if (shutdown || !memberAlive(member)) {
+                //not correct, we need to maintain the map
+                membership.removeMember( (MemberImpl) member);
+                removeSuspects.remove(member);
+                notify = true;
+            } else {
+                //add the member as suspect
+                removeSuspects.put(member, new Long(System.currentTimeMillis()));
+            }
+        }
+        if ( notify ) {
+            log.info("Verification complete. Member disappeared["+member+"]");
+            super.memberDisappeared(member);
+        } else {
+            log.info("Verification complete. Member still alive["+member+"]");
+
+        }
+    }
+    
+    public boolean hasMembers() {
+        if ( membership == null ) setupMembership();
+        return membership.hasMembers();
+    }
+
+    public Member[] getMembers() {
+        if ( membership == null ) setupMembership();
+        return membership.getMembers();
+    }
+
+    public Member getMember(Member mbr) {
+        if ( membership == null ) setupMembership();
+        return membership.getMember(mbr);
+    }
+
+    public Member getLocalMember(boolean incAlive) {
+        return super.getLocalMember(incAlive);
+    }
+    
+    public void heartbeat() {
+        try {
+            if (membership == null) setupMembership();
+            synchronized (membership) {
+                //update all alive times
+                Member[] members = super.getMembers();
+                for (int i = 0; members != null && i < members.length; i++) {
+                    if (membership.memberAlive( (MemberImpl) members[i])) {
+                        //we don't have this one in our membership, check to see if he/she is alive
+                        if (memberAlive(members[i])) {
+                            log.warn("Member added, even though we werent notified:" + members[i]);
+                            super.memberAdded(members[i]);
+                        } else {
+                            membership.removeMember( (MemberImpl) members[i]);
+                        } //end if
+                    } //end if
+                } //for
+
+                //check suspect members if they are still alive,
+                //if not, simply issue the memberDisappeared message
+                MemberImpl[] keys = (MemberImpl[]) removeSuspects.keySet().toArray(new MemberImpl[removeSuspects.size()]);
+                for (int i = 0; i < keys.length; i++) {
+                    MemberImpl m = (MemberImpl) keys[i];
+                    if (membership.getMember(m) != null && (!memberAlive(m))) {
+                        membership.removeMember(m);
+                        super.memberDisappeared(m);
+                        removeSuspects.remove(m);
+                        log.info("Suspect member, confirmed dead.["+m+"]");
+                    } //end if
+                }
+
+                //check add suspects members if they are alive now,
+                //if they are, simply issue the memberAdded message
+                keys = (MemberImpl[]) addSuspects.keySet().toArray(new MemberImpl[addSuspects.size()]);
+                for (int i = 0; i < keys.length; i++) {
+                    MemberImpl m = (MemberImpl) keys[i];
+                    if ( membership.getMember(m) == null && (memberAlive(m))) {
+                        membership.memberAlive(m);
+                        super.memberAdded(m);
+                        addSuspects.remove(m);
+                        log.info("Suspect member, confirmed alive.["+m+"]");
+                    } //end if
+                }
+            }
+        }catch ( Exception x ) {
+            log.warn("Unable to perform heartbeat on the TcpFailureDetector.",x);
+        } finally {
+            super.heartbeat();
+        }
+    }
+    
+    protected synchronized void setupMembership() {
+        if ( membership == null ) {
+            membership = new Membership((MemberImpl)super.getLocalMember(true));
+        }
+        
+    }
+    
+    protected boolean memberAlive(Member mbr) {
+        return memberAlive(mbr,TCP_FAIL_DETECT,performSendTest,performReadTest,readTestTimeout,connectTimeout,getOptionFlag());
+    }
+    
+    protected static boolean memberAlive(Member mbr, byte[] msgData, 
+                                         boolean sendTest, boolean readTest,
+                                         long readTimeout, long conTimeout,
+                                         int optionFlag) {
+        //could be a shutdown notification
+        if ( Arrays.equals(mbr.getCommand(),Member.SHUTDOWN_PAYLOAD) ) return false;
+        
+        Socket socket = new Socket();        
+        try {
+            InetAddress ia = InetAddress.getByAddress(mbr.getHost());
+            InetSocketAddress addr = new InetSocketAddress(ia, mbr.getPort());
+            socket.setSoTimeout((int)readTimeout);
+            socket.connect(addr, (int) conTimeout);
+            if ( sendTest ) {
+                ChannelData data = new ChannelData(true);
+                data.setAddress(mbr);
+                data.setMessage(new XByteBuffer(msgData,false));
+                data.setTimestamp(System.currentTimeMillis());
+                int options = optionFlag | Channel.SEND_OPTIONS_BYTE_MESSAGE;
+                if ( readTest ) options = (options | Channel.SEND_OPTIONS_USE_ACK);
+                else options = (options & (~Channel.SEND_OPTIONS_USE_ACK));
+                data.setOptions(options);
+                byte[] message = XByteBuffer.createDataPackage(data);
+                socket.getOutputStream().write(message);
+                if ( readTest ) {
+                    int length = socket.getInputStream().read(message);
+                    return length > 0;
+                }
+            }//end if
+            return true;
+        } catch ( SocketTimeoutException sx) {
+            //do nothing, we couldn't connect
+        } catch ( ConnectException cx) {
+            //do nothing, we couldn't connect
+        }catch (Exception x ) {
+            log.error("Unable to perform failure detection check, assuming member down.",x);
+        } finally {
+            try {socket.close(); } catch ( Exception ignore ){}
+        }
+        return false;
+    }
+
+
+
+    
 }
\ No newline at end of file

==================================================
TwoPhaseCommitInterceptor.java
index 537cf55d43..e9636a91b7 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/ThroughputInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/ThroughputInterceptor.java
@@ -1,120 +1,120 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- */
-
-package org.apache.catalina.tribes.group.interceptors;
-
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.group.ChannelInterceptorBase;
-import org.apache.catalina.tribes.group.InterceptorPayload;
-import org.apache.catalina.tribes.io.ChannelData;
-import org.apache.catalina.tribes.io.XByteBuffer;
-import java.text.DecimalFormat;
-import org.apache.catalina.tribes.membership.MemberImpl;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicLong;
-
-
-
-/**
- *
- *
- * @author Filip Hanik
- * @version 1.0
- */
-public class ThroughputInterceptor extends ChannelInterceptorBase {
-    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(ThroughputInterceptor.class);
-
-    double mbTx = 0;
-    double mbAppTx = 0;
-    double mbRx = 0;
-    double timeTx = 0;
-    double lastCnt = 0;
-    AtomicLong msgTxCnt = new AtomicLong(1);
-    AtomicLong msgRxCnt = new AtomicLong(0);
-    AtomicLong msgTxErr = new AtomicLong(0);
-    int interval = 10000;
-    AtomicInteger access = new AtomicInteger(0);
-    long txStart = 0;
-    long rxStart = 0;
-    DecimalFormat df = new DecimalFormat("#0.00");
-
-
-    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
-        if ( access.addAndGet(1) == 1 ) txStart = System.currentTimeMillis();
-        long bytes = XByteBuffer.getDataPackageLength(((ChannelData)msg).getDataPackageLength());
-        try {
-            super.sendMessage(destination, msg, payload);
-        }catch ( ChannelException x ) {
-            msgTxErr.addAndGet(1);
-            access.addAndGet(-1);
-            throw x;
-        } 
-        mbTx += ((double)(bytes*destination.length))/(1024d*1024d);
-        mbAppTx += ((double)(bytes))/(1024d*1024d);
-        if ( access.addAndGet(-1) == 0 ) {
-            long stop = System.currentTimeMillis();
-            timeTx += ( (double) (stop - txStart)) / 1000d;
-            if ((msgTxCnt.get() / interval) >= lastCnt) {
-                lastCnt++;
-                report(timeTx);
-            }
-        }
-        msgTxCnt.addAndGet(1);
-    }
-
-    public void messageReceived(ChannelMessage msg) {
-        if ( rxStart == 0 ) rxStart = System.currentTimeMillis();
-        long bytes = XByteBuffer.getDataPackageLength(((ChannelData)msg).getDataPackageLength());
-        mbRx += ((double)bytes)/(1024d*1024d);
-        msgRxCnt.addAndGet(1);
-        if ( msgRxCnt.get() % interval == 0 ) report(timeTx);
-        super.messageReceived(msg);
-        
-    }
-    
-    public void report(double timeTx) {
-        StringBuffer buf = new StringBuffer("ThroughputInterceptor Report[\n\tTx Msg:");
-        buf.append(msgTxCnt).append(" messages\n\tSent:");
-        buf.append(df.format(mbTx));
-        buf.append(" MB (total)\n\tSent:");
-        buf.append(df.format(mbAppTx));
-        buf.append(" MB (application)\n\tTime:");
-        buf.append(df.format(timeTx));
-        buf.append(" seconds\n\tTx Speed:");
-        buf.append(df.format(mbTx/timeTx));
-        buf.append(" MB/sec (total)\n\tTxSpeed:");
-        buf.append(df.format(mbAppTx/timeTx));
-        buf.append(" MB/sec (application)\n\tError Msg:");
-        buf.append(msgTxErr).append("\n\tRx Msg:");
-        buf.append(msgRxCnt);
-        buf.append(" messages\n\tRx Speed:");
-        buf.append(df.format(mbRx/((double)((System.currentTimeMillis()-rxStart)/1000))));
-        buf.append(" MB/sec (since 1st msg)\n\tReceived:");
-        buf.append(df.format(mbRx)).append(" MB]\n");
-        if ( log.isInfoEnabled() ) log.info(buf);
-    }
-    
-    public void setInterval(int interval) {
-        this.interval = interval;
-    }
-
-    public int getInterval() {
-        return interval;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ */
+
+package org.apache.catalina.tribes.group.interceptors;
+
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.group.ChannelInterceptorBase;
+import org.apache.catalina.tribes.group.InterceptorPayload;
+import org.apache.catalina.tribes.io.ChannelData;
+import org.apache.catalina.tribes.io.XByteBuffer;
+import java.text.DecimalFormat;
+import org.apache.catalina.tribes.membership.MemberImpl;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
+
+
+
+/**
+ *
+ *
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class ThroughputInterceptor extends ChannelInterceptorBase {
+    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(ThroughputInterceptor.class);
+
+    double mbTx = 0;
+    double mbAppTx = 0;
+    double mbRx = 0;
+    double timeTx = 0;
+    double lastCnt = 0;
+    AtomicLong msgTxCnt = new AtomicLong(1);
+    AtomicLong msgRxCnt = new AtomicLong(0);
+    AtomicLong msgTxErr = new AtomicLong(0);
+    int interval = 10000;
+    AtomicInteger access = new AtomicInteger(0);
+    long txStart = 0;
+    long rxStart = 0;
+    DecimalFormat df = new DecimalFormat("#0.00");
+
+
+    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
+        if ( access.addAndGet(1) == 1 ) txStart = System.currentTimeMillis();
+        long bytes = XByteBuffer.getDataPackageLength(((ChannelData)msg).getDataPackageLength());
+        try {
+            super.sendMessage(destination, msg, payload);
+        }catch ( ChannelException x ) {
+            msgTxErr.addAndGet(1);
+            access.addAndGet(-1);
+            throw x;
+        } 
+        mbTx += ((double)(bytes*destination.length))/(1024d*1024d);
+        mbAppTx += ((double)(bytes))/(1024d*1024d);
+        if ( access.addAndGet(-1) == 0 ) {
+            long stop = System.currentTimeMillis();
+            timeTx += ( (double) (stop - txStart)) / 1000d;
+            if ((msgTxCnt.get() / interval) >= lastCnt) {
+                lastCnt++;
+                report(timeTx);
+            }
+        }
+        msgTxCnt.addAndGet(1);
+    }
+
+    public void messageReceived(ChannelMessage msg) {
+        if ( rxStart == 0 ) rxStart = System.currentTimeMillis();
+        long bytes = XByteBuffer.getDataPackageLength(((ChannelData)msg).getDataPackageLength());
+        mbRx += ((double)bytes)/(1024d*1024d);
+        msgRxCnt.addAndGet(1);
+        if ( msgRxCnt.get() % interval == 0 ) report(timeTx);
+        super.messageReceived(msg);
+        
+    }
+    
+    public void report(double timeTx) {
+        StringBuffer buf = new StringBuffer("ThroughputInterceptor Report[\n\tTx Msg:");
+        buf.append(msgTxCnt).append(" messages\n\tSent:");
+        buf.append(df.format(mbTx));
+        buf.append(" MB (total)\n\tSent:");
+        buf.append(df.format(mbAppTx));
+        buf.append(" MB (application)\n\tTime:");
+        buf.append(df.format(timeTx));
+        buf.append(" seconds\n\tTx Speed:");
+        buf.append(df.format(mbTx/timeTx));
+        buf.append(" MB/sec (total)\n\tTxSpeed:");
+        buf.append(df.format(mbAppTx/timeTx));
+        buf.append(" MB/sec (application)\n\tError Msg:");
+        buf.append(msgTxErr).append("\n\tRx Msg:");
+        buf.append(msgRxCnt);
+        buf.append(" messages\n\tRx Speed:");
+        buf.append(df.format(mbRx/((double)((System.currentTimeMillis()-rxStart)/1000))));
+        buf.append(" MB/sec (since 1st msg)\n\tReceived:");
+        buf.append(df.format(mbRx)).append(" MB]\n");
+        if ( log.isInfoEnabled() ) log.info(buf);
+    }
+    
+    public void setInterval(int interval) {
+        this.interval = interval;
+    }
+
+    public int getInterval() {
+        return interval;
+    }
+
+}

==================================================
BufferPool.java
index dd5d224c63..28fbbc3b9f 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/TwoPhaseCommitInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/TwoPhaseCommitInterceptor.java
@@ -1,149 +1,149 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.group.interceptors;
-
-import java.util.HashMap;
-
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.group.ChannelInterceptorBase;
-import org.apache.catalina.tribes.group.InterceptorPayload;
-import org.apache.catalina.tribes.util.UUIDGenerator;
-import org.apache.catalina.tribes.util.Arrays;
-import org.apache.catalina.tribes.UniqueId;
-import java.util.Map;
-
-/**
- * <p>Title: </p>
- *
- * <p>Description: </p>
- *
- * <p>Copyright: Copyright (c) 2005</p>
- *
- * <p>Company: </p>
- *
- * @author not attributable
- * @version 1.0
- */
-public class TwoPhaseCommitInterceptor extends ChannelInterceptorBase {
-
-    public static final byte[] START_DATA = new byte[] {113, 1, -58, 2, -34, -60, 75, -78, -101, -12, 32, -29, 32, 111, -40, 4};
-    public static final byte[] END_DATA = new byte[] {54, -13, 90, 110, 47, -31, 75, -24, -81, -29, 36, 52, -58, 77, -110, 56};
-    private static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(TwoPhaseCommitInterceptor.class);
-
-    protected HashMap messages = new HashMap();
-    protected long expire = 1000 * 60; //one minute expiration
-    protected boolean deepclone = true;
-
-    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws
-        ChannelException {
-        //todo, optimize, if destination.length==1, then we can do
-        //msg.setOptions(msg.getOptions() & (~getOptionFlag())
-        //and just send one message
-        if (okToProcess(msg.getOptions()) ) {
-            super.sendMessage(destination, msg, null);
-            ChannelMessage confirmation = null;
-            if ( deepclone ) confirmation = (ChannelMessage)msg.deepclone();
-            else confirmation = (ChannelMessage)msg.clone();
-            confirmation.getMessage().reset();
-            UUIDGenerator.randomUUID(false,confirmation.getUniqueId(),0);
-            confirmation.getMessage().append(START_DATA,0,START_DATA.length);
-            confirmation.getMessage().append(msg.getUniqueId(),0,msg.getUniqueId().length);
-            confirmation.getMessage().append(END_DATA,0,END_DATA.length);
-            super.sendMessage(destination,confirmation,payload);
-        } else {
-            //turn off two phase commit
-            //this wont work if the interceptor has 0 as a flag
-            //since there is no flag to turn off
-            //msg.setOptions(msg.getOptions() & (~getOptionFlag()));
-            super.sendMessage(destination, msg, payload);
-        }
-    }
-
-    public void messageReceived(ChannelMessage msg) {
-        if (okToProcess(msg.getOptions())) {
-            if ( msg.getMessage().getLength() == (START_DATA.length+msg.getUniqueId().length+END_DATA.length) &&
-                 Arrays.contains(msg.getMessage().getBytesDirect(),0,START_DATA,0,START_DATA.length) &&
-                 Arrays.contains(msg.getMessage().getBytesDirect(),START_DATA.length+msg.getUniqueId().length,END_DATA,0,END_DATA.length) ) {
-                UniqueId id = new UniqueId(msg.getMessage().getBytesDirect(),START_DATA.length,msg.getUniqueId().length);
-                MapEntry original = (MapEntry)messages.get(id);
-                if ( original != null ) {
-                    super.messageReceived(original.msg);
-                    messages.remove(id);
-                } else log.warn("Received a confirmation, but original message is missing. Id:"+Arrays.toString(id.getBytes()));
-            } else {
-                UniqueId id = new UniqueId(msg.getUniqueId());
-                MapEntry entry = new MapEntry((ChannelMessage)msg.deepclone(),id,System.currentTimeMillis());
-                messages.put(id,entry);
-            }
-        } else {
-            super.messageReceived(msg);
-        }
-    }
-
-    public boolean getDeepclone() {
-        return deepclone;
-    }
-
-    public long getExpire() {
-        return expire;
-    }
-
-    public void setDeepclone(boolean deepclone) {
-        this.deepclone = deepclone;
-    }
-
-    public void setExpire(long expire) {
-        this.expire = expire;
-    }
-    
-    public void heartbeat() {
-        try {
-            long now = System.currentTimeMillis();
-            Map.Entry[] entries = (Map.Entry[])messages.entrySet().toArray(new Map.Entry[messages.size()]);
-            for (int i=0; i<entries.length; i++ ) {
-                MapEntry entry = (MapEntry)entries[i].getValue();
-                if ( entry.expired(now,expire) ) {
-                    log.info("Message ["+entry.id+"] has expired. Removing.");
-                    messages.remove(entry.id);
-                }//end if
-            }
-        } catch ( Exception x ) {
-            log.warn("Unable to perform heartbeat on the TwoPhaseCommit interceptor.",x);
-        } finally {
-            super.heartbeat();
-        }
-    }
-    
-    public static class MapEntry {
-        public ChannelMessage msg;
-        public UniqueId id;
-        public long timestamp;
-        
-        public MapEntry(ChannelMessage msg, UniqueId id, long timestamp) {
-            this.msg = msg;
-            this.id = id;
-            this.timestamp = timestamp;
-        }
-        public boolean expired(long now, long expiration) {
-            return (now - timestamp ) > expiration;
-        }
-
-    }
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.group.interceptors;
+
+import java.util.HashMap;
+
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.group.ChannelInterceptorBase;
+import org.apache.catalina.tribes.group.InterceptorPayload;
+import org.apache.catalina.tribes.util.UUIDGenerator;
+import org.apache.catalina.tribes.util.Arrays;
+import org.apache.catalina.tribes.UniqueId;
+import java.util.Map;
+
+/**
+ * <p>Title: </p>
+ *
+ * <p>Description: </p>
+ *
+ * <p>Copyright: Copyright (c) 2005</p>
+ *
+ * <p>Company: </p>
+ *
+ * @author not attributable
+ * @version 1.0
+ */
+public class TwoPhaseCommitInterceptor extends ChannelInterceptorBase {
+
+    public static final byte[] START_DATA = new byte[] {113, 1, -58, 2, -34, -60, 75, -78, -101, -12, 32, -29, 32, 111, -40, 4};
+    public static final byte[] END_DATA = new byte[] {54, -13, 90, 110, 47, -31, 75, -24, -81, -29, 36, 52, -58, 77, -110, 56};
+    private static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(TwoPhaseCommitInterceptor.class);
+
+    protected HashMap messages = new HashMap();
+    protected long expire = 1000 * 60; //one minute expiration
+    protected boolean deepclone = true;
+
+    public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws
+        ChannelException {
+        //todo, optimize, if destination.length==1, then we can do
+        //msg.setOptions(msg.getOptions() & (~getOptionFlag())
+        //and just send one message
+        if (okToProcess(msg.getOptions()) ) {
+            super.sendMessage(destination, msg, null);
+            ChannelMessage confirmation = null;
+            if ( deepclone ) confirmation = (ChannelMessage)msg.deepclone();
+            else confirmation = (ChannelMessage)msg.clone();
+            confirmation.getMessage().reset();
+            UUIDGenerator.randomUUID(false,confirmation.getUniqueId(),0);
+            confirmation.getMessage().append(START_DATA,0,START_DATA.length);
+            confirmation.getMessage().append(msg.getUniqueId(),0,msg.getUniqueId().length);
+            confirmation.getMessage().append(END_DATA,0,END_DATA.length);
+            super.sendMessage(destination,confirmation,payload);
+        } else {
+            //turn off two phase commit
+            //this wont work if the interceptor has 0 as a flag
+            //since there is no flag to turn off
+            //msg.setOptions(msg.getOptions() & (~getOptionFlag()));
+            super.sendMessage(destination, msg, payload);
+        }
+    }
+
+    public void messageReceived(ChannelMessage msg) {
+        if (okToProcess(msg.getOptions())) {
+            if ( msg.getMessage().getLength() == (START_DATA.length+msg.getUniqueId().length+END_DATA.length) &&
+                 Arrays.contains(msg.getMessage().getBytesDirect(),0,START_DATA,0,START_DATA.length) &&
+                 Arrays.contains(msg.getMessage().getBytesDirect(),START_DATA.length+msg.getUniqueId().length,END_DATA,0,END_DATA.length) ) {
+                UniqueId id = new UniqueId(msg.getMessage().getBytesDirect(),START_DATA.length,msg.getUniqueId().length);
+                MapEntry original = (MapEntry)messages.get(id);
+                if ( original != null ) {
+                    super.messageReceived(original.msg);
+                    messages.remove(id);
+                } else log.warn("Received a confirmation, but original message is missing. Id:"+Arrays.toString(id.getBytes()));
+            } else {
+                UniqueId id = new UniqueId(msg.getUniqueId());
+                MapEntry entry = new MapEntry((ChannelMessage)msg.deepclone(),id,System.currentTimeMillis());
+                messages.put(id,entry);
+            }
+        } else {
+            super.messageReceived(msg);
+        }
+    }
+
+    public boolean getDeepclone() {
+        return deepclone;
+    }
+
+    public long getExpire() {
+        return expire;
+    }
+
+    public void setDeepclone(boolean deepclone) {
+        this.deepclone = deepclone;
+    }
+
+    public void setExpire(long expire) {
+        this.expire = expire;
+    }
+    
+    public void heartbeat() {
+        try {
+            long now = System.currentTimeMillis();
+            Map.Entry[] entries = (Map.Entry[])messages.entrySet().toArray(new Map.Entry[messages.size()]);
+            for (int i=0; i<entries.length; i++ ) {
+                MapEntry entry = (MapEntry)entries[i].getValue();
+                if ( entry.expired(now,expire) ) {
+                    log.info("Message ["+entry.id+"] has expired. Removing.");
+                    messages.remove(entry.id);
+                }//end if
+            }
+        } catch ( Exception x ) {
+            log.warn("Unable to perform heartbeat on the TwoPhaseCommit interceptor.",x);
+        } finally {
+            super.heartbeat();
+        }
+    }
+    
+    public static class MapEntry {
+        public ChannelMessage msg;
+        public UniqueId id;
+        public long timestamp;
+        
+        public MapEntry(ChannelMessage msg, UniqueId id, long timestamp) {
+            this.msg = msg;
+            this.id = id;
+            this.timestamp = timestamp;
+        }
+        public boolean expired(long now, long expiration) {
+            return (now - timestamp ) > expiration;
+        }
+
+    }
+
 }
\ No newline at end of file

==================================================
BufferPool14Impl.java
index 62b9160c9c..39f6e4480c 100644
--- a/java/org/apache/catalina/tribes/io/BufferPool.java
+++ b/java/org/apache/catalina/tribes/io/BufferPool.java
@@ -1,94 +1,94 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.io;
-
-
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-
-/**
- *
- * @author Filip Hanik
- * 
- * @version 1.0
- */
-public class BufferPool {
-    protected static Log log = LogFactory.getLog(BufferPool.class);
-
-    public static int DEFAULT_POOL_SIZE = 100*1024*1024; //100MB
-
-
-
-    protected static BufferPool instance = null;
-    protected BufferPoolAPI pool = null;
-
-    private BufferPool(BufferPoolAPI pool) {
-        this.pool = pool;
-    }
-
-    public XByteBuffer getBuffer(int minSize, boolean discard) {
-        if ( pool != null ) return pool.getBuffer(minSize, discard);
-        else return new XByteBuffer(minSize,discard);
-    }
-
-    public void returnBuffer(XByteBuffer buffer) {
-        if ( pool != null ) pool.returnBuffer(buffer);
-    }
-
-    public void clear() {
-        if ( pool != null ) pool.clear();
-    }
-
-
-    public static BufferPool getBufferPool() {
-        if (  (instance == null) ) {
-            synchronized (BufferPool.class) {
-                if ( instance == null ) {
-                   BufferPoolAPI pool = null;
-                   Class clazz = null;
-                   try {
-                       clazz = Class.forName("org.apache.catalina.tribes.io.BufferPool15Impl");
-                       pool = (BufferPoolAPI)clazz.newInstance();
-                   } catch ( Throwable x ) {
-                       try {
-                           clazz = Class.forName("org.apache.catalina.tribes.io.BufferPool14Impl");
-                           pool = (BufferPoolAPI)clazz.newInstance();
-                       } catch ( Throwable e ) {
-                           log.warn("Unable to initilize BufferPool, not pooling XByteBuffer objects:"+x.getMessage());
-                           if ( log.isDebugEnabled() ) log.debug("Unable to initilize BufferPool, not pooling XByteBuffer objects:",x);
-                       }
-                   }
-                   pool.setMaxSize(DEFAULT_POOL_SIZE);
-                   log.info("Created a buffer pool with max size:"+DEFAULT_POOL_SIZE+" bytes of type:"+(clazz!=null?clazz.getName():"null"));
-                   instance = new BufferPool(pool);
-                }//end if
-            }//sync
-        }//end if
-        return instance;
-    }
-
-
-    public static interface BufferPoolAPI {
-        public void setMaxSize(int bytes);
-
-        public XByteBuffer getBuffer(int minSize, boolean discard);
-
-        public void returnBuffer(XByteBuffer buffer);
-
-        public void clear();
-    }    
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.io;
+
+
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+
+/**
+ *
+ * @author Filip Hanik
+ * 
+ * @version 1.0
+ */
+public class BufferPool {
+    protected static Log log = LogFactory.getLog(BufferPool.class);
+
+    public static int DEFAULT_POOL_SIZE = 100*1024*1024; //100MB
+
+
+
+    protected static BufferPool instance = null;
+    protected BufferPoolAPI pool = null;
+
+    private BufferPool(BufferPoolAPI pool) {
+        this.pool = pool;
+    }
+
+    public XByteBuffer getBuffer(int minSize, boolean discard) {
+        if ( pool != null ) return pool.getBuffer(minSize, discard);
+        else return new XByteBuffer(minSize,discard);
+    }
+
+    public void returnBuffer(XByteBuffer buffer) {
+        if ( pool != null ) pool.returnBuffer(buffer);
+    }
+
+    public void clear() {
+        if ( pool != null ) pool.clear();
+    }
+
+
+    public static BufferPool getBufferPool() {
+        if (  (instance == null) ) {
+            synchronized (BufferPool.class) {
+                if ( instance == null ) {
+                   BufferPoolAPI pool = null;
+                   Class clazz = null;
+                   try {
+                       clazz = Class.forName("org.apache.catalina.tribes.io.BufferPool15Impl");
+                       pool = (BufferPoolAPI)clazz.newInstance();
+                   } catch ( Throwable x ) {
+                       try {
+                           clazz = Class.forName("org.apache.catalina.tribes.io.BufferPool14Impl");
+                           pool = (BufferPoolAPI)clazz.newInstance();
+                       } catch ( Throwable e ) {
+                           log.warn("Unable to initilize BufferPool, not pooling XByteBuffer objects:"+x.getMessage());
+                           if ( log.isDebugEnabled() ) log.debug("Unable to initilize BufferPool, not pooling XByteBuffer objects:",x);
+                       }
+                   }
+                   pool.setMaxSize(DEFAULT_POOL_SIZE);
+                   log.info("Created a buffer pool with max size:"+DEFAULT_POOL_SIZE+" bytes of type:"+(clazz!=null?clazz.getName():"null"));
+                   instance = new BufferPool(pool);
+                }//end if
+            }//sync
+        }//end if
+        return instance;
+    }
+
+
+    public static interface BufferPoolAPI {
+        public void setMaxSize(int bytes);
+
+        public XByteBuffer getBuffer(int minSize, boolean discard);
+
+        public void returnBuffer(XByteBuffer buffer);
+
+        public void clear();
+    }    
+}

==================================================
BufferPool15Impl.java
index 95de910952..55c696d556 100644
--- a/java/org/apache/catalina/tribes/io/BufferPool14Impl.java
+++ b/java/org/apache/catalina/tribes/io/BufferPool14Impl.java
@@ -1,70 +1,70 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.io;
-
-import java.util.Queue;
-import java.util.LinkedList;
-
-
-/**
- *
- * @author Filip Hanik
- * @version 1.0
- */
-class BufferPool14Impl implements BufferPool.BufferPoolAPI {
-    protected int maxSize;
-    protected int size = 0;
-    protected LinkedList queue = new LinkedList();
-
-    public void setMaxSize(int bytes) {
-        this.maxSize = bytes;
-    }
-    
-    public synchronized int addAndGet(int val) {
-        size = size + (val);
-        return size;
-    }
-    
-    
-
-    public synchronized XByteBuffer getBuffer(int minSize, boolean discard) {
-        XByteBuffer buffer = (XByteBuffer)(queue.size()>0?queue.remove(0):null);
-        if ( buffer != null ) addAndGet(-buffer.getCapacity());
-        if ( buffer == null ) buffer = new XByteBuffer(minSize,discard);
-        else if ( buffer.getCapacity() <= minSize ) buffer.expand(minSize);
-        buffer.setDiscard(discard);
-        buffer.reset();
-        return buffer;
-    }
-
-    public synchronized void returnBuffer(XByteBuffer buffer) {
-        if ( (size + buffer.getCapacity()) <= maxSize ) {
-            addAndGet(buffer.getCapacity());
-            queue.add(buffer);
-        }
-    }
-
-    public synchronized void clear() {
-        queue.clear();
-        size = 0;
-    }
-
-    public int getMaxSize() {
-        return maxSize;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.io;
+
+import java.util.Queue;
+import java.util.LinkedList;
+
+
+/**
+ *
+ * @author Filip Hanik
+ * @version 1.0
+ */
+class BufferPool14Impl implements BufferPool.BufferPoolAPI {
+    protected int maxSize;
+    protected int size = 0;
+    protected LinkedList queue = new LinkedList();
+
+    public void setMaxSize(int bytes) {
+        this.maxSize = bytes;
+    }
+    
+    public synchronized int addAndGet(int val) {
+        size = size + (val);
+        return size;
+    }
+    
+    
+
+    public synchronized XByteBuffer getBuffer(int minSize, boolean discard) {
+        XByteBuffer buffer = (XByteBuffer)(queue.size()>0?queue.remove(0):null);
+        if ( buffer != null ) addAndGet(-buffer.getCapacity());
+        if ( buffer == null ) buffer = new XByteBuffer(minSize,discard);
+        else if ( buffer.getCapacity() <= minSize ) buffer.expand(minSize);
+        buffer.setDiscard(discard);
+        buffer.reset();
+        return buffer;
+    }
+
+    public synchronized void returnBuffer(XByteBuffer buffer) {
+        if ( (size + buffer.getCapacity()) <= maxSize ) {
+            addAndGet(buffer.getCapacity());
+            queue.add(buffer);
+        }
+    }
+
+    public synchronized void clear() {
+        queue.clear();
+        size = 0;
+    }
+
+    public int getMaxSize() {
+        return maxSize;
+    }
+
+}

==================================================
Constants.java
index 6cd29745a2..a1d32d4e91 100644
--- a/java/org/apache/catalina/tribes/io/BufferPool15Impl.java
+++ b/java/org/apache/catalina/tribes/io/BufferPool15Impl.java
@@ -1,63 +1,63 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.io;
-
-import java.util.concurrent.ConcurrentLinkedQueue;
-import java.util.concurrent.atomic.AtomicInteger;
-
-/**
- *
- * @author Filip Hanik
- * @version 1.0
- */
-class BufferPool15Impl implements BufferPool.BufferPoolAPI {
-    protected int maxSize;
-    protected AtomicInteger size = new AtomicInteger(0);
-    protected ConcurrentLinkedQueue queue = new ConcurrentLinkedQueue();
-
-    public void setMaxSize(int bytes) {
-        this.maxSize = bytes;
-    }
-
-
-    public XByteBuffer getBuffer(int minSize, boolean discard) {
-        XByteBuffer buffer = (XByteBuffer)queue.poll();
-        if ( buffer != null ) size.addAndGet(-buffer.getCapacity());
-        if ( buffer == null ) buffer = new XByteBuffer(minSize,discard);
-        else if ( buffer.getCapacity() <= minSize ) buffer.expand(minSize);
-        buffer.setDiscard(discard);
-        buffer.reset();
-        return buffer;
-    }
-
-    public void returnBuffer(XByteBuffer buffer) {
-        if ( (size.get() + buffer.getCapacity()) <= maxSize ) {
-            size.addAndGet(buffer.getCapacity());
-            queue.offer(buffer);
-        }
-    }
-
-    public void clear() {
-        queue.clear();
-        size.set(0);
-    }
-
-    public int getMaxSize() {
-        return maxSize;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.io;
+
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ *
+ * @author Filip Hanik
+ * @version 1.0
+ */
+class BufferPool15Impl implements BufferPool.BufferPoolAPI {
+    protected int maxSize;
+    protected AtomicInteger size = new AtomicInteger(0);
+    protected ConcurrentLinkedQueue queue = new ConcurrentLinkedQueue();
+
+    public void setMaxSize(int bytes) {
+        this.maxSize = bytes;
+    }
+
+
+    public XByteBuffer getBuffer(int minSize, boolean discard) {
+        XByteBuffer buffer = (XByteBuffer)queue.poll();
+        if ( buffer != null ) size.addAndGet(-buffer.getCapacity());
+        if ( buffer == null ) buffer = new XByteBuffer(minSize,discard);
+        else if ( buffer.getCapacity() <= minSize ) buffer.expand(minSize);
+        buffer.setDiscard(discard);
+        buffer.reset();
+        return buffer;
+    }
+
+    public void returnBuffer(XByteBuffer buffer) {
+        if ( (size.get() + buffer.getCapacity()) <= maxSize ) {
+            size.addAndGet(buffer.getCapacity());
+            queue.offer(buffer);
+        }
+    }
+
+    public void clear() {
+        queue.clear();
+        size.set(0);
+    }
+
+    public int getMaxSize() {
+        return maxSize;
+    }
+
+}

==================================================
McastService.java
index 1197024417..0879fcb270 100644
--- a/java/org/apache/catalina/tribes/membership/Constants.java
+++ b/java/org/apache/catalina/tribes/membership/Constants.java
@@ -1,40 +1,40 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina.tribes.membership;
-
-import org.apache.catalina.tribes.util.Arrays;
-
-
-/**
- * Manifest constants for the <code>org.apache.catalina.tribes.membership</code>
- * package.
- *
- * @author Peter Rossbach
- * @version $Revision: 303950 $ $Date: 2005-06-09 15:38:30 -0500 (Thu, 09 Jun 2005) $
- * @author Filip Hanik
- */
-
-public class Constants {
-
-    public static final String Package = "org.apache.catalina.tribes.membership";
-    public static void main(String[] args) throws Exception {
-        System.out.println(Arrays.toString("TRIBES-B".getBytes()));
-        System.out.println(Arrays.toString("TRIBES-E".getBytes()));
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.catalina.tribes.membership;
+
+import org.apache.catalina.tribes.util.Arrays;
+
+
+/**
+ * Manifest constants for the <code>org.apache.catalina.tribes.membership</code>
+ * package.
+ *
+ * @author Peter Rossbach
+ * @version $Revision$ $Date$
+ * @author Filip Hanik
+ */
+
+public class Constants {
+
+    public static final String Package = "org.apache.catalina.tribes.membership";
+    public static void main(String[] args) throws Exception {
+        System.out.println(Arrays.toString("TRIBES-B".getBytes()));
+        System.out.println(Arrays.toString("TRIBES-E".getBytes()));
+    }
+}

==================================================
McastServiceImpl.java
index 7ae1b73cf9..da85409242 100644
--- a/java/org/apache/catalina/tribes/membership/McastService.java
+++ b/java/org/apache/catalina/tribes/membership/McastService.java
@@ -1,552 +1,552 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.membership;
-
-import java.util.Properties;
-
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.MembershipListener;
-import org.apache.catalina.tribes.MembershipService;
-import org.apache.catalina.tribes.util.StringManager;
-import org.apache.catalina.tribes.util.UUIDGenerator;
-import java.io.IOException;
-
-/**
- * A <b>membership</b> implementation using simple multicast.
- * This is the representation of a multicast membership service.
- * This class is responsible for maintaining a list of active cluster nodes in the cluster.
- * If a node fails to send out a heartbeat, the node will be dismissed.
- *
- * @author Filip Hanik
- * @version $Revision: 378093 $, $Date: 2006-02-15 15:13:45 -0600 (Wed, 15 Feb 2006) $
- */
-
-
-public class McastService implements MembershipService,MembershipListener {
-
-    private static org.apache.juli.logging.Log log =
-        org.apache.juli.logging.LogFactory.getLog( McastService.class );
-
-    /**
-     * The string manager for this package.
-     */
-    protected StringManager sm = StringManager.getManager(Constants.Package);
-
-    /**
-     * The descriptive information about this implementation.
-     */
-    private static final String info = "McastService/2.1";
-
-    /**
-     * The implementation specific properties
-     */
-    protected Properties properties = new Properties();
-    /**
-     * A handle to the actual low level implementation
-     */
-    protected McastServiceImpl impl;
-    /**
-     * A membership listener delegate (should be the cluster :)
-     */
-    protected MembershipListener listener;
-    /**
-     * The local member
-     */
-    protected MemberImpl localMember ;
-    private int mcastSoTimeout;
-    private int mcastTTL;
-    
-    protected byte[] payload;
-    
-    protected byte[] domain;
-
-    /**
-     * Create a membership service.
-     */
-    public McastService() {
-        //default values
-        properties.setProperty("mcastPort","45564");
-        properties.setProperty("mcastAddress","228.0.0.4");
-        properties.setProperty("memberDropTime","3000");
-        properties.setProperty("mcastFrequency","500");
-
-    }
-
-    /**
-     * Return descriptive information about this implementation and the
-     * corresponding version number, in the format
-     * <code>&lt;description&gt;/&lt;version&gt;</code>.
-     */
-    public String getInfo() {
-        return (info);
-    }
-    
-    /**
-     *
-     * @param properties
-     * <BR/>All are required<BR />
-     * 1. mcastPort - the port to listen to<BR>
-     * 2. mcastAddress - the mcast group address<BR>
-     * 4. bindAddress - the bind address if any - only one that can be null<BR>
-     * 5. memberDropTime - the time a member is gone before it is considered gone.<BR>
-     * 6. mcastFrequency - the frequency of sending messages<BR>
-     * 7. tcpListenPort - the port this member listens to<BR>
-     * 8. tcpListenHost - the bind address of this member<BR>
-     * @exception java.lang.IllegalArgumentException if a property is missing.
-     */
-    public void setProperties(Properties properties) {
-        hasProperty(properties,"mcastPort");
-        hasProperty(properties,"mcastAddress");
-        hasProperty(properties,"memberDropTime");
-        hasProperty(properties,"mcastFrequency");
-        hasProperty(properties,"tcpListenPort");
-        hasProperty(properties,"tcpListenHost");
-        this.properties = properties;
-    }
-
-    /**
-     * Return the properties, see setProperties
-     */
-    public Properties getProperties() {
-        return properties;
-    }
-
-    /**
-     * Return the local member name
-     */
-    public String getLocalMemberName() {
-        return localMember.toString() ;
-    }
- 
-    /**
-     * Return the local member
-     */
-    public Member getLocalMember(boolean alive) {
-        if ( alive && localMember != null && impl != null) localMember.setMemberAliveTime(System.currentTimeMillis()-impl.getServiceStartTime());
-        return localMember;
-    }
-    
-    /**
-     * Sets the local member properties for broadcasting
-     */
-    public void setLocalMemberProperties(String listenHost, int listenPort) {
-        properties.setProperty("tcpListenHost",listenHost);
-        properties.setProperty("tcpListenPort",String.valueOf(listenPort));
-        try {
-            if (localMember != null) {
-                localMember.setHostname(listenHost);
-                localMember.setPort(listenPort);
-            } else {
-                localMember = new MemberImpl(listenHost, listenPort, 0);
-                localMember.setUniqueId(UUIDGenerator.randomUUID(true));
-                localMember.setPayload(getPayload());
-                localMember.setDomain(getDomain());
-            }
-            localMember.getData(true, true);
-        }catch ( IOException x ) {
-            throw new IllegalArgumentException(x);
-        }
-    }
-    
-    public void setAddress(String addr) {
-        properties.setProperty("mcastAddress", addr);
-    }
-    
-    /**
-     * @deprecated use setAddress
-     * @param addr String
-     */
-    public void setMcastAddr(String addr) {
-        setAddress(addr);
-    }
-    
-    public String getAddress() {
-        return properties.getProperty("mcastAddress");
-    }
-    
-    /**
-     * @deprecated use getAddress
-     * @return String
-     */
-    public String getMcastAddr() {
-        return getAddress();
-    }
-
-    public void setMcastBindAddress(String bindaddr) {
-        setBind(bindaddr);
-    }
-    
-    public void setBind(String bindaddr) {
-        properties.setProperty("mcastBindAddress", bindaddr);
-    }
-    /**
-     * @deprecated use getBind
-     * @return String
-     */
-    public String getMcastBindAddress() {
-        return getBind();
-    }
-
-    public String getBind() {
-        return properties.getProperty("mcastBindAddress");
-    }
-
-    /**
-     * @deprecated use setPort
-     * @param port int
-     */
-    public void setMcastPort(int port) {
-        setPort(port);
-    }
-
-    public void setPort(int port) {
-        properties.setProperty("mcastPort", String.valueOf(port));
-    }
-
-    /**
-     * @deprecated use getPort()
-     * @return int
-     */
-    public int getMcastPort() {
-        return getPort();
-    }
-    public int getPort() {
-        String p = properties.getProperty("mcastPort");
-        return new Integer(p).intValue();
-    }
-    
-    /**
-     * @deprecated use setFrequency
-     * @param time long
-     */
-    public void setMcastFrequency(long time) {
-        setFrequency(time);
-    }
-    
-    public void setFrequency(long time) {
-        properties.setProperty("mcastFrequency", String.valueOf(time));
-    }
-
-    /**
-     * @deprecated use getFrequency
-     * @return long
-     */
-    public long getMcastFrequency() {
-        return getFrequency();
-    }
-
-    public long getFrequency() {
-        String p = properties.getProperty("mcastFrequency");
-        return new Long(p).longValue();
-    }
-
-    public void setMcastDropTime(long time) {
-        setDropTime(time);
-    }
-    public void setDropTime(long time) {
-        properties.setProperty("memberDropTime", String.valueOf(time));
-    }
-    
-    /**
-     * @deprecated use getDropTime
-     * @return long
-     */
-    public long getMcastDropTime() {
-        return getDropTime();
-    }
-
-    public long getDropTime() {
-        String p = properties.getProperty("memberDropTime");
-        return new Long(p).longValue();
-    }
-
-    /**
-     * Check if a required property is available.
-     * @param properties The set of properties
-     * @param name The property to check for
-     */
-    protected void hasProperty(Properties properties, String name){
-        if ( properties.getProperty(name)==null) throw new IllegalArgumentException("McastService:Required property \""+name+"\" is missing.");
-    }
-
-    /**
-     * Start broadcasting and listening to membership pings
-     * @throws java.lang.Exception if a IO error occurs
-     */
-    public void start() throws java.lang.Exception {
-        start(MembershipService.MBR_RX);
-        start(MembershipService.MBR_TX);
-    }
-    
-    public void start(int level) throws java.lang.Exception {
-        hasProperty(properties,"mcastPort");
-        hasProperty(properties,"mcastAddress");
-        hasProperty(properties,"memberDropTime");
-        hasProperty(properties,"mcastFrequency");
-        hasProperty(properties,"tcpListenPort");
-        hasProperty(properties,"tcpListenHost");
-
-        if ( impl != null ) {
-            impl.start(level);
-            return;
-        }
-        String host = getProperties().getProperty("tcpListenHost");
-        int port = Integer.parseInt(getProperties().getProperty("tcpListenPort"));
-        
-        if ( localMember == null ) {
-            localMember = new MemberImpl(host, port, 100);
-            localMember.setUniqueId(UUIDGenerator.randomUUID(true));
-        } else {
-            localMember.setHostname(host);
-            localMember.setPort(port);
-            localMember.setMemberAliveTime(100);
-        }
-        if ( this.payload != null ) localMember.setPayload(payload);
-        if ( this.domain != null ) localMember.setDomain(domain);
-        localMember.setServiceStartTime(System.currentTimeMillis());
-        java.net.InetAddress bind = null;
-        if ( properties.getProperty("mcastBindAddress")!= null ) {
-            bind = java.net.InetAddress.getByName(properties.getProperty("mcastBindAddress"));
-        }
-        int ttl = -1;
-        int soTimeout = -1;
-        if ( properties.getProperty("mcastTTL") != null ) {
-            try {
-                ttl = Integer.parseInt(properties.getProperty("mcastTTL"));
-            } catch ( Exception x ) {
-                log.error("Unable to parse mcastTTL="+properties.getProperty("mcastTTL"),x);
-            }
-        }
-        if ( properties.getProperty("mcastSoTimeout") != null ) {
-            try {
-                soTimeout = Integer.parseInt(properties.getProperty("mcastSoTimeout"));
-            } catch ( Exception x ) {
-                log.error("Unable to parse mcastSoTimeout="+properties.getProperty("mcastSoTimeout"),x);
-            }
-        }
-
-        impl = new McastServiceImpl((MemberImpl)localMember,Long.parseLong(properties.getProperty("mcastFrequency")),
-                                    Long.parseLong(properties.getProperty("memberDropTime")),
-                                    Integer.parseInt(properties.getProperty("mcastPort")),
-                                    bind,
-                                    java.net.InetAddress.getByName(properties.getProperty("mcastAddress")),
-                                    ttl,
-                                    soTimeout,
-                                    this);
-        
-        impl.start(level);
-		
-
-    }
-
- 
-    /**
-     * Stop broadcasting and listening to membership pings
-     */
-    public void stop(int svc) {
-        try  {
-            if ( impl != null && impl.stop(svc) ) impl = null;
-        } catch ( Exception x)  {
-            log.error("Unable to stop the mcast service, level:"+svc+".",x);
-        }
-    }
-
-
-    /**
-     * Return all the members by name
-     */
-    public String[] getMembersByName() {
-        Member[] currentMembers = getMembers();
-        String [] membernames ;
-        if(currentMembers != null) {
-            membernames = new String[currentMembers.length];
-            for (int i = 0; i < currentMembers.length; i++) {
-                membernames[i] = currentMembers[i].toString() ;
-            }
-        } else
-            membernames = new String[0] ;
-        return membernames ;
-    }
- 
-    /**
-     * Return the member by name
-     */
-    public Member findMemberByName(String name) {
-        Member[] currentMembers = getMembers();
-        for (int i = 0; i < currentMembers.length; i++) {
-            if (name.equals(currentMembers[i].toString()))
-                return currentMembers[i];
-        }
-        return null;
-    }
-
-    /**
-     * has members?
-     */
-    public boolean hasMembers() {
-       if ( impl == null || impl.membership == null ) return false;
-       return impl.membership.hasMembers();
-    }
-    
-    public Member getMember(Member mbr) {
-        if ( impl == null || impl.membership == null ) return null;
-        return impl.membership.getMember(mbr);
-    }
-
-    /**
-     * Return all the members
-     */
-    public Member[] getMembers() {
-        if ( impl == null || impl.membership == null ) return null;
-        return impl.membership.getMembers();
-    }
-    /**
-     * Add a membership listener, this version only supports one listener per service,
-     * so calling this method twice will result in only the second listener being active.
-     * @param listener The listener
-     */
-    public void setMembershipListener(MembershipListener listener) {
-        this.listener = listener;
-    }
-    /**
-     * Remove the membership listener
-     */
-    public void removeMembershipListener(){
-        listener = null;
-    }
-
-    public void memberAdded(Member member) {
-        if ( listener!=null ) listener.memberAdded(member);
-    }
-
-    /**
-     * Callback from the impl when a new member has been received
-     * @param member The member
-     */
-    public void memberDisappeared(Member member)
-    {
-        if ( listener!=null ) listener.memberDisappeared(member);
-    }
-
-    /**
-     * @deprecated use getSoTimeout
-     * @return int
-     */
-    public int getMcastSoTimeout() {
-        return getSoTimeout();
-    }
-    
-    public int getSoTimeout() {
-        return mcastSoTimeout;
-    }
-    
-    /**
-     * @deprecated use setSoTimeout
-     * @param mcastSoTimeout int
-     */
-    public void setMcastSoTimeout(int mcastSoTimeout) {
-        setSoTimeout(mcastSoTimeout);
-    }
-    
-    public void setSoTimeout(int mcastSoTimeout) {
-        this.mcastSoTimeout = mcastSoTimeout;
-        properties.setProperty("mcastSoTimeout", String.valueOf(mcastSoTimeout));
-    }
-    
-    /**
-     * @deprecated use getTtl
-     * @return int
-     */
-    public int getMcastTTL() {
-        return getTtl();
-    }
-    
-    public int getTtl() {
-        return mcastTTL;
-    }
-
-    public byte[] getPayload() {
-        return payload;
-    }
-    
-    public byte[] getDomain() {
-        return domain;
-    }
-    
-    /**
-     * @deprecated use setTtl
-     * @param mcastTTL int
-     */
-    public void setMcastTTL(int mcastTTL) {
-        setTtl(mcastTTL);
-    }
-
-    public void setTtl(int mcastTTL) {
-        this.mcastTTL = mcastTTL;
-        properties.setProperty("mcastTTL", String.valueOf(mcastTTL));
-    }
-
-    public void setPayload(byte[] payload) {
-        this.payload = payload;
-        if ( localMember != null ) {
-            localMember.setPayload(payload);
-            localMember.getData(true,true);
-            try {
-                if (impl != null) impl.send(false);
-            }catch ( Exception x ) {
-                log.error("Unable to send payload update.",x);
-            }
-        }
-    }
-    
-    public void setDomain(byte[] domain) {
-        this.domain = domain;
-        if ( localMember != null ) {
-            localMember.setDomain(domain);
-            localMember.getData(true,true);
-            try {
-                if (impl != null) impl.send(false);
-            }catch ( Exception x ) {
-                log.error("Unable to send domain update.",x);
-            }
-        }
-    }
-
-    /**
-     * Simple test program
-     * @param args Command-line arguments
-     * @throws Exception If an error occurs
-     */
-    public static void main(String args[]) throws Exception {
-		if(log.isInfoEnabled())
-            log.info("Usage McastService hostname tcpport");
-        McastService service = new McastService();
-        java.util.Properties p = new java.util.Properties();
-        p.setProperty("mcastPort","5555");
-        p.setProperty("mcastAddress","224.10.10.10");
-        p.setProperty("mcastClusterDomain","catalina");
-        p.setProperty("bindAddress","localhost");
-        p.setProperty("memberDropTime","3000");
-        p.setProperty("mcastFrequency","500");
-        p.setProperty("tcpListenPort","4000");
-        p.setProperty("tcpListenHost","127.0.0.1");
-        service.setProperties(p);
-        service.start();
-        Thread.sleep(60*1000*60);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.membership;
+
+import java.util.Properties;
+
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.MembershipListener;
+import org.apache.catalina.tribes.MembershipService;
+import org.apache.catalina.tribes.util.StringManager;
+import org.apache.catalina.tribes.util.UUIDGenerator;
+import java.io.IOException;
+
+/**
+ * A <b>membership</b> implementation using simple multicast.
+ * This is the representation of a multicast membership service.
+ * This class is responsible for maintaining a list of active cluster nodes in the cluster.
+ * If a node fails to send out a heartbeat, the node will be dismissed.
+ *
+ * @author Filip Hanik
+ * @version $Revision$, $Date$
+ */
+
+
+public class McastService implements MembershipService,MembershipListener {
+
+    private static org.apache.juli.logging.Log log =
+        org.apache.juli.logging.LogFactory.getLog( McastService.class );
+
+    /**
+     * The string manager for this package.
+     */
+    protected StringManager sm = StringManager.getManager(Constants.Package);
+
+    /**
+     * The descriptive information about this implementation.
+     */
+    private static final String info = "McastService/2.1";
+
+    /**
+     * The implementation specific properties
+     */
+    protected Properties properties = new Properties();
+    /**
+     * A handle to the actual low level implementation
+     */
+    protected McastServiceImpl impl;
+    /**
+     * A membership listener delegate (should be the cluster :)
+     */
+    protected MembershipListener listener;
+    /**
+     * The local member
+     */
+    protected MemberImpl localMember ;
+    private int mcastSoTimeout;
+    private int mcastTTL;
+    
+    protected byte[] payload;
+    
+    protected byte[] domain;
+
+    /**
+     * Create a membership service.
+     */
+    public McastService() {
+        //default values
+        properties.setProperty("mcastPort","45564");
+        properties.setProperty("mcastAddress","228.0.0.4");
+        properties.setProperty("memberDropTime","3000");
+        properties.setProperty("mcastFrequency","500");
+
+    }
+
+    /**
+     * Return descriptive information about this implementation and the
+     * corresponding version number, in the format
+     * <code>&lt;description&gt;/&lt;version&gt;</code>.
+     */
+    public String getInfo() {
+        return (info);
+    }
+    
+    /**
+     *
+     * @param properties
+     * <BR/>All are required<BR />
+     * 1. mcastPort - the port to listen to<BR>
+     * 2. mcastAddress - the mcast group address<BR>
+     * 4. bindAddress - the bind address if any - only one that can be null<BR>
+     * 5. memberDropTime - the time a member is gone before it is considered gone.<BR>
+     * 6. mcastFrequency - the frequency of sending messages<BR>
+     * 7. tcpListenPort - the port this member listens to<BR>
+     * 8. tcpListenHost - the bind address of this member<BR>
+     * @exception java.lang.IllegalArgumentException if a property is missing.
+     */
+    public void setProperties(Properties properties) {
+        hasProperty(properties,"mcastPort");
+        hasProperty(properties,"mcastAddress");
+        hasProperty(properties,"memberDropTime");
+        hasProperty(properties,"mcastFrequency");
+        hasProperty(properties,"tcpListenPort");
+        hasProperty(properties,"tcpListenHost");
+        this.properties = properties;
+    }
+
+    /**
+     * Return the properties, see setProperties
+     */
+    public Properties getProperties() {
+        return properties;
+    }
+
+    /**
+     * Return the local member name
+     */
+    public String getLocalMemberName() {
+        return localMember.toString() ;
+    }
+ 
+    /**
+     * Return the local member
+     */
+    public Member getLocalMember(boolean alive) {
+        if ( alive && localMember != null && impl != null) localMember.setMemberAliveTime(System.currentTimeMillis()-impl.getServiceStartTime());
+        return localMember;
+    }
+    
+    /**
+     * Sets the local member properties for broadcasting
+     */
+    public void setLocalMemberProperties(String listenHost, int listenPort) {
+        properties.setProperty("tcpListenHost",listenHost);
+        properties.setProperty("tcpListenPort",String.valueOf(listenPort));
+        try {
+            if (localMember != null) {
+                localMember.setHostname(listenHost);
+                localMember.setPort(listenPort);
+            } else {
+                localMember = new MemberImpl(listenHost, listenPort, 0);
+                localMember.setUniqueId(UUIDGenerator.randomUUID(true));
+                localMember.setPayload(getPayload());
+                localMember.setDomain(getDomain());
+            }
+            localMember.getData(true, true);
+        }catch ( IOException x ) {
+            throw new IllegalArgumentException(x);
+        }
+    }
+    
+    public void setAddress(String addr) {
+        properties.setProperty("mcastAddress", addr);
+    }
+    
+    /**
+     * @deprecated use setAddress
+     * @param addr String
+     */
+    public void setMcastAddr(String addr) {
+        setAddress(addr);
+    }
+    
+    public String getAddress() {
+        return properties.getProperty("mcastAddress");
+    }
+    
+    /**
+     * @deprecated use getAddress
+     * @return String
+     */
+    public String getMcastAddr() {
+        return getAddress();
+    }
+
+    public void setMcastBindAddress(String bindaddr) {
+        setBind(bindaddr);
+    }
+    
+    public void setBind(String bindaddr) {
+        properties.setProperty("mcastBindAddress", bindaddr);
+    }
+    /**
+     * @deprecated use getBind
+     * @return String
+     */
+    public String getMcastBindAddress() {
+        return getBind();
+    }
+
+    public String getBind() {
+        return properties.getProperty("mcastBindAddress");
+    }
+
+    /**
+     * @deprecated use setPort
+     * @param port int
+     */
+    public void setMcastPort(int port) {
+        setPort(port);
+    }
+
+    public void setPort(int port) {
+        properties.setProperty("mcastPort", String.valueOf(port));
+    }
+
+    /**
+     * @deprecated use getPort()
+     * @return int
+     */
+    public int getMcastPort() {
+        return getPort();
+    }
+    public int getPort() {
+        String p = properties.getProperty("mcastPort");
+        return new Integer(p).intValue();
+    }
+    
+    /**
+     * @deprecated use setFrequency
+     * @param time long
+     */
+    public void setMcastFrequency(long time) {
+        setFrequency(time);
+    }
+    
+    public void setFrequency(long time) {
+        properties.setProperty("mcastFrequency", String.valueOf(time));
+    }
+
+    /**
+     * @deprecated use getFrequency
+     * @return long
+     */
+    public long getMcastFrequency() {
+        return getFrequency();
+    }
+
+    public long getFrequency() {
+        String p = properties.getProperty("mcastFrequency");
+        return new Long(p).longValue();
+    }
+
+    public void setMcastDropTime(long time) {
+        setDropTime(time);
+    }
+    public void setDropTime(long time) {
+        properties.setProperty("memberDropTime", String.valueOf(time));
+    }
+    
+    /**
+     * @deprecated use getDropTime
+     * @return long
+     */
+    public long getMcastDropTime() {
+        return getDropTime();
+    }
+
+    public long getDropTime() {
+        String p = properties.getProperty("memberDropTime");
+        return new Long(p).longValue();
+    }
+
+    /**
+     * Check if a required property is available.
+     * @param properties The set of properties
+     * @param name The property to check for
+     */
+    protected void hasProperty(Properties properties, String name){
+        if ( properties.getProperty(name)==null) throw new IllegalArgumentException("McastService:Required property \""+name+"\" is missing.");
+    }
+
+    /**
+     * Start broadcasting and listening to membership pings
+     * @throws java.lang.Exception if a IO error occurs
+     */
+    public void start() throws java.lang.Exception {
+        start(MembershipService.MBR_RX);
+        start(MembershipService.MBR_TX);
+    }
+    
+    public void start(int level) throws java.lang.Exception {
+        hasProperty(properties,"mcastPort");
+        hasProperty(properties,"mcastAddress");
+        hasProperty(properties,"memberDropTime");
+        hasProperty(properties,"mcastFrequency");
+        hasProperty(properties,"tcpListenPort");
+        hasProperty(properties,"tcpListenHost");
+
+        if ( impl != null ) {
+            impl.start(level);
+            return;
+        }
+        String host = getProperties().getProperty("tcpListenHost");
+        int port = Integer.parseInt(getProperties().getProperty("tcpListenPort"));
+        
+        if ( localMember == null ) {
+            localMember = new MemberImpl(host, port, 100);
+            localMember.setUniqueId(UUIDGenerator.randomUUID(true));
+        } else {
+            localMember.setHostname(host);
+            localMember.setPort(port);
+            localMember.setMemberAliveTime(100);
+        }
+        if ( this.payload != null ) localMember.setPayload(payload);
+        if ( this.domain != null ) localMember.setDomain(domain);
+        localMember.setServiceStartTime(System.currentTimeMillis());
+        java.net.InetAddress bind = null;
+        if ( properties.getProperty("mcastBindAddress")!= null ) {
+            bind = java.net.InetAddress.getByName(properties.getProperty("mcastBindAddress"));
+        }
+        int ttl = -1;
+        int soTimeout = -1;
+        if ( properties.getProperty("mcastTTL") != null ) {
+            try {
+                ttl = Integer.parseInt(properties.getProperty("mcastTTL"));
+            } catch ( Exception x ) {
+                log.error("Unable to parse mcastTTL="+properties.getProperty("mcastTTL"),x);
+            }
+        }
+        if ( properties.getProperty("mcastSoTimeout") != null ) {
+            try {
+                soTimeout = Integer.parseInt(properties.getProperty("mcastSoTimeout"));
+            } catch ( Exception x ) {
+                log.error("Unable to parse mcastSoTimeout="+properties.getProperty("mcastSoTimeout"),x);
+            }
+        }
+
+        impl = new McastServiceImpl((MemberImpl)localMember,Long.parseLong(properties.getProperty("mcastFrequency")),
+                                    Long.parseLong(properties.getProperty("memberDropTime")),
+                                    Integer.parseInt(properties.getProperty("mcastPort")),
+                                    bind,
+                                    java.net.InetAddress.getByName(properties.getProperty("mcastAddress")),
+                                    ttl,
+                                    soTimeout,
+                                    this);
+        
+        impl.start(level);
+		
+
+    }
+
+ 
+    /**
+     * Stop broadcasting and listening to membership pings
+     */
+    public void stop(int svc) {
+        try  {
+            if ( impl != null && impl.stop(svc) ) impl = null;
+        } catch ( Exception x)  {
+            log.error("Unable to stop the mcast service, level:"+svc+".",x);
+        }
+    }
+
+
+    /**
+     * Return all the members by name
+     */
+    public String[] getMembersByName() {
+        Member[] currentMembers = getMembers();
+        String [] membernames ;
+        if(currentMembers != null) {
+            membernames = new String[currentMembers.length];
+            for (int i = 0; i < currentMembers.length; i++) {
+                membernames[i] = currentMembers[i].toString() ;
+            }
+        } else
+            membernames = new String[0] ;
+        return membernames ;
+    }
+ 
+    /**
+     * Return the member by name
+     */
+    public Member findMemberByName(String name) {
+        Member[] currentMembers = getMembers();
+        for (int i = 0; i < currentMembers.length; i++) {
+            if (name.equals(currentMembers[i].toString()))
+                return currentMembers[i];
+        }
+        return null;
+    }
+
+    /**
+     * has members?
+     */
+    public boolean hasMembers() {
+       if ( impl == null || impl.membership == null ) return false;
+       return impl.membership.hasMembers();
+    }
+    
+    public Member getMember(Member mbr) {
+        if ( impl == null || impl.membership == null ) return null;
+        return impl.membership.getMember(mbr);
+    }
+
+    /**
+     * Return all the members
+     */
+    public Member[] getMembers() {
+        if ( impl == null || impl.membership == null ) return null;
+        return impl.membership.getMembers();
+    }
+    /**
+     * Add a membership listener, this version only supports one listener per service,
+     * so calling this method twice will result in only the second listener being active.
+     * @param listener The listener
+     */
+    public void setMembershipListener(MembershipListener listener) {
+        this.listener = listener;
+    }
+    /**
+     * Remove the membership listener
+     */
+    public void removeMembershipListener(){
+        listener = null;
+    }
+
+    public void memberAdded(Member member) {
+        if ( listener!=null ) listener.memberAdded(member);
+    }
+
+    /**
+     * Callback from the impl when a new member has been received
+     * @param member The member
+     */
+    public void memberDisappeared(Member member)
+    {
+        if ( listener!=null ) listener.memberDisappeared(member);
+    }
+
+    /**
+     * @deprecated use getSoTimeout
+     * @return int
+     */
+    public int getMcastSoTimeout() {
+        return getSoTimeout();
+    }
+    
+    public int getSoTimeout() {
+        return mcastSoTimeout;
+    }
+    
+    /**
+     * @deprecated use setSoTimeout
+     * @param mcastSoTimeout int
+     */
+    public void setMcastSoTimeout(int mcastSoTimeout) {
+        setSoTimeout(mcastSoTimeout);
+    }
+    
+    public void setSoTimeout(int mcastSoTimeout) {
+        this.mcastSoTimeout = mcastSoTimeout;
+        properties.setProperty("mcastSoTimeout", String.valueOf(mcastSoTimeout));
+    }
+    
+    /**
+     * @deprecated use getTtl
+     * @return int
+     */
+    public int getMcastTTL() {
+        return getTtl();
+    }
+    
+    public int getTtl() {
+        return mcastTTL;
+    }
+
+    public byte[] getPayload() {
+        return payload;
+    }
+    
+    public byte[] getDomain() {
+        return domain;
+    }
+    
+    /**
+     * @deprecated use setTtl
+     * @param mcastTTL int
+     */
+    public void setMcastTTL(int mcastTTL) {
+        setTtl(mcastTTL);
+    }
+
+    public void setTtl(int mcastTTL) {
+        this.mcastTTL = mcastTTL;
+        properties.setProperty("mcastTTL", String.valueOf(mcastTTL));
+    }
+
+    public void setPayload(byte[] payload) {
+        this.payload = payload;
+        if ( localMember != null ) {
+            localMember.setPayload(payload);
+            localMember.getData(true,true);
+            try {
+                if (impl != null) impl.send(false);
+            }catch ( Exception x ) {
+                log.error("Unable to send payload update.",x);
+            }
+        }
+    }
+    
+    public void setDomain(byte[] domain) {
+        this.domain = domain;
+        if ( localMember != null ) {
+            localMember.setDomain(domain);
+            localMember.getData(true,true);
+            try {
+                if (impl != null) impl.send(false);
+            }catch ( Exception x ) {
+                log.error("Unable to send domain update.",x);
+            }
+        }
+    }
+
+    /**
+     * Simple test program
+     * @param args Command-line arguments
+     * @throws Exception If an error occurs
+     */
+    public static void main(String args[]) throws Exception {
+		if(log.isInfoEnabled())
+            log.info("Usage McastService hostname tcpport");
+        McastService service = new McastService();
+        java.util.Properties p = new java.util.Properties();
+        p.setProperty("mcastPort","5555");
+        p.setProperty("mcastAddress","224.10.10.10");
+        p.setProperty("mcastClusterDomain","catalina");
+        p.setProperty("bindAddress","localhost");
+        p.setProperty("memberDropTime","3000");
+        p.setProperty("mcastFrequency","500");
+        p.setProperty("tcpListenPort","4000");
+        p.setProperty("tcpListenHost","127.0.0.1");
+        service.setProperties(p);
+        service.start();
+        Thread.sleep(60*1000*60);
+    }
+}

==================================================
MemberImpl.java
index c35234af31..580e117964 100644
--- a/java/org/apache/catalina/tribes/membership/McastServiceImpl.java
+++ b/java/org/apache/catalina/tribes/membership/McastServiceImpl.java
@@ -1,399 +1,399 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.membership;
-
-
-import java.io.IOException;
-import java.net.DatagramPacket;
-import java.net.InetAddress;
-import java.net.MulticastSocket;
-
-import org.apache.catalina.tribes.MembershipListener;
-import java.util.Arrays;
-import java.net.SocketTimeoutException;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.Channel;
-import java.net.InetSocketAddress;
-
-/**
- * A <b>membership</b> implementation using simple multicast.
- * This is the representation of a multicast membership service.
- * This class is responsible for maintaining a list of active cluster nodes in the cluster.
- * If a node fails to send out a heartbeat, the node will be dismissed.
- * This is the low level implementation that handles the multicasting sockets.
- * Need to fix this, could use java.nio and only need one thread to send and receive, or
- * just use a timeout on the receive
- * @author Filip Hanik
- * @version $Revision: 356540 $, $Date: 2005-12-13 10:53:40 -0600 (Tue, 13 Dec 2005) $
- */
-public class McastServiceImpl
-{
-    private static org.apache.juli.logging.Log log =
-        org.apache.juli.logging.LogFactory.getLog( McastService.class );
-    
-    protected static int MAX_PACKET_SIZE = 65535;
-    /**
-     * Internal flag used for the listen thread that listens to the multicasting socket.
-     */
-    protected boolean doRunSender = false;
-    protected boolean doRunReceiver = false;
-    protected int startLevel = 0;
-    /**
-     * Socket that we intend to listen to
-     */
-    protected MulticastSocket socket;
-    /**
-     * The local member that we intend to broad cast over and over again
-     */
-    protected MemberImpl member;
-    /**
-     * The multicast address
-     */
-    protected InetAddress address;
-    /**
-     * The multicast port
-     */
-    protected int port;
-    /**
-     * The time it takes for a member to expire.
-     */
-    protected long timeToExpiration;
-    /**
-     * How often to we send out a broadcast saying we are alive, must be smaller than timeToExpiration
-     */
-    protected long sendFrequency;
-    /**
-     * Reuse the sendPacket, no need to create a new one everytime
-     */
-    protected DatagramPacket sendPacket;
-    /**
-     * Reuse the receivePacket, no need to create a new one everytime
-     */
-    protected DatagramPacket receivePacket;
-    /**
-     * The membership, used so that we calculate memberships when they arrive or don't arrive
-     */
-    protected Membership membership;
-    /**
-     * The actual listener, for callback when shits goes down
-     */
-    protected MembershipListener service;
-    /**
-     * Thread to listen for pings
-     */
-    protected ReceiverThread receiver;
-    /**
-     * Thread to send pings
-     */
-    protected SenderThread sender;
-
-    /**
-     * When was the service started
-     */
-    protected long serviceStartTime = System.currentTimeMillis();
-    
-    /**
-     * Time to live for the multicast packets that are being sent out
-     */
-    protected int mcastTTL = -1;
-    /**
-     * Read timeout on the mcast socket
-     */
-    protected int mcastSoTimeout = -1;
-    /**
-     * bind address
-     */
-    protected InetAddress mcastBindAddress = null;
-    
-    /**
-     * Create a new mcast service impl
-     * @param member - the local member
-     * @param sendFrequency - the time (ms) in between pings sent out
-     * @param expireTime - the time (ms) for a member to expire
-     * @param port - the mcast port
-     * @param bind - the bind address (not sure this is used yet)
-     * @param mcastAddress - the mcast address
-     * @param service - the callback service
-     * @throws IOException
-     */
-    public McastServiceImpl(
-        MemberImpl member,
-        long sendFrequency,
-        long expireTime,
-        int port,
-        InetAddress bind,
-        InetAddress mcastAddress,
-        int ttl,
-        int soTimeout,
-        MembershipListener service)
-    throws IOException {
-        this.member = member;
-        this.address = mcastAddress;
-        this.port = port;
-        this.mcastSoTimeout = soTimeout;
-        this.mcastTTL = ttl;
-        this.mcastBindAddress = bind;
-        this.timeToExpiration = expireTime;
-        this.service = service;
-        this.sendFrequency = sendFrequency;
-        setupSocket();
-        sendPacket = new DatagramPacket(new byte[MAX_PACKET_SIZE],MAX_PACKET_SIZE);
-        sendPacket.setAddress(address);
-        sendPacket.setPort(port);
-        receivePacket = new DatagramPacket(new byte[MAX_PACKET_SIZE],MAX_PACKET_SIZE);
-        receivePacket.setAddress(address);
-        receivePacket.setPort(port);
-        membership = new Membership(member);
-    }
-    
-    protected void setupSocket() throws IOException {
-        if (mcastBindAddress != null) socket = new MulticastSocket(new InetSocketAddress(mcastBindAddress, port));
-        else socket = new MulticastSocket(port);
-        socket.setLoopbackMode(false); //hint that we don't need loop back messages
-        if (mcastBindAddress != null) {
-			if(log.isInfoEnabled())
-                log.info("Setting multihome multicast interface to:" +mcastBindAddress);
-            socket.setInterface(mcastBindAddress);
-        } //end if
-        //force a so timeout so that we don't block forever
-        if ( mcastSoTimeout <= 0 ) mcastSoTimeout = (int)sendFrequency;
-        if(log.isInfoEnabled())
-            log.info("Setting cluster mcast soTimeout to "+mcastSoTimeout);
-        socket.setSoTimeout(mcastSoTimeout);
-
-        if ( mcastTTL >= 0 ) {
-			if(log.isInfoEnabled())
-                log.info("Setting cluster mcast TTL to " + mcastTTL);
-            socket.setTimeToLive(mcastTTL);
-        }
-    }
-    
-    
-
-    /**
-     * Start the service
-     * @param level 1 starts the receiver, level 2 starts the sender
-     * @throws IOException if the service fails to start
-     * @throws IllegalStateException if the service is already started
-     */
-    public synchronized void start(int level) throws IOException {
-        boolean valid = false;
-        if ( (level & Channel.MBR_RX_SEQ)==Channel.MBR_RX_SEQ ) {
-            if ( receiver != null ) throw new IllegalStateException("McastService.receive already running.");
-            if ( sender == null ) socket.joinGroup(address);
-            doRunReceiver = true;
-            receiver = new ReceiverThread();
-            receiver.setDaemon(true);
-            receiver.start();
-            valid = true;
-        } 
-        if ( (level & Channel.MBR_TX_SEQ)==Channel.MBR_TX_SEQ ) {
-            if ( sender != null ) throw new IllegalStateException("McastService.send already running.");
-            if ( receiver == null ) socket.joinGroup(address);
-            //make sure at least one packet gets out there
-            send(false);
-            doRunSender = true;
-            serviceStartTime = System.currentTimeMillis();
-            sender = new SenderThread(sendFrequency);
-            sender.setDaemon(true);
-            sender.start();
-            //we have started the receiver, but not yet waited for membership to establish
-            valid = true;
-        } 
-        if (!valid) {
-            throw new IllegalArgumentException("Invalid start level. Only acceptable levels are Channel.MBR_RX_SEQ and Channel.MBR_TX_SEQ");
-        }
-        //pause, once or twice
-        waitForMembers(level);
-        startLevel = (startLevel | level);
-    }
-
-    private void waitForMembers(int level) {
-        long memberwait = sendFrequency*2;
-        if(log.isInfoEnabled())
-            log.info("Sleeping for "+memberwait+" milliseconds to establish cluster membership, start level:"+level);
-        try {Thread.sleep(memberwait);}catch (InterruptedException ignore){}
-        if(log.isInfoEnabled())
-            log.info("Done sleeping, membership established, start level:"+level);
-    }
-
-    /**
-     * Stops the service
-     * @throws IOException if the service fails to disconnect from the sockets
-     */
-    public synchronized boolean stop(int level) throws IOException {
-        boolean valid = false;
-        
-        if ( (level & Channel.MBR_RX_SEQ)==Channel.MBR_RX_SEQ ) {
-            valid = true;
-            doRunReceiver = false;
-            if ( receiver !=null ) receiver.interrupt();
-            receiver = null;
-        } 
-        if ( (level & Channel.MBR_TX_SEQ)==Channel.MBR_TX_SEQ ) {
-            valid = true;
-            doRunSender = false;
-            if ( sender != null )sender.interrupt();
-            sender = null;
-        } 
-        
-        if (!valid) {
-            throw new IllegalArgumentException("Invalid stop level. Only acceptable levels are Channel.MBR_RX_SEQ and Channel.MBR_TX_SEQ");
-        }
-        startLevel = (startLevel & (~level));
-        //we're shutting down, send a shutdown message and close the socket
-        if ( startLevel == 0 ) {
-            //send a stop message
-            member.setCommand(Member.SHUTDOWN_PAYLOAD);
-            member.getData(true, true);
-            send(false);
-            //leave mcast group
-            try {socket.leaveGroup(address);}catch ( Exception ignore){}
-            serviceStartTime = Long.MAX_VALUE;
-        }
-        return (startLevel == 0);
-    }
-
-    /**
-     * Receive a datagram packet, locking wait
-     * @throws IOException
-     */
-    public void receive() throws IOException {
-        try {
-            socket.receive(receivePacket);
-            if(receivePacket.getLength() > MAX_PACKET_SIZE) {
-                log.error("Multicast packet received was too long, dropping package:"+receivePacket.getLength());
-            } else {
-                byte[] data = new byte[receivePacket.getLength()];
-                System.arraycopy(receivePacket.getData(), receivePacket.getOffset(), data, 0, data.length);
-                final MemberImpl m = MemberImpl.getMember(data);
-                if (log.isTraceEnabled()) log.trace("Mcast receive ping from member " + m);
-                Thread t = null;
-                if (Arrays.equals(m.getCommand(), Member.SHUTDOWN_PAYLOAD)) {
-                    if (log.isDebugEnabled()) log.debug("Member has shutdown:" + m);
-                    membership.removeMember(m);
-                    t = new Thread() {
-                        public void run() {
-                            service.memberDisappeared(m);
-                        }
-                    };
-                } else if (membership.memberAlive(m)) {
-                    if (log.isDebugEnabled()) log.debug("Mcast add member " + m);
-                    t = new Thread() {
-                        public void run() {
-                            service.memberAdded(m);
-                        }
-                    };
-                } //end if
-                if ( t != null ) t.start();
-            }
-        } catch (SocketTimeoutException x ) { 
-            //do nothing, this is normal, we don't want to block forever
-            //since the receive thread is the same thread
-            //that does membership expiration
-        }
-        checkExpired();
-    }
-    
-    protected Object expiredMutex = new Object();
-    protected void checkExpired() {
-        synchronized (expiredMutex) {
-            MemberImpl[] expired = membership.expire(timeToExpiration);
-            for (int i = 0; i < expired.length; i++) {
-                final MemberImpl member = expired[i];
-                if (log.isDebugEnabled())
-                    log.debug("Mcast exipre  member " + expired[i]);
-                try {
-                    Thread t = new Thread() {
-                        public void run() {
-                            service.memberDisappeared(member);
-                        }
-                    };
-                    t.start();
-                } catch (Exception x) {
-                    log.error("Unable to process member disappeared message.", x);
-                }
-            }
-        }
-    }
-
-    /**
-     * Send a ping
-     * @throws Exception
-     */ 
-    public void send(boolean checkexpired) throws IOException{
-        //ignore if we haven't started the sender
-        //if ( (startLevel&Channel.MBR_TX_SEQ) != Channel.MBR_TX_SEQ ) return;
-        member.inc();
-        if(log.isTraceEnabled())
-            log.trace("Mcast send ping from member " + member);
-        byte[] data = member.getData();
-        DatagramPacket p = new DatagramPacket(data,data.length);
-        p.setAddress(address);
-        p.setPort(port);
-        socket.send(p);
-        if ( checkexpired ) checkExpired();
-    }
-
-    public long getServiceStartTime() {
-       return this.serviceStartTime;
-    }
-
-
-    public class ReceiverThread extends Thread {
-        public ReceiverThread() {
-            super();
-            setName("Cluster-MembershipReceiver");
-        }
-        public void run() {
-            while ( doRunReceiver ) {
-                try {
-                    receive();
-                } catch ( ArrayIndexOutOfBoundsException ax ) {
-                    //we can ignore this, as it means we have an invalid package
-                    //but we will log it to debug
-                    if ( log.isDebugEnabled() )
-                        log.debug("Invalid member mcast package.",ax);
-                } catch ( Exception x ) {
-                    log.warn("Error receiving mcast package. Sleeping 500ms",x);
-                    try { Thread.sleep(500); } catch ( Exception ignore ){}
-                    
-                }
-            }
-        }
-    }//class ReceiverThread
-
-    public class SenderThread extends Thread {
-        long time;
-        public SenderThread(long time) {
-            this.time = time;
-            setName("Cluster-MembershipSender");
-
-        }
-        public void run() {
-            while ( doRunSender ) {
-                try {
-                    send(true);
-                } catch ( Exception x ) {
-                    log.warn("Unable to send mcast message.",x);
-                }
-                try { Thread.sleep(time); } catch ( Exception ignore ) {}
-            }
-        }
-    }//class SenderThread
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.membership;
+
+
+import java.io.IOException;
+import java.net.DatagramPacket;
+import java.net.InetAddress;
+import java.net.MulticastSocket;
+
+import org.apache.catalina.tribes.MembershipListener;
+import java.util.Arrays;
+import java.net.SocketTimeoutException;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.Channel;
+import java.net.InetSocketAddress;
+
+/**
+ * A <b>membership</b> implementation using simple multicast.
+ * This is the representation of a multicast membership service.
+ * This class is responsible for maintaining a list of active cluster nodes in the cluster.
+ * If a node fails to send out a heartbeat, the node will be dismissed.
+ * This is the low level implementation that handles the multicasting sockets.
+ * Need to fix this, could use java.nio and only need one thread to send and receive, or
+ * just use a timeout on the receive
+ * @author Filip Hanik
+ * @version $Revision$, $Date$
+ */
+public class McastServiceImpl
+{
+    private static org.apache.juli.logging.Log log =
+        org.apache.juli.logging.LogFactory.getLog( McastService.class );
+    
+    protected static int MAX_PACKET_SIZE = 65535;
+    /**
+     * Internal flag used for the listen thread that listens to the multicasting socket.
+     */
+    protected boolean doRunSender = false;
+    protected boolean doRunReceiver = false;
+    protected int startLevel = 0;
+    /**
+     * Socket that we intend to listen to
+     */
+    protected MulticastSocket socket;
+    /**
+     * The local member that we intend to broad cast over and over again
+     */
+    protected MemberImpl member;
+    /**
+     * The multicast address
+     */
+    protected InetAddress address;
+    /**
+     * The multicast port
+     */
+    protected int port;
+    /**
+     * The time it takes for a member to expire.
+     */
+    protected long timeToExpiration;
+    /**
+     * How often to we send out a broadcast saying we are alive, must be smaller than timeToExpiration
+     */
+    protected long sendFrequency;
+    /**
+     * Reuse the sendPacket, no need to create a new one everytime
+     */
+    protected DatagramPacket sendPacket;
+    /**
+     * Reuse the receivePacket, no need to create a new one everytime
+     */
+    protected DatagramPacket receivePacket;
+    /**
+     * The membership, used so that we calculate memberships when they arrive or don't arrive
+     */
+    protected Membership membership;
+    /**
+     * The actual listener, for callback when shits goes down
+     */
+    protected MembershipListener service;
+    /**
+     * Thread to listen for pings
+     */
+    protected ReceiverThread receiver;
+    /**
+     * Thread to send pings
+     */
+    protected SenderThread sender;
+
+    /**
+     * When was the service started
+     */
+    protected long serviceStartTime = System.currentTimeMillis();
+    
+    /**
+     * Time to live for the multicast packets that are being sent out
+     */
+    protected int mcastTTL = -1;
+    /**
+     * Read timeout on the mcast socket
+     */
+    protected int mcastSoTimeout = -1;
+    /**
+     * bind address
+     */
+    protected InetAddress mcastBindAddress = null;
+    
+    /**
+     * Create a new mcast service impl
+     * @param member - the local member
+     * @param sendFrequency - the time (ms) in between pings sent out
+     * @param expireTime - the time (ms) for a member to expire
+     * @param port - the mcast port
+     * @param bind - the bind address (not sure this is used yet)
+     * @param mcastAddress - the mcast address
+     * @param service - the callback service
+     * @throws IOException
+     */
+    public McastServiceImpl(
+        MemberImpl member,
+        long sendFrequency,
+        long expireTime,
+        int port,
+        InetAddress bind,
+        InetAddress mcastAddress,
+        int ttl,
+        int soTimeout,
+        MembershipListener service)
+    throws IOException {
+        this.member = member;
+        this.address = mcastAddress;
+        this.port = port;
+        this.mcastSoTimeout = soTimeout;
+        this.mcastTTL = ttl;
+        this.mcastBindAddress = bind;
+        this.timeToExpiration = expireTime;
+        this.service = service;
+        this.sendFrequency = sendFrequency;
+        setupSocket();
+        sendPacket = new DatagramPacket(new byte[MAX_PACKET_SIZE],MAX_PACKET_SIZE);
+        sendPacket.setAddress(address);
+        sendPacket.setPort(port);
+        receivePacket = new DatagramPacket(new byte[MAX_PACKET_SIZE],MAX_PACKET_SIZE);
+        receivePacket.setAddress(address);
+        receivePacket.setPort(port);
+        membership = new Membership(member);
+    }
+    
+    protected void setupSocket() throws IOException {
+        if (mcastBindAddress != null) socket = new MulticastSocket(new InetSocketAddress(mcastBindAddress, port));
+        else socket = new MulticastSocket(port);
+        socket.setLoopbackMode(false); //hint that we don't need loop back messages
+        if (mcastBindAddress != null) {
+			if(log.isInfoEnabled())
+                log.info("Setting multihome multicast interface to:" +mcastBindAddress);
+            socket.setInterface(mcastBindAddress);
+        } //end if
+        //force a so timeout so that we don't block forever
+        if ( mcastSoTimeout <= 0 ) mcastSoTimeout = (int)sendFrequency;
+        if(log.isInfoEnabled())
+            log.info("Setting cluster mcast soTimeout to "+mcastSoTimeout);
+        socket.setSoTimeout(mcastSoTimeout);
+
+        if ( mcastTTL >= 0 ) {
+			if(log.isInfoEnabled())
+                log.info("Setting cluster mcast TTL to " + mcastTTL);
+            socket.setTimeToLive(mcastTTL);
+        }
+    }
+    
+    
+
+    /**
+     * Start the service
+     * @param level 1 starts the receiver, level 2 starts the sender
+     * @throws IOException if the service fails to start
+     * @throws IllegalStateException if the service is already started
+     */
+    public synchronized void start(int level) throws IOException {
+        boolean valid = false;
+        if ( (level & Channel.MBR_RX_SEQ)==Channel.MBR_RX_SEQ ) {
+            if ( receiver != null ) throw new IllegalStateException("McastService.receive already running.");
+            if ( sender == null ) socket.joinGroup(address);
+            doRunReceiver = true;
+            receiver = new ReceiverThread();
+            receiver.setDaemon(true);
+            receiver.start();
+            valid = true;
+        } 
+        if ( (level & Channel.MBR_TX_SEQ)==Channel.MBR_TX_SEQ ) {
+            if ( sender != null ) throw new IllegalStateException("McastService.send already running.");
+            if ( receiver == null ) socket.joinGroup(address);
+            //make sure at least one packet gets out there
+            send(false);
+            doRunSender = true;
+            serviceStartTime = System.currentTimeMillis();
+            sender = new SenderThread(sendFrequency);
+            sender.setDaemon(true);
+            sender.start();
+            //we have started the receiver, but not yet waited for membership to establish
+            valid = true;
+        } 
+        if (!valid) {
+            throw new IllegalArgumentException("Invalid start level. Only acceptable levels are Channel.MBR_RX_SEQ and Channel.MBR_TX_SEQ");
+        }
+        //pause, once or twice
+        waitForMembers(level);
+        startLevel = (startLevel | level);
+    }
+
+    private void waitForMembers(int level) {
+        long memberwait = sendFrequency*2;
+        if(log.isInfoEnabled())
+            log.info("Sleeping for "+memberwait+" milliseconds to establish cluster membership, start level:"+level);
+        try {Thread.sleep(memberwait);}catch (InterruptedException ignore){}
+        if(log.isInfoEnabled())
+            log.info("Done sleeping, membership established, start level:"+level);
+    }
+
+    /**
+     * Stops the service
+     * @throws IOException if the service fails to disconnect from the sockets
+     */
+    public synchronized boolean stop(int level) throws IOException {
+        boolean valid = false;
+        
+        if ( (level & Channel.MBR_RX_SEQ)==Channel.MBR_RX_SEQ ) {
+            valid = true;
+            doRunReceiver = false;
+            if ( receiver !=null ) receiver.interrupt();
+            receiver = null;
+        } 
+        if ( (level & Channel.MBR_TX_SEQ)==Channel.MBR_TX_SEQ ) {
+            valid = true;
+            doRunSender = false;
+            if ( sender != null )sender.interrupt();
+            sender = null;
+        } 
+        
+        if (!valid) {
+            throw new IllegalArgumentException("Invalid stop level. Only acceptable levels are Channel.MBR_RX_SEQ and Channel.MBR_TX_SEQ");
+        }
+        startLevel = (startLevel & (~level));
+        //we're shutting down, send a shutdown message and close the socket
+        if ( startLevel == 0 ) {
+            //send a stop message
+            member.setCommand(Member.SHUTDOWN_PAYLOAD);
+            member.getData(true, true);
+            send(false);
+            //leave mcast group
+            try {socket.leaveGroup(address);}catch ( Exception ignore){}
+            serviceStartTime = Long.MAX_VALUE;
+        }
+        return (startLevel == 0);
+    }
+
+    /**
+     * Receive a datagram packet, locking wait
+     * @throws IOException
+     */
+    public void receive() throws IOException {
+        try {
+            socket.receive(receivePacket);
+            if(receivePacket.getLength() > MAX_PACKET_SIZE) {
+                log.error("Multicast packet received was too long, dropping package:"+receivePacket.getLength());
+            } else {
+                byte[] data = new byte[receivePacket.getLength()];
+                System.arraycopy(receivePacket.getData(), receivePacket.getOffset(), data, 0, data.length);
+                final MemberImpl m = MemberImpl.getMember(data);
+                if (log.isTraceEnabled()) log.trace("Mcast receive ping from member " + m);
+                Thread t = null;
+                if (Arrays.equals(m.getCommand(), Member.SHUTDOWN_PAYLOAD)) {
+                    if (log.isDebugEnabled()) log.debug("Member has shutdown:" + m);
+                    membership.removeMember(m);
+                    t = new Thread() {
+                        public void run() {
+                            service.memberDisappeared(m);
+                        }
+                    };
+                } else if (membership.memberAlive(m)) {
+                    if (log.isDebugEnabled()) log.debug("Mcast add member " + m);
+                    t = new Thread() {
+                        public void run() {
+                            service.memberAdded(m);
+                        }
+                    };
+                } //end if
+                if ( t != null ) t.start();
+            }
+        } catch (SocketTimeoutException x ) { 
+            //do nothing, this is normal, we don't want to block forever
+            //since the receive thread is the same thread
+            //that does membership expiration
+        }
+        checkExpired();
+    }
+    
+    protected Object expiredMutex = new Object();
+    protected void checkExpired() {
+        synchronized (expiredMutex) {
+            MemberImpl[] expired = membership.expire(timeToExpiration);
+            for (int i = 0; i < expired.length; i++) {
+                final MemberImpl member = expired[i];
+                if (log.isDebugEnabled())
+                    log.debug("Mcast exipre  member " + expired[i]);
+                try {
+                    Thread t = new Thread() {
+                        public void run() {
+                            service.memberDisappeared(member);
+                        }
+                    };
+                    t.start();
+                } catch (Exception x) {
+                    log.error("Unable to process member disappeared message.", x);
+                }
+            }
+        }
+    }
+
+    /**
+     * Send a ping
+     * @throws Exception
+     */ 
+    public void send(boolean checkexpired) throws IOException{
+        //ignore if we haven't started the sender
+        //if ( (startLevel&Channel.MBR_TX_SEQ) != Channel.MBR_TX_SEQ ) return;
+        member.inc();
+        if(log.isTraceEnabled())
+            log.trace("Mcast send ping from member " + member);
+        byte[] data = member.getData();
+        DatagramPacket p = new DatagramPacket(data,data.length);
+        p.setAddress(address);
+        p.setPort(port);
+        socket.send(p);
+        if ( checkexpired ) checkExpired();
+    }
+
+    public long getServiceStartTime() {
+       return this.serviceStartTime;
+    }
+
+
+    public class ReceiverThread extends Thread {
+        public ReceiverThread() {
+            super();
+            setName("Cluster-MembershipReceiver");
+        }
+        public void run() {
+            while ( doRunReceiver ) {
+                try {
+                    receive();
+                } catch ( ArrayIndexOutOfBoundsException ax ) {
+                    //we can ignore this, as it means we have an invalid package
+                    //but we will log it to debug
+                    if ( log.isDebugEnabled() )
+                        log.debug("Invalid member mcast package.",ax);
+                } catch ( Exception x ) {
+                    log.warn("Error receiving mcast package. Sleeping 500ms",x);
+                    try { Thread.sleep(500); } catch ( Exception ignore ){}
+                    
+                }
+            }
+        }
+    }//class ReceiverThread
+
+    public class SenderThread extends Thread {
+        long time;
+        public SenderThread(long time) {
+            this.time = time;
+            setName("Cluster-MembershipSender");
+
+        }
+        public void run() {
+            while ( doRunSender ) {
+                try {
+                    send(true);
+                } catch ( Exception x ) {
+                    log.warn("Unable to send mcast message.",x);
+                }
+                try { Thread.sleep(time); } catch ( Exception ignore ) {}
+            }
+        }
+    }//class SenderThread
+}

==================================================
Membership.java
index 7728fcd80f..fc40dad5ac 100644
--- a/java/org/apache/catalina/tribes/membership/MemberImpl.java
+++ b/java/org/apache/catalina/tribes/membership/MemberImpl.java
@@ -1,597 +1,597 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.membership;
-
-import java.io.IOException;
-import java.io.ObjectInput;
-import java.io.ObjectOutput;
-import java.util.Arrays;
-
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.io.XByteBuffer;
-import org.apache.catalina.tribes.transport.SenderState;
-
-/**
- * A <b>membership</b> implementation using simple multicast.
- * This is the representation of a multicast member.
- * Carries the host, and port of the this or other cluster nodes.
- *
- * @author Filip Hanik
- * @version $Revision: 304032 $, $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
- */
-public class MemberImpl implements Member, java.io.Externalizable {
-
-    /**
-     * Public properties specific to this implementation
-     */
-    public static final transient String TCP_LISTEN_PORT = "tcpListenPort";
-    public static final transient String TCP_LISTEN_HOST = "tcpListenHost";
-    public static final transient String MEMBER_NAME = "memberName";
-    
-    public static final transient byte[] TRIBES_MBR_BEGIN = new byte[] {84, 82, 73, 66, 69, 83, 45, 66};
-    public static final transient byte[] TRIBES_MBR_END   = new byte[] {84, 82, 73, 66, 69, 83, 45, 69};
-    
-    /**
-     * The listen host for this member
-     */
-    protected byte[] host;
-    protected transient String hostname;
-    /**
-     * The tcp listen port for this member
-     */
-    protected int port;
-    
-    /**
-     * The tcp/SSL listen port for this member
-     */
-    protected int securePort = -1;
-
-    /**
-     * Counter for how many broadcast messages have been sent from this member
-     */
-    protected int msgCount = 0;
-    /**
-     * The number of milliseconds since this members was
-     * created, is kept track of using the start time
-     */
-    protected long memberAliveTime = 0;
-    
-    /**
-     * For the local member only
-     */
-    protected transient long serviceStartTime;
-    
-    /**
-     * To avoid serialization over and over again, once the local dataPkg
-     * has been set, we use that to transmit data
-     */
-    protected transient byte[] dataPkg = null;
-
-    /**
-     * Unique session Id for this member
-     */
-    protected byte[] uniqueId = new byte[16];
-    
-    /**
-     * Custom payload that an app framework can broadcast
-     * Also used to transport stop command.
-     */
-    protected byte[] payload = new byte[0];
-    
-    /**
-     * Command, so that the custom payload doesn't have to be used
-     * This is for internal tribes use, such as SHUTDOWN_COMMAND
-     */
-    protected byte[] command = new byte[0];
-
-    /**
-     * Domain if we want to filter based on domain.
-     */
-    protected byte[] domain = new byte[0];
-    
-    /**
-     * Empty constructor for serialization
-     */
-    public MemberImpl() {
-        
-    }
-
-    /**
-     * Construct a new member object
-     * @param name - the name of this member, cluster unique
-     * @param domain - the cluster domain name of this member
-     * @param host - the tcp listen host
-     * @param port - the tcp listen port
-     */
-    public MemberImpl(String host,
-                      int port,
-                      long aliveTime) throws IOException {
-        setHostname(host);
-        this.port = port;
-        this.memberAliveTime=aliveTime;
-    }
-    
-    public MemberImpl(String host,
-                      int port,
-                      long aliveTime,
-                      byte[] payload) throws IOException {
-        this(host,port,aliveTime);
-        setPayload(payload);
-    }
-    
-    public boolean isReady() {
-        return SenderState.getSenderState(this).isReady();
-    }
-    public boolean isSuspect() {
-        return SenderState.getSenderState(this).isSuspect();
-    }
-    public boolean isFailing() {
-        return SenderState.getSenderState(this).isFailing();
-    }
-
-    /**
-     * Increment the message count.
-     */
-    protected void inc() {
-        msgCount++;
-    }
-
-    /**
-     * Create a data package to send over the wire representing this member.
-     * This is faster than serialization.
-     * @return - the bytes for this member deserialized
-     * @throws Exception
-     */
-    public byte[] getData()  {
-        return getData(true);
-    }
-    /**
-     * Highly optimized version of serializing a member into a byte array
-     * Returns a cached byte[] reference, do not modify this data
-     * @param getalive boolean
-     * @return byte[]
-     */
-    public byte[] getData(boolean getalive)  {
-        return getData(getalive,false);
-    }
-    
-    
-    public int getDataLength() {
-        return TRIBES_MBR_BEGIN.length+ //start pkg
-               4+ //data length
-               8+ //alive time
-               4+ //port
-               4+ //secure port
-               1+ //host length
-               host.length+ //host
-               4+ //command length
-               command.length+ //command
-               4+ //domain length
-               domain.length+ //domain
-               16+ //unique id
-               4+ //payload length
-               payload.length+ //payload
-               TRIBES_MBR_END.length; //end pkg
-    }
-    
-    /**
-     * 
-     * @param getalive boolean - calculate memberAlive time
-     * @param reset boolean - reset the cached data package, and create a new one
-     * @return byte[]
-     */
-    public byte[] getData(boolean getalive, boolean reset)  {
-        if ( reset ) dataPkg = null;
-        //look in cache first
-        if ( dataPkg!=null ) {
-            if ( getalive ) {
-                //you'd be surprised, but System.currentTimeMillis
-                //shows up on the profiler
-                long alive=System.currentTimeMillis()-getServiceStartTime();
-                XByteBuffer.toBytes( (long) alive, dataPkg, TRIBES_MBR_BEGIN.length+4);
-            }
-            return dataPkg;
-        }
-        
-        //package looks like
-        //start package TRIBES_MBR_BEGIN.length
-        //package length - 4 bytes
-        //alive - 8 bytes
-        //port - 4 bytes
-        //secure port - 4 bytes
-        //host length - 1 byte
-        //host - hl bytes
-        //clen - 4 bytes
-        //command - clen bytes
-        //dlen - 4 bytes
-        //domain - dlen bytes
-        //uniqueId - 16 bytes
-        //payload length - 4 bytes
-        //payload plen bytes
-        //end package TRIBES_MBR_END.length
-        byte[] addr = host;
-        long alive=System.currentTimeMillis()-getServiceStartTime();
-        byte hl = (byte)addr.length;
-        byte[] data = new byte[getDataLength()];
-        
-        int bodylength = (getDataLength() - TRIBES_MBR_BEGIN.length - TRIBES_MBR_END.length - 4);
-        
-        int pos = 0;
-        
-        //TRIBES_MBR_BEGIN
-        System.arraycopy(TRIBES_MBR_BEGIN,0,data,pos,TRIBES_MBR_BEGIN.length);
-        pos += TRIBES_MBR_BEGIN.length;
-        
-        //body length
-        XByteBuffer.toBytes(bodylength,data,pos);
-        pos += 4;
-        
-        //alive data
-        XByteBuffer.toBytes((long)alive,data,pos);
-        pos += 8;
-        //port
-        XByteBuffer.toBytes(port,data,pos);
-        pos += 4;
-        //secure port
-        XByteBuffer.toBytes(securePort,data,pos);
-        pos += 4;
-        //host length
-        data[pos++] = hl;
-        //host
-        System.arraycopy(addr,0,data,pos,addr.length);
-        pos+=addr.length;
-        //clen - 4 bytes
-        XByteBuffer.toBytes(command.length,data,pos);
-        pos+=4;
-        //command - clen bytes
-        System.arraycopy(command,0,data,pos,command.length);
-        pos+=command.length;
-        //dlen - 4 bytes
-        XByteBuffer.toBytes(domain.length,data,pos);
-        pos+=4;
-        //domain - dlen bytes
-        System.arraycopy(domain,0,data,pos,domain.length);
-        pos+=domain.length;
-        //unique Id
-        System.arraycopy(uniqueId,0,data,pos,uniqueId.length);
-        pos+=uniqueId.length;
-        //payload
-        XByteBuffer.toBytes(payload.length,data,pos);
-        pos+=4;
-        System.arraycopy(payload,0,data,pos,payload.length);
-        pos+=payload.length;
-        
-        //TRIBES_MBR_END
-        System.arraycopy(TRIBES_MBR_END,0,data,pos,TRIBES_MBR_END.length);
-        pos += TRIBES_MBR_END.length;
-
-        //create local data
-        dataPkg = data;
-        return data;
-    }
-    /**
-     * Deserializes a member from data sent over the wire
-     * @param data - the bytes received
-     * @return a member object.
-     */
-    public static MemberImpl getMember(byte[] data, MemberImpl member) {
-        return getMember(data,0,data.length,member);
-    }
-
-    public static MemberImpl getMember(byte[] data, int offset, int length, MemberImpl member) {
-        //package looks like
-        //start package TRIBES_MBR_BEGIN.length
-        //package length - 4 bytes
-        //alive - 8 bytes
-        //port - 4 bytes
-        //secure port - 4 bytes
-        //host length - 1 byte
-        //host - hl bytes
-        //clen - 4 bytes
-        //command - clen bytes
-        //dlen - 4 bytes
-        //domain - dlen bytes
-        //uniqueId - 16 bytes
-        //payload length - 4 bytes
-        //payload plen bytes
-        //end package TRIBES_MBR_END.length
-
-        int pos = offset;
-        
-        if (XByteBuffer.firstIndexOf(data,offset,TRIBES_MBR_BEGIN)!=pos) {
-            throw new IllegalArgumentException("Invalid package, should start with:"+org.apache.catalina.tribes.util.Arrays.toString(TRIBES_MBR_BEGIN));
-        }
-
-        if ( length < (TRIBES_MBR_BEGIN.length+4) ) {
-            throw new ArrayIndexOutOfBoundsException("Member package to small to validate.");
-        }
-        
-        pos += TRIBES_MBR_BEGIN.length;
-        
-        int bodylength = XByteBuffer.toInt(data,pos);
-        pos += 4;
-        
-        if ( length < (bodylength+4+TRIBES_MBR_BEGIN.length+TRIBES_MBR_END.length) ) {
-            throw new ArrayIndexOutOfBoundsException("Not enough bytes in member package.");
-        }
-        
-        int endpos = pos+bodylength;
-        if (XByteBuffer.firstIndexOf(data,endpos,TRIBES_MBR_END)!=endpos) {
-            throw new IllegalArgumentException("Invalid package, should end with:"+org.apache.catalina.tribes.util.Arrays.toString(TRIBES_MBR_END));
-        }
-
-
-        byte[] alived = new byte[8];
-        System.arraycopy(data, pos, alived, 0, 8);
-        pos += 8;
-        byte[] portd = new byte[4];
-        System.arraycopy(data, pos, portd, 0, 4);
-        pos += 4;
-        
-        byte[] sportd = new byte[4];
-        System.arraycopy(data, pos, sportd, 0, 4);
-        pos += 4;
-
-
-    
-        byte hl = data[pos++];
-        byte[] addr = new byte[hl];
-        System.arraycopy(data, pos, addr, 0, hl);
-        pos += hl;
-    
-        int cl = XByteBuffer.toInt(data, pos);
-        pos += 4;
-    
-        byte[] command = new byte[cl];
-        System.arraycopy(data, pos, command, 0, command.length);
-        pos += command.length;
-    
-        int dl = XByteBuffer.toInt(data, pos);
-        pos += 4;
-    
-        byte[] domain = new byte[dl];
-        System.arraycopy(data, pos, domain, 0, domain.length);
-        pos += domain.length;
-    
-        byte[] uniqueId = new byte[16];
-        System.arraycopy(data, pos, uniqueId, 0, 16);
-        pos += 16;
-    
-        int pl = XByteBuffer.toInt(data, pos);
-        pos += 4;
-    
-        byte[] payload = new byte[pl];
-        System.arraycopy(data, pos, payload, 0, payload.length);
-        pos += payload.length;
-    
-        member.setHost(addr);
-        member.setPort(XByteBuffer.toInt(portd, 0));
-        member.setSecurePort(XByteBuffer.toInt(sportd, 0));
-        member.setMemberAliveTime(XByteBuffer.toLong(alived, 0));
-        member.setUniqueId(uniqueId);
-        member.payload = payload;
-        member.domain = domain;
-        member.command = command;
-    
-        member.dataPkg = new byte[length];
-        System.arraycopy(data, offset, member.dataPkg, 0, length);
-    
-        return member;
-    }
-
-    public static MemberImpl getMember(byte[] data) {
-       return getMember(data,new MemberImpl());
-    }
-
-    /**
-     * Return the name of this object
-     * @return a unique name to the cluster
-     */
-    public String getName() {
-        return "tcp://"+getHostname()+":"+getPort();
-    }
-    
-    /**
-     * Return the listen port of this member
-     * @return - tcp listen port
-     */
-    public int getPort()  {
-        return this.port;
-    }
-
-    /**
-     * Return the TCP listen host for this member
-     * @return IP address or host name
-     */
-    public byte[] getHost()  {
-        return host;
-    }
-    
-    public String getHostname() {
-        if ( this.hostname != null ) return hostname;
-        else {
-            try {
-                this.hostname = java.net.InetAddress.getByAddress(host).getHostName();
-                return this.hostname;
-            }catch ( IOException x ) {
-                throw new RuntimeException("Unable to parse hostname.",x);
-            }
-        }
-    }
-
-    /**
-     * Contains information on how long this member has been online.
-     * The result is the number of milli seconds this member has been
-     * broadcasting its membership to the cluster.
-     * @return nr of milliseconds since this member started.
-     */
-    public long getMemberAliveTime() {
-       return memberAliveTime;
-    }
-
-    public long getServiceStartTime() {
-        return serviceStartTime;
-    }
-
-    public byte[] getUniqueId() {
-        return uniqueId;
-    }
-
-    public byte[] getPayload() {
-        return payload;
-    }
-
-    public byte[] getCommand() {
-        return command;
-    }
-
-    public byte[] getDomain() {
-        return domain;
-    }
-
-    public int getSecurePort() {
-        return securePort;
-    }
-
-    public void setMemberAliveTime(long time) {
-       memberAliveTime=time;
-    }
-
-
-
-    /**
-     * String representation of this object
-     */
-    public String toString()  {
-        StringBuffer buf = new StringBuffer("org.apache.catalina.tribes.membership.MemberImpl[");
-        buf.append(getName()).append(",");
-        buf.append(getHostname()).append(",");
-        buf.append(port).append(", alive=");
-        buf.append(memberAliveTime).append(",");
-        buf.append("id=").append(bToS(this.uniqueId)).append(", ");
-        buf.append("payload=").append(bToS(this.payload,8)).append(", ");
-        buf.append("command=").append(bToS(this.command,8)).append(", ");
-        buf.append("domain=").append(bToS(this.domain,8)).append(", ");
-        buf.append("]");
-        return buf.toString();
-    }
-    public static String bToS(byte[] data) {
-        return bToS(data,data.length);
-    }
-    public static String bToS(byte[] data, int max) {
-        StringBuffer buf = new StringBuffer(4*16);
-        buf.append("{");
-        for (int i=0; data!=null && i<data.length; i++ ) {
-            buf.append(String.valueOf(data[i])).append(" ");
-            if ( i==max ) {
-                buf.append("...("+data.length+")");
-                break;
-            }
-        }
-        buf.append("}");
-        return buf.toString();
-    }
-
-    /**
-     * @see java.lang.Object#hashCode()
-     * @return The hash code
-     */
-    public int hashCode() {
-        return getHost()[0]+getHost()[1]+getHost()[2]+getHost()[3];
-    }
-
-    /**
-     * Returns true if the param o is a McastMember with the same name
-     * @param o
-     */
-    public boolean equals(Object o) {
-        if ( o instanceof MemberImpl )    {
-            return Arrays.equals(this.getHost(),((MemberImpl)o).getHost()) &&
-                   this.getPort() == ((MemberImpl)o).getPort() &&
-                   Arrays.equals(this.getUniqueId(),((MemberImpl)o).getUniqueId());
-        }
-        else
-            return false;
-    }
-    
-    public void setHost(byte[] host) {
-        this.host = host;
-    }
-    
-    public void setHostname(String host) throws IOException {
-        hostname = host;
-        this.host = java.net.InetAddress.getByName(host).getAddress();
-    }
-    
-    public void setMsgCount(int msgCount) {
-        this.msgCount = msgCount;
-    }
-
-    public void setPort(int port) {
-        this.port = port;
-        this.dataPkg = null;
-    }
-
-    public void setServiceStartTime(long serviceStartTime) {
-        this.serviceStartTime = serviceStartTime;
-    }
-
-    public void setUniqueId(byte[] uniqueId) {
-        this.uniqueId = uniqueId!=null?uniqueId:new byte[16];
-        getData(true,true);
-    }
-
-    public void setPayload(byte[] payload) {
-        byte[] oldpayload = this.payload;
-        this.payload = payload!=null?payload:new byte[0];
-        if ( this.getData(true,true).length > McastServiceImpl.MAX_PACKET_SIZE ) {
-            this.payload = oldpayload;
-            throw new IllegalArgumentException("Payload is to large for tribes to handle.");
-        }
-        
-    }
-
-    public void setCommand(byte[] command) {
-        this.command = command!=null?command:new byte[0];
-        getData(true,true);
-    }
-
-    public void setDomain(byte[] domain) {
-        this.domain = domain!=null?domain:new byte[0];
-        getData(true,true);
-    }
-
-    public void setSecurePort(int securePort) {
-        this.securePort = securePort;
-    }
-
-    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
-        int length = in.readInt();
-        byte[] message = new byte[length];
-        in.read(message);
-        getMember(message,this);
-        
-    }
-
-    public void writeExternal(ObjectOutput out) throws IOException {
-        byte[] data = this.getData();
-        out.writeInt(data.length);
-        out.write(data);
-    }
-    
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.membership;
+
+import java.io.IOException;
+import java.io.ObjectInput;
+import java.io.ObjectOutput;
+import java.util.Arrays;
+
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.io.XByteBuffer;
+import org.apache.catalina.tribes.transport.SenderState;
+
+/**
+ * A <b>membership</b> implementation using simple multicast.
+ * This is the representation of a multicast member.
+ * Carries the host, and port of the this or other cluster nodes.
+ *
+ * @author Filip Hanik
+ * @version $Revision$, $Date$
+ */
+public class MemberImpl implements Member, java.io.Externalizable {
+
+    /**
+     * Public properties specific to this implementation
+     */
+    public static final transient String TCP_LISTEN_PORT = "tcpListenPort";
+    public static final transient String TCP_LISTEN_HOST = "tcpListenHost";
+    public static final transient String MEMBER_NAME = "memberName";
+    
+    public static final transient byte[] TRIBES_MBR_BEGIN = new byte[] {84, 82, 73, 66, 69, 83, 45, 66};
+    public static final transient byte[] TRIBES_MBR_END   = new byte[] {84, 82, 73, 66, 69, 83, 45, 69};
+    
+    /**
+     * The listen host for this member
+     */
+    protected byte[] host;
+    protected transient String hostname;
+    /**
+     * The tcp listen port for this member
+     */
+    protected int port;
+    
+    /**
+     * The tcp/SSL listen port for this member
+     */
+    protected int securePort = -1;
+
+    /**
+     * Counter for how many broadcast messages have been sent from this member
+     */
+    protected int msgCount = 0;
+    /**
+     * The number of milliseconds since this members was
+     * created, is kept track of using the start time
+     */
+    protected long memberAliveTime = 0;
+    
+    /**
+     * For the local member only
+     */
+    protected transient long serviceStartTime;
+    
+    /**
+     * To avoid serialization over and over again, once the local dataPkg
+     * has been set, we use that to transmit data
+     */
+    protected transient byte[] dataPkg = null;
+
+    /**
+     * Unique session Id for this member
+     */
+    protected byte[] uniqueId = new byte[16];
+    
+    /**
+     * Custom payload that an app framework can broadcast
+     * Also used to transport stop command.
+     */
+    protected byte[] payload = new byte[0];
+    
+    /**
+     * Command, so that the custom payload doesn't have to be used
+     * This is for internal tribes use, such as SHUTDOWN_COMMAND
+     */
+    protected byte[] command = new byte[0];
+
+    /**
+     * Domain if we want to filter based on domain.
+     */
+    protected byte[] domain = new byte[0];
+    
+    /**
+     * Empty constructor for serialization
+     */
+    public MemberImpl() {
+        
+    }
+
+    /**
+     * Construct a new member object
+     * @param name - the name of this member, cluster unique
+     * @param domain - the cluster domain name of this member
+     * @param host - the tcp listen host
+     * @param port - the tcp listen port
+     */
+    public MemberImpl(String host,
+                      int port,
+                      long aliveTime) throws IOException {
+        setHostname(host);
+        this.port = port;
+        this.memberAliveTime=aliveTime;
+    }
+    
+    public MemberImpl(String host,
+                      int port,
+                      long aliveTime,
+                      byte[] payload) throws IOException {
+        this(host,port,aliveTime);
+        setPayload(payload);
+    }
+    
+    public boolean isReady() {
+        return SenderState.getSenderState(this).isReady();
+    }
+    public boolean isSuspect() {
+        return SenderState.getSenderState(this).isSuspect();
+    }
+    public boolean isFailing() {
+        return SenderState.getSenderState(this).isFailing();
+    }
+
+    /**
+     * Increment the message count.
+     */
+    protected void inc() {
+        msgCount++;
+    }
+
+    /**
+     * Create a data package to send over the wire representing this member.
+     * This is faster than serialization.
+     * @return - the bytes for this member deserialized
+     * @throws Exception
+     */
+    public byte[] getData()  {
+        return getData(true);
+    }
+    /**
+     * Highly optimized version of serializing a member into a byte array
+     * Returns a cached byte[] reference, do not modify this data
+     * @param getalive boolean
+     * @return byte[]
+     */
+    public byte[] getData(boolean getalive)  {
+        return getData(getalive,false);
+    }
+    
+    
+    public int getDataLength() {
+        return TRIBES_MBR_BEGIN.length+ //start pkg
+               4+ //data length
+               8+ //alive time
+               4+ //port
+               4+ //secure port
+               1+ //host length
+               host.length+ //host
+               4+ //command length
+               command.length+ //command
+               4+ //domain length
+               domain.length+ //domain
+               16+ //unique id
+               4+ //payload length
+               payload.length+ //payload
+               TRIBES_MBR_END.length; //end pkg
+    }
+    
+    /**
+     * 
+     * @param getalive boolean - calculate memberAlive time
+     * @param reset boolean - reset the cached data package, and create a new one
+     * @return byte[]
+     */
+    public byte[] getData(boolean getalive, boolean reset)  {
+        if ( reset ) dataPkg = null;
+        //look in cache first
+        if ( dataPkg!=null ) {
+            if ( getalive ) {
+                //you'd be surprised, but System.currentTimeMillis
+                //shows up on the profiler
+                long alive=System.currentTimeMillis()-getServiceStartTime();
+                XByteBuffer.toBytes( (long) alive, dataPkg, TRIBES_MBR_BEGIN.length+4);
+            }
+            return dataPkg;
+        }
+        
+        //package looks like
+        //start package TRIBES_MBR_BEGIN.length
+        //package length - 4 bytes
+        //alive - 8 bytes
+        //port - 4 bytes
+        //secure port - 4 bytes
+        //host length - 1 byte
+        //host - hl bytes
+        //clen - 4 bytes
+        //command - clen bytes
+        //dlen - 4 bytes
+        //domain - dlen bytes
+        //uniqueId - 16 bytes
+        //payload length - 4 bytes
+        //payload plen bytes
+        //end package TRIBES_MBR_END.length
+        byte[] addr = host;
+        long alive=System.currentTimeMillis()-getServiceStartTime();
+        byte hl = (byte)addr.length;
+        byte[] data = new byte[getDataLength()];
+        
+        int bodylength = (getDataLength() - TRIBES_MBR_BEGIN.length - TRIBES_MBR_END.length - 4);
+        
+        int pos = 0;
+        
+        //TRIBES_MBR_BEGIN
+        System.arraycopy(TRIBES_MBR_BEGIN,0,data,pos,TRIBES_MBR_BEGIN.length);
+        pos += TRIBES_MBR_BEGIN.length;
+        
+        //body length
+        XByteBuffer.toBytes(bodylength,data,pos);
+        pos += 4;
+        
+        //alive data
+        XByteBuffer.toBytes((long)alive,data,pos);
+        pos += 8;
+        //port
+        XByteBuffer.toBytes(port,data,pos);
+        pos += 4;
+        //secure port
+        XByteBuffer.toBytes(securePort,data,pos);
+        pos += 4;
+        //host length
+        data[pos++] = hl;
+        //host
+        System.arraycopy(addr,0,data,pos,addr.length);
+        pos+=addr.length;
+        //clen - 4 bytes
+        XByteBuffer.toBytes(command.length,data,pos);
+        pos+=4;
+        //command - clen bytes
+        System.arraycopy(command,0,data,pos,command.length);
+        pos+=command.length;
+        //dlen - 4 bytes
+        XByteBuffer.toBytes(domain.length,data,pos);
+        pos+=4;
+        //domain - dlen bytes
+        System.arraycopy(domain,0,data,pos,domain.length);
+        pos+=domain.length;
+        //unique Id
+        System.arraycopy(uniqueId,0,data,pos,uniqueId.length);
+        pos+=uniqueId.length;
+        //payload
+        XByteBuffer.toBytes(payload.length,data,pos);
+        pos+=4;
+        System.arraycopy(payload,0,data,pos,payload.length);
+        pos+=payload.length;
+        
+        //TRIBES_MBR_END
+        System.arraycopy(TRIBES_MBR_END,0,data,pos,TRIBES_MBR_END.length);
+        pos += TRIBES_MBR_END.length;
+
+        //create local data
+        dataPkg = data;
+        return data;
+    }
+    /**
+     * Deserializes a member from data sent over the wire
+     * @param data - the bytes received
+     * @return a member object.
+     */
+    public static MemberImpl getMember(byte[] data, MemberImpl member) {
+        return getMember(data,0,data.length,member);
+    }
+
+    public static MemberImpl getMember(byte[] data, int offset, int length, MemberImpl member) {
+        //package looks like
+        //start package TRIBES_MBR_BEGIN.length
+        //package length - 4 bytes
+        //alive - 8 bytes
+        //port - 4 bytes
+        //secure port - 4 bytes
+        //host length - 1 byte
+        //host - hl bytes
+        //clen - 4 bytes
+        //command - clen bytes
+        //dlen - 4 bytes
+        //domain - dlen bytes
+        //uniqueId - 16 bytes
+        //payload length - 4 bytes
+        //payload plen bytes
+        //end package TRIBES_MBR_END.length
+
+        int pos = offset;
+        
+        if (XByteBuffer.firstIndexOf(data,offset,TRIBES_MBR_BEGIN)!=pos) {
+            throw new IllegalArgumentException("Invalid package, should start with:"+org.apache.catalina.tribes.util.Arrays.toString(TRIBES_MBR_BEGIN));
+        }
+
+        if ( length < (TRIBES_MBR_BEGIN.length+4) ) {
+            throw new ArrayIndexOutOfBoundsException("Member package to small to validate.");
+        }
+        
+        pos += TRIBES_MBR_BEGIN.length;
+        
+        int bodylength = XByteBuffer.toInt(data,pos);
+        pos += 4;
+        
+        if ( length < (bodylength+4+TRIBES_MBR_BEGIN.length+TRIBES_MBR_END.length) ) {
+            throw new ArrayIndexOutOfBoundsException("Not enough bytes in member package.");
+        }
+        
+        int endpos = pos+bodylength;
+        if (XByteBuffer.firstIndexOf(data,endpos,TRIBES_MBR_END)!=endpos) {
+            throw new IllegalArgumentException("Invalid package, should end with:"+org.apache.catalina.tribes.util.Arrays.toString(TRIBES_MBR_END));
+        }
+
+
+        byte[] alived = new byte[8];
+        System.arraycopy(data, pos, alived, 0, 8);
+        pos += 8;
+        byte[] portd = new byte[4];
+        System.arraycopy(data, pos, portd, 0, 4);
+        pos += 4;
+        
+        byte[] sportd = new byte[4];
+        System.arraycopy(data, pos, sportd, 0, 4);
+        pos += 4;
+
+
+    
+        byte hl = data[pos++];
+        byte[] addr = new byte[hl];
+        System.arraycopy(data, pos, addr, 0, hl);
+        pos += hl;
+    
+        int cl = XByteBuffer.toInt(data, pos);
+        pos += 4;
+    
+        byte[] command = new byte[cl];
+        System.arraycopy(data, pos, command, 0, command.length);
+        pos += command.length;
+    
+        int dl = XByteBuffer.toInt(data, pos);
+        pos += 4;
+    
+        byte[] domain = new byte[dl];
+        System.arraycopy(data, pos, domain, 0, domain.length);
+        pos += domain.length;
+    
+        byte[] uniqueId = new byte[16];
+        System.arraycopy(data, pos, uniqueId, 0, 16);
+        pos += 16;
+    
+        int pl = XByteBuffer.toInt(data, pos);
+        pos += 4;
+    
+        byte[] payload = new byte[pl];
+        System.arraycopy(data, pos, payload, 0, payload.length);
+        pos += payload.length;
+    
+        member.setHost(addr);
+        member.setPort(XByteBuffer.toInt(portd, 0));
+        member.setSecurePort(XByteBuffer.toInt(sportd, 0));
+        member.setMemberAliveTime(XByteBuffer.toLong(alived, 0));
+        member.setUniqueId(uniqueId);
+        member.payload = payload;
+        member.domain = domain;
+        member.command = command;
+    
+        member.dataPkg = new byte[length];
+        System.arraycopy(data, offset, member.dataPkg, 0, length);
+    
+        return member;
+    }
+
+    public static MemberImpl getMember(byte[] data) {
+       return getMember(data,new MemberImpl());
+    }
+
+    /**
+     * Return the name of this object
+     * @return a unique name to the cluster
+     */
+    public String getName() {
+        return "tcp://"+getHostname()+":"+getPort();
+    }
+    
+    /**
+     * Return the listen port of this member
+     * @return - tcp listen port
+     */
+    public int getPort()  {
+        return this.port;
+    }
+
+    /**
+     * Return the TCP listen host for this member
+     * @return IP address or host name
+     */
+    public byte[] getHost()  {
+        return host;
+    }
+    
+    public String getHostname() {
+        if ( this.hostname != null ) return hostname;
+        else {
+            try {
+                this.hostname = java.net.InetAddress.getByAddress(host).getHostName();
+                return this.hostname;
+            }catch ( IOException x ) {
+                throw new RuntimeException("Unable to parse hostname.",x);
+            }
+        }
+    }
+
+    /**
+     * Contains information on how long this member has been online.
+     * The result is the number of milli seconds this member has been
+     * broadcasting its membership to the cluster.
+     * @return nr of milliseconds since this member started.
+     */
+    public long getMemberAliveTime() {
+       return memberAliveTime;
+    }
+
+    public long getServiceStartTime() {
+        return serviceStartTime;
+    }
+
+    public byte[] getUniqueId() {
+        return uniqueId;
+    }
+
+    public byte[] getPayload() {
+        return payload;
+    }
+
+    public byte[] getCommand() {
+        return command;
+    }
+
+    public byte[] getDomain() {
+        return domain;
+    }
+
+    public int getSecurePort() {
+        return securePort;
+    }
+
+    public void setMemberAliveTime(long time) {
+       memberAliveTime=time;
+    }
+
+
+
+    /**
+     * String representation of this object
+     */
+    public String toString()  {
+        StringBuffer buf = new StringBuffer("org.apache.catalina.tribes.membership.MemberImpl[");
+        buf.append(getName()).append(",");
+        buf.append(getHostname()).append(",");
+        buf.append(port).append(", alive=");
+        buf.append(memberAliveTime).append(",");
+        buf.append("id=").append(bToS(this.uniqueId)).append(", ");
+        buf.append("payload=").append(bToS(this.payload,8)).append(", ");
+        buf.append("command=").append(bToS(this.command,8)).append(", ");
+        buf.append("domain=").append(bToS(this.domain,8)).append(", ");
+        buf.append("]");
+        return buf.toString();
+    }
+    public static String bToS(byte[] data) {
+        return bToS(data,data.length);
+    }
+    public static String bToS(byte[] data, int max) {
+        StringBuffer buf = new StringBuffer(4*16);
+        buf.append("{");
+        for (int i=0; data!=null && i<data.length; i++ ) {
+            buf.append(String.valueOf(data[i])).append(" ");
+            if ( i==max ) {
+                buf.append("...("+data.length+")");
+                break;
+            }
+        }
+        buf.append("}");
+        return buf.toString();
+    }
+
+    /**
+     * @see java.lang.Object#hashCode()
+     * @return The hash code
+     */
+    public int hashCode() {
+        return getHost()[0]+getHost()[1]+getHost()[2]+getHost()[3];
+    }
+
+    /**
+     * Returns true if the param o is a McastMember with the same name
+     * @param o
+     */
+    public boolean equals(Object o) {
+        if ( o instanceof MemberImpl )    {
+            return Arrays.equals(this.getHost(),((MemberImpl)o).getHost()) &&
+                   this.getPort() == ((MemberImpl)o).getPort() &&
+                   Arrays.equals(this.getUniqueId(),((MemberImpl)o).getUniqueId());
+        }
+        else
+            return false;
+    }
+    
+    public void setHost(byte[] host) {
+        this.host = host;
+    }
+    
+    public void setHostname(String host) throws IOException {
+        hostname = host;
+        this.host = java.net.InetAddress.getByName(host).getAddress();
+    }
+    
+    public void setMsgCount(int msgCount) {
+        this.msgCount = msgCount;
+    }
+
+    public void setPort(int port) {
+        this.port = port;
+        this.dataPkg = null;
+    }
+
+    public void setServiceStartTime(long serviceStartTime) {
+        this.serviceStartTime = serviceStartTime;
+    }
+
+    public void setUniqueId(byte[] uniqueId) {
+        this.uniqueId = uniqueId!=null?uniqueId:new byte[16];
+        getData(true,true);
+    }
+
+    public void setPayload(byte[] payload) {
+        byte[] oldpayload = this.payload;
+        this.payload = payload!=null?payload:new byte[0];
+        if ( this.getData(true,true).length > McastServiceImpl.MAX_PACKET_SIZE ) {
+            this.payload = oldpayload;
+            throw new IllegalArgumentException("Payload is to large for tribes to handle.");
+        }
+        
+    }
+
+    public void setCommand(byte[] command) {
+        this.command = command!=null?command:new byte[0];
+        getData(true,true);
+    }
+
+    public void setDomain(byte[] domain) {
+        this.domain = domain!=null?domain:new byte[0];
+        getData(true,true);
+    }
+
+    public void setSecurePort(int securePort) {
+        this.securePort = securePort;
+    }
+
+    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
+        int length = in.readInt();
+        byte[] message = new byte[length];
+        in.read(message);
+        getMember(message,this);
+        
+    }
+
+    public void writeExternal(ObjectOutput out) throws IOException {
+        byte[] data = this.getData();
+        out.writeInt(data.length);
+        out.write(data);
+    }
+    
+}

==================================================
StaticMember.java
index 869df340ff..355e8d9393 100644
--- a/java/org/apache/catalina/tribes/membership/Membership.java
+++ b/java/org/apache/catalina/tribes/membership/Membership.java
@@ -1,325 +1,325 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.membership;
-
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
-
-import org.apache.catalina.tribes.Member;
-import java.util.Comparator;
-
-/**
- * A <b>membership</b> implementation using simple multicast.
- * This is the representation of a multicast membership.
- * This class is responsible for maintaining a list of active cluster nodes in the cluster.
- * If a node fails to send out a heartbeat, the node will be dismissed.
- *
- * @author Filip Hanik
- * @author Peter Rossbach
- * @version $Revision: 356540 $, $Date: 2005-12-13 10:53:40 -0600 (Tue, 13 Dec 2005) $
- */
-public class Membership
-{
-    protected static final MemberImpl[] EMPTY_MEMBERS = new MemberImpl[0];
-    
-    /**
-     * The name of this membership, has to be the same as the name for the local
-     * member
-     */
-    protected MemberImpl local;
-    
-    /**
-     * A map of all the members in the cluster.
-     */
-    protected HashMap map = new HashMap();
-    
-    /**
-     * A list of all the members in the cluster.
-     */
-    protected MemberImpl[] members = EMPTY_MEMBERS;
-    
-    /**
-      * sort members by alive time
-      */
-    protected Comparator memberComparator = new MemberComparator();
-
-    public Object clone() {
-        synchronized (members) {
-            Membership clone = new Membership(local, memberComparator);
-            clone.map = (HashMap) map.clone();
-            clone.members = new MemberImpl[members.length];
-            System.arraycopy(members,0,clone.members,0,members.length);
-            return clone;
-        }
-    }
-
-    /**
-     * Constructs a new membership
-     * @param name - has to be the name of the local member. Used to filter the local member from the cluster membership
-     */
-    public Membership(MemberImpl local, boolean includeLocal) {
-        this.local = local;
-        if ( includeLocal ) addMember(local);
-    }
-
-    public Membership(MemberImpl local) {
-        this(local,false);
-    }
-
-    public Membership(MemberImpl local, Comparator comp) {
-        this(local,comp,false);
-    }
-
-    public Membership(MemberImpl local, Comparator comp, boolean includeLocal) {
-        this(local,includeLocal);
-        this.memberComparator = comp;
-    }
-    /**
-     * Reset the membership and start over fresh.
-     * Ie, delete all the members and wait for them to ping again and join this membership
-     */
-    public synchronized void reset() {
-        map.clear();
-        members = EMPTY_MEMBERS ;
-    }
-
-    /**
-     * Notify the membership that this member has announced itself.
-     *
-     * @param member - the member that just pinged us
-     * @return - true if this member is new to the cluster, false otherwise.
-     * @return - false if this member is the local member or updated.
-     */
-    public synchronized boolean memberAlive(MemberImpl member) {
-        boolean result = false;
-        //ignore ourselves
-        if (  member.equals(local) ) return result;
-
-        //return true if the membership has changed
-        MbrEntry entry = (MbrEntry)map.get(member);
-        if ( entry == null ) {
-            entry = addMember(member);
-            result = true;
-       } else {
-            //update the member alive time
-            MemberImpl updateMember = entry.getMember() ;
-            if(updateMember.getMemberAliveTime() != member.getMemberAliveTime()) {
-                //update fields that can change
-                updateMember.setMemberAliveTime(member.getMemberAliveTime());
-                updateMember.setPayload(member.getPayload());
-                updateMember.setCommand(member.getCommand());
-                Arrays.sort(members, memberComparator);
-            }
-        }
-        entry.accessed();
-        return result;
-    }
-
-    /**
-     * Add a member to this component and sort array with memberComparator
-     * @param member The member to add
-     */
-    public synchronized MbrEntry addMember(MemberImpl member) {
-      synchronized (members) {
-          MbrEntry entry = new MbrEntry(member);
-          if (!map.containsKey(member) ) {
-              map.put(member, entry);
-              MemberImpl results[] = new MemberImpl[members.length + 1];
-              for (int i = 0; i < members.length; i++) results[i] = members[i];
-              results[members.length] = member;
-              members = results;
-              Arrays.sort(members, memberComparator);
-          }
-          return entry;
-      }
-    }
-    
-    /**
-     * Remove a member from this component.
-     * 
-     * @param member The member to remove
-     */
-    public void removeMember(MemberImpl member) {
-        map.remove(member);
-        synchronized (members) {
-            int n = -1;
-            for (int i = 0; i < members.length; i++) {
-                if (members[i] == member || members[i].equals(member)) {
-                    n = i;
-                    break;
-                }
-            }
-            if (n < 0) return;
-            MemberImpl results[] = new MemberImpl[members.length - 1];
-            int j = 0;
-            for (int i = 0; i < members.length; i++) {
-                if (i != n)
-                    results[j++] = members[i];
-            }
-            members = results;
-        }
-    }
-    
-    /**
-     * Runs a refresh cycle and returns a list of members that has expired.
-     * This also removes the members from the membership, in such a way that
-     * getMembers() = getMembers() - expire()
-     * @param maxtime - the max time a member can remain unannounced before it is considered dead.
-     * @return the list of expired members
-     */
-    public synchronized MemberImpl[] expire(long maxtime) {
-        if(!hasMembers() )
-           return EMPTY_MEMBERS;
-       
-        ArrayList list = null;
-        Iterator i = map.values().iterator();
-        while(i.hasNext()) {
-            MbrEntry entry = (MbrEntry)i.next();
-            if( entry.hasExpired(maxtime) ) {
-                if(list == null) // only need a list when members are expired (smaller gc)
-                    list = new java.util.ArrayList();
-                list.add(entry.getMember());
-            }
-        }
-        
-        if(list != null) {
-            MemberImpl[] result = new MemberImpl[list.size()];
-            list.toArray(result);
-            for( int j=0; j<result.length; j++) {
-                removeMember(result[j]);
-            }
-            return result;
-        } else {
-            return EMPTY_MEMBERS ;
-        }
-    }
-
-    /**
-     * Returning that service has members or not
-     */
-    public boolean hasMembers() {
-        return members.length > 0 ;
-    }
-    
-    
-    public MemberImpl getMember(Member mbr) {
-        if(hasMembers()) {
-            MemberImpl result = null;
-            for ( int i=0; i<this.members.length && result==null; i++ ) {
-                if ( members[i].equals(mbr) ) result = members[i];
-            }//for
-            return result;
-        } else {
-            return null;
-        }
-    }
-    
-    public boolean contains(Member mbr) { 
-        return getMember(mbr)!=null;
-    }
- 
-    /**
-     * Returning a list of all the members in the membership
-     * We not need a copy: add and remove generate new arrays.
-     */
-    public MemberImpl[] getMembers() {
-        if(hasMembers()) {
-            return members;
-        } else {
-            return EMPTY_MEMBERS;
-        }
-    }
-
-    /**
-     * get a copy from all member entries
-     */
-    protected synchronized MbrEntry[] getMemberEntries()
-    {
-        MbrEntry[] result = new MbrEntry[map.size()];
-        java.util.Iterator i = map.entrySet().iterator();
-        int pos = 0;
-        while ( i.hasNext() )
-            result[pos++] = ((MbrEntry)((java.util.Map.Entry)i.next()).getValue());
-        return result;
-    }
-    
-    // --------------------------------------------- Inner Class
-
-    private class MemberComparator implements java.util.Comparator {
-
-        public int compare(Object o1, Object o2) {
-            try {
-                return compare((MemberImpl) o1, (MemberImpl) o2);
-            } catch (ClassCastException x) {
-                return 0;
-            }
-        }
-
-        public int compare(MemberImpl m1, MemberImpl m2) {
-            //longer alive time, means sort first
-            long result = m2.getMemberAliveTime() - m1.getMemberAliveTime();
-            if (result < 0)
-                return -1;
-            else if (result == 0)
-                return 0;
-            else
-                return 1;
-        }
-    }
-    
-    /**
-     * Inner class that represents a member entry
-     */
-    protected static class MbrEntry
-    {
-
-        protected MemberImpl mbr;
-        protected long lastHeardFrom;
-
-        public MbrEntry(MemberImpl mbr) {
-           this.mbr = mbr;
-        }
-
-        /**
-         * Indicate that this member has been accessed.
-         */
-        public void accessed(){
-           lastHeardFrom = System.currentTimeMillis();
-        }
-
-        /**
-         * Return the actual Member object
-         */
-        public MemberImpl getMember() {
-            return mbr;
-        }
-
-        /**
-         * Check if this dude has expired
-         * @param maxtime The time threshold
-         */
-        public boolean hasExpired(long maxtime) {
-            long delta = System.currentTimeMillis() - lastHeardFrom;
-            return delta > maxtime;
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.membership;
+
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+import org.apache.catalina.tribes.Member;
+import java.util.Comparator;
+
+/**
+ * A <b>membership</b> implementation using simple multicast.
+ * This is the representation of a multicast membership.
+ * This class is responsible for maintaining a list of active cluster nodes in the cluster.
+ * If a node fails to send out a heartbeat, the node will be dismissed.
+ *
+ * @author Filip Hanik
+ * @author Peter Rossbach
+ * @version $Revision$, $Date$
+ */
+public class Membership
+{
+    protected static final MemberImpl[] EMPTY_MEMBERS = new MemberImpl[0];
+    
+    /**
+     * The name of this membership, has to be the same as the name for the local
+     * member
+     */
+    protected MemberImpl local;
+    
+    /**
+     * A map of all the members in the cluster.
+     */
+    protected HashMap map = new HashMap();
+    
+    /**
+     * A list of all the members in the cluster.
+     */
+    protected MemberImpl[] members = EMPTY_MEMBERS;
+    
+    /**
+      * sort members by alive time
+      */
+    protected Comparator memberComparator = new MemberComparator();
+
+    public Object clone() {
+        synchronized (members) {
+            Membership clone = new Membership(local, memberComparator);
+            clone.map = (HashMap) map.clone();
+            clone.members = new MemberImpl[members.length];
+            System.arraycopy(members,0,clone.members,0,members.length);
+            return clone;
+        }
+    }
+
+    /**
+     * Constructs a new membership
+     * @param name - has to be the name of the local member. Used to filter the local member from the cluster membership
+     */
+    public Membership(MemberImpl local, boolean includeLocal) {
+        this.local = local;
+        if ( includeLocal ) addMember(local);
+    }
+
+    public Membership(MemberImpl local) {
+        this(local,false);
+    }
+
+    public Membership(MemberImpl local, Comparator comp) {
+        this(local,comp,false);
+    }
+
+    public Membership(MemberImpl local, Comparator comp, boolean includeLocal) {
+        this(local,includeLocal);
+        this.memberComparator = comp;
+    }
+    /**
+     * Reset the membership and start over fresh.
+     * Ie, delete all the members and wait for them to ping again and join this membership
+     */
+    public synchronized void reset() {
+        map.clear();
+        members = EMPTY_MEMBERS ;
+    }
+
+    /**
+     * Notify the membership that this member has announced itself.
+     *
+     * @param member - the member that just pinged us
+     * @return - true if this member is new to the cluster, false otherwise.
+     * @return - false if this member is the local member or updated.
+     */
+    public synchronized boolean memberAlive(MemberImpl member) {
+        boolean result = false;
+        //ignore ourselves
+        if (  member.equals(local) ) return result;
+
+        //return true if the membership has changed
+        MbrEntry entry = (MbrEntry)map.get(member);
+        if ( entry == null ) {
+            entry = addMember(member);
+            result = true;
+       } else {
+            //update the member alive time
+            MemberImpl updateMember = entry.getMember() ;
+            if(updateMember.getMemberAliveTime() != member.getMemberAliveTime()) {
+                //update fields that can change
+                updateMember.setMemberAliveTime(member.getMemberAliveTime());
+                updateMember.setPayload(member.getPayload());
+                updateMember.setCommand(member.getCommand());
+                Arrays.sort(members, memberComparator);
+            }
+        }
+        entry.accessed();
+        return result;
+    }
+
+    /**
+     * Add a member to this component and sort array with memberComparator
+     * @param member The member to add
+     */
+    public synchronized MbrEntry addMember(MemberImpl member) {
+      synchronized (members) {
+          MbrEntry entry = new MbrEntry(member);
+          if (!map.containsKey(member) ) {
+              map.put(member, entry);
+              MemberImpl results[] = new MemberImpl[members.length + 1];
+              for (int i = 0; i < members.length; i++) results[i] = members[i];
+              results[members.length] = member;
+              members = results;
+              Arrays.sort(members, memberComparator);
+          }
+          return entry;
+      }
+    }
+    
+    /**
+     * Remove a member from this component.
+     * 
+     * @param member The member to remove
+     */
+    public void removeMember(MemberImpl member) {
+        map.remove(member);
+        synchronized (members) {
+            int n = -1;
+            for (int i = 0; i < members.length; i++) {
+                if (members[i] == member || members[i].equals(member)) {
+                    n = i;
+                    break;
+                }
+            }
+            if (n < 0) return;
+            MemberImpl results[] = new MemberImpl[members.length - 1];
+            int j = 0;
+            for (int i = 0; i < members.length; i++) {
+                if (i != n)
+                    results[j++] = members[i];
+            }
+            members = results;
+        }
+    }
+    
+    /**
+     * Runs a refresh cycle and returns a list of members that has expired.
+     * This also removes the members from the membership, in such a way that
+     * getMembers() = getMembers() - expire()
+     * @param maxtime - the max time a member can remain unannounced before it is considered dead.
+     * @return the list of expired members
+     */
+    public synchronized MemberImpl[] expire(long maxtime) {
+        if(!hasMembers() )
+           return EMPTY_MEMBERS;
+       
+        ArrayList list = null;
+        Iterator i = map.values().iterator();
+        while(i.hasNext()) {
+            MbrEntry entry = (MbrEntry)i.next();
+            if( entry.hasExpired(maxtime) ) {
+                if(list == null) // only need a list when members are expired (smaller gc)
+                    list = new java.util.ArrayList();
+                list.add(entry.getMember());
+            }
+        }
+        
+        if(list != null) {
+            MemberImpl[] result = new MemberImpl[list.size()];
+            list.toArray(result);
+            for( int j=0; j<result.length; j++) {
+                removeMember(result[j]);
+            }
+            return result;
+        } else {
+            return EMPTY_MEMBERS ;
+        }
+    }
+
+    /**
+     * Returning that service has members or not
+     */
+    public boolean hasMembers() {
+        return members.length > 0 ;
+    }
+    
+    
+    public MemberImpl getMember(Member mbr) {
+        if(hasMembers()) {
+            MemberImpl result = null;
+            for ( int i=0; i<this.members.length && result==null; i++ ) {
+                if ( members[i].equals(mbr) ) result = members[i];
+            }//for
+            return result;
+        } else {
+            return null;
+        }
+    }
+    
+    public boolean contains(Member mbr) { 
+        return getMember(mbr)!=null;
+    }
+ 
+    /**
+     * Returning a list of all the members in the membership
+     * We not need a copy: add and remove generate new arrays.
+     */
+    public MemberImpl[] getMembers() {
+        if(hasMembers()) {
+            return members;
+        } else {
+            return EMPTY_MEMBERS;
+        }
+    }
+
+    /**
+     * get a copy from all member entries
+     */
+    protected synchronized MbrEntry[] getMemberEntries()
+    {
+        MbrEntry[] result = new MbrEntry[map.size()];
+        java.util.Iterator i = map.entrySet().iterator();
+        int pos = 0;
+        while ( i.hasNext() )
+            result[pos++] = ((MbrEntry)((java.util.Map.Entry)i.next()).getValue());
+        return result;
+    }
+    
+    // --------------------------------------------- Inner Class
+
+    private class MemberComparator implements java.util.Comparator {
+
+        public int compare(Object o1, Object o2) {
+            try {
+                return compare((MemberImpl) o1, (MemberImpl) o2);
+            } catch (ClassCastException x) {
+                return 0;
+            }
+        }
+
+        public int compare(MemberImpl m1, MemberImpl m2) {
+            //longer alive time, means sort first
+            long result = m2.getMemberAliveTime() - m1.getMemberAliveTime();
+            if (result < 0)
+                return -1;
+            else if (result == 0)
+                return 0;
+            else
+                return 1;
+        }
+    }
+    
+    /**
+     * Inner class that represents a member entry
+     */
+    protected static class MbrEntry
+    {
+
+        protected MemberImpl mbr;
+        protected long lastHeardFrom;
+
+        public MbrEntry(MemberImpl mbr) {
+           this.mbr = mbr;
+        }
+
+        /**
+         * Indicate that this member has been accessed.
+         */
+        public void accessed(){
+           lastHeardFrom = System.currentTimeMillis();
+        }
+
+        /**
+         * Return the actual Member object
+         */
+        public MemberImpl getMember() {
+            return mbr;
+        }
+
+        /**
+         * Check if this dude has expired
+         * @param maxtime The time threshold
+         */
+        public boolean hasExpired(long maxtime) {
+            long delta = System.currentTimeMillis() - lastHeardFrom;
+            return delta > maxtime;
+        }
+    }
+}

==================================================
AbstractReplicatedMap.java
index 4d51b9f7ee..933b36d17e 100644
--- a/java/org/apache/catalina/tribes/membership/StaticMember.java
+++ b/java/org/apache/catalina/tribes/membership/StaticMember.java
@@ -1,80 +1,80 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.membership;
-
-import java.io.IOException;
-import org.apache.catalina.tribes.util.UUIDGenerator;
-import org.apache.catalina.tribes.util.Arrays;
-
-/**
- * <p>Title: </p>
- *
- * <p>Description: </p>
- *
- * <p>Copyright: Copyright (c) 2006</p>
- *
- * <p>Company: </p>
- *
- * @author not attributable
- * @version 1.0
- */
-public class StaticMember extends MemberImpl {
-    public StaticMember() {
-        super();
-    }
-
-    public StaticMember(String host, int port, long aliveTime) throws IOException {
-        super(host, port, aliveTime);
-    }
-
-    public StaticMember(String host, int port, long aliveTime, byte[] payload) throws IOException {
-        super(host, port, aliveTime, payload);
-    }
-     
-    /**
-     * @param host String, either in byte array string format, like {214,116,1,3}
-     * or as a regular hostname, 127.0.0.1 or tomcat01.mydomain.com
-     */
-    public void setHost(String host) {
-        if ( host == null ) return;
-        if ( host.startsWith("{") ) setHost(Arrays.fromString(host));
-        else try { setHostname(host); }catch (IOException x) { throw new RuntimeException(x);}
-        
-    }
-    
-    /**
-     * @param domain String, either in byte array string format, like {214,116,1,3}
-     * or as a regular string value like 'mydomain'. The latter will be converted using ISO-8859-1 encoding
-     */
-    public void setDomain(String domain) {
-        if ( domain == null ) return;
-        if ( domain.startsWith("{") ) setDomain(Arrays.fromString(domain));
-        else setDomain(Arrays.convert(domain));
-    }
-    
-    /**
-     * @param id String, must be in byte array string format, like {214,116,1,3} and exactly 16 bytes long
-     */
-    public void setUniqueId(String id) {
-        byte[] uuid = Arrays.fromString(id);
-        if ( uuid==null || uuid.length != 16 ) throw new RuntimeException("UUID must be exactly 16 bytes, not:"+id);
-        setUniqueId(uuid);
-    }
-    
-    
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.membership;
+
+import java.io.IOException;
+import org.apache.catalina.tribes.util.UUIDGenerator;
+import org.apache.catalina.tribes.util.Arrays;
+
+/**
+ * <p>Title: </p>
+ *
+ * <p>Description: </p>
+ *
+ * <p>Copyright: Copyright (c) 2006</p>
+ *
+ * <p>Company: </p>
+ *
+ * @author not attributable
+ * @version 1.0
+ */
+public class StaticMember extends MemberImpl {
+    public StaticMember() {
+        super();
+    }
+
+    public StaticMember(String host, int port, long aliveTime) throws IOException {
+        super(host, port, aliveTime);
+    }
+
+    public StaticMember(String host, int port, long aliveTime, byte[] payload) throws IOException {
+        super(host, port, aliveTime, payload);
+    }
+     
+    /**
+     * @param host String, either in byte array string format, like {214,116,1,3}
+     * or as a regular hostname, 127.0.0.1 or tomcat01.mydomain.com
+     */
+    public void setHost(String host) {
+        if ( host == null ) return;
+        if ( host.startsWith("{") ) setHost(Arrays.fromString(host));
+        else try { setHostname(host); }catch (IOException x) { throw new RuntimeException(x);}
+        
+    }
+    
+    /**
+     * @param domain String, either in byte array string format, like {214,116,1,3}
+     * or as a regular string value like 'mydomain'. The latter will be converted using ISO-8859-1 encoding
+     */
+    public void setDomain(String domain) {
+        if ( domain == null ) return;
+        if ( domain.startsWith("{") ) setDomain(Arrays.fromString(domain));
+        else setDomain(Arrays.convert(domain));
+    }
+    
+    /**
+     * @param id String, must be in byte array string format, like {214,116,1,3} and exactly 16 bytes long
+     */
+    public void setUniqueId(String id) {
+        byte[] uuid = Arrays.fromString(id);
+        if ( uuid==null || uuid.length != 16 ) throw new RuntimeException("UUID must be exactly 16 bytes, not:"+id);
+        setUniqueId(uuid);
+    }
+    
+    
 }
\ No newline at end of file

==================================================
LazyReplicatedMap.java
index 53382e591d..a17379e955 100644
--- a/java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java
+++ b/java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java
@@ -1,1368 +1,1368 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.tipis;
-
-import java.io.IOException;
-import java.io.ObjectInput;
-import java.io.ObjectOutput;
-import java.io.Serializable;
-import java.io.UnsupportedEncodingException;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Set;
-
-import org.apache.catalina.tribes.Channel;
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelListener;
-import org.apache.catalina.tribes.Heartbeat;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.MembershipListener;
-import org.apache.catalina.tribes.group.Response;
-import org.apache.catalina.tribes.group.RpcCallback;
-import org.apache.catalina.tribes.group.RpcChannel;
-import org.apache.catalina.tribes.io.XByteBuffer;
-import org.apache.catalina.tribes.membership.MemberImpl;
-import org.apache.catalina.tribes.util.Arrays;
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-import java.util.ConcurrentModificationException;
-
-/**
- *
- * @author Filip Hanik
- * @version 1.0
- */
-public abstract class AbstractReplicatedMap extends LinkedHashMap implements RpcCallback, ChannelListener, MembershipListener, Heartbeat {
-    protected static Log log = LogFactory.getLog(AbstractReplicatedMap.class);
-
-    /**
-     * The default initial capacity - MUST be a power of two.
-     */
-    public static final int DEFAULT_INITIAL_CAPACITY = 16;
-
-    /**
-     * The load factor used when none specified in constructor.
-     **/
-    public static final float DEFAULT_LOAD_FACTOR = 0.75f;
-    
-    /**
-     * Used to identify the map
-     */
-    final String chset = "ISO-8859-1";
-
-//------------------------------------------------------------------------------
-//              INSTANCE VARIABLES
-//------------------------------------------------------------------------------
-    
-    /**
-     * Timeout for RPC messages, how long we will wait for a reply
-     */
-    protected transient long rpcTimeout = 5000;
-    /**
-     * Reference to the channel for sending messages
-     */
-    protected transient Channel channel;
-    /**
-     * The RpcChannel to send RPC messages through
-     */
-    protected transient RpcChannel rpcChannel;
-    /**
-     * The Map context name makes this map unique, this
-     * allows us to have more than one map shared
-     * through one channel
-     */
-    protected transient byte[] mapContextName;
-    /**
-     * Has the state been transferred
-     */
-    protected transient boolean stateTransferred = false;
-    /**
-     * Simple lock object for transfers
-     */
-    protected transient Object stateMutex = new Object();
-    /**
-     * A list of members in our map
-     */
-    protected transient HashMap mapMembers = new HashMap();
-    /**
-     * Our default send options
-     */
-    protected transient int channelSendOptions = Channel.SEND_OPTIONS_DEFAULT;
-    /**
-     * The owner of this map, ala a SessionManager for example
-     */
-    protected transient Object mapOwner;
-    /**
-     * External class loaders if serialization and deserialization is to be performed successfully.
-     */
-    protected transient ClassLoader[] externalLoaders;
-    
-    /**
-     * The node we are currently backing up data to, this index will rotate
-     * on a round robin basis
-     */
-    protected transient int currentNode = 0;
-    
-    /**
-     * Since the map keeps internal membership
-     * this is the timeout for a ping message to be responded to
-     * If a remote map doesn't respond within this timeframe, 
-     * its considered dead.
-     */
-    protected transient long accessTimeout = 5000;
-    
-    /**
-     * Readable string of the mapContextName value
-     */
-    protected transient String mapname = "";
-    
-
-//------------------------------------------------------------------------------
-//              CONSTRUCTORS
-//------------------------------------------------------------------------------
-
-    /**
-     * Creates a new map
-     * @param channel The channel to use for communication
-     * @param timeout long - timeout for RPC messags
-     * @param mapContextName String - unique name for this map, to allow multiple maps per channel
-     * @param initialCapacity int - the size of this map, see HashMap
-     * @param loadFactor float - load factor, see HashMap
-     * @param cls - a list of classloaders to be used for deserialization of objects.
-     */
-    public AbstractReplicatedMap(Object owner,
-                                 Channel channel, 
-                                 long timeout, 
-                                 String mapContextName, 
-                                 int initialCapacity,
-                                 float loadFactor,
-                                 int channelSendOptions,
-                                 ClassLoader[] cls) {
-        super(initialCapacity, loadFactor);
-        init(owner, channel, mapContextName, timeout, channelSendOptions, cls);
-        
-    }
-
-    /**
-     * Helper methods, wraps a single member in an array
-     * @param m Member
-     * @return Member[]
-     */
-    protected Member[] wrap(Member m) {
-        if ( m == null ) return new Member[0];
-        else return new Member[] {m};
-    }
-
-    /**
-     * Initializes the map by creating the RPC channel, registering itself as a channel listener
-     * This method is also responsible for initiating the state transfer
-     * @param owner Object
-     * @param channel Channel
-     * @param mapContextName String
-     * @param timeout long
-     * @param channelSendOptions int
-     * @param cls ClassLoader[]
-     */
-    protected void init(Object owner, Channel channel, String mapContextName, long timeout, int channelSendOptions,ClassLoader[] cls) {
-        log.info("Initializing AbstractReplicatedMap with context name:"+mapContextName);
-        this.mapOwner = owner;
-        this.externalLoaders = cls;
-        this.channelSendOptions = channelSendOptions;
-        this.channel = channel;
-        this.rpcTimeout = timeout;
-
-        try {
-            this.mapname = mapContextName;
-            //unique context is more efficient if it is stored as bytes
-            this.mapContextName = mapContextName.getBytes(chset);
-        } catch (UnsupportedEncodingException x) {
-            log.warn("Unable to encode mapContextName[" + mapContextName + "] using getBytes(" + chset +") using default getBytes()", x);
-            this.mapContextName = mapContextName.getBytes();
-        }
-        if ( log.isTraceEnabled() ) log.trace("Created Lazy Map with name:"+mapContextName+", bytes:"+Arrays.toString(this.mapContextName));
-
-        //create an rpc channel and add the map as a listener
-        this.rpcChannel = new RpcChannel(this.mapContextName, channel, this);
-        //add this map as a message listener
-        this.channel.addChannelListener(this);
-        //listen for membership notifications
-        this.channel.addMembershipListener(this);
-        
-        
-        try {
-            //broadcast our map, this just notifies other members of our existence
-            broadcast(MapMessage.MSG_INIT, true);
-            //transfer state from another map
-            transferState();
-            //state is transferred, we are ready for messaging
-            broadcast(MapMessage.MSG_START, true);
-        } catch (ChannelException x) {
-            log.warn("Unable to send map start message.");
-            throw new RuntimeException("Unable to start replicated map.",x);
-        }
-    }
-    
-    
-    /**
-     * Sends a ping out to all the members in the cluster, not just map members
-     * that this map is alive.
-     * @param timeout long
-     * @throws ChannelException
-     */
-    protected void ping(long timeout) throws ChannelException {
-        //send out a map membership message, only wait for the first reply
-        MapMessage msg = new MapMessage(this.mapContextName, 
-                                        MapMessage.MSG_INIT,
-                                        false, 
-                                        null, 
-                                        null, 
-                                        null, 
-                                        wrap(channel.getLocalMember(false)));
-        if ( channel.getMembers().length > 0 ) {
-            //send a ping, wait for all nodes to reply
-            Response[] resp = rpcChannel.send(channel.getMembers(), 
-                                              msg, rpcChannel.ALL_REPLY, 
-                                              (channelSendOptions),
-                                              (int) accessTimeout);
-            for (int i = 0; i < resp.length; i++) {
-                memberAlive(resp[i].getSource());
-            } //for
-        }
-        //update our map of members, expire some if we didn't receive a ping back
-        synchronized (mapMembers) {
-            Iterator it = mapMembers.entrySet().iterator();
-            long now = System.currentTimeMillis();
-            while ( it.hasNext() ) {
-                Map.Entry entry = (Map.Entry)it.next();
-                long access = ((Long)entry.getValue()).longValue(); 
-                if ( (now - access) > timeout ) memberDisappeared((Member)entry.getKey());
-            }
-        }//synch
-    }
-
-    /**
-     * We have received a member alive notification
-     * @param member Member
-     */
-    protected void memberAlive(Member member) {
-        synchronized (mapMembers) {
-            if (!mapMembers.containsKey(member)) {
-                mapMemberAdded(member);
-            } //end if
-            mapMembers.put(member, new Long(System.currentTimeMillis()));
-        }
-    }
-    
-    /**
-     * Helper method to broadcast a message to all members in a channel
-     * @param msgtype int
-     * @param rpc boolean
-     * @throws ChannelException
-     */
-    protected void broadcast(int msgtype, boolean rpc) throws ChannelException {
-        //send out a map membership message, only wait for the first reply
-        MapMessage msg = new MapMessage(this.mapContextName, msgtype,
-                                        false, null, null, null, wrap(channel.getLocalMember(false)));
-        if ( rpc) {
-            Response[] resp = rpcChannel.send(channel.getMembers(), msg, rpcChannel.FIRST_REPLY, (channelSendOptions),rpcTimeout);
-            for (int i = 0; i < resp.length; i++) {
-                mapMemberAdded(resp[i].getSource());
-                messageReceived(resp[i].getMessage(), resp[i].getSource());
-            }
-        } else {
-            channel.send(channel.getMembers(),msg,channelSendOptions);
-        }
-    }
-
-    public void breakdown() {
-        finalize();
-    }
-
-    public void finalize() {
-        try {broadcast(MapMessage.MSG_STOP,false); }catch ( Exception ignore){}
-        //cleanup
-        if (this.rpcChannel != null) {
-            this.rpcChannel.breakdown();
-        }
-        if (this.channel != null) {
-            this.channel.removeChannelListener(this);
-            this.channel.removeMembershipListener(this);
-        }
-        this.rpcChannel = null;
-        this.channel = null;
-        this.mapMembers.clear();
-        super.clear();
-        this.stateTransferred = false;
-        this.externalLoaders = null;
-    }
-    
-    public int hashCode() {
-        return Arrays.hashCode(this.mapContextName);
-    }
-    
-    public boolean equals(Object o) {
-        if ( o == null ) return false;
-        if ( !(o instanceof AbstractReplicatedMap)) return false;
-        if ( !(o.getClass().equals(this.getClass())) ) return false;
-        AbstractReplicatedMap other = (AbstractReplicatedMap)o;
-        return Arrays.equals(mapContextName,other.mapContextName);
-    }
-
-//------------------------------------------------------------------------------
-//              GROUP COM INTERFACES
-//------------------------------------------------------------------------------
-    public Member[] getMapMembers(HashMap members) {
-        synchronized (members) {
-            Member[] result = new Member[members.size()];
-            members.keySet().toArray(result);
-            return result;
-        }
-    }
-    public Member[] getMapMembers() {
-        return getMapMembers(this.mapMembers);
-    }
-    
-    public Member[] getMapMembersExcl(Member[] exclude) {
-        synchronized (mapMembers) {
-            HashMap list = (HashMap)mapMembers.clone();
-            for (int i=0; i<exclude.length;i++) list.remove(exclude[i]);
-            return getMapMembers(list);
-        }
-    }
-
-
-    /**
-     * Replicates any changes to the object since the last time
-     * The object has to be primary, ie, if the object is a proxy or a backup, it will not be replicated<br>
-     * @param complete - if set to true, the object is replicated to its backup
-     * if set to false, only objects that implement ReplicatedMapEntry and the isDirty() returns true will
-     * be replicated
-     */
-    public void replicate(Object key, boolean complete) {
-        if ( log.isTraceEnabled() )
-            log.trace("Replicate invoked on key:"+key);
-        MapEntry entry = (MapEntry)super.get(key);
-        if ( entry == null ) return;
-        if ( !entry.isSerializable() ) return;
-        if (entry != null && entry.isPrimary() && entry.getBackupNodes()!= null && entry.getBackupNodes().length > 0) {
-            Object value = entry.getValue();
-            //check to see if we need to replicate this object isDirty()||complete
-            boolean repl = complete || ( (value instanceof ReplicatedMapEntry) && ( (ReplicatedMapEntry) value).isDirty());
-            
-            if (!repl) {
-                if ( log.isTraceEnabled() )
-                    log.trace("Not replicating:"+key+", no change made");
-                
-                return;
-            }
-            //check to see if the message is diffable
-            boolean diff = ( (value instanceof ReplicatedMapEntry) && ( (ReplicatedMapEntry) value).isDiffable());
-            MapMessage msg = null;
-            if (diff) {
-                ReplicatedMapEntry rentry = (ReplicatedMapEntry)entry.getValue();
-                try {
-                    rentry.lock();
-                    //construct a diff message
-                    msg = new MapMessage(mapContextName, MapMessage.MSG_BACKUP,
-                                         true, (Serializable) entry.getKey(), null,
-                                         rentry.getDiff(),
-                                         entry.getBackupNodes());
-                } catch (IOException x) {
-                    log.error("Unable to diff object. Will replicate the entire object instead.", x);
-                } finally {
-                    rentry.unlock();
-                }
-                
-            }
-            if (msg == null) {
-                //construct a complete
-                msg = new MapMessage(mapContextName, MapMessage.MSG_BACKUP,
-                                     false, (Serializable) entry.getKey(),
-                                     (Serializable) entry.getValue(),
-                                     null, entry.getBackupNodes());
-
-            }
-            try {
-                if ( channel!=null && entry.getBackupNodes()!= null && entry.getBackupNodes().length > 0 ) {
-                    channel.send(entry.getBackupNodes(), msg, channelSendOptions);
-                }
-            } catch (ChannelException x) {
-                log.error("Unable to replicate data.", x);
-            }
-        } //end if
-
-    }
-
-    /**
-     * This can be invoked by a periodic thread to replicate out any changes.
-     * For maps that don't store objects that implement ReplicatedMapEntry, this
-     * method should be used infrequently to avoid large amounts of data transfer
-     * @param complete boolean
-     */
-    public void replicate(boolean complete) {
-        Iterator i = super.entrySet().iterator();
-        while (i.hasNext()) {
-            Map.Entry e = (Map.Entry) i.next();
-            replicate(e.getKey(), complete);
-        } //while
-
-    }
-
-    public void transferState() {
-        try {
-            Member[] members = getMapMembers();
-            Member backup = members.length > 0 ? (Member) members[0] : null;
-            if (backup != null) {
-                MapMessage msg = new MapMessage(mapContextName, MapMessage.MSG_STATE, false,
-                                                null, null, null, null);
-                Response[] resp = rpcChannel.send(new Member[] {backup}, msg, rpcChannel.FIRST_REPLY, channelSendOptions, rpcTimeout);
-                if (resp.length > 0) {
-                    synchronized (stateMutex) {
-                        msg = (MapMessage) resp[0].getMessage();
-                        msg.deserialize(getExternalLoaders());
-                        ArrayList list = (ArrayList) msg.getValue();
-                        for (int i = 0; i < list.size(); i++) {
-                            messageReceived( (Serializable) list.get(i), resp[0].getSource());
-                        } //for
-                    }
-                } else {
-                    log.warn("Transfer state, 0 replies, probably a timeout.");
-                }
-            }
-        } catch (ChannelException x) {
-            log.error("Unable to transfer LazyReplicatedMap state.", x);
-        } catch (IOException x) {
-            log.error("Unable to transfer LazyReplicatedMap state.", x);
-        } catch (ClassNotFoundException x) {
-            log.error("Unable to transfer LazyReplicatedMap state.", x);
-        }
-        stateTransferred = true;
-    }
-
-    /**
-     * @todo implement state transfer
-     * @param msg Serializable
-     * @return Serializable - null if no reply should be sent
-     */
-    public Serializable replyRequest(Serializable msg, final Member sender) {
-        if (! (msg instanceof MapMessage))return null;
-        MapMessage mapmsg = (MapMessage) msg;
-
-        //map init request
-        if (mapmsg.getMsgType() == mapmsg.MSG_INIT) {
-            mapmsg.setBackUpNodes(wrap(channel.getLocalMember(false)));
-            return mapmsg;
-        }
-        
-        //map start request
-        if (mapmsg.getMsgType() == mapmsg.MSG_START) {
-            mapmsg.setBackUpNodes(wrap(channel.getLocalMember(false)));
-            mapMemberAdded(sender);
-            return mapmsg;
-        }
-
-        //backup request
-        if (mapmsg.getMsgType() == mapmsg.MSG_RETRIEVE_BACKUP) {
-            MapEntry entry = (MapEntry)super.get(mapmsg.getKey());
-            if (entry == null || (!entry.isSerializable()) )return null;
-            mapmsg.setValue( (Serializable) entry.getValue());
-            return mapmsg;
-        }
-
-        //state transfer request
-        if (mapmsg.getMsgType() == mapmsg.MSG_STATE) {
-            synchronized (stateMutex) { //make sure we dont do two things at the same time
-                ArrayList list = new ArrayList();
-                Iterator i = super.entrySet().iterator();
-                while (i.hasNext()) {
-                    Map.Entry e = (Map.Entry) i.next();
-                    MapEntry entry = (MapEntry) e.getValue();
-                    if ( entry.isSerializable() ) {
-                        MapMessage me = new MapMessage(mapContextName, MapMessage.MSG_PROXY,
-                            false, (Serializable) entry.getKey(), null, null, entry.getBackupNodes());
-                        list.add(me);
-                    }
-                }
-                mapmsg.setValue(list);
-                return mapmsg;
-                
-            } //synchronized
-        }
-
-        return null;
-
-    }
-
-    /**
-     * If the reply has already been sent to the requesting thread,
-     * the rpc callback can handle any data that comes in after the fact.
-     * @param msg Serializable
-     * @param sender Member
-     */
-    public void leftOver(Serializable msg, Member sender) {
-        //left over membership messages
-        if (! (msg instanceof MapMessage))return;
-
-        MapMessage mapmsg = (MapMessage) msg;
-        try {
-            mapmsg.deserialize(getExternalLoaders());
-            if (mapmsg.getMsgType() == MapMessage.MSG_START) {
-                mapMemberAdded(mapmsg.getBackupNodes()[0]);
-            } else if (mapmsg.getMsgType() == MapMessage.MSG_INIT) {
-                memberAlive(mapmsg.getBackupNodes()[0]);
-            }
-        } catch (IOException x ) {
-            log.error("Unable to deserialize MapMessage.",x);
-        } catch (ClassNotFoundException x ) {
-            log.error("Unable to deserialize MapMessage.",x);
-        }
-    }
-
-    public void messageReceived(Serializable msg, Member sender) {
-        if (! (msg instanceof MapMessage)) return;
-
-        MapMessage mapmsg = (MapMessage) msg;
-        if ( log.isTraceEnabled() ) {
-            log.trace("Map["+mapname+"] received message:"+mapmsg);
-        }
-        
-        try {
-            mapmsg.deserialize(getExternalLoaders());
-        } catch (IOException x) {
-            log.error("Unable to deserialize MapMessage.", x);
-            return;
-        } catch (ClassNotFoundException x) {
-            log.error("Unable to deserialize MapMessage.", x);
-            return;
-        }
-        if ( log.isTraceEnabled() ) 
-            log.trace("Map message received from:"+sender.getName()+" msg:"+mapmsg);
-        if (mapmsg.getMsgType() == MapMessage.MSG_START) {
-            mapMemberAdded(mapmsg.getBackupNodes()[0]);
-        }
-
-        if (mapmsg.getMsgType() == MapMessage.MSG_STOP) {
-            memberDisappeared(mapmsg.getBackupNodes()[0]);
-        }
-
-        if (mapmsg.getMsgType() == MapMessage.MSG_PROXY) {
-            MapEntry entry = (MapEntry)super.get(mapmsg.getKey());
-            if ( entry==null ) {
-                entry = new MapEntry(mapmsg.getKey(), mapmsg.getValue());
-                entry.setBackup(false);
-                entry.setProxy(true);
-                entry.setBackupNodes(mapmsg.getBackupNodes());
-                super.put(entry.getKey(), entry);
-            } else {
-                entry.setProxy(true);
-                entry.setBackup(false);
-                entry.setBackupNodes(mapmsg.getBackupNodes());
-            }
-        }
-
-        if (mapmsg.getMsgType() == MapMessage.MSG_REMOVE) {
-            super.remove(mapmsg.getKey());
-        }
-
-        if (mapmsg.getMsgType() == MapMessage.MSG_BACKUP) {
-            MapEntry entry = (MapEntry)super.get(mapmsg.getKey());
-            if (entry == null) {
-                entry = new MapEntry(mapmsg.getKey(), mapmsg.getValue());
-                entry.setBackup(true);
-                entry.setProxy(false);
-                entry.setBackupNodes(mapmsg.getBackupNodes());
-                if (mapmsg.getValue()!=null && mapmsg.getValue() instanceof ReplicatedMapEntry ) {
-                    ((ReplicatedMapEntry)mapmsg.getValue()).setOwner(getMapOwner());
-                }
-            } else {
-                entry.setBackup(true);
-                entry.setProxy(false);
-                entry.setBackupNodes(mapmsg.getBackupNodes());
-                if (entry.getValue() instanceof ReplicatedMapEntry) {
-                    ReplicatedMapEntry diff = (ReplicatedMapEntry) entry.getValue();
-                    if (mapmsg.isDiff()) {
-                        try {
-                            diff.lock();
-                            diff.applyDiff(mapmsg.getDiffValue(), 0, mapmsg.getDiffValue().length);
-                        } catch (Exception x) {
-                            log.error("Unable to apply diff to key:" + entry.getKey(), x);
-                        } finally {
-                            diff.unlock();
-                        }
-                    } else {
-                        if ( mapmsg.getValue()!=null ) entry.setValue(mapmsg.getValue());
-                        ((ReplicatedMapEntry)entry.getValue()).setOwner(getMapOwner());
-                    } //end if
-                } else if  (mapmsg.getValue() instanceof ReplicatedMapEntry) {
-                    ReplicatedMapEntry re = (ReplicatedMapEntry)mapmsg.getValue();
-                    re.setOwner(getMapOwner());
-                    entry.setValue(re);
-                } else {
-                    if ( mapmsg.getValue()!=null ) entry.setValue(mapmsg.getValue());
-                } //end if
-            } //end if
-            super.put(entry.getKey(), entry);
-        } //end if
-    }
-
-    public boolean accept(Serializable msg, Member sender) {
-        boolean result = false;
-        if (msg instanceof MapMessage) {
-            if ( log.isTraceEnabled() ) log.trace("Map["+mapname+"] accepting...."+msg);
-            result = Arrays.equals(mapContextName, ( (MapMessage) msg).getMapId());
-            if ( log.isTraceEnabled() ) log.trace("Msg["+mapname+"] accepted["+result+"]...."+msg);
-        }
-        return result;
-    }
-
-    public void mapMemberAdded(Member member) {
-        if ( member.equals(getChannel().getLocalMember(false)) ) return;
-        boolean memberAdded = false;
-        //select a backup node if we don't have one
-        synchronized (mapMembers) {
-            if (!mapMembers.containsKey(member) ) {
-                mapMembers.put(member, new Long(System.currentTimeMillis()));
-                memberAdded = true;
-            }
-        }
-        if ( memberAdded ) {
-            synchronized (stateMutex) {
-                Iterator i = super.entrySet().iterator();
-                while (i.hasNext()) {
-                    Map.Entry e = (Map.Entry) i.next();
-                    MapEntry entry = (MapEntry) e.getValue();
-                    if ( entry == null ) continue;
-                    if (entry.isPrimary() && (entry.getBackupNodes() == null || entry.getBackupNodes().length == 0)) {
-                        try {
-                            Member[] backup = publishEntryInfo(entry.getKey(), entry.getValue());
-                            entry.setBackupNodes(backup);
-                        } catch (ChannelException x) {
-                            log.error("Unable to select backup node.", x);
-                        } //catch
-                    } //end if
-                } //while
-            } //synchronized
-        }//end if
-    }
-    
-    public boolean inSet(Member m, Member[] set) {
-        if ( set == null ) return false;
-        boolean result = false;
-        for (int i=0; i<set.length && (!result); i++ )
-            if ( m.equals(set[i]) ) result = true;
-        return result;
-    }
-
-    public Member[] excludeFromSet(Member[] mbrs, Member[] set) {
-        ArrayList result = new ArrayList();
-        for (int i=0; i<set.length; i++ ) {
-            boolean include = true;
-            for (int j=0; j<mbrs.length; j++ ) 
-                if ( mbrs[j].equals(set[i]) ) include = false;
-            if ( include ) result.add(set[i]);
-        }
-        return (Member[])result.toArray(new Member[result.size()]);
-    }
-
-    public void memberAdded(Member member) {
-        //do nothing
-    }
-
-    public void memberDisappeared(Member member) {
-        boolean removed = false;
-        synchronized (mapMembers) {
-            removed = (mapMembers.remove(member) != null );
-        }
-        Iterator i = super.entrySet().iterator();
-        while (i.hasNext()) {
-            Map.Entry e = (Map.Entry) i.next();
-            MapEntry entry = (MapEntry) e.getValue();
-            if (entry.isPrimary() && inSet(member,entry.getBackupNodes())) {
-                try {
-                    Member[] backup = publishEntryInfo(entry.getKey(), entry.getValue());
-                    entry.setBackupNodes(backup);
-                } catch (ChannelException x) {
-                    log.error("Unable to relocate[" + entry.getKey() + "] to a new backup node", x);
-                }
-            } //end if
-        } //while
-    }
-
-    public int getNextBackupIndex() {
-        int size = mapMembers.size();
-        if (mapMembers.size() == 0)return -1;
-        int node = currentNode++;
-        if (node >= size) {
-            node = 0;
-            currentNode = 0;
-        }
-        return node;
-    }
-    public Member getNextBackupNode() {
-        Member[] members = getMapMembers();
-        int node = getNextBackupIndex();
-        if ( members.length == 0 || node==-1) return null;
-        if ( node >= members.length ) node = 0;
-        return members[node];
-    }
-
-    protected abstract Member[] publishEntryInfo(Object key, Object value) throws ChannelException;
-    
-    public void heartbeat() {
-        try {
-            ping(accessTimeout);
-        }catch ( Exception x ) {
-            log.error("Unable to send AbstractReplicatedMap.ping message",x);
-        }
-    }
-
-//------------------------------------------------------------------------------    
-//              METHODS TO OVERRIDE    
-//------------------------------------------------------------------------------
-  
-    /**
-     * Removes an object from this map, it will also remove it from 
-     * 
-     * @param key Object
-     * @return Object
-     */
-    public Object remove(Object key) {
-        MapEntry entry = (MapEntry)super.remove(key);
-
-        try {
-            if (getMapMembers().length > 0 ) {
-                MapMessage msg = new MapMessage(getMapContextName(), MapMessage.MSG_REMOVE, false, (Serializable) key, null, null, null);
-                getChannel().send(getMapMembers(), msg, getChannelSendOptions());
-            }
-        } catch ( ChannelException x ) {
-            log.error("Unable to replicate out data for a LazyReplicatedMap.remove operation",x);
-        }
-        return entry!=null?entry.getValue():null;
-    }
-    
-    public Object get(Object key) {
-        MapEntry entry = (MapEntry)super.get(key);
-        if (log.isTraceEnabled()) log.trace("Requesting id:"+key+" entry:"+entry);
-        if ( entry == null ) return null;
-        if ( !entry.isPrimary() ) {
-            //if the message is not primary, we need to retrieve the latest value
-            try {
-                Member[] backup = null;
-                MapMessage msg = null;
-                if ( !entry.isBackup() ) {
-                    //make sure we don't retrieve from ourselves
-                    msg = new MapMessage(getMapContextName(), MapMessage.MSG_RETRIEVE_BACKUP, false,
-                                         (Serializable) key, null, null, null);
-                    Response[] resp = getRpcChannel().send(entry.getBackupNodes(),msg, this.getRpcChannel().FIRST_REPLY, Channel.SEND_OPTIONS_DEFAULT, getRpcTimeout());
-                    if (resp == null || resp.length == 0) {
-                        //no responses
-                        log.warn("Unable to retrieve remote object for key:" + key);
-                        return null;
-                    }
-                    msg = (MapMessage) resp[0].getMessage();
-                    msg.deserialize(getExternalLoaders());
-                    backup = entry.getBackupNodes();
-                    if ( entry.getValue() instanceof ReplicatedMapEntry ) {
-                        ReplicatedMapEntry val = (ReplicatedMapEntry)entry.getValue();
-                        val.setOwner(getMapOwner());
-                    }
-                    if ( msg.getValue()!=null ) entry.setValue(msg.getValue());
-                }
-                if (entry.isBackup()) {
-                    //select a new backup node
-                    backup = publishEntryInfo(key, entry.getValue());
-                } else if ( entry.isProxy() ) {
-                    //invalidate the previous primary
-                    msg = new MapMessage(getMapContextName(),MapMessage.MSG_PROXY,false,(Serializable)key,null,null,backup);
-                    Member[] dest = getMapMembersExcl(backup);
-                    if ( dest!=null && dest.length >0) {
-                        getChannel().send(dest, msg, getChannelSendOptions());
-                    }
-                }
-
-                entry.setBackupNodes(backup);
-                entry.setBackup(false);
-                entry.setProxy(false);
-
-
-            } catch (Exception x) {
-                log.error("Unable to replicate out data for a LazyReplicatedMap.get operation", x);
-                return null;
-            }
-        }
-        if (log.isTraceEnabled()) log.trace("Requesting id:"+key+" result:"+entry.getValue());
-        if ( entry.getValue() != null && entry.getValue() instanceof ReplicatedMapEntry ) {
-            ReplicatedMapEntry val = (ReplicatedMapEntry)entry.getValue();
-            //hack, somehow this is not being set above
-            val.setOwner(getMapOwner());
-            
-        }
-        return entry.getValue();
-    }    
-
-    
-    protected void printMap(String header) {
-        try {
-            System.out.println("\nDEBUG MAP:"+header);
-            System.out.println("Map["+ new String(mapContextName, chset) + ", Map Size:" + super.size());
-            Member[] mbrs = getMapMembers();
-            for ( int i=0; i<mbrs.length;i++ ) {
-                System.out.println("Mbr["+(i+1)+"="+mbrs[i].getName());
-            }
-            Iterator i = super.entrySet().iterator();
-            int cnt = 0;
-
-            while (i.hasNext()) {
-                Map.Entry e = (Map.Entry) i.next();
-                System.out.println( (++cnt) + ". " + e.getValue());
-            }
-            System.out.println("EndMap]\n\n");
-        }catch ( Exception ignore) {
-            ignore.printStackTrace();
-        }
-    }
-    
-    /**
-         * Returns true if the key has an entry in the map.
-         * The entry can be a proxy or a backup entry, invoking <code>get(key)</code>
-         * will make this entry primary for the group
-         * @param key Object
-         * @return boolean
-         */
-        public boolean containsKey(Object key) {
-            return super.containsKey(key);
-        }
-    
-    
-        public Object put(Object key, Object value) {
-            MapEntry entry = new MapEntry(key,value);
-            entry.setBackup(false);
-            entry.setProxy(false);
-    
-            Object old = null;
-    
-            //make sure that any old values get removed
-            if ( containsKey(key) ) old = remove(key);
-            try {
-                Member[] backup = publishEntryInfo(key, value);
-                entry.setBackupNodes(backup);
-            } catch (ChannelException x) {
-                log.error("Unable to replicate out data for a LazyReplicatedMap.put operation", x);
-            }
-            super.put(key,entry);
-            return old;
-        }
-    
-    
-        /**
-         * Copies all values from one map to this instance
-         * @param m Map
-         */
-        public void putAll(Map m) {
-            Iterator i = m.entrySet().iterator();
-            while ( i.hasNext() ) {
-                Map.Entry entry = (Map.Entry)i.next();
-                put(entry.getKey(),entry.getValue());
-            }
-        }
-    
-        public void clear() {
-            //only delete active keys
-            Iterator keys = keySet().iterator();
-            while ( keys.hasNext() ) remove(keys.next());
-        }
-    
-        public boolean containsValue(Object value) {
-            if ( value == null ) {
-                return super.containsValue(value);
-            } else {
-                Iterator i = super.entrySet().iterator();
-                while (i.hasNext()) {
-                    Map.Entry e = (Map.Entry) i.next();
-                    MapEntry entry = (MapEntry) e.getValue();
-                    if (entry.isPrimary() && value.equals(entry.getValue())) return true;
-                }//while
-                return false;
-            }//end if
-        }
-    
-        public Object clone() {
-            throw new UnsupportedOperationException("This operation is not valid on a replicated map");
-        }
-    
-        /**
-         * Returns the entire contents of the map
-         * Map.Entry.getValue() will return a LazyReplicatedMap.MapEntry object containing all the information 
-         * about the object.
-         * @return Set
-         */
-        public Set entrySetFull() {
-            return super.entrySet();
-        }
-    
-        public Set keySetFull() {
-            return super.keySet();
-        }
-    
-        public int sizeFull() {
-            return super.size();
-        }
-    
-        public Set entrySet() {
-            LinkedHashSet set = new LinkedHashSet(super.size());
-            Iterator i = super.entrySet().iterator();
-            while ( i.hasNext() ) {
-                Map.Entry e = (Map.Entry)i.next();
-                MapEntry entry = (MapEntry)e.getValue();
-                if ( entry.isPrimary() ) set.add(entry);
-            }
-            return Collections.unmodifiableSet(set);
-        }
-    
-        public Set keySet() {
-            //todo implement
-            //should only return keys where this is active.
-            LinkedHashSet set = new LinkedHashSet(super.size());
-            Iterator i = super.entrySet().iterator();
-            while ( i.hasNext() ) {
-                Map.Entry e = (Map.Entry)i.next();
-                MapEntry entry = (MapEntry)e.getValue();
-                if ( entry.isPrimary() ) set.add(entry.getKey());
-            }
-            return Collections.unmodifiableSet(set);
-        }
-    
-    
-        public int size() {
-            //todo, implement a counter variable instead
-            //only count active members in this node
-            int counter = 0;
-            Iterator it = Collections.unmodifiableSet(super.entrySet()).iterator();
-            while (it.hasNext() ) {
-                Map.Entry e = (Map.Entry) it.next();
-                if ( e != null ) {
-                    MapEntry entry = (MapEntry) e.getValue();
-                    if (entry.isPrimary() && entry.getValue() != null) counter++;
-                }
-            }
-            return counter;
-        }
-    
-        protected boolean removeEldestEntry(Map.Entry eldest) {
-            return false;
-        }
-    
-        public boolean isEmpty() {
-            return size()==0;
-        }
-    
-        public Collection values() {
-            ArrayList values = new ArrayList();
-            Iterator i = super.entrySet().iterator();
-            while ( i.hasNext() ) {
-                Map.Entry e = (Map.Entry)i.next();
-                MapEntry entry = (MapEntry)e.getValue();
-                if ( entry.isPrimary() && entry.getValue()!=null) values.add(entry.getValue());
-            }
-            return Collections.unmodifiableCollection(values);
-        }
-        
-
-//------------------------------------------------------------------------------
-//                Map Entry class
-//------------------------------------------------------------------------------
-    public static class MapEntry implements Map.Entry {
-        private boolean backup;
-        private boolean proxy;
-        private Member[] backupNodes;
-
-        private Object key;
-        private Object value;
-
-        public MapEntry(Object key, Object value) {
-            setKey(key);
-            setValue(value);
-            
-        }
-        
-        public boolean isKeySerializable() {
-            return (key == null) || (key instanceof Serializable);
-        }
-        
-        public boolean isValueSerializable() {
-            return (value==null) || (value instanceof Serializable);
-        }
-        
-        public boolean isSerializable() {
-            return isKeySerializable() && isValueSerializable();
-        }
-        
-        public boolean isBackup() {
-            return backup;
-        }
-
-        public void setBackup(boolean backup) {
-            this.backup = backup;
-        }
-
-        public boolean isProxy() {
-            return proxy;
-        }
-
-        public boolean isPrimary() {
-            return ( (!proxy) && (!backup));
-        }
-
-        public void setProxy(boolean proxy) {
-            this.proxy = proxy;
-        }
-
-        public boolean isDiffable() {
-            return (value instanceof ReplicatedMapEntry) &&
-                   ((ReplicatedMapEntry)value).isDiffable();
-        }
-
-        public void setBackupNodes(Member[] nodes) {
-            this.backupNodes = nodes;
-        }
-
-        public Member[] getBackupNodes() {
-            return backupNodes;
-        }
-
-        public Object getValue() {
-            return value;
-        }
-
-        public Object setValue(Object value) {
-            Object old = this.value;
-            this.value = (Serializable) value;
-            return old;
-        }
-
-        public Object getKey() {
-            return key;
-        }
-        
-        public Object setKey(Object key) {
-            Object old = this.key;
-            this.key = (Serializable)key;
-            return old;
-        }
-
-        public int hashCode() {
-            return key.hashCode();
-        }
-
-        public boolean equals(Object o) {
-            return key.equals(o);
-        }
-
-        /**
-         * apply a diff, or an entire object
-         * @param data byte[]
-         * @param offset int
-         * @param length int
-         * @param diff boolean
-         * @throws IOException
-         * @throws ClassNotFoundException
-         */
-        public void apply(byte[] data, int offset, int length, boolean diff) throws IOException, ClassNotFoundException {
-            if (isDiffable() && diff) {
-                ReplicatedMapEntry rentry = (ReplicatedMapEntry) value;
-                try {
-                    rentry.lock();
-                    rentry.applyDiff(data, offset, length);
-                } finally {
-                    rentry.unlock();
-                }
-            } else if (length == 0) {
-                value = null;
-                proxy = true;
-            } else {
-                value = XByteBuffer.deserialize(data, offset, length);
-            }
-        }
-        
-        public String toString() {
-            StringBuffer buf = new StringBuffer("MapEntry[key:");
-            buf.append(getKey()).append("; ");
-            buf.append("value:").append(getValue()).append("; ");
-            buf.append("primary:").append(isPrimary()).append("; ");
-            buf.append("backup:").append(isBackup()).append("; ");
-            buf.append("proxy:").append(isProxy()).append(";]");
-            return buf.toString();
-        }
-
-    }
-
-//------------------------------------------------------------------------------
-//                map message to send to and from other maps
-//------------------------------------------------------------------------------
-
-    public static class MapMessage implements Serializable {
-        public static final int MSG_BACKUP = 1;
-        public static final int MSG_RETRIEVE_BACKUP = 2;
-        public static final int MSG_PROXY = 3;
-        public static final int MSG_REMOVE = 4;
-        public static final int MSG_STATE = 5;
-        public static final int MSG_START = 6;
-        public static final int MSG_STOP = 7;
-        public static final int MSG_INIT = 8;
-
-        private byte[] mapId;
-        private int msgtype;
-        private boolean diff;
-        private transient Serializable key;
-        private transient Serializable value;
-        private byte[] valuedata;
-        private byte[] keydata;
-        private byte[] diffvalue;
-        private Member[] nodes;
-        
-        public String toString() {
-            StringBuffer buf = new StringBuffer("MapMessage[context=");
-            buf.append(new String(mapId));
-            buf.append("; type=");
-            buf.append(getTypeDesc());
-            buf.append("; key=");
-            buf.append(key);
-            buf.append("; value=");
-            buf.append(value);
-            return buf.toString();
-        }
-        
-        public String getTypeDesc() {
-            switch (msgtype) {
-                case MSG_BACKUP: return "MSG_BACKUP";
-                case MSG_RETRIEVE_BACKUP: return "MSG_RETRIEVE_BACKUP";
-                case MSG_PROXY: return "MSG_PROXY";
-                case MSG_REMOVE: return "MSG_REMOVE";
-                case MSG_STATE: return "MSG_STATE";
-                case MSG_START: return "MSG_START";
-                case MSG_STOP: return "MSG_STOP";
-                case MSG_INIT: return "MSG_INIT";
-                default : return "UNKNOWN";
-            }
-        }
-
-        public MapMessage() {}
-
-        public MapMessage(byte[] mapId,int msgtype, boolean diff,
-                          Serializable key, Serializable value,
-                          byte[] diffvalue, Member[] nodes)  {
-            this.mapId = mapId;
-            this.msgtype = msgtype;
-            this.diff = diff;
-            this.key = key;
-            this.value = value;
-            this.diffvalue = diffvalue;
-            this.nodes = nodes;
-            setValue(value);
-            setKey(key);
-        }
-        
-        public void deserialize(ClassLoader[] cls) throws IOException, ClassNotFoundException {
-            key(cls);
-            value(cls);
-        }
-
-        public int getMsgType() {
-            return msgtype;
-        }
-
-        public boolean isDiff() {
-            return diff;
-        }
-
-        public Serializable getKey() {
-            try {
-                return key(null);
-            } catch ( Exception x ) {
-                log.error("Deserialization error of the MapMessage.key",x);
-                return null;
-            }
-        }
-
-        public Serializable key(ClassLoader[] cls) throws IOException, ClassNotFoundException {
-            if ( key!=null ) return key;
-            if ( keydata == null || keydata.length == 0 ) return null;
-            key = XByteBuffer.deserialize(keydata,0,keydata.length,cls);
-            keydata = null;
-            return key;
-        }
-        
-        public byte[] getKeyData() {
-            return keydata;
-        }
-        
-        public Serializable getValue() {
-            try {
-                return value(null);
-            } catch ( Exception x ) {
-                log.error("Deserialization error of the MapMessage.value",x);
-                return null;
-            }
-        }
-
-        public Serializable value(ClassLoader[] cls) throws IOException, ClassNotFoundException  {
-            if ( value!=null ) return value;
-            if ( valuedata == null || valuedata.length == 0 ) return null;
-            value = XByteBuffer.deserialize(valuedata,0,valuedata.length,cls);
-            valuedata = null;;
-            return value;
-        }
-        
-        public byte[] getValueData() {
-            return valuedata;
-        }
-
-        public byte[] getDiffValue() {
-            return diffvalue;
-        }
-
-        public Member[] getBackupNodes() {
-            return nodes;
-        }
-
-        private void setBackUpNodes(Member[] nodes) {
-            this.nodes = nodes;
-        }
-
-        public byte[] getMapId() {
-            return mapId;
-        }
-
-        public void setValue(Serializable value) {
-            try {
-                if ( value != null ) valuedata = XByteBuffer.serialize(value);
-                this.value = value;
-            }catch ( IOException x ) {
-                throw new RuntimeException(x);
-            }
-        }
-        
-        public void setKey(Serializable key) {
-            try {
-                if (key != null) keydata = XByteBuffer.serialize(key);
-                this.key = key;
-            } catch (IOException x) {
-                throw new RuntimeException(x);
-            }
-        }
-        
-        protected Member[] readMembers(ObjectInput in) throws IOException, ClassNotFoundException {
-            int nodecount = in.readInt();
-            Member[] members = new Member[nodecount];
-            for ( int i=0; i<members.length; i++ ) {
-                byte[] d = new byte[in.readInt()];
-                in.read(d);
-                if (d.length > 0) members[i] = MemberImpl.getMember(d);
-            }
-            return members;
-        }
-        
-        protected void writeMembers(ObjectOutput out,Member[] members) throws IOException {
-            if ( members == null ) members = new Member[0];
-            out.writeInt(members.length);
-            for (int i=0; i<members.length; i++ ) {
-                if ( members[i] != null ) {
-                    byte[] d = members[i] != null ? ( (MemberImpl)members[i]).getData(false) : new byte[0];
-                    out.writeInt(d.length);
-                    out.write(d);
-                }
-            }
-        }
-        
-        
-        /**
-         * shallow clone
-         * @return Object
-         */
-        public Object clone() {
-            MapMessage msg = new MapMessage(this.mapId, this.msgtype, this.diff, this.key, this.value, this.diffvalue, this.nodes);
-            msg.keydata = this.keydata;
-            msg.valuedata = this.valuedata;
-            return msg;
-        }
-    } //MapMessage
-
-
-    public Channel getChannel() {
-        return channel;
-    }
-
-    public byte[] getMapContextName() {
-        return mapContextName;
-    }
-
-    public RpcChannel getRpcChannel() {
-        return rpcChannel;
-    }
-
-    public long getRpcTimeout() {
-        return rpcTimeout;
-    }
-
-    public Object getStateMutex() {
-        return stateMutex;
-    }
-
-    public boolean isStateTransferred() {
-        return stateTransferred;
-    }
-
-    public Object getMapOwner() {
-        return mapOwner;
-    }
-
-    public ClassLoader[] getExternalLoaders() {
-        return externalLoaders;
-    }
-
-    public int getChannelSendOptions() {
-        return channelSendOptions;
-    }
-
-    public long getAccessTimeout() {
-        return accessTimeout;
-    }
-
-    public void setMapOwner(Object mapOwner) {
-        this.mapOwner = mapOwner;
-    }
-
-    public void setExternalLoaders(ClassLoader[] externalLoaders) {
-        this.externalLoaders = externalLoaders;
-    }
-
-    public void setChannelSendOptions(int channelSendOptions) {
-        this.channelSendOptions = channelSendOptions;
-    }
-
-    public void setAccessTimeout(long accessTimeout) {
-        this.accessTimeout = accessTimeout;
-    }
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.tipis;
+
+import java.io.IOException;
+import java.io.ObjectInput;
+import java.io.ObjectOutput;
+import java.io.Serializable;
+import java.io.UnsupportedEncodingException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.catalina.tribes.Channel;
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelListener;
+import org.apache.catalina.tribes.Heartbeat;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.MembershipListener;
+import org.apache.catalina.tribes.group.Response;
+import org.apache.catalina.tribes.group.RpcCallback;
+import org.apache.catalina.tribes.group.RpcChannel;
+import org.apache.catalina.tribes.io.XByteBuffer;
+import org.apache.catalina.tribes.membership.MemberImpl;
+import org.apache.catalina.tribes.util.Arrays;
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+import java.util.ConcurrentModificationException;
+
+/**
+ *
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public abstract class AbstractReplicatedMap extends LinkedHashMap implements RpcCallback, ChannelListener, MembershipListener, Heartbeat {
+    protected static Log log = LogFactory.getLog(AbstractReplicatedMap.class);
+
+    /**
+     * The default initial capacity - MUST be a power of two.
+     */
+    public static final int DEFAULT_INITIAL_CAPACITY = 16;
+
+    /**
+     * The load factor used when none specified in constructor.
+     **/
+    public static final float DEFAULT_LOAD_FACTOR = 0.75f;
+    
+    /**
+     * Used to identify the map
+     */
+    final String chset = "ISO-8859-1";
+
+//------------------------------------------------------------------------------
+//              INSTANCE VARIABLES
+//------------------------------------------------------------------------------
+    
+    /**
+     * Timeout for RPC messages, how long we will wait for a reply
+     */
+    protected transient long rpcTimeout = 5000;
+    /**
+     * Reference to the channel for sending messages
+     */
+    protected transient Channel channel;
+    /**
+     * The RpcChannel to send RPC messages through
+     */
+    protected transient RpcChannel rpcChannel;
+    /**
+     * The Map context name makes this map unique, this
+     * allows us to have more than one map shared
+     * through one channel
+     */
+    protected transient byte[] mapContextName;
+    /**
+     * Has the state been transferred
+     */
+    protected transient boolean stateTransferred = false;
+    /**
+     * Simple lock object for transfers
+     */
+    protected transient Object stateMutex = new Object();
+    /**
+     * A list of members in our map
+     */
+    protected transient HashMap mapMembers = new HashMap();
+    /**
+     * Our default send options
+     */
+    protected transient int channelSendOptions = Channel.SEND_OPTIONS_DEFAULT;
+    /**
+     * The owner of this map, ala a SessionManager for example
+     */
+    protected transient Object mapOwner;
+    /**
+     * External class loaders if serialization and deserialization is to be performed successfully.
+     */
+    protected transient ClassLoader[] externalLoaders;
+    
+    /**
+     * The node we are currently backing up data to, this index will rotate
+     * on a round robin basis
+     */
+    protected transient int currentNode = 0;
+    
+    /**
+     * Since the map keeps internal membership
+     * this is the timeout for a ping message to be responded to
+     * If a remote map doesn't respond within this timeframe, 
+     * its considered dead.
+     */
+    protected transient long accessTimeout = 5000;
+    
+    /**
+     * Readable string of the mapContextName value
+     */
+    protected transient String mapname = "";
+    
+
+//------------------------------------------------------------------------------
+//              CONSTRUCTORS
+//------------------------------------------------------------------------------
+
+    /**
+     * Creates a new map
+     * @param channel The channel to use for communication
+     * @param timeout long - timeout for RPC messags
+     * @param mapContextName String - unique name for this map, to allow multiple maps per channel
+     * @param initialCapacity int - the size of this map, see HashMap
+     * @param loadFactor float - load factor, see HashMap
+     * @param cls - a list of classloaders to be used for deserialization of objects.
+     */
+    public AbstractReplicatedMap(Object owner,
+                                 Channel channel, 
+                                 long timeout, 
+                                 String mapContextName, 
+                                 int initialCapacity,
+                                 float loadFactor,
+                                 int channelSendOptions,
+                                 ClassLoader[] cls) {
+        super(initialCapacity, loadFactor);
+        init(owner, channel, mapContextName, timeout, channelSendOptions, cls);
+        
+    }
+
+    /**
+     * Helper methods, wraps a single member in an array
+     * @param m Member
+     * @return Member[]
+     */
+    protected Member[] wrap(Member m) {
+        if ( m == null ) return new Member[0];
+        else return new Member[] {m};
+    }
+
+    /**
+     * Initializes the map by creating the RPC channel, registering itself as a channel listener
+     * This method is also responsible for initiating the state transfer
+     * @param owner Object
+     * @param channel Channel
+     * @param mapContextName String
+     * @param timeout long
+     * @param channelSendOptions int
+     * @param cls ClassLoader[]
+     */
+    protected void init(Object owner, Channel channel, String mapContextName, long timeout, int channelSendOptions,ClassLoader[] cls) {
+        log.info("Initializing AbstractReplicatedMap with context name:"+mapContextName);
+        this.mapOwner = owner;
+        this.externalLoaders = cls;
+        this.channelSendOptions = channelSendOptions;
+        this.channel = channel;
+        this.rpcTimeout = timeout;
+
+        try {
+            this.mapname = mapContextName;
+            //unique context is more efficient if it is stored as bytes
+            this.mapContextName = mapContextName.getBytes(chset);
+        } catch (UnsupportedEncodingException x) {
+            log.warn("Unable to encode mapContextName[" + mapContextName + "] using getBytes(" + chset +") using default getBytes()", x);
+            this.mapContextName = mapContextName.getBytes();
+        }
+        if ( log.isTraceEnabled() ) log.trace("Created Lazy Map with name:"+mapContextName+", bytes:"+Arrays.toString(this.mapContextName));
+
+        //create an rpc channel and add the map as a listener
+        this.rpcChannel = new RpcChannel(this.mapContextName, channel, this);
+        //add this map as a message listener
+        this.channel.addChannelListener(this);
+        //listen for membership notifications
+        this.channel.addMembershipListener(this);
+        
+        
+        try {
+            //broadcast our map, this just notifies other members of our existence
+            broadcast(MapMessage.MSG_INIT, true);
+            //transfer state from another map
+            transferState();
+            //state is transferred, we are ready for messaging
+            broadcast(MapMessage.MSG_START, true);
+        } catch (ChannelException x) {
+            log.warn("Unable to send map start message.");
+            throw new RuntimeException("Unable to start replicated map.",x);
+        }
+    }
+    
+    
+    /**
+     * Sends a ping out to all the members in the cluster, not just map members
+     * that this map is alive.
+     * @param timeout long
+     * @throws ChannelException
+     */
+    protected void ping(long timeout) throws ChannelException {
+        //send out a map membership message, only wait for the first reply
+        MapMessage msg = new MapMessage(this.mapContextName, 
+                                        MapMessage.MSG_INIT,
+                                        false, 
+                                        null, 
+                                        null, 
+                                        null, 
+                                        wrap(channel.getLocalMember(false)));
+        if ( channel.getMembers().length > 0 ) {
+            //send a ping, wait for all nodes to reply
+            Response[] resp = rpcChannel.send(channel.getMembers(), 
+                                              msg, rpcChannel.ALL_REPLY, 
+                                              (channelSendOptions),
+                                              (int) accessTimeout);
+            for (int i = 0; i < resp.length; i++) {
+                memberAlive(resp[i].getSource());
+            } //for
+        }
+        //update our map of members, expire some if we didn't receive a ping back
+        synchronized (mapMembers) {
+            Iterator it = mapMembers.entrySet().iterator();
+            long now = System.currentTimeMillis();
+            while ( it.hasNext() ) {
+                Map.Entry entry = (Map.Entry)it.next();
+                long access = ((Long)entry.getValue()).longValue(); 
+                if ( (now - access) > timeout ) memberDisappeared((Member)entry.getKey());
+            }
+        }//synch
+    }
+
+    /**
+     * We have received a member alive notification
+     * @param member Member
+     */
+    protected void memberAlive(Member member) {
+        synchronized (mapMembers) {
+            if (!mapMembers.containsKey(member)) {
+                mapMemberAdded(member);
+            } //end if
+            mapMembers.put(member, new Long(System.currentTimeMillis()));
+        }
+    }
+    
+    /**
+     * Helper method to broadcast a message to all members in a channel
+     * @param msgtype int
+     * @param rpc boolean
+     * @throws ChannelException
+     */
+    protected void broadcast(int msgtype, boolean rpc) throws ChannelException {
+        //send out a map membership message, only wait for the first reply
+        MapMessage msg = new MapMessage(this.mapContextName, msgtype,
+                                        false, null, null, null, wrap(channel.getLocalMember(false)));
+        if ( rpc) {
+            Response[] resp = rpcChannel.send(channel.getMembers(), msg, rpcChannel.FIRST_REPLY, (channelSendOptions),rpcTimeout);
+            for (int i = 0; i < resp.length; i++) {
+                mapMemberAdded(resp[i].getSource());
+                messageReceived(resp[i].getMessage(), resp[i].getSource());
+            }
+        } else {
+            channel.send(channel.getMembers(),msg,channelSendOptions);
+        }
+    }
+
+    public void breakdown() {
+        finalize();
+    }
+
+    public void finalize() {
+        try {broadcast(MapMessage.MSG_STOP,false); }catch ( Exception ignore){}
+        //cleanup
+        if (this.rpcChannel != null) {
+            this.rpcChannel.breakdown();
+        }
+        if (this.channel != null) {
+            this.channel.removeChannelListener(this);
+            this.channel.removeMembershipListener(this);
+        }
+        this.rpcChannel = null;
+        this.channel = null;
+        this.mapMembers.clear();
+        super.clear();
+        this.stateTransferred = false;
+        this.externalLoaders = null;
+    }
+    
+    public int hashCode() {
+        return Arrays.hashCode(this.mapContextName);
+    }
+    
+    public boolean equals(Object o) {
+        if ( o == null ) return false;
+        if ( !(o instanceof AbstractReplicatedMap)) return false;
+        if ( !(o.getClass().equals(this.getClass())) ) return false;
+        AbstractReplicatedMap other = (AbstractReplicatedMap)o;
+        return Arrays.equals(mapContextName,other.mapContextName);
+    }
+
+//------------------------------------------------------------------------------
+//              GROUP COM INTERFACES
+//------------------------------------------------------------------------------
+    public Member[] getMapMembers(HashMap members) {
+        synchronized (members) {
+            Member[] result = new Member[members.size()];
+            members.keySet().toArray(result);
+            return result;
+        }
+    }
+    public Member[] getMapMembers() {
+        return getMapMembers(this.mapMembers);
+    }
+    
+    public Member[] getMapMembersExcl(Member[] exclude) {
+        synchronized (mapMembers) {
+            HashMap list = (HashMap)mapMembers.clone();
+            for (int i=0; i<exclude.length;i++) list.remove(exclude[i]);
+            return getMapMembers(list);
+        }
+    }
+
+
+    /**
+     * Replicates any changes to the object since the last time
+     * The object has to be primary, ie, if the object is a proxy or a backup, it will not be replicated<br>
+     * @param complete - if set to true, the object is replicated to its backup
+     * if set to false, only objects that implement ReplicatedMapEntry and the isDirty() returns true will
+     * be replicated
+     */
+    public void replicate(Object key, boolean complete) {
+        if ( log.isTraceEnabled() )
+            log.trace("Replicate invoked on key:"+key);
+        MapEntry entry = (MapEntry)super.get(key);
+        if ( entry == null ) return;
+        if ( !entry.isSerializable() ) return;
+        if (entry != null && entry.isPrimary() && entry.getBackupNodes()!= null && entry.getBackupNodes().length > 0) {
+            Object value = entry.getValue();
+            //check to see if we need to replicate this object isDirty()||complete
+            boolean repl = complete || ( (value instanceof ReplicatedMapEntry) && ( (ReplicatedMapEntry) value).isDirty());
+            
+            if (!repl) {
+                if ( log.isTraceEnabled() )
+                    log.trace("Not replicating:"+key+", no change made");
+                
+                return;
+            }
+            //check to see if the message is diffable
+            boolean diff = ( (value instanceof ReplicatedMapEntry) && ( (ReplicatedMapEntry) value).isDiffable());
+            MapMessage msg = null;
+            if (diff) {
+                ReplicatedMapEntry rentry = (ReplicatedMapEntry)entry.getValue();
+                try {
+                    rentry.lock();
+                    //construct a diff message
+                    msg = new MapMessage(mapContextName, MapMessage.MSG_BACKUP,
+                                         true, (Serializable) entry.getKey(), null,
+                                         rentry.getDiff(),
+                                         entry.getBackupNodes());
+                } catch (IOException x) {
+                    log.error("Unable to diff object. Will replicate the entire object instead.", x);
+                } finally {
+                    rentry.unlock();
+                }
+                
+            }
+            if (msg == null) {
+                //construct a complete
+                msg = new MapMessage(mapContextName, MapMessage.MSG_BACKUP,
+                                     false, (Serializable) entry.getKey(),
+                                     (Serializable) entry.getValue(),
+                                     null, entry.getBackupNodes());
+
+            }
+            try {
+                if ( channel!=null && entry.getBackupNodes()!= null && entry.getBackupNodes().length > 0 ) {
+                    channel.send(entry.getBackupNodes(), msg, channelSendOptions);
+                }
+            } catch (ChannelException x) {
+                log.error("Unable to replicate data.", x);
+            }
+        } //end if
+
+    }
+
+    /**
+     * This can be invoked by a periodic thread to replicate out any changes.
+     * For maps that don't store objects that implement ReplicatedMapEntry, this
+     * method should be used infrequently to avoid large amounts of data transfer
+     * @param complete boolean
+     */
+    public void replicate(boolean complete) {
+        Iterator i = super.entrySet().iterator();
+        while (i.hasNext()) {
+            Map.Entry e = (Map.Entry) i.next();
+            replicate(e.getKey(), complete);
+        } //while
+
+    }
+
+    public void transferState() {
+        try {
+            Member[] members = getMapMembers();
+            Member backup = members.length > 0 ? (Member) members[0] : null;
+            if (backup != null) {
+                MapMessage msg = new MapMessage(mapContextName, MapMessage.MSG_STATE, false,
+                                                null, null, null, null);
+                Response[] resp = rpcChannel.send(new Member[] {backup}, msg, rpcChannel.FIRST_REPLY, channelSendOptions, rpcTimeout);
+                if (resp.length > 0) {
+                    synchronized (stateMutex) {
+                        msg = (MapMessage) resp[0].getMessage();
+                        msg.deserialize(getExternalLoaders());
+                        ArrayList list = (ArrayList) msg.getValue();
+                        for (int i = 0; i < list.size(); i++) {
+                            messageReceived( (Serializable) list.get(i), resp[0].getSource());
+                        } //for
+                    }
+                } else {
+                    log.warn("Transfer state, 0 replies, probably a timeout.");
+                }
+            }
+        } catch (ChannelException x) {
+            log.error("Unable to transfer LazyReplicatedMap state.", x);
+        } catch (IOException x) {
+            log.error("Unable to transfer LazyReplicatedMap state.", x);
+        } catch (ClassNotFoundException x) {
+            log.error("Unable to transfer LazyReplicatedMap state.", x);
+        }
+        stateTransferred = true;
+    }
+
+    /**
+     * @todo implement state transfer
+     * @param msg Serializable
+     * @return Serializable - null if no reply should be sent
+     */
+    public Serializable replyRequest(Serializable msg, final Member sender) {
+        if (! (msg instanceof MapMessage))return null;
+        MapMessage mapmsg = (MapMessage) msg;
+
+        //map init request
+        if (mapmsg.getMsgType() == mapmsg.MSG_INIT) {
+            mapmsg.setBackUpNodes(wrap(channel.getLocalMember(false)));
+            return mapmsg;
+        }
+        
+        //map start request
+        if (mapmsg.getMsgType() == mapmsg.MSG_START) {
+            mapmsg.setBackUpNodes(wrap(channel.getLocalMember(false)));
+            mapMemberAdded(sender);
+            return mapmsg;
+        }
+
+        //backup request
+        if (mapmsg.getMsgType() == mapmsg.MSG_RETRIEVE_BACKUP) {
+            MapEntry entry = (MapEntry)super.get(mapmsg.getKey());
+            if (entry == null || (!entry.isSerializable()) )return null;
+            mapmsg.setValue( (Serializable) entry.getValue());
+            return mapmsg;
+        }
+
+        //state transfer request
+        if (mapmsg.getMsgType() == mapmsg.MSG_STATE) {
+            synchronized (stateMutex) { //make sure we dont do two things at the same time
+                ArrayList list = new ArrayList();
+                Iterator i = super.entrySet().iterator();
+                while (i.hasNext()) {
+                    Map.Entry e = (Map.Entry) i.next();
+                    MapEntry entry = (MapEntry) e.getValue();
+                    if ( entry.isSerializable() ) {
+                        MapMessage me = new MapMessage(mapContextName, MapMessage.MSG_PROXY,
+                            false, (Serializable) entry.getKey(), null, null, entry.getBackupNodes());
+                        list.add(me);
+                    }
+                }
+                mapmsg.setValue(list);
+                return mapmsg;
+                
+            } //synchronized
+        }
+
+        return null;
+
+    }
+
+    /**
+     * If the reply has already been sent to the requesting thread,
+     * the rpc callback can handle any data that comes in after the fact.
+     * @param msg Serializable
+     * @param sender Member
+     */
+    public void leftOver(Serializable msg, Member sender) {
+        //left over membership messages
+        if (! (msg instanceof MapMessage))return;
+
+        MapMessage mapmsg = (MapMessage) msg;
+        try {
+            mapmsg.deserialize(getExternalLoaders());
+            if (mapmsg.getMsgType() == MapMessage.MSG_START) {
+                mapMemberAdded(mapmsg.getBackupNodes()[0]);
+            } else if (mapmsg.getMsgType() == MapMessage.MSG_INIT) {
+                memberAlive(mapmsg.getBackupNodes()[0]);
+            }
+        } catch (IOException x ) {
+            log.error("Unable to deserialize MapMessage.",x);
+        } catch (ClassNotFoundException x ) {
+            log.error("Unable to deserialize MapMessage.",x);
+        }
+    }
+
+    public void messageReceived(Serializable msg, Member sender) {
+        if (! (msg instanceof MapMessage)) return;
+
+        MapMessage mapmsg = (MapMessage) msg;
+        if ( log.isTraceEnabled() ) {
+            log.trace("Map["+mapname+"] received message:"+mapmsg);
+        }
+        
+        try {
+            mapmsg.deserialize(getExternalLoaders());
+        } catch (IOException x) {
+            log.error("Unable to deserialize MapMessage.", x);
+            return;
+        } catch (ClassNotFoundException x) {
+            log.error("Unable to deserialize MapMessage.", x);
+            return;
+        }
+        if ( log.isTraceEnabled() ) 
+            log.trace("Map message received from:"+sender.getName()+" msg:"+mapmsg);
+        if (mapmsg.getMsgType() == MapMessage.MSG_START) {
+            mapMemberAdded(mapmsg.getBackupNodes()[0]);
+        }
+
+        if (mapmsg.getMsgType() == MapMessage.MSG_STOP) {
+            memberDisappeared(mapmsg.getBackupNodes()[0]);
+        }
+
+        if (mapmsg.getMsgType() == MapMessage.MSG_PROXY) {
+            MapEntry entry = (MapEntry)super.get(mapmsg.getKey());
+            if ( entry==null ) {
+                entry = new MapEntry(mapmsg.getKey(), mapmsg.getValue());
+                entry.setBackup(false);
+                entry.setProxy(true);
+                entry.setBackupNodes(mapmsg.getBackupNodes());
+                super.put(entry.getKey(), entry);
+            } else {
+                entry.setProxy(true);
+                entry.setBackup(false);
+                entry.setBackupNodes(mapmsg.getBackupNodes());
+            }
+        }
+
+        if (mapmsg.getMsgType() == MapMessage.MSG_REMOVE) {
+            super.remove(mapmsg.getKey());
+        }
+
+        if (mapmsg.getMsgType() == MapMessage.MSG_BACKUP) {
+            MapEntry entry = (MapEntry)super.get(mapmsg.getKey());
+            if (entry == null) {
+                entry = new MapEntry(mapmsg.getKey(), mapmsg.getValue());
+                entry.setBackup(true);
+                entry.setProxy(false);
+                entry.setBackupNodes(mapmsg.getBackupNodes());
+                if (mapmsg.getValue()!=null && mapmsg.getValue() instanceof ReplicatedMapEntry ) {
+                    ((ReplicatedMapEntry)mapmsg.getValue()).setOwner(getMapOwner());
+                }
+            } else {
+                entry.setBackup(true);
+                entry.setProxy(false);
+                entry.setBackupNodes(mapmsg.getBackupNodes());
+                if (entry.getValue() instanceof ReplicatedMapEntry) {
+                    ReplicatedMapEntry diff = (ReplicatedMapEntry) entry.getValue();
+                    if (mapmsg.isDiff()) {
+                        try {
+                            diff.lock();
+                            diff.applyDiff(mapmsg.getDiffValue(), 0, mapmsg.getDiffValue().length);
+                        } catch (Exception x) {
+                            log.error("Unable to apply diff to key:" + entry.getKey(), x);
+                        } finally {
+                            diff.unlock();
+                        }
+                    } else {
+                        if ( mapmsg.getValue()!=null ) entry.setValue(mapmsg.getValue());
+                        ((ReplicatedMapEntry)entry.getValue()).setOwner(getMapOwner());
+                    } //end if
+                } else if  (mapmsg.getValue() instanceof ReplicatedMapEntry) {
+                    ReplicatedMapEntry re = (ReplicatedMapEntry)mapmsg.getValue();
+                    re.setOwner(getMapOwner());
+                    entry.setValue(re);
+                } else {
+                    if ( mapmsg.getValue()!=null ) entry.setValue(mapmsg.getValue());
+                } //end if
+            } //end if
+            super.put(entry.getKey(), entry);
+        } //end if
+    }
+
+    public boolean accept(Serializable msg, Member sender) {
+        boolean result = false;
+        if (msg instanceof MapMessage) {
+            if ( log.isTraceEnabled() ) log.trace("Map["+mapname+"] accepting...."+msg);
+            result = Arrays.equals(mapContextName, ( (MapMessage) msg).getMapId());
+            if ( log.isTraceEnabled() ) log.trace("Msg["+mapname+"] accepted["+result+"]...."+msg);
+        }
+        return result;
+    }
+
+    public void mapMemberAdded(Member member) {
+        if ( member.equals(getChannel().getLocalMember(false)) ) return;
+        boolean memberAdded = false;
+        //select a backup node if we don't have one
+        synchronized (mapMembers) {
+            if (!mapMembers.containsKey(member) ) {
+                mapMembers.put(member, new Long(System.currentTimeMillis()));
+                memberAdded = true;
+            }
+        }
+        if ( memberAdded ) {
+            synchronized (stateMutex) {
+                Iterator i = super.entrySet().iterator();
+                while (i.hasNext()) {
+                    Map.Entry e = (Map.Entry) i.next();
+                    MapEntry entry = (MapEntry) e.getValue();
+                    if ( entry == null ) continue;
+                    if (entry.isPrimary() && (entry.getBackupNodes() == null || entry.getBackupNodes().length == 0)) {
+                        try {
+                            Member[] backup = publishEntryInfo(entry.getKey(), entry.getValue());
+                            entry.setBackupNodes(backup);
+                        } catch (ChannelException x) {
+                            log.error("Unable to select backup node.", x);
+                        } //catch
+                    } //end if
+                } //while
+            } //synchronized
+        }//end if
+    }
+    
+    public boolean inSet(Member m, Member[] set) {
+        if ( set == null ) return false;
+        boolean result = false;
+        for (int i=0; i<set.length && (!result); i++ )
+            if ( m.equals(set[i]) ) result = true;
+        return result;
+    }
+
+    public Member[] excludeFromSet(Member[] mbrs, Member[] set) {
+        ArrayList result = new ArrayList();
+        for (int i=0; i<set.length; i++ ) {
+            boolean include = true;
+            for (int j=0; j<mbrs.length; j++ ) 
+                if ( mbrs[j].equals(set[i]) ) include = false;
+            if ( include ) result.add(set[i]);
+        }
+        return (Member[])result.toArray(new Member[result.size()]);
+    }
+
+    public void memberAdded(Member member) {
+        //do nothing
+    }
+
+    public void memberDisappeared(Member member) {
+        boolean removed = false;
+        synchronized (mapMembers) {
+            removed = (mapMembers.remove(member) != null );
+        }
+        Iterator i = super.entrySet().iterator();
+        while (i.hasNext()) {
+            Map.Entry e = (Map.Entry) i.next();
+            MapEntry entry = (MapEntry) e.getValue();
+            if (entry.isPrimary() && inSet(member,entry.getBackupNodes())) {
+                try {
+                    Member[] backup = publishEntryInfo(entry.getKey(), entry.getValue());
+                    entry.setBackupNodes(backup);
+                } catch (ChannelException x) {
+                    log.error("Unable to relocate[" + entry.getKey() + "] to a new backup node", x);
+                }
+            } //end if
+        } //while
+    }
+
+    public int getNextBackupIndex() {
+        int size = mapMembers.size();
+        if (mapMembers.size() == 0)return -1;
+        int node = currentNode++;
+        if (node >= size) {
+            node = 0;
+            currentNode = 0;
+        }
+        return node;
+    }
+    public Member getNextBackupNode() {
+        Member[] members = getMapMembers();
+        int node = getNextBackupIndex();
+        if ( members.length == 0 || node==-1) return null;
+        if ( node >= members.length ) node = 0;
+        return members[node];
+    }
+
+    protected abstract Member[] publishEntryInfo(Object key, Object value) throws ChannelException;
+    
+    public void heartbeat() {
+        try {
+            ping(accessTimeout);
+        }catch ( Exception x ) {
+            log.error("Unable to send AbstractReplicatedMap.ping message",x);
+        }
+    }
+
+//------------------------------------------------------------------------------    
+//              METHODS TO OVERRIDE    
+//------------------------------------------------------------------------------
+  
+    /**
+     * Removes an object from this map, it will also remove it from 
+     * 
+     * @param key Object
+     * @return Object
+     */
+    public Object remove(Object key) {
+        MapEntry entry = (MapEntry)super.remove(key);
+
+        try {
+            if (getMapMembers().length > 0 ) {
+                MapMessage msg = new MapMessage(getMapContextName(), MapMessage.MSG_REMOVE, false, (Serializable) key, null, null, null);
+                getChannel().send(getMapMembers(), msg, getChannelSendOptions());
+            }
+        } catch ( ChannelException x ) {
+            log.error("Unable to replicate out data for a LazyReplicatedMap.remove operation",x);
+        }
+        return entry!=null?entry.getValue():null;
+    }
+    
+    public Object get(Object key) {
+        MapEntry entry = (MapEntry)super.get(key);
+        if (log.isTraceEnabled()) log.trace("Requesting id:"+key+" entry:"+entry);
+        if ( entry == null ) return null;
+        if ( !entry.isPrimary() ) {
+            //if the message is not primary, we need to retrieve the latest value
+            try {
+                Member[] backup = null;
+                MapMessage msg = null;
+                if ( !entry.isBackup() ) {
+                    //make sure we don't retrieve from ourselves
+                    msg = new MapMessage(getMapContextName(), MapMessage.MSG_RETRIEVE_BACKUP, false,
+                                         (Serializable) key, null, null, null);
+                    Response[] resp = getRpcChannel().send(entry.getBackupNodes(),msg, this.getRpcChannel().FIRST_REPLY, Channel.SEND_OPTIONS_DEFAULT, getRpcTimeout());
+                    if (resp == null || resp.length == 0) {
+                        //no responses
+                        log.warn("Unable to retrieve remote object for key:" + key);
+                        return null;
+                    }
+                    msg = (MapMessage) resp[0].getMessage();
+                    msg.deserialize(getExternalLoaders());
+                    backup = entry.getBackupNodes();
+                    if ( entry.getValue() instanceof ReplicatedMapEntry ) {
+                        ReplicatedMapEntry val = (ReplicatedMapEntry)entry.getValue();
+                        val.setOwner(getMapOwner());
+                    }
+                    if ( msg.getValue()!=null ) entry.setValue(msg.getValue());
+                }
+                if (entry.isBackup()) {
+                    //select a new backup node
+                    backup = publishEntryInfo(key, entry.getValue());
+                } else if ( entry.isProxy() ) {
+                    //invalidate the previous primary
+                    msg = new MapMessage(getMapContextName(),MapMessage.MSG_PROXY,false,(Serializable)key,null,null,backup);
+                    Member[] dest = getMapMembersExcl(backup);
+                    if ( dest!=null && dest.length >0) {
+                        getChannel().send(dest, msg, getChannelSendOptions());
+                    }
+                }
+
+                entry.setBackupNodes(backup);
+                entry.setBackup(false);
+                entry.setProxy(false);
+
+
+            } catch (Exception x) {
+                log.error("Unable to replicate out data for a LazyReplicatedMap.get operation", x);
+                return null;
+            }
+        }
+        if (log.isTraceEnabled()) log.trace("Requesting id:"+key+" result:"+entry.getValue());
+        if ( entry.getValue() != null && entry.getValue() instanceof ReplicatedMapEntry ) {
+            ReplicatedMapEntry val = (ReplicatedMapEntry)entry.getValue();
+            //hack, somehow this is not being set above
+            val.setOwner(getMapOwner());
+            
+        }
+        return entry.getValue();
+    }    
+
+    
+    protected void printMap(String header) {
+        try {
+            System.out.println("\nDEBUG MAP:"+header);
+            System.out.println("Map["+ new String(mapContextName, chset) + ", Map Size:" + super.size());
+            Member[] mbrs = getMapMembers();
+            for ( int i=0; i<mbrs.length;i++ ) {
+                System.out.println("Mbr["+(i+1)+"="+mbrs[i].getName());
+            }
+            Iterator i = super.entrySet().iterator();
+            int cnt = 0;
+
+            while (i.hasNext()) {
+                Map.Entry e = (Map.Entry) i.next();
+                System.out.println( (++cnt) + ". " + e.getValue());
+            }
+            System.out.println("EndMap]\n\n");
+        }catch ( Exception ignore) {
+            ignore.printStackTrace();
+        }
+    }
+    
+    /**
+         * Returns true if the key has an entry in the map.
+         * The entry can be a proxy or a backup entry, invoking <code>get(key)</code>
+         * will make this entry primary for the group
+         * @param key Object
+         * @return boolean
+         */
+        public boolean containsKey(Object key) {
+            return super.containsKey(key);
+        }
+    
+    
+        public Object put(Object key, Object value) {
+            MapEntry entry = new MapEntry(key,value);
+            entry.setBackup(false);
+            entry.setProxy(false);
+    
+            Object old = null;
+    
+            //make sure that any old values get removed
+            if ( containsKey(key) ) old = remove(key);
+            try {
+                Member[] backup = publishEntryInfo(key, value);
+                entry.setBackupNodes(backup);
+            } catch (ChannelException x) {
+                log.error("Unable to replicate out data for a LazyReplicatedMap.put operation", x);
+            }
+            super.put(key,entry);
+            return old;
+        }
+    
+    
+        /**
+         * Copies all values from one map to this instance
+         * @param m Map
+         */
+        public void putAll(Map m) {
+            Iterator i = m.entrySet().iterator();
+            while ( i.hasNext() ) {
+                Map.Entry entry = (Map.Entry)i.next();
+                put(entry.getKey(),entry.getValue());
+            }
+        }
+    
+        public void clear() {
+            //only delete active keys
+            Iterator keys = keySet().iterator();
+            while ( keys.hasNext() ) remove(keys.next());
+        }
+    
+        public boolean containsValue(Object value) {
+            if ( value == null ) {
+                return super.containsValue(value);
+            } else {
+                Iterator i = super.entrySet().iterator();
+                while (i.hasNext()) {
+                    Map.Entry e = (Map.Entry) i.next();
+                    MapEntry entry = (MapEntry) e.getValue();
+                    if (entry.isPrimary() && value.equals(entry.getValue())) return true;
+                }//while
+                return false;
+            }//end if
+        }
+    
+        public Object clone() {
+            throw new UnsupportedOperationException("This operation is not valid on a replicated map");
+        }
+    
+        /**
+         * Returns the entire contents of the map
+         * Map.Entry.getValue() will return a LazyReplicatedMap.MapEntry object containing all the information 
+         * about the object.
+         * @return Set
+         */
+        public Set entrySetFull() {
+            return super.entrySet();
+        }
+    
+        public Set keySetFull() {
+            return super.keySet();
+        }
+    
+        public int sizeFull() {
+            return super.size();
+        }
+    
+        public Set entrySet() {
+            LinkedHashSet set = new LinkedHashSet(super.size());
+            Iterator i = super.entrySet().iterator();
+            while ( i.hasNext() ) {
+                Map.Entry e = (Map.Entry)i.next();
+                MapEntry entry = (MapEntry)e.getValue();
+                if ( entry.isPrimary() ) set.add(entry);
+            }
+            return Collections.unmodifiableSet(set);
+        }
+    
+        public Set keySet() {
+            //todo implement
+            //should only return keys where this is active.
+            LinkedHashSet set = new LinkedHashSet(super.size());
+            Iterator i = super.entrySet().iterator();
+            while ( i.hasNext() ) {
+                Map.Entry e = (Map.Entry)i.next();
+                MapEntry entry = (MapEntry)e.getValue();
+                if ( entry.isPrimary() ) set.add(entry.getKey());
+            }
+            return Collections.unmodifiableSet(set);
+        }
+    
+    
+        public int size() {
+            //todo, implement a counter variable instead
+            //only count active members in this node
+            int counter = 0;
+            Iterator it = Collections.unmodifiableSet(super.entrySet()).iterator();
+            while (it.hasNext() ) {
+                Map.Entry e = (Map.Entry) it.next();
+                if ( e != null ) {
+                    MapEntry entry = (MapEntry) e.getValue();
+                    if (entry.isPrimary() && entry.getValue() != null) counter++;
+                }
+            }
+            return counter;
+        }
+    
+        protected boolean removeEldestEntry(Map.Entry eldest) {
+            return false;
+        }
+    
+        public boolean isEmpty() {
+            return size()==0;
+        }
+    
+        public Collection values() {
+            ArrayList values = new ArrayList();
+            Iterator i = super.entrySet().iterator();
+            while ( i.hasNext() ) {
+                Map.Entry e = (Map.Entry)i.next();
+                MapEntry entry = (MapEntry)e.getValue();
+                if ( entry.isPrimary() && entry.getValue()!=null) values.add(entry.getValue());
+            }
+            return Collections.unmodifiableCollection(values);
+        }
+        
+
+//------------------------------------------------------------------------------
+//                Map Entry class
+//------------------------------------------------------------------------------
+    public static class MapEntry implements Map.Entry {
+        private boolean backup;
+        private boolean proxy;
+        private Member[] backupNodes;
+
+        private Object key;
+        private Object value;
+
+        public MapEntry(Object key, Object value) {
+            setKey(key);
+            setValue(value);
+            
+        }
+        
+        public boolean isKeySerializable() {
+            return (key == null) || (key instanceof Serializable);
+        }
+        
+        public boolean isValueSerializable() {
+            return (value==null) || (value instanceof Serializable);
+        }
+        
+        public boolean isSerializable() {
+            return isKeySerializable() && isValueSerializable();
+        }
+        
+        public boolean isBackup() {
+            return backup;
+        }
+
+        public void setBackup(boolean backup) {
+            this.backup = backup;
+        }
+
+        public boolean isProxy() {
+            return proxy;
+        }
+
+        public boolean isPrimary() {
+            return ( (!proxy) && (!backup));
+        }
+
+        public void setProxy(boolean proxy) {
+            this.proxy = proxy;
+        }
+
+        public boolean isDiffable() {
+            return (value instanceof ReplicatedMapEntry) &&
+                   ((ReplicatedMapEntry)value).isDiffable();
+        }
+
+        public void setBackupNodes(Member[] nodes) {
+            this.backupNodes = nodes;
+        }
+
+        public Member[] getBackupNodes() {
+            return backupNodes;
+        }
+
+        public Object getValue() {
+            return value;
+        }
+
+        public Object setValue(Object value) {
+            Object old = this.value;
+            this.value = (Serializable) value;
+            return old;
+        }
+
+        public Object getKey() {
+            return key;
+        }
+        
+        public Object setKey(Object key) {
+            Object old = this.key;
+            this.key = (Serializable)key;
+            return old;
+        }
+
+        public int hashCode() {
+            return key.hashCode();
+        }
+
+        public boolean equals(Object o) {
+            return key.equals(o);
+        }
+
+        /**
+         * apply a diff, or an entire object
+         * @param data byte[]
+         * @param offset int
+         * @param length int
+         * @param diff boolean
+         * @throws IOException
+         * @throws ClassNotFoundException
+         */
+        public void apply(byte[] data, int offset, int length, boolean diff) throws IOException, ClassNotFoundException {
+            if (isDiffable() && diff) {
+                ReplicatedMapEntry rentry = (ReplicatedMapEntry) value;
+                try {
+                    rentry.lock();
+                    rentry.applyDiff(data, offset, length);
+                } finally {
+                    rentry.unlock();
+                }
+            } else if (length == 0) {
+                value = null;
+                proxy = true;
+            } else {
+                value = XByteBuffer.deserialize(data, offset, length);
+            }
+        }
+        
+        public String toString() {
+            StringBuffer buf = new StringBuffer("MapEntry[key:");
+            buf.append(getKey()).append("; ");
+            buf.append("value:").append(getValue()).append("; ");
+            buf.append("primary:").append(isPrimary()).append("; ");
+            buf.append("backup:").append(isBackup()).append("; ");
+            buf.append("proxy:").append(isProxy()).append(";]");
+            return buf.toString();
+        }
+
+    }
+
+//------------------------------------------------------------------------------
+//                map message to send to and from other maps
+//------------------------------------------------------------------------------
+
+    public static class MapMessage implements Serializable {
+        public static final int MSG_BACKUP = 1;
+        public static final int MSG_RETRIEVE_BACKUP = 2;
+        public static final int MSG_PROXY = 3;
+        public static final int MSG_REMOVE = 4;
+        public static final int MSG_STATE = 5;
+        public static final int MSG_START = 6;
+        public static final int MSG_STOP = 7;
+        public static final int MSG_INIT = 8;
+
+        private byte[] mapId;
+        private int msgtype;
+        private boolean diff;
+        private transient Serializable key;
+        private transient Serializable value;
+        private byte[] valuedata;
+        private byte[] keydata;
+        private byte[] diffvalue;
+        private Member[] nodes;
+        
+        public String toString() {
+            StringBuffer buf = new StringBuffer("MapMessage[context=");
+            buf.append(new String(mapId));
+            buf.append("; type=");
+            buf.append(getTypeDesc());
+            buf.append("; key=");
+            buf.append(key);
+            buf.append("; value=");
+            buf.append(value);
+            return buf.toString();
+        }
+        
+        public String getTypeDesc() {
+            switch (msgtype) {
+                case MSG_BACKUP: return "MSG_BACKUP";
+                case MSG_RETRIEVE_BACKUP: return "MSG_RETRIEVE_BACKUP";
+                case MSG_PROXY: return "MSG_PROXY";
+                case MSG_REMOVE: return "MSG_REMOVE";
+                case MSG_STATE: return "MSG_STATE";
+                case MSG_START: return "MSG_START";
+                case MSG_STOP: return "MSG_STOP";
+                case MSG_INIT: return "MSG_INIT";
+                default : return "UNKNOWN";
+            }
+        }
+
+        public MapMessage() {}
+
+        public MapMessage(byte[] mapId,int msgtype, boolean diff,
+                          Serializable key, Serializable value,
+                          byte[] diffvalue, Member[] nodes)  {
+            this.mapId = mapId;
+            this.msgtype = msgtype;
+            this.diff = diff;
+            this.key = key;
+            this.value = value;
+            this.diffvalue = diffvalue;
+            this.nodes = nodes;
+            setValue(value);
+            setKey(key);
+        }
+        
+        public void deserialize(ClassLoader[] cls) throws IOException, ClassNotFoundException {
+            key(cls);
+            value(cls);
+        }
+
+        public int getMsgType() {
+            return msgtype;
+        }
+
+        public boolean isDiff() {
+            return diff;
+        }
+
+        public Serializable getKey() {
+            try {
+                return key(null);
+            } catch ( Exception x ) {
+                log.error("Deserialization error of the MapMessage.key",x);
+                return null;
+            }
+        }
+
+        public Serializable key(ClassLoader[] cls) throws IOException, ClassNotFoundException {
+            if ( key!=null ) return key;
+            if ( keydata == null || keydata.length == 0 ) return null;
+            key = XByteBuffer.deserialize(keydata,0,keydata.length,cls);
+            keydata = null;
+            return key;
+        }
+        
+        public byte[] getKeyData() {
+            return keydata;
+        }
+        
+        public Serializable getValue() {
+            try {
+                return value(null);
+            } catch ( Exception x ) {
+                log.error("Deserialization error of the MapMessage.value",x);
+                return null;
+            }
+        }
+
+        public Serializable value(ClassLoader[] cls) throws IOException, ClassNotFoundException  {
+            if ( value!=null ) return value;
+            if ( valuedata == null || valuedata.length == 0 ) return null;
+            value = XByteBuffer.deserialize(valuedata,0,valuedata.length,cls);
+            valuedata = null;;
+            return value;
+        }
+        
+        public byte[] getValueData() {
+            return valuedata;
+        }
+
+        public byte[] getDiffValue() {
+            return diffvalue;
+        }
+
+        public Member[] getBackupNodes() {
+            return nodes;
+        }
+
+        private void setBackUpNodes(Member[] nodes) {
+            this.nodes = nodes;
+        }
+
+        public byte[] getMapId() {
+            return mapId;
+        }
+
+        public void setValue(Serializable value) {
+            try {
+                if ( value != null ) valuedata = XByteBuffer.serialize(value);
+                this.value = value;
+            }catch ( IOException x ) {
+                throw new RuntimeException(x);
+            }
+        }
+        
+        public void setKey(Serializable key) {
+            try {
+                if (key != null) keydata = XByteBuffer.serialize(key);
+                this.key = key;
+            } catch (IOException x) {
+                throw new RuntimeException(x);
+            }
+        }
+        
+        protected Member[] readMembers(ObjectInput in) throws IOException, ClassNotFoundException {
+            int nodecount = in.readInt();
+            Member[] members = new Member[nodecount];
+            for ( int i=0; i<members.length; i++ ) {
+                byte[] d = new byte[in.readInt()];
+                in.read(d);
+                if (d.length > 0) members[i] = MemberImpl.getMember(d);
+            }
+            return members;
+        }
+        
+        protected void writeMembers(ObjectOutput out,Member[] members) throws IOException {
+            if ( members == null ) members = new Member[0];
+            out.writeInt(members.length);
+            for (int i=0; i<members.length; i++ ) {
+                if ( members[i] != null ) {
+                    byte[] d = members[i] != null ? ( (MemberImpl)members[i]).getData(false) : new byte[0];
+                    out.writeInt(d.length);
+                    out.write(d);
+                }
+            }
+        }
+        
+        
+        /**
+         * shallow clone
+         * @return Object
+         */
+        public Object clone() {
+            MapMessage msg = new MapMessage(this.mapId, this.msgtype, this.diff, this.key, this.value, this.diffvalue, this.nodes);
+            msg.keydata = this.keydata;
+            msg.valuedata = this.valuedata;
+            return msg;
+        }
+    } //MapMessage
+
+
+    public Channel getChannel() {
+        return channel;
+    }
+
+    public byte[] getMapContextName() {
+        return mapContextName;
+    }
+
+    public RpcChannel getRpcChannel() {
+        return rpcChannel;
+    }
+
+    public long getRpcTimeout() {
+        return rpcTimeout;
+    }
+
+    public Object getStateMutex() {
+        return stateMutex;
+    }
+
+    public boolean isStateTransferred() {
+        return stateTransferred;
+    }
+
+    public Object getMapOwner() {
+        return mapOwner;
+    }
+
+    public ClassLoader[] getExternalLoaders() {
+        return externalLoaders;
+    }
+
+    public int getChannelSendOptions() {
+        return channelSendOptions;
+    }
+
+    public long getAccessTimeout() {
+        return accessTimeout;
+    }
+
+    public void setMapOwner(Object mapOwner) {
+        this.mapOwner = mapOwner;
+    }
+
+    public void setExternalLoaders(ClassLoader[] externalLoaders) {
+        this.externalLoaders = externalLoaders;
+    }
+
+    public void setChannelSendOptions(int channelSendOptions) {
+        this.channelSendOptions = channelSendOptions;
+    }
+
+    public void setAccessTimeout(long accessTimeout) {
+        this.accessTimeout = accessTimeout;
+    }
+
 }
\ No newline at end of file

==================================================
ReplicatedMap.java
index 64dbfeb9eb..55556a7e53 100644
--- a/java/org/apache/catalina/tribes/tipis/LazyReplicatedMap.java
+++ b/java/org/apache/catalina/tribes/tipis/LazyReplicatedMap.java
@@ -1,185 +1,185 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.tipis;
-
-import java.io.Serializable;
-
-import org.apache.catalina.tribes.Channel;
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelListener;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.MembershipListener;
-import org.apache.catalina.tribes.group.RpcCallback;
-import org.apache.catalina.tribes.util.Arrays;
-import org.apache.catalina.tribes.UniqueId;
-
-/**
- * A smart implementation of a stateful replicated map. uses primary/secondary backup strategy. 
- * One node is always the primary and one node is always the backup.
- * This map is synchronized across a cluster, and only has one backup member.<br/>
- * A perfect usage for this map would be a session map for a session manager in a clustered environment.<br/>
- * The only way to modify this list is to use the <code>put, putAll, remove</code> methods.
- * entrySet, entrySetFull, keySet, keySetFull, returns all non modifiable sets.<br><br>
- * If objects (values) in the map change without invoking <code>put()</code> or <code>remove()</code>
- * the data can be distributed using two different methods:<br>
- * <code>replicate(boolean)</code> and <code>replicate(Object, boolean)</code><br>
- * These two methods are very important two understand. The map can work with two set of value objects:<br>
- * 1. Serializable - the entire object gets serialized each time it is replicated<br>
- * 2. ReplicatedMapEntry - this interface allows for a isDirty() flag and to replicate diffs if desired.<br>
- * Implementing the <code>ReplicatedMapEntry</code> interface allows you to decide what objects 
- * get replicated and how much data gets replicated each time.<br>
- * If you implement a smart AOP mechanism to detect changes in underlying objects, you can replicate
- * only those changes by implementing the ReplicatedMapEntry interface, and return true when isDiffable()
- * is invoked.<br><br>
- * 
- * This map implementation doesn't have a background thread running to replicate changes.
- * If you do have changes without invoking put/remove then you need to invoke one of the following methods:
- * <ul>
- * <li><code>replicate(Object,boolean)</code> - replicates only the object that belongs to the key</li>
- * <li><code>replicate(boolean)</code> - Scans the entire map for changes and replicates data</li>
- *  </ul>
- * the <code>boolean</code> value in the <code>replicate</code> method used to decide 
- * whether to only replicate objects that implement the <code>ReplicatedMapEntry</code> interface
- * or to replicate all objects. If an object doesn't implement the <code>ReplicatedMapEntry</code> interface
- * each time the object gets replicated the entire object gets serialized, hence a call to <code>replicate(true)</code>
- * will replicate all objects in this map that are using this node as primary.
- * 
- * <br><br><b>REMBER TO CALL <code>breakdown()</code> or <code>finalize()</code> when you are done with the map to 
- * avoid memory leaks.<br><br>
- * @todo implement periodic sync/transfer thread
- * @author Filip Hanik
- * @version 1.0
- */
-public class LazyReplicatedMap extends AbstractReplicatedMap 
-    implements RpcCallback, ChannelListener, MembershipListener {
-    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(LazyReplicatedMap.class);
-    
-    
-    
-//------------------------------------------------------------------------------    
-//              CONSTRUCTORS / DESTRUCTORS
-//------------------------------------------------------------------------------   
-    /**
-         * Creates a new map
-         * @param channel The channel to use for communication
-         * @param timeout long - timeout for RPC messags
-         * @param mapContextName String - unique name for this map, to allow multiple maps per channel
-         * @param initialCapacity int - the size of this map, see HashMap
-         * @param loadFactor float - load factor, see HashMap
-         */
-        public LazyReplicatedMap(Object owner, Channel channel, long timeout, String mapContextName, int initialCapacity, float loadFactor, ClassLoader[] cls) {
-            super(owner,channel,timeout,mapContextName,initialCapacity,loadFactor, Channel.SEND_OPTIONS_DEFAULT,cls);
-        }
-
-        /**
-         * Creates a new map
-         * @param channel The channel to use for communication
-         * @param timeout long - timeout for RPC messags
-         * @param mapContextName String - unique name for this map, to allow multiple maps per channel
-         * @param initialCapacity int - the size of this map, see HashMap
-         */
-        public LazyReplicatedMap(Object owner, Channel channel, long timeout, String mapContextName, int initialCapacity, ClassLoader[] cls) {
-            super(owner, channel,timeout,mapContextName,initialCapacity, LazyReplicatedMap.DEFAULT_LOAD_FACTOR, Channel.SEND_OPTIONS_DEFAULT, cls);
-        }
-
-        /**
-         * Creates a new map
-         * @param channel The channel to use for communication
-         * @param timeout long - timeout for RPC messags
-         * @param mapContextName String - unique name for this map, to allow multiple maps per channel
-         */
-        public LazyReplicatedMap(Object owner, Channel channel, long timeout, String mapContextName, ClassLoader[] cls) {
-            super(owner, channel,timeout,mapContextName, LazyReplicatedMap.DEFAULT_INITIAL_CAPACITY,LazyReplicatedMap.DEFAULT_LOAD_FACTOR,Channel.SEND_OPTIONS_DEFAULT, cls);
-        }
-
-
-
-
-    
-//------------------------------------------------------------------------------    
-//              METHODS TO OVERRIDE    
-//------------------------------------------------------------------------------
-    /**
-     * publish info about a map pair (key/value) to other nodes in the cluster
-     * @param key Object
-     * @param value Object
-     * @return Member - the backup node
-     * @throws ChannelException
-     */
-    protected Member[] publishEntryInfo(Object key, Object value) throws ChannelException {
-        if  (! (key instanceof Serializable && value instanceof Serializable)  ) return new Member[0];
-        Member[] members = getMapMembers();
-        int firstIdx = getNextBackupIndex();
-        int nextIdx = firstIdx;
-        Member[] backup = new Member[0];
-        
-        //there are no backups
-        if ( members.length == 0 || firstIdx == -1 ) return backup;
-        
-        boolean success = false;
-        do {
-            //select a backup node
-            Member next = members[firstIdx];
-            
-            //increment for the next round of back up selection
-            nextIdx = firstIdx + 1;
-            if ( nextIdx >= members.length ) nextIdx = 0;
-            
-            if (next == null) {
-                continue;
-            }
-            MapMessage msg = null;
-            try {
-                backup = wrap(next);
-                //publish the backup data to one node
-                msg = new MapMessage(getMapContextName(), MapMessage.MSG_BACKUP, false,
-                                     (Serializable) key, (Serializable) value, null, backup);
-                if ( log.isTraceEnabled() ) 
-                    log.trace("Publishing backup data:"+msg+" to: "+next.getName());
-                UniqueId id = getChannel().send(backup, msg, getChannelSendOptions());
-                if ( log.isTraceEnabled() )
-                    log.trace("Data published:"+msg+" msg Id:"+id);
-                //we published out to a backup, mark the test success
-                success = true;
-            }catch ( ChannelException x ) {
-                log.error("Unable to replicate backup key:"+key+" to backup:"+next+". Reason:"+x.getMessage(),x);
-            }
-            try {
-                //publish the data out to all nodes
-                Member[] proxies = excludeFromSet(backup, getMapMembers());
-                if (success && proxies.length > 0 ) {
-                    msg = new MapMessage(getMapContextName(), MapMessage.MSG_PROXY, false,
-                                         (Serializable) key, null, null, backup);
-                    if ( log.isTraceEnabled() ) 
-                    log.trace("Publishing proxy data:"+msg+" to: "+Arrays.toNameString(proxies));
-                    getChannel().send(proxies, msg, getChannelSendOptions());
-                }
-            }catch  ( ChannelException x ) {
-                //log the error, but proceed, this should only happen if a node went down,
-                //and if the node went down, then it can't receive the message, the others
-                //should still get it.
-                log.error("Unable to replicate proxy key:"+key+" to backup:"+next+". Reason:"+x.getMessage(),x);
-            }
-        } while ( !success && (firstIdx!=nextIdx));
-        return backup;
-    }
-    
-    
-
-
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.tipis;
+
+import java.io.Serializable;
+
+import org.apache.catalina.tribes.Channel;
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelListener;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.MembershipListener;
+import org.apache.catalina.tribes.group.RpcCallback;
+import org.apache.catalina.tribes.util.Arrays;
+import org.apache.catalina.tribes.UniqueId;
+
+/**
+ * A smart implementation of a stateful replicated map. uses primary/secondary backup strategy. 
+ * One node is always the primary and one node is always the backup.
+ * This map is synchronized across a cluster, and only has one backup member.<br/>
+ * A perfect usage for this map would be a session map for a session manager in a clustered environment.<br/>
+ * The only way to modify this list is to use the <code>put, putAll, remove</code> methods.
+ * entrySet, entrySetFull, keySet, keySetFull, returns all non modifiable sets.<br><br>
+ * If objects (values) in the map change without invoking <code>put()</code> or <code>remove()</code>
+ * the data can be distributed using two different methods:<br>
+ * <code>replicate(boolean)</code> and <code>replicate(Object, boolean)</code><br>
+ * These two methods are very important two understand. The map can work with two set of value objects:<br>
+ * 1. Serializable - the entire object gets serialized each time it is replicated<br>
+ * 2. ReplicatedMapEntry - this interface allows for a isDirty() flag and to replicate diffs if desired.<br>
+ * Implementing the <code>ReplicatedMapEntry</code> interface allows you to decide what objects 
+ * get replicated and how much data gets replicated each time.<br>
+ * If you implement a smart AOP mechanism to detect changes in underlying objects, you can replicate
+ * only those changes by implementing the ReplicatedMapEntry interface, and return true when isDiffable()
+ * is invoked.<br><br>
+ * 
+ * This map implementation doesn't have a background thread running to replicate changes.
+ * If you do have changes without invoking put/remove then you need to invoke one of the following methods:
+ * <ul>
+ * <li><code>replicate(Object,boolean)</code> - replicates only the object that belongs to the key</li>
+ * <li><code>replicate(boolean)</code> - Scans the entire map for changes and replicates data</li>
+ *  </ul>
+ * the <code>boolean</code> value in the <code>replicate</code> method used to decide 
+ * whether to only replicate objects that implement the <code>ReplicatedMapEntry</code> interface
+ * or to replicate all objects. If an object doesn't implement the <code>ReplicatedMapEntry</code> interface
+ * each time the object gets replicated the entire object gets serialized, hence a call to <code>replicate(true)</code>
+ * will replicate all objects in this map that are using this node as primary.
+ * 
+ * <br><br><b>REMBER TO CALL <code>breakdown()</code> or <code>finalize()</code> when you are done with the map to 
+ * avoid memory leaks.<br><br>
+ * @todo implement periodic sync/transfer thread
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class LazyReplicatedMap extends AbstractReplicatedMap 
+    implements RpcCallback, ChannelListener, MembershipListener {
+    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(LazyReplicatedMap.class);
+    
+    
+    
+//------------------------------------------------------------------------------    
+//              CONSTRUCTORS / DESTRUCTORS
+//------------------------------------------------------------------------------   
+    /**
+         * Creates a new map
+         * @param channel The channel to use for communication
+         * @param timeout long - timeout for RPC messags
+         * @param mapContextName String - unique name for this map, to allow multiple maps per channel
+         * @param initialCapacity int - the size of this map, see HashMap
+         * @param loadFactor float - load factor, see HashMap
+         */
+        public LazyReplicatedMap(Object owner, Channel channel, long timeout, String mapContextName, int initialCapacity, float loadFactor, ClassLoader[] cls) {
+            super(owner,channel,timeout,mapContextName,initialCapacity,loadFactor, Channel.SEND_OPTIONS_DEFAULT,cls);
+        }
+
+        /**
+         * Creates a new map
+         * @param channel The channel to use for communication
+         * @param timeout long - timeout for RPC messags
+         * @param mapContextName String - unique name for this map, to allow multiple maps per channel
+         * @param initialCapacity int - the size of this map, see HashMap
+         */
+        public LazyReplicatedMap(Object owner, Channel channel, long timeout, String mapContextName, int initialCapacity, ClassLoader[] cls) {
+            super(owner, channel,timeout,mapContextName,initialCapacity, LazyReplicatedMap.DEFAULT_LOAD_FACTOR, Channel.SEND_OPTIONS_DEFAULT, cls);
+        }
+
+        /**
+         * Creates a new map
+         * @param channel The channel to use for communication
+         * @param timeout long - timeout for RPC messags
+         * @param mapContextName String - unique name for this map, to allow multiple maps per channel
+         */
+        public LazyReplicatedMap(Object owner, Channel channel, long timeout, String mapContextName, ClassLoader[] cls) {
+            super(owner, channel,timeout,mapContextName, LazyReplicatedMap.DEFAULT_INITIAL_CAPACITY,LazyReplicatedMap.DEFAULT_LOAD_FACTOR,Channel.SEND_OPTIONS_DEFAULT, cls);
+        }
+
+
+
+
+    
+//------------------------------------------------------------------------------    
+//              METHODS TO OVERRIDE    
+//------------------------------------------------------------------------------
+    /**
+     * publish info about a map pair (key/value) to other nodes in the cluster
+     * @param key Object
+     * @param value Object
+     * @return Member - the backup node
+     * @throws ChannelException
+     */
+    protected Member[] publishEntryInfo(Object key, Object value) throws ChannelException {
+        if  (! (key instanceof Serializable && value instanceof Serializable)  ) return new Member[0];
+        Member[] members = getMapMembers();
+        int firstIdx = getNextBackupIndex();
+        int nextIdx = firstIdx;
+        Member[] backup = new Member[0];
+        
+        //there are no backups
+        if ( members.length == 0 || firstIdx == -1 ) return backup;
+        
+        boolean success = false;
+        do {
+            //select a backup node
+            Member next = members[firstIdx];
+            
+            //increment for the next round of back up selection
+            nextIdx = firstIdx + 1;
+            if ( nextIdx >= members.length ) nextIdx = 0;
+            
+            if (next == null) {
+                continue;
+            }
+            MapMessage msg = null;
+            try {
+                backup = wrap(next);
+                //publish the backup data to one node
+                msg = new MapMessage(getMapContextName(), MapMessage.MSG_BACKUP, false,
+                                     (Serializable) key, (Serializable) value, null, backup);
+                if ( log.isTraceEnabled() ) 
+                    log.trace("Publishing backup data:"+msg+" to: "+next.getName());
+                UniqueId id = getChannel().send(backup, msg, getChannelSendOptions());
+                if ( log.isTraceEnabled() )
+                    log.trace("Data published:"+msg+" msg Id:"+id);
+                //we published out to a backup, mark the test success
+                success = true;
+            }catch ( ChannelException x ) {
+                log.error("Unable to replicate backup key:"+key+" to backup:"+next+". Reason:"+x.getMessage(),x);
+            }
+            try {
+                //publish the data out to all nodes
+                Member[] proxies = excludeFromSet(backup, getMapMembers());
+                if (success && proxies.length > 0 ) {
+                    msg = new MapMessage(getMapContextName(), MapMessage.MSG_PROXY, false,
+                                         (Serializable) key, null, null, backup);
+                    if ( log.isTraceEnabled() ) 
+                    log.trace("Publishing proxy data:"+msg+" to: "+Arrays.toNameString(proxies));
+                    getChannel().send(proxies, msg, getChannelSendOptions());
+                }
+            }catch  ( ChannelException x ) {
+                //log the error, but proceed, this should only happen if a node went down,
+                //and if the node went down, then it can't receive the message, the others
+                //should still get it.
+                log.error("Unable to replicate proxy key:"+key+" to backup:"+next+". Reason:"+x.getMessage(),x);
+            }
+        } while ( !success && (firstIdx!=nextIdx));
+        return backup;
+    }
+    
+    
+
+
+
 }
\ No newline at end of file

==================================================
ReplicatedMapEntry.java
index 7879d81470..49fc8ab2d2 100644
--- a/java/org/apache/catalina/tribes/tipis/ReplicatedMap.java
+++ b/java/org/apache/catalina/tribes/tipis/ReplicatedMap.java
@@ -1,118 +1,118 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.tipis;
-
-import java.io.Serializable;
-
-import org.apache.catalina.tribes.Channel;
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelListener;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.MembershipListener;
-import org.apache.catalina.tribes.group.RpcCallback;
-
-/**
- * All-to-all replication for a hash map implementation. Each node in the cluster will carry an identical 
- * copy of the map.<br><br>
- * This map implementation doesn't have a background thread running to replicate changes.
- * If you do have changes without invoking put/remove then you need to invoke one of the following methods:
- * <ul>
- * <li><code>replicate(Object,boolean)</code> - replicates only the object that belongs to the key</li>
- * <li><code>replicate(boolean)</code> - Scans the entire map for changes and replicates data</li>
- *  </ul>
- * the <code>boolean</code> value in the <code>replicate</code> method used to decide
- * whether to only replicate objects that implement the <code>ReplicatedMapEntry</code> interface
- * or to replicate all objects. If an object doesn't implement the <code>ReplicatedMapEntry</code> interface
- * each time the object gets replicated the entire object gets serialized, hence a call to <code>replicate(true)</code>
- * will replicate all objects in this map that are using this node as primary.
- *
- * <br><br><b>REMBER TO CALL <code>breakdown()</code> or <code>finalize()</code> when you are done with the map to
- * avoid memory leaks.<br><br>
- * @todo implement periodic sync/transfer thread
- * @author Filip Hanik
- * @version 1.0
- * 
- * @todo memberDisappeared, should do nothing except change map membership
- *       by default it relocates the primary objects
- */
-public class ReplicatedMap extends AbstractReplicatedMap implements RpcCallback, ChannelListener, MembershipListener {
-
-    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(ReplicatedMap.class);
-
-//------------------------------------------------------------------------------
-//              CONSTRUCTORS / DESTRUCTORS
-//------------------------------------------------------------------------------
-    /**
-     * Creates a new map
-     * @param channel The channel to use for communication
-     * @param timeout long - timeout for RPC messags
-     * @param mapContextName String - unique name for this map, to allow multiple maps per channel
-     * @param initialCapacity int - the size of this map, see HashMap
-     * @param loadFactor float - load factor, see HashMap
-     */
-    public ReplicatedMap(Object owner, Channel channel, long timeout, String mapContextName, int initialCapacity,float loadFactor, ClassLoader[] cls) {
-        super(owner,channel, timeout, mapContextName, initialCapacity, loadFactor, Channel.SEND_OPTIONS_DEFAULT, cls);
-    }
-
-    /**
-     * Creates a new map
-     * @param channel The channel to use for communication
-     * @param timeout long - timeout for RPC messags
-     * @param mapContextName String - unique name for this map, to allow multiple maps per channel
-     * @param initialCapacity int - the size of this map, see HashMap
-     */
-    public ReplicatedMap(Object owner, Channel channel, long timeout, String mapContextName, int initialCapacity, ClassLoader[] cls) {
-        super(owner,channel, timeout, mapContextName, initialCapacity, AbstractReplicatedMap.DEFAULT_LOAD_FACTOR,Channel.SEND_OPTIONS_DEFAULT, cls);
-    }
-
-    /**
-     * Creates a new map
-     * @param channel The channel to use for communication
-     * @param timeout long - timeout for RPC messags
-     * @param mapContextName String - unique name for this map, to allow multiple maps per channel
-     */
-    public ReplicatedMap(Object owner, Channel channel, long timeout, String mapContextName, ClassLoader[] cls) {
-        super(owner, channel, timeout, mapContextName,AbstractReplicatedMap.DEFAULT_INITIAL_CAPACITY, AbstractReplicatedMap.DEFAULT_LOAD_FACTOR, Channel.SEND_OPTIONS_DEFAULT, cls);
-    }
-
-//------------------------------------------------------------------------------
-//              METHODS TO OVERRIDE
-//------------------------------------------------------------------------------
-    /**
-     * publish info about a map pair (key/value) to other nodes in the cluster
-     * @param key Object
-     * @param value Object
-     * @return Member - the backup node
-     * @throws ChannelException
-     */
-    protected Member[] publishEntryInfo(Object key, Object value) throws ChannelException {
-        if  (! (key instanceof Serializable && value instanceof Serializable)  ) return new Member[0];
-        //select a backup node
-        Member[] backup = getMapMembers();
-
-        if (backup == null || backup.length == 0) return null;
-
-        //publish the data out to all nodes
-        MapMessage msg = new MapMessage(getMapContextName(), MapMessage.MSG_BACKUP, false,
-                                        (Serializable) key, null, null, backup);
-
-        getChannel().send(getMapMembers(), msg, getChannelSendOptions());
-
-        return backup;
-    }
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.tipis;
+
+import java.io.Serializable;
+
+import org.apache.catalina.tribes.Channel;
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelListener;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.MembershipListener;
+import org.apache.catalina.tribes.group.RpcCallback;
+
+/**
+ * All-to-all replication for a hash map implementation. Each node in the cluster will carry an identical 
+ * copy of the map.<br><br>
+ * This map implementation doesn't have a background thread running to replicate changes.
+ * If you do have changes without invoking put/remove then you need to invoke one of the following methods:
+ * <ul>
+ * <li><code>replicate(Object,boolean)</code> - replicates only the object that belongs to the key</li>
+ * <li><code>replicate(boolean)</code> - Scans the entire map for changes and replicates data</li>
+ *  </ul>
+ * the <code>boolean</code> value in the <code>replicate</code> method used to decide
+ * whether to only replicate objects that implement the <code>ReplicatedMapEntry</code> interface
+ * or to replicate all objects. If an object doesn't implement the <code>ReplicatedMapEntry</code> interface
+ * each time the object gets replicated the entire object gets serialized, hence a call to <code>replicate(true)</code>
+ * will replicate all objects in this map that are using this node as primary.
+ *
+ * <br><br><b>REMBER TO CALL <code>breakdown()</code> or <code>finalize()</code> when you are done with the map to
+ * avoid memory leaks.<br><br>
+ * @todo implement periodic sync/transfer thread
+ * @author Filip Hanik
+ * @version 1.0
+ * 
+ * @todo memberDisappeared, should do nothing except change map membership
+ *       by default it relocates the primary objects
+ */
+public class ReplicatedMap extends AbstractReplicatedMap implements RpcCallback, ChannelListener, MembershipListener {
+
+    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(ReplicatedMap.class);
+
+//------------------------------------------------------------------------------
+//              CONSTRUCTORS / DESTRUCTORS
+//------------------------------------------------------------------------------
+    /**
+     * Creates a new map
+     * @param channel The channel to use for communication
+     * @param timeout long - timeout for RPC messags
+     * @param mapContextName String - unique name for this map, to allow multiple maps per channel
+     * @param initialCapacity int - the size of this map, see HashMap
+     * @param loadFactor float - load factor, see HashMap
+     */
+    public ReplicatedMap(Object owner, Channel channel, long timeout, String mapContextName, int initialCapacity,float loadFactor, ClassLoader[] cls) {
+        super(owner,channel, timeout, mapContextName, initialCapacity, loadFactor, Channel.SEND_OPTIONS_DEFAULT, cls);
+    }
+
+    /**
+     * Creates a new map
+     * @param channel The channel to use for communication
+     * @param timeout long - timeout for RPC messags
+     * @param mapContextName String - unique name for this map, to allow multiple maps per channel
+     * @param initialCapacity int - the size of this map, see HashMap
+     */
+    public ReplicatedMap(Object owner, Channel channel, long timeout, String mapContextName, int initialCapacity, ClassLoader[] cls) {
+        super(owner,channel, timeout, mapContextName, initialCapacity, AbstractReplicatedMap.DEFAULT_LOAD_FACTOR,Channel.SEND_OPTIONS_DEFAULT, cls);
+    }
+
+    /**
+     * Creates a new map
+     * @param channel The channel to use for communication
+     * @param timeout long - timeout for RPC messags
+     * @param mapContextName String - unique name for this map, to allow multiple maps per channel
+     */
+    public ReplicatedMap(Object owner, Channel channel, long timeout, String mapContextName, ClassLoader[] cls) {
+        super(owner, channel, timeout, mapContextName,AbstractReplicatedMap.DEFAULT_INITIAL_CAPACITY, AbstractReplicatedMap.DEFAULT_LOAD_FACTOR, Channel.SEND_OPTIONS_DEFAULT, cls);
+    }
+
+//------------------------------------------------------------------------------
+//              METHODS TO OVERRIDE
+//------------------------------------------------------------------------------
+    /**
+     * publish info about a map pair (key/value) to other nodes in the cluster
+     * @param key Object
+     * @param value Object
+     * @return Member - the backup node
+     * @throws ChannelException
+     */
+    protected Member[] publishEntryInfo(Object key, Object value) throws ChannelException {
+        if  (! (key instanceof Serializable && value instanceof Serializable)  ) return new Member[0];
+        //select a backup node
+        Member[] backup = getMapMembers();
+
+        if (backup == null || backup.length == 0) return null;
+
+        //publish the data out to all nodes
+        MapMessage msg = new MapMessage(getMapContextName(), MapMessage.MSG_BACKUP, false,
+                                        (Serializable) key, null, null, backup);
+
+        getChannel().send(getMapMembers(), msg, getChannelSendOptions());
+
+        return backup;
+    }
+
 }
\ No newline at end of file

==================================================
Streamable.java
index 78bcb85d56..ad0049803d 100644
--- a/java/org/apache/catalina/tribes/tipis/ReplicatedMapEntry.java
+++ b/java/org/apache/catalina/tribes/tipis/ReplicatedMapEntry.java
@@ -1,124 +1,124 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.tipis;
-
-import java.io.IOException;
-import java.io.Serializable;
-
-/**
- * 
- * For smarter replication, an object can implement this interface to replicate diffs<br>
- * The replication logic will call the methods in the following order:<br>
- * <code>
- * 1. if ( entry.isDirty() ) <br>
- *      try {
- * 2.     entry.lock();<br>
- * 3.     byte[] diff = entry.getDiff();<br>
- * 4.     entry.reset();<br>
- *      } finally {<br>
- * 5.     entry.unlock();<br>
- *      }<br>
- *    }<br>
- * </code>
- * <br>
- * <br>
- * When the data is deserialized the logic is called in the following order<br>
- * <code>
- * 1. ReplicatedMapEntry entry = (ReplicatedMapEntry)objectIn.readObject();<br>
- * 2. if ( isBackup(entry)||isPrimary(entry) ) entry.setOwner(owner); <br>
- * </code>
- * <br>
- * 
- * 
- * @author Filip Hanik
- * @version 1.0
- */
-public interface ReplicatedMapEntry extends Serializable {
-    
-    /**
-     * Has the object changed since last replication
-     * and is not in a locked state
-     * @return boolean
-     */
-    public boolean isDirty();
-    
-    /**
-     * If this returns true, the map will extract the diff using getDiff()
-     * Otherwise it will serialize the entire object.
-     * @return boolean
-     */
-    public boolean isDiffable();
-    
-    /**
-     * Returns a diff and sets the dirty map to false
-     * @return byte[]
-     * @throws IOException
-     */
-    public byte[] getDiff() throws IOException;
-    
-    
-    /**
-     * Applies a diff to an existing object.
-     * @param diff byte[]
-     * @param offset int
-     * @param length int
-     * @throws IOException
-     */
-    public void applyDiff(byte[] diff, int offset, int length) throws IOException, ClassNotFoundException;
-    
-    /**
-     * Resets the current diff state and resets the dirty flag
-     */
-    public void resetDiff();
-    
-    /**
-     * Lock during serialization
-     */
-    public void lock();
-    
-    /**
-     * Unlock after serialization
-     */
-    public void unlock();
-    
-    /**
-     * This method is called after the object has been 
-     * created on a remote map. On this method,
-     * the object can initialize itself for any data that wasn't 
-     * 
-     * @param owner Object
-     */
-    public void setOwner(Object owner);
-    
-    /**
-     * For accuracy checking, a serialized attribute can contain a version number
-     * This number increases as modifications are made to the data.
-     * The replicated map can use this to ensure accuracy on a periodic basis
-     * @return long - the version number or -1 if the data is not versioned
-     */
-    public long getVersion();
-    
-    /**
-     * Forces a certain version to a replicated map entry<br>
-     * @param version long
-     */
-    public void setVersion(long version);
-    
-    
-    
-    
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.tipis;
+
+import java.io.IOException;
+import java.io.Serializable;
+
+/**
+ * 
+ * For smarter replication, an object can implement this interface to replicate diffs<br>
+ * The replication logic will call the methods in the following order:<br>
+ * <code>
+ * 1. if ( entry.isDirty() ) <br>
+ *      try {
+ * 2.     entry.lock();<br>
+ * 3.     byte[] diff = entry.getDiff();<br>
+ * 4.     entry.reset();<br>
+ *      } finally {<br>
+ * 5.     entry.unlock();<br>
+ *      }<br>
+ *    }<br>
+ * </code>
+ * <br>
+ * <br>
+ * When the data is deserialized the logic is called in the following order<br>
+ * <code>
+ * 1. ReplicatedMapEntry entry = (ReplicatedMapEntry)objectIn.readObject();<br>
+ * 2. if ( isBackup(entry)||isPrimary(entry) ) entry.setOwner(owner); <br>
+ * </code>
+ * <br>
+ * 
+ * 
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public interface ReplicatedMapEntry extends Serializable {
+    
+    /**
+     * Has the object changed since last replication
+     * and is not in a locked state
+     * @return boolean
+     */
+    public boolean isDirty();
+    
+    /**
+     * If this returns true, the map will extract the diff using getDiff()
+     * Otherwise it will serialize the entire object.
+     * @return boolean
+     */
+    public boolean isDiffable();
+    
+    /**
+     * Returns a diff and sets the dirty map to false
+     * @return byte[]
+     * @throws IOException
+     */
+    public byte[] getDiff() throws IOException;
+    
+    
+    /**
+     * Applies a diff to an existing object.
+     * @param diff byte[]
+     * @param offset int
+     * @param length int
+     * @throws IOException
+     */
+    public void applyDiff(byte[] diff, int offset, int length) throws IOException, ClassNotFoundException;
+    
+    /**
+     * Resets the current diff state and resets the dirty flag
+     */
+    public void resetDiff();
+    
+    /**
+     * Lock during serialization
+     */
+    public void lock();
+    
+    /**
+     * Unlock after serialization
+     */
+    public void unlock();
+    
+    /**
+     * This method is called after the object has been 
+     * created on a remote map. On this method,
+     * the object can initialize itself for any data that wasn't 
+     * 
+     * @param owner Object
+     */
+    public void setOwner(Object owner);
+    
+    /**
+     * For accuracy checking, a serialized attribute can contain a version number
+     * This number increases as modifications are made to the data.
+     * The replicated map can use this to ensure accuracy on a periodic basis
+     * @return long - the version number or -1 if the data is not versioned
+     */
+    public long getVersion();
+    
+    /**
+     * Forces a certain version to a replicated map entry<br>
+     * @param version long
+     */
+    public void setVersion(long version);
+    
+    
+    
+    
 }
\ No newline at end of file

==================================================
Constants.java
index a38adb28a6..5607bb26eb 100644
--- a/java/org/apache/catalina/tribes/tipis/Streamable.java
+++ b/java/org/apache/catalina/tribes/tipis/Streamable.java
@@ -1,61 +1,61 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.tipis;
-
-import java.io.IOException;
-
-/**
- * Example usage:
- * <code><pre>
- * byte[] data = new byte[1024];
- * Streamable st = ....;
- * while ( !st.eof() ) {
- * &nbsp;&nbsp;int length = st.read(data,0,data.length);
- * &nbsp;&nbsp;String s = new String(data,0,length);
- * &nbsp;&nbsp;System.out.println(s);
- * }
- * </pre></code>
- * @author Filip Hanik
- * @version 1.0
- */
-public interface Streamable {
-    
-    /**
-     * returns true if the stream has reached its end
-     * @return boolean
-     */
-    public boolean eof();
-   
-    /**
-     * write data into the byte array starting at offset, maximum bytes read are (data.length-offset)
-     * @param data byte[] - the array to read data into
-     * @param offset int - start position for writing data
-     * @return int - the number of bytes written into the data buffer
-     */
-    public int write(byte[] data, int offset, int length) throws IOException;
-    
-    /**
-     * read data into the byte array starting at offset
-     * @param data byte[] - the array to read data into
-     * @param offset int - start position for writing data
-     * @param length - the desired read length
-     * @return int - the number of bytes read from the data buffer
-     */
-    public int read(byte[] data, int offset, int length) throws IOException;
-
-   
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.tipis;
+
+import java.io.IOException;
+
+/**
+ * Example usage:
+ * <code><pre>
+ * byte[] data = new byte[1024];
+ * Streamable st = ....;
+ * while ( !st.eof() ) {
+ * &nbsp;&nbsp;int length = st.read(data,0,data.length);
+ * &nbsp;&nbsp;String s = new String(data,0,length);
+ * &nbsp;&nbsp;System.out.println(s);
+ * }
+ * </pre></code>
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public interface Streamable {
+    
+    /**
+     * returns true if the stream has reached its end
+     * @return boolean
+     */
+    public boolean eof();
+   
+    /**
+     * write data into the byte array starting at offset, maximum bytes read are (data.length-offset)
+     * @param data byte[] - the array to read data into
+     * @param offset int - start position for writing data
+     * @return int - the number of bytes written into the data buffer
+     */
+    public int write(byte[] data, int offset, int length) throws IOException;
+    
+    /**
+     * read data into the byte array starting at offset
+     * @param data byte[] - the array to read data into
+     * @param offset int - start position for writing data
+     * @param length - the desired read length
+     * @return int - the number of bytes read from the data buffer
+     */
+    public int read(byte[] data, int offset, int length) throws IOException;
+
+   
 }
\ No newline at end of file

==================================================
DataSender.java
index 42b6477ba4..6192403eaa 100644
--- a/java/org/apache/catalina/tribes/transport/Constants.java
+++ b/java/org/apache/catalina/tribes/transport/Constants.java
@@ -1,43 +1,43 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina.tribes.transport;
-
-import org.apache.catalina.tribes.io.XByteBuffer;
-
-/**
- * Manifest constants for the <code>org.apache.catalina.tribes.transport</code>
- * package.
- * @author Filip Hanik
- * @author Peter Rossbach
- * @version $Revision: 303753 $ $Date: 2005-03-14 15:24:30 -0600 (Mon, 14 Mar 2005) $
- */
-
-public class Constants {
-
-    public static final String Package = "org.apache.catalina.tribes.transport";
-    
-    /*
-     * Do not change any of these values!
-     */
-    public static final byte[] ACK_DATA = new byte[] {6, 2, 3};
-    public static final byte[] FAIL_ACK_DATA = new byte[] {11, 0, 5};
-    public static final byte[] ACK_COMMAND = XByteBuffer.createDataPackage(ACK_DATA);
-    public static final byte[] FAIL_ACK_COMMAND = XByteBuffer.createDataPackage(FAIL_ACK_DATA);
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.catalina.tribes.transport;
+
+import org.apache.catalina.tribes.io.XByteBuffer;
+
+/**
+ * Manifest constants for the <code>org.apache.catalina.tribes.transport</code>
+ * package.
+ * @author Filip Hanik
+ * @author Peter Rossbach
+ * @version $Revision$ $Date$
+ */
+
+public class Constants {
+
+    public static final String Package = "org.apache.catalina.tribes.transport";
+    
+    /*
+     * Do not change any of these values!
+     */
+    public static final byte[] ACK_DATA = new byte[] {6, 2, 3};
+    public static final byte[] FAIL_ACK_DATA = new byte[] {11, 0, 5};
+    public static final byte[] ACK_COMMAND = XByteBuffer.createDataPackage(ACK_DATA);
+    public static final byte[] FAIL_ACK_COMMAND = XByteBuffer.createDataPackage(FAIL_ACK_DATA);
+
+}

==================================================
MultiPointSender.java
index e9c98c7072..88ce30014d 100644
--- a/java/org/apache/catalina/tribes/transport/DataSender.java
+++ b/java/org/apache/catalina/tribes/transport/DataSender.java
@@ -1,47 +1,47 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.transport;
-
-import java.io.IOException;
-
-/**
- * <p>Title: </p>
- *
- * <p>Description: </p>
- *
- * <p>Copyright: Copyright (c) 2005</p>
- *
- * <p>Company: </p>
- *
- * @author not attributable
- * @version 1.0
- */
-public interface DataSender {
-    public void connect() throws IOException;
-    public void disconnect();
-    public boolean isConnected();
-    public void setRxBufSize(int size);
-    public void setTxBufSize(int size);
-    public boolean keepalive();
-    public void setTimeout(long timeout);
-    public void setKeepAliveCount(int maxRequests);
-    public void setKeepAliveTime(long keepAliveTimeInMs);
-    public int getRequestCount();
-    public long getConnectTime();
-    
-    
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.transport;
+
+import java.io.IOException;
+
+/**
+ * <p>Title: </p>
+ *
+ * <p>Description: </p>
+ *
+ * <p>Copyright: Copyright (c) 2005</p>
+ *
+ * <p>Company: </p>
+ *
+ * @author not attributable
+ * @version 1.0
+ */
+public interface DataSender {
+    public void connect() throws IOException;
+    public void disconnect();
+    public boolean isConnected();
+    public void setRxBufSize(int size);
+    public void setTxBufSize(int size);
+    public boolean keepalive();
+    public void setTimeout(long timeout);
+    public void setKeepAliveCount(int maxRequests);
+    public void setKeepAliveTime(long keepAliveTimeInMs);
+    public int getRequestCount();
+    public long getConnectTime();
+    
+    
 }
\ No newline at end of file

==================================================
PooledSender.java
index a20b587f79..1a5f1e7a92 100644
--- a/java/org/apache/catalina/tribes/transport/MultiPointSender.java
+++ b/java/org/apache/catalina/tribes/transport/MultiPointSender.java
@@ -1,38 +1,38 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.transport;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.Member;
-
-/**
- * @author Filip Hanik
- * @version $Revision: 303993 $ $Date: 2005-07-16 16:05:54 -0500 (Sat, 16 Jul 2005) $
- * @since 5.5.16
- */
-
-public interface MultiPointSender extends DataSender
-{
-    public void sendMessage(Member[] destination, ChannelMessage data) throws ChannelException;
-    public void setRxBufSize(int size);
-    public void setTxBufSize(int size);
-    public void setMaxRetryAttempts(int attempts);
-    public void setDirectBuffer(boolean directBuf);
-    public void memberAdded(Member member);
-    public void memberDisappeared(Member member);
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.transport;
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.Member;
+
+/**
+ * @author Filip Hanik
+ * @version $Revision$ $Date$
+ * @since 5.5.16
+ */
+
+public interface MultiPointSender extends DataSender
+{
+    public void sendMessage(Member[] destination, ChannelMessage data) throws ChannelException;
+    public void setRxBufSize(int size);
+    public void setTxBufSize(int size);
+    public void setMaxRetryAttempts(int attempts);
+    public void setDirectBuffer(boolean directBuf);
+    public void memberAdded(Member member);
+    public void memberDisappeared(Member member);
+}

==================================================
ReplicationTransmitter.java
index d7d558d511..7524b16586 100644
--- a/java/org/apache/catalina/tribes/transport/PooledSender.java
+++ b/java/org/apache/catalina/tribes/transport/PooledSender.java
@@ -1,198 +1,198 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.transport;
-
-import java.io.IOException;
-import java.util.List;
-
-/**
- * <p>Title: </p>
- *
- * <p>Description: </p>
- *
- * <p>Copyright: Copyright (c) 2005</p>
- *
- * <p>Company: </p>
- *
- * @author not attributable
- * @version 1.0
- */
-public abstract class PooledSender extends AbstractSender implements MultiPointSender {
-    
-    private SenderQueue queue = null;
-    private int poolSize = 25;
-    public PooledSender() {
-        queue = new SenderQueue(this,poolSize);
-    }
-    
-    public abstract DataSender getNewDataSender();
-    
-    public DataSender getSender() {
-        return queue.getSender(getTimeout());
-    }
-    
-    public void returnSender(DataSender sender) {
-        sender.keepalive();
-        queue.returnSender(sender);
-    }
-    
-    public synchronized void connect() throws IOException {
-        //do nothing, happens in the socket sender itself
-        queue.open();
-        setConnected(true);
-    }
-    
-    public synchronized void disconnect() {
-        queue.close();
-        setConnected(false);
-    }
-    
-    
-    public int getInPoolSize() {
-        return queue.getInPoolSize();
-    }
-
-    public int getInUsePoolSize() {
-        return queue.getInUsePoolSize();
-    }
-
-
-    public void setPoolSize(int poolSize) {
-        this.poolSize = poolSize;
-        queue.setLimit(poolSize);
-    }
-
-    public int getPoolSize() {
-        return poolSize;
-    }
-
-    public boolean keepalive() {
-        //do nothing, the pool checks on every return
-        return false;
-    }
-
-    
-
-    //  ----------------------------------------------------- Inner Class
-
-    private class SenderQueue {
-        private int limit = 25;
-
-        PooledSender parent = null;
-
-        private List notinuse = null;
-
-        private List inuse = null;
-
-        private boolean isOpen = true;
-
-        public SenderQueue(PooledSender parent, int limit) {
-            this.limit = limit;
-            this.parent = parent;
-            notinuse = new java.util.LinkedList();
-            inuse = new java.util.LinkedList();
-        }
-
-        /**
-         * @return Returns the limit.
-         */
-        public int getLimit() {
-            return limit;
-        }
-        /**
-         * @param limit The limit to set.
-         */
-        public void setLimit(int limit) {
-            this.limit = limit;
-        }
-        /**
-         * @return
-         */
-        public int getInUsePoolSize() {
-            return inuse.size();
-        }
-
-        /**
-         * @return
-         */
-        public int getInPoolSize() {
-            return notinuse.size();
-        }
-
-        public synchronized DataSender getSender(long timeout) {
-            long start = System.currentTimeMillis();
-            while ( true ) {
-                if (!isOpen)throw new IllegalStateException("Queue is closed");
-                DataSender sender = null;
-                if (notinuse.size() == 0 && inuse.size() < limit) {
-                    sender = parent.getNewDataSender();
-                } else if (notinuse.size() > 0) {
-                    sender = (DataSender) notinuse.remove(0);
-                }
-                if (sender != null) {
-                    inuse.add(sender);
-                    return sender;
-                }//end if
-                long delta = System.currentTimeMillis() - start;
-                if ( delta > timeout && timeout>0) return null;
-                else {
-                    try {
-                        wait(Math.max(timeout - delta,1));
-                    }catch (InterruptedException x){}
-                }//end if
-            }
-        }
-
-        public synchronized void returnSender(DataSender sender) {
-            if ( !isOpen) {
-                sender.disconnect();
-                return;
-            }
-            //to do
-            inuse.remove(sender);
-            //just in case the limit has changed
-            if ( notinuse.size() < this.getLimit() ) notinuse.add(sender);
-            else try {sender.disconnect(); } catch ( Exception ignore){}
-            notify();
-        }
-
-        public synchronized void close() {
-            isOpen = false;
-            Object[] unused = notinuse.toArray();
-            Object[] used = inuse.toArray();
-            for (int i = 0; i < unused.length; i++) {
-                DataSender sender = (DataSender) unused[i];
-                sender.disconnect();
-            }//for
-            for (int i = 0; i < used.length; i++) {
-                DataSender sender = (DataSender) used[i];
-                sender.disconnect();
-            }//for
-            notinuse.clear();
-            inuse.clear();
-            notify();
-            
-
-
-        }
-
-        public synchronized void open() {
-            isOpen = true;
-            notify();
-        }
-    }
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.transport;
+
+import java.io.IOException;
+import java.util.List;
+
+/**
+ * <p>Title: </p>
+ *
+ * <p>Description: </p>
+ *
+ * <p>Copyright: Copyright (c) 2005</p>
+ *
+ * <p>Company: </p>
+ *
+ * @author not attributable
+ * @version 1.0
+ */
+public abstract class PooledSender extends AbstractSender implements MultiPointSender {
+    
+    private SenderQueue queue = null;
+    private int poolSize = 25;
+    public PooledSender() {
+        queue = new SenderQueue(this,poolSize);
+    }
+    
+    public abstract DataSender getNewDataSender();
+    
+    public DataSender getSender() {
+        return queue.getSender(getTimeout());
+    }
+    
+    public void returnSender(DataSender sender) {
+        sender.keepalive();
+        queue.returnSender(sender);
+    }
+    
+    public synchronized void connect() throws IOException {
+        //do nothing, happens in the socket sender itself
+        queue.open();
+        setConnected(true);
+    }
+    
+    public synchronized void disconnect() {
+        queue.close();
+        setConnected(false);
+    }
+    
+    
+    public int getInPoolSize() {
+        return queue.getInPoolSize();
+    }
+
+    public int getInUsePoolSize() {
+        return queue.getInUsePoolSize();
+    }
+
+
+    public void setPoolSize(int poolSize) {
+        this.poolSize = poolSize;
+        queue.setLimit(poolSize);
+    }
+
+    public int getPoolSize() {
+        return poolSize;
+    }
+
+    public boolean keepalive() {
+        //do nothing, the pool checks on every return
+        return false;
+    }
+
+    
+
+    //  ----------------------------------------------------- Inner Class
+
+    private class SenderQueue {
+        private int limit = 25;
+
+        PooledSender parent = null;
+
+        private List notinuse = null;
+
+        private List inuse = null;
+
+        private boolean isOpen = true;
+
+        public SenderQueue(PooledSender parent, int limit) {
+            this.limit = limit;
+            this.parent = parent;
+            notinuse = new java.util.LinkedList();
+            inuse = new java.util.LinkedList();
+        }
+
+        /**
+         * @return Returns the limit.
+         */
+        public int getLimit() {
+            return limit;
+        }
+        /**
+         * @param limit The limit to set.
+         */
+        public void setLimit(int limit) {
+            this.limit = limit;
+        }
+        /**
+         * @return
+         */
+        public int getInUsePoolSize() {
+            return inuse.size();
+        }
+
+        /**
+         * @return
+         */
+        public int getInPoolSize() {
+            return notinuse.size();
+        }
+
+        public synchronized DataSender getSender(long timeout) {
+            long start = System.currentTimeMillis();
+            while ( true ) {
+                if (!isOpen)throw new IllegalStateException("Queue is closed");
+                DataSender sender = null;
+                if (notinuse.size() == 0 && inuse.size() < limit) {
+                    sender = parent.getNewDataSender();
+                } else if (notinuse.size() > 0) {
+                    sender = (DataSender) notinuse.remove(0);
+                }
+                if (sender != null) {
+                    inuse.add(sender);
+                    return sender;
+                }//end if
+                long delta = System.currentTimeMillis() - start;
+                if ( delta > timeout && timeout>0) return null;
+                else {
+                    try {
+                        wait(Math.max(timeout - delta,1));
+                    }catch (InterruptedException x){}
+                }//end if
+            }
+        }
+
+        public synchronized void returnSender(DataSender sender) {
+            if ( !isOpen) {
+                sender.disconnect();
+                return;
+            }
+            //to do
+            inuse.remove(sender);
+            //just in case the limit has changed
+            if ( notinuse.size() < this.getLimit() ) notinuse.add(sender);
+            else try {sender.disconnect(); } catch ( Exception ignore){}
+            notify();
+        }
+
+        public synchronized void close() {
+            isOpen = false;
+            Object[] unused = notinuse.toArray();
+            Object[] used = inuse.toArray();
+            for (int i = 0; i < unused.length; i++) {
+                DataSender sender = (DataSender) unused[i];
+                sender.disconnect();
+            }//for
+            for (int i = 0; i < used.length; i++) {
+                DataSender sender = (DataSender) used[i];
+                sender.disconnect();
+            }//for
+            notinuse.clear();
+            inuse.clear();
+            notify();
+            
+
+
+        }
+
+        public synchronized void open() {
+            isOpen = true;
+            notify();
+        }
+    }
 }
\ No newline at end of file

==================================================
SenderState.java
index d2f33b52cd..d7e14b739d 100644
--- a/java/org/apache/catalina/tribes/transport/ReplicationTransmitter.java
+++ b/java/org/apache/catalina/tribes/transport/ReplicationTransmitter.java
@@ -29,7 +29,7 @@ import org.apache.catalina.tribes.transport.nio.PooledParallelSender;
  * type 
  * 
  * @author Filip Hanik
- * @version $Revision: 379956 $ $Date: 2006-02-22 16:57:35 -0600 (Wed, 22 Feb 2006) $
+ * @version $Revision$ $Date$
  */
 public class ReplicationTransmitter implements ChannelSender {
     private static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(ReplicationTransmitter.class);

==================================================
ThreadPool.java
index 07131477e1..c8eebbf8b0 100644
--- a/java/org/apache/catalina/tribes/transport/SenderState.java
+++ b/java/org/apache/catalina/tribes/transport/SenderState.java
@@ -1,115 +1,115 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.transport;
-
-import org.apache.catalina.tribes.Member;
-import java.util.HashMap;
-
-
-/**
- * 
- * @author Filip Hanik
- * @version 1.0
- * @since 5.5.16
- */
-
-public class SenderState {
-    
-    public static final int READY = 0;
-    public static final int SUSPECT = 1;
-    public static final int FAILING = 2;
-    /**
-     * The descriptive information about this implementation.
-     */
-    private static final String info = "SenderState/1.0";
-    
-    
-    protected static HashMap memberStates = new HashMap();
-    
-    public static SenderState getSenderState(Member member) {
-        return getSenderState(member,true);
-    }
-
-    public static SenderState getSenderState(Member member, boolean create) {
-        SenderState state = (SenderState)memberStates.get(member);
-        if ( state == null && create) {
-            synchronized ( memberStates ) {
-                state = (SenderState)memberStates.get(member);
-                if ( state == null ) {
-                    state = new SenderState();
-                    memberStates.put(member,state);
-                }
-            }
-        }
-        return state;
-    }
-    
-    public static void removeSenderState(Member member) {
-        synchronized ( memberStates ) {
-            memberStates.remove(member);
-        }
-    }
-    
-
-    // ----------------------------------------------------- Instance Variables
-
-    private int state = READY;
-
-    //  ----------------------------------------------------- Constructor
-
-    
-    private SenderState() {
-        this(READY);
-    }
-
-    private SenderState(int state) {
-        this.state = state;
-    }
-    
-    /**
-     * 
-     * @return boolean
-     */
-    public boolean isSuspect() {
-        return (state == SUSPECT) || (state == FAILING);
-    }
-
-    public void setSuspect() {
-        state = SUSPECT;
-    }
-    
-    public boolean isReady() {
-        return state == READY;
-    }
-    
-    public void setReady() {
-        state = READY;
-    }
-    
-    public boolean isFailing() {
-        return state == FAILING;
-    }
-    
-    public void setFailing() {
-        state = FAILING;
-    }
-    
-
-    //  ----------------------------------------------------- Public Properties
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.transport;
+
+import org.apache.catalina.tribes.Member;
+import java.util.HashMap;
+
+
+/**
+ * 
+ * @author Filip Hanik
+ * @version 1.0
+ * @since 5.5.16
+ */
+
+public class SenderState {
+    
+    public static final int READY = 0;
+    public static final int SUSPECT = 1;
+    public static final int FAILING = 2;
+    /**
+     * The descriptive information about this implementation.
+     */
+    private static final String info = "SenderState/1.0";
+    
+    
+    protected static HashMap memberStates = new HashMap();
+    
+    public static SenderState getSenderState(Member member) {
+        return getSenderState(member,true);
+    }
+
+    public static SenderState getSenderState(Member member, boolean create) {
+        SenderState state = (SenderState)memberStates.get(member);
+        if ( state == null && create) {
+            synchronized ( memberStates ) {
+                state = (SenderState)memberStates.get(member);
+                if ( state == null ) {
+                    state = new SenderState();
+                    memberStates.put(member,state);
+                }
+            }
+        }
+        return state;
+    }
+    
+    public static void removeSenderState(Member member) {
+        synchronized ( memberStates ) {
+            memberStates.remove(member);
+        }
+    }
+    
+
+    // ----------------------------------------------------- Instance Variables
+
+    private int state = READY;
+
+    //  ----------------------------------------------------- Constructor
+
+    
+    private SenderState() {
+        this(READY);
+    }
+
+    private SenderState(int state) {
+        this.state = state;
+    }
+    
+    /**
+     * 
+     * @return boolean
+     */
+    public boolean isSuspect() {
+        return (state == SUSPECT) || (state == FAILING);
+    }
+
+    public void setSuspect() {
+        state = SUSPECT;
+    }
+    
+    public boolean isReady() {
+        return state == READY;
+    }
+    
+    public void setReady() {
+        state = READY;
+    }
+    
+    public boolean isFailing() {
+        return state == FAILING;
+    }
+    
+    public void setFailing() {
+        state = FAILING;
+    }
+    
+
+    //  ----------------------------------------------------- Public Properties
+
+}

==================================================
WorkerThread.java
index fbe1e3e47d..e15a0182d6 100644
--- a/java/org/apache/catalina/tribes/transport/ThreadPool.java
+++ b/java/org/apache/catalina/tribes/transport/ThreadPool.java
@@ -1,165 +1,165 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.transport;
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.List;
-
-/**
- * @author not attributable
- * @version 1.0
- */
-
-public class ThreadPool
-{
-    /**
-     * A very simple thread pool class.  The pool size is set at
-     * construction time and remains fixed.  Threads are cycled
-     * through a FIFO idle queue.
-     */
-
-    List idle = new LinkedList();
-    List used = new LinkedList();
-    
-    Object mutex = new Object();
-    boolean running = true;
-    
-    private static int counter = 1;
-    private int maxThreads;
-    private int minThreads;
-    
-    private ThreadCreator creator = null;
-
-    private static synchronized int inc() {
-        return counter++;
-    }
-
-    
-    public ThreadPool (int maxThreads, int minThreads, ThreadCreator creator) throws Exception {
-        // fill up the pool with worker threads
-        this.maxThreads = maxThreads;
-        this.minThreads = minThreads;
-        this.creator = creator;
-        //for (int i = 0; i < minThreads; i++) {
-        for (int i = 0; i < maxThreads; i++) { //temporary fix for thread hand off problem
-            WorkerThread thread = creator.getWorkerThread();
-            setupThread(thread);
-            idle.add (thread);
-        }
-    }
-    
-    protected void setupThread(WorkerThread thread) {
-        synchronized (thread) {
-            thread.setPool(this);
-            thread.setName(thread.getClass().getName() + "[" + inc() + "]");
-            thread.setDaemon(true);
-            thread.setPriority(Thread.MAX_PRIORITY);
-            thread.start();
-            try {thread.wait(500); }catch ( InterruptedException x ) {}
-        }
-    }
-
-    /**
-     * Find an idle worker thread, if any.  Could return null.
-     */
-    public WorkerThread getWorker()
-    {
-        WorkerThread worker = null;
-        synchronized (mutex) {
-            while ( worker == null && running ) {
-                if (idle.size() > 0) {
-                    try {
-                        worker = (WorkerThread) idle.remove(0);
-                    } catch (java.util.NoSuchElementException x) {
-                        //this means that there are no available workers
-                        worker = null;
-                    }
-                } else if ( used.size() < this.maxThreads && creator != null) {
-                    worker = creator.getWorkerThread();
-                    setupThread(worker);
-                } else {
-                    try { mutex.wait(); } catch ( java.lang.InterruptedException x ) {Thread.currentThread().interrupted();}
-                }
-            }//while
-            if ( worker != null ) used.add(worker);
-        }
-        return (worker);
-    }
-    
-    public int available() {
-        return idle.size();
-    }
-
-    /**
-     * Called by the worker thread to return itself to the
-     * idle pool.
-     */
-    public void returnWorker (WorkerThread worker) {
-        if ( running ) {
-            synchronized (mutex) {
-                used.remove(worker);
-                //if ( idle.size() < minThreads && !idle.contains(worker)) idle.add(worker);
-                if ( idle.size() < maxThreads && !idle.contains(worker)) idle.add(worker); //let max be the upper limit
-                else {
-                    worker.setDoRun(false);
-                    synchronized (worker){worker.notify();}
-                }
-                mutex.notify();
-            }
-        }else {
-            worker.setDoRun(false);
-            synchronized (worker){worker.notify();}
-        }
-    }
-
-    public int getMaxThreads() {
-        return maxThreads;
-    }
-
-    public int getMinThreads() {
-        return minThreads;
-    }
-
-    public void stop() {
-        running = false;
-        synchronized (mutex) {
-            Iterator i = idle.iterator();
-            while ( i.hasNext() ) {
-                WorkerThread worker = (WorkerThread)i.next();
-                returnWorker(worker);
-                i.remove();
-            }
-        }
-    }
-
-    public void setMaxThreads(int maxThreads) {
-        this.maxThreads = maxThreads;
-    }
-
-    public void setMinThreads(int minThreads) {
-        this.minThreads = minThreads;
-    }
-
-    public ThreadCreator getThreadCreator() {
-        return this.creator;
-    }
-    
-    public static interface ThreadCreator {
-        public WorkerThread getWorkerThread();
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.transport;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+
+/**
+ * @author not attributable
+ * @version 1.0
+ */
+
+public class ThreadPool
+{
+    /**
+     * A very simple thread pool class.  The pool size is set at
+     * construction time and remains fixed.  Threads are cycled
+     * through a FIFO idle queue.
+     */
+
+    List idle = new LinkedList();
+    List used = new LinkedList();
+    
+    Object mutex = new Object();
+    boolean running = true;
+    
+    private static int counter = 1;
+    private int maxThreads;
+    private int minThreads;
+    
+    private ThreadCreator creator = null;
+
+    private static synchronized int inc() {
+        return counter++;
+    }
+
+    
+    public ThreadPool (int maxThreads, int minThreads, ThreadCreator creator) throws Exception {
+        // fill up the pool with worker threads
+        this.maxThreads = maxThreads;
+        this.minThreads = minThreads;
+        this.creator = creator;
+        //for (int i = 0; i < minThreads; i++) {
+        for (int i = 0; i < maxThreads; i++) { //temporary fix for thread hand off problem
+            WorkerThread thread = creator.getWorkerThread();
+            setupThread(thread);
+            idle.add (thread);
+        }
+    }
+    
+    protected void setupThread(WorkerThread thread) {
+        synchronized (thread) {
+            thread.setPool(this);
+            thread.setName(thread.getClass().getName() + "[" + inc() + "]");
+            thread.setDaemon(true);
+            thread.setPriority(Thread.MAX_PRIORITY);
+            thread.start();
+            try {thread.wait(500); }catch ( InterruptedException x ) {}
+        }
+    }
+
+    /**
+     * Find an idle worker thread, if any.  Could return null.
+     */
+    public WorkerThread getWorker()
+    {
+        WorkerThread worker = null;
+        synchronized (mutex) {
+            while ( worker == null && running ) {
+                if (idle.size() > 0) {
+                    try {
+                        worker = (WorkerThread) idle.remove(0);
+                    } catch (java.util.NoSuchElementException x) {
+                        //this means that there are no available workers
+                        worker = null;
+                    }
+                } else if ( used.size() < this.maxThreads && creator != null) {
+                    worker = creator.getWorkerThread();
+                    setupThread(worker);
+                } else {
+                    try { mutex.wait(); } catch ( java.lang.InterruptedException x ) {Thread.currentThread().interrupted();}
+                }
+            }//while
+            if ( worker != null ) used.add(worker);
+        }
+        return (worker);
+    }
+    
+    public int available() {
+        return idle.size();
+    }
+
+    /**
+     * Called by the worker thread to return itself to the
+     * idle pool.
+     */
+    public void returnWorker (WorkerThread worker) {
+        if ( running ) {
+            synchronized (mutex) {
+                used.remove(worker);
+                //if ( idle.size() < minThreads && !idle.contains(worker)) idle.add(worker);
+                if ( idle.size() < maxThreads && !idle.contains(worker)) idle.add(worker); //let max be the upper limit
+                else {
+                    worker.setDoRun(false);
+                    synchronized (worker){worker.notify();}
+                }
+                mutex.notify();
+            }
+        }else {
+            worker.setDoRun(false);
+            synchronized (worker){worker.notify();}
+        }
+    }
+
+    public int getMaxThreads() {
+        return maxThreads;
+    }
+
+    public int getMinThreads() {
+        return minThreads;
+    }
+
+    public void stop() {
+        running = false;
+        synchronized (mutex) {
+            Iterator i = idle.iterator();
+            while ( i.hasNext() ) {
+                WorkerThread worker = (WorkerThread)i.next();
+                returnWorker(worker);
+                i.remove();
+            }
+        }
+    }
+
+    public void setMaxThreads(int maxThreads) {
+        this.maxThreads = maxThreads;
+    }
+
+    public void setMinThreads(int minThreads) {
+        this.minThreads = minThreads;
+    }
+
+    public ThreadCreator getThreadCreator() {
+        return this.creator;
+    }
+    
+    public static interface ThreadCreator {
+        public WorkerThread getWorkerThread();
+    }
+}

==================================================
BioReplicationThread.java
index d5e3051249..8c7df84085 100644
--- a/java/org/apache/catalina/tribes/transport/WorkerThread.java
+++ b/java/org/apache/catalina/tribes/transport/WorkerThread.java
@@ -1,89 +1,89 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.transport;
-
-import org.apache.catalina.tribes.io.ListenCallback;
-
-
-
-
-/**
- * @author Filip Hanik
- * @version $Revision: 366253 $ $Date: 2006-01-05 13:30:42 -0600 (Thu, 05 Jan 2006) $
- */
-public abstract class WorkerThread extends Thread 
-{
-    
-    public static final int OPTION_DIRECT_BUFFER = ReceiverBase.OPTION_DIRECT_BUFFER;
-    
-    private ListenCallback callback;
-    private ThreadPool pool;
-    private boolean doRun = true;
-    private int options;
-    protected boolean useBufferPool = true;
-
-    public WorkerThread(ListenCallback callback) {
-        this.callback = callback;
-    }
-
-    public void setPool(ThreadPool pool) {
-        this.pool = pool;
-    }
-
-    public void setOptions(int options) {
-        this.options = options;
-    }
-
-    public void setCallback(ListenCallback callback) {
-        this.callback = callback;
-    }
-
-    public void setDoRun(boolean doRun) {
-        this.doRun = doRun;
-    }
-
-    public ThreadPool getPool() {
-        return pool;
-    }
-
-    public int getOptions() {
-        return options;
-    }
-
-    public ListenCallback getCallback() {
-        return callback;
-    }
-
-    public boolean isDoRun() {
-        return doRun;
-    }
-
-    public void close()
-    {
-        doRun = false;
-        notify();
-    }
-    
-    public void setUseBufferPool(boolean usebufpool) {
-        useBufferPool = usebufpool;
-    }
-    
-    public boolean getUseBufferPool() {
-        return useBufferPool;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.transport;
+
+import org.apache.catalina.tribes.io.ListenCallback;
+
+
+
+
+/**
+ * @author Filip Hanik
+ * @version $Revision$ $Date$
+ */
+public abstract class WorkerThread extends Thread 
+{
+    
+    public static final int OPTION_DIRECT_BUFFER = ReceiverBase.OPTION_DIRECT_BUFFER;
+    
+    private ListenCallback callback;
+    private ThreadPool pool;
+    private boolean doRun = true;
+    private int options;
+    protected boolean useBufferPool = true;
+
+    public WorkerThread(ListenCallback callback) {
+        this.callback = callback;
+    }
+
+    public void setPool(ThreadPool pool) {
+        this.pool = pool;
+    }
+
+    public void setOptions(int options) {
+        this.options = options;
+    }
+
+    public void setCallback(ListenCallback callback) {
+        this.callback = callback;
+    }
+
+    public void setDoRun(boolean doRun) {
+        this.doRun = doRun;
+    }
+
+    public ThreadPool getPool() {
+        return pool;
+    }
+
+    public int getOptions() {
+        return options;
+    }
+
+    public ListenCallback getCallback() {
+        return callback;
+    }
+
+    public boolean isDoRun() {
+        return doRun;
+    }
+
+    public void close()
+    {
+        doRun = false;
+        notify();
+    }
+    
+    public void setUseBufferPool(boolean usebufpool) {
+        useBufferPool = usebufpool;
+    }
+    
+    public boolean getUseBufferPool() {
+        return useBufferPool;
+    }
+}

==================================================
BioSender.java
index 4edc9ee6b7..61ae79353e 100644
--- a/java/org/apache/catalina/tribes/transport/bio/BioReplicationThread.java
+++ b/java/org/apache/catalina/tribes/transport/bio/BioReplicationThread.java
@@ -1,181 +1,181 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.transport.bio;
-import java.io.IOException;
-
-import org.apache.catalina.tribes.io.ObjectReader;
-import org.apache.catalina.tribes.transport.Constants;
-import org.apache.catalina.tribes.transport.WorkerThread;
-import java.net.Socket;
-import java.io.InputStream;
-import org.apache.catalina.tribes.transport.ReceiverBase;
-import java.io.OutputStream;
-import org.apache.catalina.tribes.io.ListenCallback;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.io.ChannelData;
-import org.apache.catalina.tribes.io.BufferPool;
-
-/**
- * A worker thread class which can drain channels and echo-back the input. Each
- * instance is constructed with a reference to the owning thread pool object.
- * When started, the thread loops forever waiting to be awakened to service the
- * channel associated with a SelectionKey object. The worker is tasked by
- * calling its serviceChannel() method with a SelectionKey object. The
- * serviceChannel() method stores the key reference in the thread object then
- * calls notify() to wake it up. When the channel has been drained, the worker
- * thread returns itself to its parent pool.
- * 
- * @author Filip Hanik
- * 
- * @version $Revision: 378050 $, $Date: 2006-02-15 12:30:02 -0600 (Wed, 15 Feb 2006) $
- */
-public class BioReplicationThread extends WorkerThread {
-
-
-    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( BioReplicationThread.class );
-    
-    protected Socket socket;
-    protected ObjectReader reader;
-    
-    public BioReplicationThread (ListenCallback callback) {
-        super(callback);
-    }
-
-    // loop forever waiting for work to do
-    public synchronized void run()
-    {
-        this.notify();
-        while (isDoRun()) {
-            try {
-                // sleep and release object lock
-                this.wait();
-            } catch (InterruptedException e) {
-                if(log.isInfoEnabled())
-                    log.info("TCP worker thread interrupted in cluster",e);
-                // clear interrupt status
-                Thread.interrupted();
-            }
-            if ( socket == null ) continue;
-            try {
-                drainSocket();
-            } catch ( Exception x ) {
-                log.error("Unable to service bio socket");
-            }finally {
-                try {socket.close();}catch ( Exception ignore){}
-                try {reader.close();}catch ( Exception ignore){}
-                reader = null;
-                socket = null;
-            }
-            // done, ready for more, return to pool
-            if ( getPool() != null ) getPool().returnWorker (this);
-            else setDoRun(false);
-        }
-    }
-
-    
-    public synchronized void serviceSocket(Socket socket, ObjectReader reader) {
-        this.socket = socket;
-        this.reader = reader;
-        this.notify();		// awaken the thread
-    }
-    
-    protected void execute(ObjectReader reader) throws Exception{
-        int pkgcnt = reader.count();
-
-        if ( pkgcnt > 0 ) {
-            ChannelMessage[] msgs = reader.execute();
-            for ( int i=0; i<msgs.length; i++ ) {
-                /**
-                 * Use send ack here if you want to ack the request to the remote 
-                 * server before completing the request
-                 * This is considered an asynchronized request
-                 */
-                if (ChannelData.sendAckAsync(msgs[i].getOptions())) sendAck(Constants.ACK_COMMAND);
-                try {
-                    //process the message
-                    getCallback().messageDataReceived(msgs[i]);
-                    /**
-                     * Use send ack here if you want the request to complete on this
-                     * server before sending the ack to the remote server
-                     * This is considered a synchronized request
-                     */
-                    if (ChannelData.sendAckSync(msgs[i].getOptions())) sendAck(Constants.ACK_COMMAND);
-                }catch  ( Exception x ) {
-                    if (ChannelData.sendAckSync(msgs[i].getOptions())) sendAck(Constants.FAIL_ACK_COMMAND);
-                    log.error("Error thrown from messageDataReceived.",x);
-                }
-                if ( getUseBufferPool() ) {
-                    BufferPool.getBufferPool().returnBuffer(msgs[i].getMessage());
-                    msgs[i].setMessage(null);
-                }
-            }                       
-        }
-
-       
-    }
-
-    /**
-     * The actual code which drains the channel associated with
-     * the given key.  This method assumes the key has been
-     * modified prior to invocation to turn off selection
-     * interest in OP_READ.  When this method completes it
-     * re-enables OP_READ and calls wakeup() on the selector
-     * so the selector will resume watching this channel.
-     */
-    protected void drainSocket () throws Exception {
-        InputStream in = socket.getInputStream();
-        // loop while data available, channel is non-blocking
-        byte[] buf = new byte[1024];
-        int length = in.read(buf);
-        while ( length >= 0 ) {
-            int count = reader.append(buf,0,length,true);
-            if ( count > 0 ) execute(reader);
-            length = in.read(buf);
-        }
-    }
-
-
-
-
-    /**
-     * send a reply-acknowledgement (6,2,3)
-     * @param key
-     * @param channel
-     */
-    protected void sendAck(byte[] command) {
-        try {
-            OutputStream out = socket.getOutputStream();
-            out.write(command);
-            out.flush();
-            if (log.isTraceEnabled()) {
-                log.trace("ACK sent to " + socket.getPort());
-            }
-        } catch ( java.io.IOException x ) {
-            log.warn("Unable to send ACK back through channel, channel disconnected?: "+x.getMessage());
-        }
-    }
-    
-    public void close() {
-        setDoRun(false);
-        try {socket.close();}catch ( Exception ignore){}
-        try {reader.close();}catch ( Exception ignore){}
-        reader = null;
-        socket = null;
-        super.close();
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.transport.bio;
+import java.io.IOException;
+
+import org.apache.catalina.tribes.io.ObjectReader;
+import org.apache.catalina.tribes.transport.Constants;
+import org.apache.catalina.tribes.transport.WorkerThread;
+import java.net.Socket;
+import java.io.InputStream;
+import org.apache.catalina.tribes.transport.ReceiverBase;
+import java.io.OutputStream;
+import org.apache.catalina.tribes.io.ListenCallback;
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.io.ChannelData;
+import org.apache.catalina.tribes.io.BufferPool;
+
+/**
+ * A worker thread class which can drain channels and echo-back the input. Each
+ * instance is constructed with a reference to the owning thread pool object.
+ * When started, the thread loops forever waiting to be awakened to service the
+ * channel associated with a SelectionKey object. The worker is tasked by
+ * calling its serviceChannel() method with a SelectionKey object. The
+ * serviceChannel() method stores the key reference in the thread object then
+ * calls notify() to wake it up. When the channel has been drained, the worker
+ * thread returns itself to its parent pool.
+ * 
+ * @author Filip Hanik
+ * 
+ * @version $Revision$, $Date$
+ */
+public class BioReplicationThread extends WorkerThread {
+
+
+    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( BioReplicationThread.class );
+    
+    protected Socket socket;
+    protected ObjectReader reader;
+    
+    public BioReplicationThread (ListenCallback callback) {
+        super(callback);
+    }
+
+    // loop forever waiting for work to do
+    public synchronized void run()
+    {
+        this.notify();
+        while (isDoRun()) {
+            try {
+                // sleep and release object lock
+                this.wait();
+            } catch (InterruptedException e) {
+                if(log.isInfoEnabled())
+                    log.info("TCP worker thread interrupted in cluster",e);
+                // clear interrupt status
+                Thread.interrupted();
+            }
+            if ( socket == null ) continue;
+            try {
+                drainSocket();
+            } catch ( Exception x ) {
+                log.error("Unable to service bio socket");
+            }finally {
+                try {socket.close();}catch ( Exception ignore){}
+                try {reader.close();}catch ( Exception ignore){}
+                reader = null;
+                socket = null;
+            }
+            // done, ready for more, return to pool
+            if ( getPool() != null ) getPool().returnWorker (this);
+            else setDoRun(false);
+        }
+    }
+
+    
+    public synchronized void serviceSocket(Socket socket, ObjectReader reader) {
+        this.socket = socket;
+        this.reader = reader;
+        this.notify();		// awaken the thread
+    }
+    
+    protected void execute(ObjectReader reader) throws Exception{
+        int pkgcnt = reader.count();
+
+        if ( pkgcnt > 0 ) {
+            ChannelMessage[] msgs = reader.execute();
+            for ( int i=0; i<msgs.length; i++ ) {
+                /**
+                 * Use send ack here if you want to ack the request to the remote 
+                 * server before completing the request
+                 * This is considered an asynchronized request
+                 */
+                if (ChannelData.sendAckAsync(msgs[i].getOptions())) sendAck(Constants.ACK_COMMAND);
+                try {
+                    //process the message
+                    getCallback().messageDataReceived(msgs[i]);
+                    /**
+                     * Use send ack here if you want the request to complete on this
+                     * server before sending the ack to the remote server
+                     * This is considered a synchronized request
+                     */
+                    if (ChannelData.sendAckSync(msgs[i].getOptions())) sendAck(Constants.ACK_COMMAND);
+                }catch  ( Exception x ) {
+                    if (ChannelData.sendAckSync(msgs[i].getOptions())) sendAck(Constants.FAIL_ACK_COMMAND);
+                    log.error("Error thrown from messageDataReceived.",x);
+                }
+                if ( getUseBufferPool() ) {
+                    BufferPool.getBufferPool().returnBuffer(msgs[i].getMessage());
+                    msgs[i].setMessage(null);
+                }
+            }                       
+        }
+
+       
+    }
+
+    /**
+     * The actual code which drains the channel associated with
+     * the given key.  This method assumes the key has been
+     * modified prior to invocation to turn off selection
+     * interest in OP_READ.  When this method completes it
+     * re-enables OP_READ and calls wakeup() on the selector
+     * so the selector will resume watching this channel.
+     */
+    protected void drainSocket () throws Exception {
+        InputStream in = socket.getInputStream();
+        // loop while data available, channel is non-blocking
+        byte[] buf = new byte[1024];
+        int length = in.read(buf);
+        while ( length >= 0 ) {
+            int count = reader.append(buf,0,length,true);
+            if ( count > 0 ) execute(reader);
+            length = in.read(buf);
+        }
+    }
+
+
+
+
+    /**
+     * send a reply-acknowledgement (6,2,3)
+     * @param key
+     * @param channel
+     */
+    protected void sendAck(byte[] command) {
+        try {
+            OutputStream out = socket.getOutputStream();
+            out.write(command);
+            out.flush();
+            if (log.isTraceEnabled()) {
+                log.trace("ACK sent to " + socket.getPort());
+            }
+        } catch ( java.io.IOException x ) {
+            log.warn("Unable to send ACK back through channel, channel disconnected?: "+x.getMessage());
+        }
+    }
+    
+    public void close() {
+        setDoRun(false);
+        try {socket.close();}catch ( Exception ignore){}
+        try {reader.close();}catch ( Exception ignore){}
+        reader = null;
+        socket = null;
+        super.close();
+    }
+}

==================================================
FastQueue.java
index 2b97624011..496e069b6f 100644
--- a/java/org/apache/catalina/tribes/transport/bio/BioSender.java
+++ b/java/org/apache/catalina/tribes/transport/bio/BioSender.java
@@ -39,7 +39,7 @@ import org.apache.catalina.tribes.util.StringManager;
  * 
  * @author Peter Rossbach
  * @author Filip Hanik
- * @version $Revision: 377484 $ $Date: 2006-02-13 15:00:05 -0600 (Mon, 13 Feb 2006) $
+ * @version $Revision$ $Date$
  * @since 5.5.16
  */
 public class BioSender extends AbstractSender implements DataSender {

==================================================
LinkObject.java
index 064a0f0446..39395adf84 100644
--- a/java/org/apache/catalina/tribes/transport/bio/util/FastQueue.java
+++ b/java/org/apache/catalina/tribes/transport/bio/util/FastQueue.java
@@ -1,394 +1,394 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.transport.bio.util;
-
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.ErrorHandler;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.group.InterceptorPayload;
-
-
-
-/**
- * A fast queue that remover thread lock the adder thread. <br/>Limit the queue
- * length when you have strange producer thread problemes.
- * 
- * FIXME add i18n support to log messages
- * @author Rainer Jung
- * @author Peter Rossbach
- * @version $Revision: 345567 $ $Date: 2005-11-18 15:07:23 -0600 (Fri, 18 Nov 2005) $
- */
-public class FastQueue {
-
-    private static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(FastQueue.class);
-
-    /**
-     * This is the actual queue
-     */
-    private SingleRemoveSynchronizedAddLock lock = null;
-
-    /**
-     * First Object at queue (consumer message)
-     */
-    private LinkObject first = null;
-
-    /**
-     * Last object in queue (producer Object)
-     */
-    private LinkObject last = null;
-
-    /**
-     * Current Queue elements size
-     */
-    private int size = 0;
-
-    /**
-     * check lock to detect strange threadings things
-     */
-    private boolean checkLock = false;
-
-    /**
-     * protocol the thread wait times
-     */
-    private boolean timeWait = false;
-
-    private boolean inAdd = false;
-
-    private boolean inRemove = false;
-
-    private boolean inMutex = false;
-
-    /**
-     * limit the queue legnth ( default is unlimited)
-     */
-    private int maxQueueLength = 0;
-
-    /**
-     * addWaitTimeout for producer
-     */
-    private long addWaitTimeout = 10000L;
-
-    
-    /**
-     * removeWaitTimeout for consumer
-     */
-    private long removeWaitTimeout = 30000L;
-
-    /**
-     * enabled the queue
-     */
-    private boolean enabled = true;
-
-    /**
-     *  max queue size
-     */
-    private int maxSize = 0;
-
-    /**
-     *  avg size sample interval
-     */
-    private int sampleInterval = 100;
-
-    /**
-     * Generate Queue SingleRemoveSynchronizedAddLock and set add and wait
-     * Timeouts
-     */
-    public FastQueue() {
-        lock = new SingleRemoveSynchronizedAddLock();
-        lock.setAddWaitTimeout(addWaitTimeout);
-        lock.setRemoveWaitTimeout(removeWaitTimeout);
-    }
-
-    /**
-     * get current add wait timeout
-     * 
-     * @return current wait timeout
-     */
-    public long getAddWaitTimeout() {
-        addWaitTimeout = lock.getAddWaitTimeout();
-        return addWaitTimeout;
-    }
-
-    /**
-     * Set add wait timeout (default 10000 msec)
-     * 
-     * @param timeout
-     */
-    public void setAddWaitTimeout(long timeout) {
-        addWaitTimeout = timeout;
-        lock.setAddWaitTimeout(addWaitTimeout);
-    }
-
-    /**
-     * get current remove wait timeout
-     * 
-     * @return The timeout
-     */
-    public long getRemoveWaitTimeout() {
-        removeWaitTimeout = lock.getRemoveWaitTimeout();
-        return removeWaitTimeout;
-    }
-
-    /**
-     * set remove wait timeout ( default 30000 msec)
-     * 
-     * @param timeout
-     */
-    public void setRemoveWaitTimeout(long timeout) {
-        removeWaitTimeout = timeout;
-        lock.setRemoveWaitTimeout(removeWaitTimeout);
-    }
-
-    /**
-     * get Max Queue length
-     * 
-     * @see org.apache.catalina.tribes.util.IQueue#getMaxQueueLength()
-     */
-    public int getMaxQueueLength() {
-        return maxQueueLength;
-    }
-
-    public void setMaxQueueLength(int length) {
-        maxQueueLength = length;
-    }
-
-    public boolean isEnabled() {
-        return enabled;
-    }
-
-    public void setEnabled(boolean enable) {
-        enabled = enable;
-        if (!enabled) {
-            lock.abortRemove();
-            last = first = null;
-        }
-    }
-
-    /**
-     * @return Returns the checkLock.
-     */
-    public boolean isCheckLock() {
-        return checkLock;
-    }
-
-    /**
-     * @param checkLock The checkLock to set.
-     */
-    public void setCheckLock(boolean checkLock) {
-        this.checkLock = checkLock;
-    }
-
-    
-    /**
-     * @return The max size
-     */
-    public int getMaxSize() {
-        return maxSize;
-    }
-
-    /**
-     * @param size
-     */
-    public void setMaxSize(int size) {
-        maxSize = size;
-    }
-
-    
-    /**
-     * unlock queue for next add 
-     */
-    public void unlockAdd() {
-        lock.unlockAdd(size > 0 ? true : false);
-    }
-
-    /**
-     * unlock queue for next remove 
-     */
-    public void unlockRemove() {
-        lock.unlockRemove();
-    }
-
-    /**
-     * start queuing
-     */
-    public void start() {
-        setEnabled(true);
-    }
-
-    /**
-     * start queuing
-     */
-    public void stop() {
-        setEnabled(false);
-    }
-
-    public int getSize() {
-        return size;
-    }
-
-    public SingleRemoveSynchronizedAddLock getLock() {
-        return lock;
-    }
-
-    /**
-     * Add new data to the queue
-     * @see org.apache.catalina.tribes.util.IQueue#add(java.lang.String, java.lang.Object)
-     * FIXME extract some method
-     */
-    public boolean add(ChannelMessage msg, Member[] destination, InterceptorPayload payload) {
-        boolean ok = true;
-        long time = 0;
-
-        if (!enabled) {
-            if (log.isInfoEnabled())
-                log.info("FastQueue.add: queue disabled, add aborted");
-            return false;
-        }
-
-        if (timeWait) {
-            time = System.currentTimeMillis();
-        }
-        lock.lockAdd();
-        try {
-            if (log.isTraceEnabled()) {
-                log.trace("FastQueue.add: starting with size " + size);
-            }
-            if (checkLock) {
-                if (inAdd)
-                    log.warn("FastQueue.add: Detected other add");
-                inAdd = true;
-                if (inMutex)
-                    log.warn("FastQueue.add: Detected other mutex in add");
-                inMutex = true;
-            }
-
-            if ((maxQueueLength > 0) && (size >= maxQueueLength)) {
-                ok = false;
-                if (log.isTraceEnabled()) {
-                    log.trace("FastQueue.add: Could not add, since queue is full (" + size + ">=" + maxQueueLength + ")");
-                }
-            } else {
-                LinkObject element = new LinkObject(msg,destination, payload);
-                if (size == 0) {
-                    first = last = element;
-                    size = 1;
-                } else {
-                    if (last == null) {
-                        ok = false;
-                        log.error("FastQueue.add: Could not add, since last is null although size is "+ size + " (>0)");
-                    } else {
-                        last.append(element);
-                        last = element;
-                        size++;
-                    }
-                }
-            }
-
-            if (first == null) {
-                log.error("FastQueue.add: first is null, size is " + size + " at end of add");
-            }
-            if (last == null) {
-                log.error("FastQueue.add: last is null, size is " + size+ " at end of add");
-            }
-
-            if (checkLock) {
-                if (!inMutex) log.warn("FastQueue.add: Cancelled by other mutex in add");
-                inMutex = false;
-                if (!inAdd) log.warn("FastQueue.add: Cancelled by other add");
-                inAdd = false;
-            }
-            if (log.isTraceEnabled()) log.trace("FastQueue.add: add ending with size " + size);
-
-        } finally {
-            lock.unlockAdd(true);
-        }
-        return ok;
-    }
-
-    /**
-     * remove the complete queued object list
-     * @see org.apache.catalina.tribes.util.IQueue#remove()
-     * FIXME extract some method
-     */
-    public LinkObject remove() {
-        LinkObject element;
-        boolean gotLock;
-        long time = 0;
-
-        if (!enabled) {
-            if (log.isInfoEnabled())
-                log.info("FastQueue.remove: queue disabled, remove aborted");
-            return null;
-        }
-
-        if (timeWait) {
-            time = System.currentTimeMillis();
-        }
-        gotLock = lock.lockRemove();
-        try {
-
-            if (!gotLock) {
-                if (enabled) {
-                    if (log.isInfoEnabled())
-                        log.info("FastQueue.remove: Remove aborted although queue enabled");
-                } else {
-                    if (log.isInfoEnabled())
-                        log.info("FastQueue.remove: queue disabled, remove aborted");
-                }
-                return null;
-            }
-
-            if (log.isTraceEnabled()) {
-                log.trace("FastQueue.remove: remove starting with size " + size);
-            }
-            if (checkLock) {
-                if (inRemove)
-                    log.warn("FastQueue.remove: Detected other remove");
-                inRemove = true;
-                if (inMutex)
-                    log.warn("FastQueue.remove: Detected other mutex in remove");
-                inMutex = true;
-            }
-
-            element = first;
-
-            first = last = null;
-            size = 0;
-
-            if (checkLock) {
-                if (!inMutex)
-                    log.warn("FastQueue.remove: Cancelled by other mutex in remove");
-                inMutex = false;
-                if (!inRemove)
-                    log.warn("FastQueue.remove: Cancelled by other remove");
-                inRemove = false;
-            }
-            if (log.isTraceEnabled()) {
-                log.trace("FastQueue.remove: remove ending with size " + size);
-            }
-
-            if (timeWait) {
-                time = System.currentTimeMillis();
-            }
-        } finally {
-            lock.unlockRemove();
-        }
-        return element;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.transport.bio.util;
+
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.ErrorHandler;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.group.InterceptorPayload;
+
+
+
+/**
+ * A fast queue that remover thread lock the adder thread. <br/>Limit the queue
+ * length when you have strange producer thread problemes.
+ * 
+ * FIXME add i18n support to log messages
+ * @author Rainer Jung
+ * @author Peter Rossbach
+ * @version $Revision$ $Date$
+ */
+public class FastQueue {
+
+    private static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(FastQueue.class);
+
+    /**
+     * This is the actual queue
+     */
+    private SingleRemoveSynchronizedAddLock lock = null;
+
+    /**
+     * First Object at queue (consumer message)
+     */
+    private LinkObject first = null;
+
+    /**
+     * Last object in queue (producer Object)
+     */
+    private LinkObject last = null;
+
+    /**
+     * Current Queue elements size
+     */
+    private int size = 0;
+
+    /**
+     * check lock to detect strange threadings things
+     */
+    private boolean checkLock = false;
+
+    /**
+     * protocol the thread wait times
+     */
+    private boolean timeWait = false;
+
+    private boolean inAdd = false;
+
+    private boolean inRemove = false;
+
+    private boolean inMutex = false;
+
+    /**
+     * limit the queue legnth ( default is unlimited)
+     */
+    private int maxQueueLength = 0;
+
+    /**
+     * addWaitTimeout for producer
+     */
+    private long addWaitTimeout = 10000L;
+
+    
+    /**
+     * removeWaitTimeout for consumer
+     */
+    private long removeWaitTimeout = 30000L;
+
+    /**
+     * enabled the queue
+     */
+    private boolean enabled = true;
+
+    /**
+     *  max queue size
+     */
+    private int maxSize = 0;
+
+    /**
+     *  avg size sample interval
+     */
+    private int sampleInterval = 100;
+
+    /**
+     * Generate Queue SingleRemoveSynchronizedAddLock and set add and wait
+     * Timeouts
+     */
+    public FastQueue() {
+        lock = new SingleRemoveSynchronizedAddLock();
+        lock.setAddWaitTimeout(addWaitTimeout);
+        lock.setRemoveWaitTimeout(removeWaitTimeout);
+    }
+
+    /**
+     * get current add wait timeout
+     * 
+     * @return current wait timeout
+     */
+    public long getAddWaitTimeout() {
+        addWaitTimeout = lock.getAddWaitTimeout();
+        return addWaitTimeout;
+    }
+
+    /**
+     * Set add wait timeout (default 10000 msec)
+     * 
+     * @param timeout
+     */
+    public void setAddWaitTimeout(long timeout) {
+        addWaitTimeout = timeout;
+        lock.setAddWaitTimeout(addWaitTimeout);
+    }
+
+    /**
+     * get current remove wait timeout
+     * 
+     * @return The timeout
+     */
+    public long getRemoveWaitTimeout() {
+        removeWaitTimeout = lock.getRemoveWaitTimeout();
+        return removeWaitTimeout;
+    }
+
+    /**
+     * set remove wait timeout ( default 30000 msec)
+     * 
+     * @param timeout
+     */
+    public void setRemoveWaitTimeout(long timeout) {
+        removeWaitTimeout = timeout;
+        lock.setRemoveWaitTimeout(removeWaitTimeout);
+    }
+
+    /**
+     * get Max Queue length
+     * 
+     * @see org.apache.catalina.tribes.util.IQueue#getMaxQueueLength()
+     */
+    public int getMaxQueueLength() {
+        return maxQueueLength;
+    }
+
+    public void setMaxQueueLength(int length) {
+        maxQueueLength = length;
+    }
+
+    public boolean isEnabled() {
+        return enabled;
+    }
+
+    public void setEnabled(boolean enable) {
+        enabled = enable;
+        if (!enabled) {
+            lock.abortRemove();
+            last = first = null;
+        }
+    }
+
+    /**
+     * @return Returns the checkLock.
+     */
+    public boolean isCheckLock() {
+        return checkLock;
+    }
+
+    /**
+     * @param checkLock The checkLock to set.
+     */
+    public void setCheckLock(boolean checkLock) {
+        this.checkLock = checkLock;
+    }
+
+    
+    /**
+     * @return The max size
+     */
+    public int getMaxSize() {
+        return maxSize;
+    }
+
+    /**
+     * @param size
+     */
+    public void setMaxSize(int size) {
+        maxSize = size;
+    }
+
+    
+    /**
+     * unlock queue for next add 
+     */
+    public void unlockAdd() {
+        lock.unlockAdd(size > 0 ? true : false);
+    }
+
+    /**
+     * unlock queue for next remove 
+     */
+    public void unlockRemove() {
+        lock.unlockRemove();
+    }
+
+    /**
+     * start queuing
+     */
+    public void start() {
+        setEnabled(true);
+    }
+
+    /**
+     * start queuing
+     */
+    public void stop() {
+        setEnabled(false);
+    }
+
+    public int getSize() {
+        return size;
+    }
+
+    public SingleRemoveSynchronizedAddLock getLock() {
+        return lock;
+    }
+
+    /**
+     * Add new data to the queue
+     * @see org.apache.catalina.tribes.util.IQueue#add(java.lang.String, java.lang.Object)
+     * FIXME extract some method
+     */
+    public boolean add(ChannelMessage msg, Member[] destination, InterceptorPayload payload) {
+        boolean ok = true;
+        long time = 0;
+
+        if (!enabled) {
+            if (log.isInfoEnabled())
+                log.info("FastQueue.add: queue disabled, add aborted");
+            return false;
+        }
+
+        if (timeWait) {
+            time = System.currentTimeMillis();
+        }
+        lock.lockAdd();
+        try {
+            if (log.isTraceEnabled()) {
+                log.trace("FastQueue.add: starting with size " + size);
+            }
+            if (checkLock) {
+                if (inAdd)
+                    log.warn("FastQueue.add: Detected other add");
+                inAdd = true;
+                if (inMutex)
+                    log.warn("FastQueue.add: Detected other mutex in add");
+                inMutex = true;
+            }
+
+            if ((maxQueueLength > 0) && (size >= maxQueueLength)) {
+                ok = false;
+                if (log.isTraceEnabled()) {
+                    log.trace("FastQueue.add: Could not add, since queue is full (" + size + ">=" + maxQueueLength + ")");
+                }
+            } else {
+                LinkObject element = new LinkObject(msg,destination, payload);
+                if (size == 0) {
+                    first = last = element;
+                    size = 1;
+                } else {
+                    if (last == null) {
+                        ok = false;
+                        log.error("FastQueue.add: Could not add, since last is null although size is "+ size + " (>0)");
+                    } else {
+                        last.append(element);
+                        last = element;
+                        size++;
+                    }
+                }
+            }
+
+            if (first == null) {
+                log.error("FastQueue.add: first is null, size is " + size + " at end of add");
+            }
+            if (last == null) {
+                log.error("FastQueue.add: last is null, size is " + size+ " at end of add");
+            }
+
+            if (checkLock) {
+                if (!inMutex) log.warn("FastQueue.add: Cancelled by other mutex in add");
+                inMutex = false;
+                if (!inAdd) log.warn("FastQueue.add: Cancelled by other add");
+                inAdd = false;
+            }
+            if (log.isTraceEnabled()) log.trace("FastQueue.add: add ending with size " + size);
+
+        } finally {
+            lock.unlockAdd(true);
+        }
+        return ok;
+    }
+
+    /**
+     * remove the complete queued object list
+     * @see org.apache.catalina.tribes.util.IQueue#remove()
+     * FIXME extract some method
+     */
+    public LinkObject remove() {
+        LinkObject element;
+        boolean gotLock;
+        long time = 0;
+
+        if (!enabled) {
+            if (log.isInfoEnabled())
+                log.info("FastQueue.remove: queue disabled, remove aborted");
+            return null;
+        }
+
+        if (timeWait) {
+            time = System.currentTimeMillis();
+        }
+        gotLock = lock.lockRemove();
+        try {
+
+            if (!gotLock) {
+                if (enabled) {
+                    if (log.isInfoEnabled())
+                        log.info("FastQueue.remove: Remove aborted although queue enabled");
+                } else {
+                    if (log.isInfoEnabled())
+                        log.info("FastQueue.remove: queue disabled, remove aborted");
+                }
+                return null;
+            }
+
+            if (log.isTraceEnabled()) {
+                log.trace("FastQueue.remove: remove starting with size " + size);
+            }
+            if (checkLock) {
+                if (inRemove)
+                    log.warn("FastQueue.remove: Detected other remove");
+                inRemove = true;
+                if (inMutex)
+                    log.warn("FastQueue.remove: Detected other mutex in remove");
+                inMutex = true;
+            }
+
+            element = first;
+
+            first = last = null;
+            size = 0;
+
+            if (checkLock) {
+                if (!inMutex)
+                    log.warn("FastQueue.remove: Cancelled by other mutex in remove");
+                inMutex = false;
+                if (!inRemove)
+                    log.warn("FastQueue.remove: Cancelled by other remove");
+                inRemove = false;
+            }
+            if (log.isTraceEnabled()) {
+                log.trace("FastQueue.remove: remove ending with size " + size);
+            }
+
+            if (timeWait) {
+                time = System.currentTimeMillis();
+            }
+        } finally {
+            lock.unlockRemove();
+        }
+        return element;
+    }
+
+}

==================================================
SingleRemoveSynchronizedAddLock.java
index f6497675be..a21c1f14ca 100644
--- a/java/org/apache/catalina/tribes/transport/bio/util/LinkObject.java
+++ b/java/org/apache/catalina/tribes/transport/bio/util/LinkObject.java
@@ -1,108 +1,108 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.transport.bio.util;
-
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.ErrorHandler;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.group.InterceptorPayload;
-
-/**
- * The class <b>LinkObject</b> implements an element
- * for a linked list, consisting of a general
- * data object and a pointer to the next element.
- *
- * @author Rainer Jung
- * @author Peter Rossbach
- * @author Filip Hanik
- * @version $Revision: 304032 $ $Date: 2005-07-27 10:11:55 -0500 (Wed, 27 Jul 2005) $
-
- */
-
-public class LinkObject {
-
-    private ChannelMessage msg;
-    private LinkObject next;
-    private byte[] key ;
-    private Member[] destination;
-    private InterceptorPayload payload;
-
-    /**
-     * Construct a new element from the data object.
-     * Sets the pointer to null.
-     *
-     * @param key The key
-     * @param payload The data object.
-     */
-    public LinkObject(ChannelMessage msg, Member[] destination, InterceptorPayload payload) {
-        this.msg = msg;
-        this.next = null;
-        this.key = msg.getUniqueId();
-        this.payload = payload;
-        this.destination = destination;
-    }
-
-    /**
-     * Set the next element.
-     * @param next The next element.
-     */
-    public void append(LinkObject next) {
-        this.next = next;
-    }
-
-    /**
-     * Get the next element.
-     * @return The next element.
-     */
-    public LinkObject next() {
-        return next;
-    }
-    
-    public void setNext(LinkObject next) {
-        this.next = next;
-    }
-
-    /**
-     * Get the data object from the element.
-     * @return The data object from the element.
-     */
-    public ChannelMessage data() {
-        return msg;
-    }
-
-    /**
-     * Get the unique message id
-     * @return the unique message id
-     */
-    public byte[] getKey() {
-        return key;
-    }
-
-    public ErrorHandler getHandler() {
-        return payload!=null?payload.getErrorHandler():null;
-    }
-
-    public InterceptorPayload getPayload() {
-        return payload;
-    }
-
-    public Member[] getDestination() {
-        return destination;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.transport.bio.util;
+
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.ErrorHandler;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.group.InterceptorPayload;
+
+/**
+ * The class <b>LinkObject</b> implements an element
+ * for a linked list, consisting of a general
+ * data object and a pointer to the next element.
+ *
+ * @author Rainer Jung
+ * @author Peter Rossbach
+ * @author Filip Hanik
+ * @version $Revision$ $Date$
+
+ */
+
+public class LinkObject {
+
+    private ChannelMessage msg;
+    private LinkObject next;
+    private byte[] key ;
+    private Member[] destination;
+    private InterceptorPayload payload;
+
+    /**
+     * Construct a new element from the data object.
+     * Sets the pointer to null.
+     *
+     * @param key The key
+     * @param payload The data object.
+     */
+    public LinkObject(ChannelMessage msg, Member[] destination, InterceptorPayload payload) {
+        this.msg = msg;
+        this.next = null;
+        this.key = msg.getUniqueId();
+        this.payload = payload;
+        this.destination = destination;
+    }
+
+    /**
+     * Set the next element.
+     * @param next The next element.
+     */
+    public void append(LinkObject next) {
+        this.next = next;
+    }
+
+    /**
+     * Get the next element.
+     * @return The next element.
+     */
+    public LinkObject next() {
+        return next;
+    }
+    
+    public void setNext(LinkObject next) {
+        this.next = next;
+    }
+
+    /**
+     * Get the data object from the element.
+     * @return The data object from the element.
+     */
+    public ChannelMessage data() {
+        return msg;
+    }
+
+    /**
+     * Get the unique message id
+     * @return the unique message id
+     */
+    public byte[] getKey() {
+        return key;
+    }
+
+    public ErrorHandler getHandler() {
+        return payload!=null?payload.getErrorHandler():null;
+    }
+
+    public InterceptorPayload getPayload() {
+        return payload;
+    }
+
+    public Member[] getDestination() {
+        return destination;
+    }
+
+}

==================================================
NioReceiver.java
index dd008c39f7..28ca2e099a 100644
--- a/java/org/apache/catalina/tribes/transport/bio/util/SingleRemoveSynchronizedAddLock.java
+++ b/java/org/apache/catalina/tribes/transport/bio/util/SingleRemoveSynchronizedAddLock.java
@@ -1,254 +1,254 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.transport.bio.util;
-
-/**
- * The class <b>SingleRemoveSynchronizedAddLock</b> implement locking for accessing the queue
- * by a single remove thread and multiple add threads.
- *
- * A thread is only allowed to be either the remove or
- * an add thread.
- *
- * The lock can either be owned by the remove thread
- * or by a single add thread.
- *
- * If the remove thread tries to get the lock,
- * but the queue is empty, it will block (poll)
- * until an add threads adds an entry to the queue and
- * releases the lock.
- * 
- * If the remove thread and add threads compete for
- * the lock and an add thread releases the lock, then
- * the remove thread will get the lock first.
- *
- * The remove thread removes all entries in the queue
- * at once and proceeses them without further
- * polling the queue.
- *
- * The lock is not reentrant, in the sense, that all
- * threads must release an owned lock before competing
- * for the lock again!
- *
- * @author Rainer Jung
- * @author Peter Rossbach
- * @version 1.1
- */
- 
-public class SingleRemoveSynchronizedAddLock {
-    
-    public SingleRemoveSynchronizedAddLock() {
-    }
-    
-    public SingleRemoveSynchronizedAddLock(boolean dataAvailable) {
-        this.dataAvailable=dataAvailable;
-    }
-    
-    /**
-     * Time in milliseconds after which threads
-     * waiting for an add lock are woken up.
-     * This is used as a safety measure in case
-     * thread notification via the unlock methods
-     * has a bug.
-     */
-    private long addWaitTimeout = 10000L;
-
-    /**
-     * Time in milliseconds after which threads
-     * waiting for a remove lock are woken up.
-     * This is used as a safety measure in case
-     * thread notification via the unlock methods
-     * has a bug.
-     */
-    private long removeWaitTimeout = 30000L;
-
-    /**
-     * The current remove thread.
-     * It is set to the remove thread polling for entries.
-     * It is reset to null when the remove thread
-     * releases the lock and proceeds processing
-     * the removed entries.
-     */
-    private Thread remover = null;
-
-    /**
-     * A flag indicating, if an add thread owns the lock.
-     */
-    private boolean addLocked = false;
-
-    /**
-     * A flag indicating, if the remove thread owns the lock.
-     */
-    private boolean removeLocked = false;
-
-    /**
-     * A flag indicating, if the remove thread is allowed
-     * to wait for the lock. The flag is set to false, when aborting.
-     */
-    private boolean removeEnabled = true;
-
-    /**
-     * A flag indicating, if the remover needs polling.
-     * It indicates, if the locked object has data available
-     * to be removed.
-     */
-    private boolean dataAvailable = false;
-
-    /**
-     * @return Value of addWaitTimeout
-     */
-    public synchronized long getAddWaitTimeout() {
-        return addWaitTimeout;
-    }
-
-    /**
-     * Set value of addWaitTimeout
-     */
-    public synchronized void setAddWaitTimeout(long timeout) {
-        addWaitTimeout = timeout;
-    }
-
-    /**
-     * @return Value of removeWaitTimeout
-     */
-    public synchronized long getRemoveWaitTimeout() {
-        return removeWaitTimeout;
-    }
-
-    /**
-     * Set value of removeWaitTimeout
-     */
-    public synchronized void setRemoveWaitTimeout(long timeout) {
-        removeWaitTimeout = timeout;
-    }
-
-    /**
-     * Check if the locked object has data available
-     * i.e. the remover can stop poling and get the lock.
-     * @return True iff the lock Object has data available.
-     */
-    public synchronized boolean isDataAvailable() {
-        return dataAvailable;
-    }
-
-    /**
-     * Check if an add thread owns the lock.
-     * @return True iff an add thread owns the lock.
-     */
-    public synchronized boolean isAddLocked() {
-        return addLocked;
-    }
-
-    /**
-     * Check if the remove thread owns the lock.
-     * @return True iff the remove thread owns the lock.
-     */
-    public synchronized boolean isRemoveLocked() {
-        return removeLocked;
-    }
-
-    /**
-     * Check if the remove thread is polling.
-     * @return True iff the remove thread is polling.
-     */
-    public synchronized boolean isRemovePolling() {
-        if ( remover != null ) {
-            return true;
-        }
-        return false;
-    }
-
-    /**
-     * Acquires the lock by an add thread and sets the add flag.
-     * If any add thread or the remove thread already acquired the lock
-     * this add thread will block until the lock is released.
-     */
-    public synchronized void lockAdd() {
-        if ( addLocked || removeLocked ) {
-            do {
-                try {
-                    wait(addWaitTimeout);
-                } catch ( InterruptedException e ) {
-                    Thread.currentThread().interrupted();
-                }
-            } while ( addLocked || removeLocked );
-        }
-        addLocked=true;
-    }
-
-    /**
-     * Acquires the lock by the remove thread and sets the remove flag.
-     * If any add thread already acquired the lock or the queue is
-     * empty, the remove thread will block until the lock is released
-     * and the queue is not empty.
-     */
-    public synchronized boolean lockRemove() {
-        removeLocked=false;
-        removeEnabled=true;
-        if ( ( addLocked || ! dataAvailable ) && removeEnabled ) {
-            remover=Thread.currentThread();
-            do {
-                try {
-                    wait(removeWaitTimeout);
-                } catch ( InterruptedException e ) {
-                    Thread.currentThread().interrupted();
-                }
-            } while ( ( addLocked || ! dataAvailable ) && removeEnabled );
-            remover=null;
-        }
-        if ( removeEnabled ) {
-            removeLocked=true;
-        } 
-        return removeLocked;
-    }
-
-    /**
-     * Releases the lock by an add thread and reset the remove flag.
-     * If the reader thread is polling, notify it.
-     */
-    public synchronized void unlockAdd(boolean dataAvailable) {
-        addLocked=false;
-        this.dataAvailable=dataAvailable;
-        if ( ( remover != null ) && ( dataAvailable || ! removeEnabled ) ) {
-            remover.interrupt();
-        } else {
-            notifyAll();
-        }
-    }
-
-    /**
-     * Releases the lock by the remove thread and reset the add flag.
-     * Notify all waiting add threads,
-     * that the lock has been released by the remove thread.
-     */
-    public synchronized void unlockRemove() {
-        removeLocked=false;
-        dataAvailable=false;
-        notifyAll();
-    }
-
-    /**
-     * Abort any polling remover thread
-     */
-    public synchronized void abortRemove() {
-        removeEnabled=false;
-        if ( remover != null ) {
-            remover.interrupt();
-        }
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.transport.bio.util;
+
+/**
+ * The class <b>SingleRemoveSynchronizedAddLock</b> implement locking for accessing the queue
+ * by a single remove thread and multiple add threads.
+ *
+ * A thread is only allowed to be either the remove or
+ * an add thread.
+ *
+ * The lock can either be owned by the remove thread
+ * or by a single add thread.
+ *
+ * If the remove thread tries to get the lock,
+ * but the queue is empty, it will block (poll)
+ * until an add threads adds an entry to the queue and
+ * releases the lock.
+ * 
+ * If the remove thread and add threads compete for
+ * the lock and an add thread releases the lock, then
+ * the remove thread will get the lock first.
+ *
+ * The remove thread removes all entries in the queue
+ * at once and proceeses them without further
+ * polling the queue.
+ *
+ * The lock is not reentrant, in the sense, that all
+ * threads must release an owned lock before competing
+ * for the lock again!
+ *
+ * @author Rainer Jung
+ * @author Peter Rossbach
+ * @version 1.1
+ */
+ 
+public class SingleRemoveSynchronizedAddLock {
+    
+    public SingleRemoveSynchronizedAddLock() {
+    }
+    
+    public SingleRemoveSynchronizedAddLock(boolean dataAvailable) {
+        this.dataAvailable=dataAvailable;
+    }
+    
+    /**
+     * Time in milliseconds after which threads
+     * waiting for an add lock are woken up.
+     * This is used as a safety measure in case
+     * thread notification via the unlock methods
+     * has a bug.
+     */
+    private long addWaitTimeout = 10000L;
+
+    /**
+     * Time in milliseconds after which threads
+     * waiting for a remove lock are woken up.
+     * This is used as a safety measure in case
+     * thread notification via the unlock methods
+     * has a bug.
+     */
+    private long removeWaitTimeout = 30000L;
+
+    /**
+     * The current remove thread.
+     * It is set to the remove thread polling for entries.
+     * It is reset to null when the remove thread
+     * releases the lock and proceeds processing
+     * the removed entries.
+     */
+    private Thread remover = null;
+
+    /**
+     * A flag indicating, if an add thread owns the lock.
+     */
+    private boolean addLocked = false;
+
+    /**
+     * A flag indicating, if the remove thread owns the lock.
+     */
+    private boolean removeLocked = false;
+
+    /**
+     * A flag indicating, if the remove thread is allowed
+     * to wait for the lock. The flag is set to false, when aborting.
+     */
+    private boolean removeEnabled = true;
+
+    /**
+     * A flag indicating, if the remover needs polling.
+     * It indicates, if the locked object has data available
+     * to be removed.
+     */
+    private boolean dataAvailable = false;
+
+    /**
+     * @return Value of addWaitTimeout
+     */
+    public synchronized long getAddWaitTimeout() {
+        return addWaitTimeout;
+    }
+
+    /**
+     * Set value of addWaitTimeout
+     */
+    public synchronized void setAddWaitTimeout(long timeout) {
+        addWaitTimeout = timeout;
+    }
+
+    /**
+     * @return Value of removeWaitTimeout
+     */
+    public synchronized long getRemoveWaitTimeout() {
+        return removeWaitTimeout;
+    }
+
+    /**
+     * Set value of removeWaitTimeout
+     */
+    public synchronized void setRemoveWaitTimeout(long timeout) {
+        removeWaitTimeout = timeout;
+    }
+
+    /**
+     * Check if the locked object has data available
+     * i.e. the remover can stop poling and get the lock.
+     * @return True iff the lock Object has data available.
+     */
+    public synchronized boolean isDataAvailable() {
+        return dataAvailable;
+    }
+
+    /**
+     * Check if an add thread owns the lock.
+     * @return True iff an add thread owns the lock.
+     */
+    public synchronized boolean isAddLocked() {
+        return addLocked;
+    }
+
+    /**
+     * Check if the remove thread owns the lock.
+     * @return True iff the remove thread owns the lock.
+     */
+    public synchronized boolean isRemoveLocked() {
+        return removeLocked;
+    }
+
+    /**
+     * Check if the remove thread is polling.
+     * @return True iff the remove thread is polling.
+     */
+    public synchronized boolean isRemovePolling() {
+        if ( remover != null ) {
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Acquires the lock by an add thread and sets the add flag.
+     * If any add thread or the remove thread already acquired the lock
+     * this add thread will block until the lock is released.
+     */
+    public synchronized void lockAdd() {
+        if ( addLocked || removeLocked ) {
+            do {
+                try {
+                    wait(addWaitTimeout);
+                } catch ( InterruptedException e ) {
+                    Thread.currentThread().interrupted();
+                }
+            } while ( addLocked || removeLocked );
+        }
+        addLocked=true;
+    }
+
+    /**
+     * Acquires the lock by the remove thread and sets the remove flag.
+     * If any add thread already acquired the lock or the queue is
+     * empty, the remove thread will block until the lock is released
+     * and the queue is not empty.
+     */
+    public synchronized boolean lockRemove() {
+        removeLocked=false;
+        removeEnabled=true;
+        if ( ( addLocked || ! dataAvailable ) && removeEnabled ) {
+            remover=Thread.currentThread();
+            do {
+                try {
+                    wait(removeWaitTimeout);
+                } catch ( InterruptedException e ) {
+                    Thread.currentThread().interrupted();
+                }
+            } while ( ( addLocked || ! dataAvailable ) && removeEnabled );
+            remover=null;
+        }
+        if ( removeEnabled ) {
+            removeLocked=true;
+        } 
+        return removeLocked;
+    }
+
+    /**
+     * Releases the lock by an add thread and reset the remove flag.
+     * If the reader thread is polling, notify it.
+     */
+    public synchronized void unlockAdd(boolean dataAvailable) {
+        addLocked=false;
+        this.dataAvailable=dataAvailable;
+        if ( ( remover != null ) && ( dataAvailable || ! removeEnabled ) ) {
+            remover.interrupt();
+        } else {
+            notifyAll();
+        }
+    }
+
+    /**
+     * Releases the lock by the remove thread and reset the add flag.
+     * Notify all waiting add threads,
+     * that the lock has been released by the remove thread.
+     */
+    public synchronized void unlockRemove() {
+        removeLocked=false;
+        dataAvailable=false;
+        notifyAll();
+    }
+
+    /**
+     * Abort any polling remover thread
+     */
+    public synchronized void abortRemove() {
+        removeEnabled=false;
+        if ( remover != null ) {
+            remover.interrupt();
+        }
+    }
+
+}

==================================================
NioReplicationThread.java
index 5d916ff0ed..fac742c534 100644
--- a/java/org/apache/catalina/tribes/transport/nio/NioReceiver.java
+++ b/java/org/apache/catalina/tribes/transport/nio/NioReceiver.java
@@ -1,383 +1,383 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.transport.nio;
-
-import java.io.IOException;
-import java.net.ServerSocket;
-import java.nio.channels.SelectableChannel;
-import java.nio.channels.SelectionKey;
-import java.nio.channels.Selector;
-import java.nio.channels.ServerSocketChannel;
-import java.nio.channels.SocketChannel;
-import java.util.Iterator;
-
-import org.apache.catalina.tribes.ChannelReceiver;
-import org.apache.catalina.tribes.io.ListenCallback;
-import org.apache.catalina.tribes.io.ObjectReader;
-import org.apache.catalina.tribes.transport.Constants;
-import org.apache.catalina.tribes.transport.ReceiverBase;
-import org.apache.catalina.tribes.transport.ThreadPool;
-import org.apache.catalina.tribes.transport.WorkerThread;
-import org.apache.catalina.tribes.util.StringManager;
-import java.util.LinkedList;
-import java.util.Set;
-import java.nio.channels.CancelledKeyException;
-
-/**
- * @author Filip Hanik
- * @version $Revision: 379904 $ $Date: 2006-02-22 15:16:25 -0600 (Wed, 22 Feb 2006) $
- */
-public class NioReceiver extends ReceiverBase implements Runnable, ChannelReceiver, ListenCallback {
-
-    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(NioReceiver.class);
-
-    /**
-     * The string manager for this package.
-     */
-    protected StringManager sm = StringManager.getManager(Constants.Package);
-
-    /**
-     * The descriptive information about this implementation.
-     */
-    private static final String info = "NioReceiver/1.0";
-
-    private Selector selector = null;
-    private ServerSocketChannel serverChannel = null;
-
-    protected LinkedList events = new LinkedList();
-//    private Object interestOpsMutex = new Object();
-
-    public NioReceiver() {
-    }
-
-    /**
-     * Return descriptive information about this implementation and the
-     * corresponding version number, in the format
-     * <code>&lt;description&gt;/&lt;version&gt;</code>.
-     */
-    public String getInfo() {
-        return (info);
-    }
-
-//    public Object getInterestOpsMutex() {
-//        return interestOpsMutex;
-//    }
-
-    public void stop() {
-        this.stopListening();
-    }
-
-    /**
-     * start cluster receiver
-     * @throws Exception
-     * @see org.apache.catalina.tribes.ClusterReceiver#start()
-     */
-    public void start() throws IOException {
-        try {
-//            setPool(new ThreadPool(interestOpsMutex, getMaxThreads(),getMinThreads(),this));
-            setPool(new ThreadPool(getMaxThreads(),getMinThreads(),this));
-        } catch (Exception x) {
-            log.fatal("ThreadPool can initilzed. Listener not started", x);
-            if ( x instanceof IOException ) throw (IOException)x;
-            else throw new IOException(x.getMessage());
-        }
-        try {
-            getBind();
-            bind();
-            Thread t = new Thread(this, "NioReceiver");
-            t.setDaemon(true);
-            t.start();
-        } catch (Exception x) {
-            log.fatal("Unable to start cluster receiver", x);
-            if ( x instanceof IOException ) throw (IOException)x;
-            else throw new IOException(x.getMessage());
-        }
-    }
-    
-    public WorkerThread getWorkerThread() {
-        NioReplicationThread thread = new NioReplicationThread(this,this);
-        thread.setUseBufferPool(this.getUseBufferPool());
-        thread.setRxBufSize(getRxBufSize());
-        thread.setOptions(getWorkerThreadOptions());
-        return thread;
-    }
-    
-    
-    
-    protected void bind() throws IOException {
-        // allocate an unbound server socket channel
-        serverChannel = ServerSocketChannel.open();
-        // Get the associated ServerSocket to bind it with
-        ServerSocket serverSocket = serverChannel.socket();
-        // create a new Selector for use below
-        selector = Selector.open();
-        // set the port the server channel will listen to
-        //serverSocket.bind(new InetSocketAddress(getBind(), getTcpListenPort()));
-        bind(serverSocket,getTcpListenPort(),getAutoBind());
-        // set non-blocking mode for the listening socket
-        serverChannel.configureBlocking(false);
-        // register the ServerSocketChannel with the Selector
-        serverChannel.register(selector, SelectionKey.OP_ACCEPT);
-        
-    }
-    
-    public void addEvent(Runnable event) {
-        if ( selector != null ) {
-            synchronized (events) {
-                events.add(event);
-            }
-            if ( log.isTraceEnabled() ) log.trace("Adding event to selector:"+event);
-            selector.wakeup();
-        }
-    }
-
-    public void events() {
-        if ( events.size() == 0 ) return;
-        synchronized (events) {
-            Runnable r = null;
-            while ( (events.size() > 0) && (r = (Runnable)events.removeFirst()) != null ) {
-                try {
-                    if ( log.isTraceEnabled() ) log.trace("Processing event in selector:"+r);
-                    r.run();
-                } catch ( Exception x ) {
-                    log.error("",x);
-                }
-            }
-            events.clear();
-        }
-    }
-    
-    public static void cancelledKey(SelectionKey key) {
-        ObjectReader reader = (ObjectReader)key.attachment();
-        if ( reader != null ) {
-            reader.setCancelled(true);
-            reader.finish();
-        }
-        key.cancel(); 
-        key.attach(null);
-        try { ((SocketChannel)key.channel()).socket().close(); } catch (IOException e) { if (log.isDebugEnabled()) log.debug("", e); }
-        try { key.channel().close(); } catch (IOException e) { if (log.isDebugEnabled()) log.debug("", e); }
-        
-    }
-    
-    protected void socketTimeouts() {
-        //timeout
-        Set keys = selector.keys();
-        long now = System.currentTimeMillis();
-        for (Iterator iter = keys.iterator(); iter.hasNext(); ) {
-            SelectionKey key = (SelectionKey) iter.next();
-            try {
-//                if (key.interestOps() == SelectionKey.OP_READ) {
-//                    //only timeout sockets that we are waiting for a read from
-//                    ObjectReader ka = (ObjectReader) key.attachment();
-//                    long delta = now - ka.getLastAccess();
-//                    if (delta > (long) getTimeout()) {
-//                        cancelledKey(key);
-//                    }
-//                }
-//                else
-                if ( key.interestOps() == 0 ) {
-                    //check for keys that didn't make it in.
-                    ObjectReader ka = (ObjectReader) key.attachment();
-                    if ( ka != null ) {
-                        long delta = now - ka.getLastAccess();
-                        if (delta > (long) getTimeout() && (!ka.isAccessed())) {
-                            log.warn("Channel key is registered, but has had no interest ops for the last "+getTimeout()+" ms. (cancelled:"+ka.isCancelled()+"):"+key+" last access:"+new java.sql.Timestamp(ka.getLastAccess()));
-//                            System.out.println("Interest:"+key.interestOps());
-//                            System.out.println("Ready Ops:"+key.readyOps());
-//                            System.out.println("Valid:"+key.isValid());
-                            ka.setLastAccess(now);
-                            //key.interestOps(SelectionKey.OP_READ);
-                        }//end if
-                    } else {
-                        cancelledKey(key);
-                    }//end if
-                }//end if
-            }catch ( CancelledKeyException ckx ) {
-                cancelledKey(key);
-            }
-        }
-    }
-
-
-    /**
-     * get data from channel and store in byte array
-     * send it to cluster
-     * @throws IOException
-     * @throws java.nio.channels.ClosedChannelException
-     */
-    protected void listen() throws Exception {
-        if (doListen()) {
-            log.warn("ServerSocketChannel already started");
-            return;
-        }
-        
-        setListen(true);
-
-        while (doListen() && selector != null) {
-            // this may block for a long time, upon return the
-            // selected set contains keys of the ready channels
-            try {
-                events();
-                socketTimeouts();
-                int n = selector.select(getTcpSelectorTimeout());
-                if (n == 0) {
-                    //there is a good chance that we got here
-                    //because the TcpReplicationThread called
-                    //selector wakeup().
-                    //if that happens, we must ensure that that
-                    //thread has enough time to call interestOps
-//                    synchronized (interestOpsMutex) {
-                        //if we got the lock, means there are no
-                        //keys trying to register for the
-                        //interestOps method
-//                    }
-                    continue; // nothing to do
-                }
-                // get an iterator over the set of selected keys
-                Iterator it = selector.selectedKeys().iterator();
-                // look at each key in the selected set
-                while (it.hasNext()) {
-                    SelectionKey key = (SelectionKey) it.next();
-                    // Is a new connection coming in?
-                    if (key.isAcceptable()) {
-                        ServerSocketChannel server = (ServerSocketChannel) key.channel();
-                        SocketChannel channel = server.accept();
-                        channel.socket().setReceiveBufferSize(getRxBufSize());
-                        channel.socket().setSendBufferSize(getTxBufSize());
-                        channel.socket().setTcpNoDelay(getTcpNoDelay());
-                        channel.socket().setKeepAlive(getSoKeepAlive());
-                        channel.socket().setOOBInline(getOoBInline());
-                        channel.socket().setReuseAddress(getSoReuseAddress());
-                        channel.socket().setSoLinger(getSoLingerOn(),getSoLingerTime());
-                        channel.socket().setTrafficClass(getSoTrafficClass());
-                        channel.socket().setSoTimeout(getTimeout());
-                        Object attach = new ObjectReader(channel);
-                        registerChannel(selector,
-                                        channel,
-                                        SelectionKey.OP_READ,
-                                        attach);
-                    }
-                    // is there data to read on this channel?
-                    if (key.isReadable()) {
-                        readDataFromSocket(key);
-                    } else {
-                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
-                    }
-
-                    // remove key from selected set, it's been handled
-                    it.remove();
-                }
-            } catch (java.nio.channels.ClosedSelectorException cse) {
-                // ignore is normal at shutdown or stop listen socket
-            } catch (java.nio.channels.CancelledKeyException nx) {
-                log.warn("Replication client disconnected, error when polling key. Ignoring client.");
-            } catch (Throwable x) {
-                try {
-                    log.error("Unable to process request in NioReceiver", x);
-                }catch ( Throwable tx ) {
-                    //in case an out of memory error, will affect the logging framework as well
-                    tx.printStackTrace();
-                }
-            }
-
-        }
-        serverChannel.close();
-        if (selector != null)
-            selector.close();
-    }
-
-    
-
-    /**
-     * Close Selector.
-     *
-     * @see org.apache.catalina.tribes.transport.ClusterReceiverBase#stopListening()
-     */
-    protected void stopListening() {
-        // Bugzilla 37529: http://issues.apache.org/bugzilla/show_bug.cgi?id=37529
-        setListen(false);
-        if (selector != null) {
-            try {
-                for (int i = 0; i < getMaxThreads(); i++) {
-                    selector.wakeup();
-                }
-                selector.close();
-            } catch (Exception x) {
-                log.error("Unable to close cluster receiver selector.", x);
-            } finally {
-                selector = null;
-            }
-        }
-    }
-
-    // ----------------------------------------------------------
-
-    /**
-     * Register the given channel with the given selector for
-     * the given operations of interest
-     */
-    protected void registerChannel(Selector selector,
-                                   SelectableChannel channel,
-                                   int ops,
-                                   Object attach) throws Exception {
-        if (channel == null)return; // could happen
-        // set the new channel non-blocking
-        channel.configureBlocking(false);
-        // register it with the selector
-        channel.register(selector, ops, attach);
-    }
-
-    /**
-     * Start thread and listen
-     */
-    public void run() {
-        try {
-            listen();
-        } catch (Exception x) {
-            log.error("Unable to run replication listener.", x);
-        }
-    }
-
-    // ----------------------------------------------------------
-
-    /**
-     * Sample data handler method for a channel with data ready to read.
-     * @param key A SelectionKey object associated with a channel
-     *  determined by the selector to be ready for reading.  If the
-     *  channel returns an EOF condition, it is closed here, which
-     *  automatically invalidates the associated key.  The selector
-     *  will then de-register the channel on the next select call.
-     */
-    protected void readDataFromSocket(SelectionKey key) throws Exception {
-        NioReplicationThread worker = (NioReplicationThread) getPool().getWorker();
-        if (worker == null) {
-            // No threads available, do nothing, the selection
-            // loop will keep calling this method until a
-            // thread becomes available, the thread pool itself has a waiting mechanism
-            // so we will not wait here.
-            if (log.isDebugEnabled())
-                log.debug("No TcpReplicationThread available");
-        } else {
-            // invoking this wakes up the worker thread then returns
-            worker.serviceChannel(key);
-        }
-    }
-
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.transport.nio;
+
+import java.io.IOException;
+import java.net.ServerSocket;
+import java.nio.channels.SelectableChannel;
+import java.nio.channels.SelectionKey;
+import java.nio.channels.Selector;
+import java.nio.channels.ServerSocketChannel;
+import java.nio.channels.SocketChannel;
+import java.util.Iterator;
+
+import org.apache.catalina.tribes.ChannelReceiver;
+import org.apache.catalina.tribes.io.ListenCallback;
+import org.apache.catalina.tribes.io.ObjectReader;
+import org.apache.catalina.tribes.transport.Constants;
+import org.apache.catalina.tribes.transport.ReceiverBase;
+import org.apache.catalina.tribes.transport.ThreadPool;
+import org.apache.catalina.tribes.transport.WorkerThread;
+import org.apache.catalina.tribes.util.StringManager;
+import java.util.LinkedList;
+import java.util.Set;
+import java.nio.channels.CancelledKeyException;
+
+/**
+ * @author Filip Hanik
+ * @version $Revision$ $Date$
+ */
+public class NioReceiver extends ReceiverBase implements Runnable, ChannelReceiver, ListenCallback {
+
+    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(NioReceiver.class);
+
+    /**
+     * The string manager for this package.
+     */
+    protected StringManager sm = StringManager.getManager(Constants.Package);
+
+    /**
+     * The descriptive information about this implementation.
+     */
+    private static final String info = "NioReceiver/1.0";
+
+    private Selector selector = null;
+    private ServerSocketChannel serverChannel = null;
+
+    protected LinkedList events = new LinkedList();
+//    private Object interestOpsMutex = new Object();
+
+    public NioReceiver() {
+    }
+
+    /**
+     * Return descriptive information about this implementation and the
+     * corresponding version number, in the format
+     * <code>&lt;description&gt;/&lt;version&gt;</code>.
+     */
+    public String getInfo() {
+        return (info);
+    }
+
+//    public Object getInterestOpsMutex() {
+//        return interestOpsMutex;
+//    }
+
+    public void stop() {
+        this.stopListening();
+    }
+
+    /**
+     * start cluster receiver
+     * @throws Exception
+     * @see org.apache.catalina.tribes.ClusterReceiver#start()
+     */
+    public void start() throws IOException {
+        try {
+//            setPool(new ThreadPool(interestOpsMutex, getMaxThreads(),getMinThreads(),this));
+            setPool(new ThreadPool(getMaxThreads(),getMinThreads(),this));
+        } catch (Exception x) {
+            log.fatal("ThreadPool can initilzed. Listener not started", x);
+            if ( x instanceof IOException ) throw (IOException)x;
+            else throw new IOException(x.getMessage());
+        }
+        try {
+            getBind();
+            bind();
+            Thread t = new Thread(this, "NioReceiver");
+            t.setDaemon(true);
+            t.start();
+        } catch (Exception x) {
+            log.fatal("Unable to start cluster receiver", x);
+            if ( x instanceof IOException ) throw (IOException)x;
+            else throw new IOException(x.getMessage());
+        }
+    }
+    
+    public WorkerThread getWorkerThread() {
+        NioReplicationThread thread = new NioReplicationThread(this,this);
+        thread.setUseBufferPool(this.getUseBufferPool());
+        thread.setRxBufSize(getRxBufSize());
+        thread.setOptions(getWorkerThreadOptions());
+        return thread;
+    }
+    
+    
+    
+    protected void bind() throws IOException {
+        // allocate an unbound server socket channel
+        serverChannel = ServerSocketChannel.open();
+        // Get the associated ServerSocket to bind it with
+        ServerSocket serverSocket = serverChannel.socket();
+        // create a new Selector for use below
+        selector = Selector.open();
+        // set the port the server channel will listen to
+        //serverSocket.bind(new InetSocketAddress(getBind(), getTcpListenPort()));
+        bind(serverSocket,getTcpListenPort(),getAutoBind());
+        // set non-blocking mode for the listening socket
+        serverChannel.configureBlocking(false);
+        // register the ServerSocketChannel with the Selector
+        serverChannel.register(selector, SelectionKey.OP_ACCEPT);
+        
+    }
+    
+    public void addEvent(Runnable event) {
+        if ( selector != null ) {
+            synchronized (events) {
+                events.add(event);
+            }
+            if ( log.isTraceEnabled() ) log.trace("Adding event to selector:"+event);
+            selector.wakeup();
+        }
+    }
+
+    public void events() {
+        if ( events.size() == 0 ) return;
+        synchronized (events) {
+            Runnable r = null;
+            while ( (events.size() > 0) && (r = (Runnable)events.removeFirst()) != null ) {
+                try {
+                    if ( log.isTraceEnabled() ) log.trace("Processing event in selector:"+r);
+                    r.run();
+                } catch ( Exception x ) {
+                    log.error("",x);
+                }
+            }
+            events.clear();
+        }
+    }
+    
+    public static void cancelledKey(SelectionKey key) {
+        ObjectReader reader = (ObjectReader)key.attachment();
+        if ( reader != null ) {
+            reader.setCancelled(true);
+            reader.finish();
+        }
+        key.cancel(); 
+        key.attach(null);
+        try { ((SocketChannel)key.channel()).socket().close(); } catch (IOException e) { if (log.isDebugEnabled()) log.debug("", e); }
+        try { key.channel().close(); } catch (IOException e) { if (log.isDebugEnabled()) log.debug("", e); }
+        
+    }
+    
+    protected void socketTimeouts() {
+        //timeout
+        Set keys = selector.keys();
+        long now = System.currentTimeMillis();
+        for (Iterator iter = keys.iterator(); iter.hasNext(); ) {
+            SelectionKey key = (SelectionKey) iter.next();
+            try {
+//                if (key.interestOps() == SelectionKey.OP_READ) {
+//                    //only timeout sockets that we are waiting for a read from
+//                    ObjectReader ka = (ObjectReader) key.attachment();
+//                    long delta = now - ka.getLastAccess();
+//                    if (delta > (long) getTimeout()) {
+//                        cancelledKey(key);
+//                    }
+//                }
+//                else
+                if ( key.interestOps() == 0 ) {
+                    //check for keys that didn't make it in.
+                    ObjectReader ka = (ObjectReader) key.attachment();
+                    if ( ka != null ) {
+                        long delta = now - ka.getLastAccess();
+                        if (delta > (long) getTimeout() && (!ka.isAccessed())) {
+                            log.warn("Channel key is registered, but has had no interest ops for the last "+getTimeout()+" ms. (cancelled:"+ka.isCancelled()+"):"+key+" last access:"+new java.sql.Timestamp(ka.getLastAccess()));
+//                            System.out.println("Interest:"+key.interestOps());
+//                            System.out.println("Ready Ops:"+key.readyOps());
+//                            System.out.println("Valid:"+key.isValid());
+                            ka.setLastAccess(now);
+                            //key.interestOps(SelectionKey.OP_READ);
+                        }//end if
+                    } else {
+                        cancelledKey(key);
+                    }//end if
+                }//end if
+            }catch ( CancelledKeyException ckx ) {
+                cancelledKey(key);
+            }
+        }
+    }
+
+
+    /**
+     * get data from channel and store in byte array
+     * send it to cluster
+     * @throws IOException
+     * @throws java.nio.channels.ClosedChannelException
+     */
+    protected void listen() throws Exception {
+        if (doListen()) {
+            log.warn("ServerSocketChannel already started");
+            return;
+        }
+        
+        setListen(true);
+
+        while (doListen() && selector != null) {
+            // this may block for a long time, upon return the
+            // selected set contains keys of the ready channels
+            try {
+                events();
+                socketTimeouts();
+                int n = selector.select(getTcpSelectorTimeout());
+                if (n == 0) {
+                    //there is a good chance that we got here
+                    //because the TcpReplicationThread called
+                    //selector wakeup().
+                    //if that happens, we must ensure that that
+                    //thread has enough time to call interestOps
+//                    synchronized (interestOpsMutex) {
+                        //if we got the lock, means there are no
+                        //keys trying to register for the
+                        //interestOps method
+//                    }
+                    continue; // nothing to do
+                }
+                // get an iterator over the set of selected keys
+                Iterator it = selector.selectedKeys().iterator();
+                // look at each key in the selected set
+                while (it.hasNext()) {
+                    SelectionKey key = (SelectionKey) it.next();
+                    // Is a new connection coming in?
+                    if (key.isAcceptable()) {
+                        ServerSocketChannel server = (ServerSocketChannel) key.channel();
+                        SocketChannel channel = server.accept();
+                        channel.socket().setReceiveBufferSize(getRxBufSize());
+                        channel.socket().setSendBufferSize(getTxBufSize());
+                        channel.socket().setTcpNoDelay(getTcpNoDelay());
+                        channel.socket().setKeepAlive(getSoKeepAlive());
+                        channel.socket().setOOBInline(getOoBInline());
+                        channel.socket().setReuseAddress(getSoReuseAddress());
+                        channel.socket().setSoLinger(getSoLingerOn(),getSoLingerTime());
+                        channel.socket().setTrafficClass(getSoTrafficClass());
+                        channel.socket().setSoTimeout(getTimeout());
+                        Object attach = new ObjectReader(channel);
+                        registerChannel(selector,
+                                        channel,
+                                        SelectionKey.OP_READ,
+                                        attach);
+                    }
+                    // is there data to read on this channel?
+                    if (key.isReadable()) {
+                        readDataFromSocket(key);
+                    } else {
+                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
+                    }
+
+                    // remove key from selected set, it's been handled
+                    it.remove();
+                }
+            } catch (java.nio.channels.ClosedSelectorException cse) {
+                // ignore is normal at shutdown or stop listen socket
+            } catch (java.nio.channels.CancelledKeyException nx) {
+                log.warn("Replication client disconnected, error when polling key. Ignoring client.");
+            } catch (Throwable x) {
+                try {
+                    log.error("Unable to process request in NioReceiver", x);
+                }catch ( Throwable tx ) {
+                    //in case an out of memory error, will affect the logging framework as well
+                    tx.printStackTrace();
+                }
+            }
+
+        }
+        serverChannel.close();
+        if (selector != null)
+            selector.close();
+    }
+
+    
+
+    /**
+     * Close Selector.
+     *
+     * @see org.apache.catalina.tribes.transport.ClusterReceiverBase#stopListening()
+     */
+    protected void stopListening() {
+        // Bugzilla 37529: http://issues.apache.org/bugzilla/show_bug.cgi?id=37529
+        setListen(false);
+        if (selector != null) {
+            try {
+                for (int i = 0; i < getMaxThreads(); i++) {
+                    selector.wakeup();
+                }
+                selector.close();
+            } catch (Exception x) {
+                log.error("Unable to close cluster receiver selector.", x);
+            } finally {
+                selector = null;
+            }
+        }
+    }
+
+    // ----------------------------------------------------------
+
+    /**
+     * Register the given channel with the given selector for
+     * the given operations of interest
+     */
+    protected void registerChannel(Selector selector,
+                                   SelectableChannel channel,
+                                   int ops,
+                                   Object attach) throws Exception {
+        if (channel == null)return; // could happen
+        // set the new channel non-blocking
+        channel.configureBlocking(false);
+        // register it with the selector
+        channel.register(selector, ops, attach);
+    }
+
+    /**
+     * Start thread and listen
+     */
+    public void run() {
+        try {
+            listen();
+        } catch (Exception x) {
+            log.error("Unable to run replication listener.", x);
+        }
+    }
+
+    // ----------------------------------------------------------
+
+    /**
+     * Sample data handler method for a channel with data ready to read.
+     * @param key A SelectionKey object associated with a channel
+     *  determined by the selector to be ready for reading.  If the
+     *  channel returns an EOF condition, it is closed here, which
+     *  automatically invalidates the associated key.  The selector
+     *  will then de-register the channel on the next select call.
+     */
+    protected void readDataFromSocket(SelectionKey key) throws Exception {
+        NioReplicationThread worker = (NioReplicationThread) getPool().getWorker();
+        if (worker == null) {
+            // No threads available, do nothing, the selection
+            // loop will keep calling this method until a
+            // thread becomes available, the thread pool itself has a waiting mechanism
+            // so we will not wait here.
+            if (log.isDebugEnabled())
+                log.debug("No TcpReplicationThread available");
+        } else {
+            // invoking this wakes up the worker thread then returns
+            worker.serviceChannel(key);
+        }
+    }
+
+
+}

==================================================
NioSender.java
index 44308e9e5b..7dac62b6c8 100644
--- a/java/org/apache/catalina/tribes/transport/nio/NioReplicationThread.java
+++ b/java/org/apache/catalina/tribes/transport/nio/NioReplicationThread.java
@@ -1,311 +1,311 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.transport.nio;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.channels.SelectionKey;
-import java.nio.channels.SocketChannel;
-
-import org.apache.catalina.tribes.io.ObjectReader;
-import org.apache.catalina.tribes.transport.Constants;
-import org.apache.catalina.tribes.transport.WorkerThread;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.io.ListenCallback;
-import org.apache.catalina.tribes.io.ChannelData;
-import org.apache.catalina.tribes.io.BufferPool;
-import java.nio.channels.CancelledKeyException;
-import org.apache.catalina.tribes.UniqueId;
-import org.apache.catalina.tribes.RemoteProcessException;
-import org.apache.catalina.tribes.util.Logs;
-
-/**
- * A worker thread class which can drain channels and echo-back the input. Each
- * instance is constructed with a reference to the owning thread pool object.
- * When started, the thread loops forever waiting to be awakened to service the
- * channel associated with a SelectionKey object. The worker is tasked by
- * calling its serviceChannel() method with a SelectionKey object. The
- * serviceChannel() method stores the key reference in the thread object then
- * calls notify() to wake it up. When the channel has been drained, the worker
- * thread returns itself to its parent pool.
- * 
- * @author Filip Hanik
- * 
- * @version $Revision: 378050 $, $Date: 2006-02-15 12:30:02 -0600 (Wed, 15 Feb 2006) $
- */
-public class NioReplicationThread extends WorkerThread {
-    
-    private static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( NioReplicationThread.class );
-    
-    private ByteBuffer buffer = null;
-    private SelectionKey key;
-    private int rxBufSize;
-    private NioReceiver receiver;
-    public NioReplicationThread (ListenCallback callback, NioReceiver receiver)
-    {
-        super(callback);
-        this.receiver = receiver;
-    }
-
-    // loop forever waiting for work to do
-    public synchronized void run() { 
-        this.notify();
-        if ( (getOptions() & OPTION_DIRECT_BUFFER) == OPTION_DIRECT_BUFFER ) {
-            buffer = ByteBuffer.allocateDirect(getRxBufSize());
-        }else {
-            buffer = ByteBuffer.allocate (getRxBufSize());
-        }
-        while (isDoRun()) {
-            try {
-                // sleep and release object lock
-                this.wait();
-            } catch (InterruptedException e) {
-                if(log.isInfoEnabled()) log.info("TCP worker thread interrupted in cluster",e);
-                // clear interrupt status
-                Thread.interrupted();
-            }
-            if (key == null) {
-                continue;	// just in case
-            }
-            if ( log.isTraceEnabled() ) 
-                log.trace("Servicing key:"+key);
-
-            try {
-                ObjectReader reader = (ObjectReader)key.attachment();
-                if ( reader == null ) {
-                    if ( log.isTraceEnabled() ) 
-                        log.trace("No object reader, cancelling:"+key);
-                    cancelKey(key);
-                } else {
-                    if ( log.isTraceEnabled() ) 
-                        log.trace("Draining channel:"+key);
-
-                    drainChannel(key, reader);
-                }
-            } catch (Exception e) {
-                //this is common, since the sockets on the other
-                //end expire after a certain time.
-                if ( e instanceof CancelledKeyException ) {
-                    //do nothing
-                } else if ( e instanceof IOException ) {
-                    //dont spew out stack traces for IO exceptions unless debug is enabled.
-                    if (log.isDebugEnabled()) log.debug ("IOException in replication worker, unable to drain channel. Probable cause: Keep alive socket closed["+e.getMessage()+"].", e);
-                    else log.warn ("IOException in replication worker, unable to drain channel. Probable cause: Keep alive socket closed["+e.getMessage()+"].");
-                } else if ( log.isErrorEnabled() ) {
-                    //this is a real error, log it.
-                    log.error("Exception caught in TcpReplicationThread.drainChannel.",e);
-                } 
-                cancelKey(key);
-            } finally {
-                
-            }
-            key = null;
-            // done, ready for more, return to pool
-            getPool().returnWorker (this);
-        }
-    }
-
-    /**
-     * Called to initiate a unit of work by this worker thread
-     * on the provided SelectionKey object.  This method is
-     * synchronized, as is the run() method, so only one key
-     * can be serviced at a given time.
-     * Before waking the worker thread, and before returning
-     * to the main selection loop, this key's interest set is
-     * updated to remove OP_READ.  This will cause the selector
-     * to ignore read-readiness for this channel while the
-     * worker thread is servicing it.
-     */
-    public synchronized void serviceChannel (SelectionKey key) {
-        if ( log.isTraceEnabled() ) 
-            log.trace("About to service key:"+key);
-        ObjectReader reader = (ObjectReader)key.attachment();
-        if ( reader != null ) reader.setLastAccess(System.currentTimeMillis());
-        this.key = key;
-        key.interestOps (key.interestOps() & (~SelectionKey.OP_READ));
-        key.interestOps (key.interestOps() & (~SelectionKey.OP_WRITE));
-        this.notify();		// awaken the thread
-    }
-
-    /**
-     * The actual code which drains the channel associated with
-     * the given key.  This method assumes the key has been
-     * modified prior to invocation to turn off selection
-     * interest in OP_READ.  When this method completes it
-     * re-enables OP_READ and calls wakeup() on the selector
-     * so the selector will resume watching this channel.
-     */
-    protected void drainChannel (final SelectionKey key, ObjectReader reader) throws Exception {
-        reader.setLastAccess(System.currentTimeMillis());
-        reader.access();
-        SocketChannel channel = (SocketChannel) key.channel();
-        int count;
-        buffer.clear();			// make buffer empty
-
-        // loop while data available, channel is non-blocking
-        while ((count = channel.read (buffer)) > 0) {
-            buffer.flip();		// make buffer readable
-            if ( buffer.hasArray() ) 
-                reader.append(buffer.array(),0,count,false);
-            else 
-                reader.append(buffer,count,false);
-            buffer.clear();		// make buffer empty
-            //do we have at least one package?
-            if ( reader.hasPackage() ) break;
-        }
-
-        int pkgcnt = reader.count();
-        
-        if (count < 0 && pkgcnt == 0 ) {
-            //end of stream, and no more packages to process
-            remoteEof(key);
-            return;
-        }
-        
-        ChannelMessage[] msgs = pkgcnt == 0? ChannelData.EMPTY_DATA_ARRAY : reader.execute();
-        
-        registerForRead(key,reader);//register to read new data, before we send it off to avoid dead locks
-        
-        for ( int i=0; i<msgs.length; i++ ) {
-            /**
-             * Use send ack here if you want to ack the request to the remote 
-             * server before completing the request
-             * This is considered an asynchronized request
-             */
-            if (ChannelData.sendAckAsync(msgs[i].getOptions())) sendAck(key,channel,Constants.ACK_COMMAND);
-            try {
-                if ( Logs.MESSAGES.isTraceEnabled() ) {
-                    try {
-                        Logs.MESSAGES.trace("NioReplicationThread - Received msg:" + new UniqueId(msgs[i].getUniqueId()) + " at " + new java.sql.Timestamp(System.currentTimeMillis()));
-                    }catch ( Throwable t ) {}
-                }
-                //process the message
-                getCallback().messageDataReceived(msgs[i]);
-                /**
-                 * Use send ack here if you want the request to complete on this 
-                 * server before sending the ack to the remote server
-                 * This is considered a synchronized request
-                 */
-                if (ChannelData.sendAckSync(msgs[i].getOptions())) sendAck(key,channel,Constants.ACK_COMMAND);
-            }catch ( RemoteProcessException e ) {
-                if ( log.isDebugEnabled() ) log.error("Processing of cluster message failed.",e);
-                if (ChannelData.sendAckSync(msgs[i].getOptions())) sendAck(key,channel,Constants.FAIL_ACK_COMMAND);
-            }catch ( Exception e ) {
-                log.error("Processing of cluster message failed.",e);
-                if (ChannelData.sendAckSync(msgs[i].getOptions())) sendAck(key,channel,Constants.FAIL_ACK_COMMAND);
-            }
-            if ( getUseBufferPool() ) {
-                BufferPool.getBufferPool().returnBuffer(msgs[i].getMessage());
-                msgs[i].setMessage(null);
-            }
-        }                        
-        
-        if (count < 0) {
-            remoteEof(key);
-            return;
-        }
-    }
-
-    private void remoteEof(SelectionKey key) {
-        // close channel on EOF, invalidates the key
-        if ( log.isDebugEnabled() ) log.debug("Channel closed on the remote end, disconnecting");
-        cancelKey(key);
-    }
-
-    protected void registerForRead(final SelectionKey key, ObjectReader reader) {
-        if ( log.isTraceEnabled() ) 
-            log.trace("Adding key for read event:"+key);
-        reader.finish();
-        //register our OP_READ interest
-        Runnable r = new Runnable() {
-            public void run() {
-                try {
-                    if (key.isValid()) {
-                        // cycle the selector so this key is active again
-                        key.selector().wakeup();
-                        // resume interest in OP_READ, OP_WRITE
-                        int resumeOps = key.interestOps() | SelectionKey.OP_READ;
-                        key.interestOps(resumeOps);
-                        if ( log.isTraceEnabled() ) 
-                            log.trace("Registering key for read:"+key);
-                    }
-                } catch (CancelledKeyException ckx ) {
-                    NioReceiver.cancelledKey(key);
-                    if ( log.isTraceEnabled() ) 
-                        log.trace("CKX Cancelling key:"+key);
-
-                } catch (Exception x) {
-                    log.error("Error registering key for read:"+key,x);
-                }
-            }
-        };
-        receiver.addEvent(r);
-    }
-
-    private void cancelKey(final SelectionKey key) {
-        if ( log.isTraceEnabled() ) 
-            log.trace("Adding key for cancel event:"+key);
-
-        ObjectReader reader = (ObjectReader)key.attachment();
-        if ( reader != null ) {
-            reader.setCancelled(true);
-            reader.finish();
-        }
-        Runnable cx = new Runnable() {
-            public void run() {
-                if ( log.isTraceEnabled() ) 
-                    log.trace("Cancelling key:"+key);
-
-                NioReceiver.cancelledKey(key);
-            }
-        };
-        receiver.addEvent(cx);
-    }
-    
-    
-
-
-
-    /**
-     * send a reply-acknowledgement (6,2,3)
-     * @param key
-     * @param channel
-     */
-    protected void sendAck(SelectionKey key, SocketChannel channel, byte[] command) {
-        
-        try {
-            ByteBuffer buf = ByteBuffer.wrap(command);
-            int total = 0;
-            while ( total < command.length ) {
-                total += channel.write(buf);
-            }
-            if (log.isTraceEnabled()) {
-                log.trace("ACK sent to " + channel.socket().getPort());
-            }
-        } catch ( java.io.IOException x ) {
-            log.warn("Unable to send ACK back through channel, channel disconnected?: "+x.getMessage());
-        }
-    }
-
-    public void setRxBufSize(int rxBufSize) {
-        this.rxBufSize = rxBufSize;
-    }
-
-    public int getRxBufSize() {
-        return rxBufSize;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.transport.nio;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.SelectionKey;
+import java.nio.channels.SocketChannel;
+
+import org.apache.catalina.tribes.io.ObjectReader;
+import org.apache.catalina.tribes.transport.Constants;
+import org.apache.catalina.tribes.transport.WorkerThread;
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.io.ListenCallback;
+import org.apache.catalina.tribes.io.ChannelData;
+import org.apache.catalina.tribes.io.BufferPool;
+import java.nio.channels.CancelledKeyException;
+import org.apache.catalina.tribes.UniqueId;
+import org.apache.catalina.tribes.RemoteProcessException;
+import org.apache.catalina.tribes.util.Logs;
+
+/**
+ * A worker thread class which can drain channels and echo-back the input. Each
+ * instance is constructed with a reference to the owning thread pool object.
+ * When started, the thread loops forever waiting to be awakened to service the
+ * channel associated with a SelectionKey object. The worker is tasked by
+ * calling its serviceChannel() method with a SelectionKey object. The
+ * serviceChannel() method stores the key reference in the thread object then
+ * calls notify() to wake it up. When the channel has been drained, the worker
+ * thread returns itself to its parent pool.
+ * 
+ * @author Filip Hanik
+ * 
+ * @version $Revision$, $Date$
+ */
+public class NioReplicationThread extends WorkerThread {
+    
+    private static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( NioReplicationThread.class );
+    
+    private ByteBuffer buffer = null;
+    private SelectionKey key;
+    private int rxBufSize;
+    private NioReceiver receiver;
+    public NioReplicationThread (ListenCallback callback, NioReceiver receiver)
+    {
+        super(callback);
+        this.receiver = receiver;
+    }
+
+    // loop forever waiting for work to do
+    public synchronized void run() { 
+        this.notify();
+        if ( (getOptions() & OPTION_DIRECT_BUFFER) == OPTION_DIRECT_BUFFER ) {
+            buffer = ByteBuffer.allocateDirect(getRxBufSize());
+        }else {
+            buffer = ByteBuffer.allocate (getRxBufSize());
+        }
+        while (isDoRun()) {
+            try {
+                // sleep and release object lock
+                this.wait();
+            } catch (InterruptedException e) {
+                if(log.isInfoEnabled()) log.info("TCP worker thread interrupted in cluster",e);
+                // clear interrupt status
+                Thread.interrupted();
+            }
+            if (key == null) {
+                continue;	// just in case
+            }
+            if ( log.isTraceEnabled() ) 
+                log.trace("Servicing key:"+key);
+
+            try {
+                ObjectReader reader = (ObjectReader)key.attachment();
+                if ( reader == null ) {
+                    if ( log.isTraceEnabled() ) 
+                        log.trace("No object reader, cancelling:"+key);
+                    cancelKey(key);
+                } else {
+                    if ( log.isTraceEnabled() ) 
+                        log.trace("Draining channel:"+key);
+
+                    drainChannel(key, reader);
+                }
+            } catch (Exception e) {
+                //this is common, since the sockets on the other
+                //end expire after a certain time.
+                if ( e instanceof CancelledKeyException ) {
+                    //do nothing
+                } else if ( e instanceof IOException ) {
+                    //dont spew out stack traces for IO exceptions unless debug is enabled.
+                    if (log.isDebugEnabled()) log.debug ("IOException in replication worker, unable to drain channel. Probable cause: Keep alive socket closed["+e.getMessage()+"].", e);
+                    else log.warn ("IOException in replication worker, unable to drain channel. Probable cause: Keep alive socket closed["+e.getMessage()+"].");
+                } else if ( log.isErrorEnabled() ) {
+                    //this is a real error, log it.
+                    log.error("Exception caught in TcpReplicationThread.drainChannel.",e);
+                } 
+                cancelKey(key);
+            } finally {
+                
+            }
+            key = null;
+            // done, ready for more, return to pool
+            getPool().returnWorker (this);
+        }
+    }
+
+    /**
+     * Called to initiate a unit of work by this worker thread
+     * on the provided SelectionKey object.  This method is
+     * synchronized, as is the run() method, so only one key
+     * can be serviced at a given time.
+     * Before waking the worker thread, and before returning
+     * to the main selection loop, this key's interest set is
+     * updated to remove OP_READ.  This will cause the selector
+     * to ignore read-readiness for this channel while the
+     * worker thread is servicing it.
+     */
+    public synchronized void serviceChannel (SelectionKey key) {
+        if ( log.isTraceEnabled() ) 
+            log.trace("About to service key:"+key);
+        ObjectReader reader = (ObjectReader)key.attachment();
+        if ( reader != null ) reader.setLastAccess(System.currentTimeMillis());
+        this.key = key;
+        key.interestOps (key.interestOps() & (~SelectionKey.OP_READ));
+        key.interestOps (key.interestOps() & (~SelectionKey.OP_WRITE));
+        this.notify();		// awaken the thread
+    }
+
+    /**
+     * The actual code which drains the channel associated with
+     * the given key.  This method assumes the key has been
+     * modified prior to invocation to turn off selection
+     * interest in OP_READ.  When this method completes it
+     * re-enables OP_READ and calls wakeup() on the selector
+     * so the selector will resume watching this channel.
+     */
+    protected void drainChannel (final SelectionKey key, ObjectReader reader) throws Exception {
+        reader.setLastAccess(System.currentTimeMillis());
+        reader.access();
+        SocketChannel channel = (SocketChannel) key.channel();
+        int count;
+        buffer.clear();			// make buffer empty
+
+        // loop while data available, channel is non-blocking
+        while ((count = channel.read (buffer)) > 0) {
+            buffer.flip();		// make buffer readable
+            if ( buffer.hasArray() ) 
+                reader.append(buffer.array(),0,count,false);
+            else 
+                reader.append(buffer,count,false);
+            buffer.clear();		// make buffer empty
+            //do we have at least one package?
+            if ( reader.hasPackage() ) break;
+        }
+
+        int pkgcnt = reader.count();
+        
+        if (count < 0 && pkgcnt == 0 ) {
+            //end of stream, and no more packages to process
+            remoteEof(key);
+            return;
+        }
+        
+        ChannelMessage[] msgs = pkgcnt == 0? ChannelData.EMPTY_DATA_ARRAY : reader.execute();
+        
+        registerForRead(key,reader);//register to read new data, before we send it off to avoid dead locks
+        
+        for ( int i=0; i<msgs.length; i++ ) {
+            /**
+             * Use send ack here if you want to ack the request to the remote 
+             * server before completing the request
+             * This is considered an asynchronized request
+             */
+            if (ChannelData.sendAckAsync(msgs[i].getOptions())) sendAck(key,channel,Constants.ACK_COMMAND);
+            try {
+                if ( Logs.MESSAGES.isTraceEnabled() ) {
+                    try {
+                        Logs.MESSAGES.trace("NioReplicationThread - Received msg:" + new UniqueId(msgs[i].getUniqueId()) + " at " + new java.sql.Timestamp(System.currentTimeMillis()));
+                    }catch ( Throwable t ) {}
+                }
+                //process the message
+                getCallback().messageDataReceived(msgs[i]);
+                /**
+                 * Use send ack here if you want the request to complete on this 
+                 * server before sending the ack to the remote server
+                 * This is considered a synchronized request
+                 */
+                if (ChannelData.sendAckSync(msgs[i].getOptions())) sendAck(key,channel,Constants.ACK_COMMAND);
+            }catch ( RemoteProcessException e ) {
+                if ( log.isDebugEnabled() ) log.error("Processing of cluster message failed.",e);
+                if (ChannelData.sendAckSync(msgs[i].getOptions())) sendAck(key,channel,Constants.FAIL_ACK_COMMAND);
+            }catch ( Exception e ) {
+                log.error("Processing of cluster message failed.",e);
+                if (ChannelData.sendAckSync(msgs[i].getOptions())) sendAck(key,channel,Constants.FAIL_ACK_COMMAND);
+            }
+            if ( getUseBufferPool() ) {
+                BufferPool.getBufferPool().returnBuffer(msgs[i].getMessage());
+                msgs[i].setMessage(null);
+            }
+        }                        
+        
+        if (count < 0) {
+            remoteEof(key);
+            return;
+        }
+    }
+
+    private void remoteEof(SelectionKey key) {
+        // close channel on EOF, invalidates the key
+        if ( log.isDebugEnabled() ) log.debug("Channel closed on the remote end, disconnecting");
+        cancelKey(key);
+    }
+
+    protected void registerForRead(final SelectionKey key, ObjectReader reader) {
+        if ( log.isTraceEnabled() ) 
+            log.trace("Adding key for read event:"+key);
+        reader.finish();
+        //register our OP_READ interest
+        Runnable r = new Runnable() {
+            public void run() {
+                try {
+                    if (key.isValid()) {
+                        // cycle the selector so this key is active again
+                        key.selector().wakeup();
+                        // resume interest in OP_READ, OP_WRITE
+                        int resumeOps = key.interestOps() | SelectionKey.OP_READ;
+                        key.interestOps(resumeOps);
+                        if ( log.isTraceEnabled() ) 
+                            log.trace("Registering key for read:"+key);
+                    }
+                } catch (CancelledKeyException ckx ) {
+                    NioReceiver.cancelledKey(key);
+                    if ( log.isTraceEnabled() ) 
+                        log.trace("CKX Cancelling key:"+key);
+
+                } catch (Exception x) {
+                    log.error("Error registering key for read:"+key,x);
+                }
+            }
+        };
+        receiver.addEvent(r);
+    }
+
+    private void cancelKey(final SelectionKey key) {
+        if ( log.isTraceEnabled() ) 
+            log.trace("Adding key for cancel event:"+key);
+
+        ObjectReader reader = (ObjectReader)key.attachment();
+        if ( reader != null ) {
+            reader.setCancelled(true);
+            reader.finish();
+        }
+        Runnable cx = new Runnable() {
+            public void run() {
+                if ( log.isTraceEnabled() ) 
+                    log.trace("Cancelling key:"+key);
+
+                NioReceiver.cancelledKey(key);
+            }
+        };
+        receiver.addEvent(cx);
+    }
+    
+    
+
+
+
+    /**
+     * send a reply-acknowledgement (6,2,3)
+     * @param key
+     * @param channel
+     */
+    protected void sendAck(SelectionKey key, SocketChannel channel, byte[] command) {
+        
+        try {
+            ByteBuffer buf = ByteBuffer.wrap(command);
+            int total = 0;
+            while ( total < command.length ) {
+                total += channel.write(buf);
+            }
+            if (log.isTraceEnabled()) {
+                log.trace("ACK sent to " + channel.socket().getPort());
+            }
+        } catch ( java.io.IOException x ) {
+            log.warn("Unable to send ACK back through channel, channel disconnected?: "+x.getMessage());
+        }
+    }
+
+    public void setRxBufSize(int rxBufSize) {
+        this.rxBufSize = rxBufSize;
+    }
+
+    public int getRxBufSize() {
+        return rxBufSize;
+    }
+}

==================================================
ParallelNioSender.java
index 38f2364981..b295ef8eeb 100644
--- a/java/org/apache/catalina/tribes/transport/nio/NioSender.java
+++ b/java/org/apache/catalina/tribes/transport/nio/NioSender.java
@@ -1,333 +1,333 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.transport.nio;
-
-import java.io.IOException;
-import java.net.InetSocketAddress;
-import java.net.UnknownHostException;
-import java.nio.ByteBuffer;
-import java.nio.channels.SelectionKey;
-import java.nio.channels.Selector;
-import java.nio.channels.SocketChannel;
-import java.util.Arrays;
-
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.io.XByteBuffer;
-import org.apache.catalina.tribes.transport.AbstractSender;
-import org.apache.catalina.tribes.transport.DataSender;
-import org.apache.catalina.tribes.RemoteProcessException;
-import java.io.EOFException;
-
-/**
- * This class is NOT thread safe and should never be used with more than one thread at a time
- * 
- * This is a state machine, handled by the process method
- * States are:
- * - NOT_CONNECTED -> connect() -> CONNECTED
- * - CONNECTED -> setMessage() -> READY TO WRITE
- * - READY_TO_WRITE -> write() -> READY TO WRITE | READY TO READ
- * - READY_TO_READ -> read() -> READY_TO_READ | TRANSFER_COMPLETE
- * - TRANSFER_COMPLETE -> CONNECTED
- * 
- * @author Filip Hanik
- * @version 1.0
- */
-public class NioSender extends AbstractSender implements DataSender{
-
-    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(NioSender.class);
-
-    
-    
-    protected Selector selector;    
-    protected SocketChannel socketChannel;
-
-    /*
-     * STATE VARIABLES *
-     */
-    protected ByteBuffer readbuf = null;
-    protected ByteBuffer writebuf = null;
-    protected byte[] current = null;
-    protected XByteBuffer ackbuf = new XByteBuffer(128,true);
-    protected int remaining = 0;
-    protected boolean complete;
-    
-    protected boolean connecting = false;
-    
-    public NioSender() {
-        super();
-        
-    }
-    
-    /**
-     * State machine to send data
-     * @param key SelectionKey
-     * @return boolean
-     * @throws IOException
-     */
-    public boolean process(SelectionKey key, boolean waitForAck) throws IOException {
-        int ops = key.readyOps();
-        key.interestOps(key.interestOps() & ~ops);
-        //in case disconnect has been called
-        if ((!isConnected()) && (!connecting)) throw new IOException("Sender has been disconnected, can't selection key.");
-        if ( !key.isValid() ) throw new IOException("Key is not valid, it must have been cancelled.");
-        if ( key.isConnectable() ) {
-            if ( socketChannel.finishConnect() ) {
-                //we connected, register ourselves for writing
-                setConnected(true);
-                connecting = false;
-                setRequestCount(0);
-                setConnectTime(System.currentTimeMillis());
-                socketChannel.socket().setSendBufferSize(getTxBufSize());
-                socketChannel.socket().setReceiveBufferSize(getRxBufSize());
-                socketChannel.socket().setSoTimeout((int)getTimeout());
-                socketChannel.socket().setSoLinger(false,0);
-                socketChannel.socket().setTcpNoDelay(getTcpNoDelay());
-                socketChannel.socket().setKeepAlive(getSoKeepAlive());
-                socketChannel.socket().setReuseAddress(getSoReuseAddress());
-                socketChannel.socket().setOOBInline(getOoBInline());
-                socketChannel.socket().setSoLinger(getSoLingerOn(),getSoLingerTime());
-                socketChannel.socket().setTrafficClass(getSoTrafficClass());
-                if ( current != null ) key.interestOps(key.interestOps() | SelectionKey.OP_WRITE);
-                return false;
-            } else  { 
-                //wait for the connection to finish
-                key.interestOps(key.interestOps() | SelectionKey.OP_CONNECT);
-                return false;
-            }//end if
-        } else if ( key.isWritable() ) {
-            boolean writecomplete = write(key);
-            if ( writecomplete ) {
-                //we are completed, should we read an ack?
-                if ( waitForAck ) {
-                    //register to read the ack
-                    key.interestOps(key.interestOps() | SelectionKey.OP_READ);
-                } else {
-                    //if not, we are ready, setMessage will reregister us for another write interest
-                    //do a health check, we have no way of verify a disconnected
-                    //socket since we don't register for OP_READ on waitForAck=false
-                    read(key);//this causes overhead
-                    setRequestCount(getRequestCount()+1);
-                    return true;
-                }
-            } else {
-                //we are not complete, lets write some more
-                key.interestOps(key.interestOps()|SelectionKey.OP_WRITE);
-            }//end if
-        } else if ( key.isReadable() ) {
-            boolean readcomplete = read(key);
-            if ( readcomplete ) {
-                setRequestCount(getRequestCount()+1);
-                return true;
-            } else {
-                key.interestOps(key.interestOps() | SelectionKey.OP_READ);
-            }//end if
-        } else {
-            //unknown state, should never happen
-            log.warn("Data is in unknown state. readyOps="+ops);
-            throw new IOException("Data is in unknown state. readyOps="+ops);
-        }//end if
-        return false;
-    }
-    
-    
-
-    protected boolean read(SelectionKey key) throws IOException {
-        //if there is no message here, we are done
-        if ( current == null ) return true;
-        int read = socketChannel.read(readbuf);
-        //end of stream
-        if ( read == -1 ) throw new IOException("Unable to receive an ack message. EOF on socket channel has been reached.");
-        //no data read
-        else if ( read == 0 ) return false;
-        readbuf.flip();
-        ackbuf.append(readbuf,read);
-        readbuf.clear();
-        if (ackbuf.doesPackageExist() ) {
-            byte[] ackcmd = ackbuf.extractDataPackage(true).getBytes();
-            boolean ack = Arrays.equals(ackcmd,org.apache.catalina.tribes.transport.Constants.ACK_DATA);
-            boolean fack = Arrays.equals(ackcmd,org.apache.catalina.tribes.transport.Constants.FAIL_ACK_DATA);
-            if ( fack && getThrowOnFailedAck() ) throw new RemoteProcessException("Received a failed ack:org.apache.catalina.tribes.transport.Constants.FAIL_ACK_DATA");
-            return ack || fack;
-        } else {
-            return false;
-        }
-    }
-
-    
-    protected boolean write(SelectionKey key) throws IOException {
-        if ( (!isConnected()) || (this.socketChannel==null)) {
-            throw new IOException("NioSender is not connected, this should not occur.");
-        }
-        if ( current != null ) {
-            if ( remaining > 0 ) {
-                //weve written everything, or we are starting a new package
-                //protect against buffer overwrite
-                int byteswritten = socketChannel.write(writebuf);
-                if (byteswritten == -1 ) throw new EOFException();
-                remaining -= byteswritten;
-                //if the entire message was written from the buffer
-                //reset the position counter
-                if ( remaining < 0 ) {
-                    remaining = 0;
-                }
-            }
-            return (remaining==0);
-        }
-        //no message to send, we can consider that complete
-        return true;
-    }
-
-    /**
-     * connect - blocking in this operation
-     *
-     * @throws IOException
-     * @todo Implement this org.apache.catalina.tribes.transport.IDataSender method
-     */
-    public synchronized void connect() throws IOException {
-        if ( connecting ) return;
-        connecting = true;
-        if ( isConnected() ) throw new IOException("NioSender is already in connected state.");
-        if ( readbuf == null ) {
-            readbuf = getReadBuffer();
-        } else {
-            readbuf.clear();
-        }
-        if ( writebuf == null ) {
-            writebuf = getWriteBuffer();
-        } else {
-            writebuf.clear();
-        }
-        
-        InetSocketAddress addr = new InetSocketAddress(getAddress(),getPort());
-        if ( socketChannel != null ) throw new IOException("Socket channel has already been established. Connection might be in progress.");
-        socketChannel = SocketChannel.open();
-        socketChannel.configureBlocking(false);
-        socketChannel.connect(addr);
-        socketChannel.register(getSelector(),SelectionKey.OP_CONNECT,this);
-    }
-    
-
-    /**
-     * disconnect
-     *
-     * @todo Implement this org.apache.catalina.tribes.transport.IDataSender method
-     */
-    public void disconnect() {
-        try {
-            connecting = false;
-            setConnected(false);
-            if ( socketChannel != null ) {
-                try {
-                    try {socketChannel.socket().close();}catch ( Exception x){}
-                    //error free close, all the way
-                    //try {socket.shutdownOutput();}catch ( Exception x){}
-                    //try {socket.shutdownInput();}catch ( Exception x){}
-                    //try {socket.close();}catch ( Exception x){}
-                    try {socketChannel.close();}catch ( Exception x){}
-                }finally {
-                    socketChannel = null;
-                }
-            }
-        } catch ( Exception x ) {
-            log.error("Unable to disconnect NioSender. msg="+x.getMessage());
-            if ( log.isDebugEnabled() ) log.debug("Unable to disconnect NioSender. msg="+x.getMessage(),x);
-        } finally {
-        }
-
-    }
-    
-    public void reset() {
-        if ( isConnected() && readbuf == null) {
-            readbuf = getReadBuffer();
-        }
-        if ( readbuf != null ) readbuf.clear();
-        if ( writebuf != null ) writebuf.clear();
-        current = null;
-        ackbuf.clear();
-        remaining = 0;
-        complete = false;
-        setAttempt(0);
-        setRequestCount(0);
-        setConnectTime(-1);
-    }
-
-    private ByteBuffer getReadBuffer() { 
-        return getBuffer(getRxBufSize());
-    }
-    
-    private ByteBuffer getWriteBuffer() {
-        return getBuffer(getTxBufSize());
-    }
-
-    private ByteBuffer getBuffer(int size) {
-        return (getDirectBuffer()?ByteBuffer.allocateDirect(size):ByteBuffer.allocate(size));
-    }
-    
-    /**
-    * sendMessage
-    *
-    * @param data ChannelMessage
-    * @throws IOException
-    * @todo Implement this org.apache.catalina.tribes.transport.IDataSender method
-    */
-   public synchronized void setMessage(byte[] data) throws IOException {
-       setMessage(data,0,data.length);
-   }
-
-   public synchronized void setMessage(byte[] data,int offset, int length) throws IOException {
-       if ( data != null ) {
-           current = data;
-           remaining = length;
-           ackbuf.clear();
-           if ( writebuf != null ) writebuf.clear();
-           else writebuf = getBuffer(length);
-           if ( writebuf.capacity() < length ) writebuf = getBuffer(length);
-           writebuf.put(data,offset,length);
-           //writebuf.rewind();
-           //set the limit so that we don't write non wanted data
-           //writebuf.limit(length);
-           writebuf.flip();
-           if (isConnected()) {
-               socketChannel.register(getSelector(), SelectionKey.OP_WRITE, this);
-           }
-       } 
-   }
-   
-   public byte[] getMessage() {
-       return current;
-   }
-
-
-
-    public boolean isComplete() {
-        return complete;
-    }
-
-    public Selector getSelector() {
-        return selector;
-    }
-
-    public void setSelector(Selector selector) {
-        this.selector = selector;
-    }
-
-
-    public void setComplete(boolean complete) {
-        this.complete = complete;
-    }
-}
\ No newline at end of file
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.tribes.transport.nio;
+
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.net.UnknownHostException;
+import java.nio.ByteBuffer;
+import java.nio.channels.SelectionKey;
+import java.nio.channels.Selector;
+import java.nio.channels.SocketChannel;
+import java.util.Arrays;
+
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.io.XByteBuffer;
+import org.apache.catalina.tribes.transport.AbstractSender;
+import org.apache.catalina.tribes.transport.DataSender;
+import org.apache.catalina.tribes.RemoteProcessException;
+import java.io.EOFException;
+
+/**
+ * This class is NOT thread safe and should never be used with more than one thread at a time
+ * 
+ * This is a state machine, handled by the process method
+ * States are:
+ * - NOT_CONNECTED -> connect() -> CONNECTED
+ * - CONNECTED -> setMessage() -> READY TO WRITE
+ * - READY_TO_WRITE -> write() -> READY TO WRITE | READY TO READ
+ * - READY_TO_READ -> read() -> READY_TO_READ | TRANSFER_COMPLETE
+ * - TRANSFER_COMPLETE -> CONNECTED
+ * 
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class NioSender extends AbstractSender implements DataSender{
+
+    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(NioSender.class);
+
+    
+    
+    protected Selector selector;    
+    protected SocketChannel socketChannel;
+
+    /*
+     * STATE VARIABLES *
+     */
+    protected ByteBuffer readbuf = null;
+    protected ByteBuffer writebuf = null;
+    protected byte[] current = null;
+    protected XByteBuffer ackbuf = new XByteBuffer(128,true);
+    protected int remaining = 0;
+    protected boolean complete;
+    
+    protected boolean connecting = false;
+    
+    public NioSender() {
+        super();
+        
+    }
+    
+    /**
+     * State machine to send data
+     * @param key SelectionKey
+     * @return boolean
+     * @throws IOException
+     */
+    public boolean process(SelectionKey key, boolean waitForAck) throws IOException {
+        int ops = key.readyOps();
+        key.interestOps(key.interestOps() & ~ops);
+        //in case disconnect has been called
+        if ((!isConnected()) && (!connecting)) throw new IOException("Sender has been disconnected, can't selection key.");
+        if ( !key.isValid() ) throw new IOException("Key is not valid, it must have been cancelled.");
+        if ( key.isConnectable() ) {
+            if ( socketChannel.finishConnect() ) {
+                //we connected, register ourselves for writing
+                setConnected(true);
+                connecting = false;
+                setRequestCount(0);
+                setConnectTime(System.currentTimeMillis());
+                socketChannel.socket().setSendBufferSize(getTxBufSize());
+                socketChannel.socket().setReceiveBufferSize(getRxBufSize());
+                socketChannel.socket().setSoTimeout((int)getTimeout());
+                socketChannel.socket().setSoLinger(false,0);
+                socketChannel.socket().setTcpNoDelay(getTcpNoDelay());
+                socketChannel.socket().setKeepAlive(getSoKeepAlive());
+                socketChannel.socket().setReuseAddress(getSoReuseAddress());
+                socketChannel.socket().setOOBInline(getOoBInline());
+                socketChannel.socket().setSoLinger(getSoLingerOn(),getSoLingerTime());
+                socketChannel.socket().setTrafficClass(getSoTrafficClass());
+                if ( current != null ) key.interestOps(key.interestOps() | SelectionKey.OP_WRITE);
+                return false;
+            } else  { 
+                //wait for the connection to finish
+                key.interestOps(key.interestOps() | SelectionKey.OP_CONNECT);
+                return false;
+            }//end if
+        } else if ( key.isWritable() ) {
+            boolean writecomplete = write(key);
+            if ( writecomplete ) {
+                //we are completed, should we read an ack?
+                if ( waitForAck ) {
+                    //register to read the ack
+                    key.interestOps(key.interestOps() | SelectionKey.OP_READ);
+                } else {
+                    //if not, we are ready, setMessage will reregister us for another write interest
+                    //do a health check, we have no way of verify a disconnected
+                    //socket since we don't register for OP_READ on waitForAck=false
+                    read(key);//this causes overhead
+                    setRequestCount(getRequestCount()+1);
+                    return true;
+                }
+            } else {
+                //we are not complete, lets write some more
+                key.interestOps(key.interestOps()|SelectionKey.OP_WRITE);
+            }//end if
+        } else if ( key.isReadable() ) {
+            boolean readcomplete = read(key);
+            if ( readcomplete ) {
+                setRequestCount(getRequestCount()+1);
+                return true;
+            } else {
+                key.interestOps(key.interestOps() | SelectionKey.OP_READ);
+            }//end if
+        } else {
+            //unknown state, should never happen
+            log.warn("Data is in unknown state. readyOps="+ops);
+            throw new IOException("Data is in unknown state. readyOps="+ops);
+        }//end if
+        return false;
+    }
+    
+    
+
+    protected boolean read(SelectionKey key) throws IOException {
+        //if there is no message here, we are done
+        if ( current == null ) return true;
+        int read = socketChannel.read(readbuf);
+        //end of stream
+        if ( read == -1 ) throw new IOException("Unable to receive an ack message. EOF on socket channel has been reached.");
+        //no data read
+        else if ( read == 0 ) return false;
+        readbuf.flip();
+        ackbuf.append(readbuf,read);
+        readbuf.clear();
+        if (ackbuf.doesPackageExist() ) {
+            byte[] ackcmd = ackbuf.extractDataPackage(true).getBytes();
+            boolean ack = Arrays.equals(ackcmd,org.apache.catalina.tribes.transport.Constants.ACK_DATA);
+            boolean fack = Arrays.equals(ackcmd,org.apache.catalina.tribes.transport.Constants.FAIL_ACK_DATA);
+            if ( fack && getThrowOnFailedAck() ) throw new RemoteProcessException("Received a failed ack:org.apache.catalina.tribes.transport.Constants.FAIL_ACK_DATA");
+            return ack || fack;
+        } else {
+            return false;
+        }
+    }
+
+    
+    protected boolean write(SelectionKey key) throws IOException {
+        if ( (!isConnected()) || (this.socketChannel==null)) {
+            throw new IOException("NioSender is not connected, this should not occur.");
+        }
+        if ( current != null ) {
+            if ( remaining > 0 ) {
+                //weve written everything, or we are starting a new package
+                //protect against buffer overwrite
+                int byteswritten = socketChannel.write(writebuf);
+                if (byteswritten == -1 ) throw new EOFException();
+                remaining -= byteswritten;
+                //if the entire message was written from the buffer
+                //reset the position counter
+                if ( remaining < 0 ) {
+                    remaining = 0;
+                }
+            }
+            return (remaining==0);
+        }
+        //no message to send, we can consider that complete
+        return true;
+    }
+
+    /**
+     * connect - blocking in this operation
+     *
+     * @throws IOException
+     * @todo Implement this org.apache.catalina.tribes.transport.IDataSender method
+     */
+    public synchronized void connect() throws IOException {
+        if ( connecting ) return;
+        connecting = true;
+        if ( isConnected() ) throw new IOException("NioSender is already in connected state.");
+        if ( readbuf == null ) {
+            readbuf = getReadBuffer();
+        } else {
+            readbuf.clear();
+        }
+        if ( writebuf == null ) {
+            writebuf = getWriteBuffer();
+        } else {
+            writebuf.clear();
+        }
+        
+        InetSocketAddress addr = new InetSocketAddress(getAddress(),getPort());
+        if ( socketChannel != null ) throw new IOException("Socket channel has already been established. Connection might be in progress.");
+        socketChannel = SocketChannel.open();
+        socketChannel.configureBlocking(false);
+        socketChannel.connect(addr);
+        socketChannel.register(getSelector(),SelectionKey.OP_CONNECT,this);
+    }
+    
+
+    /**
+     * disconnect
+     *
+     * @todo Implement this org.apache.catalina.tribes.transport.IDataSender method
+     */
+    public void disconnect() {
+        try {
+            connecting = false;
+            setConnected(false);
+            if ( socketChannel != null ) {
+                try {
+                    try {socketChannel.socket().close();}catch ( Exception x){}
+                    //error free close, all the way
+                    //try {socket.shutdownOutput();}catch ( Exception x){}
+                    //try {socket.shutdownInput();}catch ( Exception x){}
+                    //try {socket.close();}catch ( Exception x){}
+                    try {socketChannel.close();}catch ( Exception x){}
+                }finally {
+                    socketChannel = null;
+                }
+            }
+        } catch ( Exception x ) {
+            log.error("Unable to disconnect NioSender. msg="+x.getMessage());
+            if ( log.isDebugEnabled() ) log.debug("Unable to disconnect NioSender. msg="+x.getMessage(),x);
+        } finally {
+        }
+
+    }
+    
+    public void reset() {
+        if ( isConnected() && readbuf == null) {
+            readbuf = getReadBuffer();
+        }
+        if ( readbuf != null ) readbuf.clear();
+        if ( writebuf != null ) writebuf.clear();
+        current = null;
+        ackbuf.clear();
+        remaining = 0;
+        complete = false;
+        setAttempt(0);
+        setRequestCount(0);
+        setConnectTime(-1);
+    }
+
+    private ByteBuffer getReadBuffer() { 
+        return getBuffer(getRxBufSize());
+    }
+    
+    private ByteBuffer getWriteBuffer() {
+        return getBuffer(getTxBufSize());
+    }
+
+    private ByteBuffer getBuffer(int size) {
+        return (getDirectBuffer()?ByteBuffer.allocateDirect(size):ByteBuffer.allocate(size));
+    }
+    
+    /**
+    * sendMessage
+    *
+    * @param data ChannelMessage
+    * @throws IOException
+    * @todo Implement this org.apache.catalina.tribes.transport.IDataSender method
+    */
+   public synchronized void setMessage(byte[] data) throws IOException {
+       setMessage(data,0,data.length);
+   }
+
+   public synchronized void setMessage(byte[] data,int offset, int length) throws IOException {
+       if ( data != null ) {
+           current = data;
+           remaining = length;
+           ackbuf.clear();
+           if ( writebuf != null ) writebuf.clear();
+           else writebuf = getBuffer(length);
+           if ( writebuf.capacity() < length ) writebuf = getBuffer(length);
+           writebuf.put(data,offset,length);
+           //writebuf.rewind();
+           //set the limit so that we don't write non wanted data
+           //writebuf.limit(length);
+           writebuf.flip();
+           if (isConnected()) {
+               socketChannel.register(getSelector(), SelectionKey.OP_WRITE, this);
+           }
+       } 
+   }
+   
+   public byte[] getMessage() {
+       return current;
+   }
+
+
+
+    public boolean isComplete() {
+        return complete;
+    }
+
+    public Selector getSelector() {
+        return selector;
+    }
+
+    public void setSelector(Selector selector) {
+        this.selector = selector;
+    }
+
+
+    public void setComplete(boolean complete) {
+        this.complete = complete;
+    }
+}

==================================================
PooledParallelSender.java
index 12d6316ece..e02e566d72 100644
--- a/java/org/apache/catalina/tribes/transport/nio/ParallelNioSender.java
+++ b/java/org/apache/catalina/tribes/transport/nio/ParallelNioSender.java
@@ -1,289 +1,289 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.transport.nio;
-
-
-import java.io.IOException;
-import java.nio.channels.SelectionKey;
-import java.nio.channels.Selector;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
-
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.io.ChannelData;
-import org.apache.catalina.tribes.io.XByteBuffer;
-import org.apache.catalina.tribes.transport.MultiPointSender;
-import org.apache.catalina.tribes.transport.SenderState;
-import org.apache.catalina.tribes.transport.AbstractSender;
-import java.net.UnknownHostException;
-import org.apache.catalina.tribes.Channel;
-import org.apache.catalina.tribes.group.RpcChannel;
-import org.apache.catalina.tribes.util.Logs;
-import org.apache.catalina.tribes.UniqueId;
-
-/**
- * <p>Title: </p>
- *
- * <p>Description: </p>
- *
- * <p>Copyright: Copyright (c) 2005</p>
- *
- * <p>Company: </p>
- *
- * @author not attributable
- * @version 1.0
- */
-public class ParallelNioSender extends AbstractSender implements MultiPointSender {
-    
-    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(ParallelNioSender.class);
-    protected long selectTimeout = 5000; //default 5 seconds, same as send timeout
-    protected Selector selector;
-    protected HashMap nioSenders = new HashMap();
-
-    public ParallelNioSender() throws IOException {
-        selector = Selector.open();
-        setConnected(true);
-    }
-    
-    
-    public synchronized void sendMessage(Member[] destination, ChannelMessage msg) throws ChannelException {
-        long start = System.currentTimeMillis();
-        byte[] data = XByteBuffer.createDataPackage((ChannelData)msg);
-        NioSender[] senders = setupForSend(destination);
-        connect(senders);
-        setData(senders,data);
-        
-        int remaining = senders.length;
-        ChannelException cx = null;
-        try {
-            //loop until complete, an error happens, or we timeout
-            long delta = System.currentTimeMillis() - start;
-            boolean waitForAck = (Channel.SEND_OPTIONS_USE_ACK & msg.getOptions()) == Channel.SEND_OPTIONS_USE_ACK;
-            while ( (remaining>0) && (delta<getTimeout()) ) {
-                try {
-                    remaining -= doLoop(selectTimeout, getMaxRetryAttempts(),waitForAck,msg);
-                } catch (Exception x ) {
-                    if ( cx == null ) {
-                        if ( x instanceof ChannelException ) cx = (ChannelException)x;
-                        else cx = new ChannelException("Parallel NIO send failed.", x);
-                    } else {
-                        if (x instanceof ChannelException) cx.addFaultyMember( ( (ChannelException) x).getFaultyMembers());
-                    }
-                }
-                //bail out if all remaining senders are failing
-                if ( cx != null && cx.getFaultyMembers().length == remaining ) throw cx;
-                delta = System.currentTimeMillis() - start;
-            }
-            if ( remaining > 0 ) {
-                //timeout has occured
-                cx = new ChannelException("Operation has timed out("+getTimeout()+" ms.).");
-                for (int i=0; i<senders.length; i++ ) {
-                    if (!senders[i].isComplete() ) cx.addFaultyMember(senders[i].getDestination(),null);
-                }
-                throw cx;
-            }
-        } catch (Exception x ) {
-            try { this.disconnect(); } catch (Exception ignore) {}
-            if ( x instanceof ChannelException ) throw (ChannelException)x;
-            else throw new ChannelException(x);
-        }
-        
-    }
-    
-    private int doLoop(long selectTimeOut, int maxAttempts, boolean waitForAck, ChannelMessage msg) throws IOException, ChannelException {
-        int completed = 0;
-        int selectedKeys = selector.select(selectTimeOut);
-        
-        if (selectedKeys == 0) {
-            return 0;
-        }
-        
-        Iterator it = selector.selectedKeys().iterator();
-        while (it.hasNext()) {
-            SelectionKey sk = (SelectionKey) it.next();
-            it.remove();
-            int readyOps = sk.readyOps();
-            sk.interestOps(sk.interestOps() & ~readyOps);
-            NioSender sender = (NioSender) sk.attachment();
-            try {
-                if (sender.process(sk,waitForAck)) {
-                    completed++;
-                    sender.setComplete(true);
-                    if ( Logs.MESSAGES.isTraceEnabled() ) {
-                        Logs.MESSAGES.trace("ParallelNioSender - Sent msg:" + new UniqueId(msg.getUniqueId()) + " at " +new java.sql.Timestamp(System.currentTimeMillis())+ " to "+sender.getDestination().getName());
-                    }
-                    SenderState.getSenderState(sender.getDestination()).setReady();
-                }//end if
-            } catch (Exception x) {
-                SenderState state = SenderState.getSenderState(sender.getDestination());
-                int attempt = sender.getAttempt()+1;
-                boolean retry = (sender.getAttempt() <= maxAttempts && maxAttempts>0);
-                synchronized (state) {
-                
-                    //sk.cancel();
-                    if (state.isSuspect()) state.setFailing();
-                    if (state.isReady()) {
-                        state.setSuspect();
-                        if ( retry ) 
-                            log.warn("Member send is failing for:" + sender.getDestination().getName() +" ; Setting to suspect and retrying.");
-                        else 
-                            log.warn("Member send is failing for:" + sender.getDestination().getName() +" ; Setting to suspect.", x);
-                    }                    
-                }
-                if ( !isConnected() ) {
-                    log.warn("Not retrying send for:" + sender.getDestination().getName() + "; Sender is disconnected.");
-                    ChannelException cx = new ChannelException("Send failed, and sender is disconnected. Not retrying.",x);
-                    cx.addFaultyMember(sender.getDestination(),x);
-                    throw cx;
-                }
-                
-                byte[] data = sender.getMessage();
-                if ( retry ) {
-                    try { 
-                        sender.disconnect(); 
-                        sender.connect();
-                        sender.setAttempt(attempt);
-                        sender.setMessage(data);
-                    }catch ( Exception ignore){
-                        state.setFailing();
-                    }
-                } else {
-                    ChannelException cx = new ChannelException("Send failed, attempt:"+sender.getAttempt()+" max:"+maxAttempts,x);
-                    cx.addFaultyMember(sender.getDestination(),x);
-                    throw cx;
-                }//end if
-            }
-        }
-        return completed;
-
-    }
-    
-    private void connect(NioSender[] senders) throws ChannelException {
-        ChannelException x = null;
-        for (int i=0; i<senders.length; i++ ) {
-            try {
-                if (!senders[i].isConnected()) senders[i].connect();
-            }catch ( IOException io ) {
-                if ( x==null ) x = new ChannelException(io);
-                x.addFaultyMember(senders[i].getDestination(),io);
-            }
-        }
-        if ( x != null ) throw x;
-    }
-    
-    private void setData(NioSender[] senders, byte[] data) throws ChannelException {
-        ChannelException x = null;
-        for (int i=0; i<senders.length; i++ ) {
-            try {
-                senders[i].setMessage(data);
-            }catch ( IOException io ) {
-                if ( x==null ) x = new ChannelException(io);
-                x.addFaultyMember(senders[i].getDestination(),io);
-            }
-        }
-        if ( x != null ) throw x;
-    }
-    
-    
-    private NioSender[] setupForSend(Member[] destination) throws ChannelException {
-        ChannelException cx = null;
-        NioSender[] result = new NioSender[destination.length];
-        for ( int i=0; i<destination.length; i++ ) {
-            NioSender sender = (NioSender)nioSenders.get(destination[i]);
-            try {
-
-                if (sender == null) {
-                    sender = new NioSender();
-                    sender.transferProperties(this, sender);
-                    nioSenders.put(destination[i], sender);
-                }
-                if (sender != null) {
-                    sender.reset();
-                    sender.setDestination(destination[i]);
-                    sender.setSelector(selector);
-                    result[i] = sender;
-                }
-            }catch ( UnknownHostException x ) {
-                if (cx == null) cx = new ChannelException("Unable to setup NioSender.", x);
-                cx.addFaultyMember(destination[i], x);
-            }
-        }
-        if ( cx != null ) throw cx;
-        else return result;
-    }
-    
-    public void connect() {
-        //do nothing, we connect on demand
-        setConnected(true);
-    }
-    
-    
-    private synchronized void close() throws ChannelException  {
-        ChannelException x = null;
-        Object[] members = nioSenders.keySet().toArray();
-        for (int i=0; i<members.length; i++ ) {
-            Member mbr = (Member)members[i];
-            try {
-                NioSender sender = (NioSender)nioSenders.get(mbr);
-                sender.disconnect();
-            }catch ( Exception e ) {
-                if ( x == null ) x = new ChannelException(e);
-                x.addFaultyMember(mbr,e);
-            }
-            nioSenders.remove(mbr);
-        }
-        if ( x != null ) throw x;
-    }
-    
-    public void memberAdded(Member member) {
-        
-    }
-    
-    public void memberDisappeared(Member member) {
-        //disconnect senders
-        NioSender sender = (NioSender)nioSenders.remove(member);
-        if ( sender != null ) sender.disconnect();
-    }
-
-    
-    public synchronized void disconnect() {
-        setConnected(false);
-        try {close(); }catch (Exception x){}
-        
-    }
-    
-    public void finalize() {
-        try {disconnect(); }catch ( Exception ignore){}
-    }
-
-    public boolean keepalive() {
-        //throw new UnsupportedOperationException("Method ParallelNioSender.checkKeepAlive() not implemented");
-        boolean result = false;
-        for ( Iterator i = nioSenders.entrySet().iterator(); i.hasNext();  ) {
-            Map.Entry entry = (Map.Entry)i.next();
-            NioSender sender = (NioSender)entry.getValue();
-            if ( sender.keepalive() ) {
-                nioSenders.remove(entry.getKey());
-            }
-        }
-        return result;
-    }
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.transport.nio;
+
+
+import java.io.IOException;
+import java.nio.channels.SelectionKey;
+import java.nio.channels.Selector;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.io.ChannelData;
+import org.apache.catalina.tribes.io.XByteBuffer;
+import org.apache.catalina.tribes.transport.MultiPointSender;
+import org.apache.catalina.tribes.transport.SenderState;
+import org.apache.catalina.tribes.transport.AbstractSender;
+import java.net.UnknownHostException;
+import org.apache.catalina.tribes.Channel;
+import org.apache.catalina.tribes.group.RpcChannel;
+import org.apache.catalina.tribes.util.Logs;
+import org.apache.catalina.tribes.UniqueId;
+
+/**
+ * <p>Title: </p>
+ *
+ * <p>Description: </p>
+ *
+ * <p>Copyright: Copyright (c) 2005</p>
+ *
+ * <p>Company: </p>
+ *
+ * @author not attributable
+ * @version 1.0
+ */
+public class ParallelNioSender extends AbstractSender implements MultiPointSender {
+    
+    protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(ParallelNioSender.class);
+    protected long selectTimeout = 5000; //default 5 seconds, same as send timeout
+    protected Selector selector;
+    protected HashMap nioSenders = new HashMap();
+
+    public ParallelNioSender() throws IOException {
+        selector = Selector.open();
+        setConnected(true);
+    }
+    
+    
+    public synchronized void sendMessage(Member[] destination, ChannelMessage msg) throws ChannelException {
+        long start = System.currentTimeMillis();
+        byte[] data = XByteBuffer.createDataPackage((ChannelData)msg);
+        NioSender[] senders = setupForSend(destination);
+        connect(senders);
+        setData(senders,data);
+        
+        int remaining = senders.length;
+        ChannelException cx = null;
+        try {
+            //loop until complete, an error happens, or we timeout
+            long delta = System.currentTimeMillis() - start;
+            boolean waitForAck = (Channel.SEND_OPTIONS_USE_ACK & msg.getOptions()) == Channel.SEND_OPTIONS_USE_ACK;
+            while ( (remaining>0) && (delta<getTimeout()) ) {
+                try {
+                    remaining -= doLoop(selectTimeout, getMaxRetryAttempts(),waitForAck,msg);
+                } catch (Exception x ) {
+                    if ( cx == null ) {
+                        if ( x instanceof ChannelException ) cx = (ChannelException)x;
+                        else cx = new ChannelException("Parallel NIO send failed.", x);
+                    } else {
+                        if (x instanceof ChannelException) cx.addFaultyMember( ( (ChannelException) x).getFaultyMembers());
+                    }
+                }
+                //bail out if all remaining senders are failing
+                if ( cx != null && cx.getFaultyMembers().length == remaining ) throw cx;
+                delta = System.currentTimeMillis() - start;
+            }
+            if ( remaining > 0 ) {
+                //timeout has occured
+                cx = new ChannelException("Operation has timed out("+getTimeout()+" ms.).");
+                for (int i=0; i<senders.length; i++ ) {
+                    if (!senders[i].isComplete() ) cx.addFaultyMember(senders[i].getDestination(),null);
+                }
+                throw cx;
+            }
+        } catch (Exception x ) {
+            try { this.disconnect(); } catch (Exception ignore) {}
+            if ( x instanceof ChannelException ) throw (ChannelException)x;
+            else throw new ChannelException(x);
+        }
+        
+    }
+    
+    private int doLoop(long selectTimeOut, int maxAttempts, boolean waitForAck, ChannelMessage msg) throws IOException, ChannelException {
+        int completed = 0;
+        int selectedKeys = selector.select(selectTimeOut);
+        
+        if (selectedKeys == 0) {
+            return 0;
+        }
+        
+        Iterator it = selector.selectedKeys().iterator();
+        while (it.hasNext()) {
+            SelectionKey sk = (SelectionKey) it.next();
+            it.remove();
+            int readyOps = sk.readyOps();
+            sk.interestOps(sk.interestOps() & ~readyOps);
+            NioSender sender = (NioSender) sk.attachment();
+            try {
+                if (sender.process(sk,waitForAck)) {
+                    completed++;
+                    sender.setComplete(true);
+                    if ( Logs.MESSAGES.isTraceEnabled() ) {
+                        Logs.MESSAGES.trace("ParallelNioSender - Sent msg:" + new UniqueId(msg.getUniqueId()) + " at " +new java.sql.Timestamp(System.currentTimeMillis())+ " to "+sender.getDestination().getName());
+                    }
+                    SenderState.getSenderState(sender.getDestination()).setReady();
+                }//end if
+            } catch (Exception x) {
+                SenderState state = SenderState.getSenderState(sender.getDestination());
+                int attempt = sender.getAttempt()+1;
+                boolean retry = (sender.getAttempt() <= maxAttempts && maxAttempts>0);
+                synchronized (state) {
+                
+                    //sk.cancel();
+                    if (state.isSuspect()) state.setFailing();
+                    if (state.isReady()) {
+                        state.setSuspect();
+                        if ( retry ) 
+                            log.warn("Member send is failing for:" + sender.getDestination().getName() +" ; Setting to suspect and retrying.");
+                        else 
+                            log.warn("Member send is failing for:" + sender.getDestination().getName() +" ; Setting to suspect.", x);
+                    }                    
+                }
+                if ( !isConnected() ) {
+                    log.warn("Not retrying send for:" + sender.getDestination().getName() + "; Sender is disconnected.");
+                    ChannelException cx = new ChannelException("Send failed, and sender is disconnected. Not retrying.",x);
+                    cx.addFaultyMember(sender.getDestination(),x);
+                    throw cx;
+                }
+                
+                byte[] data = sender.getMessage();
+                if ( retry ) {
+                    try { 
+                        sender.disconnect(); 
+                        sender.connect();
+                        sender.setAttempt(attempt);
+                        sender.setMessage(data);
+                    }catch ( Exception ignore){
+                        state.setFailing();
+                    }
+                } else {
+                    ChannelException cx = new ChannelException("Send failed, attempt:"+sender.getAttempt()+" max:"+maxAttempts,x);
+                    cx.addFaultyMember(sender.getDestination(),x);
+                    throw cx;
+                }//end if
+            }
+        }
+        return completed;
+
+    }
+    
+    private void connect(NioSender[] senders) throws ChannelException {
+        ChannelException x = null;
+        for (int i=0; i<senders.length; i++ ) {
+            try {
+                if (!senders[i].isConnected()) senders[i].connect();
+            }catch ( IOException io ) {
+                if ( x==null ) x = new ChannelException(io);
+                x.addFaultyMember(senders[i].getDestination(),io);
+            }
+        }
+        if ( x != null ) throw x;
+    }
+    
+    private void setData(NioSender[] senders, byte[] data) throws ChannelException {
+        ChannelException x = null;
+        for (int i=0; i<senders.length; i++ ) {
+            try {
+                senders[i].setMessage(data);
+            }catch ( IOException io ) {
+                if ( x==null ) x = new ChannelException(io);
+                x.addFaultyMember(senders[i].getDestination(),io);
+            }
+        }
+        if ( x != null ) throw x;
+    }
+    
+    
+    private NioSender[] setupForSend(Member[] destination) throws ChannelException {
+        ChannelException cx = null;
+        NioSender[] result = new NioSender[destination.length];
+        for ( int i=0; i<destination.length; i++ ) {
+            NioSender sender = (NioSender)nioSenders.get(destination[i]);
+            try {
+
+                if (sender == null) {
+                    sender = new NioSender();
+                    sender.transferProperties(this, sender);
+                    nioSenders.put(destination[i], sender);
+                }
+                if (sender != null) {
+                    sender.reset();
+                    sender.setDestination(destination[i]);
+                    sender.setSelector(selector);
+                    result[i] = sender;
+                }
+            }catch ( UnknownHostException x ) {
+                if (cx == null) cx = new ChannelException("Unable to setup NioSender.", x);
+                cx.addFaultyMember(destination[i], x);
+            }
+        }
+        if ( cx != null ) throw cx;
+        else return result;
+    }
+    
+    public void connect() {
+        //do nothing, we connect on demand
+        setConnected(true);
+    }
+    
+    
+    private synchronized void close() throws ChannelException  {
+        ChannelException x = null;
+        Object[] members = nioSenders.keySet().toArray();
+        for (int i=0; i<members.length; i++ ) {
+            Member mbr = (Member)members[i];
+            try {
+                NioSender sender = (NioSender)nioSenders.get(mbr);
+                sender.disconnect();
+            }catch ( Exception e ) {
+                if ( x == null ) x = new ChannelException(e);
+                x.addFaultyMember(mbr,e);
+            }
+            nioSenders.remove(mbr);
+        }
+        if ( x != null ) throw x;
+    }
+    
+    public void memberAdded(Member member) {
+        
+    }
+    
+    public void memberDisappeared(Member member) {
+        //disconnect senders
+        NioSender sender = (NioSender)nioSenders.remove(member);
+        if ( sender != null ) sender.disconnect();
+    }
+
+    
+    public synchronized void disconnect() {
+        setConnected(false);
+        try {close(); }catch (Exception x){}
+        
+    }
+    
+    public void finalize() {
+        try {disconnect(); }catch ( Exception ignore){}
+    }
+
+    public boolean keepalive() {
+        //throw new UnsupportedOperationException("Method ParallelNioSender.checkKeepAlive() not implemented");
+        boolean result = false;
+        for ( Iterator i = nioSenders.entrySet().iterator(); i.hasNext();  ) {
+            Map.Entry entry = (Map.Entry)i.next();
+            NioSender sender = (NioSender)entry.getValue();
+            if ( sender.keepalive() ) {
+                nioSenders.remove(entry.getKey());
+            }
+        }
+        return result;
+    }
+
 }
\ No newline at end of file

==================================================
Arrays.java
index 582785b788..5b9fa4e0ba 100644
--- a/java/org/apache/catalina/tribes/transport/nio/PooledParallelSender.java
+++ b/java/org/apache/catalina/tribes/transport/nio/PooledParallelSender.java
@@ -1,85 +1,85 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.transport.nio;
-
-import java.io.IOException;
-
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.transport.DataSender;
-import org.apache.catalina.tribes.transport.MultiPointSender;
-import org.apache.catalina.tribes.transport.PooledSender;
-
-/**
- * <p>Title: </p>
- *
- * <p>Description: </p>
- *
- * <p>Copyright: Copyright (c) 2005</p>
- *
- * <p>Company: </p>
- *
- * @author not attributable
- * @version 1.0
- */
-public class PooledParallelSender extends PooledSender implements MultiPointSender {
-    protected boolean connected = true;
-    public PooledParallelSender() {
-        super();
-    }
-    
-    public void sendMessage(Member[] destination, ChannelMessage message) throws ChannelException {
-        if ( !connected ) throw new ChannelException("Sender not connected.");
-        ParallelNioSender sender = (ParallelNioSender)getSender();
-        try {
-            sender.sendMessage(destination, message);
-            sender.keepalive();
-        }finally {
-            if ( !connected ) disconnect();
-            returnSender(sender);
-        }
-    }
-
-    public DataSender getNewDataSender() {
-        try {
-            ParallelNioSender sender = new ParallelNioSender();
-            sender.transferProperties(this,sender);
-            return sender;
-        } catch ( IOException x ) {
-            throw new RuntimeException("Unable to open NIO selector.",x);
-        }
-    }
-    
-    public synchronized void disconnect() {
-        this.connected = false;
-        super.disconnect();
-    }
-
-    public synchronized void connect() throws IOException {
-        this.connected = true;
-        super.connect();
-    }
-
-    public void memberAdded(Member member) {
-    
-    }
-    
-    public void memberDisappeared(Member member) {
-        //disconnect senders
-    }    
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.transport.nio;
+
+import java.io.IOException;
+
+import org.apache.catalina.tribes.ChannelException;
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.transport.DataSender;
+import org.apache.catalina.tribes.transport.MultiPointSender;
+import org.apache.catalina.tribes.transport.PooledSender;
+
+/**
+ * <p>Title: </p>
+ *
+ * <p>Description: </p>
+ *
+ * <p>Copyright: Copyright (c) 2005</p>
+ *
+ * <p>Company: </p>
+ *
+ * @author not attributable
+ * @version 1.0
+ */
+public class PooledParallelSender extends PooledSender implements MultiPointSender {
+    protected boolean connected = true;
+    public PooledParallelSender() {
+        super();
+    }
+    
+    public void sendMessage(Member[] destination, ChannelMessage message) throws ChannelException {
+        if ( !connected ) throw new ChannelException("Sender not connected.");
+        ParallelNioSender sender = (ParallelNioSender)getSender();
+        try {
+            sender.sendMessage(destination, message);
+            sender.keepalive();
+        }finally {
+            if ( !connected ) disconnect();
+            returnSender(sender);
+        }
+    }
+
+    public DataSender getNewDataSender() {
+        try {
+            ParallelNioSender sender = new ParallelNioSender();
+            sender.transferProperties(this,sender);
+            return sender;
+        } catch ( IOException x ) {
+            throw new RuntimeException("Unable to open NIO selector.",x);
+        }
+    }
+    
+    public synchronized void disconnect() {
+        this.connected = false;
+        super.disconnect();
+    }
+
+    public synchronized void connect() throws IOException {
+        this.connected = true;
+        super.connect();
+    }
+
+    public void memberAdded(Member member) {
+    
+    }
+    
+    public void memberDisappeared(Member member) {
+        //disconnect senders
+    }    
 }
\ No newline at end of file

==================================================
Logs.java
index b7488ab5a9..5b92e0f592 100644
--- a/java/org/apache/catalina/tribes/util/Arrays.java
+++ b/java/org/apache/catalina/tribes/util/Arrays.java
@@ -1,221 +1,221 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.util;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.UniqueId;
-import org.apache.catalina.tribes.group.AbsoluteOrder;
-import org.apache.catalina.tribes.membership.MemberImpl;
-import org.apache.catalina.tribes.membership.Membership;
-import java.io.UnsupportedEncodingException;
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-import java.util.StringTokenizer;
-
-/**
- * @author Filip Hanik
- * @version 1.0
- */
-public class Arrays {
-    protected static Log log = LogFactory.getLog(Arrays.class);
-    
-    public static boolean contains(byte[] source, int srcoffset, byte[] key, int keyoffset, int length) {
-        if ( srcoffset < 0 || srcoffset >= source.length) throw new ArrayIndexOutOfBoundsException("srcoffset is out of bounds.");
-        if ( keyoffset < 0 || keyoffset >= key.length) throw new ArrayIndexOutOfBoundsException("keyoffset is out of bounds.");
-        if ( length > (key.length-keyoffset) ) throw new ArrayIndexOutOfBoundsException("not enough data elements in the key, length is out of bounds.");
-        //we don't have enough data to validate it
-        if ( length > (source.length-srcoffset) ) return false;
-        boolean match = true;
-        int pos = keyoffset;
-        for ( int i=srcoffset; match && i<length; i++ ) {
-            match = (source[i] == key[pos++]);
-        }
-        return match;
-    }
-    
-    public static String toString(byte[] data) {
-        return toString(data,0,data!=null?data.length:0);
-    }
-
-    public static String toString(byte[] data, int offset, int length) {
-        StringBuffer buf = new StringBuffer("{");
-        if ( data != null && length > 0 ) {
-            buf.append(data[offset++]);
-            for (int i = offset; i < length; i++) {
-                buf.append(", ").append(data[i]);
-            }
-        }
-        buf.append("}");
-        return buf.toString();
-    }
-    
-    public static String toString(Object[] data) {
-        return toString(data,0,data!=null?data.length:0);
-    }
-    
-    public static String toString(Object[] data, int offset, int length) {
-        StringBuffer buf = new StringBuffer("{");
-        if ( data != null && length > 0 ) {
-            buf.append(data[offset++]);
-            for (int i = offset; i < length; i++) {
-                buf.append(", ").append(data[i]);
-            }
-        }
-        buf.append("}");
-        return buf.toString();
-    }
-    
-    public static String toNameString(Member[] data) {
-        return toNameString(data,0,data!=null?data.length:0);
-    }
-    
-    public static String toNameString(Member[] data, int offset, int length) {
-        StringBuffer buf = new StringBuffer("{");
-        if ( data != null && length > 0 ) {
-            buf.append(data[offset++].getName());
-            for (int i = offset; i < length; i++) {
-                buf.append(", ").append(data[i].getName());
-            }
-        }
-        buf.append("}");
-        return buf.toString();
-    }
-
-    public static int add(int[] data) {
-        int result = 0;
-        for (int i=0;i<data.length; i++ ) result += data[i];
-        return result;
-    }
-    
-    public static UniqueId getUniqudId(ChannelMessage msg) {
-        return new UniqueId(msg.getUniqueId());
-    }
-
-    public static UniqueId getUniqudId(byte[] data) {
-        return new UniqueId(data);
-    }
-    
-    public static boolean equals(byte[] o1, byte[] o2) {
-        return java.util.Arrays.equals(o1,o2);
-    }
-
-    public static boolean equals(Object[] o1, Object[] o2) {
-        boolean result = o1.length == o2.length;
-        if ( result ) for (int i=0; i<o1.length && result; i++ ) result = o1[i].equals(o2[i]);
-        return result;
-    }
-    
-    public static boolean sameMembers(Member[] m1, Member[] m2) {
-        AbsoluteOrder.absoluteOrder(m1);
-        AbsoluteOrder.absoluteOrder(m2);
-        return equals(m1,m2);
-    }
-    
-    public static Member[] merge(Member[] m1, Member[] m2) {
-        AbsoluteOrder.absoluteOrder(m1);
-        AbsoluteOrder.absoluteOrder(m2);
-        ArrayList list = new ArrayList(java.util.Arrays.asList(m1));
-        for (int i=0; i<m2.length; i++) if ( !list.contains(m2[i]) ) list.add(m2[i]);
-        Member[] result = new Member[list.size()];
-        list.toArray(result);
-        AbsoluteOrder.absoluteOrder(result);
-        return result;
-    }
-    
-    public static void fill(Membership mbrship, Member[] m) {
-        for (int i=0; i<m.length; i++ ) mbrship.addMember((MemberImpl)m[i]);
-    }
-    
-    public static Member[] diff(Membership complete, Membership local, MemberImpl ignore) {
-        ArrayList result = new ArrayList();
-        MemberImpl[] comp = complete.getMembers();
-        for ( int i=0; i<comp.length; i++ ) {
-            if ( ignore!=null && ignore.equals(comp[i]) ) continue;
-            if ( local.getMember(comp[i]) == null ) result.add(comp[i]);
-        }
-        return (MemberImpl[])result.toArray(new MemberImpl[result.size()]);
-    }
-    
-    public static Member[] remove(Member[] all, Member remove) {
-        return extract(all,new Member[] {remove});
-    }
-    
-    public static Member[] extract(Member[] all, Member[] remove) {
-        List alist = java.util.Arrays.asList(all);
-        ArrayList list = new ArrayList(alist);
-        for (int i=0; i<remove.length; i++ ) list.remove(remove[i]);
-        return (Member[])list.toArray(new Member[list.size()]);
-    }
-    
-    public static int indexOf(Member member, Member[] members) {
-        int result = -1;
-        for (int i=0; (result==-1) && (i<members.length); i++ ) 
-            if ( member.equals(members[i]) ) result = i;
-        return result;
-    }
-    
-    public static int nextIndex(Member member, Member[] members) {
-        int idx = indexOf(member,members)+1;
-        if (idx >= members.length ) idx = ((members.length>0)?0:-1);
-        
-//System.out.println("Next index:"+idx);
-//System.out.println("Member:"+member.getName());
-//System.out.println("Members:"+toNameString(members));
-        return idx;
-    }
-    
-    public static int hashCode(byte a[]) {
-        if (a == null)
-            return 0;
-
-        int result = 1;
-        for (int i=0; i<a.length; i++) {
-            byte element = a[i];
-            result = 31 * result + element;
-        }
-        return result;
-    }
-    
-    public static byte[] fromString(String value) { 
-        if ( value == null ) return null;
-        if ( !value.startsWith("{") ) throw new RuntimeException("byte arrays must be represented as {1,3,4,5,6}");
-        StringTokenizer t = new StringTokenizer(value,"{,}",false);
-        byte[] result = new byte[t.countTokens()];
-        for (int i=0; i<result.length; i++ ) result[i] = Byte.parseByte(t.nextToken());
-        return result;
-    }
-
-    
- 
-    public static byte[] convert(String s) {
-        try {
-            return s.getBytes("ISO-8859-1");
-        }catch (UnsupportedEncodingException ux ) {
-            log.error("Unable to convert ["+s+"] into a byte[] using ISO-8859-1 encoding, falling back to default encoding.");
-            return s.getBytes();
-        }
-    }
-
-
-    
-    
-    
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.util;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.catalina.tribes.ChannelMessage;
+import org.apache.catalina.tribes.Member;
+import org.apache.catalina.tribes.UniqueId;
+import org.apache.catalina.tribes.group.AbsoluteOrder;
+import org.apache.catalina.tribes.membership.MemberImpl;
+import org.apache.catalina.tribes.membership.Membership;
+import java.io.UnsupportedEncodingException;
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+import java.util.StringTokenizer;
+
+/**
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class Arrays {
+    protected static Log log = LogFactory.getLog(Arrays.class);
+    
+    public static boolean contains(byte[] source, int srcoffset, byte[] key, int keyoffset, int length) {
+        if ( srcoffset < 0 || srcoffset >= source.length) throw new ArrayIndexOutOfBoundsException("srcoffset is out of bounds.");
+        if ( keyoffset < 0 || keyoffset >= key.length) throw new ArrayIndexOutOfBoundsException("keyoffset is out of bounds.");
+        if ( length > (key.length-keyoffset) ) throw new ArrayIndexOutOfBoundsException("not enough data elements in the key, length is out of bounds.");
+        //we don't have enough data to validate it
+        if ( length > (source.length-srcoffset) ) return false;
+        boolean match = true;
+        int pos = keyoffset;
+        for ( int i=srcoffset; match && i<length; i++ ) {
+            match = (source[i] == key[pos++]);
+        }
+        return match;
+    }
+    
+    public static String toString(byte[] data) {
+        return toString(data,0,data!=null?data.length:0);
+    }
+
+    public static String toString(byte[] data, int offset, int length) {
+        StringBuffer buf = new StringBuffer("{");
+        if ( data != null && length > 0 ) {
+            buf.append(data[offset++]);
+            for (int i = offset; i < length; i++) {
+                buf.append(", ").append(data[i]);
+            }
+        }
+        buf.append("}");
+        return buf.toString();
+    }
+    
+    public static String toString(Object[] data) {
+        return toString(data,0,data!=null?data.length:0);
+    }
+    
+    public static String toString(Object[] data, int offset, int length) {
+        StringBuffer buf = new StringBuffer("{");
+        if ( data != null && length > 0 ) {
+            buf.append(data[offset++]);
+            for (int i = offset; i < length; i++) {
+                buf.append(", ").append(data[i]);
+            }
+        }
+        buf.append("}");
+        return buf.toString();
+    }
+    
+    public static String toNameString(Member[] data) {
+        return toNameString(data,0,data!=null?data.length:0);
+    }
+    
+    public static String toNameString(Member[] data, int offset, int length) {
+        StringBuffer buf = new StringBuffer("{");
+        if ( data != null && length > 0 ) {
+            buf.append(data[offset++].getName());
+            for (int i = offset; i < length; i++) {
+                buf.append(", ").append(data[i].getName());
+            }
+        }
+        buf.append("}");
+        return buf.toString();
+    }
+
+    public static int add(int[] data) {
+        int result = 0;
+        for (int i=0;i<data.length; i++ ) result += data[i];
+        return result;
+    }
+    
+    public static UniqueId getUniqudId(ChannelMessage msg) {
+        return new UniqueId(msg.getUniqueId());
+    }
+
+    public static UniqueId getUniqudId(byte[] data) {
+        return new UniqueId(data);
+    }
+    
+    public static boolean equals(byte[] o1, byte[] o2) {
+        return java.util.Arrays.equals(o1,o2);
+    }
+
+    public static boolean equals(Object[] o1, Object[] o2) {
+        boolean result = o1.length == o2.length;
+        if ( result ) for (int i=0; i<o1.length && result; i++ ) result = o1[i].equals(o2[i]);
+        return result;
+    }
+    
+    public static boolean sameMembers(Member[] m1, Member[] m2) {
+        AbsoluteOrder.absoluteOrder(m1);
+        AbsoluteOrder.absoluteOrder(m2);
+        return equals(m1,m2);
+    }
+    
+    public static Member[] merge(Member[] m1, Member[] m2) {
+        AbsoluteOrder.absoluteOrder(m1);
+        AbsoluteOrder.absoluteOrder(m2);
+        ArrayList list = new ArrayList(java.util.Arrays.asList(m1));
+        for (int i=0; i<m2.length; i++) if ( !list.contains(m2[i]) ) list.add(m2[i]);
+        Member[] result = new Member[list.size()];
+        list.toArray(result);
+        AbsoluteOrder.absoluteOrder(result);
+        return result;
+    }
+    
+    public static void fill(Membership mbrship, Member[] m) {
+        for (int i=0; i<m.length; i++ ) mbrship.addMember((MemberImpl)m[i]);
+    }
+    
+    public static Member[] diff(Membership complete, Membership local, MemberImpl ignore) {
+        ArrayList result = new ArrayList();
+        MemberImpl[] comp = complete.getMembers();
+        for ( int i=0; i<comp.length; i++ ) {
+            if ( ignore!=null && ignore.equals(comp[i]) ) continue;
+            if ( local.getMember(comp[i]) == null ) result.add(comp[i]);
+        }
+        return (MemberImpl[])result.toArray(new MemberImpl[result.size()]);
+    }
+    
+    public static Member[] remove(Member[] all, Member remove) {
+        return extract(all,new Member[] {remove});
+    }
+    
+    public static Member[] extract(Member[] all, Member[] remove) {
+        List alist = java.util.Arrays.asList(all);
+        ArrayList list = new ArrayList(alist);
+        for (int i=0; i<remove.length; i++ ) list.remove(remove[i]);
+        return (Member[])list.toArray(new Member[list.size()]);
+    }
+    
+    public static int indexOf(Member member, Member[] members) {
+        int result = -1;
+        for (int i=0; (result==-1) && (i<members.length); i++ ) 
+            if ( member.equals(members[i]) ) result = i;
+        return result;
+    }
+    
+    public static int nextIndex(Member member, Member[] members) {
+        int idx = indexOf(member,members)+1;
+        if (idx >= members.length ) idx = ((members.length>0)?0:-1);
+        
+//System.out.println("Next index:"+idx);
+//System.out.println("Member:"+member.getName());
+//System.out.println("Members:"+toNameString(members));
+        return idx;
+    }
+    
+    public static int hashCode(byte a[]) {
+        if (a == null)
+            return 0;
+
+        int result = 1;
+        for (int i=0; i<a.length; i++) {
+            byte element = a[i];
+            result = 31 * result + element;
+        }
+        return result;
+    }
+    
+    public static byte[] fromString(String value) { 
+        if ( value == null ) return null;
+        if ( !value.startsWith("{") ) throw new RuntimeException("byte arrays must be represented as {1,3,4,5,6}");
+        StringTokenizer t = new StringTokenizer(value,"{,}",false);
+        byte[] result = new byte[t.countTokens()];
+        for (int i=0; i<result.length; i++ ) result[i] = Byte.parseByte(t.nextToken());
+        return result;
+    }
+
+    
+ 
+    public static byte[] convert(String s) {
+        try {
+            return s.getBytes("ISO-8859-1");
+        }catch (UnsupportedEncodingException ux ) {
+            log.error("Unable to convert ["+s+"] into a byte[] using ISO-8859-1 encoding, falling back to default encoding.");
+            return s.getBytes();
+        }
+    }
+
+
+    
+    
+    
 }
\ No newline at end of file

==================================================
StringManager.java
index 12e1d91aea..23b1d34590 100644
--- a/java/org/apache/catalina/tribes/util/Logs.java
+++ b/java/org/apache/catalina/tribes/util/Logs.java
@@ -1,29 +1,29 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.util;
-
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-/**
- * 
- * Simple class that holds references to global loggers
- * @author Filip Hanik
- * @version 1.0
- */
-public class Logs {
-    public static Log MESSAGES = LogFactory.getLog( "org.apache.catalina.tribes.MESSAGES" );
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.util;
+
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+/**
+ * 
+ * Simple class that holds references to global loggers
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class Logs {
+    public static Log MESSAGES = LogFactory.getLog( "org.apache.catalina.tribes.MESSAGES" );
+}

==================================================
UUIDGenerator.java
index dd4e88944b..e2b22291d1 100644
--- a/java/org/apache/catalina/tribes/util/StringManager.java
+++ b/java/org/apache/catalina/tribes/util/StringManager.java
@@ -1,253 +1,253 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina.tribes.util;
-
-import java.text.MessageFormat;
-import java.util.Hashtable;
-import java.util.Locale;
-import java.util.MissingResourceException;
-import java.util.ResourceBundle;
-import java.net.URLClassLoader;
-
-/**
- * An internationalization / localization helper class which reduces
- * the bother of handling ResourceBundles and takes care of the
- * common cases of message formating which otherwise require the
- * creation of Object arrays and such.
- *
- * <p>The StringManager operates on a package basis. One StringManager
- * per package can be created and accessed via the getManager method
- * call.
- *
- * <p>The StringManager will look for a ResourceBundle named by
- * the package name given plus the suffix of "LocalStrings". In
- * practice, this means that the localized information will be contained
- * in a LocalStrings.properties file located in the package
- * directory of the classpath.
- *
- * <p>Please see the documentation for java.util.ResourceBundle for
- * more information.
- *
- * @author James Duncan Davidson [duncan@eng.sun.com]
- * @author James Todd [gonzo@eng.sun.com]
- */
-
-public class StringManager {
-
-    /**
-     * The ResourceBundle for this StringManager.
-     */
-
-    private ResourceBundle bundle;
-
-    private static org.apache.juli.logging.Log log=
-        org.apache.juli.logging.LogFactory.getLog( StringManager.class );
-
-    /**
-     * Creates a new StringManager for a given package. This is a
-     * private method and all access to it is arbitrated by the
-     * static getManager method call so that only one StringManager
-     * per package will be created.
-     *
-     * @param packageName Name of package to create StringManager for.
-     */
-
-    private StringManager(String packageName) {
-        String bundleName = packageName + ".LocalStrings";
-        try {
-            bundle = ResourceBundle.getBundle(bundleName);
-            return;
-        } catch( MissingResourceException ex ) {
-            // Try from the current loader ( that's the case for trusted apps )
-            ClassLoader cl=Thread.currentThread().getContextClassLoader();
-            if( cl != null ) {
-                try {
-                    bundle=ResourceBundle.getBundle(bundleName, Locale.getDefault(), cl);
-                    return;
-                } catch(MissingResourceException ex2) {
-                }
-            }
-            if( cl==null )
-                cl=this.getClass().getClassLoader();
-
-            if (log.isDebugEnabled())
-                log.debug("Can't find resource " + bundleName +
-                    " " + cl);
-            if( cl instanceof URLClassLoader ) {
-                if (log.isDebugEnabled()) 
-                    log.debug( ((URLClassLoader)cl).getURLs());
-            }
-        }
-    }
-
-    /**
-     * Get a string from the underlying resource bundle.
-     *
-     * @param key The resource name
-     */
-    public String getString(String key) {
-        return MessageFormat.format(getStringInternal(key), (Object [])null);
-    }
-
-
-    protected String getStringInternal(String key) {
-        if (key == null) {
-            String msg = "key is null";
-
-            throw new NullPointerException(msg);
-        }
-
-        String str = null;
-
-        if( bundle==null )
-            return key;
-        try {
-            str = bundle.getString(key);
-        } catch (MissingResourceException mre) {
-            str = "Cannot find message associated with key '" + key + "'";
-        }
-
-        return str;
-    }
-
-    /**
-     * Get a string from the underlying resource bundle and format
-     * it with the given set of arguments.
-     *
-     * @param key The resource name
-     * @param args Formatting directives
-     */
-
-    public String getString(String key, Object[] args) {
-        String iString = null;
-        String value = getStringInternal(key);
-
-        // this check for the runtime exception is some pre 1.1.6
-        // VM's don't do an automatic toString() on the passed in
-        // objects and barf out
-
-        try {
-            // ensure the arguments are not null so pre 1.2 VM's don't barf
-            Object nonNullArgs[] = args;
-            for (int i=0; i<args.length; i++) {
-                if (args[i] == null) {
-                    if (nonNullArgs==args) nonNullArgs=(Object[])args.clone();
-                    nonNullArgs[i] = "null";
-                }
-            }
-
-            iString = MessageFormat.format(value, nonNullArgs);
-        } catch (IllegalArgumentException iae) {
-            StringBuffer buf = new StringBuffer();
-            buf.append(value);
-            for (int i = 0; i < args.length; i++) {
-                buf.append(" arg[" + i + "]=" + args[i]);
-            }
-            iString = buf.toString();
-        }
-        return iString;
-    }
-
-    /**
-     * Get a string from the underlying resource bundle and format it
-     * with the given object argument. This argument can of course be
-     * a String object.
-     *
-     * @param key The resource name
-     * @param arg Formatting directive
-     */
-
-    public String getString(String key, Object arg) {
-        Object[] args = new Object[] {arg};
-        return getString(key, args);
-    }
-
-    /**
-     * Get a string from the underlying resource bundle and format it
-     * with the given object arguments. These arguments can of course
-     * be String objects.
-     *
-     * @param key The resource name
-     * @param arg1 Formatting directive
-     * @param arg2 Formatting directive
-     */
-
-    public String getString(String key, Object arg1, Object arg2) {
-        Object[] args = new Object[] {arg1, arg2};
-        return getString(key, args);
-    }
-
-    /**
-     * Get a string from the underlying resource bundle and format it
-     * with the given object arguments. These arguments can of course
-     * be String objects.
-     *
-     * @param key The resource name
-     * @param arg1 Formatting directive
-     * @param arg2 Formatting directive
-     * @param arg3 Formatting directive
-     */
-
-    public String getString(String key, Object arg1, Object arg2,
-                            Object arg3) {
-        Object[] args = new Object[] {arg1, arg2, arg3};
-        return getString(key, args);
-    }
-
-    /**
-     * Get a string from the underlying resource bundle and format it
-     * with the given object arguments. These arguments can of course
-     * be String objects.
-     *
-     * @param key The resource name
-     * @param arg1 Formatting directive
-     * @param arg2 Formatting directive
-     * @param arg3 Formatting directive
-     * @param arg4 Formatting directive
-     */
-
-    public String getString(String key, Object arg1, Object arg2,
-                            Object arg3, Object arg4) {
-        Object[] args = new Object[] {arg1, arg2, arg3, arg4};
-        return getString(key, args);
-    }
-    // --------------------------------------------------------------
-    // STATIC SUPPORT METHODS
-    // --------------------------------------------------------------
-
-    private static Hashtable managers = new Hashtable();
-
-    /**
-     * Get the StringManager for a particular package. If a manager for
-     * a package already exists, it will be reused, else a new
-     * StringManager will be created and returned.
-     *
-     * @param packageName The package name
-     */
-
-    public synchronized static StringManager getManager(String packageName) {
-        StringManager mgr = (StringManager)managers.get(packageName);
-
-        if (mgr == null) {
-            mgr = new StringManager(packageName);
-            managers.put(packageName, mgr);
-        }
-        return mgr;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.catalina.tribes.util;
+
+import java.text.MessageFormat;
+import java.util.Hashtable;
+import java.util.Locale;
+import java.util.MissingResourceException;
+import java.util.ResourceBundle;
+import java.net.URLClassLoader;
+
+/**
+ * An internationalization / localization helper class which reduces
+ * the bother of handling ResourceBundles and takes care of the
+ * common cases of message formating which otherwise require the
+ * creation of Object arrays and such.
+ *
+ * <p>The StringManager operates on a package basis. One StringManager
+ * per package can be created and accessed via the getManager method
+ * call.
+ *
+ * <p>The StringManager will look for a ResourceBundle named by
+ * the package name given plus the suffix of "LocalStrings". In
+ * practice, this means that the localized information will be contained
+ * in a LocalStrings.properties file located in the package
+ * directory of the classpath.
+ *
+ * <p>Please see the documentation for java.util.ResourceBundle for
+ * more information.
+ *
+ * @author James Duncan Davidson [duncan@eng.sun.com]
+ * @author James Todd [gonzo@eng.sun.com]
+ */
+
+public class StringManager {
+
+    /**
+     * The ResourceBundle for this StringManager.
+     */
+
+    private ResourceBundle bundle;
+
+    private static org.apache.juli.logging.Log log=
+        org.apache.juli.logging.LogFactory.getLog( StringManager.class );
+
+    /**
+     * Creates a new StringManager for a given package. This is a
+     * private method and all access to it is arbitrated by the
+     * static getManager method call so that only one StringManager
+     * per package will be created.
+     *
+     * @param packageName Name of package to create StringManager for.
+     */
+
+    private StringManager(String packageName) {
+        String bundleName = packageName + ".LocalStrings";
+        try {
+            bundle = ResourceBundle.getBundle(bundleName);
+            return;
+        } catch( MissingResourceException ex ) {
+            // Try from the current loader ( that's the case for trusted apps )
+            ClassLoader cl=Thread.currentThread().getContextClassLoader();
+            if( cl != null ) {
+                try {
+                    bundle=ResourceBundle.getBundle(bundleName, Locale.getDefault(), cl);
+                    return;
+                } catch(MissingResourceException ex2) {
+                }
+            }
+            if( cl==null )
+                cl=this.getClass().getClassLoader();
+
+            if (log.isDebugEnabled())
+                log.debug("Can't find resource " + bundleName +
+                    " " + cl);
+            if( cl instanceof URLClassLoader ) {
+                if (log.isDebugEnabled()) 
+                    log.debug( ((URLClassLoader)cl).getURLs());
+            }
+        }
+    }
+
+    /**
+     * Get a string from the underlying resource bundle.
+     *
+     * @param key The resource name
+     */
+    public String getString(String key) {
+        return MessageFormat.format(getStringInternal(key), (Object [])null);
+    }
+
+
+    protected String getStringInternal(String key) {
+        if (key == null) {
+            String msg = "key is null";
+
+            throw new NullPointerException(msg);
+        }
+
+        String str = null;
+
+        if( bundle==null )
+            return key;
+        try {
+            str = bundle.getString(key);
+        } catch (MissingResourceException mre) {
+            str = "Cannot find message associated with key '" + key + "'";
+        }
+
+        return str;
+    }
+
+    /**
+     * Get a string from the underlying resource bundle and format
+     * it with the given set of arguments.
+     *
+     * @param key The resource name
+     * @param args Formatting directives
+     */
+
+    public String getString(String key, Object[] args) {
+        String iString = null;
+        String value = getStringInternal(key);
+
+        // this check for the runtime exception is some pre 1.1.6
+        // VM's don't do an automatic toString() on the passed in
+        // objects and barf out
+
+        try {
+            // ensure the arguments are not null so pre 1.2 VM's don't barf
+            Object nonNullArgs[] = args;
+            for (int i=0; i<args.length; i++) {
+                if (args[i] == null) {
+                    if (nonNullArgs==args) nonNullArgs=(Object[])args.clone();
+                    nonNullArgs[i] = "null";
+                }
+            }
+
+            iString = MessageFormat.format(value, nonNullArgs);
+        } catch (IllegalArgumentException iae) {
+            StringBuffer buf = new StringBuffer();
+            buf.append(value);
+            for (int i = 0; i < args.length; i++) {
+                buf.append(" arg[" + i + "]=" + args[i]);
+            }
+            iString = buf.toString();
+        }
+        return iString;
+    }
+
+    /**
+     * Get a string from the underlying resource bundle and format it
+     * with the given object argument. This argument can of course be
+     * a String object.
+     *
+     * @param key The resource name
+     * @param arg Formatting directive
+     */
+
+    public String getString(String key, Object arg) {
+        Object[] args = new Object[] {arg};
+        return getString(key, args);
+    }
+
+    /**
+     * Get a string from the underlying resource bundle and format it
+     * with the given object arguments. These arguments can of course
+     * be String objects.
+     *
+     * @param key The resource name
+     * @param arg1 Formatting directive
+     * @param arg2 Formatting directive
+     */
+
+    public String getString(String key, Object arg1, Object arg2) {
+        Object[] args = new Object[] {arg1, arg2};
+        return getString(key, args);
+    }
+
+    /**
+     * Get a string from the underlying resource bundle and format it
+     * with the given object arguments. These arguments can of course
+     * be String objects.
+     *
+     * @param key The resource name
+     * @param arg1 Formatting directive
+     * @param arg2 Formatting directive
+     * @param arg3 Formatting directive
+     */
+
+    public String getString(String key, Object arg1, Object arg2,
+                            Object arg3) {
+        Object[] args = new Object[] {arg1, arg2, arg3};
+        return getString(key, args);
+    }
+
+    /**
+     * Get a string from the underlying resource bundle and format it
+     * with the given object arguments. These arguments can of course
+     * be String objects.
+     *
+     * @param key The resource name
+     * @param arg1 Formatting directive
+     * @param arg2 Formatting directive
+     * @param arg3 Formatting directive
+     * @param arg4 Formatting directive
+     */
+
+    public String getString(String key, Object arg1, Object arg2,
+                            Object arg3, Object arg4) {
+        Object[] args = new Object[] {arg1, arg2, arg3, arg4};
+        return getString(key, args);
+    }
+    // --------------------------------------------------------------
+    // STATIC SUPPORT METHODS
+    // --------------------------------------------------------------
+
+    private static Hashtable managers = new Hashtable();
+
+    /**
+     * Get the StringManager for a particular package. If a manager for
+     * a package already exists, it will be reused, else a new
+     * StringManager will be created and returned.
+     *
+     * @param packageName The package name
+     */
+
+    public synchronized static StringManager getManager(String packageName) {
+        StringManager mgr = (StringManager)managers.get(packageName);
+
+        if (mgr == null) {
+            mgr = new StringManager(packageName);
+            managers.put(packageName, mgr);
+        }
+        return mgr;
+    }
+}

==================================================
AbstractGroup.java
index b450d352fd..4514f49a9a 100644
--- a/java/org/apache/catalina/tribes/util/UUIDGenerator.java
+++ b/java/org/apache/catalina/tribes/util/UUIDGenerator.java
@@ -1,77 +1,77 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.util;
-
-import java.security.SecureRandom;
-import java.util.Random;
-
-/**
- * simple generation of a UUID 
- * @author Filip Hanik
- * @version 1.0
- */
-public class UUIDGenerator {
-    public static final int UUID_LENGTH = 16;
-    public static final int UUID_VERSION = 4;
-    public static final int BYTES_PER_INT = 4;
-    public static final int BITS_PER_BYTE = 8;
-    
-    protected static SecureRandom secrand = null;
-    protected static Random rand = new Random(System.currentTimeMillis());
-    static {
-        secrand = new SecureRandom();
-        secrand.setSeed(rand.nextLong());
-    }
-    
-    public static byte[] randomUUID(boolean secure) {
-        byte[] result = new byte[UUID_LENGTH];
-        return randomUUID(secure,result,0);
-    }
-
-    public static byte[] randomUUID(boolean secure, byte[] into, int offset) {
-        if ( (offset+UUID_LENGTH)>into.length )
-            throw new ArrayIndexOutOfBoundsException("Unable to fit "+UUID_LENGTH+" bytes into the array. length:"+into.length+" required length:"+(offset+UUID_LENGTH));
-        Random r = (secure&&(secrand!=null))?secrand:rand;
-        nextBytes(into,offset,UUID_LENGTH,r);
-        into[6+offset] &= 0x0F;
-        into[6+offset] |= (UUID_VERSION << 4);
-        into[8+offset] &= 0x3F; //0011 1111
-        into[8+offset] |= 0x80; //1000 0000
-        return into;
-    }
-    
-    /**
-     * Same as java.util.Random.nextBytes except this one we dont have to allocate a new byte array
-     * @param into byte[]
-     * @param offset int
-     * @param length int
-     * @param r Random
-     */
-    public static void nextBytes(byte[] into, int offset, int length, Random r) {
-        int numRequested = length;
-        int numGot = 0, rnd = 0;
-        while (true) {
-            for (int i = 0; i < BYTES_PER_INT; i++) {
-                if (numGot == numRequested) return;
-                rnd = (i == 0 ? r.nextInt() : rnd >> BITS_PER_BYTE);
-                into[offset+numGot] = (byte) rnd;
-                numGot++;
-            }
-        }
-    }
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.tribes.util;
+
+import java.security.SecureRandom;
+import java.util.Random;
+
+/**
+ * simple generation of a UUID 
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class UUIDGenerator {
+    public static final int UUID_LENGTH = 16;
+    public static final int UUID_VERSION = 4;
+    public static final int BYTES_PER_INT = 4;
+    public static final int BITS_PER_BYTE = 8;
+    
+    protected static SecureRandom secrand = null;
+    protected static Random rand = new Random(System.currentTimeMillis());
+    static {
+        secrand = new SecureRandom();
+        secrand.setSeed(rand.nextLong());
+    }
+    
+    public static byte[] randomUUID(boolean secure) {
+        byte[] result = new byte[UUID_LENGTH];
+        return randomUUID(secure,result,0);
+    }
+
+    public static byte[] randomUUID(boolean secure, byte[] into, int offset) {
+        if ( (offset+UUID_LENGTH)>into.length )
+            throw new ArrayIndexOutOfBoundsException("Unable to fit "+UUID_LENGTH+" bytes into the array. length:"+into.length+" required length:"+(offset+UUID_LENGTH));
+        Random r = (secure&&(secrand!=null))?secrand:rand;
+        nextBytes(into,offset,UUID_LENGTH,r);
+        into[6+offset] &= 0x0F;
+        into[6+offset] |= (UUID_VERSION << 4);
+        into[8+offset] &= 0x3F; //0011 1111
+        into[8+offset] |= 0x80; //1000 0000
+        return into;
+    }
+    
+    /**
+     * Same as java.util.Random.nextBytes except this one we dont have to allocate a new byte array
+     * @param into byte[]
+     * @param offset int
+     * @param length int
+     * @param r Random
+     */
+    public static void nextBytes(byte[] into, int offset, int length, Random r) {
+        int numRequested = length;
+        int numGot = 0, rnd = 0;
+        while (true) {
+            for (int i = 0; i < BYTES_PER_INT; i++) {
+                if (numGot == numRequested) return;
+                rnd = (i == 0 ? r.nextInt() : rnd >> BITS_PER_BYTE);
+                into[offset+numGot] = (byte) rnd;
+                numGot++;
+            }
+        }
+    }
+
 }
\ No newline at end of file

==================================================
AbstractRole.java
index 1831c27ed9..e41c3a7fd6 100644
--- a/java/org/apache/catalina/users/AbstractGroup.java
+++ b/java/org/apache/catalina/users/AbstractGroup.java
@@ -30,7 +30,7 @@ import org.apache.catalina.UserDatabase;
  * <p>Convenience base class for {@link Group} implementations.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303133 $ $Date: 2004-08-29 18:46:15 +0200 (dim., 29 août 2004) $
+ * @version $Revision$ $Date$
  * @since 4.1
  */
 

==================================================
AbstractUser.java
index e950dbddad..83aa863cca 100644
--- a/java/org/apache/catalina/users/AbstractRole.java
+++ b/java/org/apache/catalina/users/AbstractRole.java
@@ -27,7 +27,7 @@ import org.apache.catalina.UserDatabase;
  * <p>Convenience base class for {@link Role} implementations.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  * @since 4.1
  */
 

==================================================
Constants.java
index 2665ff5121..46c4d09fe3 100644
--- a/java/org/apache/catalina/users/AbstractUser.java
+++ b/java/org/apache/catalina/users/AbstractUser.java
@@ -29,7 +29,7 @@ import org.apache.catalina.User;
  * <p>Convenience base class for {@link User} implementations.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303133 $ $Date: 2004-08-29 18:46:15 +0200 (dim., 29 août 2004) $
+ * @version $Revision$ $Date$
  * @since 4.1
  */
 

==================================================
MemoryGroup.java
index 9cd49eb806..a0b34875ae 100644
--- a/java/org/apache/catalina/users/Constants.java
+++ b/java/org/apache/catalina/users/Constants.java
@@ -24,7 +24,7 @@ package org.apache.catalina.users;
  *
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  * @since 4.1
  */
 

==================================================
MemoryRole.java
index 4e1a6389c1..94d7c463a7 100644
--- a/java/org/apache/catalina/users/MemoryGroup.java
+++ b/java/org/apache/catalina/users/MemoryGroup.java
@@ -31,7 +31,7 @@ import org.apache.catalina.UserDatabase;
  * {@link MemoryUserDatabase} implementation of {@link UserDatabase}.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303133 $ $Date: 2004-08-29 18:46:15 +0200 (dim., 29 août 2004) $
+ * @version $Revision$ $Date$
  * @since 4.1
  */
 

==================================================
MemoryUser.java
index f0f91c6c21..77169015cf 100644
--- a/java/org/apache/catalina/users/MemoryRole.java
+++ b/java/org/apache/catalina/users/MemoryRole.java
@@ -27,7 +27,7 @@ import org.apache.catalina.UserDatabase;
  * {@link MemoryUserDatabase} implementation of {@link UserDatabase}.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303133 $ $Date: 2004-08-29 18:46:15 +0200 (dim., 29 août 2004) $
+ * @version $Revision$ $Date$
  * @since 4.1
  */
 

==================================================
MemoryUserDatabase.java
index e7a413994a..02703509a7 100644
--- a/java/org/apache/catalina/users/MemoryUser.java
+++ b/java/org/apache/catalina/users/MemoryUser.java
@@ -32,7 +32,7 @@ import org.apache.catalina.util.RequestUtil;
  * {@link MemoryUserDatabase} implementation of {@link UserDatabase}.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303133 $ $Date: 2004-08-29 18:46:15 +0200 (dim., 29 août 2004) $
+ * @version $Revision$ $Date$
  * @since 4.1
  */
 

==================================================
MemoryUserDatabaseFactory.java
index d4f26ba261..6533d18e61 100644
--- a/java/org/apache/catalina/users/MemoryUserDatabase.java
+++ b/java/org/apache/catalina/users/MemoryUserDatabase.java
@@ -45,7 +45,7 @@ import org.xml.sax.Attributes;
  * and uses a specified XML file for its persistent storage.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 304047 $ $Date: 2005-08-04 15:12:16 +0200 (jeu., 04 août 2005) $
+ * @version $Revision$ $Date$
  * @since 4.1
  */
 

==================================================
Base64.java
index 6a1906da00..00f6733efc 100644
--- a/java/org/apache/catalina/users/MemoryUserDatabaseFactory.java
+++ b/java/org/apache/catalina/users/MemoryUserDatabaseFactory.java
@@ -45,7 +45,7 @@ import javax.naming.spi.ObjectFactory;
  * </ul>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 304046 $ $Date: 2005-08-04 15:06:56 +0200 (jeu., 04 août 2005) $
+ * @version $Revision$ $Date$
  * @since 4.1
  */
 

==================================================
CharsetMapper.java
index c01bded7d6..3148a848fe 100644
--- a/java/org/apache/catalina/util/Base64.java
+++ b/java/org/apache/catalina/util/Base64.java
@@ -28,7 +28,7 @@ import org.apache.tomcat.util.buf.CharChunk;
  * Internet Message Bodies. Reference 1996
  *
  * @author Jeffrey Rodriguez
- * @version $Id: Base64.java 303133 2004-08-29 16:46:15Z yoavs $
+ * @version $Id$
  */
 public final class  Base64
 {

==================================================
CustomObjectInputStream.java
index f52395bc73..80378b12f1 100644
--- a/java/org/apache/catalina/util/CharsetMapper.java
+++ b/java/org/apache/catalina/util/CharsetMapper.java
@@ -33,7 +33,7 @@ import java.util.Properties;
  * your own version for a particular web application.
  *
  * @author Craig R. McClanahan
- * @version $Date: 2005-01-05 11:00:45 +0100 (mer., 05 janv. 2005) $ $Version$
+ * @version $Date$ $Version$
  */
 
 public class CharsetMapper {

==================================================
DefaultAnnotationProcessor.java
index 3547775caa..f5f7e11bc8 100644
--- a/java/org/apache/catalina/util/CustomObjectInputStream.java
+++ b/java/org/apache/catalina/util/CustomObjectInputStream.java
@@ -30,7 +30,7 @@ import java.lang.reflect.Proxy;
  *
  * @author Craig R. McClanahan
  * @author Bip Thelin
- * @version $Revision: 304082 $, $Date: 2005-09-08 17:41:11 +0200 (jeu., 08 sept. 2005) $
+ * @version $Revision$, $Date$
  */
 
 public final class CustomObjectInputStream

==================================================
Enumerator.java
index be2ee92043..0c5039cd3c 100644
--- a/java/org/apache/catalina/util/DefaultAnnotationProcessor.java
+++ b/java/org/apache/catalina/util/DefaultAnnotationProcessor.java
@@ -39,7 +39,7 @@ import org.apache.AnnotationProcessor;
  *
  * @author Fabien Carrion
  * @author Remy Maucherat
- * @version $Revision: 303236 $, $Date: 2006-03-09 16:46:52 -0600 (Thu, 09 Mar 2006) $
+ * @version $Revision$, $Date$
  */
 public class DefaultAnnotationProcessor implements AnnotationProcessor {
     

==================================================
Extension.java
index 09441036e9..d04b4f1667 100644
--- a/java/org/apache/catalina/util/Enumerator.java
+++ b/java/org/apache/catalina/util/Enumerator.java
@@ -35,7 +35,7 @@ import java.util.NoSuchElementException;
  * Constructors are provided to easliy create such wrappers.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public final class Enumerator implements Enumeration {

==================================================
ExtensionValidator.java
index 18960bb799..87cb39638b 100644
--- a/java/org/apache/catalina/util/Extension.java
+++ b/java/org/apache/catalina/util/Extension.java
@@ -41,7 +41,7 @@ import java.util.StringTokenizer;
  * @author Craig McClanahan
  * @author Justyna Horwat
  * @author Greg Murray
- * @version $Revision: 360278 $ $Date: 2005-12-31 14:26:41 +0100 (sam., 31 déc. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public final class Extension {

==================================================
InstanceSupport.java
index f58318a904..a476501ce0 100644
--- a/java/org/apache/catalina/util/ExtensionValidator.java
+++ b/java/org/apache/catalina/util/ExtensionValidator.java
@@ -47,7 +47,7 @@ import org.apache.naming.resources.Resource;
  *
  * @author Greg Murray
  * @author Justyna Horwat
- * @version $Revision: 360278 $ $Date: 2005-12-31 14:26:41 +0100 (sam., 31 déc. 2005) $
+ * @version $Revision$ $Date$
  *
  */
 public final class ExtensionValidator {

==================================================
LifecycleSupport.java
index 6f824421a2..90560fe55c 100644
--- a/java/org/apache/catalina/util/InstanceSupport.java
+++ b/java/org/apache/catalina/util/InstanceSupport.java
@@ -33,7 +33,7 @@ import org.apache.catalina.Wrapper;
  * registered InstanceListeners.
  *
  * @author Craig R. McClanahan
- * @version $Id: InstanceSupport.java 303133 2004-08-29 16:46:15Z yoavs $
+ * @version $Id$
  */
 
 public final class InstanceSupport {

==================================================
MD5Encoder.java
index 32dd06033b..82fe25d400 100644
--- a/java/org/apache/catalina/util/LifecycleSupport.java
+++ b/java/org/apache/catalina/util/LifecycleSupport.java
@@ -29,7 +29,7 @@ import org.apache.catalina.LifecycleListener;
  * registered LifecycleListeners.
  *
  * @author Craig R. McClanahan
- * @version $Id: LifecycleSupport.java 302726 2004-02-27 14:59:07Z yoavs $
+ * @version $Id$
  */
 
 public final class LifecycleSupport {

==================================================
MIME2Java.java
index 5e1f1c982b..3643168d0a 100644
--- a/java/org/apache/catalina/util/MD5Encoder.java
+++ b/java/org/apache/catalina/util/MD5Encoder.java
@@ -27,7 +27,7 @@ package org.apache.catalina.util;
  * of the digest.
  *
  * @author Remy Maucherat
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public final class MD5Encoder {

==================================================
ManifestResource.java
index 45eff4d41c..831c177e5c 100644
--- a/java/org/apache/catalina/util/MIME2Java.java
+++ b/java/org/apache/catalina/util/MIME2Java.java
@@ -466,7 +466,7 @@ import java.util.*;
  *  </TR>
  * </TABLE>
  *
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  * @author TAMURA Kent &lt;kent@trl.ibm.co.jp&gt;
  */
 public class MIME2Java {

==================================================
ParameterMap.java
index 6bef95d4f9..29806dbfb2 100644
--- a/java/org/apache/catalina/util/ManifestResource.java
+++ b/java/org/apache/catalina/util/ManifestResource.java
@@ -27,7 +27,7 @@ import java.util.ArrayList;
  *  
  * @author Greg Murray
  * @author Justyna Horwat
- * @version $Revision: 360278 $ $Date: 2005-12-31 14:26:41 +0100 (sam., 31 déc. 2005) $
+ * @version $Revision$ $Date$
  * 
  */
 public class ManifestResource {

==================================================
RequestUtil.java
index 50836f7e64..c56243c771 100644
--- a/java/org/apache/catalina/util/ParameterMap.java
+++ b/java/org/apache/catalina/util/ParameterMap.java
@@ -31,7 +31,7 @@ import java.util.Map;
  * <code>ParmaeterMap</code> instance is not locked.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public final class ParameterMap extends HashMap {

==================================================
ResourceSet.java
index a29adc4735..5840aecdbe 100644
--- a/java/org/apache/catalina/util/RequestUtil.java
+++ b/java/org/apache/catalina/util/RequestUtil.java
@@ -32,7 +32,7 @@ import javax.servlet.http.Cookie;
  *
  * @author Craig R. McClanahan
  * @author Tim Tye
- * @version $Revision: 302905 $ $Date: 2004-05-26 18:41:54 +0200 (mer., 26 mai 2004) $
+ * @version $Revision$ $Date$
  */
 
 public final class RequestUtil {

==================================================
ServerInfo.java
index 4187aceb15..efc726aaff 100644
--- a/java/org/apache/catalina/util/ResourceSet.java
+++ b/java/org/apache/catalina/util/ResourceSet.java
@@ -31,7 +31,7 @@ import java.util.HashSet;
  * is not locked.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public final class ResourceSet extends HashSet {

==================================================
Strftime.java
index 52d4ebd02d..18aadf2af4 100644
--- a/java/org/apache/catalina/util/ServerInfo.java
+++ b/java/org/apache/catalina/util/ServerInfo.java
@@ -28,7 +28,7 @@ import java.util.Properties;
  * when integrating Tomcat.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303276 $ $Date: 2004-09-24 18:41:12 +0200 (ven., 24 sept. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class ServerInfo {

==================================================
StringParser.java
index 37990625ac..9574deb301 100644
--- a/java/org/apache/catalina/util/Strftime.java
+++ b/java/org/apache/catalina/util/Strftime.java
@@ -40,7 +40,7 @@ import java.util.TimeZone;
  *
  * @author Bip Thelin
  * @author Dan Sandberg
- * @version $Revision: 303133 $, $Date: 2004-08-29 18:46:15 +0200 (dim., 29 août 2004) $
+ * @version $Revision$, $Date$
  */
 public class Strftime {
     protected static Properties translate;

==================================================
URL.java
index 8f2f6d9682..2b804b8d0d 100644
--- a/java/org/apache/catalina/util/StringParser.java
+++ b/java/org/apache/catalina/util/StringParser.java
@@ -28,7 +28,7 @@ package org.apache.catalina.util;
  * method with the appropriate saved offset values.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public final class StringParser {

==================================================
AccessLogValve.java
index 5159ace866..1bd5b2eeb0 100644
--- a/java/org/apache/catalina/util/URL.java
+++ b/java/org/apache/catalina/util/URL.java
@@ -42,7 +42,7 @@ import java.net.MalformedURLException;
  * package someplace.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public final class URL implements Serializable {

==================================================
CometConnectionManagerValve.java
index 08008bdf6e..0afdd212e3 100644
--- a/java/org/apache/catalina/valves/AccessLogValve.java
+++ b/java/org/apache/catalina/valves/AccessLogValve.java
@@ -105,7 +105,7 @@ import org.apache.catalina.util.StringManager;
  *
  * @author Craig R. McClanahan
  * @author Jason Brittain
- * @version $Revision: 303826 $ $Date: 2005-03-31 12:31:54 +0200 (jeu., 31 mars 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class AccessLogValve

==================================================
ErrorReportValve.java
index 59d6716e2f..48e344fc83 100644
--- a/java/org/apache/catalina/valves/CometConnectionManagerValve.java
+++ b/java/org/apache/catalina/valves/CometConnectionManagerValve.java
@@ -48,7 +48,7 @@ import org.apache.catalina.util.StringManager;
  * <p>This Valve should be attached to a Context.</p>
  *
  * @author Remy Maucherat
- * @version $Revision: 386404 $ $Date: 2006-03-16 18:50:37 +0100 (jeu., 16 mars 2006) $
+ * @version $Revision$ $Date$
  */
 
 public class CometConnectionManagerValve

==================================================
ExtendedAccessLogValve.java
index 6775e1d7d2..29b60066cd 100644
--- a/java/org/apache/catalina/valves/ErrorReportValve.java
+++ b/java/org/apache/catalina/valves/ErrorReportValve.java
@@ -48,7 +48,7 @@ import org.apache.tomcat.util.IntrospectionUtils;
  * @author <a href="mailto:nicolaken@supereva.it">Nicola Ken Barozzi</a> Aisa
  * @author <a href="mailto:stefano@apache.org">Stefano Mazzocchi</a>
  * @author Yoav Shapira
- * @version $Revision: 304023 $ $Date: 2005-07-26 14:45:22 +0200 (mar., 26 juil. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class ErrorReportValve

==================================================
FastCommonAccessLogValve.java
index 9388cd2a0a..252164f4a6 100644
--- a/java/org/apache/catalina/valves/ExtendedAccessLogValve.java
+++ b/java/org/apache/catalina/valves/ExtendedAccessLogValve.java
@@ -130,7 +130,7 @@ import org.apache.juli.logging.LogFactory;
  *
  *
  * @author Tim Funk
- * @version $Revision: 303601 $ $Date: 2004-12-24 00:58:07 +0100 (ven., 24 déc. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class ExtendedAccessLogValve

==================================================
PersistentValve.java
index 3d151dabad..38c6ab317f 100644
--- a/java/org/apache/catalina/valves/FastCommonAccessLogValve.java
+++ b/java/org/apache/catalina/valves/FastCommonAccessLogValve.java
@@ -55,7 +55,7 @@ import org.apache.catalina.util.StringManager;
  * @author Craig R. McClanahan
  * @author Jason Brittain
  * @author Remy Maucherat
- * @version $Revision: 304032 $ $Date: 2005-07-27 17:11:55 +0200 (mer., 27 juil. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public final class FastCommonAccessLogValve

==================================================
RemoteAddrValve.java
index f3c9a7e828..1b7da1eb0e 100644
--- a/java/org/apache/catalina/valves/PersistentValve.java
+++ b/java/org/apache/catalina/valves/PersistentValve.java
@@ -42,7 +42,7 @@ import org.apache.catalina.util.StringManager;
  * <b>USAGE CONSTRAINT</b>: To work correctly it requires a  PersistentManager.
  *
  * @author Jean-Frederic Clere
- * @version $Revision: 303826 $ $Date: 2005-03-31 12:31:54 +0200 (jeu., 31 mars 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class PersistentValve

==================================================
RemoteHostValve.java
index 41893e9b91..4ea725e717 100644
--- a/java/org/apache/catalina/valves/RemoteAddrValve.java
+++ b/java/org/apache/catalina/valves/RemoteAddrValve.java
@@ -30,7 +30,7 @@ import org.apache.catalina.connector.Response;
  * based on the string representation of the remote client's IP address.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303133 $ $Date: 2004-08-29 18:46:15 +0200 (dim., 29 août 2004) $
+ * @version $Revision$ $Date$
  */
 
 public final class RemoteAddrValve

==================================================
RequestDumperValve.java
index ca4d7945f5..b6d67d1e98 100644
--- a/java/org/apache/catalina/valves/RemoteHostValve.java
+++ b/java/org/apache/catalina/valves/RemoteHostValve.java
@@ -30,7 +30,7 @@ import org.apache.catalina.connector.Response;
  * based on the remote client's host name.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 304096 $ $Date: 2005-09-20 23:02:12 +0200 (mar., 20 sept. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public final class RemoteHostValve

==================================================
RequestFilterValve.java
index 1097ade37d..ad8c50b911 100644
--- a/java/org/apache/catalina/valves/RequestDumperValve.java
+++ b/java/org/apache/catalina/valves/RequestDumperValve.java
@@ -41,7 +41,7 @@ import org.apache.juli.logging.Log;
  * of the logging you wish to perform.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303133 $ $Date: 2004-08-29 18:46:15 +0200 (dim., 29 août 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class RequestDumperValve

==================================================
SemaphoreValve.java
index 8a4004809b..9d8c12c358 100644
--- a/java/org/apache/catalina/valves/RequestFilterValve.java
+++ b/java/org/apache/catalina/valves/RequestFilterValve.java
@@ -62,7 +62,7 @@ import org.apache.catalina.util.StringManager;
  * of the filtering you wish to perform.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303161 $ $Date: 2004-09-01 12:10:10 +0200 (mer., 01 sept. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public abstract class RequestFilterValve

==================================================
ValveBase.java
index e8d4009604..e366a93854 100644
--- a/java/org/apache/catalina/valves/SemaphoreValve.java
+++ b/java/org/apache/catalina/valves/SemaphoreValve.java
@@ -40,7 +40,7 @@ import org.apache.catalina.util.StringManager;
  * of the concurrency control you wish to perform.</p>
  *
  * @author Remy Maucherat
- * @version $Revision: 386404 $ $Date: 2006-03-16 18:50:37 +0100 (jeu., 16 mars 2006) $
+ * @version $Revision$ $Date$
  */
 
 public class SemaphoreValve

==================================================
ExpressionFactoryImpl.java
index e4cd2087e9..653de6991d 100644
--- a/java/org/apache/coyote/http11/LocalStrings_ja.properties
+++ b/java/org/apache/coyote/http11/LocalStrings_ja.properties
@@ -1,4 +1,4 @@
-# $Id: LocalStrings_ja.properties 299758 2004-08-30 17:29:47Z amyroh $
+# $Id$
 
 # language ja
 

==================================================
MethodExpressionImpl.java
index 8b30e9289e..79718bdc1a 100644
--- a/java/org/apache/el/ExpressionFactoryImpl.java
+++ b/java/org/apache/el/ExpressionFactoryImpl.java
@@ -31,7 +31,7 @@ import org.apache.el.util.MessageFactory;
  * @see javax.el.ExpressionFactory
  * 
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: kchung $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public class ExpressionFactoryImpl extends ExpressionFactory {
 

==================================================
ValueExpressionImpl.java
index 338139002d..12beb2d94c 100644
--- a/java/org/apache/el/MethodExpressionImpl.java
+++ b/java/org/apache/el/MethodExpressionImpl.java
@@ -76,7 +76,7 @@ import org.apache.el.util.ReflectionUtil;
  * @see javax.el.MethodExpression
  * 
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: jhook $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class MethodExpressionImpl extends MethodExpression implements
         Externalizable {

==================================================
ELArithmetic.java
index 31f38d1248..759a0fd6ba 100644
--- a/java/org/apache/el/ValueExpressionImpl.java
+++ b/java/org/apache/el/ValueExpressionImpl.java
@@ -87,7 +87,7 @@ import org.apache.el.util.ReflectionUtil;
  * @see javax.el.ValueExpression
  * 
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class ValueExpressionImpl extends ValueExpression implements
         Externalizable {

==================================================
ELSupport.java
index c248f75e7e..752a6e32cb 100644
--- a/java/org/apache/el/lang/ELArithmetic.java
+++ b/java/org/apache/el/lang/ELArithmetic.java
@@ -26,7 +26,7 @@ import org.apache.el.util.MessageFactory;
 /**
  * A helper class of Arithmetic defined by the EL Specification
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public abstract class ELArithmetic {
 

==================================================
ExpressionBuilder.java
index 793ce2a331..3ecbd99807 100644
--- a/java/org/apache/el/lang/ELSupport.java
+++ b/java/org/apache/el/lang/ELSupport.java
@@ -32,7 +32,7 @@ import org.apache.el.util.MessageFactory;
  * A helper class that implements the EL Specification
  * 
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: kchung $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public class ELSupport {
 

==================================================
FunctionMapperFactory.java
index 994bf26081..a8bca8f503 100644
--- a/java/org/apache/el/lang/ExpressionBuilder.java
+++ b/java/org/apache/el/lang/ExpressionBuilder.java
@@ -51,7 +51,7 @@ import org.apache.el.util.MessageFactory;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: jhook $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class ExpressionBuilder implements NodeVisitor {
 

==================================================
FunctionMapperImpl.java
index 7745cee8be..63d2a6e58f 100644
--- a/java/org/apache/el/lang/FunctionMapperFactory.java
+++ b/java/org/apache/el/lang/FunctionMapperFactory.java
@@ -23,7 +23,7 @@ import javax.el.FunctionMapper;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public class FunctionMapperFactory extends FunctionMapper {
 

==================================================
ArithmeticNode.java
index 012ffd4f58..0a938d0606 100644
--- a/java/org/apache/el/lang/FunctionMapperImpl.java
+++ b/java/org/apache/el/lang/FunctionMapperImpl.java
@@ -32,7 +32,7 @@ import org.apache.el.util.ReflectionUtil;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public class FunctionMapperImpl extends FunctionMapper implements
         Externalizable {

==================================================
AstAnd.java
index 2e8694e442..74b9bd4ab6 100644
--- a/java/org/apache/el/parser/ArithmeticNode.java
+++ b/java/org/apache/el/parser/ArithmeticNode.java
@@ -24,7 +24,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public class ArithmeticNode extends SimpleNode {
 

==================================================
AstBracketSuffix.java
index 41f8e8fa22..feaac6f220 100644
--- a/java/org/apache/el/parser/AstAnd.java
+++ b/java/org/apache/el/parser/AstAnd.java
@@ -9,7 +9,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstAnd extends BooleanNode {
     public AstAnd(int id) {

==================================================
AstChoice.java
index 2734d833f5..9afd6d8316 100644
--- a/java/org/apache/el/parser/AstBracketSuffix.java
+++ b/java/org/apache/el/parser/AstBracketSuffix.java
@@ -9,7 +9,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstBracketSuffix extends SimpleNode {
     public AstBracketSuffix(int id) {

==================================================
AstCompositeExpression.java
index 02c1307ef2..b3969eaf66 100644
--- a/java/org/apache/el/parser/AstChoice.java
+++ b/java/org/apache/el/parser/AstChoice.java
@@ -9,7 +9,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstChoice extends SimpleNode {
     public AstChoice(int id) {

==================================================
AstDeferredExpression.java
index db3d7eb624..843fcddcfc 100644
--- a/java/org/apache/el/parser/AstCompositeExpression.java
+++ b/java/org/apache/el/parser/AstCompositeExpression.java
@@ -9,7 +9,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstCompositeExpression extends SimpleNode {
 

==================================================
AstDiv.java
index d965b8abcc..b63299d4c0 100644
--- a/java/org/apache/el/parser/AstDeferredExpression.java
+++ b/java/org/apache/el/parser/AstDeferredExpression.java
@@ -9,7 +9,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstDeferredExpression extends SimpleNode {
     public AstDeferredExpression(int id) {

==================================================
AstDotSuffix.java
index ca0095d636..8309452649 100644
--- a/java/org/apache/el/parser/AstDiv.java
+++ b/java/org/apache/el/parser/AstDiv.java
@@ -10,7 +10,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstDiv extends ArithmeticNode {
     public AstDiv(int id) {

==================================================
AstDynamicExpression.java
index 6edcb88c8d..11d84b3d18 100644
--- a/java/org/apache/el/parser/AstDotSuffix.java
+++ b/java/org/apache/el/parser/AstDotSuffix.java
@@ -9,7 +9,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstDotSuffix extends SimpleNode {
     public AstDotSuffix(int id) {

==================================================
AstEmpty.java
index 0004a44b77..792febd856 100644
--- a/java/org/apache/el/parser/AstDynamicExpression.java
+++ b/java/org/apache/el/parser/AstDynamicExpression.java
@@ -9,7 +9,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstDynamicExpression extends SimpleNode {
     public AstDynamicExpression(int id) {

==================================================
AstEqual.java
index 5416304a40..0f0353948f 100644
--- a/java/org/apache/el/parser/AstEmpty.java
+++ b/java/org/apache/el/parser/AstEmpty.java
@@ -12,7 +12,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstEmpty extends SimpleNode {
     public AstEmpty(int id) {

==================================================
AstFalse.java
index b550311ba1..a5ea4214ef 100644
--- a/java/org/apache/el/parser/AstEqual.java
+++ b/java/org/apache/el/parser/AstEqual.java
@@ -9,7 +9,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstEqual extends BooleanNode {
     public AstEqual(int id) {

==================================================
AstFloatingPoint.java
index 0477953d34..64264f49c3 100644
--- a/java/org/apache/el/parser/AstFalse.java
+++ b/java/org/apache/el/parser/AstFalse.java
@@ -9,7 +9,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstFalse extends BooleanNode {
     public AstFalse(int id) {

==================================================
AstFunction.java
index 2e1d978cf4..7a41e75e41 100644
--- a/java/org/apache/el/parser/AstFloatingPoint.java
+++ b/java/org/apache/el/parser/AstFloatingPoint.java
@@ -11,7 +11,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstFloatingPoint extends SimpleNode {
     public AstFloatingPoint(int id) {

==================================================
AstGreaterThan.java
index 92b563b0ce..d3451f2d4c 100644
--- a/java/org/apache/el/parser/AstFunction.java
+++ b/java/org/apache/el/parser/AstFunction.java
@@ -14,7 +14,7 @@ import org.apache.el.util.MessageFactory;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstFunction extends SimpleNode {
 

==================================================
AstGreaterThanEqual.java
index 9c952c5890..fdf0adacae 100644
--- a/java/org/apache/el/parser/AstGreaterThan.java
+++ b/java/org/apache/el/parser/AstGreaterThan.java
@@ -9,7 +9,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstGreaterThan extends BooleanNode {
     public AstGreaterThan(int id) {

==================================================
AstIdentifier.java
index 6704a2b980..0365a5ea7d 100644
--- a/java/org/apache/el/parser/AstGreaterThanEqual.java
+++ b/java/org/apache/el/parser/AstGreaterThanEqual.java
@@ -9,7 +9,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: kchung $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstGreaterThanEqual extends BooleanNode {
     public AstGreaterThanEqual(int id) {

==================================================
AstInteger.java
index eb8c0e17bb..3fa837c789 100644
--- a/java/org/apache/el/parser/AstIdentifier.java
+++ b/java/org/apache/el/parser/AstIdentifier.java
@@ -14,7 +14,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: jhook $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstIdentifier extends SimpleNode {
     public AstIdentifier(int id) {

==================================================
AstLessThan.java
index 4133a7fdd8..e7b78f759c 100644
--- a/java/org/apache/el/parser/AstInteger.java
+++ b/java/org/apache/el/parser/AstInteger.java
@@ -11,7 +11,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstInteger extends SimpleNode {
     public AstInteger(int id) {

==================================================
AstLessThanEqual.java
index 6020ed2db6..99195a9f44 100644
--- a/java/org/apache/el/parser/AstLessThan.java
+++ b/java/org/apache/el/parser/AstLessThan.java
@@ -9,7 +9,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstLessThan extends BooleanNode {
     public AstLessThan(int id) {

==================================================
AstLiteralExpression.java
index 3b5c582db5..5af5b4175a 100644
--- a/java/org/apache/el/parser/AstLessThanEqual.java
+++ b/java/org/apache/el/parser/AstLessThanEqual.java
@@ -9,7 +9,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: kchung $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstLessThanEqual extends BooleanNode {
     public AstLessThanEqual(int id) {

==================================================
AstMinus.java
index cd83c2cdfd..95f6991488 100644
--- a/java/org/apache/el/parser/AstLiteralExpression.java
+++ b/java/org/apache/el/parser/AstLiteralExpression.java
@@ -9,7 +9,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: kchung $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstLiteralExpression extends SimpleNode {
     public AstLiteralExpression(int id) {

==================================================
AstMod.java
index 55268045a8..6fea776b66 100644
--- a/java/org/apache/el/parser/AstMinus.java
+++ b/java/org/apache/el/parser/AstMinus.java
@@ -10,7 +10,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstMinus extends ArithmeticNode {
     public AstMinus(int id) {

==================================================
AstMult.java
index b3b2deb520..90695b72ba 100644
--- a/java/org/apache/el/parser/AstMod.java
+++ b/java/org/apache/el/parser/AstMod.java
@@ -10,7 +10,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstMod extends ArithmeticNode {
     public AstMod(int id) {

==================================================
AstNegative.java
index 6b3aefee6b..f19cf56fc9 100644
--- a/java/org/apache/el/parser/AstMult.java
+++ b/java/org/apache/el/parser/AstMult.java
@@ -10,7 +10,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstMult extends ArithmeticNode {
     public AstMult(int id) {

==================================================
AstNot.java
index d7609d2331..7ac0ff8c9a 100644
--- a/java/org/apache/el/parser/AstNegative.java
+++ b/java/org/apache/el/parser/AstNegative.java
@@ -12,7 +12,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstNegative extends SimpleNode {
     public AstNegative(int id) {

==================================================
AstNotEqual.java
index a1b8ae111d..adc60a6f36 100644
--- a/java/org/apache/el/parser/AstNot.java
+++ b/java/org/apache/el/parser/AstNot.java
@@ -9,7 +9,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstNot extends SimpleNode {
     public AstNot(int id) {

==================================================
AstNull.java
index 2ea2dd6608..cd3611e3a9 100644
--- a/java/org/apache/el/parser/AstNotEqual.java
+++ b/java/org/apache/el/parser/AstNotEqual.java
@@ -9,7 +9,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstNotEqual extends BooleanNode {
     public AstNotEqual(int id) {

==================================================
AstOr.java
index 876272d56b..8759fcad9c 100644
--- a/java/org/apache/el/parser/AstNull.java
+++ b/java/org/apache/el/parser/AstNull.java
@@ -9,7 +9,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstNull extends SimpleNode {
     public AstNull(int id) {

==================================================
AstPlus.java
index 7827c3859c..801401dae5 100644
--- a/java/org/apache/el/parser/AstOr.java
+++ b/java/org/apache/el/parser/AstOr.java
@@ -9,7 +9,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstOr extends BooleanNode {
     public AstOr(int id) {

==================================================
AstString.java
index 0924e29f33..445e517e78 100644
--- a/java/org/apache/el/parser/AstPlus.java
+++ b/java/org/apache/el/parser/AstPlus.java
@@ -10,7 +10,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstPlus extends ArithmeticNode {
     public AstPlus(int id) {

==================================================
AstTrue.java
index 39ac13ebf4..a9d24eea5c 100644
--- a/java/org/apache/el/parser/AstString.java
+++ b/java/org/apache/el/parser/AstString.java
@@ -9,7 +9,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: kchung $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstString extends SimpleNode {
     public AstString(int id) {

==================================================
AstValue.java
index d7df8ec19a..d58eec4288 100644
--- a/java/org/apache/el/parser/AstTrue.java
+++ b/java/org/apache/el/parser/AstTrue.java
@@ -9,7 +9,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstTrue extends BooleanNode {
     public AstTrue(int id) {

==================================================
BooleanNode.java
index 1d8c486ecd..479d1c815b 100644
--- a/java/org/apache/el/parser/AstValue.java
+++ b/java/org/apache/el/parser/AstValue.java
@@ -17,7 +17,7 @@ import org.apache.el.util.ReflectionUtil;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class AstValue extends SimpleNode {
 

==================================================
Node.java
index ae6fe61695..9e8f6dd0d3 100644
--- a/java/org/apache/el/parser/ELParser.jjt
+++ b/java/org/apache/el/parser/ELParser.jjt
@@ -1,471 +1,471 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
-	Author:	Jacob Hookom
-	Email:	jacob at hookom.net
-*/
-
-/* == Option Declaration == */
-options
-{
-	STATIC=false;
-	NODE_PREFIX="Ast";
-	VISITOR_EXCEPTION="javax.el.ELException";
-	VISITOR=false;
-	MULTI=true;
-	NODE_DEFAULT_VOID=true;
-	JAVA_UNICODE_ESCAPE=false;
-  	UNICODE_INPUT=true;
-	BUILD_NODE_FILES=true;
-}
-
-/* == Parser Declaration == */
-PARSER_BEGIN( ELParser )
-package org.apache.el.parser;
-import java.io.StringReader;
-import javax.el.ELException;
-public class ELParser
-{
-    public static Node parse(String ref) throws ELException
-    {
-        try {
-        	return (new ELParser(new StringReader(ref))).CompositeExpression();
-        } catch (ParseException pe) {
-           	throw new ELException(pe.getMessage());
-        }
-    }
-}
-PARSER_END( ELParser )
-
-/*
- * CompositeExpression
- * Allow most flexible parsing, restrict by examining
- * type of returned node
- */
-AstCompositeExpression CompositeExpression() #CompositeExpression : {}
-{
-	(DeferredExpression() | DynamicExpression() | LiteralExpression())* <EOF> { return jjtThis; }
-}
-
-/*
- * LiteralExpression
- * Non-EL Expression blocks
- */
-void LiteralExpression() #LiteralExpression : { Token t = null; }
-{
-	t=<LITERAL_EXPRESSION> { jjtThis.setImage(t.image); }
-}
-
-/*
- * DeferredExpression
- * #{..} Expressions
- */
-void DeferredExpression() #DeferredExpression : {}
-{
-	<START_DEFERRED_EXPRESSION> Expression() <END_EXPRESSION> 
-}
-
-/*
- * DynamicExpression
- * ${..} Expressions
- */
-void DynamicExpression() #DynamicExpression : {}
-{
-	<START_DYNAMIC_EXPRESSION> Expression() <END_EXPRESSION> 
-}
-
-/*
- * Expression
- * EL Expression Language Root, goes to Choice
- */
-void Expression() : {}
-{
-	Choice()
-}
-
-/*
- * Choice
- * For Choice markup a ? b : c, then Or
- */
-void Choice() : {}
-{
-	Or() (<QUESTIONMARK> Or() <COLON> Choice() #Choice(3))*
-}
-
-/*
- * Or
- * For 'or' '||', then And
- */
-void Or() : {}
-{
-	And() ((<OR0>|<OR1>) And() #Or(2))*
-}
-
-/*
- * And
- * For 'and' '&&', then Equality
- */
-void And() : {}
-{
-	Equality() ((<AND0>|<AND1>) Equality() #And(2))*
-}
-
-/*
- * Equality
- * For '==' 'eq' '!=' 'ne', then Compare
- */
-void Equality() : {}
-{
-	Compare()
-	(
-		((<EQ0>|<EQ1>) Compare() #Equal(2))
-	|
-		((<NE0>|<NE1>) Compare() #NotEqual(2))
-	)*
-}
-
-/*
- * Compare
- * For a bunch of them, then Math
- */
-void Compare() : {}
-{
-	Math()
-	(
-		((<LT0>|<LT1>) Math() #LessThan(2))
-	|
-		((<GT0>|<GT1>) Math() #GreaterThan(2))
-	|
-		((<LE0>|<LE1>) Math() #LessThanEqual(2))
-	|
-		((<GE0>|<GE1>) Math() #GreaterThanEqual(2))
-	)*
-}
-
-/*
- * Math
- * For '+' '-', then Multiplication
- */
-void Math() : {}
-{
-	Multiplication()
-	(
-		(<PLUS> Multiplication() #Plus(2))
-	|
-		(<MINUS> Multiplication() #Minus(2))
-	)*
-}
-
-/*
- * Multiplication
- * For a bunch of them, then Unary
- */
-void Multiplication() : {}
-{
-	Unary()
-	(
-		(<MULT> Unary() #Mult(2))
-	|
-		((<DIV0>|<DIV1>) Unary() #Div(2))
-	|
-		((<MOD0>|<MOD1>) Unary() #Mod(2))	
-	)*	
-}
-
-/*
- * Unary
- * For '-' '!' 'not' 'empty', then Value
- */
-void Unary() : {}
-{
-		<MINUS> Unary() #Negative 
-	|
-		(<NOT0>|<NOT1>) Unary() #Not 
-	|
-		<EMPTY> Unary() #Empty
-	|	
-		Value()
-}
-
-/*
- * Value
- * Defines Prefix plus zero or more Suffixes
- */
-void Value() : {}
-{
-	(ValuePrefix() (ValueSuffix())*) #Value(>1)
-}
-
-/*
- * ValuePrefix
- * For Literals, Variables, and Functions
- */
-void ValuePrefix() : {}
-{
-	Literal()
-	| NonLiteral()
-}
-
-/*
- * ValueSuffix
- * Either dot or bracket notation
- */
-void ValueSuffix() : {}
-{
-	DotSuffix() | BracketSuffix()
-}
-
-/*
- * DotSuffix
- * Dot Property
- */
-void DotSuffix() #DotSuffix : { Token t = null; }
-{
-	<DOT> t=<IDENTIFIER> { jjtThis.setImage(t.image); }
-}
-
-/*
- * BracketSuffix
- * Sub Expression Suffix
- */
-void BracketSuffix() #BracketSuffix : {}
-{
-	<LBRACK> Expression() <RBRACK>
-}
-
-/*
- * NonLiteral
- * For Grouped Operations, Identifiers, and Functions
- */
-void NonLiteral() : {}
-{
- 	<LPAREN> Expression() <RPAREN>
- 	| LOOKAHEAD(3) Function()
-	| Identifier()
-}
-
-/*
- * Identifier
- * Java Language Identifier
- */
-void Identifier() #Identifier : { Token t = null; }
-{
-	t=<IDENTIFIER> { jjtThis.setImage(t.image); }
-}
-
-/*
- * Function
- * Namespace:Name(a,b,c)
- */
-void Function() #Function :
-{
-	Token t0 = null;
-	Token t1 = null;
-}
-{
-	(t0=<NAMESPACE>)? t1=<IDENTIFIER>
-	{
-		if (t0 != null) {
-			jjtThis.setPrefix(t0.image.substring(0, t0.image.length() - 1));
-			jjtThis.setLocalName(t1.image);
-		} else {
-			jjtThis.setLocalName(t1.image);
-		}
-	}
-	<LPAREN> (Expression() (<COMMA> Expression())*)? <RPAREN>
-}
-
-/*
- * Literal
- * Reserved Keywords
- */
-void Literal() : {}
-{
-	Boolean()
-	| FloatingPoint()
-	| Integer()
-	| String()
-	| Null()
-}
-
-/*
- * Boolean
- * For 'true' 'false'
- */
-void Boolean() : {}
-{
-	<TRUE> #True
-	| <FALSE> #False
-}
-
-/*
- * FloatinPoint
- * For Decimal and Floating Point Literals
- */
-void FloatingPoint() #FloatingPoint : { Token t = null; }
-{
-	t=<FLOATING_POINT_LITERAL> { jjtThis.setImage(t.image); }
-}
-
-/*
- * Integer
- * For Simple Numeric Literals
- */
-void Integer() #Integer : { Token t = null; }
-{
-	t=<INTEGER_LITERAL> { jjtThis.setImage(t.image); }
-}
-
-/*
- * String
- * For Quoted Literals
- */
-void String() #String : { Token t = null; }
-{
-	t=<STRING_LITERAL> { jjtThis.setImage(t.image); }
-}
-
-/*
- * Null
- * For 'null'
- */
-void Null() #Null : {}
-{
-	<NULL>
-}
-
-
-/* ==================================================================================== */
-<DEFAULT> TOKEN :
-{
-  < LITERAL_EXPRESSION:
-    ((~["\\", "$", "#"])
-      | ("\\" ("\\" | "$" | "#"))
-      | ("$" ~["{", "$"])
-      | ("#" ~["{", "#"])
-    )+
-    | "$"
-    | "#"
-  >
-|
-  < START_DYNAMIC_EXPRESSION: "${" > : IN_EXPRESSION
-|
-  < START_DEFERRED_EXPRESSION: "#{" > : IN_EXPRESSION
-}
-
-<DEFAULT> SKIP : { "\\" }
-
-<IN_EXPRESSION> SKIP : { " " | "\t" | "\n" | "\r" }
-
-<IN_EXPRESSION> TOKEN :
-{
-	< INTEGER_LITERAL: ["0"-"9"] (["0"-"9"])* >
-|	< FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? 
-		| "." (["0"-"9"])+ (<EXPONENT>)?
-		| (["0"-"9"])+ <EXPONENT>
-	>
-|	< #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
-|	< STRING_LITERAL: ("\"" ((~["\"","\\"])
-		| ("\\" ( ["\\","\""] )))* "\"")
-		| ("\'" ((~["\'","\\"])
-		| ("\\" ( ["\\","\'"] )))* "\'")
-	>
-|	< BADLY_ESCAPED_STRING_LITERAL: ("\"" (~["\"","\\"])* ("\\" ( ~["\\","\""] )))
-		| ("\'" (~["\'","\\"])* ("\\" ( ~["\\","\'"] )))
-	>
-|	< TRUE : "true" >
-|	< FALSE : "false" >
-|	< NULL : "null" >
-|	< END_EXPRESSION : "}" > : DEFAULT
-|	< DOT : "." >
-|	< LPAREN : "(" >
-|	< RPAREN : ")" >
-|	< LBRACK : "[" >
-|	< RBRACK : "]" >
-|	< COLON : ":" >
-|	< COMMA : "," >
-|	< GT0 : ">" >
-|	< GT1 : "gt" >
-|	< LT0 : "<" >
-|	< LT1 : "lt" >
-|	< GE0 : ">=" >
-|	< GE1 : "ge" >
-|	< LE0 : "<=" >
-|	< LE1 : "le" >
-|	< EQ0 : "==" >
-|	< EQ1 : "eq" >
-|	< NE0 : "!=" >
-|	< NE1 : "ne" >
-|	< NOT0 : "!" >
-|	< NOT1 : "not" >
-|	< AND0 : "&&" >
-|	< AND1 : "and" >
-|	< OR0 : "||" >
-|	< OR1 : "or" >
-|	< EMPTY : "empty" >
-|	< INSTANCEOF : "instanceof" >
-|	< MULT : "*" >
-|	< PLUS : "+" >
-|	< MINUS : "-" >
-|	< QUESTIONMARK : "?" >
-|	< DIV0 : "/" >
-|	< DIV1 : "div" >
-|	< MOD0 : "%" >
-|	< MOD1 : "mod" >
-|	< IDENTIFIER : (<LETTER>|<IMPL_OBJ_START>) (<LETTER>|<DIGIT>)* >
-|   < NAMESPACE : (<IDENTIFIER> (<IDENTIFIER>|<MINUS>|<DOT>)* <COLON>) >
-|	< FUNCTIONSUFFIX : (<IDENTIFIER>) >
-|	< #IMPL_OBJ_START: "#" >
-|	< #LETTER:
-		[
-		"\u0024",
-		"\u0041"-"\u005a",
-		"\u005f",
-		"\u0061"-"\u007a",
-		"\u00c0"-"\u00d6",
-		"\u00d8"-"\u00f6",
-		"\u00f8"-"\u00ff",
-		"\u0100"-"\u1fff",
-		"\u3040"-"\u318f",
-		"\u3300"-"\u337f",
-		"\u3400"-"\u3d2d",
-		"\u4e00"-"\u9fff",
-		"\uf900"-"\ufaff"
-		]
-	>
-|	< #DIGIT:
-		[
-		"\u0030"-"\u0039",
-		"\u0660"-"\u0669",
-		"\u06f0"-"\u06f9",
-		"\u0966"-"\u096f",
-		"\u09e6"-"\u09ef",
-		"\u0a66"-"\u0a6f",
-		"\u0ae6"-"\u0aef",
-		"\u0b66"-"\u0b6f",
-		"\u0be7"-"\u0bef",
-		"\u0c66"-"\u0c6f",
-		"\u0ce6"-"\u0cef",
-		"\u0d66"-"\u0d6f",
-		"\u0e50"-"\u0e59",
-		"\u0ed0"-"\u0ed9",
-		"\u1040"-"\u1049"
-		]
-	>
-|	< ILLEGAL_CHARACTER: (~[]) >
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+	Author:	Jacob Hookom
+	Email:	jacob at hookom.net
+*/
+
+/* == Option Declaration == */
+options
+{
+	STATIC=false;
+	NODE_PREFIX="Ast";
+	VISITOR_EXCEPTION="javax.el.ELException";
+	VISITOR=false;
+	MULTI=true;
+	NODE_DEFAULT_VOID=true;
+	JAVA_UNICODE_ESCAPE=false;
+  	UNICODE_INPUT=true;
+	BUILD_NODE_FILES=true;
+}
+
+/* == Parser Declaration == */
+PARSER_BEGIN( ELParser )
+package org.apache.el.parser;
+import java.io.StringReader;
+import javax.el.ELException;
+public class ELParser
+{
+    public static Node parse(String ref) throws ELException
+    {
+        try {
+        	return (new ELParser(new StringReader(ref))).CompositeExpression();
+        } catch (ParseException pe) {
+           	throw new ELException(pe.getMessage());
+        }
+    }
+}
+PARSER_END( ELParser )
+
+/*
+ * CompositeExpression
+ * Allow most flexible parsing, restrict by examining
+ * type of returned node
+ */
+AstCompositeExpression CompositeExpression() #CompositeExpression : {}
+{
+	(DeferredExpression() | DynamicExpression() | LiteralExpression())* <EOF> { return jjtThis; }
+}
+
+/*
+ * LiteralExpression
+ * Non-EL Expression blocks
+ */
+void LiteralExpression() #LiteralExpression : { Token t = null; }
+{
+	t=<LITERAL_EXPRESSION> { jjtThis.setImage(t.image); }
+}
+
+/*
+ * DeferredExpression
+ * #{..} Expressions
+ */
+void DeferredExpression() #DeferredExpression : {}
+{
+	<START_DEFERRED_EXPRESSION> Expression() <END_EXPRESSION> 
+}
+
+/*
+ * DynamicExpression
+ * ${..} Expressions
+ */
+void DynamicExpression() #DynamicExpression : {}
+{
+	<START_DYNAMIC_EXPRESSION> Expression() <END_EXPRESSION> 
+}
+
+/*
+ * Expression
+ * EL Expression Language Root, goes to Choice
+ */
+void Expression() : {}
+{
+	Choice()
+}
+
+/*
+ * Choice
+ * For Choice markup a ? b : c, then Or
+ */
+void Choice() : {}
+{
+	Or() (<QUESTIONMARK> Or() <COLON> Choice() #Choice(3))*
+}
+
+/*
+ * Or
+ * For 'or' '||', then And
+ */
+void Or() : {}
+{
+	And() ((<OR0>|<OR1>) And() #Or(2))*
+}
+
+/*
+ * And
+ * For 'and' '&&', then Equality
+ */
+void And() : {}
+{
+	Equality() ((<AND0>|<AND1>) Equality() #And(2))*
+}
+
+/*
+ * Equality
+ * For '==' 'eq' '!=' 'ne', then Compare
+ */
+void Equality() : {}
+{
+	Compare()
+	(
+		((<EQ0>|<EQ1>) Compare() #Equal(2))
+	|
+		((<NE0>|<NE1>) Compare() #NotEqual(2))
+	)*
+}
+
+/*
+ * Compare
+ * For a bunch of them, then Math
+ */
+void Compare() : {}
+{
+	Math()
+	(
+		((<LT0>|<LT1>) Math() #LessThan(2))
+	|
+		((<GT0>|<GT1>) Math() #GreaterThan(2))
+	|
+		((<LE0>|<LE1>) Math() #LessThanEqual(2))
+	|
+		((<GE0>|<GE1>) Math() #GreaterThanEqual(2))
+	)*
+}
+
+/*
+ * Math
+ * For '+' '-', then Multiplication
+ */
+void Math() : {}
+{
+	Multiplication()
+	(
+		(<PLUS> Multiplication() #Plus(2))
+	|
+		(<MINUS> Multiplication() #Minus(2))
+	)*
+}
+
+/*
+ * Multiplication
+ * For a bunch of them, then Unary
+ */
+void Multiplication() : {}
+{
+	Unary()
+	(
+		(<MULT> Unary() #Mult(2))
+	|
+		((<DIV0>|<DIV1>) Unary() #Div(2))
+	|
+		((<MOD0>|<MOD1>) Unary() #Mod(2))	
+	)*	
+}
+
+/*
+ * Unary
+ * For '-' '!' 'not' 'empty', then Value
+ */
+void Unary() : {}
+{
+		<MINUS> Unary() #Negative 
+	|
+		(<NOT0>|<NOT1>) Unary() #Not 
+	|
+		<EMPTY> Unary() #Empty
+	|	
+		Value()
+}
+
+/*
+ * Value
+ * Defines Prefix plus zero or more Suffixes
+ */
+void Value() : {}
+{
+	(ValuePrefix() (ValueSuffix())*) #Value(>1)
+}
+
+/*
+ * ValuePrefix
+ * For Literals, Variables, and Functions
+ */
+void ValuePrefix() : {}
+{
+	Literal()
+	| NonLiteral()
+}
+
+/*
+ * ValueSuffix
+ * Either dot or bracket notation
+ */
+void ValueSuffix() : {}
+{
+	DotSuffix() | BracketSuffix()
+}
+
+/*
+ * DotSuffix
+ * Dot Property
+ */
+void DotSuffix() #DotSuffix : { Token t = null; }
+{
+	<DOT> t=<IDENTIFIER> { jjtThis.setImage(t.image); }
+}
+
+/*
+ * BracketSuffix
+ * Sub Expression Suffix
+ */
+void BracketSuffix() #BracketSuffix : {}
+{
+	<LBRACK> Expression() <RBRACK>
+}
+
+/*
+ * NonLiteral
+ * For Grouped Operations, Identifiers, and Functions
+ */
+void NonLiteral() : {}
+{
+ 	<LPAREN> Expression() <RPAREN>
+ 	| LOOKAHEAD(3) Function()
+	| Identifier()
+}
+
+/*
+ * Identifier
+ * Java Language Identifier
+ */
+void Identifier() #Identifier : { Token t = null; }
+{
+	t=<IDENTIFIER> { jjtThis.setImage(t.image); }
+}
+
+/*
+ * Function
+ * Namespace:Name(a,b,c)
+ */
+void Function() #Function :
+{
+	Token t0 = null;
+	Token t1 = null;
+}
+{
+	(t0=<NAMESPACE>)? t1=<IDENTIFIER>
+	{
+		if (t0 != null) {
+			jjtThis.setPrefix(t0.image.substring(0, t0.image.length() - 1));
+			jjtThis.setLocalName(t1.image);
+		} else {
+			jjtThis.setLocalName(t1.image);
+		}
+	}
+	<LPAREN> (Expression() (<COMMA> Expression())*)? <RPAREN>
+}
+
+/*
+ * Literal
+ * Reserved Keywords
+ */
+void Literal() : {}
+{
+	Boolean()
+	| FloatingPoint()
+	| Integer()
+	| String()
+	| Null()
+}
+
+/*
+ * Boolean
+ * For 'true' 'false'
+ */
+void Boolean() : {}
+{
+	<TRUE> #True
+	| <FALSE> #False
+}
+
+/*
+ * FloatinPoint
+ * For Decimal and Floating Point Literals
+ */
+void FloatingPoint() #FloatingPoint : { Token t = null; }
+{
+	t=<FLOATING_POINT_LITERAL> { jjtThis.setImage(t.image); }
+}
+
+/*
+ * Integer
+ * For Simple Numeric Literals
+ */
+void Integer() #Integer : { Token t = null; }
+{
+	t=<INTEGER_LITERAL> { jjtThis.setImage(t.image); }
+}
+
+/*
+ * String
+ * For Quoted Literals
+ */
+void String() #String : { Token t = null; }
+{
+	t=<STRING_LITERAL> { jjtThis.setImage(t.image); }
+}
+
+/*
+ * Null
+ * For 'null'
+ */
+void Null() #Null : {}
+{
+	<NULL>
+}
+
+
+/* ==================================================================================== */
+<DEFAULT> TOKEN :
+{
+  < LITERAL_EXPRESSION:
+    ((~["\\", "$", "#"])
+      | ("\\" ("\\" | "$" | "#"))
+      | ("$" ~["{", "$"])
+      | ("#" ~["{", "#"])
+    )+
+    | "$"
+    | "#"
+  >
+|
+  < START_DYNAMIC_EXPRESSION: "${" > : IN_EXPRESSION
+|
+  < START_DEFERRED_EXPRESSION: "#{" > : IN_EXPRESSION
+}
+
+<DEFAULT> SKIP : { "\\" }
+
+<IN_EXPRESSION> SKIP : { " " | "\t" | "\n" | "\r" }
+
+<IN_EXPRESSION> TOKEN :
+{
+	< INTEGER_LITERAL: ["0"-"9"] (["0"-"9"])* >
+|	< FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? 
+		| "." (["0"-"9"])+ (<EXPONENT>)?
+		| (["0"-"9"])+ <EXPONENT>
+	>
+|	< #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
+|	< STRING_LITERAL: ("\"" ((~["\"","\\"])
+		| ("\\" ( ["\\","\""] )))* "\"")
+		| ("\'" ((~["\'","\\"])
+		| ("\\" ( ["\\","\'"] )))* "\'")
+	>
+|	< BADLY_ESCAPED_STRING_LITERAL: ("\"" (~["\"","\\"])* ("\\" ( ~["\\","\""] )))
+		| ("\'" (~["\'","\\"])* ("\\" ( ~["\\","\'"] )))
+	>
+|	< TRUE : "true" >
+|	< FALSE : "false" >
+|	< NULL : "null" >
+|	< END_EXPRESSION : "}" > : DEFAULT
+|	< DOT : "." >
+|	< LPAREN : "(" >
+|	< RPAREN : ")" >
+|	< LBRACK : "[" >
+|	< RBRACK : "]" >
+|	< COLON : ":" >
+|	< COMMA : "," >
+|	< GT0 : ">" >
+|	< GT1 : "gt" >
+|	< LT0 : "<" >
+|	< LT1 : "lt" >
+|	< GE0 : ">=" >
+|	< GE1 : "ge" >
+|	< LE0 : "<=" >
+|	< LE1 : "le" >
+|	< EQ0 : "==" >
+|	< EQ1 : "eq" >
+|	< NE0 : "!=" >
+|	< NE1 : "ne" >
+|	< NOT0 : "!" >
+|	< NOT1 : "not" >
+|	< AND0 : "&&" >
+|	< AND1 : "and" >
+|	< OR0 : "||" >
+|	< OR1 : "or" >
+|	< EMPTY : "empty" >
+|	< INSTANCEOF : "instanceof" >
+|	< MULT : "*" >
+|	< PLUS : "+" >
+|	< MINUS : "-" >
+|	< QUESTIONMARK : "?" >
+|	< DIV0 : "/" >
+|	< DIV1 : "div" >
+|	< MOD0 : "%" >
+|	< MOD1 : "mod" >
+|	< IDENTIFIER : (<LETTER>|<IMPL_OBJ_START>) (<LETTER>|<DIGIT>)* >
+|   < NAMESPACE : (<IDENTIFIER> (<IDENTIFIER>|<MINUS>|<DOT>)* <COLON>) >
+|	< FUNCTIONSUFFIX : (<IDENTIFIER>) >
+|	< #IMPL_OBJ_START: "#" >
+|	< #LETTER:
+		[
+		"\u0024",
+		"\u0041"-"\u005a",
+		"\u005f",
+		"\u0061"-"\u007a",
+		"\u00c0"-"\u00d6",
+		"\u00d8"-"\u00f6",
+		"\u00f8"-"\u00ff",
+		"\u0100"-"\u1fff",
+		"\u3040"-"\u318f",
+		"\u3300"-"\u337f",
+		"\u3400"-"\u3d2d",
+		"\u4e00"-"\u9fff",
+		"\uf900"-"\ufaff"
+		]
+	>
+|	< #DIGIT:
+		[
+		"\u0030"-"\u0039",
+		"\u0660"-"\u0669",
+		"\u06f0"-"\u06f9",
+		"\u0966"-"\u096f",
+		"\u09e6"-"\u09ef",
+		"\u0a66"-"\u0a6f",
+		"\u0ae6"-"\u0aef",
+		"\u0b66"-"\u0b6f",
+		"\u0be7"-"\u0bef",
+		"\u0c66"-"\u0c6f",
+		"\u0ce6"-"\u0cef",
+		"\u0d66"-"\u0d6f",
+		"\u0e50"-"\u0e59",
+		"\u0ed0"-"\u0ed9",
+		"\u1040"-"\u1049"
+		]
+	>
+|	< ILLEGAL_CHARACTER: (~[]) >
+}

==================================================
NodeVisitor.java
index b72814b1f0..256e838bd7 100644
--- a/java/org/apache/el/parser/Node.java
+++ b/java/org/apache/el/parser/Node.java
@@ -31,7 +31,7 @@ import org.apache.el.lang.EvaluationContext;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: jhook $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public interface Node {
 

==================================================
SimpleNode.java
index 405883626d..57d456e9b2 100644
--- a/java/org/apache/el/parser/NodeVisitor.java
+++ b/java/org/apache/el/parser/NodeVisitor.java
@@ -18,7 +18,7 @@ package org.apache.el.parser;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public interface NodeVisitor {
     public void visit(Node node) throws Exception;

==================================================
MessageFactory.java
index 784bc1646b..8bcd68bd1b 100644
--- a/java/org/apache/el/parser/SimpleNode.java
+++ b/java/org/apache/el/parser/SimpleNode.java
@@ -13,7 +13,7 @@ import org.apache.el.util.MessageFactory;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: jhook $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public abstract class SimpleNode extends ELSupport implements Node {
     protected Node parent;

==================================================
ReflectionUtil.java
index cca3ede351..f3871818b4 100644
--- a/java/org/apache/el/util/MessageFactory.java
+++ b/java/org/apache/el/util/MessageFactory.java
@@ -21,7 +21,7 @@ import java.util.ResourceBundle;
 
 /**
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: dpatil $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public final class MessageFactory {
 

==================================================
JspRuntimeContext.java
index ead44f450d..42f162a5c2 100644
--- a/java/org/apache/el/util/ReflectionUtil.java
+++ b/java/org/apache/el/util/ReflectionUtil.java
@@ -34,7 +34,7 @@ import org.apache.el.lang.ELSupport;
  * Utilities for Managing Serialization and Reflection
  * 
  * @author Jacob Hookom [jacob@hookom.net]
- * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: jhook $
+ * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author$
  */
 public class ReflectionUtil {
 

==================================================
AnnotationHelper.java
index eb24a578b3..cfaa070169 100644
--- a/java/org/apache/jasper/resources/LocalStrings_ja.properties
+++ b/java/org/apache/jasper/resources/LocalStrings_ja.properties
@@ -1,4 +1,4 @@
-# $Id: LocalStrings_ja.properties 349479 2005-11-28 19:44:47Z yoavs $
+# $Id$
 #
 # Default localized string information
 # Localized this the Default Locale as is ja_JP

==================================================
Enumerator.java
index 63b47617e7..428f3d2840 100644
--- a/java/org/apache/jasper/runtime/AnnotationHelper.java
+++ b/java/org/apache/jasper/runtime/AnnotationHelper.java
@@ -29,7 +29,7 @@ import org.apache.AnnotationProcessor;
  *
  * @author Fabien Carrion
  * @author Remy Maucherat
- * @version $Revision: 303236 $, $Date: 2006-03-09 16:46:52 -0600 (Thu, 09 Mar 2006) $
+ * @version $Revision$, $Date$
  */
 public class AnnotationHelper {
 

==================================================
ASCIIReader.java
index 254467c8ff..8c6e7e35b2 100644
--- a/java/org/apache/jasper/util/Enumerator.java
+++ b/java/org/apache/jasper/util/Enumerator.java
@@ -35,7 +35,7 @@ import java.util.NoSuchElementException;
  * Constructors are provided to easliy create such wrappers.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public final class Enumerator implements Enumeration {

==================================================
EncodingMap.java
index 279b58a6f1..7a13dd53f7 100644
--- a/java/org/apache/jasper/xmlparser/ASCIIReader.java
+++ b/java/org/apache/jasper/xmlparser/ASCIIReader.java
@@ -28,7 +28,7 @@ import org.apache.jasper.compiler.Localizer;
  *
  * @author Andy Clark, IBM
  *
- * @version $Id: ASCIIReader.java 305933 2004-03-17 19:23:05Z luehe $
+ * @version $Id$
  */
 public class ASCIIReader
     extends Reader {

==================================================
ParserUtils.java
index ffdc73cc8b..0ebf31f113 100644
--- a/java/org/apache/jasper/xmlparser/EncodingMap.java
+++ b/java/org/apache/jasper/xmlparser/EncodingMap.java
@@ -474,7 +474,7 @@ import java.util.Hashtable;
  * @author TAMURA Kent, IBM
  * @author Andy Clark, IBM
  *
- * @version $Id: EncodingMap.java 306086 2004-10-01 19:24:35Z luehe $
+ * @version $Id$
  */
 public class EncodingMap {
 

==================================================
SymbolTable.java
index 1e3a11517d..e27cc856da 100644
--- a/java/org/apache/jasper/xmlparser/ParserUtils.java
+++ b/java/org/apache/jasper/xmlparser/ParserUtils.java
@@ -48,7 +48,7 @@ import org.xml.sax.SAXParseException;
  * use a separate class loader for the parser to be used.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 306152 $ $Date: 2005-03-23 22:08:01 -0600 (Wed, 23 Mar 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class ParserUtils {

==================================================
TreeNode.java
index 5edbde79d9..ad77e29857 100644
--- a/java/org/apache/jasper/xmlparser/SymbolTable.java
+++ b/java/org/apache/jasper/xmlparser/SymbolTable.java
@@ -49,7 +49,7 @@ package org.apache.jasper.xmlparser;
  * </ul>
  *
  * @author Andy Clark
- * @version $Id: SymbolTable.java 306179 2005-07-27 15:12:04Z yoavs $
+ * @version $Id$
  */
 public class SymbolTable {
 

==================================================
UCSReader.java
index 6a76ffe240..4ccf97b416 100644
--- a/java/org/apache/jasper/xmlparser/TreeNode.java
+++ b/java/org/apache/jasper/xmlparser/TreeNode.java
@@ -34,7 +34,7 @@ import java.util.Iterator;
  * synchronized.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 305933 $ $Date: 2004-03-17 13:23:05 -0600 (Wed, 17 Mar 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class TreeNode {

==================================================
UTF8Reader.java
index f2005fae9c..8f3de57274 100644
--- a/java/org/apache/jasper/xmlparser/UCSReader.java
+++ b/java/org/apache/jasper/xmlparser/UCSReader.java
@@ -27,7 +27,7 @@ import java.io.Reader;
  *
  * @author Neil Graham, IBM
  *
- * @version $Id: UCSReader.java 306148 2005-03-21 15:38:13Z remm $
+ * @version $Id$
  */
 public class UCSReader extends Reader {
 

==================================================
XMLChar.java
index cd3f7a6a8e..c562e4c53c 100644
--- a/java/org/apache/jasper/xmlparser/UTF8Reader.java
+++ b/java/org/apache/jasper/xmlparser/UTF8Reader.java
@@ -26,7 +26,7 @@ import org.apache.jasper.compiler.Localizer;
 /**
  * @author Andy Clark, IBM
  *
- * @version $Id: UTF8Reader.java 306148 2005-03-21 15:38:13Z remm $
+ * @version $Id$
  */
 public class UTF8Reader
     extends Reader {

==================================================
XMLString.java
index 858cd8e7c1..4e022ec7f1 100644
--- a/java/org/apache/jasper/xmlparser/XMLChar.java
+++ b/java/org/apache/jasper/xmlparser/XMLChar.java
@@ -49,7 +49,7 @@ import java.util.Arrays;
  * @author Michael Glavassevich, IBM
  * @author Rahul Srivastava, Sun Microsystems Inc.
  *
- * @version $Id: XMLChar.java 306179 2005-07-27 15:12:04Z yoavs $
+ * @version $Id$
  */
 public class XMLChar {
 

==================================================
XMLStringBuffer.java
index 66919fa1ca..4311cdddc6 100644
--- a/java/org/apache/jasper/xmlparser/XMLString.java
+++ b/java/org/apache/jasper/xmlparser/XMLString.java
@@ -47,7 +47,7 @@ package org.apache.jasper.xmlparser;
  * @author Eric Ye, IBM
  * @author Andy Clark, IBM
  *
- * @version $Id: XMLString.java 306086 2004-10-01 19:24:35Z luehe $
+ * @version $Id$
  */
 public class XMLString {
 

==================================================
BaseJkConfig.java
index f96cb4917e..69802d0f94 100644
--- a/java/org/apache/jasper/xmlparser/XMLStringBuffer.java
+++ b/java/org/apache/jasper/xmlparser/XMLStringBuffer.java
@@ -44,7 +44,7 @@ package org.apache.jasper.xmlparser;
  * @author Andy Clark, IBM
  * @author Eric Ye, IBM
  *
- * @version $Id: XMLStringBuffer.java 306086 2004-10-01 19:24:35Z luehe $
+ * @version $Id$
  */
 public class XMLStringBuffer
     extends XMLString {

==================================================
FileHandler.java
index 29c977157a..661c01ca35 100644
--- a/java/org/apache/jk/config/BaseJkConfig.java
+++ b/java/org/apache/jk/config/BaseJkConfig.java
@@ -89,7 +89,7 @@ import org.apache.catalina.Server;
     @author Costin Manolache
     @author Larry Isaacs
     @author Bill Barker
-        @version $Revision: 299988 $
+        @version $Revision$
  */
 public class BaseJkConfig  implements LifecycleListener {
     private static org.apache.juli.logging.Log log =

==================================================
Log.java
index 447789a9e5..2aff256d62 100644
--- a/java/org/apache/juli/FileHandler.java
+++ b/java/org/apache/juli/FileHandler.java
@@ -36,7 +36,7 @@ import java.util.logging.SimpleFormatter;
  * named {prefix}.{date}.{suffix} in a configured directory, with an
  * optional preceding timestamp.
  *
- * @version $Revision: 300331 $ $Date: 2005-03-03 19:29:45 +0100 (jeu., 03 mars 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class FileHandler

==================================================
LogConfigurationException.java
index b00c6d7085..9264a15b14 100644
--- a/java/org/apache/juli/logging/Log.java
+++ b/java/org/apache/juli/logging/Log.java
@@ -58,7 +58,7 @@ package org.apache.juli.logging;
  *
  * @author <a href="mailto:sanders@apache.org">Scott Sanders</a>
  * @author Rod Waldhoff
- * @version $Id: Log.java 155426 2005-02-26 13:10:49Z dirkv $
+ * @version $Id$
  */
 public interface Log {
 

==================================================
LogFactory.java
index b0e0029493..5fd32c50f0 100644
--- a/java/org/apache/juli/logging/LogConfigurationException.java
+++ b/java/org/apache/juli/logging/LogConfigurationException.java
@@ -24,7 +24,7 @@ package org.apache.juli.logging;
  * factory methods.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 155426 $ $Date: 2005-02-26 05:10:49 -0800 (Sat, 26 Feb 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class LogConfigurationException extends RuntimeException {

==================================================
ContextAccessController.java
index bc9d6222b3..0bdd955bbf 100644
--- a/java/org/apache/juli/logging/LogFactory.java
+++ b/java/org/apache/juli/logging/LogFactory.java
@@ -63,7 +63,7 @@ import java.util.Properties;
  * @author Craig R. McClanahan
  * @author Costin Manolache
  * @author Richard A. Sitze
- * @version $Revision: 209449 $ $Date: 2005-07-06 05:06:32 -0700 (Wed, 06 Jul 2005) $
+ * @version $Revision$ $Date$
  */
 public /* abstract */ class LogFactory {
 

==================================================
ContextBindings.java
index c8e44348c2..20b4906b9b 100644
--- a/java/org/apache/naming/ContextAccessController.java
+++ b/java/org/apache/naming/ContextAccessController.java
@@ -24,7 +24,7 @@ import java.util.Hashtable;
  * Handles the access control on the JNDI contexts.
  *
  * @author Remy Maucherat
- * @version $Revision: 303133 $ $Date: 2004-08-29 18:46:15 +0200 (dim., 29 août 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class ContextAccessController {

==================================================
EjbRef.java
index 25935d32f2..523848b941 100644
--- a/java/org/apache/naming/ContextBindings.java
+++ b/java/org/apache/naming/ContextBindings.java
@@ -30,7 +30,7 @@ import javax.naming.Context;
  * </ul>
  *
  * @author Remy Maucherat
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class ContextBindings {

==================================================
JndiPermission.java
index 0486af4d67..86e330e9c5 100644
--- a/java/org/apache/naming/EjbRef.java
+++ b/java/org/apache/naming/EjbRef.java
@@ -26,7 +26,7 @@ import javax.naming.StringRefAddr;
  * Represents a reference address to an EJB.
  *
  * @author Remy Maucherat
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class EjbRef

==================================================
NameParserImpl.java
index 2cfe4bba79..ec2c2b61ab 100644
--- a/java/org/apache/naming/LocalStrings_es.properties
+++ b/java/org/apache/naming/LocalStrings_es.properties
@@ -1,4 +1,4 @@
-# $Id: LocalStrings_es.properties 301082 2002-07-18 16:47:23Z remm $
+# $Id$
 
 # language es
 

==================================================
NamingContext.java
index be7af2bc75..3c8cb0573e 100644
--- a/java/org/apache/naming/NameParserImpl.java
+++ b/java/org/apache/naming/NameParserImpl.java
@@ -27,7 +27,7 @@ import javax.naming.CompositeName;
  * Parses names.
  *
  * @author Remy Maucherat
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class NameParserImpl 

==================================================
NamingContextBindingsEnumeration.java
index 3d600bbf25..092a0937c8 100644
--- a/java/org/apache/naming/NamingContext.java
+++ b/java/org/apache/naming/NamingContext.java
@@ -41,7 +41,7 @@ import javax.naming.spi.NamingManager;
  * Catalina JNDI Context implementation.
  *
  * @author Remy Maucherat
- * @version $Revision: 366304 $ $Date: 2006-01-05 22:42:29 +0100 (jeu., 05 janv. 2006) $
+ * @version $Revision$ $Date$
  */
 public class NamingContext implements Context {
 

==================================================
NamingContextEnumeration.java
index c8acd98027..27adb0de6a 100644
--- a/java/org/apache/naming/NamingContextBindingsEnumeration.java
+++ b/java/org/apache/naming/NamingContextBindingsEnumeration.java
@@ -30,7 +30,7 @@ import javax.naming.NamingException;
  * Naming enumeration implementation.
  *
  * @author Remy Maucherat
- * @version $Revision: 366304 $ $Date: 2006-01-05 22:42:29 +0100 (jeu., 05 janv. 2006) $
+ * @version $Revision$ $Date$
  */
 
 public class NamingContextBindingsEnumeration 

==================================================
NamingEntry.java
index bc893df024..239bb4e9ac 100644
--- a/java/org/apache/naming/NamingContextEnumeration.java
+++ b/java/org/apache/naming/NamingContextEnumeration.java
@@ -28,7 +28,7 @@ import javax.naming.NamingException;
  * Naming enumeration implementation.
  *
  * @author Remy Maucherat
- * @version $Revision: 303022 $ $Date: 2004-07-24 00:46:08 +0200 (sam., 24 juil. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class NamingContextEnumeration 

==================================================
NamingService.java
index f1d688c6a4..a8caef8e93 100644
--- a/java/org/apache/naming/NamingEntry.java
+++ b/java/org/apache/naming/NamingEntry.java
@@ -23,7 +23,7 @@ package org.apache.naming;
  * Represents a binding in a NamingContext.
  *
  * @author Remy Maucherat
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class NamingEntry {

==================================================
NamingServiceMBean.java
index 5020c43470..4e1348bac0 100644
--- a/java/org/apache/naming/NamingService.java
+++ b/java/org/apache/naming/NamingService.java
@@ -29,7 +29,7 @@ import javax.management.Notification;
  * Implementation of the NamingService JMX MBean.
  * 
  * @author <a href="mailto:remm@apache.org">Remy Maucherat</a>
- * @version $Revision: 303104 $
+ * @version $Revision$
  */
 
 public final class NamingService

==================================================
ResourceEnvRef.java
index f0309bb8cc..936c8a8d6f 100644
--- a/java/org/apache/naming/NamingServiceMBean.java
+++ b/java/org/apache/naming/NamingServiceMBean.java
@@ -21,7 +21,7 @@ package org.apache.naming;
  * Naming MBean interface.
  * 
  * @author <a href="mailto:remm@apache.org">Remy Maucherat</a>
- * @version $Revision: 302726 $
+ * @version $Revision$
  */
 
 public interface NamingServiceMBean {

==================================================
ResourceLinkRef.java
index 8f0153e6ac..e4c188bbe3 100644
--- a/java/org/apache/naming/ResourceEnvRef.java
+++ b/java/org/apache/naming/ResourceEnvRef.java
@@ -25,7 +25,7 @@ import javax.naming.Reference;
  * Represents a reference address to a resource environment.
  *
  * @author Remy Maucherat
- * @version $Revision: 303133 $ $Date: 2004-08-29 18:46:15 +0200 (dim., 29 août 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class ResourceEnvRef

==================================================
ResourceRef.java
index c8e9c85dbe..e8879ab4b4 100644
--- a/java/org/apache/naming/ResourceLinkRef.java
+++ b/java/org/apache/naming/ResourceLinkRef.java
@@ -26,7 +26,7 @@ import javax.naming.StringRefAddr;
  * Represents a reference address to a resource.
  *
  * @author Remy Maucherat
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class ResourceLinkRef

==================================================
SelectorContext.java
index 2e5f08cd5a..3456fdea07 100644
--- a/java/org/apache/naming/ResourceRef.java
+++ b/java/org/apache/naming/ResourceRef.java
@@ -29,7 +29,7 @@ import javax.naming.StringRefAddr;
  * Represents a reference address to a resource.
  *
  * @author Remy Maucherat
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class ResourceRef

==================================================
TransactionRef.java
index 26e51c60fb..c44ca69633 100644
--- a/java/org/apache/naming/SelectorContext.java
+++ b/java/org/apache/naming/SelectorContext.java
@@ -29,7 +29,7 @@ import javax.naming.NamingException;
  * Catalina JNDI Context implementation.
  *
  * @author Remy Maucherat
- * @version $Revision: 303999 $ $Date: 2005-07-20 23:25:18 +0200 (mer., 20 juil. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class SelectorContext implements Context {

==================================================
EjbFactory.java
index 650fa40a42..50eb61a1ed 100644
--- a/java/org/apache/naming/TransactionRef.java
+++ b/java/org/apache/naming/TransactionRef.java
@@ -25,7 +25,7 @@ import javax.naming.Reference;
  * Represents a reference address to a transaction.
  *
  * @author Remy Maucherat
- * @version $Revision: 303133 $ $Date: 2004-08-29 18:46:15 +0200 (dim., 29 août 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class TransactionRef

==================================================
MailSessionFactory.java
index e55309fad2..57195f8f77 100644
--- a/java/org/apache/naming/factory/EjbFactory.java
+++ b/java/org/apache/naming/factory/EjbFactory.java
@@ -32,7 +32,7 @@ import org.apache.naming.EjbRef;
  * Object factory for EJBs.
  * 
  * @author Remy Maucherat
- * @version $Revision: 375650 $ $Date: 2006-02-07 18:55:11 +0100 (mar., 07 févr. 2006) $
+ * @version $Revision$ $Date$
  */
 
 public class EjbFactory

==================================================
OpenEjbFactory.java
index 0595bdb6e1..eefcf085b9 100644
--- a/java/org/apache/naming/factory/MailSessionFactory.java
+++ b/java/org/apache/naming/factory/MailSessionFactory.java
@@ -62,7 +62,7 @@ import javax.naming.spi.ObjectFactory;
  * </pre>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 303771 $ $Date: 2005-03-23 16:30:56 +0100 (mer., 23 mars 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class MailSessionFactory implements ObjectFactory {

==================================================
ResourceEnvFactory.java
index 270ea1d586..9a88ba51cd 100644
--- a/java/org/apache/naming/factory/OpenEjbFactory.java
+++ b/java/org/apache/naming/factory/OpenEjbFactory.java
@@ -34,7 +34,7 @@ import java.util.Properties;
  * 
  * @author Jacek Laskowski
  * @author Remy Maucherat
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 public class OpenEjbFactory implements ObjectFactory {
 

==================================================
ResourceFactory.java
index d10ff35908..781a284b53 100644
--- a/java/org/apache/naming/factory/ResourceEnvFactory.java
+++ b/java/org/apache/naming/factory/ResourceEnvFactory.java
@@ -31,7 +31,7 @@ import org.apache.naming.ResourceEnvRef;
  * Object factory for Resources env.
  * 
  * @author Remy Maucherat
- * @version $Revision: 375650 $ $Date: 2006-02-07 18:55:11 +0100 (mar., 07 févr. 2006) $
+ * @version $Revision$ $Date$
  */
 
 public class ResourceEnvFactory

==================================================
ResourceLinkFactory.java
index 77dd4c8d48..341c0d108c 100644
--- a/java/org/apache/naming/factory/ResourceFactory.java
+++ b/java/org/apache/naming/factory/ResourceFactory.java
@@ -31,7 +31,7 @@ import org.apache.naming.ResourceRef;
  * Object factory for Resources.
  * 
  * @author Remy Maucherat
- * @version $Revision: 375650 $ $Date: 2006-02-07 18:55:11 +0100 (mar., 07 févr. 2006) $
+ * @version $Revision$ $Date$
  */
 
 public class ResourceFactory

==================================================
TransactionFactory.java
index 85ea9dc5e8..babbce2447 100644
--- a/java/org/apache/naming/factory/ResourceLinkFactory.java
+++ b/java/org/apache/naming/factory/ResourceLinkFactory.java
@@ -34,7 +34,7 @@ import org.apache.naming.ResourceLinkRef;
  * <p>Object factory for resource links.</p>
  * 
  * @author Remy Maucherat
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class ResourceLinkFactory

==================================================
javaURLContextFactory.java
index d2dc8c69fb..7541f14f6f 100644
--- a/java/org/apache/naming/factory/TransactionFactory.java
+++ b/java/org/apache/naming/factory/TransactionFactory.java
@@ -31,7 +31,7 @@ import org.apache.naming.TransactionRef;
  * Object factory for User trasactions.
  * 
  * @author Remy Maucherat
- * @version $Revision: 375650 $ $Date: 2006-02-07 18:55:11 +0100 (mar., 07 févr. 2006) $
+ * @version $Revision$ $Date$
  */
 
 public class TransactionFactory

==================================================
BaseDirContext.java
index 61519f1a28..2f759e9f19 100644
--- a/java/org/apache/naming/java/javaURLContextFactory.java
+++ b/java/org/apache/naming/java/javaURLContextFactory.java
@@ -44,7 +44,7 @@ import org.apache.naming.ContextBindings;
  * </ul>
  * 
  * @author Remy Maucherat
- * @version $Revision: 302726 $ $Date: 2004-02-27 15:59:07 +0100 (ven., 27 févr. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class javaURLContextFactory

==================================================
CacheEntry.java
index 3593ecf4da..78f3c02b1e 100644
--- a/java/org/apache/naming/resources/BaseDirContext.java
+++ b/java/org/apache/naming/resources/BaseDirContext.java
@@ -37,7 +37,7 @@ import org.apache.naming.StringManager;
  * Directory Context implementation helper class.
  *
  * @author Remy Maucherat
- * @version $Revision: 303999 $ $Date: 2005-07-20 23:25:18 +0200 (mer., 20 juil. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public abstract class BaseDirContext implements DirContext {

==================================================
DirContextURLConnection.java
index 88f97cebfc..aafc1a877d 100644
--- a/java/org/apache/naming/resources/CacheEntry.java
+++ b/java/org/apache/naming/resources/CacheEntry.java
@@ -23,7 +23,7 @@ import javax.naming.directory.DirContext;
  * Implements a cache entry.
  * 
  * @author <a href="mailto:remm@apache.org">Remy Maucherat</a>
- * @version $Revision: 302726 $
+ * @version $Revision$
  */
 public class CacheEntry {
     

==================================================
DirContextURLStreamHandler.java
index bdae090046..aa60769e0f 100644
--- a/java/org/apache/naming/resources/DirContextURLConnection.java
+++ b/java/org/apache/naming/resources/DirContextURLConnection.java
@@ -45,7 +45,7 @@ import org.apache.naming.resources.ResourceAttributes;
  * content is directly returned.
  * 
  * @author <a href="mailto:remm@apache.org">Remy Maucherat</a>
- * @version $Revision: 303022 $
+ * @version $Revision$
  */
 public class DirContextURLConnection 
     extends URLConnection {

==================================================
DirContextURLStreamHandlerFactory.java
index c1d9dfa477..389042d267 100644
--- a/java/org/apache/naming/resources/DirContextURLStreamHandler.java
+++ b/java/org/apache/naming/resources/DirContextURLStreamHandler.java
@@ -29,7 +29,7 @@ import javax.naming.directory.DirContext;
  * Stream handler to a JNDI directory context.
  * 
  * @author <a href="mailto:remm@apache.org">Remy Maucherat</a>
- * @version $Revision: 304080 $
+ * @version $Revision$
  */
 public class DirContextURLStreamHandler 
     extends URLStreamHandler {

==================================================
FileDirContext.java
index 64a4f2eaa6..ab77b5ae51 100644
--- a/java/org/apache/naming/resources/DirContextURLStreamHandlerFactory.java
+++ b/java/org/apache/naming/resources/DirContextURLStreamHandlerFactory.java
@@ -24,7 +24,7 @@ import java.net.URLStreamHandlerFactory;
  * Factory for Stream handlers to a JNDI directory context.
  * 
  * @author <a href="mailto:remm@apache.org">Remy Maucherat</a>
- * @version $Revision: 302726 $
+ * @version $Revision$
  */
 public class DirContextURLStreamHandlerFactory 
     implements URLStreamHandlerFactory {

==================================================
ImmutableNameNotFoundException.java
index 38fa992c6e..ddb40feb5c 100644
--- a/java/org/apache/naming/resources/FileDirContext.java
+++ b/java/org/apache/naming/resources/FileDirContext.java
@@ -45,7 +45,7 @@ import org.apache.naming.NamingEntry;
  * Filesystem Directory Context implementation helper class.
  *
  * @author Remy Maucherat
- * @version $Revision: 366304 $ $Date: 2006-01-05 22:42:29 +0100 (jeu., 05 janv. 2006) $
+ * @version $Revision$ $Date$
  */
 
 public class FileDirContext extends BaseDirContext {

==================================================
ProxyDirContext.java
index af70d53483..d924fa77df 100644
--- a/java/org/apache/naming/resources/ImmutableNameNotFoundException.java
+++ b/java/org/apache/naming/resources/ImmutableNameNotFoundException.java
@@ -26,7 +26,7 @@ import javax.naming.NameNotFoundException;
  * properly populated exceptions.
  * 
  * @author <a href="mailto:remm@apache.org">Remy Maucherat</a>
- * @version $Revision: 302726 $
+ * @version $Revision$
  */
 public class ImmutableNameNotFoundException
     extends NameNotFoundException {

==================================================
RecyclableNamingEnumeration.java
index 602ac27a9f..509c0e2ed9 100644
--- a/java/org/apache/naming/resources/ProxyDirContext.java
+++ b/java/org/apache/naming/resources/ProxyDirContext.java
@@ -40,7 +40,7 @@ import org.apache.naming.StringManager;
  * Proxy Directory Context implementation.
  *
  * @author Remy Maucherat
- * @version $Revision: 304085 $ $Date: 2005-09-12 12:57:46 +0200 (lun., 12 sept. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class ProxyDirContext implements DirContext {

==================================================
Resource.java
index e013b7118b..efd31c4861 100644
--- a/java/org/apache/naming/resources/RecyclableNamingEnumeration.java
+++ b/java/org/apache/naming/resources/RecyclableNamingEnumeration.java
@@ -28,7 +28,7 @@ import javax.naming.NamingException;
  * Naming enumeration implementation.
  *
  * @author Remy Maucherat
- * @version $Revision: 303022 $ $Date: 2004-07-24 00:46:08 +0200 (sam., 24 juil. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public class RecyclableNamingEnumeration 

==================================================
ResourceAttributes.java
index 83abc8d6d3..7dc44dc3a5 100644
--- a/java/org/apache/naming/resources/Resource.java
+++ b/java/org/apache/naming/resources/Resource.java
@@ -25,7 +25,7 @@ import java.io.IOException;
  * Encapsultes the contents of a resource.
  * 
  * @author <a href="mailto:remm@apache.org">Remy Maucherat</a>
- * @version $Revision: 302726 $
+ * @version $Revision$
  */
 public class Resource {
     

==================================================
ResourceCache.java
index 300ab6d7a1..59bf3e423f 100644
--- a/java/org/apache/naming/resources/ResourceAttributes.java
+++ b/java/org/apache/naming/resources/ResourceAttributes.java
@@ -34,7 +34,7 @@ import javax.naming.directory.BasicAttribute;
  * Attributes implementation.
  * 
  * @author <a href="mailto:remm@apache.org">Remy Maucherat</a>
- * @version $Revision: 303877 $
+ * @version $Revision$
  */
 public class ResourceAttributes implements Attributes {
     

==================================================
WARDirContext.java
index da14599dbe..2e6fc6a182 100644
--- a/java/org/apache/naming/resources/ResourceCache.java
+++ b/java/org/apache/naming/resources/ResourceCache.java
@@ -25,7 +25,7 @@ import java.util.Random;
  * Implements a special purpose cache.
  * 
  * @author <a href="mailto:remm@apache.org">Remy Maucherat</a>
- * @version $Revision: 304084 $
+ * @version $Revision$
  */
 public class ResourceCache {
     

==================================================
Handler.java
index 61a24780d7..788a1620b0 100644
--- a/java/org/apache/naming/resources/WARDirContext.java
+++ b/java/org/apache/naming/resources/WARDirContext.java
@@ -48,7 +48,7 @@ import org.apache.naming.NamingEntry;
  * WAR Directory Context implementation.
  *
  * @author Remy Maucherat
- * @version $Revision: 366304 $ $Date: 2006-01-05 22:42:29 +0100 (jeu., 05 janv. 2006) $
+ * @version $Revision$ $Date$
  */
 
 public class WARDirContext extends BaseDirContext {

==================================================
Address.java
index a308d6051b..4d568b867c 100644
--- a/java/org/apache/naming/resources/jndi/Handler.java
+++ b/java/org/apache/naming/resources/jndi/Handler.java
@@ -23,7 +23,7 @@ import org.apache.naming.resources.DirContextURLStreamHandler;
  * Stream handler to a JNDI directory context.
  * 
  * @author <a href="mailto:remm@apache.org">Remy Maucherat</a>
- * @version $Revision: 302726 $
+ * @version $Revision$
  */
 public class Handler 
     extends DirContextURLStreamHandler {

==================================================
BIOCallback.java
index cc7b4f8d56..048db45751 100644
--- a/java/org/apache/tomcat/jni/Address.java
+++ b/java/org/apache/tomcat/jni/Address.java
@@ -20,7 +20,7 @@ package org.apache.tomcat.jni;
 /** Address
  *
  * @author Mladen Turk
- * @version $Revision: 300969 $, $Date: 2005-07-12 16:56:11 +0200 (mar., 12 juil. 2005) $
+ * @version $Revision$, $Date$
  */
 
 public class Address {

==================================================
Directory.java
index 296bc16c6b..3632244642 100644
--- a/java/org/apache/tomcat/jni/BIOCallback.java
+++ b/java/org/apache/tomcat/jni/BIOCallback.java
@@ -20,7 +20,7 @@ package org.apache.tomcat.jni;
 /** Open SSL BIO Callback Interface
  *
  * @author Mladen Turk
- * @version $Revision: 300969 $, $Date: 2005-07-12 16:56:11 +0200 (mar., 12 juil. 2005) $
+ * @version $Revision$, $Date$
  */
 
 public interface BIOCallback {

==================================================
Error.java
index 7fddcd4eb5..db31124e7a 100644
--- a/java/org/apache/tomcat/jni/Directory.java
+++ b/java/org/apache/tomcat/jni/Directory.java
@@ -20,7 +20,7 @@ package org.apache.tomcat.jni;
 /** Directory
  *
  * @author Mladen Turk
- * @version $Revision: 300969 $, $Date: 2005-07-12 16:56:11 +0200 (mar., 12 juil. 2005) $
+ * @version $Revision$, $Date$
  */
 
 public class Directory {

==================================================
File.java
index bc76af1a4f..9d56b89b9d 100644
--- a/java/org/apache/tomcat/jni/Error.java
+++ b/java/org/apache/tomcat/jni/Error.java
@@ -20,7 +20,7 @@ package org.apache.tomcat.jni;
 /** Error
  *
  * @author Mladen Turk
- * @version $Revision: 300969 $, $Date: 2005-07-12 16:56:11 +0200 (mar., 12 juil. 2005) $
+ * @version $Revision$, $Date$
  */
 
 public class Error extends Exception {

==================================================
FileInfo.java
index b4d4c05745..7f72d558a7 100644
--- a/java/org/apache/tomcat/jni/File.java
+++ b/java/org/apache/tomcat/jni/File.java
@@ -21,7 +21,7 @@ import java.nio.ByteBuffer;
 /** File
  *
  * @author Mladen Turk
- * @version $Revision: 369000 $, $Date: 2006-01-14 09:08:44 +0100 (sam., 14 janv. 2006) $
+ * @version $Revision$, $Date$
  */
 
 public class File {

==================================================
Global.java
index 0ec0d1921c..59a1cbd955 100644
--- a/java/org/apache/tomcat/jni/FileInfo.java
+++ b/java/org/apache/tomcat/jni/FileInfo.java
@@ -20,7 +20,7 @@ package org.apache.tomcat.jni;
 /** Fileinfo
  *
  * @author Mladen Turk
- * @version $Revision: 300969 $, $Date: 2005-07-12 16:56:11 +0200 (mar., 12 juil. 2005) $
+ * @version $Revision$, $Date$
  */
 
 public class FileInfo {

==================================================
Library.java
index a398911487..47638e47ef 100644
--- a/java/org/apache/tomcat/jni/Global.java
+++ b/java/org/apache/tomcat/jni/Global.java
@@ -20,7 +20,7 @@ package org.apache.tomcat.jni;
 /** Global
  *
  * @author Mladen Turk
- * @version $Revision: 300969 $, $Date: 2005-07-12 16:56:11 +0200 (mar., 12 juil. 2005) $
+ * @version $Revision$, $Date$
  */
 
 public class Global {

==================================================
Local.java
index 59346f2c29..d178c7892a 100644
--- a/java/org/apache/tomcat/jni/Library.java
+++ b/java/org/apache/tomcat/jni/Library.java
@@ -20,7 +20,7 @@ package org.apache.tomcat.jni;
 /** Library
  *
  * @author Mladen Turk
- * @version $Revision: 300969 $, $Date: 2005-07-12 16:56:11 +0200 (mar., 12 juil. 2005) $
+ * @version $Revision$, $Date$
  */
 
 public final class Library {

==================================================
Lock.java
index 37f112ac8f..fb5a7a64c0 100644
--- a/java/org/apache/tomcat/jni/Local.java
+++ b/java/org/apache/tomcat/jni/Local.java
@@ -20,7 +20,7 @@ package org.apache.tomcat.jni;
 /** Local socket
  *
  * @author Mladen Turk
- * @version $Revision: 300969 $, $Date: 2005-07-12 16:56:11 +0200 (mar., 12 juil. 2005) $
+ * @version $Revision$, $Date$
  */
 
 public class Local {

==================================================
Mmap.java
index b759069219..df6e549e37 100644
--- a/java/org/apache/tomcat/jni/Lock.java
+++ b/java/org/apache/tomcat/jni/Lock.java
@@ -20,7 +20,7 @@ package org.apache.tomcat.jni;
 /** Lock
  *
  * @author Mladen Turk
- * @version $Revision: 300969 $, $Date: 2005-07-12 16:56:11 +0200 (mar., 12 juil. 2005) $
+ * @version $Revision$, $Date$
  */
 
 public class Lock {

==================================================
Multicast.java
index de6b243113..f42fd376f8 100644
--- a/java/org/apache/tomcat/jni/Mmap.java
+++ b/java/org/apache/tomcat/jni/Mmap.java
@@ -20,7 +20,7 @@ package org.apache.tomcat.jni;
 /** Mmap
  *
  * @author Mladen Turk
- * @version $Revision: 300969 $, $Date: 2005-07-12 16:56:11 +0200 (mar., 12 juil. 2005) $
+ * @version $Revision$, $Date$
  */
 
 public class Mmap {

==================================================
OS.java
index 88f3b4059a..4e2e6806a4 100644
--- a/java/org/apache/tomcat/jni/Multicast.java
+++ b/java/org/apache/tomcat/jni/Multicast.java
@@ -20,7 +20,7 @@ package org.apache.tomcat.jni;
 /** Multicast
  *
  * @author Mladen Turk
- * @version $Revision: 300969 $, $Date: 2005-07-12 16:56:11 +0200 (mar., 12 juil. 2005) $
+ * @version $Revision$, $Date$
  */
 
 public class Multicast {

==================================================
PasswordCallback.java
index f63dc0f6da..0e7c8a6f94 100644
--- a/java/org/apache/tomcat/jni/OS.java
+++ b/java/org/apache/tomcat/jni/OS.java
@@ -20,7 +20,7 @@ package org.apache.tomcat.jni;
 /** OS
  *
  * @author Mladen Turk
- * @version $Revision: 386278 $, $Date: 2006-03-16 08:15:58 +0100 (jeu., 16 mars 2006) $
+ * @version $Revision$, $Date$
  */
 
 public class OS {

==================================================
Poll.java
index 2c7609ba29..d085ae3c56 100644
--- a/java/org/apache/tomcat/jni/PasswordCallback.java
+++ b/java/org/apache/tomcat/jni/PasswordCallback.java
@@ -20,7 +20,7 @@ package org.apache.tomcat.jni;
 /** PasswordCallback Interface
  *
  * @author Mladen Turk
- * @version $Revision: 300969 $, $Date: 2005-07-12 16:56:11 +0200 (mar., 12 juil. 2005) $
+ * @version $Revision$, $Date$
  */
 
 public interface PasswordCallback {

==================================================
Pool.java
index 5fff9ea25f..8eb0ee82c7 100644
--- a/java/org/apache/tomcat/jni/Poll.java
+++ b/java/org/apache/tomcat/jni/Poll.java
@@ -20,7 +20,7 @@ package org.apache.tomcat.jni;
 /** Poll
  *
  * @author Mladen Turk
- * @version $Revision: 300969 $, $Date: 2005-07-12 16:56:11 +0200 (mar., 12 juil. 2005) $
+ * @version $Revision$, $Date$
  */
 
 public class Poll {

==================================================
PoolCallback.java
index 7f79a9fc22..408c9cb452 100644
--- a/java/org/apache/tomcat/jni/Pool.java
+++ b/java/org/apache/tomcat/jni/Pool.java
@@ -22,7 +22,7 @@ import java.nio.ByteBuffer;
 /** Pool
  *
  * @author Mladen Turk
- * @version $Revision: 300969 $, $Date: 2005-07-12 16:56:11 +0200 (mar., 12 juil. 2005) $
+ * @version $Revision$, $Date$
  */
 
 public class Pool {

==================================================
Proc.java
index e38e8201cb..fa93ec4add 100644
--- a/java/org/apache/tomcat/jni/PoolCallback.java
+++ b/java/org/apache/tomcat/jni/PoolCallback.java
@@ -20,7 +20,7 @@ package org.apache.tomcat.jni;
 /** PoolCallback Interface
  *
  * @author Mladen Turk
- * @version $Revision: 300969 $, $Date: 2005-07-12 16:56:11 +0200 (mar., 12 juil. 2005) $
+ * @version $Revision$, $Date$
  */
 
 public interface PoolCallback {

==================================================
ProcErrorCallback.java
index 90ab1516e0..7f037c71b5 100644
--- a/java/org/apache/tomcat/jni/Proc.java
+++ b/java/org/apache/tomcat/jni/Proc.java
@@ -20,7 +20,7 @@ package org.apache.tomcat.jni;
 /** Proc
  *
  * @author Mladen Turk
- * @version $Revision: 300969 $, $Date: 2005-07-12 16:56:11 +0200 (mar., 12 juil. 2005) $
+ * @version $Revision$, $Date$
  */
 
 public class Proc {

==================================================
Procattr.java
index 7e567c7352..f3598239d4 100644
--- a/java/org/apache/tomcat/jni/ProcErrorCallback.java
+++ b/java/org/apache/tomcat/jni/ProcErrorCallback.java
@@ -20,7 +20,7 @@ package org.apache.tomcat.jni;
 /** ProcErrorCallback Interface
  *
  * @author Mladen Turk
- * @version $Revision: 300969 $, $Date: 2005-07-12 16:56:11 +0200 (mar., 12 juil. 2005) $
+ * @version $Revision$, $Date$
  */
 
 public interface ProcErrorCallback {

==================================================
Registry.java
index bcd7f100c9..f66f64298f 100644
--- a/java/org/apache/tomcat/jni/Procattr.java
+++ b/java/org/apache/tomcat/jni/Procattr.java
@@ -20,7 +20,7 @@ package org.apache.tomcat.jni;
 /** Procattr
  *
  * @author Mladen Turk
- * @version $Revision: 300969 $, $Date: 2005-07-12 16:56:11 +0200 (mar., 12 juil. 2005) $
+ * @version $Revision$, $Date$
  */
 
 public class Procattr {

==================================================
SSL.java
index 4fbe10f73a..724151fb7e 100644
--- a/java/org/apache/tomcat/jni/Registry.java
+++ b/java/org/apache/tomcat/jni/Registry.java
@@ -20,7 +20,7 @@ package org.apache.tomcat.jni;
 /** Windows Registy support
  *
  * @author Mladen Turk
- * @version $Revision: 301076 $, $Date: 2005-09-29 14:07:39 +0200 (jeu., 29 sept. 2005) $
+ * @version $Revision$, $Date$
  */
 
 public class Registry {

==================================================
SSLContext.java
index e001e61e3d..daf8d29ac7 100644
--- a/java/org/apache/tomcat/jni/SSL.java
+++ b/java/org/apache/tomcat/jni/SSL.java
@@ -20,7 +20,7 @@ package org.apache.tomcat.jni;
 /** SSL
  *
  * @author Mladen Turk
- * @version $Revision: 301018 $, $Date: 2005-08-01 09:23:09 +0200 (lun., 01 août 2005) $
+ * @version $Revision$, $Date$
  */
 
 public final class SSL {

==================================================
SSLSocket.java
index fa216a7d74..90472f84d0 100644
--- a/java/org/apache/tomcat/jni/SSLContext.java
+++ b/java/org/apache/tomcat/jni/SSLContext.java
@@ -20,7 +20,7 @@ package org.apache.tomcat.jni;
 /** SSL Context
  *
  * @author Mladen Turk
- * @version $Revision: 300969 $, $Date: 2005-07-12 16:56:11 +0200 (mar., 12 juil. 2005) $
+ * @version $Revision$, $Date$
  */
 
 public final class SSLContext {

==================================================
Shm.java
index 02456148ee..fd408ffe0b 100644
--- a/java/org/apache/tomcat/jni/SSLSocket.java
+++ b/java/org/apache/tomcat/jni/SSLSocket.java
@@ -20,7 +20,7 @@ package org.apache.tomcat.jni;
 /** SSL Socket
  *
  * @author Mladen Turk
- * @version $Revision: 300970 $, $Date: 2005-07-12 19:01:42 +0200 (mar., 12 juil. 2005) $
+ * @version $Revision$, $Date$
  */
 
 public class SSLSocket {

==================================================
Sockaddr.java
index af2e96dfb7..838440582d 100644
--- a/java/org/apache/tomcat/jni/Shm.java
+++ b/java/org/apache/tomcat/jni/Shm.java
@@ -22,7 +22,7 @@ import java.nio.ByteBuffer;
 /** Shm
  *
  * @author Mladen Turk
- * @version $Revision: 300969 $, $Date: 2005-07-12 16:56:11 +0200 (mar., 12 juil. 2005) $
+ * @version $Revision$, $Date$
  */
 
 public class Shm {

==================================================
Socket.java
index aab46ba64b..3f2b90cb8f 100644
--- a/java/org/apache/tomcat/jni/Sockaddr.java
+++ b/java/org/apache/tomcat/jni/Sockaddr.java
@@ -20,7 +20,7 @@ package org.apache.tomcat.jni;
 /** Sockaddr
  *
  * @author Mladen Turk
- * @version $Revision: 300969 $, $Date: 2005-07-12 16:56:11 +0200 (mar., 12 juil. 2005) $
+ * @version $Revision$, $Date$
  */
 
 public class Sockaddr {

==================================================
Status.java
index 6848f4d2d5..969a16b6f7 100644
--- a/java/org/apache/tomcat/jni/Socket.java
+++ b/java/org/apache/tomcat/jni/Socket.java
@@ -23,7 +23,7 @@ import java.nio.ByteBuffer;
 /** Socket
  *
  * @author Mladen Turk
- * @version $Revision: 327657 $, $Date: 2005-10-22 14:32:32 +0200 (sam., 22 oct. 2005) $
+ * @version $Revision$, $Date$
  */
 
 public class Socket {

==================================================
Stdlib.java
index caa1033e36..9f883ea9c7 100644
--- a/java/org/apache/tomcat/jni/Status.java
+++ b/java/org/apache/tomcat/jni/Status.java
@@ -20,7 +20,7 @@ package org.apache.tomcat.jni;
 /** Status
  *
  * @author Mladen Turk
- * @version $Revision: 300969 $, $Date: 2005-07-12 16:56:11 +0200 (mar., 12 juil. 2005) $
+ * @version $Revision$, $Date$
  */
 
 public class Status {

==================================================
Time.java
index c63da45335..1be544b9b5 100644
--- a/java/org/apache/tomcat/jni/Stdlib.java
+++ b/java/org/apache/tomcat/jni/Stdlib.java
@@ -20,7 +20,7 @@ package org.apache.tomcat.jni;
 /** Stdlib
  *
  * @author Mladen Turk
- * @version $Revision: 300969 $, $Date: 2005-07-12 16:56:11 +0200 (mar., 12 juil. 2005) $
+ * @version $Revision$, $Date$
  */
 
 public class Stdlib {

==================================================
User.java
index 2fc271e28b..dc41535a6c 100644
--- a/java/org/apache/tomcat/jni/Time.java
+++ b/java/org/apache/tomcat/jni/Time.java
@@ -20,7 +20,7 @@ package org.apache.tomcat.jni;
 /** Time
  *
  * @author Mladen Turk
- * @version $Revision: 300969 $, $Date: 2005-07-12 16:56:11 +0200 (mar., 12 juil. 2005) $
+ * @version $Revision$, $Date$
  */
 
 public class Time {

==================================================
Base64.java
index eb0fe14730..69723f9dcc 100644
--- a/java/org/apache/tomcat/jni/User.java
+++ b/java/org/apache/tomcat/jni/User.java
@@ -20,7 +20,7 @@ package org.apache.tomcat.jni;
 /** User
  *
  * @author Mladen Turk
- * @version $Revision: 300969 $, $Date: 2005-07-12 16:56:11 +0200 (mar., 12 juil. 2005) $
+ * @version $Revision$, $Date$
  */
 
 public class User {

==================================================
AbstractObjectCreationFactory.java
index 173b77cec1..c1e5e5f9e3 100644
--- a/java/org/apache/tomcat/util/buf/Base64.java
+++ b/java/org/apache/tomcat/util/buf/Base64.java
@@ -28,7 +28,7 @@ package org.apache.tomcat.util.buf;
  * This class is used by XML Schema binary format validation
  *
  * @author Jeffrey Rodriguez
- * @version $Revision: 299789 $ $Date: 2004-09-17 20:34:19 +0200 (ven., 17 sept. 2004) $
+ * @version $Revision$ $Date$
  */
 
 public final class Base64 {

==================================================
AbstractRulesImpl.java
index 95444e5bd0..43eaf48cfd 100644
--- a/java/org/apache/tomcat/util/digester/AbstractObjectCreationFactory.java
+++ b/java/org/apache/tomcat/util/digester/AbstractObjectCreationFactory.java
@@ -1,4 +1,4 @@
-/* $Id: AbstractObjectCreationFactory.java 299475 2004-06-26 17:41:32Z remm $
+/* $Id$
  *
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with

==================================================
ArrayStack.java
index 3db53b6a26..34b552cf15 100644
--- a/java/org/apache/tomcat/util/digester/AbstractRulesImpl.java
+++ b/java/org/apache/tomcat/util/digester/AbstractRulesImpl.java
@@ -1,4 +1,4 @@
-/* $Id: AbstractRulesImpl.java 299475 2004-06-26 17:41:32Z remm $
+/* $Id$
  *
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with

==================================================
CallMethodRule.java
index 573c71f7f4..6830bd0fad 100644
--- a/java/org/apache/tomcat/util/digester/ArrayStack.java
+++ b/java/org/apache/tomcat/util/digester/ArrayStack.java
@@ -1,4 +1,4 @@
-/* $Id: ArrayStack.java 299475 2004-06-26 17:41:32Z remm $
+/* $Id$
  *
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with

==================================================
CallParamRule.java
index e253627775..985953f973 100644
--- a/java/org/apache/tomcat/util/digester/CallMethodRule.java
+++ b/java/org/apache/tomcat/util/digester/CallMethodRule.java
@@ -1,4 +1,4 @@
-/* $Id: CallMethodRule.java 299765 2004-08-31 23:52:52Z yoavs $
+/* $Id$
  *
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with

==================================================
Digester.java
index a307fdd86e..56d17838a4 100644
--- a/java/org/apache/tomcat/util/digester/CallParamRule.java
+++ b/java/org/apache/tomcat/util/digester/CallParamRule.java
@@ -1,4 +1,4 @@
-/* $Id: CallParamRule.java 299475 2004-06-26 17:41:32Z remm $
+/* $Id$
  *
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with

==================================================
FactoryCreateRule.java
index 4ae08f5c09..2c5d8c3d7b 100644
--- a/java/org/apache/tomcat/util/digester/Digester.java
+++ b/java/org/apache/tomcat/util/digester/Digester.java
@@ -1,4 +1,4 @@
-/* $Id: Digester.java 380645 2006-02-24 11:37:46Z remm $
+/* $Id$
  *
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with

==================================================
GenericParser.java
index 1a66d4a5f9..98fa702780 100644
--- a/java/org/apache/tomcat/util/digester/FactoryCreateRule.java
+++ b/java/org/apache/tomcat/util/digester/FactoryCreateRule.java
@@ -1,4 +1,4 @@
-/* $Id: FactoryCreateRule.java 299475 2004-06-26 17:41:32Z remm $
+/* $Id$
  *
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with

==================================================
NodeCreateRule.java
index 4f7e9a7d30..c61acdcdd2 100644
--- a/java/org/apache/tomcat/util/digester/GenericParser.java
+++ b/java/org/apache/tomcat/util/digester/GenericParser.java
@@ -1,4 +1,4 @@
-/* $Id: GenericParser.java 299475 2004-06-26 17:41:32Z remm $
+/* $Id$
  *
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with

==================================================
ObjectCreateRule.java
index 4e22bb67c8..7f7f6822fe 100644
--- a/java/org/apache/tomcat/util/digester/NodeCreateRule.java
+++ b/java/org/apache/tomcat/util/digester/NodeCreateRule.java
@@ -1,4 +1,4 @@
-/* $Id: NodeCreateRule.java 299765 2004-08-31 23:52:52Z yoavs $
+/* $Id$
  *
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with

==================================================
ObjectCreationFactory.java
index ac70a327bb..742d61639b 100644
--- a/java/org/apache/tomcat/util/digester/ObjectCreateRule.java
+++ b/java/org/apache/tomcat/util/digester/ObjectCreateRule.java
@@ -1,4 +1,4 @@
-/* $Id: ObjectCreateRule.java 299475 2004-06-26 17:41:32Z remm $
+/* $Id$
  *
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with

==================================================
ObjectParamRule.java
index 8155efc690..ced916f7fc 100644
--- a/java/org/apache/tomcat/util/digester/ObjectCreationFactory.java
+++ b/java/org/apache/tomcat/util/digester/ObjectCreationFactory.java
@@ -1,4 +1,4 @@
-/* $Id: ObjectCreationFactory.java 299475 2004-06-26 17:41:32Z remm $
+/* $Id$
  *
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with

==================================================
ParserFeatureSetterFactory.java
index 5149123f06..927200b894 100644
--- a/java/org/apache/tomcat/util/digester/ObjectParamRule.java
+++ b/java/org/apache/tomcat/util/digester/ObjectParamRule.java
@@ -1,4 +1,4 @@
-/* $Id: ObjectParamRule.java 299475 2004-06-26 17:41:32Z remm $
+/* $Id$
  *
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with

==================================================
PathCallParamRule.java
index bff9195151..7760499165 100644
--- a/java/org/apache/tomcat/util/digester/ParserFeatureSetterFactory.java
+++ b/java/org/apache/tomcat/util/digester/ParserFeatureSetterFactory.java
@@ -1,4 +1,4 @@
-/* $Id: ParserFeatureSetterFactory.java 299475 2004-06-26 17:41:32Z remm $
+/* $Id$
  *
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with

==================================================
Rule.java
index 897d1f5d2c..d3f854948a 100644
--- a/java/org/apache/tomcat/util/digester/PathCallParamRule.java
+++ b/java/org/apache/tomcat/util/digester/PathCallParamRule.java
@@ -1,4 +1,4 @@
-/* $Id: PathCallParamRule.java 299475 2004-06-26 17:41:32Z remm $
+/* $Id$
  *
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with

==================================================
RuleSet.java
index 251814b56f..c20239cd05 100644
--- a/java/org/apache/tomcat/util/digester/Rule.java
+++ b/java/org/apache/tomcat/util/digester/Rule.java
@@ -1,4 +1,4 @@
-/* $Id: Rule.java 299475 2004-06-26 17:41:32Z remm $
+/* $Id$
  *
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with

==================================================
RuleSetBase.java
index a168cfa10e..090c66aa9e 100644
--- a/java/org/apache/tomcat/util/digester/RuleSet.java
+++ b/java/org/apache/tomcat/util/digester/RuleSet.java
@@ -1,4 +1,4 @@
-/* $Id: RuleSet.java 299475 2004-06-26 17:41:32Z remm $
+/* $Id$
  *
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with

==================================================
Rules.java
index fb53692f02..1a84b833c5 100644
--- a/java/org/apache/tomcat/util/digester/RuleSetBase.java
+++ b/java/org/apache/tomcat/util/digester/RuleSetBase.java
@@ -1,4 +1,4 @@
-/* $Id: RuleSetBase.java 299475 2004-06-26 17:41:32Z remm $
+/* $Id$
  *
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with

==================================================
RulesBase.java
index 91ae6b78ef..34b2e7ef56 100644
--- a/java/org/apache/tomcat/util/digester/Rules.java
+++ b/java/org/apache/tomcat/util/digester/Rules.java
@@ -1,4 +1,4 @@
-/* $Id: Rules.java 299475 2004-06-26 17:41:32Z remm $
+/* $Id$
  *
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with

==================================================
SetNextRule.java
index b3defb48da..1ba91e7854 100644
--- a/java/org/apache/tomcat/util/digester/RulesBase.java
+++ b/java/org/apache/tomcat/util/digester/RulesBase.java
@@ -1,4 +1,4 @@
-/* $Id: RulesBase.java 299475 2004-06-26 17:41:32Z remm $
+/* $Id$
  *
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with

==================================================
SetPropertiesRule.java
index 8d6241ecb2..54063003f2 100644
--- a/java/org/apache/tomcat/util/digester/SetNextRule.java
+++ b/java/org/apache/tomcat/util/digester/SetNextRule.java
@@ -1,4 +1,4 @@
-/* $Id: SetNextRule.java 299475 2004-06-26 17:41:32Z remm $
+/* $Id$
  *
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with

==================================================
SetPropertyRule.java
index 2d7b8c6c67..f49ddbda55 100644
--- a/java/org/apache/tomcat/util/digester/SetPropertiesRule.java
+++ b/java/org/apache/tomcat/util/digester/SetPropertiesRule.java
@@ -1,4 +1,4 @@
-/* $Id: SetPropertiesRule.java 299475 2004-06-26 17:41:32Z remm $
+/* $Id$
  *
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with

==================================================
SetRootRule.java
index 1aab6c732f..60d8e90604 100644
--- a/java/org/apache/tomcat/util/digester/SetPropertyRule.java
+++ b/java/org/apache/tomcat/util/digester/SetPropertyRule.java
@@ -1,4 +1,4 @@
-/* $Id: SetPropertyRule.java 299475 2004-06-26 17:41:32Z remm $
+/* $Id$
  *
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with

==================================================
SetTopRule.java
index 2f47eae765..b801c5052d 100644
--- a/java/org/apache/tomcat/util/digester/SetRootRule.java
+++ b/java/org/apache/tomcat/util/digester/SetRootRule.java
@@ -1,4 +1,4 @@
-/* $Id: SetRootRule.java 299475 2004-06-26 17:41:32Z remm $
+/* $Id$
  *
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with

==================================================
WithDefaultsRulesWrapper.java
index 32d169545d..08500cda32 100644
--- a/java/org/apache/tomcat/util/digester/SetTopRule.java
+++ b/java/org/apache/tomcat/util/digester/SetTopRule.java
@@ -1,4 +1,4 @@
-/* $Id: SetTopRule.java 299475 2004-06-26 17:41:32Z remm $
+/* $Id$
  *
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with

==================================================
XercesParser.java
index e8e0684ed3..eadfc5c0f9 100644
--- a/java/org/apache/tomcat/util/digester/WithDefaultsRulesWrapper.java
+++ b/java/org/apache/tomcat/util/digester/WithDefaultsRulesWrapper.java
@@ -1,4 +1,4 @@
-/* $Id: WithDefaultsRulesWrapper.java 299475 2004-06-26 17:41:32Z remm $
+/* $Id$
  *
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with

==================================================
BaseRequest.java
index 6a64ae4757..47d0d1009f 100644
--- a/java/org/apache/tomcat/util/digester/XercesParser.java
+++ b/java/org/apache/tomcat/util/digester/XercesParser.java
@@ -1,4 +1,4 @@
-/* $Id: XercesParser.java 299768 2004-09-02 00:48:12Z yoavs $
+/* $Id$
  *
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with

==================================================
DefaultFileItem.java
index 1fc018e8f7..b00f5d3222 100644
--- a/java/org/apache/tomcat/util/http/BaseRequest.java
+++ b/java/org/apache/tomcat/util/http/BaseRequest.java
@@ -18,7 +18,7 @@
 /***************************************************************************
  * Description: Base http request object.                                  *
  * Author:      Keving Seguin [seguin@apache.org]                          *
- * Version:     $Revision: 299484 $                                           *
+ * Version:     $Revision$                                           *
  ***************************************************************************/
 
 package org.apache.tomcat.util.http;

==================================================
DefaultFileItemFactory.java
index 2e492e9c23..8d9087c23a 100644
--- a/java/org/apache/tomcat/util/http/fileupload/DefaultFileItem.java
+++ b/java/org/apache/tomcat/util/http/fileupload/DefaultFileItem.java
@@ -51,7 +51,7 @@ import java.io.UnsupportedEncodingException;
  * @author <a href="mailto:martinc@apache.org">Martin Cooper</a>
  * @author Sean C. Sullivan
  *
- * @version $Id: DefaultFileItem.java,v 1.21 2003/06/24 05:45:15 martinc Exp $
+ * @version $Id$
  */
 public class DefaultFileItem
     implements FileItem

==================================================
DeferredFileOutputStream.java
index 75e6436291..2d29b38996 100644
--- a/java/org/apache/tomcat/util/http/fileupload/DefaultFileItemFactory.java
+++ b/java/org/apache/tomcat/util/http/fileupload/DefaultFileItemFactory.java
@@ -41,7 +41,7 @@ import java.io.File;
  *
  * @author <a href="mailto:martinc@apache.org">Martin Cooper</a>
  *
- * @version $Id: DefaultFileItemFactory.java,v 1.2 2003/05/31 22:31:08 martinc Exp $
+ * @version $Id$
  */
 public class DefaultFileItemFactory implements FileItemFactory
 {

==================================================
DiskFileUpload.java
index ccd97c1ac2..5ba416565d 100644
--- a/java/org/apache/tomcat/util/http/fileupload/DeferredFileOutputStream.java
+++ b/java/org/apache/tomcat/util/http/fileupload/DeferredFileOutputStream.java
@@ -32,7 +32,7 @@ import java.io.OutputStream;
  *
  * @author <a href="mailto:martinc@apache.org">Martin Cooper</a>
  *
- * @version $Id: DeferredFileOutputStream.java,v 1.2 2003/05/31 22:31:08 martinc Exp $
+ * @version $Id$
  */
 public class DeferredFileOutputStream
     extends ThresholdingOutputStream

==================================================
FileItem.java
index 12288ac317..d867f81834 100644
--- a/java/org/apache/tomcat/util/http/fileupload/DiskFileUpload.java
+++ b/java/org/apache/tomcat/util/http/fileupload/DiskFileUpload.java
@@ -45,7 +45,7 @@ import javax.servlet.http.HttpServletRequest;
  * @author <a href="mailto:martinc@apache.org">Martin Cooper</a>
  * @author Sean C. Sullivan
  *
- * @version $Id: DiskFileUpload.java,v 1.3 2003/06/01 00:18:13 martinc Exp $
+ * @version $Id$
  */
 public class DiskFileUpload
     extends FileUploadBase

==================================================
FileItemFactory.java
index c0a475a912..7237c089c3 100644
--- a/java/org/apache/tomcat/util/http/fileupload/FileItem.java
+++ b/java/org/apache/tomcat/util/http/fileupload/FileItem.java
@@ -52,7 +52,7 @@ import java.io.UnsupportedEncodingException;
  * @author <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
  * @author <a href="mailto:martinc@apache.org">Martin Cooper</a>
  *
- * @version $Id: FileItem.java,v 1.15 2003/06/01 17:33:24 martinc Exp $
+ * @version $Id$
  */
 public interface FileItem
     extends Serializable

==================================================
FileUpload.java
index 030013720f..f6988ae242 100644
--- a/java/org/apache/tomcat/util/http/fileupload/FileItemFactory.java
+++ b/java/org/apache/tomcat/util/http/fileupload/FileItemFactory.java
@@ -26,7 +26,7 @@ package org.apache.tomcat.util.http.fileupload;
  *
  * @author <a href="mailto:martinc@apache.org">Martin Cooper</a>
  * 
- * @version $Id: FileItemFactory.java,v 1.1 2003/04/27 17:30:06 martinc Exp $
+ * @version $Id$
  */
 public interface FileItemFactory
 {

==================================================
FileUploadBase.java
index 7e1b082177..5ed1944166 100644
--- a/java/org/apache/tomcat/util/http/fileupload/FileUpload.java
+++ b/java/org/apache/tomcat/util/http/fileupload/FileUpload.java
@@ -40,7 +40,7 @@ package org.apache.tomcat.util.http.fileupload;
  * @author <a href="mailto:martinc@apache.org">Martin Cooper</a>
  * @author Sean C. Sullivan
  *
- * @version $Id: FileUpload.java,v 1.23 2003/06/24 05:45:43 martinc Exp $
+ * @version $Id$
  */
 public class FileUpload
     extends FileUploadBase

==================================================
FileUploadException.java
index 04a01761c9..5b9251d6e2 100644
--- a/java/org/apache/tomcat/util/http/fileupload/FileUploadBase.java
+++ b/java/org/apache/tomcat/util/http/fileupload/FileUploadBase.java
@@ -50,7 +50,7 @@ import javax.servlet.http.HttpServletRequest;
  * @author <a href="mailto:martinc@apache.org">Martin Cooper</a>
  * @author Sean C. Sullivan
  *
- * @version $Id: FileUploadBase.java,v 1.3 2003/06/01 00:18:13 martinc Exp $
+ * @version $Id$
  */
 public abstract class FileUploadBase
 {

==================================================
MultipartStream.java
index c8bcc00218..fd5def1394 100644
--- a/java/org/apache/tomcat/util/http/fileupload/FileUploadException.java
+++ b/java/org/apache/tomcat/util/http/fileupload/FileUploadException.java
@@ -23,7 +23,7 @@ package org.apache.tomcat.util.http.fileupload;
  * Exception for errors encountered while processing the request.
  *
  * @author <a href="mailto:jmcnally@collab.net">John McNally</a>
- * @version $Id: FileUploadException.java,v 1.7 2003/04/27 17:30:06 martinc Exp $
+ * @version $Id$
  */
 public class FileUploadException
     extends Exception

==================================================
ThresholdingOutputStream.java
index 5562a3807c..1ce4ec3fbb 100644
--- a/java/org/apache/tomcat/util/http/fileupload/MultipartStream.java
+++ b/java/org/apache/tomcat/util/http/fileupload/MultipartStream.java
@@ -85,7 +85,7 @@ import java.io.UnsupportedEncodingException;
  * @author <a href="mailto:martinc@apache.org">Martin Cooper</a>
  * @author Sean C. Sullivan
  *
- * @version $Id: MultipartStream.java,v 1.12 2003/06/01 00:18:13 martinc Exp $
+ * @version $Id$
  */
 public class MultipartStream
 {

==================================================
BaseAttributeFilter.java
index 853871f156..87c27b7159 100644
--- a/java/org/apache/tomcat/util/http/fileupload/package.html
+++ b/java/org/apache/tomcat/util/http/fileupload/package.html
@@ -1,4 +1,4 @@
-<!-- $Id: package.html,v 1.3 2003/04/27 17:30:06 martinc Exp $ -->
+<!-- $Id$ -->
 <html>
    <head>
       <title>Overview of the org.apache.commons.fileupload component</title>

==================================================
FeatureInfo.java
index b9eca5cae5..a142c083ab 100644
--- a/java/org/apache/tomcat/util/modeler/BaseAttributeFilter.java
+++ b/java/org/apache/tomcat/util/modeler/BaseAttributeFilter.java
@@ -33,7 +33,7 @@ import javax.management.NotificationFilter;
  * supplied by the application.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 155428 $ $Date: 2005-02-26 14:12:25 +0100 (sam., 26 févr. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class BaseAttributeFilter implements NotificationFilter {

==================================================
ManagedBean.java
index 7dedc87cad..e979da9a6c 100644
--- a/java/org/apache/tomcat/util/modeler/FeatureInfo.java
+++ b/java/org/apache/tomcat/util/modeler/FeatureInfo.java
@@ -31,7 +31,7 @@ import javax.management.MBeanFeatureInfo;
  * <code>ModelMBean</code> beans exposed for management.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 155428 $ $Date: 2005-02-26 14:12:25 +0100 (sam., 26 févr. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class FeatureInfo implements Serializable {

==================================================
NotificationInfo.java
index 9d7c55b3e6..04a6daac1d 100644
--- a/java/org/apache/tomcat/util/modeler/ManagedBean.java
+++ b/java/org/apache/tomcat/util/modeler/ManagedBean.java
@@ -43,7 +43,7 @@ import javax.management.ServiceNotFoundException;
  * descriptor.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 383268 $ $Date: 2006-03-05 03:02:01 +0100 (dim., 05 mars 2006) $
+ * @version $Revision$ $Date$
  */
 
 public class ManagedBean implements java.io.Serializable

==================================================
ParameterInfo.java
index c685896bfe..f924d7e14a 100644
--- a/java/org/apache/tomcat/util/modeler/NotificationInfo.java
+++ b/java/org/apache/tomcat/util/modeler/NotificationInfo.java
@@ -29,7 +29,7 @@ import javax.management.MBeanNotificationInfo;
  * descriptor.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 155428 $ $Date: 2005-02-26 14:12:25 +0100 (sam., 26 févr. 2005) $
+ * @version $Revision$ $Date$
  */
 
 public class NotificationInfo extends FeatureInfo implements Serializable {

==================================================
NioChannel.java
index f2d9c61b6b..8a6a852904 100644
--- a/java/org/apache/tomcat/util/modeler/mbeans-descriptors.dtd
+++ b/java/org/apache/tomcat/util/modeler/mbeans-descriptors.dtd
@@ -11,7 +11,7 @@
       "-//Apache Software Foundation//DTD Model MBeans Configuration File"
       "http://jakarta.apache.org/commons/dtds/mbeans-descriptors.dtd">
 
-     $Id: mbeans-descriptors.dtd 155428 2005-02-26 13:12:25Z dirkv $
+     $Id$
 -->
 
 

==================================================
URL.java
index 33b008ff09..2cff92b2ec 100644
--- a/java/org/apache/tomcat/util/net/NioChannel.java
+++ b/java/org/apache/tomcat/util/net/NioChannel.java
@@ -1,177 +1,177 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.tomcat.util.net;
-
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.channels.ByteChannel;
-import java.nio.channels.SocketChannel;
-
-import org.apache.tomcat.util.net.NioEndpoint.Poller;
-import org.apache.tomcat.util.net.SecureNioChannel.ApplicationBufferHandler;
-import java.nio.channels.Selector;
-
-/**
- * 
- * Base class for a SocketChannel wrapper used by the endpoint.
- * This way, logic for a SSL socket channel remains the same as for
- * a non SSL, making sure we don't need to code for any exception cases.
- * 
- * @author Filip Hanik
- * @version 1.0
- */
-public class NioChannel implements ByteChannel{
-
-    protected static ByteBuffer emptyBuf = ByteBuffer.allocate(0);
-
-    protected SocketChannel sc = null;
-
-    protected ApplicationBufferHandler bufHandler;
-
-    protected Poller poller;
-
-    public NioChannel(SocketChannel channel, ApplicationBufferHandler bufHandler) throws IOException {
-        this.sc = channel;
-        this.bufHandler = bufHandler;
-    }
-
-    public void reset() throws IOException {
-        bufHandler.getReadBuffer().clear();
-        bufHandler.getWriteBuffer().clear();
-    }
-
-    /**
-     * returns true if the network buffer has 
-     * been flushed out and is empty
-     * @return boolean
-     */
-    public boolean flush(Selector s) throws IOException {
-        return true; //no network buffer in the regular channel
-    }
-
-
-    /**
-     * Closes this channel.
-     *
-     * @throws IOException If an I/O error occurs
-     * @todo Implement this java.nio.channels.Channel method
-     */
-    public void close() throws IOException {
-        getIOChannel().socket().close();
-        sc.close();
-    }
-
-    public void close(boolean force) throws IOException {
-        if (isOpen() || force ) close();
-    }
-    /**
-     * Tells whether or not this channel is open.
-     *
-     * @return <tt>true</tt> if, and only if, this channel is open
-     * @todo Implement this java.nio.channels.Channel method
-     */
-    public boolean isOpen() {
-        return sc.isOpen();
-    }
-
-    /**
-     * Writes a sequence of bytes to this channel from the given buffer.
-     *
-     * @param src The buffer from which bytes are to be retrieved
-     * @return The number of bytes written, possibly zero
-     * @throws IOException If some other I/O error occurs
-     * @todo Implement this java.nio.channels.WritableByteChannel method
-     */
-    public int write(ByteBuffer src) throws IOException {
-        return sc.write(src);
-    }
-
-    /**
-     * Reads a sequence of bytes from this channel into the given buffer.
-     *
-     * @param dst The buffer into which bytes are to be transferred
-     * @return The number of bytes read, possibly zero, or <tt>-1</tt> if the channel has reached end-of-stream
-     * @throws IOException If some other I/O error occurs
-     * @todo Implement this java.nio.channels.ReadableByteChannel method
-     */
-    public int read(ByteBuffer dst) throws IOException {
-        return sc.read(dst);
-    }
-
-
-    /**
-     * getBufHandler
-     *
-     * @return ApplicationBufferHandler
-     * @todo Implement this org.apache.tomcat.util.net.SecureNioChannel method
-     */
-    public ApplicationBufferHandler getBufHandler() {
-        return bufHandler;
-    }
-
-    public Poller getPoller() {
-        return poller;
-    }
-    /**
-     * getIOChannel
-     *
-     * @return SocketChannel
-     * @todo Implement this org.apache.tomcat.util.net.SecureNioChannel method
-     */
-    public SocketChannel getIOChannel() {
-        return sc;
-    }
-
-    /**
-     * isClosing
-     *
-     * @return boolean
-     * @todo Implement this org.apache.tomcat.util.net.SecureNioChannel method
-     */
-    public boolean isClosing() {
-        return false;
-    }
-
-    /**
-     * isInitHandshakeComplete
-     *
-     * @return boolean
-     * @todo Implement this org.apache.tomcat.util.net.SecureNioChannel method
-     */
-    public boolean isInitHandshakeComplete() {
-        return true;
-    }
-
-    public int handshake(boolean read, boolean write) throws IOException {
-        return 0;
-    }
-
-    public void setPoller(Poller poller) {
-        this.poller = poller;
-    }
-
-    public void setIOChannel(SocketChannel IOChannel) {
-        this.sc = IOChannel;
-    }
-
-    public String toString() {
-        return super.toString()+":"+this.sc.toString();
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.tomcat.util.net;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.ByteChannel;
+import java.nio.channels.SocketChannel;
+
+import org.apache.tomcat.util.net.NioEndpoint.Poller;
+import org.apache.tomcat.util.net.SecureNioChannel.ApplicationBufferHandler;
+import java.nio.channels.Selector;
+
+/**
+ * 
+ * Base class for a SocketChannel wrapper used by the endpoint.
+ * This way, logic for a SSL socket channel remains the same as for
+ * a non SSL, making sure we don't need to code for any exception cases.
+ * 
+ * @author Filip Hanik
+ * @version 1.0
+ */
+public class NioChannel implements ByteChannel{
+
+    protected static ByteBuffer emptyBuf = ByteBuffer.allocate(0);
+
+    protected SocketChannel sc = null;
+
+    protected ApplicationBufferHandler bufHandler;
+
+    protected Poller poller;
+
+    public NioChannel(SocketChannel channel, ApplicationBufferHandler bufHandler) throws IOException {
+        this.sc = channel;
+        this.bufHandler = bufHandler;
+    }
+
+    public void reset() throws IOException {
+        bufHandler.getReadBuffer().clear();
+        bufHandler.getWriteBuffer().clear();
+    }
+
+    /**
+     * returns true if the network buffer has 
+     * been flushed out and is empty
+     * @return boolean
+     */
+    public boolean flush(Selector s) throws IOException {
+        return true; //no network buffer in the regular channel
+    }
+
+
+    /**
+     * Closes this channel.
+     *
+     * @throws IOException If an I/O error occurs
+     * @todo Implement this java.nio.channels.Channel method
+     */
+    public void close() throws IOException {
+        getIOChannel().socket().close();
+        sc.close();
+    }
+
+    public void close(boolean force) throws IOException {
+        if (isOpen() || force ) close();
+    }
+    /**
+     * Tells whether or not this channel is open.
+     *
+     * @return <tt>true</tt> if, and only if, this channel is open
+     * @todo Implement this java.nio.channels.Channel method
+     */
+    public boolean isOpen() {
+        return sc.isOpen();
+    }
+
+    /**
+     * Writes a sequence of bytes to this channel from the given buffer.
+     *
+     * @param src The buffer from which bytes are to be retrieved
+     * @return The number of bytes written, possibly zero
+     * @throws IOException If some other I/O error occurs
+     * @todo Implement this java.nio.channels.WritableByteChannel method
+     */
+    public int write(ByteBuffer src) throws IOException {
+        return sc.write(src);
+    }
+
+    /**
+     * Reads a sequence of bytes from this channel into the given buffer.
+     *
+     * @param dst The buffer into which bytes are to be transferred
+     * @return The number of bytes read, possibly zero, or <tt>-1</tt> if the channel has reached end-of-stream
+     * @throws IOException If some other I/O error occurs
+     * @todo Implement this java.nio.channels.ReadableByteChannel method
+     */
+    public int read(ByteBuffer dst) throws IOException {
+        return sc.read(dst);
+    }
+
+
+    /**
+     * getBufHandler
+     *
+     * @return ApplicationBufferHandler
+     * @todo Implement this org.apache.tomcat.util.net.SecureNioChannel method
+     */
+    public ApplicationBufferHandler getBufHandler() {
+        return bufHandler;
+    }
+
+    public Poller getPoller() {
+        return poller;
+    }
+    /**
+     * getIOChannel
+     *
+     * @return SocketChannel
+     * @todo Implement this org.apache.tomcat.util.net.SecureNioChannel method
+     */
+    public SocketChannel getIOChannel() {
+        return sc;
+    }
+
+    /**
+     * isClosing
+     *
+     * @return boolean
+     * @todo Implement this org.apache.tomcat.util.net.SecureNioChannel method
+     */
+    public boolean isClosing() {
+        return false;
+    }
+
+    /**
+     * isInitHandshakeComplete
+     *
+     * @return boolean
+     * @todo Implement this org.apache.tomcat.util.net.SecureNioChannel method
+     */
+    public boolean isInitHandshakeComplete() {
+        return true;
+    }
+
+    public int handshake(boolean read, boolean write) throws IOException {
+        return 0;
+    }
+
+    public void setPoller(Poller poller) {
+        this.poller = poller;
+    }
+
+    public void setIOChannel(SocketChannel IOChannel) {
+        this.sc = IOChannel;
+    }
+
+    public String toString() {
+        return super.toString()+":"+this.sc.toString();
+    }
+
+}

==================================================
StringManager.java
index e264d6343f..3521f6eb75 100644
--- a/java/org/apache/tomcat/util/net/URL.java
+++ b/java/org/apache/tomcat/util/net/URL.java
@@ -41,7 +41,7 @@ import java.net.MalformedURLException;
  * package someplace.</p>
  *
  * @author Craig R. McClanahan
- * @version $Revision: 299472 $ $Date: 2004-06-20 02:08:15 +0200 (dim., 20 juin 2004) $
+ * @version $Revision$ $Date$
  */
 
 public final class URL implements Serializable {

==================================================
