48954891c3a40a7bf2753648f2d1904b17a9421f
==================================================
bug 49159: Improve ThreadLocal memory leak clean-up 
==================================================
Sylvain Laurent
==================================================
Sun Dec 5 22:54:05 2010 +0000
==================================================
StandardContext.java
index 2226ea0462..b98069449d 100644
--- a/conf/server.xml
+++ b/conf/server.xml
@@ -28,6 +28,7 @@
   <!-- Prevent memory leaks due to use of particular java/javax APIs-->
   <Listener className="org.apache.catalina.core.JreMemoryLeakPreventionListener" />
   <Listener className="org.apache.catalina.mbeans.GlobalResourcesLifecycleListener" />
+  <Listener className="org.apache.catalina.core.ThreadLocalLeakPreventionListener" />
 
   <!-- Global JNDI resources
        Documentation at /docs/jndi-resources-howto.html

==================================================
StandardThreadExecutor.java
index d5a3bd7545..7f8adebe64 100644
--- a/java/org/apache/catalina/core/StandardContext.java
+++ b/java/org/apache/catalina/core/StandardContext.java
@@ -789,15 +789,14 @@ public class StandardContext extends ContainerBase
      * default value of <code>false</code> will be used.
      */
     private boolean clearReferencesStopTimerThreads = false;
-    
+
     /**
-     * Should Tomcat attempt to clear any ThreadLocal objects that are instances
-     * of classes loaded by this class loader. Failure to remove any such
-     * objects will result in a memory leak on web application stop, undeploy or
-     * reload. It is disabled by default since the clearing of the ThreadLocal
-     * objects is not performed in a thread-safe manner.
+     * Should Tomcat renew the threads of the thread pool when the application
+     * is stopped to avoid memory leaks because of uncleaned ThreadLocal
+     * variables. This also requires that the threadRenewalDelay property of the
+     * StandardThreadExecutor of ThreadPoolExecutor be set to a positive value.
      */
-    private boolean clearReferencesThreadLocals = false;
+    private boolean renewThreadsWhenStoppingContext = true;
     
     /**
      * Should the effective web.xml be logged when the context starts?
@@ -2486,34 +2485,19 @@ public class StandardContext extends ContainerBase
     }
 
 
-    /**
-     * Return the clearReferencesThreadLocals flag for this Context.
-     */
-    public boolean getClearReferencesThreadLocals() {
-
-        return (this.clearReferencesThreadLocals);
-
+    public boolean getRenewThreadsWhenStoppingContext() {
+        return this.renewThreadsWhenStoppingContext;
     }
 
-
-    /**
-     * Set the clearReferencesThreadLocals feature for this Context.
-     *
-     * @param clearReferencesThreadLocals The new flag value
-     */
-    public void setClearReferencesThreadLocals(
-            boolean clearReferencesThreadLocals) {
-
-        boolean oldClearReferencesThreadLocals =
-            this.clearReferencesThreadLocals;
-        this.clearReferencesThreadLocals = clearReferencesThreadLocals;
-        support.firePropertyChange("clearReferencesStopThreads",
-                                   oldClearReferencesThreadLocals,
-                                   this.clearReferencesThreadLocals);
-
+    public void setRenewThreadsWhenStoppingContext(boolean renewThreadsWhenStoppingContext) {
+        boolean oldRenewThreadsWhenStoppingContext =
+            this.renewThreadsWhenStoppingContext;
+        this.renewThreadsWhenStoppingContext = renewThreadsWhenStoppingContext;
+        support.firePropertyChange("renewThreadsWhenStoppingContext",
+                oldRenewThreadsWhenStoppingContext,
+                this.renewThreadsWhenStoppingContext);
     }
 
-
     // -------------------------------------------------------- Context Methods
 
 

==================================================
ThreadLocalLeakPreventionListener.java
index 27e267f873..6c6581f1fb 100644
--- a/java/org/apache/catalina/core/StandardThreadExecutor.java
+++ b/java/org/apache/catalina/core/StandardThreadExecutor.java
@@ -83,6 +83,13 @@ public class StandardThreadExecutor extends LifecycleMBeanBase
      */
     protected int maxQueueSize = Integer.MAX_VALUE;
     
+    /**
+     * After a context is stopped, threads in the pool are renewed. To avoid
+     * renewing all threads at the same time, this delay is observed between 2
+     * threads being renewed.
+     */
+    protected long threadRenewalDelay = 1000L;
+    
     private TaskQueue taskqueue = null;
     // ---------------------------------------------- Constructors
     public StandardThreadExecutor() {
@@ -164,6 +171,12 @@ public class StandardThreadExecutor extends LifecycleMBeanBase
             }
         } else throw new IllegalStateException("StandardThreadPool not started.");
     }
+    
+    public void contextStopping() {
+        if (executor != null) {
+            executor.contextStopping();
+        }
+    }
 
     public int getThreadPriority() {
         return threadPriority;
@@ -249,6 +262,17 @@ public class StandardThreadExecutor extends LifecycleMBeanBase
         return maxQueueSize;
     }
     
+    public long getThreadRenewalDelay() {
+        return threadRenewalDelay;
+    }
+
+    public void setThreadRenewalDelay(long threadRenewalDelay) {
+        this.threadRenewalDelay = threadRenewalDelay;
+        if (executor != null) {
+            executor.setThreadRenewalDelay(threadRenewalDelay);
+        }
+    }
+
     // Statistics from the thread pool
     @Override
     public int getActiveCount() {

==================================================
WebappClassLoader.java
index 47fd08330d..f7daddec0a 100644
--- a/java/org/apache/catalina/loader/LocalStrings.properties
+++ b/java/org/apache/catalina/loader/LocalStrings.properties
@@ -44,14 +44,12 @@ webappClassLoader.clearReferencesResourceBundlesCount=Removed [{0}] ResourceBund
 webappClassLoader.clearReferencesResourceBundlesFail=Failed to clear ResourceBundle references for web application [{0}]
 webappClassLoader.clearRmiInfo=Failed to find class sun.rmi.transport.Target to clear context class loader for web application [{0}]. This is expected on non-Sun JVMs.
 webappClassLoader.clearRmiFail=Failed to clear context class loader referenced from sun.rmi.transport.Target for web application [{0}]
-webappClassLoader.clearThreadLocalDebug=The web application [{0}] created a ThreadLocal with key of type [{1}] (value [{2}]). The ThreadLocal has been correctly set to null and the key will be removed by GC.
-webappClassLoader.clearThreadLocal=The web application [{0}] created a ThreadLocal with key of type [{1}] (value [{2}]) and a value of type [{3}] (value [{4}]) but failed to remove it when the web application was stopped. This is very likely to create a memory leak.
-webappClassLoader.clearThreadLocalDebugClear=To simplify the process of tracing memory leaks, the key has been forcibly removed.
-webappClassLoader.clearThreadLocalClear=To prevent a memory leak, the ThreadLocal has been forcibly removed.
-webappClassLoader.clearThreadLocalFail=Failed to clear ThreadLocal references for web application [{0}]
-webappClassLoader.clearThreadLocal.badKey=Unable to determine string representation of key of type [{0}]
-webappClassLoader.clearThreadLocal.badValue=Unable to determine string representation of value of type [{0}]
-webappClassLoader.clearThreadLocal.unknown=Unknown
+webappClassLoader.checkThreadLocalsForLeaks.badKey=Unable to determine string representation of key of type [{0}]
+webappClassLoader.checkThreadLocalsForLeaks.badValue=Unable to determine string representation of value of type [{0}]
+webappClassLoader.checkThreadLocalsForLeaks.unknown=Unknown
+webappClassLoader.checkThreadLocalsForLeaks=The web application [{0}] created a ThreadLocal with key of type [{1}] (value [{2}]) and a value of type [{3}] (value [{4}]) but failed to remove it when the web application was stopped. Threads are going to be renewed over time to try and avoid a probable memory leak. 
+webappClassLoader.checkThreadLocalsForLeaksDebug=The web application [{0}] created a ThreadLocal with key of type [{1}] (value [{2}]). The ThreadLocal has been correctly set to null and the key will be removed by GC.
+webappClassLoader.checkThreadLocalsForLeaksFail=Failed to check for ThreadLocal references for web application [{0}]
 webappClassLoader.stopThreadFail=Failed to terminate thread named [{0}] for web application [{1}]
 webappClassLoader.stopTimerThreadFail=Failed to terminate TimerThread named [{0}] for web application [{1}]
 webappClassLoader.validationErrorJarPath=Unable to validate JAR entry with name {0}

==================================================
WebappLoader.java
index a667c6cf75..7ed7f58cfd 100644
--- a/java/org/apache/catalina/loader/WebappClassLoader.java
+++ b/java/org/apache/catalina/loader/WebappClassLoader.java
@@ -457,15 +457,6 @@ public class WebappClassLoader
      */
     private boolean clearReferencesStopTimerThreads = false;
 
-    /**
-     * Should Tomcat attempt to clear any ThreadLocal objects that are instances
-     * of classes loaded by this class loader. Failure to remove any such
-     * objects will result in a memory leak on web application stop, undeploy or
-     * reload. It is disabled by default since the clearing of the ThreadLocal
-     * objects is not performed in a thread-safe manner.
-     */
-    private boolean clearReferencesThreadLocals = false;
-    
     /**
      * Should Tomcat call {@link org.apache.juli.logging.LogFactory#release()}
      * when the class loader is stopped? If not specified, the default value
@@ -754,25 +745,6 @@ public class WebappClassLoader
      }
 
 
-     /**
-      * Return the clearReferencesThreadLocals flag for this Context.
-      */
-     public boolean getClearReferencesThreadLocals() {
-         return (this.clearReferencesThreadLocals);
-     }
-
-
-     /**
-      * Set the clearReferencesThreadLocals feature for this Context.
-      *
-      * @param clearReferencesThreadLocals The new flag value
-      */
-     public void setClearReferencesThreadLocals(
-             boolean clearReferencesThreadLocals) {
-         this.clearReferencesThreadLocals = clearReferencesThreadLocals;
-     }
-
-
     // ------------------------------------------------------- Reloader Methods
 
 
@@ -1949,8 +1921,8 @@ public class WebappClassLoader
         // Stop any threads the web application started
         clearReferencesThreads();
         
-        // Clear any ThreadLocals loaded by this class loader
-        clearReferencesThreadLocals();
+        // Check for leaks triggered by ThreadLocals loaded by this class loader
+        checkThreadLocalsForLeaks();
         
         // Clear RMI Targets loaded by this class loader
         clearReferencesRmiTargets();
@@ -2347,7 +2319,7 @@ public class WebappClassLoader
         }
     }
 
-    private void clearReferencesThreadLocals() {
+    private void checkThreadLocalsForLeaks() {
         Thread[] threads = getThreads();
 
         try {
@@ -2371,73 +2343,66 @@ public class WebappClassLoader
                 if (threads[i] != null) {
                     // Clear the first map
                     threadLocalMap = threadLocalsField.get(threads[i]);
-                    clearThreadLocalMap(threadLocalMap, tableField);
+                    checkThreadLocalMapForLeaks(threadLocalMap, tableField);
                     // Clear the second map
                     threadLocalMap =
                         inheritableThreadLocalsField.get(threads[i]);
-                    clearThreadLocalMap(threadLocalMap, tableField);
+                    checkThreadLocalMapForLeaks(threadLocalMap, tableField);
                 }
             }
         } catch (SecurityException e) {
-            log.warn(sm.getString("webappClassLoader.clearThreadLocalFail",
+            log.warn(sm.getString("webappClassLoader.checkThreadLocalsForLeaksFail",
                     contextName), e);
         } catch (NoSuchFieldException e) {
-            log.warn(sm.getString("webappClassLoader.clearThreadLocalFail",
+            log.warn(sm.getString("webappClassLoader.checkThreadLocalsForLeaksFail",
                     contextName), e);
         } catch (ClassNotFoundException e) {
-            log.warn(sm.getString("webappClassLoader.clearThreadLocalFail",
+            log.warn(sm.getString("webappClassLoader.checkThreadLocalsForLeaksFail",
                     contextName), e);
         } catch (IllegalArgumentException e) {
-            log.warn(sm.getString("webappClassLoader.clearThreadLocalFail",
+            log.warn(sm.getString("webappClassLoader.checkThreadLocalsForLeaksFail",
                     contextName), e);
         } catch (IllegalAccessException e) {
-            log.warn(sm.getString("webappClassLoader.clearThreadLocalFail",
+            log.warn(sm.getString("webappClassLoader.checkThreadLocalsForLeaksFail",
                     contextName), e);
         } catch (NoSuchMethodException e) {
-            log.warn(sm.getString("webappClassLoader.clearThreadLocalFail",
+            log.warn(sm.getString("webappClassLoader.checkThreadLocalsForLeaksFail",
                     contextName), e);
         } catch (InvocationTargetException e) {
-            log.warn(sm.getString("webappClassLoader.clearThreadLocalFail",
+            log.warn(sm.getString("webappClassLoader.checkThreadLocalsForLeaksFail",
                     contextName), e);
         }       
     }
 
 
     /*
-     * Clears the given thread local map object. Also pass in the field that
+     * Analyzes the given thread local map object. Also pass in the field that
      * points to the internal table to save re-calculating it on every
      * call to this method.
      */
-    private void clearThreadLocalMap(Object map, Field internalTableField)
+    private void checkThreadLocalMapForLeaks(Object map, Field internalTableField)
             throws NoSuchMethodException, IllegalAccessException,
             NoSuchFieldException, InvocationTargetException {
         if (map != null) {
-            Method mapRemove =
-                map.getClass().getDeclaredMethod("remove",
-                        ThreadLocal.class);
-            mapRemove.setAccessible(true);
             Object[] table = (Object[]) internalTableField.get(map);
-            int staleEntriesCount = 0;
             if (table != null) {
                 for (int j =0; j < table.length; j++) {
                     if (table[j] != null) {
-                        boolean remove = false;
+                        boolean potentialLeak = false;
                         // Check the key
                         Object key = ((Reference<?>) table[j]).get();
-                        if (this.equals(key) ||
-                                isLoadedByThisWebappClassLoader(key)) {
-                            remove = true;
+                        if (this.equals(key) || loadedByThisOrChild(key)) {
+                            potentialLeak = true;
                         }
                         // Check the value
                         Field valueField =
                             table[j].getClass().getDeclaredField("value");
                         valueField.setAccessible(true);
                         Object value = valueField.get(table[j]);
-                        if (this.equals(value) ||
-                                isLoadedByThisWebappClassLoader(value)) {
-                            remove = true;
+                        if (this.equals(value) || loadedByThisOrChild(value)) {
+                            potentialLeak = true;
                         }
-                        if (remove) {
+                        if (potentialLeak) {
                             Object[] args = new Object[5];
                             args[0] = contextName;
                             if (key != null) {
@@ -2446,10 +2411,10 @@ public class WebappClassLoader
                                     args[2] = key.toString();
                                 } catch (Exception e) {
                                     log.error(sm.getString(
-                                            "webappClassLoader.clearThreadLocal.badKey",
+                                            "webappClassLoader.checkThreadLocalsForLeaks.badKey",
                                             args[1]), e);
                                     args[2] = sm.getString(
-                                            "webappClassLoader.clearThreadLocal.unknown");
+                                            "webappClassLoader.checkThreadLocalsForLeaks.unknown");
                                 }
                             }
                             if (value != null) {
@@ -2458,48 +2423,27 @@ public class WebappClassLoader
                                     args[4] = value.toString();
                                 } catch (Exception e) {
                                     log.error(sm.getString(
-                                            "webappClassLoader.clearThreadLocal.badValue",
+                                            "webappClassLoader.checkThreadLocalsForLeaks.badValue",
                                             args[3]), e);
                                     args[4] = sm.getString(
-                                    "webappClassLoader.clearThreadLocal.unknown");
+                                    "webappClassLoader.checkThreadLocalsForLeaks.unknown");
                                 }
                             }
                             if (value == null) {
                                 if (log.isDebugEnabled()) {
                                     log.debug(sm.getString(
-                                            "webappClassLoader.clearThreadLocalDebug",
+                                            "webappClassLoader.checkThreadLocalsForLeaksDebug",
                                             args));
-                                    if (clearReferencesThreadLocals) {
-                                        log.debug(sm.getString(
-                                                "webappClassLoader.clearThreadLocalDebugClear"));
-                                    }
                                 }
                             } else {
                                 log.error(sm.getString(
-                                        "webappClassLoader.clearThreadLocal",
+                                        "webappClassLoader.checkThreadLocalsForLeaks",
                                         args));
-                                if (clearReferencesThreadLocals) {
-                                    log.info(sm.getString(
-                                            "webappClassLoader.clearThreadLocalClear"));
-                                }
-                            }
-                            if (clearReferencesThreadLocals) {
-                                if (key == null) {
-                                  staleEntriesCount++;
-                                } else {
-                                  mapRemove.invoke(map, key);
-                                }
                             }
                         }
                     }
                 }
             }
-            if (staleEntriesCount > 0) {
-                Method mapRemoveStale =
-                    map.getClass().getDeclaredMethod("expungeStaleEntries");
-                mapRemoveStale.setAccessible(true);
-                mapRemoveStale.invoke(map);
-            }
         }
     }
 
@@ -2512,15 +2456,23 @@ public class WebappClassLoader
     }
     
     /**
-     * @param o object to test
+     * @param o object to test, may be null
      * @return <code>true</code> if o has been loaded by the current classloader
      * or one of its descendants.
      */
-    private boolean isLoadedByThisWebappClassLoader(Object o) {
+    private boolean loadedByThisOrChild(Object o) {
         if (o == null) {
             return false;
         }
-        ClassLoader cl = o.getClass().getClassLoader();
+
+        Class<?> clazz;
+        if (o instanceof Class) {
+            clazz = (Class<?>) o;
+        } else {
+            clazz = o.getClass();
+        }
+
+        ClassLoader cl = clazz.getClassLoader();
         while (cl != null) {
             if(cl == this) {
                 return true;
@@ -2717,24 +2669,6 @@ public class WebappClassLoader
     }
 
 
-    /**
-     * Determine whether a class was loaded by this class loader or one of
-     * its child class loaders.
-     */
-    protected boolean loadedByThisOrChild(Class<? extends Object> clazz)
-    {
-        boolean result = false;
-        for (ClassLoader classLoader = clazz.getClassLoader();
-                null != classLoader; classLoader = classLoader.getParent()) {
-            if (classLoader.equals(this)) {
-                result = true;
-                break;
-            }
-        }
-        return result;
-    }    
-
-
     /**
      * Used to periodically signal to the classloader to release JAR resources.
      */

==================================================
Constants.java
index 9c8eab7d7f..0c920c136f 100644
--- a/java/org/apache/catalina/loader/WebappLoader.java
+++ b/java/org/apache/catalina/loader/WebappLoader.java
@@ -591,8 +591,6 @@ public class WebappLoader extends LifecycleMBeanBase
                         ((StandardContext) container).getClearReferencesStopThreads());
                 classLoader.setClearReferencesStopTimerThreads(
                         ((StandardContext) container).getClearReferencesStopTimerThreads());
-                classLoader.setClearReferencesThreadLocals(
-                        ((StandardContext) container).getClearReferencesThreadLocals());
             }
 
             for (int i = 0; i < repositories.length; i++) {

==================================================
TaskQueue.java
new file mode 100644
index 0000000000..b67afa5a8e
--- /dev/null
+++ b/java/org/apache/tomcat/util/threads/LocalStrings.properties
@@ -0,0 +1,16 @@
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+threadPoolExecutor.threadStoppedToAvoidPotentialLeak=Stopping thread {0} to avoid potential memory leaks after a context was stopped.

==================================================
TaskThread.java
index 8c8487e720..8ffd8b6980 100644
--- a/java/org/apache/tomcat/util/threads/TaskQueue.java
+++ b/java/org/apache/tomcat/util/threads/TaskQueue.java
@@ -34,6 +34,10 @@ public class TaskQueue extends LinkedBlockingQueue<Runnable> {
     private static final long serialVersionUID = 1L;
 
     private ThreadPoolExecutor parent = null;
+    
+    // no need to be volatile, the one times when we change and read it occur in
+    // a single thread (the one that did stop a context and fired listeners)
+    private Integer forcedRemainingCapacity = null;
 
     public TaskQueue() {
         super();
@@ -74,4 +78,44 @@ public class TaskQueue extends LinkedBlockingQueue<Runnable> {
         //if we reached here, we need to add it to the queue
         return super.offer(o);
     }
+
+
+    @Override
+    public Runnable poll(long timeout, TimeUnit unit) throws InterruptedException {
+        Runnable runnable = super.poll(timeout, unit);
+        if (runnable == null && parent != null) {
+            // the poll timed out, it gives an opportunity to stop the current
+            // thread if needed to avoid memory leaks.
+            parent.stopCurrentThreadIfNeeded();
+        }
+        return runnable;
+    }
+    
+
+    @Override
+    public Runnable take() throws InterruptedException {
+        if (parent != null && parent.currentThreadShouldBeStopped()) {
+            return poll(parent.getKeepAliveTime(TimeUnit.MILLISECONDS), TimeUnit.MILLISECONDS);
+            //yes, this may return null (in case of timeout) which normally does not occur with take()
+            //but the ThreadPoolExecutor implementation allows this
+        }
+        return super.take();
+    }
+
+    @Override
+    public int remainingCapacity() {
+        if(forcedRemainingCapacity != null) {
+            // ThreadPoolExecutor.setCorePoolSize checks that
+            // remainingCapacity==0 to allow to interrupt idle threads
+            // I don't see why, but this hack allows to conform to this
+            // "requirement"
+            return forcedRemainingCapacity.intValue();
+        }
+        return super.remainingCapacity();
+    }
+
+    public void setForcedRemainingCapacity(Integer forcedRemainingCapacity) {
+        this.forcedRemainingCapacity = forcedRemainingCapacity;
+    }
+
 }

==================================================
TaskThreadFactory.java
new file mode 100644
index 0000000000..84dc37530e
--- /dev/null
+++ b/java/org/apache/tomcat/util/threads/TaskThread.java
@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.util.threads;
+
+/**
+ * A Thread implementation that records the time at which it was created.
+ * 
+ * @author slaurent
+ * 
+ */
+public class TaskThread extends Thread {
+
+    private final long creationTime;
+
+    public TaskThread(ThreadGroup group, Runnable target, String name) {
+        super(group, target, name);
+        this.creationTime = System.currentTimeMillis();
+    }
+
+    public TaskThread(ThreadGroup group, Runnable target, String name,
+            long stackSize) {
+        super(group, target, name, stackSize);
+        this.creationTime = System.currentTimeMillis();
+    }
+
+    /**
+     * @return the time (in ms) at which this thread was created
+     */
+    public final long getCreationTime() {
+        return creationTime;
+    }
+
+}

==================================================
ThreadPoolExecutor.java
index 8ca548d3c7..59b87eec87 100644
--- a/java/org/apache/tomcat/util/threads/TaskThreadFactory.java
+++ b/java/org/apache/tomcat/util/threads/TaskThreadFactory.java
@@ -39,7 +39,7 @@ public class TaskThreadFactory implements ThreadFactory {
 
     @Override
     public Thread newThread(Runnable r) {
-        Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement());
+        TaskThread t = new TaskThread(group, r, namePrefix + threadNumber.getAndIncrement());
         t.setDaemon(daemon);
         t.setPriority(threadPriority);
         return t;

==================================================
