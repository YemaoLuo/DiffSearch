ac46a3544add83bcf7bad59b59a0510c66a9b71f
==================================================
Fix svn properties. Patch provided by sebb
==================================================
Mark Emlyn
==================================================
Thu Mar 4 21:20:59 2010 +0000
==================================================
EnclosingMethod.java
Fix svn properties. Patch provided by sebb

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@919188 13f79535-47bb-0310-9956-ffa450edef68



==================================================
LocalVariableTypeTable.java
old mode 100755
new mode 100644

==================================================
FileCleaningTracker.java
old mode 100755
new mode 100644

==================================================
FileItemHeaders.java
index 6b106b562b..df16f2ad19 100644
--- a/java/org/apache/tomcat/util/http/fileupload/FileCleaningTracker.java
+++ b/java/org/apache/tomcat/util/http/fileupload/FileCleaningTracker.java
@@ -1,259 +1,259 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.tomcat.util.http.fileupload;
-
-import java.io.File;
-import java.lang.ref.PhantomReference;
-import java.lang.ref.ReferenceQueue;
-import java.util.Collection;
-import java.util.Vector;
-
-/**
- * Keeps track of files awaiting deletion, and deletes them when an associated
- * marker object is reclaimed by the garbage collector.
- * <p>
- * This utility creates a background thread to handle file deletion.
- * Each file to be deleted is registered with a handler object.
- * When the handler object is garbage collected, the file is deleted.
- * <p>
- * In an environment with multiple class loaders (a servlet container, for
- * example), you should consider stopping the background thread if it is no
- * longer needed. This is done by invoking the method
- * {@link #exitWhenFinished}, typically in
- * {@link javax.servlet.ServletContextListener#contextDestroyed} or similar.
- *
- * @author Noel Bergman
- * @author Martin Cooper
- * @version $Id: FileCleaner.java 490987 2006-12-29 12:11:48Z scolebourne $
- */
-public class FileCleaningTracker {
-    /**
-     * Queue of <code>Tracker</code> instances being watched.
-     */
-    ReferenceQueue /* Tracker */ q = new ReferenceQueue();
-    /**
-     * Collection of <code>Tracker</code> instances in existence.
-     */
-    final Collection<Tracker> trackers = new Vector<Tracker>();  // synchronized
-    /**
-     * Whether to terminate the thread when the tracking is complete.
-     */
-    volatile boolean exitWhenFinished = false;
-    /**
-     * The thread that will clean up registered files.
-     */
-    Thread reaper;
-
-    //-----------------------------------------------------------------------
-    /**
-     * Track the specified file, using the provided marker, deleting the file
-     * when the marker instance is garbage collected.
-     * The {@link FileDeleteStrategy#NORMAL normal} deletion strategy will be used.
-     *
-     * @param file  the file to be tracked, not null
-     * @param marker  the marker object used to track the file, not null
-     * @throws NullPointerException if the file is null
-     */
-    public void track(File file, Object marker) {
-        track(file, marker, (FileDeleteStrategy) null);
-    }
-
-    /**
-     * Track the specified file, using the provided marker, deleting the file
-     * when the marker instance is garbage collected.
-     * The speified deletion strategy is used.
-     *
-     * @param file  the file to be tracked, not null
-     * @param marker  the marker object used to track the file, not null
-     * @param deleteStrategy  the strategy to delete the file, null means normal
-     * @throws NullPointerException if the file is null
-     */
-    public void track(File file, Object marker, FileDeleteStrategy deleteStrategy) {
-        if (file == null) {
-            throw new NullPointerException("The file must not be null");
-        }
-        addTracker(file.getPath(), marker, deleteStrategy);
-    }
-
-    /**
-     * Track the specified file, using the provided marker, deleting the file
-     * when the marker instance is garbage collected.
-     * The {@link FileDeleteStrategy#NORMAL normal} deletion strategy will be used.
-     *
-     * @param path  the full path to the file to be tracked, not null
-     * @param marker  the marker object used to track the file, not null
-     * @throws NullPointerException if the path is null
-     */
-    public void track(String path, Object marker) {
-        track(path, marker, (FileDeleteStrategy) null);
-    }
-
-    /**
-     * Track the specified file, using the provided marker, deleting the file
-     * when the marker instance is garbage collected.
-     * The speified deletion strategy is used.
-     *
-     * @param path  the full path to the file to be tracked, not null
-     * @param marker  the marker object used to track the file, not null
-     * @param deleteStrategy  the strategy to delete the file, null means normal
-     * @throws NullPointerException if the path is null
-     */
-    public void track(String path, Object marker, FileDeleteStrategy deleteStrategy) {
-        if (path == null) {
-            throw new NullPointerException("The path must not be null");
-        }
-        addTracker(path, marker, deleteStrategy);
-    }
-
-    /**
-     * Adds a tracker to the list of trackers.
-     * 
-     * @param path  the full path to the file to be tracked, not null
-     * @param marker  the marker object used to track the file, not null
-     * @param deleteStrategy  the strategy to delete the file, null means normal
-     */
-    private synchronized void addTracker(String path, Object marker, FileDeleteStrategy deleteStrategy) {
-        // synchronized block protects reaper
-        if (exitWhenFinished) {
-            throw new IllegalStateException("No new trackers can be added once exitWhenFinished() is called");
-        }
-        if (reaper == null) {
-            reaper = new Reaper();
-            reaper.start();
-        }
-        trackers.add(new Tracker(path, deleteStrategy, marker, q));
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Retrieve the number of files currently being tracked, and therefore
-     * awaiting deletion.
-     *
-     * @return the number of files being tracked
-     */
-    public int getTrackCount() {
-        return trackers.size();
-    }
-
-    /**
-     * Call this method to cause the file cleaner thread to terminate when
-     * there are no more objects being tracked for deletion.
-     * <p>
-     * In a simple environment, you don't need this method as the file cleaner
-     * thread will simply exit when the JVM exits. In a more complex environment,
-     * with multiple class loaders (such as an application server), you should be
-     * aware that the file cleaner thread will continue running even if the class
-     * loader it was started from terminates. This can consitute a memory leak.
-     * <p>
-     * For example, suppose that you have developed a web application, which
-     * contains the commons-io jar file in your WEB-INF/lib directory. In other
-     * words, the FileCleaner class is loaded through the class loader of your
-     * web application. If the web application is terminated, but the servlet
-     * container is still running, then the file cleaner thread will still exist,
-     * posing a memory leak.
-     * <p>
-     * This method allows the thread to be terminated. Simply call this method
-     * in the resource cleanup code, such as {@link javax.servlet.ServletContextListener#contextDestroyed}.
-     * One called, no new objects can be tracked by the file cleaner.
-     */
-    public synchronized void exitWhenFinished() {
-        // synchronized block protects reaper
-        exitWhenFinished = true;
-        if (reaper != null) {
-            synchronized (reaper) {
-                reaper.interrupt();
-            }
-        }
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * The reaper thread.
-     */
-    private final class Reaper extends Thread {
-        /** Construct a new Reaper */
-        Reaper() {
-            super("File Reaper");
-            setPriority(Thread.MAX_PRIORITY);
-            setDaemon(true);
-        }
-
-        /**
-         * Run the reaper thread that will delete files as their associated
-         * marker objects are reclaimed by the garbage collector.
-         */
-        @Override
-        public void run() {
-            // thread exits when exitWhenFinished is true and there are no more tracked objects
-            while (exitWhenFinished == false || trackers.size() > 0) {
-                Tracker tracker = null;
-                try {
-                    // Wait for a tracker to remove.
-                    tracker = (Tracker) q.remove();
-                } catch (Exception e) {
-                    continue;
-                }
-                if (tracker != null) {
-                    tracker.delete();
-                    tracker.clear();
-                    trackers.remove(tracker);
-                }
-            }
-        }
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Inner class which acts as the reference for a file pending deletion.
-     */
-    private static final class Tracker extends PhantomReference {
-
-        /**
-         * The full path to the file being tracked.
-         */
-        private final String path;
-        /**
-         * The strategy for deleting files.
-         */
-        private final FileDeleteStrategy deleteStrategy;
-
-        /**
-         * Constructs an instance of this class from the supplied parameters.
-         *
-         * @param path  the full path to the file to be tracked, not null
-         * @param deleteStrategy  the strategy to delete the file, null means normal
-         * @param marker  the marker object used to track the file, not null
-         * @param queue  the queue on to which the tracker will be pushed, not null
-         */
-        Tracker(String path, FileDeleteStrategy deleteStrategy, Object marker, ReferenceQueue queue) {
-            super(marker, queue);
-            this.path = path;
-            this.deleteStrategy = (deleteStrategy == null ? FileDeleteStrategy.NORMAL : deleteStrategy);
-        }
-
-        /**
-         * Deletes the file associated with this tracker instance.
-         *
-         * @return <code>true</code> if the file was deleted successfully;
-         *         <code>false</code> otherwise.
-         */
-        public boolean delete() {
-            return deleteStrategy.deleteQuietly(new File(path));
-        }
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.util.http.fileupload;
+
+import java.io.File;
+import java.lang.ref.PhantomReference;
+import java.lang.ref.ReferenceQueue;
+import java.util.Collection;
+import java.util.Vector;
+
+/**
+ * Keeps track of files awaiting deletion, and deletes them when an associated
+ * marker object is reclaimed by the garbage collector.
+ * <p>
+ * This utility creates a background thread to handle file deletion.
+ * Each file to be deleted is registered with a handler object.
+ * When the handler object is garbage collected, the file is deleted.
+ * <p>
+ * In an environment with multiple class loaders (a servlet container, for
+ * example), you should consider stopping the background thread if it is no
+ * longer needed. This is done by invoking the method
+ * {@link #exitWhenFinished}, typically in
+ * {@link javax.servlet.ServletContextListener#contextDestroyed} or similar.
+ *
+ * @author Noel Bergman
+ * @author Martin Cooper
+ * @version $Id: FileCleaner.java 490987 2006-12-29 12:11:48Z scolebourne $
+ */
+public class FileCleaningTracker {
+    /**
+     * Queue of <code>Tracker</code> instances being watched.
+     */
+    ReferenceQueue /* Tracker */ q = new ReferenceQueue();
+    /**
+     * Collection of <code>Tracker</code> instances in existence.
+     */
+    final Collection<Tracker> trackers = new Vector<Tracker>();  // synchronized
+    /**
+     * Whether to terminate the thread when the tracking is complete.
+     */
+    volatile boolean exitWhenFinished = false;
+    /**
+     * The thread that will clean up registered files.
+     */
+    Thread reaper;
+
+    //-----------------------------------------------------------------------
+    /**
+     * Track the specified file, using the provided marker, deleting the file
+     * when the marker instance is garbage collected.
+     * The {@link FileDeleteStrategy#NORMAL normal} deletion strategy will be used.
+     *
+     * @param file  the file to be tracked, not null
+     * @param marker  the marker object used to track the file, not null
+     * @throws NullPointerException if the file is null
+     */
+    public void track(File file, Object marker) {
+        track(file, marker, (FileDeleteStrategy) null);
+    }
+
+    /**
+     * Track the specified file, using the provided marker, deleting the file
+     * when the marker instance is garbage collected.
+     * The speified deletion strategy is used.
+     *
+     * @param file  the file to be tracked, not null
+     * @param marker  the marker object used to track the file, not null
+     * @param deleteStrategy  the strategy to delete the file, null means normal
+     * @throws NullPointerException if the file is null
+     */
+    public void track(File file, Object marker, FileDeleteStrategy deleteStrategy) {
+        if (file == null) {
+            throw new NullPointerException("The file must not be null");
+        }
+        addTracker(file.getPath(), marker, deleteStrategy);
+    }
+
+    /**
+     * Track the specified file, using the provided marker, deleting the file
+     * when the marker instance is garbage collected.
+     * The {@link FileDeleteStrategy#NORMAL normal} deletion strategy will be used.
+     *
+     * @param path  the full path to the file to be tracked, not null
+     * @param marker  the marker object used to track the file, not null
+     * @throws NullPointerException if the path is null
+     */
+    public void track(String path, Object marker) {
+        track(path, marker, (FileDeleteStrategy) null);
+    }
+
+    /**
+     * Track the specified file, using the provided marker, deleting the file
+     * when the marker instance is garbage collected.
+     * The speified deletion strategy is used.
+     *
+     * @param path  the full path to the file to be tracked, not null
+     * @param marker  the marker object used to track the file, not null
+     * @param deleteStrategy  the strategy to delete the file, null means normal
+     * @throws NullPointerException if the path is null
+     */
+    public void track(String path, Object marker, FileDeleteStrategy deleteStrategy) {
+        if (path == null) {
+            throw new NullPointerException("The path must not be null");
+        }
+        addTracker(path, marker, deleteStrategy);
+    }
+
+    /**
+     * Adds a tracker to the list of trackers.
+     * 
+     * @param path  the full path to the file to be tracked, not null
+     * @param marker  the marker object used to track the file, not null
+     * @param deleteStrategy  the strategy to delete the file, null means normal
+     */
+    private synchronized void addTracker(String path, Object marker, FileDeleteStrategy deleteStrategy) {
+        // synchronized block protects reaper
+        if (exitWhenFinished) {
+            throw new IllegalStateException("No new trackers can be added once exitWhenFinished() is called");
+        }
+        if (reaper == null) {
+            reaper = new Reaper();
+            reaper.start();
+        }
+        trackers.add(new Tracker(path, deleteStrategy, marker, q));
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Retrieve the number of files currently being tracked, and therefore
+     * awaiting deletion.
+     *
+     * @return the number of files being tracked
+     */
+    public int getTrackCount() {
+        return trackers.size();
+    }
+
+    /**
+     * Call this method to cause the file cleaner thread to terminate when
+     * there are no more objects being tracked for deletion.
+     * <p>
+     * In a simple environment, you don't need this method as the file cleaner
+     * thread will simply exit when the JVM exits. In a more complex environment,
+     * with multiple class loaders (such as an application server), you should be
+     * aware that the file cleaner thread will continue running even if the class
+     * loader it was started from terminates. This can consitute a memory leak.
+     * <p>
+     * For example, suppose that you have developed a web application, which
+     * contains the commons-io jar file in your WEB-INF/lib directory. In other
+     * words, the FileCleaner class is loaded through the class loader of your
+     * web application. If the web application is terminated, but the servlet
+     * container is still running, then the file cleaner thread will still exist,
+     * posing a memory leak.
+     * <p>
+     * This method allows the thread to be terminated. Simply call this method
+     * in the resource cleanup code, such as {@link javax.servlet.ServletContextListener#contextDestroyed}.
+     * One called, no new objects can be tracked by the file cleaner.
+     */
+    public synchronized void exitWhenFinished() {
+        // synchronized block protects reaper
+        exitWhenFinished = true;
+        if (reaper != null) {
+            synchronized (reaper) {
+                reaper.interrupt();
+            }
+        }
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * The reaper thread.
+     */
+    private final class Reaper extends Thread {
+        /** Construct a new Reaper */
+        Reaper() {
+            super("File Reaper");
+            setPriority(Thread.MAX_PRIORITY);
+            setDaemon(true);
+        }
+
+        /**
+         * Run the reaper thread that will delete files as their associated
+         * marker objects are reclaimed by the garbage collector.
+         */
+        @Override
+        public void run() {
+            // thread exits when exitWhenFinished is true and there are no more tracked objects
+            while (exitWhenFinished == false || trackers.size() > 0) {
+                Tracker tracker = null;
+                try {
+                    // Wait for a tracker to remove.
+                    tracker = (Tracker) q.remove();
+                } catch (Exception e) {
+                    continue;
+                }
+                if (tracker != null) {
+                    tracker.delete();
+                    tracker.clear();
+                    trackers.remove(tracker);
+                }
+            }
+        }
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Inner class which acts as the reference for a file pending deletion.
+     */
+    private static final class Tracker extends PhantomReference {
+
+        /**
+         * The full path to the file being tracked.
+         */
+        private final String path;
+        /**
+         * The strategy for deleting files.
+         */
+        private final FileDeleteStrategy deleteStrategy;
+
+        /**
+         * Constructs an instance of this class from the supplied parameters.
+         *
+         * @param path  the full path to the file to be tracked, not null
+         * @param deleteStrategy  the strategy to delete the file, null means normal
+         * @param marker  the marker object used to track the file, not null
+         * @param queue  the queue on to which the tracker will be pushed, not null
+         */
+        Tracker(String path, FileDeleteStrategy deleteStrategy, Object marker, ReferenceQueue queue) {
+            super(marker, queue);
+            this.path = path;
+            this.deleteStrategy = (deleteStrategy == null ? FileDeleteStrategy.NORMAL : deleteStrategy);
+        }
+
+        /**
+         * Deletes the file associated with this tracker instance.
+         *
+         * @return <code>true</code> if the file was deleted successfully;
+         *         <code>false</code> otherwise.
+         */
+        public boolean delete() {
+            return deleteStrategy.deleteQuietly(new File(path));
+        }
+    }
+
+}

==================================================
FileItemHeadersSupport.java
index 87c5f0a9d4..429b43818e 100644
--- a/java/org/apache/tomcat/util/http/fileupload/FileItemHeaders.java
+++ b/java/org/apache/tomcat/util/http/fileupload/FileItemHeaders.java
@@ -1,77 +1,77 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.tomcat.util.http.fileupload;
-
-import java.util.Iterator;
-
-/**
- * <p> This class provides support for accessing the headers for a file or form
- * item that was received within a <code>multipart/form-data</code> POST
- * request.</p>
- *
- * @author Michael C. Macaluso
- * @since 1.3
- */
-public interface FileItemHeaders {
-    /**
-     * Returns the value of the specified part header as a <code>String</code>.
-     * If the part did not include a header of the specified name, this method
-     * return <code>null</code>.  If there are multiple headers with the same
-     * name, this method returns the first header in the item.  The header
-     * name is case insensitive.
-     *
-     * @param name a <code>String</code> specifying the header name
-     * @return a <code>String</code> containing the value of the requested
-     *         header, or <code>null</code> if the item does not have a header
-     *         of that name
-     */
-    String getHeader(String name);
-
-    /**
-     * <p>
-     * Returns all the values of the specified item header as an
-     * <code>Enumeration</code> of <code>String</code> objects.
-     * </p>
-     * <p>
-     * If the item did not include any headers of the specified name, this
-     * method returns an empty <code>Enumeration</code>. The header name is
-     * case insensitive.
-     * </p>
-     *
-     * @param name a <code>String</code> specifying the header name
-     * @return an <code>Enumeration</code> containing the values of the
-     *         requested header. If the item does not have any headers of
-     *         that name, return an empty <code>Enumeration</code>
-     */
-    Iterator<String> getHeaders(String name);
-
-    /**
-     * <p>
-     * Returns an <code>Enumeration</code> of all the header names.
-     * </p>
-     * <p>
-     * If the item did not include any headers of the specified name, this
-     * method returns an empty <code>Enumeration</code>. The header name is
-     * case insensitive.
-     * </p>
-     *
-     * @return an <code>Enumeration</code> containing the values of the
-     *         requested header. If the item does not have any headers of
-     *         that name return an empty <code>Enumeration</code>
-     */
-    Iterator<String> getHeaderNames();
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.util.http.fileupload;
+
+import java.util.Iterator;
+
+/**
+ * <p> This class provides support for accessing the headers for a file or form
+ * item that was received within a <code>multipart/form-data</code> POST
+ * request.</p>
+ *
+ * @author Michael C. Macaluso
+ * @since 1.3
+ */
+public interface FileItemHeaders {
+    /**
+     * Returns the value of the specified part header as a <code>String</code>.
+     * If the part did not include a header of the specified name, this method
+     * return <code>null</code>.  If there are multiple headers with the same
+     * name, this method returns the first header in the item.  The header
+     * name is case insensitive.
+     *
+     * @param name a <code>String</code> specifying the header name
+     * @return a <code>String</code> containing the value of the requested
+     *         header, or <code>null</code> if the item does not have a header
+     *         of that name
+     */
+    String getHeader(String name);
+
+    /**
+     * <p>
+     * Returns all the values of the specified item header as an
+     * <code>Enumeration</code> of <code>String</code> objects.
+     * </p>
+     * <p>
+     * If the item did not include any headers of the specified name, this
+     * method returns an empty <code>Enumeration</code>. The header name is
+     * case insensitive.
+     * </p>
+     *
+     * @param name a <code>String</code> specifying the header name
+     * @return an <code>Enumeration</code> containing the values of the
+     *         requested header. If the item does not have any headers of
+     *         that name, return an empty <code>Enumeration</code>
+     */
+    Iterator<String> getHeaders(String name);
+
+    /**
+     * <p>
+     * Returns an <code>Enumeration</code> of all the header names.
+     * </p>
+     * <p>
+     * If the item did not include any headers of the specified name, this
+     * method returns an empty <code>Enumeration</code>. The header name is
+     * case insensitive.
+     * </p>
+     *
+     * @return an <code>Enumeration</code> containing the values of the
+     *         requested header. If the item does not have any headers of
+     *         that name return an empty <code>Enumeration</code>
+     */
+    Iterator<String> getHeaderNames();
+}

==================================================
