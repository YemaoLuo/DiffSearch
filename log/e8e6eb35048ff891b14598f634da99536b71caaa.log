e8e6eb35048ff891b14598f634da99536b71caaa
==================================================
First pass at cleaning up timeouts.
==================================================
Mark Thomas
==================================================
Thu Jan 29 19:11:47 2015 +0000
==================================================
AjpProcessor.java
First pass at cleaning up timeouts.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1655807 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AbstractHttp11Processor.java
index 9000ae358d..d443c083da 100644
--- a/java/org/apache/coyote/ajp/AjpProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpProcessor.java
@@ -683,7 +683,7 @@ public class AjpProcessor<S> extends AbstractProcessor<S> {
         } else {
             // Set keep alive timeout for next request if enabled
             if (keepAliveTimeout > 0) {
-                socketWrapper.setTimeout(keepAliveTimeout);
+                socketWrapper.setReadTimeout(keepAliveTimeout);
             }
             request.updateCounters();
             if (getErrorState().isError()) {
@@ -724,7 +724,7 @@ public class AjpProcessor<S> extends AbstractProcessor<S> {
                 }
                 // Set back timeout if keep alive timeout is enabled
                 if (keepAliveTimeout > 0) {
-                    socketWrapper.setTimeout(soTimeout);
+                    socketWrapper.setReadTimeout(soTimeout);
                 }
                 // Check message type, process right away and break if
                 // not regular request processing
@@ -830,7 +830,7 @@ public class AjpProcessor<S> extends AbstractProcessor<S> {
             rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);
             // Set keep alive timeout for next request if enabled
             if (keepAliveTimeout > 0) {
-                socketWrapper.setTimeout(keepAliveTimeout);
+                socketWrapper.setReadTimeout(keepAliveTimeout);
             }
 
             recycle();
@@ -1534,9 +1534,6 @@ public class AjpProcessor<S> extends AbstractProcessor<S> {
 
 
     private void writeData(ByteChunk chunk) throws IOException {
-        // Prevent timeout
-        socketWrapper.access();
-
         boolean blocking = (response.getWriteListener() == null);
 
         int len = chunk.getLength();

==================================================
Http11AprProcessor.java
index 54950965fd..7722dc2288 100644
--- a/java/org/apache/coyote/http11/AbstractHttp11Processor.java
+++ b/java/org/apache/coyote/http11/AbstractHttp11Processor.java
@@ -944,12 +944,6 @@ public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
     abstract void actionInternal(ActionCode actionCode, Object param);
 
 
-    /**
-     * Set the socket timeout.
-     */
-    protected abstract void setSocketTimeout(int timeout) throws IOException;
-
-
     /**
      * Process pipelined HTTP requests using the specified input and output
      * streams.
@@ -1004,7 +998,7 @@ public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
                         break;
                     }
                     if (!disableUploadTimeout) {
-                        setSocketTimeout(connectionUploadTimeout);
+                        socketWrapper.setReadTimeout(connectionUploadTimeout);
                     }
                 }
             } catch (IOException e) {
@@ -1140,9 +1134,9 @@ public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
             if (!disableUploadTimeout) {
                 int soTimeout = endpoint.getSoTimeout();
                 if(soTimeout > 0) {
-                    setSocketTimeout(soTimeout);
+                    socketWrapper.setReadTimeout(soTimeout);
                 } else {
-                    setSocketTimeout(0);
+                    socketWrapper.setReadTimeout(0);
                 }
             }
 
@@ -1188,7 +1182,7 @@ public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
             if (keptAlive) {
                 // Haven't read the request line and have previously processed a
                 // request. Must be keep-alive. Make sure poller uses keepAlive.
-                socketWrapper.setTimeout(endpoint.getKeepAliveTimeout());
+                socketWrapper.setReadTimeout(endpoint.getKeepAliveTimeout());
             }
         } else {
             // Started to read request line.
@@ -1205,7 +1199,7 @@ public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
                 // Need to keep processor associated with socket
                 readComplete = false;
                 // Make sure poller uses soTimeout from here onwards
-                socketWrapper.setTimeout(endpoint.getSoTimeout());
+                socketWrapper.setReadTimeout(endpoint.getSoTimeout());
             }
         }
         return true;

==================================================
Http11Nio2Processor.java
index 1d8fe369a8..d7f49929d9 100644
--- a/java/org/apache/coyote/http11/Http11AprProcessor.java
+++ b/java/org/apache/coyote/http11/Http11AprProcessor.java
@@ -74,12 +74,6 @@ public class Http11AprProcessor extends AbstractHttp11Processor<Long> {
 
     // --------------------------------------------------------- Public Methods
 
-    @Override
-    protected void setSocketTimeout(int timeout) {
-        Socket.timeoutSet(socketWrapper.getSocket().longValue(), timeout * 1000);
-    }
-
-
     @Override
     protected void resetTimeouts() {
         // NO-OP for APR
@@ -91,8 +85,8 @@ public class Http11AprProcessor extends AbstractHttp11Processor<Long> {
         // NOOP for APR
     }
 
-    // ----------------------------------------------------- ActionHook Methods
 
+    // ----------------------------------------------------- ActionHook Methods
 
     /**
      * Send an action to the connector.

==================================================
Http11NioProcessor.java
index 2e14909c27..991f72dd69 100644
--- a/java/org/apache/coyote/http11/Http11Nio2Processor.java
+++ b/java/org/apache/coyote/http11/Http11Nio2Processor.java
@@ -82,20 +82,14 @@ public class Http11Nio2Processor extends AbstractHttp11Processor<Nio2Channel> {
 
             // Reset the timeout
             if (keepAlive) {
-                socketWrapper.setTimeout(endpoint.getKeepAliveTimeout());
+                socketWrapper.setReadTimeout(endpoint.getKeepAliveTimeout());
             } else {
-                socketWrapper.setTimeout(endpoint.getSoTimeout());
+                socketWrapper.setReadTimeout(endpoint.getSoTimeout());
             }
         }
     }
 
 
-    @Override
-    protected void setSocketTimeout(int timeout) throws IOException {
-        socketWrapper.setTimeout(timeout);
-    }
-
-
     // ----------------------------------------------------- ActionHook Methods
 
     /**

==================================================
UpgradeProcessor.java
index 76e3f0f0b4..ef8f90a2dd 100644
--- a/java/org/apache/coyote/http11/Http11NioProcessor.java
+++ b/java/org/apache/coyote/http11/Http11NioProcessor.java
@@ -64,26 +64,21 @@ public class Http11NioProcessor extends AbstractHttp11Processor<NioChannel> {
 
     @Override
     protected void resetTimeouts() {
-        final NioEndpoint.NioSocketWrapper attach = (NioEndpoint.NioSocketWrapper)socketWrapper.getSocket().getAttachment();
+        final NioEndpoint.NioSocketWrapper attach =
+                (NioEndpoint.NioSocketWrapper)socketWrapper.getSocket().getAttachment();
         if (!getErrorState().isError() && attach != null &&
                 asyncStateMachine.isAsyncDispatching()) {
 
             // Reset the timeout
             if (keepAlive) {
-                attach.setTimeout(endpoint.getKeepAliveTimeout());
+                attach.setReadTimeout(endpoint.getKeepAliveTimeout());
             } else {
-                attach.setTimeout(endpoint.getSoTimeout());
+                attach.setReadTimeout(endpoint.getSoTimeout());
             }
         }
     }
 
 
-    @Override
-    protected void setSocketTimeout(int timeout) throws IOException {
-        socketWrapper.getSocket().getIOChannel().socket().setSoTimeout(timeout);
-    }
-
-
     // ----------------------------------------------------- ActionHook Methods
 
     /**

==================================================
AprEndpoint.java
index 9abf38de7f..71ad47d10e 100644
--- a/java/org/apache/coyote/http11/upgrade/UpgradeProcessor.java
+++ b/java/org/apache/coyote/http11/upgrade/UpgradeProcessor.java
@@ -54,7 +54,7 @@ public class UpgradeProcessor<S> implements Processor<S>, WebConnection {
         this.upgradeServletOutputStream = new UpgradeServletOutputStream(wrapper);
 
         wrapper.unRead(leftOverInput);
-        wrapper.setTimeout(INFINITE_TIMEOUT);
+        wrapper.setReadTimeout(INFINITE_TIMEOUT);
     }
 
 

==================================================
Nio2Endpoint.java
index daae59f93b..e03132277f 100644
--- a/java/org/apache/tomcat/util/net/AprEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AprEndpoint.java
@@ -2391,16 +2391,6 @@ public class AprEndpoint extends AbstractEndpoint<Long> {
         }
 
 
-        // TODO Can this be removed once all reads and writes are handled within
-        // this class?
-        @Override
-        public void setTimeout(long timeout) {
-            super.setTimeout(timeout);
-            Socket.timeoutSet(getSocket().longValue(), timeout * 1000);
-        }
-
-
-
         @Override
         public int read(boolean block, byte[] b, int off, int len) throws IOException {
 
@@ -2429,6 +2419,9 @@ public class AprEndpoint extends AbstractEndpoint<Long> {
             readLock.lock();
             try {
                 if (getBlockingStatus() == block) {
+                    if (block) {
+                        Socket.timeoutSet(getSocket().longValue(), getReadTimeout() * 1000);
+                    }
                     result = Socket.recv(getSocket().longValue(), b, off, len);
                     readDone = true;
                 }
@@ -2439,9 +2432,13 @@ public class AprEndpoint extends AbstractEndpoint<Long> {
             if (!readDone) {
                 writeLock.lock();
                 try {
-                    setBlockingStatus(block);
                     // Set the current settings for this socket
-                    Socket.optSet(getSocket().longValue(), Socket.APR_SO_NONBLOCK, (block ? 0 : 1));
+                    setBlockingStatus(block);
+                    if (block) {
+                        Socket.timeoutSet(getSocket().longValue(), getReadTimeout() * 1000);
+                    } else {
+                        Socket.timeoutSet(getSocket().longValue(), 0);
+                    }
                     // Downgrade the lock
                     readLock.lock();
                     try {
@@ -2525,7 +2522,7 @@ public class AprEndpoint extends AbstractEndpoint<Long> {
 
 
         @Override
-        protected void doWrite(boolean block) throws IOException {
+        protected void doWriteInternal(boolean block) throws IOException {
             if (closed) {
                 throw new IOException(sm.getString("apr.closed", getSocket()));
             }
@@ -2536,6 +2533,9 @@ public class AprEndpoint extends AbstractEndpoint<Long> {
             readLock.lock();
             try {
                 if (getBlockingStatus() == block) {
+                    if (block) {
+                        Socket.timeoutSet(getSocket().longValue(), getWriteTimeout() * 1000);
+                    }
                     doWriteInternal();
                 }
             } finally {
@@ -2547,7 +2547,7 @@ public class AprEndpoint extends AbstractEndpoint<Long> {
                 // Set the current settings for this socket
                 setBlockingStatus(block);
                 if (block) {
-                    Socket.timeoutSet(getSocket().longValue(), getEndpoint().getSoTimeout() * 1000);
+                    Socket.timeoutSet(getSocket().longValue(), getWriteTimeout() * 1000);
                 } else {
                     Socket.timeoutSet(getSocket().longValue(), 0);
                 }

==================================================
NioBlockingSelector.java
index 046037eb30..d1a181de05 100644
--- a/java/org/apache/tomcat/util/net/Nio2Endpoint.java
+++ b/java/org/apache/tomcat/util/net/Nio2Endpoint.java
@@ -814,13 +814,14 @@ public class Nio2Endpoint extends AbstractEndpoint<Nio2Channel> {
                             Nio2SocketWrapper.this.bufferedWrites.clear();
                             ByteBuffer[] array = arrayList.toArray(new ByteBuffer[arrayList.size()]);
                             Nio2SocketWrapper.this.getSocket().write(array, 0, array.length,
-                                    Nio2SocketWrapper.this.getTimeout(), TimeUnit.MILLISECONDS,
+                                    Nio2SocketWrapper.this.getNio2WriteTimeout(), TimeUnit.MILLISECONDS,
                                     array, gatheringWriteCompletionHandler);
                             nestedWriteCompletionCount.get().decrementAndGet();
                         } else if (attachment.hasRemaining()) {
                             // Regular write
                             nestedWriteCompletionCount.get().incrementAndGet();
-                            Nio2SocketWrapper.this.getSocket().write(attachment, Nio2SocketWrapper.this.getTimeout(),
+                            Nio2SocketWrapper.this.getSocket().write(attachment,
+                                    Nio2SocketWrapper.this.getNio2WriteTimeout(),
                                     TimeUnit.MILLISECONDS, attachment, writeCompletionHandler);
                             nestedWriteCompletionCount.get().decrementAndGet();
                         } else {
@@ -874,7 +875,7 @@ public class Nio2Endpoint extends AbstractEndpoint<Nio2Channel> {
                             Nio2SocketWrapper.this.bufferedWrites.clear();
                             ByteBuffer[] array = arrayList.toArray(new ByteBuffer[arrayList.size()]);
                             Nio2SocketWrapper.this.getSocket().write(array, 0, array.length,
-                                    Nio2SocketWrapper.this.getTimeout(), TimeUnit.MILLISECONDS,
+                                    Nio2SocketWrapper.this.getNio2WriteTimeout(), TimeUnit.MILLISECONDS,
                                     array, gatheringWriteCompletionHandler);
                             nestedWriteCompletionCount.get().decrementAndGet();
                         } else {
@@ -933,12 +934,6 @@ public class Nio2Endpoint extends AbstractEndpoint<Nio2Channel> {
             }
         }
 
-        @Override
-        public long getTimeout() {
-            long timeout = super.getTimeout();
-            return (timeout > 0) ? timeout : Long.MAX_VALUE;
-        }
-
         @Override
         public void setUpgraded(boolean upgraded) {
             if (upgraded && !isUpgraded()) {
@@ -1090,7 +1085,7 @@ public class Nio2Endpoint extends AbstractEndpoint<Nio2Channel> {
             if (block) {
                 try {
                     nRead = getSocket().read(socketBufferHandler.getReadBuffer()).get(
-                            getTimeout(), TimeUnit.MILLISECONDS).intValue();
+                            getNio2ReadTimeout(), TimeUnit.MILLISECONDS).intValue();
                     readPending.release();
                 } catch (ExecutionException e) {
                     if (e.getCause() instanceof IOException) {
@@ -1106,8 +1101,8 @@ public class Nio2Endpoint extends AbstractEndpoint<Nio2Channel> {
                 }
             } else {
                 Nio2Endpoint.startInline();
-                getSocket().read(socketBufferHandler.getReadBuffer(), getTimeout(), TimeUnit.MILLISECONDS,
-                        this, readCompletionHandler);
+                getSocket().read(socketBufferHandler.getReadBuffer(), getNio2ReadTimeout(),
+                        TimeUnit.MILLISECONDS, this, readCompletionHandler);
                 Nio2Endpoint.endInline();
                 if (readPending.availablePermits() == 1) {
                     nRead = socketBufferHandler.getReadBuffer().position();
@@ -1159,12 +1154,12 @@ public class Nio2Endpoint extends AbstractEndpoint<Nio2Channel> {
          *              blocking case
          */
         @Override
-        protected void doWrite(boolean block) throws IOException {
+        protected void doWriteInternal(boolean block) throws IOException {
             try {
                 socketBufferHandler.configureWriteBufferForRead();
                 do {
-                    if (getSocket().write(socketBufferHandler.getWriteBuffer()).get(getTimeout(),
-                            TimeUnit.MILLISECONDS).intValue() < 0) {
+                    if (getSocket().write(socketBufferHandler.getWriteBuffer()).get(
+                            getNio2WriteTimeout(), TimeUnit.MILLISECONDS).intValue() < 0) {
                         throw new EOFException(sm.getString("iob.failedwrite"));
                     }
                 } while (socketBufferHandler.getWriteBuffer().hasRemaining());
@@ -1187,7 +1182,7 @@ public class Nio2Endpoint extends AbstractEndpoint<Nio2Channel> {
             // Before doing a blocking flush, make sure that any pending non
             // blocking write has completed.
             try {
-                if (writePending.tryAcquire(getTimeout(), TimeUnit.MILLISECONDS)) {
+                if (writePending.tryAcquire(getNio2WriteTimeout(), TimeUnit.MILLISECONDS)) {
                     writePending.release();
                 } else {
                     throw new SocketTimeoutException();
@@ -1221,13 +1216,13 @@ public class Nio2Endpoint extends AbstractEndpoint<Nio2Channel> {
                         bufferedWrites.clear();
                         ByteBuffer[] array = arrayList.toArray(new ByteBuffer[arrayList.size()]);
                         Nio2Endpoint.startInline();
-                        getSocket().write(array, 0, array.length, getTimeout(),
+                        getSocket().write(array, 0, array.length, getNio2WriteTimeout(),
                                 TimeUnit.MILLISECONDS, array, gatheringWriteCompletionHandler);
                         Nio2Endpoint.endInline();
                     } else if (socketBufferHandler.getWriteBuffer().hasRemaining()) {
                         // Regular write
                         Nio2Endpoint.startInline();
-                        getSocket().write(socketBufferHandler.getWriteBuffer(), getTimeout(),
+                        getSocket().write(socketBufferHandler.getWriteBuffer(), getNio2WriteTimeout(),
                                 TimeUnit.MILLISECONDS, socketBufferHandler.getWriteBuffer(),
                                 writeCompletionHandler);
                         Nio2Endpoint.endInline();
@@ -1294,7 +1289,7 @@ public class Nio2Endpoint extends AbstractEndpoint<Nio2Channel> {
                 getSocket().getBufHandler().configureReadBufferForWrite();
                 Nio2Endpoint.startInline();
                 getSocket().read(getSocket().getBufHandler().getReadBuffer(),
-                        getTimeout(), TimeUnit.MILLISECONDS, this, awaitBytesHandler);
+                        getNio2ReadTimeout(), TimeUnit.MILLISECONDS, this, awaitBytesHandler);
                 Nio2Endpoint.endInline();
             }
         }
@@ -1313,6 +1308,26 @@ public class Nio2Endpoint extends AbstractEndpoint<Nio2Channel> {
         }
 
 
+        private long getNio2ReadTimeout() {
+            long readTimeout = getReadTimeout();
+            if (readTimeout > 0) {
+                return readTimeout;
+            }
+            // NIO2 can't do infinite timeout so use Long.MAX_VALUE
+            return Long.MAX_VALUE;
+        }
+
+
+        private long getNio2WriteTimeout() {
+            long writeTimeout = getWriteTimeout();
+            if (writeTimeout > 0) {
+                return writeTimeout;
+            }
+            // NIO2 can't do infinite timeout so use Long.MAX_VALUE
+            return Long.MAX_VALUE;
+        }
+
+
         @Override
         protected void populateRemoteAddr() {
             SocketAddress socketAddress = null;
@@ -1495,8 +1510,9 @@ public class Nio2Endpoint extends AbstractEndpoint<Nio2Channel> {
                     }
                 }
             }
-            attachment.socket.getSocket().write(attachment.buffer, attachment.socket.getTimeout(),
-                    TimeUnit.MILLISECONDS, attachment, this);
+            attachment.socket.getSocket().write(attachment.buffer,
+                    attachment.socket.getNio2WriteTimeout(), TimeUnit.MILLISECONDS,
+                    attachment, this);
         }
 
         @Override
@@ -1543,7 +1559,7 @@ public class Nio2Endpoint extends AbstractEndpoint<Nio2Channel> {
             data.length -= nRead;
             socket.getSocket().getBufHandler().configureWriteBufferForRead();
             Nio2Endpoint.startInline();
-            socket.getSocket().write(buffer, socket.getTimeout(), TimeUnit.MILLISECONDS,
+            socket.getSocket().write(buffer, socket.getNio2WriteTimeout(), TimeUnit.MILLISECONDS,
                     data, sendfile);
             Nio2Endpoint.endInline();
             if (data.doneInline) {

==================================================
NioEndpoint.java
index 3a5b04e7bc..737ff23a28 100644
--- a/java/org/apache/tomcat/util/net/NioBlockingSelector.java
+++ b/java/org/apache/tomcat/util/net/NioBlockingSelector.java
@@ -366,7 +366,6 @@ public class NioBlockingSelector {
                         SelectionKey sk = iterator.next();
                         NioSocketWrapper attachment = (NioSocketWrapper)sk.attachment();
                         try {
-                            attachment.access();
                             iterator.remove();
                             sk.interestOps(sk.interestOps() & (~sk.readyOps()));
                             if ( sk.isReadable() ) {

==================================================
SocketWrapperBase.java
index 17c9f45c4e..09db4d5e36 100644
--- a/java/org/apache/tomcat/util/net/NioEndpoint.java
+++ b/java/org/apache/tomcat/util/net/NioEndpoint.java
@@ -772,7 +772,6 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
                     if (key != null) {
                         final NioSocketWrapper att = (NioSocketWrapper) key.attachment();
                         if ( att!=null ) {
-                            att.access();//to prevent timeout
                             //we are registering the key to start with, reset the fairness counter.
                             int ops = key.interestOps() | interestOps;
                             att.interestOps(ops);
@@ -1026,7 +1025,6 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
                         if (attachment == null) {
                             iterator.remove();
                         } else {
-                            attachment.access();
                             iterator.remove();
                             processKey(sk, attachment);
                         }
@@ -1059,7 +1057,6 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
                 if ( close ) {
                     cancelledKey(sk);
                 } else if ( sk.isValid() && attachment != null ) {
-                    attachment.access();//make sure we don't time out valid sockets
                     if (sk.isReadable() || sk.isWritable() ) {
                         if ( attachment.getSendfileData() != null ) {
                             processSendfile(sk,attachment, false);
@@ -1128,14 +1125,14 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
                 // We still have data in the buffer
                 if (sc.getOutboundRemaining()>0) {
                     if (sc.flushOutbound()) {
-                        socketWrapper.access();
+                        socketWrapper.updateLastWrite();
                     }
                 } else {
                     long written = sd.fchannel.transferTo(sd.pos,sd.length,wc);
                     if (written > 0) {
                         sd.pos += written;
                         sd.length -= written;
-                        socketWrapper.access();
+                        socketWrapper.updateLastWrite();
                     } else {
                         // Unusual not to be able to transfer any bytes
                         // Check the length was set correctly
@@ -1229,18 +1226,29 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
                         cancelledKey(key);//TODO this is not yet being used
                     } else if ((ka.interestOps()&SelectionKey.OP_READ) == SelectionKey.OP_READ ||
                               (ka.interestOps()&SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE) {
-                        //only timeout sockets that we are waiting for a read from
-                        long delta = now - ka.getLastAccess();
-                        long timeout = ka.getTimeout();
-                        boolean isTimedout = timeout > 0 && delta > timeout;
-                        if ( close ) {
+                        if (close) {
                             key.interestOps(0);
                             ka.interestOps(0); //avoid duplicate stop calls
                             processKey(key,ka);
-                        } else if (isTimedout) {
-                            key.interestOps(0);
-                            ka.interestOps(0); //avoid duplicate timeout calls
-                            cancelledKey(key);
+                        } else {
+                            boolean isTimedOut = false;
+                            // Check for read timeout
+                            if ((ka.interestOps() & SelectionKey.OP_READ) == SelectionKey.OP_READ) {
+                                long delta = now - ka.getLastRead();
+                                long timeout = ka.getReadTimeout();
+                                isTimedOut = timeout > 0 && delta > timeout;
+                            }
+                            // Check for write timeout
+                            if (!isTimedOut && (ka.interestOps() & SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE) {
+                                long delta = now - ka.getLastWrite();
+                                long timeout = ka.getWriteTimeout();
+                                isTimedOut = timeout > 0 && delta > timeout;
+                            }
+                            if (isTimedOut) {
+                                key.interestOps(0);
+                                ka.interestOps(0); //avoid duplicate timeout calls
+                                cancelledKey(key);
+                            }
                         }
                     } else if (ka.isAsync()) {
                         if (close) {
@@ -1250,7 +1258,7 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
                         } else if (ka.getAsyncTimeout() > 0) {
                             if ((now - ka.getLastAsyncStart()) > ka.getAsyncTimeout()) {
                                 // Prevent subsequent timeouts if the timeout event takes a while to process
-                                ka.access(Long.MAX_VALUE);
+                                ka.setAsyncTimeout(0);
                                 processSocket(ka, SocketStatus.TIMEOUT, true);
                             }
                         }
@@ -1282,7 +1290,6 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
         private CountDownLatch readLatch = null;
         private CountDownLatch writeLatch = null;
         private volatile SendfileData sendfileData = null;
-        private long writeTimeout = -1;
 
         public NioSocketWrapper(NioChannel channel, NioEndpoint endpoint) {
             super(channel, endpoint);
@@ -1367,11 +1374,6 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
         public void setSendfileData(SendfileData sf) { this.sendfileData = sf;}
         public SendfileData getSendfileData() { return this.sendfileData;}
 
-        public void setWriteTimeout(long writeTimeout) {
-            this.writeTimeout = writeTimeout;
-        }
-        public long getWriteTimeout() {return this.writeTimeout;}
-
 
         @Override
         public boolean isReadyForRead() throws IOException {
@@ -1473,7 +1475,7 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
                         throw new IOException("Key must be cancelled.");
                     }
                     nRead = pool.read(socketBufferHandler.getReadBuffer(),
-                            channel, selector, att.getTimeout());
+                            channel, selector, att.getReadTimeout());
                 } catch (EOFException eof) {
                     nRead = -1;
                 } finally {
@@ -1489,7 +1491,7 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
 
 
         @Override
-        protected synchronized void doWrite(boolean block) throws IOException {
+        protected synchronized void doWriteInternal(boolean block) throws IOException {
             socketBufferHandler.configureWriteBufferForRead();
 
             long writeTimeout = getWriteTimeout();

==================================================
