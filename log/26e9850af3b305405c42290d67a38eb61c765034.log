26e9850af3b305405c42290d67a38eb61c765034
==================================================
Whitespace removal from /java/org/apache/tomcat
==================================================
Mark Emlyn
==================================================
Sat Oct 22 21:02:40 2011 +0000
==================================================
InstanceManager.java
Whitespace removal from /java/org/apache/tomcat

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1187781 13f79535-47bb-0310-9956-ffa450edef68



==================================================
JarScanner.java
index 1190f15e34..8159929a3c 100644
--- a/java/org/apache/tomcat/InstanceManager.java
+++ b/java/org/apache/tomcat/InstanceManager.java
@@ -26,14 +26,14 @@ import javax.naming.NamingException;
 public interface InstanceManager {
 
     public Object newInstance(String className)
-        throws IllegalAccessException, InvocationTargetException, NamingException, 
+        throws IllegalAccessException, InvocationTargetException, NamingException,
             InstantiationException, ClassNotFoundException;
 
-    public Object newInstance(String fqcn, ClassLoader classLoader) 
-        throws IllegalAccessException, InvocationTargetException, NamingException, 
+    public Object newInstance(String fqcn, ClassLoader classLoader)
+        throws IllegalAccessException, InvocationTargetException, NamingException,
             InstantiationException, ClassNotFoundException;
 
-    public void newInstance(Object o) 
+    public void newInstance(Object o)
         throws IllegalAccessException, InvocationTargetException, NamingException;
 
     public void destroyInstance(Object o)

==================================================
JarScannerCallback.java
index 620bb02c75..6e8446cda8 100644
--- a/java/org/apache/tomcat/JarScanner.java
+++ b/java/org/apache/tomcat/JarScanner.java
@@ -23,14 +23,14 @@ import javax.servlet.ServletContext;
 /**
  * Scans a web application and classloader hierarchy for JAR files. Uses
  * include TLD scanning and web-fragment.xml scanning. Uses a call-back
- * mechanism so the caller can process each JAR found. 
+ * mechanism so the caller can process each JAR found.
  */
 public interface JarScanner {
 
     /**
      * Scan the provided ServletContext and classloader for JAR files. Each JAR
      * file found will be passed to the callback handler to be processed.
-     *  
+     *
      * @param context       The ServletContext - used to locate and access
      *                      WEB-INF/lib
      * @param classloader   The classloader - used to access JARs not in
@@ -40,5 +40,5 @@ public interface JarScanner {
      */
     public void scan(ServletContext context, ClassLoader classloader,
             JarScannerCallback callback, Set<String> jarsToSkip);
-    
+
 }

==================================================
PeriodicEventListener.java
index 478ba68892..8fd4bb74a0 100644
--- a/java/org/apache/tomcat/JarScannerCallback.java
+++ b/java/org/apache/tomcat/JarScannerCallback.java
@@ -24,12 +24,12 @@ import java.net.JarURLConnection;
 public interface JarScannerCallback {
 
     /**
-     * 
+     *
      * @param urlConn
      * @throws IOException
      */
     public void scan(JarURLConnection urlConn) throws IOException;
-    
+
     public void scan(File file) throws IOException ;
 
 }

==================================================
Txt2Html.java
index 2d8c63ce42..7393eedb34 100644
--- a/java/org/apache/tomcat/PeriodicEventListener.java
+++ b/java/org/apache/tomcat/PeriodicEventListener.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
Directory.java
index 6f814307e4..8e5438aee5 100644
--- a/java/org/apache/tomcat/buildutil/Txt2Html.java
+++ b/java/org/apache/tomcat/buildutil/Txt2Html.java
@@ -42,16 +42,16 @@ import org.apache.tools.ant.types.FileSet;
  *
  * @author Mark Roth
  */
-public class Txt2Html 
-    extends Task 
+public class Txt2Html
+    extends Task
 {
-    
+
     /** The directory to contain the resulting files */
     private File todir;
-    
+
     /** The file to be converted into HTML */
     private List<FileSet> filesets = new LinkedList<FileSet>();
-    
+
     /**
      * Sets the directory to contain the resulting files
      *
@@ -60,7 +60,7 @@ public class Txt2Html
     public void setTodir( File todir ) {
         this.todir = todir;
     }
-    
+
     /**
      * Sets the files to be converted into HTML
      *
@@ -69,7 +69,7 @@ public class Txt2Html
     public void addFileset( FileSet fs ) {
         filesets.add( fs );
     }
-    
+
     /**
      * Perform the conversion
      *
@@ -77,11 +77,11 @@ public class Txt2Html
      *    this task.
      */
     @Override
-    public void execute() 
-        throws BuildException 
+    public void execute()
+        throws BuildException
     {
         int count = 0;
-        
+
         // Step through each file and convert.
         Iterator<FileSet> iter = filesets.iterator();
         while( iter.hasNext() ) {
@@ -92,29 +92,29 @@ public class Txt2Html
             for( int i = 0; i < files.length; i++ ) {
                 File from = new File( basedir, files[i] );
                 File to = new File( todir, files[i] + ".html" );
-                if( !to.exists() || 
-                    (from.lastModified() > to.lastModified()) ) 
+                if( !to.exists() ||
+                    (from.lastModified() > to.lastModified()) )
                 {
-                    log( "Converting file '" + from.getAbsolutePath() + 
+                    log( "Converting file '" + from.getAbsolutePath() +
                         "' to '" + to.getAbsolutePath(), Project.MSG_VERBOSE );
                     try {
                         convert( from, to );
                     }
                     catch( IOException e ) {
-                        throw new BuildException( "Could not convert '" + 
-                            from.getAbsolutePath() + "' to '" + 
+                        throw new BuildException( "Could not convert '" +
+                            from.getAbsolutePath() + "' to '" +
                             to.getAbsolutePath() + "'", e );
                     }
                     count++;
                 }
             }
             if( count > 0 ) {
-                log( "Converted " + count + " file" + (count > 1 ? "s" : "") + 
+                log( "Converted " + count + " file" + (count > 1 ? "s" : "") +
                     " to " + todir.getAbsolutePath() );
             }
         }
     }
-    
+
     /**
      * Perform the actual copy and conversion
      *
@@ -128,10 +128,10 @@ public class Txt2Html
         // Open files:
         BufferedReader in = new BufferedReader( new FileReader( from ) );
         PrintWriter out = new PrintWriter( new FileWriter( to ) );
-        
+
         // Output header:
         out.println( "<html><body><pre>" );
-        
+
         // Convert, line-by-line:
         String line;
         while( (line = in.readLine()) != null ) {
@@ -152,15 +152,15 @@ public class Txt2Html
             }
             out.println( result.toString() );
         }
-        
+
         // Output footer:
         out.println( "</pre></body></html>" );
-        
+
         // Close streams:
         out.close();
         in.close();
     }
-    
+
 }
 
 

==================================================
File.java
index 1bd28badb6..1aa763ff70 100644
--- a/java/org/apache/tomcat/jni/Directory.java
+++ b/java/org/apache/tomcat/jni/Directory.java
@@ -53,7 +53,7 @@ public class Directory {
      * Find an existing directory suitable as a temporary storage location.
      * @param pool The pool to use for any necessary allocations.
      * @return The temp directory.
-     * 
+     *
      * This function uses an algorithm to search for a directory that an
      * an application can use for temporary storage.  Once such a
      * directory is found, that location is cached by the library.  Thus,

==================================================
SSLSocket.java
index 41e6350fa9..74bdc0d5f8 100644
--- a/java/org/apache/tomcat/jni/File.java
+++ b/java/org/apache/tomcat/jni/File.java
@@ -242,7 +242,7 @@ public class File {
      *              APR_CREATE | APR_READ | APR_WRITE | APR_EXCL | APR_DELONCLOSE
      * @param pool The pool to allocate the file out of.
      * @return The apr file to use as a temporary file.
-     * 
+     *
      * This function  generates  a unique temporary file name from template.
      * The last six characters of template must be XXXXXX and these are replaced
      * with a string that makes the filename unique. Since it will  be  modified,

==================================================
DomUtil.java
index a3d02820bf..2c51d44387 100644
--- a/java/org/apache/tomcat/jni/SSLSocket.java
+++ b/java/org/apache/tomcat/jni/SSLSocket.java
@@ -78,8 +78,8 @@ public class SSLSocket {
      * @param level Type of Client Certificate verification.
      */
     public static native void setVerify(long sock, int level, int depth);
-    
-    /**    
+
+    /**
      * Return SSL Info parameter as byte array.
      *
      * @param sock The socket to read the data from.

==================================================
ExceptionUtils.java
index 9c94463b56..28a2229703 100644
--- a/java/org/apache/tomcat/util/DomUtil.java
+++ b/java/org/apache/tomcat/util/DomUtil.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -101,15 +101,15 @@ public class DomUtil {
         attNode.setNodeValue( val );
         attributes.setNamedItem(attNode);
     }
-    
+
     public static void removeAttribute( Node node, String attName ) {
         NamedNodeMap attributes=node.getAttributes();
-        attributes.removeNamedItem(attName);                
+        attributes.removeNamedItem(attName);
     }
-    
-    
-    /** Set or replace the text value 
-     */ 
+
+
+    /** Set or replace the text value
+     */
     public static void setText(Node node, String val) {
         Node chld=DomUtil.getChild(node, Node.TEXT_NODE);
         if( chld == null ) {
@@ -118,35 +118,35 @@ public class DomUtil {
             return;
         }
         // change the value
-        chld.setNodeValue(val);           
+        chld.setNodeValue(val);
     }
 
     /** Find the first direct child with a given attribute.
      * @param parent
-     * @param elemName name of the element, or null for any 
+     * @param elemName name of the element, or null for any
      * @param attName attribute we're looking for
      * @param attVal attribute value or null if we just want any
-     */ 
+     */
     public static Node findChildWithAtt(Node parent, String elemName,
                                         String attName, String attVal) {
-        
+
         Node child=DomUtil.getChild(parent, Node.ELEMENT_NODE);
         if( attVal== null ) {
             while( child!= null &&
-                    ( elemName==null || elemName.equals( child.getNodeName())) && 
+                    ( elemName==null || elemName.equals( child.getNodeName())) &&
                     DomUtil.getAttribute(child, attName) != null ) {
                 child=getNext(child, elemName, Node.ELEMENT_NODE );
             }
         } else {
-            while( child!= null && 
-                    ( elemName==null || elemName.equals( child.getNodeName())) && 
+            while( child!= null &&
+                    ( elemName==null || elemName.equals( child.getNodeName())) &&
                     ! attVal.equals( DomUtil.getAttribute(child, attName)) ) {
                 child=getNext(child, elemName, Node.ELEMENT_NODE );
             }
         }
-        return child;        
-    }    
-    
+        return child;
+    }
+
 
     /** Get the first child's content ( ie it's included TEXT node ).
      */
@@ -183,14 +183,14 @@ public class DomUtil {
     }
 
     /** Return the next sibling with a given name and type
-     */ 
+     */
     public static Node getNext( Node current, String name, int type) {
         Node first=current.getNextSibling();
         if( first==null ) return null;
 
         for (Node node = first; node != null;
              node = node.getNextSibling()) {
-            
+
             if( type >= 0 && node.getNodeType() != type ) continue;
             //System.out.println("getNode: " + name + " " + node.getNodeName());
             if( name==null )

==================================================
IntrospectionUtils.java
index 754614169a..6110e83be0 100644
--- a/java/org/apache/tomcat/util/ExceptionUtils.java
+++ b/java/org/apache/tomcat/util/ExceptionUtils.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -20,9 +20,9 @@ package org.apache.tomcat.util;
  * Utilities for handling Throwables and Exceptions.
  */
 public class ExceptionUtils {
-    
+
     /**
-     * Checks whether the supplied Throwable is one that needs to be 
+     * Checks whether the supplied Throwable is one that needs to be
      * rethrown and swallows all others.
      * @param t the Throwable to check
      */

==================================================
Constants.java
index a027139c01..26d3ac3b12 100644
--- a/java/org/apache/tomcat/util/IntrospectionUtils.java
+++ b/java/org/apache/tomcat/util/IntrospectionUtils.java
@@ -37,10 +37,10 @@ import java.util.Vector;
  */
 public final class IntrospectionUtils {
 
-    
+
     private static final org.apache.juli.logging.Log log=
         org.apache.juli.logging.LogFactory.getLog( IntrospectionUtils.class );
-    
+
     /**
      * Call execute() - any ant-like task should work
      */
@@ -134,7 +134,7 @@ public final class IntrospectionUtils {
      * Guess a product install/home by analyzing the class path. It works for
      * product using the pattern: lib/executable.jar or if executable.jar is
      * included in classpath by a shell script. ( java -jar also works )
-     * 
+     *
      * Insures both "install" and "home" System properties are set. If either or
      * both System properties are unset, "install" and "home" will be set to the
      * same value. This value will be the other System property that is set, or
@@ -345,9 +345,9 @@ public final class IntrospectionUtils {
                     if (methods[i].getReturnType()==Boolean.TYPE){
                         setPropertyMethodBool = methods[i];
                     }else {
-                        setPropertyMethodVoid = methods[i];    
+                        setPropertyMethodVoid = methods[i];
                     }
-                    
+
                 }
             }
 
@@ -443,7 +443,7 @@ public final class IntrospectionUtils {
         return null;
     }
 
-    /** 
+    /**
      */
     public static void setProperty(Object o, String name) {
         String setter = "set" + capitalize(name);
@@ -631,7 +631,7 @@ public final class IntrospectionUtils {
      * Add elements from the classpath <i>cp </i> to a Vector <i>jars </i> as
      * file URLs (We use Vector for JDK 1.1 compat).
      * <p>
-     * 
+     *
      * @param jars The jar list
      * @param cp a String classpath of directory or jar file elements
      *   separated by path.separator delimiters.
@@ -703,7 +703,7 @@ public final class IntrospectionUtils {
     public static void clear() {
         objectMethods.clear();
     }
-    
+
     static Hashtable<Class<?>,Method[]> objectMethods =
         new Hashtable<Class<?>,Method[]>();
 
@@ -892,7 +892,7 @@ public final class IntrospectionUtils {
         }
         return result;
     }
-    
+
     // -------------------- Get property --------------------
     // This provides a layer of abstraction
 

==================================================
AnnotationDefault.java
index 205b995a67..a94ad6c21d 100644
--- a/java/org/apache/tomcat/util/bcel/Constants.java
+++ b/java/org/apache/tomcat/util/bcel/Constants.java
@@ -97,7 +97,7 @@ public interface Constants {
     "CONSTANT_Class", "CONSTANT_String", "CONSTANT_Fieldref",
     "CONSTANT_Methodref", "CONSTANT_InterfaceMethodref",
     "CONSTANT_NameAndType" };
-  
+
   /** Java VM opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
   public static final short LDC              = 18;
@@ -138,11 +138,11 @@ public interface Constants {
   /** Java VM opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
   public static final short ASTORE           = 58;
-  
+
   /** Java VM opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
   public static final short IINC             = 132;
-  
+
   /** Java VM opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
   public static final short IFEQ             = 153;
@@ -218,14 +218,14 @@ public interface Constants {
   /** Java VM opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
   public static final short INVOKESPECIAL    = 183;
-  
+
   /** Java VM opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
   public static final short INVOKESTATIC     = 184;
   /** Java VM opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
   public static final short INVOKEINTERFACE  = 185;
-  
+
   /** Java VM opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
   public static final short NEW              = 187;
@@ -235,14 +235,14 @@ public interface Constants {
   /** Java VM opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
   public static final short ANEWARRAY        = 189;
-  
+
   /** Java VM opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
   public static final short CHECKCAST        = 192;
   /** Java VM opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
   public static final short INSTANCEOF       = 193;
-  
+
   /** Java VM opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
   public static final short WIDE             = 196;
@@ -279,8 +279,8 @@ public interface Constants {
   public static final byte T_SHORT   = 9;
   /** Int data type. */
   public static final byte T_INT     = 10;
-  
-  
+
+
   /** Unknown data type. */
   public static final byte T_UNKNOWN   = 15;
 
@@ -431,7 +431,7 @@ public interface Constants {
 
   /**
    * Names of opcodes.  Indexed by opcode.  OPCODE_NAMES[ALOAD] = "aload".
-   */ 
+   */
   public static final String[] OPCODE_NAMES = {
     "nop", "aconst_null", "iconst_m1", "iconst_0", "iconst_1",
     "iconst_2", "iconst_3", "iconst_4", "iconst_5", "lconst_0",
@@ -513,7 +513,7 @@ public interface Constants {
     "SourceFile", "ConstantValue", "Code", "Exceptions",
     "LineNumberTable", "LocalVariableTable",
     "InnerClasses", "Synthetic", "Deprecated",
-    "PMGClass", "Signature", "StackMap", 
+    "PMGClass", "Signature", "StackMap",
     "RuntimeVisibleAnnotations", "RuntimeInvisibleAnnotations",
     "RuntimeVisibleParameterAnnotations", "RuntimeInvisibleParameterAnnotations",
     "AnnotationDefault", "LocalVariableTypeTable", "EnclosingMethod", "StackMapTable"
@@ -527,25 +527,25 @@ public interface Constants {
 
   public static final String[] ITEM_NAMES = {
     "Bogus", "Integer", "Float", "Double", "Long",
-    "Null", "InitObject", "Object", "NewObject" 
+    "Null", "InitObject", "Object", "NewObject"
   };
-  
+
   /** Constants used to identify StackMapEntry types.
-   * 
-   * For those types which can specify a range, the 
+   *
+   * For those types which can specify a range, the
    * constant names the lowest value.
    */
-  public static final int SAME_FRAME = 0; 
-  public static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64; 
-  public static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247; 
-  public static final int CHOP_FRAME = 248; 
-  public static final int SAME_FRAME_EXTENDED = 251; 
-  public static final int APPEND_FRAME = 252; 
-  public static final int FULL_FRAME = 255; 
-  
-  /** Constants that define the maximum value of 
+  public static final int SAME_FRAME = 0;
+  public static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64;
+  public static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247;
+  public static final int CHOP_FRAME = 248;
+  public static final int SAME_FRAME_EXTENDED = 251;
+  public static final int APPEND_FRAME = 252;
+  public static final int FULL_FRAME = 255;
+
+  /** Constants that define the maximum value of
    * those constants which store ranges. */
-  
+
   public static final int SAME_FRAME_MAX = 63;
   public static final int SAME_LOCALS_1_STACK_ITEM_FRAME_MAX = 127;
   public static final int CHOP_FRAME_MAX = 250;

==================================================
AnnotationEntry.java
index 251a57d260..e62a12849a 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/AnnotationDefault.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/AnnotationDefault.java
@@ -25,7 +25,7 @@ import org.apache.tomcat.util.bcel.Constants;
 
 /**
  * represents the default value of a annotation for a method info
- * 
+ *
  * @version $Id: AnnotationDefault 1 2005-02-13 03:15:08Z dbrosius $
  * @author <A HREF="mailto:dbrosius@qis.net">D. Brosius</A>
  * @since 5.3

==================================================
Annotations.java
index 9ec1a8503e..c42dfd11ce 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/AnnotationEntry.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/AnnotationEntry.java
@@ -28,7 +28,7 @@ import org.apache.tomcat.util.bcel.Constants;
 
 /**
  * represents one annotation in the annotation table
- * 
+ *
  * @version $Id: AnnotationEntry
  * @author  <A HREF="mailto:dbrosius@mebigfatguy.com">D. Brosius</A>
  * @since 5.3
@@ -36,22 +36,22 @@ import org.apache.tomcat.util.bcel.Constants;
 public class AnnotationEntry implements Constants, Serializable {
 
     private static final long serialVersionUID = 1L;
-    
+
     private final int type_index;
     private final ConstantPool constant_pool;
 
     private List<ElementValuePair> element_value_pairs;
-    
+
     /**
      * Factory method to create an AnnotionEntry from a DataInputStream
-     * 
+     *
      * @param file
      * @param constant_pool
      * @return the entry
      * @throws IOException
      */
     public static AnnotationEntry read(DataInputStream file, ConstantPool constant_pool) throws IOException {
-        
+
         final AnnotationEntry annotationEntry = new AnnotationEntry(file.readUnsignedShort(), constant_pool);
         final int num_element_value_pairs = (file.readUnsignedShort());
         annotationEntry.element_value_pairs = new ArrayList<ElementValuePair>();
@@ -66,7 +66,7 @@ public class AnnotationEntry implements Constants, Serializable {
         this.type_index = type_index;
         this.constant_pool = constant_pool;
     }
-    
+
     /**
      * @return the annotation type name
      */

==================================================
Attribute.java
index 7558c5790b..cc7049a51a 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/Annotations.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/Annotations.java
@@ -23,7 +23,7 @@ import java.io.IOException;
 
 /**
  * base class for annotations
- * 
+ *
  * @version $Id: Annotations
  * @author  <A HREF="mailto:dbrosius@qis.net">D. Brosius</A>
  * @since 5.3
@@ -31,9 +31,9 @@ import java.io.IOException;
 public abstract class Annotations extends Attribute {
 
     private static final long serialVersionUID = 1L;
-    
+
     private AnnotationEntry[] annotation_table;
-    
+
     /**
      * @param annotation_type the subclass type of the annotation
      * @param name_index Index pointing to the name <em>Code</em>

==================================================
ClassFormatException.java
index 0a3d3c0986..335b009567 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/Attribute.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/Attribute.java
@@ -33,7 +33,7 @@ import org.apache.tomcat.util.bcel.Constants;
  * <em>LocalVariableTable</em>, <em>InnerClasses</em> and
  * <em>Synthetic</em> attributes are supported. The <em>Unknown</em>
  * attribute stands for non-standard-attributes.
- * 
+ *
  * @version $Id$
  * @author <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
  * @see ConstantValue
@@ -71,7 +71,7 @@ public abstract class Attribute implements Cloneable, Serializable
 
     /**
      * Dump attribute to file stream in binary format.
-     * 
+     *
      * @param file
      *            Output file stream
      * @throws IOException
@@ -89,7 +89,7 @@ public abstract class Attribute implements Cloneable, Serializable
      * Class method reads one attribute from the input data stream. This method
      * must not be accessible from the outside. It is called by the Field and
      * Method constructor methods.
-     * 
+     *
      * @see Field
      * @see Method @param file Input stream @param constant_pool Array of
      *      constants @return Attribute @throws IOException @throws
@@ -208,7 +208,7 @@ public abstract class Attribute implements Cloneable, Serializable
     /**
      * Use copy() if you want to have a deep copy(), i.e., with all references
      * copied correctly.
-     * 
+     *
      * @return shallow copy of this attribute
      */
     @Override

==================================================
ClassParser.java
index 527c555b11..7cde30fa83 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ClassFormatException.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ClassFormatException.java
@@ -17,7 +17,7 @@
  */
 package org.apache.tomcat.util.bcel.classfile;
 
-/** 
+/**
  * Thrown when the BCEL attempts to read a class file and determines
  * that the file is malformed or otherwise cannot be interpreted as a
  * class file.
@@ -37,7 +37,7 @@ public class ClassFormatException extends RuntimeException {
     public ClassFormatException(String s) {
         super(s);
     }
-    
+
     public ClassFormatException(String s, Throwable initCause) {
         super(s, initCause);
     }

==================================================
Code.java
index c601b872ff..9f1d82487f 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ClassParser.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ClassParser.java
@@ -40,7 +40,7 @@ import org.apache.tomcat.util.bcel.Constants;
  * further details about the structure of a bytecode file.
  *
  * @version $Id$
- * @author <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A> 
+ * @author <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
  */
 public final class ClassParser {
 
@@ -97,11 +97,11 @@ public final class ClassParser {
                 if (is_zip) {
                     zip = new ZipFile(zip_file);
                     ZipEntry entry = zip.getEntry(file_name);
-                    
+
                     if (entry == null) {
                         throw new IOException("File " + file_name + " not found");
                     }
-                    
+
                     file = new DataInputStream(new BufferedInputStream(zip.getInputStream(entry),
                             BUFSIZE));
                 } else {

==================================================
CodeException.java
index e4cd5dc79b..1df7415717 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/Code.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/Code.java
@@ -23,7 +23,7 @@ import java.io.IOException;
 
 import org.apache.tomcat.util.bcel.Constants;
 
-/** 
+/**
  * This class represents a chunk of Java byte code contained in a
  * method. It is instantiated by the
  * <em>Attribute.readAttribute()</em> method. A <em>Code</em>
@@ -32,7 +32,7 @@ import org.apache.tomcat.util.bcel.Constants;
  * method.
  *
  * This attribute has attributes itself, namely <em>LineNumberTable</em> which
- * is used for debugging purposes and <em>LocalVariableTable</em> which 
+ * is used for debugging purposes and <em>LocalVariableTable</em> which
  * contains information about the local variables.
  *
  * @version $Id$
@@ -152,7 +152,7 @@ public final class Code extends Attribute {
 
 
     /**
-     * @return the internal length of this code attribute (minus the first 6 bytes) 
+     * @return the internal length of this code attribute (minus the first 6 bytes)
      * and excluding all its attributes
      */
     private final int getInternalLength() {
@@ -242,7 +242,7 @@ public final class Code extends Attribute {
 
     /**
      * @return deep copy of this attribute
-     * 
+     *
      * @param _constant_pool the constant pool to duplicate
      */
     @Override

==================================================
Constant.java
index 72f7a916d7..21ded53892 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/CodeException.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/CodeException.java
@@ -64,8 +64,8 @@ public final class CodeException implements Cloneable, Constants, Serializable {
      * @param end_pc is exclusive
      * @param handler_pc Starting address of exception handler, i.e.,
      * an offset from start of code.
-     * @param catch_type If zero the handler catches any 
-     * exception, otherwise it points to the exception class which is 
+     * @param catch_type If zero the handler catches any
+     * exception, otherwise it points to the exception class which is
      * to be caught.
      */
     public CodeException(int start_pc, int end_pc, int handler_pc, int catch_type) {

==================================================
ConstantCP.java
index 507a67d853..cad5b5732a 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/Constant.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/Constant.java
@@ -57,7 +57,7 @@ public abstract class Constant implements Cloneable, Serializable {
      * places we will use the tag for switch()es anyway.
      *
      * First, we want match the specification as closely as possible. Second we
-     * need the tag as an index to select the corresponding class name from the 
+     * need the tag as an index to select the corresponding class name from the
      * `CONSTANT_NAMES' array.
      */
     protected byte tag;
@@ -137,7 +137,7 @@ public abstract class Constant implements Cloneable, Serializable {
      * Return value as defined by given BCELComparator strategy.
      * By default two Constant objects are said to be equal when
      * the result of toString() is equal.
-     * 
+     *
      * @see java.lang.Object#equals(java.lang.Object)
      */
     @Override
@@ -149,7 +149,7 @@ public abstract class Constant implements Cloneable, Serializable {
     /**
      * Return value as defined by given BCELComparator strategy.
      * By default return the hashcode of the result of toString().
-     * 
+     *
      * @see java.lang.Object#hashCode()
      */
     @Override

==================================================
ConstantClass.java
index f0221e86af..27581bec6e 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ConstantCP.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ConstantCP.java
@@ -21,7 +21,7 @@ import java.io.DataInput;
 import java.io.DataOutputStream;
 import java.io.IOException;
 
-/** 
+/**
  * Abstract super class for Fieldref and Methodref constants.
  *
  * @version $Id$
@@ -61,7 +61,7 @@ public abstract class ConstantCP extends Constant {
     }
 
 
-    /** 
+    /**
      * Dump constant field reference to file stream in binary format.
      *
      * @param file Output file stream

==================================================
ConstantDouble.java
index 5ec1a5a6b7..dfffd79b7c 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ConstantClass.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ConstantClass.java
@@ -23,9 +23,9 @@ import java.io.IOException;
 
 import org.apache.tomcat.util.bcel.Constants;
 
-/** 
- * This class is derived from the abstract 
- * <A HREF="org.apache.tomcat.util.bcel.classfile.Constant.html">Constant</A> class 
+/**
+ * This class is derived from the abstract
+ * <A HREF="org.apache.tomcat.util.bcel.classfile.Constant.html">Constant</A> class
  * and represents a reference to a (external) class.
  *
  * @version $Id$
@@ -59,7 +59,7 @@ public final class ConstantClass extends Constant {
     }
 
 
-    /** 
+    /**
      * Dump constant class to file stream in binary format.
      *
      * @param file Output file stream

==================================================
ConstantFieldref.java
index 073c67854b..65bb0fc6c8 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ConstantDouble.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ConstantDouble.java
@@ -23,9 +23,9 @@ import java.io.IOException;
 
 import org.apache.tomcat.util.bcel.Constants;
 
-/** 
- * This class is derived from the abstract 
- * <A HREF="org.apache.tomcat.util.bcel.classfile.Constant.html">Constant</A> class 
+/**
+ * This class is derived from the abstract
+ * <A HREF="org.apache.tomcat.util.bcel.classfile.Constant.html">Constant</A> class
  * and represents a reference to a Double object.
  *
  * @version $Id$
@@ -38,7 +38,7 @@ public final class ConstantDouble extends Constant {
     private double bytes;
 
 
-    /** 
+    /**
      * @param bytes Data
      */
     public ConstantDouble(double bytes) {
@@ -47,7 +47,7 @@ public final class ConstantDouble extends Constant {
     }
 
 
-    /** 
+    /**
      * Initialize instance from file data.
      *
      * @param file Input stream

==================================================
ConstantFloat.java
index fb946a906c..ea356c3fd6 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ConstantFieldref.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ConstantFieldref.java
@@ -22,7 +22,7 @@ import java.io.IOException;
 
 import org.apache.tomcat.util.bcel.Constants;
 
-/** 
+/**
  * This class represents a constant pool reference to a field.
  *
  * @version $Id$

==================================================
ConstantInteger.java
index b1d458ff60..1012cf67b2 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ConstantFloat.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ConstantFloat.java
@@ -23,9 +23,9 @@ import java.io.IOException;
 
 import org.apache.tomcat.util.bcel.Constants;
 
-/** 
- * This class is derived from the abstract 
- * <A HREF="org.apache.tomcat.util.bcel.classfile.Constant.html">Constant</A> class 
+/**
+ * This class is derived from the abstract
+ * <A HREF="org.apache.tomcat.util.bcel.classfile.Constant.html">Constant</A> class
  * and represents a reference to a float object.
  *
  * @version $Id$
@@ -38,7 +38,7 @@ public final class ConstantFloat extends Constant {
     private float bytes;
 
 
-    /** 
+    /**
      * @param bytes Data
      */
     public ConstantFloat(float bytes) {
@@ -47,7 +47,7 @@ public final class ConstantFloat extends Constant {
     }
 
 
-    /** 
+    /**
      * Initialize instance from file data.
      *
      * @param file Input stream
@@ -57,7 +57,7 @@ public final class ConstantFloat extends Constant {
         this(file.readFloat());
     }
 
-    
+
     /**
      * Dump constant float to file stream in binary format.
      *

==================================================
ConstantInterfaceMethodref.java
index 0437cda3e0..d1c659e2a5 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ConstantInteger.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ConstantInteger.java
@@ -23,9 +23,9 @@ import java.io.IOException;
 
 import org.apache.tomcat.util.bcel.Constants;
 
-/** 
- * This class is derived from the abstract 
- * <A HREF="org.apache.tomcat.util.bcel.classfile.Constant.html">Constant</A> class 
+/**
+ * This class is derived from the abstract
+ * <A HREF="org.apache.tomcat.util.bcel.classfile.Constant.html">Constant</A> class
  * and represents a reference to an int object.
  *
  * @version $Id$
@@ -38,7 +38,7 @@ public final class ConstantInteger extends Constant {
     private int bytes;
 
 
-    /** 
+    /**
      * @param bytes Data
      */
     public ConstantInteger(int bytes) {
@@ -47,7 +47,7 @@ public final class ConstantInteger extends Constant {
     }
 
 
-    /** 
+    /**
      * Initialize instance from file data.
      *
      * @param file Input stream

==================================================
ConstantLong.java
index 5dbe87d207..fa33a5d583 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ConstantInterfaceMethodref.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ConstantInterfaceMethodref.java
@@ -22,7 +22,7 @@ import java.io.IOException;
 
 import org.apache.tomcat.util.bcel.Constants;
 
-/** 
+/**
  * This class represents a constant pool reference to an interface method.
  *
  * @version $Id$

==================================================
ConstantMethodref.java
index f9340451ae..62de4721ee 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ConstantLong.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ConstantLong.java
@@ -23,9 +23,9 @@ import java.io.IOException;
 
 import org.apache.tomcat.util.bcel.Constants;
 
-/** 
- * This class is derived from the abstract 
- * <A HREF="org.apache.tomcat.util.bcel.classfile.Constant.html">Constant</A> class 
+/**
+ * This class is derived from the abstract
+ * <A HREF="org.apache.tomcat.util.bcel.classfile.Constant.html">Constant</A> class
  * and represents a reference to a long object.
  *
  * @version $Id$
@@ -38,7 +38,7 @@ public final class ConstantLong extends Constant {
     private long bytes;
 
 
-    /** 
+    /**
      * @param bytes Data
      */
     public ConstantLong(long bytes) {
@@ -47,7 +47,7 @@ public final class ConstantLong extends Constant {
     }
 
 
-    /** 
+    /**
      * Initialize instance from file data.
      *
      * @param file Input stream

==================================================
ConstantNameAndType.java
index a83c41bf61..98a2a524b1 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ConstantMethodref.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ConstantMethodref.java
@@ -22,7 +22,7 @@ import java.io.IOException;
 
 import org.apache.tomcat.util.bcel.Constants;
 
-/** 
+/**
  * This class represents a constant pool reference to a method.
  *
  * @version $Id$

==================================================
ConstantPool.java
index cdc75e19ab..9ea5d82c16 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ConstantNameAndType.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ConstantNameAndType.java
@@ -23,9 +23,9 @@ import java.io.IOException;
 
 import org.apache.tomcat.util.bcel.Constants;
 
-/** 
- * This class is derived from the abstract 
- * <A HREF="org.apache.tomcat.util.bcel.classfile.Constant.html">Constant</A> class 
+/**
+ * This class is derived from the abstract
+ * <A HREF="org.apache.tomcat.util.bcel.classfile.Constant.html">Constant</A> class
  * and represents a reference to the name and signature
  * of a field or method.
  *

==================================================
ConstantString.java
index 00d4bd8ea5..a6549d815a 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ConstantPool.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ConstantPool.java
@@ -62,7 +62,7 @@ public class ConstantPool implements Cloneable, Serializable {
              * "All eight byte constants take up two spots in the constant pool.
              * If this is the n'th byte in the constant pool, then the next item
              * will be numbered n+2"
-             * 
+             *
              * Thus we have to increment the index counter.
              */
             tag = constant_pool[i].getTag();
@@ -213,7 +213,7 @@ public class ConstantPool implements Cloneable, Serializable {
 
 
     /**
-     * Get string from constant pool and bypass the indirection of 
+     * Get string from constant pool and bypass the indirection of
      * `ConstantClass' and `ConstantString' objects. I.e. these classes have
      * an index field that points to another entry of the constant pool of
      * type `ConstantUtf8' which contains the real data.

==================================================
ConstantUtf8.java
index 29efb80c53..7fd45b72ec 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ConstantString.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ConstantString.java
@@ -23,9 +23,9 @@ import java.io.IOException;
 
 import org.apache.tomcat.util.bcel.Constants;
 
-/** 
- * This class is derived from the abstract 
- * <A HREF="org.apache.tomcat.util.bcel.classfile.Constant.html">Constant</A> class 
+/**
+ * This class is derived from the abstract
+ * <A HREF="org.apache.tomcat.util.bcel.classfile.Constant.html">Constant</A> class
  * and represents a reference to a String object.
  *
  * @version $Id$
@@ -38,7 +38,7 @@ public final class ConstantString extends Constant {
     private int string_index; // Identical to ConstantClass except for this name
 
 
-    /** 
+    /**
      * Initialize instance from file data.
      *
      * @param file Input stream

==================================================
ConstantValue.java
index 1f374e268f..21a446282f 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ConstantUtf8.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ConstantUtf8.java
@@ -22,9 +22,9 @@ import java.io.IOException;
 
 import org.apache.tomcat.util.bcel.Constants;
 
-/** 
- * This class is derived from the abstract 
- * <A HREF="org.apache.tomcat.util.bcel.classfile.Constant.html">Constant</A> class 
+/**
+ * This class is derived from the abstract
+ * <A HREF="org.apache.tomcat.util.bcel.classfile.Constant.html">Constant</A> class
  * and represents a reference to a Utf8 encoded string.
  *
  * @version $Id$

==================================================
ElementValuePair.java
index 5562f83fa0..cb356fb5ab 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ConstantValue.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ConstantValue.java
@@ -23,7 +23,7 @@ import java.io.IOException;
 import org.apache.tomcat.util.bcel.Constants;
 
 /**
- * This class is derived from <em>Attribute</em> and represents a constant 
+ * This class is derived from <em>Attribute</em> and represents a constant
  * value, i.e., a default value for initializing a class field.
  * This class is instantiated by the <em>Attribute.readAttribute()</em> method.
  *

==================================================
EnclosingMethod.java
index f9a3a95bff..8ff7c04cb6 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ElementValuePair.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ElementValuePair.java
@@ -24,7 +24,7 @@ import org.apache.tomcat.util.bcel.Constants;
 
 /**
  * an annotation's element value pair
- * 
+ *
  * @version $Id: ElementValuePair
  * @author <A HREF="mailto:dbrosius@qis.net">D. Brosius</A>
  * @since 5.3
@@ -56,7 +56,7 @@ public class ElementValuePair
     {
         return elementValue;
     }
-    
+
     protected void dump(DataOutputStream dos) throws IOException {
         dos.writeShort(elementNameIndex); // u2 name of the element
         elementValue.dump(dos);

==================================================
ExceptionTable.java
index 4592923944..5a0e46068d 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/EnclosingMethod.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/EnclosingMethod.java
@@ -23,24 +23,24 @@ import java.io.IOException;
 import org.apache.tomcat.util.bcel.Constants;
 
 /**
- * This attribute exists for local or 
+ * This attribute exists for local or
  * anonymous classes and ... there can be only one.
  */
 public class EnclosingMethod extends Attribute {
-    
+
     private static final long serialVersionUID = 6755214228300933233L;
 
-    // Pointer to the CONSTANT_Class_info structure representing the 
+    // Pointer to the CONSTANT_Class_info structure representing the
     // innermost class that encloses the declaration of the current class.
     private int classIndex;
-    
-    // If the current class is not immediately enclosed by a method or 
-    // constructor, then the value of the method_index item must be zero.  
-    // Otherwise, the value of the  method_index item must point to a 
-    // CONSTANT_NameAndType_info structure representing the name and the 
-    // type of a method in the class referenced by the class we point 
-    // to in the class_index.  *It is the compiler responsibility* to 
-    // ensure that the method identified by this index is the closest 
+
+    // If the current class is not immediately enclosed by a method or
+    // constructor, then the value of the method_index item must be zero.
+    // Otherwise, the value of the  method_index item must point to a
+    // CONSTANT_NameAndType_info structure representing the name and the
+    // type of a method in the class referenced by the class we point
+    // to in the class_index.  *It is the compiler responsibility* to
+    // ensure that the method identified by this index is the closest
     // lexically enclosing method that includes the local/anonymous class.
     private int methodIndex;
 
@@ -61,11 +61,11 @@ public class EnclosingMethod extends Attribute {
         // is this next line sufficient?
         // return (EnclosingMethod)clone();
     }
-    
+
     @Override
     public final void dump(DataOutputStream file) throws IOException {
         super.dump(file);
         file.writeShort(classIndex);
         file.writeShort(methodIndex);
-    }    
+    }
 }

==================================================
Field.java
index 5f04ae5df4..e24b022bd0 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ExceptionTable.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ExceptionTable.java
@@ -23,7 +23,7 @@ import java.io.IOException;
 
 import org.apache.tomcat.util.bcel.Constants;
 
-/** 
+/**
  * This class represents the table of exceptions that are thrown by a
  * method. This attribute may be used once per method.  The name of
  * this class is <em>ExceptionTable</em> for historical reasons; The

==================================================
FieldOrMethod.java
index 3a436254af..f44ba059b1 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/Field.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/Field.java
@@ -24,7 +24,7 @@ import org.apache.tomcat.util.bcel.Constants;
 import org.apache.tomcat.util.bcel.util.BCELComparator;
 
 /**
- * This class represents the field info structure, i.e., the representation 
+ * This class represents the field info structure, i.e., the representation
  * for a variable in the class. See JVM specification for details.
  *
  * @version $Id$
@@ -109,7 +109,7 @@ public final class Field extends FieldOrMethod {
      * Return value as defined by given BCELComparator strategy.
      * By default two Field objects are said to be equal when
      * their names and signatures are equal.
-     * 
+     *
      * @see java.lang.Object#equals(java.lang.Object)
      */
     @Override
@@ -121,7 +121,7 @@ public final class Field extends FieldOrMethod {
     /**
      * Return value as defined by given BCELComparator strategy.
      * By default return the hashcode of the field's name XOR signature.
-     * 
+     *
      * @see java.lang.Object#hashCode()
      */
     @Override

==================================================
InnerClass.java
index 2ecb1c2822..e891238894 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/FieldOrMethod.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/FieldOrMethod.java
@@ -22,7 +22,7 @@ import java.io.IOException;
 
 import org.apache.tomcat.util.bcel.Constants;
 
-/** 
+/**
  * Abstract super class for fields and methods.
  *
  * @version $Id$
@@ -31,11 +31,11 @@ import org.apache.tomcat.util.bcel.Constants;
 public abstract class FieldOrMethod extends AccessFlags implements Cloneable {
 
     private static final long serialVersionUID = -3383525930205542157L;
-    protected int name_index; // Points to field name in constant pool 
+    protected int name_index; // Points to field name in constant pool
     protected int signature_index; // Points to encoded signature
     protected int attributes_count; // No. of attributes
     protected Attribute[] attributes; // Collection of attributes
-    
+
     protected ConstantPool constant_pool;
 
     FieldOrMethod() {
@@ -85,7 +85,7 @@ public abstract class FieldOrMethod extends AccessFlags implements Cloneable {
         attributes_count = (attributes == null) ? 0 : attributes.length;
     }
 
-    
+
     /**
      * @return Name of object, i.e., method name or field name
      */

==================================================
JavaClass.java
index f65cd2aaf5..5d0d6c1f6e 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/InnerClass.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/InnerClass.java
@@ -24,7 +24,7 @@ import java.io.Serializable;
 
 import org.apache.tomcat.util.bcel.Constants;
 
-/** 
+/**
  * This class represents a inner class attribute, i.e., the class
  * indices of the inner and outer classes, the name and the attributes
  * of the inner class.

==================================================
LocalVariableTable.java
index 70cb11da67..3a6f167884 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/JavaClass.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/JavaClass.java
@@ -55,7 +55,7 @@ public class JavaClass extends AccessFlags
 
     //  Annotations are collected from certain attributes, don't do it more than necessary!
     private boolean annotationsOutOfDate = true;
-    
+
     private static BCELComparator _cmp = new BCELComparator() {
 
         @Override
@@ -124,7 +124,7 @@ public class JavaClass extends AccessFlags
             }
         }
         /* According to the specification the following entries must be of type
-         * `ConstantClass' but we check that anyway via the 
+         * `ConstantClass' but we check that anyway via the
          * `ConstPool.getConstant' method.
          */
         class_name = constant_pool.getConstantString(class_name_index, Constants.CONSTANT_Class);
@@ -151,9 +151,9 @@ public class JavaClass extends AccessFlags
     public Attribute[] getAttributes() {
         return attributes;
     }
-    
+
     public AnnotationEntry[] getAnnotationEntries() {
-        if (annotationsOutOfDate) { 
+        if (annotationsOutOfDate) {
             // Find attributes that contain annotation data
             Attribute[] attrs = getAttributes();
             List<AnnotationEntry> accumulatedAnnotations = new ArrayList<AnnotationEntry>();
@@ -216,7 +216,7 @@ public class JavaClass extends AccessFlags
         AnnotationEntry[] annotations = getAnnotationEntries();
         if (annotations!=null && annotations.length>0) {
             buf.append("\nAnnotation(s):\n");
-            for (int i=0; i<annotations.length; i++) 
+            for (int i=0; i<annotations.length; i++)
                 buf.append(indent(annotations[i]));
         }
         if (fields.length > 0) {
@@ -253,7 +253,7 @@ public class JavaClass extends AccessFlags
      * Return value as defined by given BCELComparator strategy.
      * By default two JavaClass objects are said to be equal when
      * their class names are equal.
-     * 
+     *
      * @see java.lang.Object#equals(java.lang.Object)
      */
     @Override
@@ -275,7 +275,7 @@ public class JavaClass extends AccessFlags
     /**
      * Return value as defined by given BCELComparator strategy.
      * By default return the hashcode of the class name.
-     * 
+     *
      * @see java.lang.Object#hashCode()
      */
     @Override

==================================================
LocalVariableTypeTable.java
index 3127ff050a..2668336ac8 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/LocalVariableTable.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/LocalVariableTable.java
@@ -87,12 +87,12 @@ public class LocalVariableTable extends Attribute {
     }
 
 
-    /** 
-     * 
+    /**
+     *
      * @param index the variable slot
-     * 
+     *
      * @return the first LocalVariable that matches the slot or null if not found
-     * 
+     *
      * @deprecated since 5.2 because multiple variables can share the
      *             same slot, use getLocalVariable(int index, int pc) instead.
      */

==================================================
Method.java
index afa213369d..dce9456f83 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/LocalVariableTypeTable.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/LocalVariableTypeTable.java
@@ -40,7 +40,7 @@ import org.apache.tomcat.util.bcel.Constants;
 //    u2 attribute_name_index;
 //    u4 attribute_length;
 //    u2 local_variable_type_table_length;
-//    { 
+//    {
 //      u2 start_pc;
 //      u2 length;
 //      u2 name_index;
@@ -60,7 +60,7 @@ private int             local_variable_type_table_length; // Table of local
   {
     super(Constants.ATTR_LOCAL_VARIABLE_TYPE_TABLE, name_index, length, constant_pool);
     setLocalVariableTable(local_variable_table);
-  }    
+  }
 
   LocalVariableTypeTable(int nameIdx, int len, DataInputStream dis,ConstantPool cpool) throws IOException {
     this(nameIdx, len, (LocalVariable[])null, cpool);
@@ -90,7 +90,7 @@ private int             local_variable_type_table_length; // Table of local
 
   /**
    * @return String representation.
-   */ 
+   */
   @Override
   public final String toString() {
       StringBuilder buf = new StringBuilder();

==================================================
ParameterAnnotationEntry.java
index eb322672ac..e8d5f28430 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/Method.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/Method.java
@@ -24,7 +24,7 @@ import org.apache.tomcat.util.bcel.Constants;
 import org.apache.tomcat.util.bcel.util.BCELComparator;
 
 /**
- * This class represents the method info structure, i.e., the representation 
+ * This class represents the method info structure, i.e., the representation
  * for a method in the class. See JVM specification for details.
  * A method has access flags, a name, a signature and a number of attributes.
  *
@@ -153,7 +153,7 @@ public final class Method extends FieldOrMethod {
      * Return value as defined by given BCELComparator strategy.
      * By default two method objects are said to be equal when
      * their names and signatures are equal.
-     * 
+     *
      * @see java.lang.Object#equals(java.lang.Object)
      */
     @Override
@@ -165,7 +165,7 @@ public final class Method extends FieldOrMethod {
     /**
      * Return value as defined by given BCELComparator strategy.
      * By default return the hashcode of the method's name XOR signature.
-     * 
+     *
      * @see java.lang.Object#hashCode()
      */
     @Override

==================================================
ParameterAnnotations.java
index 2cf5e8a908..2a21714339 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ParameterAnnotationEntry.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ParameterAnnotationEntry.java
@@ -24,7 +24,7 @@ import org.apache.tomcat.util.bcel.Constants;
 
 /**
  * represents one parameter annotation in the parameter annotation table
- * 
+ *
  * @version $Id: ParameterAnnotationEntry
  * @author  <A HREF="mailto:dbrosius@qis.net">D. Brosius</A>
  * @since 5.3
@@ -47,5 +47,5 @@ public class ParameterAnnotationEntry implements Constants {
             annotation_table[i] = AnnotationEntry.read(file, constant_pool);
         }
     }
-    
+
 }

==================================================
RuntimeInvisibleAnnotations.java
index bb5cadbcc8..eecb9fb85a 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ParameterAnnotations.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ParameterAnnotations.java
@@ -22,7 +22,7 @@ import java.io.IOException;
 
 /**
  * base class for parameter annotations
- * 
+ *
  * @version $Id: ParameterAnnotations
  * @author  <A HREF="mailto:dbrosius@qis.net">D. Brosius</A>
  * @since 5.3

==================================================
RuntimeInvisibleParameterAnnotations.java
index e6959e983c..138964d8b9 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/RuntimeInvisibleAnnotations.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/RuntimeInvisibleAnnotations.java
@@ -26,7 +26,7 @@ import org.apache.tomcat.util.bcel.Constants;
 /**
  * represents an annotation that is represented in the class file but is not
  * provided to the JVM.
- * 
+ *
  * @version $Id: RuntimeInvisibleAnnotations
  * @author <A HREF="mailto:dbrosius@qis.net">D. Brosius</A>
  * @since 5.3

==================================================
RuntimeVisibleAnnotations.java
index 547df6bc0e..43730a2241 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/RuntimeInvisibleParameterAnnotations.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/RuntimeInvisibleParameterAnnotations.java
@@ -25,7 +25,7 @@ import org.apache.tomcat.util.bcel.Constants;
 /**
  * represents a parameter annotation that is represented in the class file
  * but is not provided to the JVM.
- * 
+ *
  * @version $Id: RuntimeInvisibleParameterAnnotations
  * @author  <A HREF="mailto:dbrosius@qis.net">D. Brosius</A>
  * @since 5.3

==================================================
RuntimeVisibleParameterAnnotations.java
index 245cc9f062..7a2315021a 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/RuntimeVisibleAnnotations.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/RuntimeVisibleAnnotations.java
@@ -26,7 +26,7 @@ import org.apache.tomcat.util.bcel.Constants;
 /**
  * represents an annotation that is represented in the class file and is
  * provided to the JVM.
- * 
+ *
  * @version $Id: RuntimeVisibleAnnotations
  * @author <A HREF="mailto:dbrosius@qis.net">D. Brosius</A>
  * @since 5.3

==================================================
SimpleElementValue.java
index 0fc4640196..ad0acbedf2 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/RuntimeVisibleParameterAnnotations.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/RuntimeVisibleParameterAnnotations.java
@@ -25,7 +25,7 @@ import org.apache.tomcat.util.bcel.Constants;
 /**
  * represents a parameter annotation that is represented in the class file
  * and is provided to the JVM.
- * 
+ *
  * @version $Id: RuntimeVisibleParameterAnnotations
  * @author  <A HREF="mailto:dbrosius@qis.net">D. Brosius</A>
  * @since 5.3

==================================================
StackMapTableEntry.java
index d86619369e..7ba328bcb3 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/SimpleElementValue.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/SimpleElementValue.java
@@ -39,7 +39,7 @@ public class SimpleElementValue extends ElementValue
     {
         return index;
     }
-    
+
 
     @Override
     public String toString()

==================================================
Utility.java
index 4f710a73ab..2b65811ec1 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/StackMapTableEntry.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/StackMapTableEntry.java
@@ -53,7 +53,7 @@ public final class StackMapTableEntry implements Cloneable, Serializable {
      */
     StackMapTableEntry(DataInputStream file, ConstantPool constant_pool) throws IOException {
         this(file.read(), -1, -1, null, -1, null);
-        
+
         if (frame_type >= Constants.SAME_FRAME && frame_type <= Constants.SAME_FRAME_MAX) {
             byte_code_offset_delta = frame_type - Constants.SAME_FRAME;
         } else if (frame_type >= Constants.SAME_LOCALS_1_STACK_ITEM_FRAME && frame_type <= Constants.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {
@@ -76,8 +76,8 @@ public final class StackMapTableEntry implements Cloneable, Serializable {
             types_of_locals = new StackMapType[number_of_locals];
             for (int i = 0; i < number_of_locals; i++) {
                 types_of_locals[i] = new StackMapType(file, constant_pool);
-            }            
-        } else if (frame_type == Constants.FULL_FRAME) {        
+            }
+        } else if (frame_type == Constants.FULL_FRAME) {
             byte_code_offset_delta = file.readShort();
             number_of_locals = file.readShort();
             types_of_locals = new StackMapType[number_of_locals];
@@ -132,7 +132,7 @@ public final class StackMapTableEntry implements Cloneable, Serializable {
             for (int i = 0; i < number_of_locals; i++) {
                 types_of_locals[i].dump(file);
             }
-        } else if (frame_type == Constants.FULL_FRAME) {        
+        } else if (frame_type == Constants.FULL_FRAME) {
             file.writeShort(byte_code_offset_delta);
             file.writeShort(number_of_locals);
             for (int i = 0; i < number_of_locals; i++) {
@@ -168,7 +168,7 @@ public final class StackMapTableEntry implements Cloneable, Serializable {
             buf.append("SAME_EXTENDED");
         } else if (frame_type >= Constants.APPEND_FRAME && frame_type <= Constants.APPEND_FRAME_MAX) {
             buf.append("APPEND "+(frame_type-251));
-        } else if (frame_type == Constants.FULL_FRAME) {        
+        } else if (frame_type == Constants.FULL_FRAME) {
             buf.append("FULL");
         } else {
             buf.append("UNKNOWN");

==================================================
BCELComparator.java
index f83b04aa86..2d8857b5d1 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/Utility.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/Utility.java
@@ -78,7 +78,7 @@ public abstract class Utility {
      * Special case: Classes compiled with new compilers and with the
      * `ACC_SUPER' flag would be said to be "synchronized". This is
      * because SUN used the same value for the flags `ACC_SUPER' and
-     * `ACC_SYNCHRONIZED'. 
+     * `ACC_SYNCHRONIZED'.
      *
      * @param  access_flags Access flags
      * @param  for_class access flags are for class qualifiers ?
@@ -107,7 +107,7 @@ public abstract class Utility {
 
     /**
      * @param access_flags the class flags
-     * 
+     *
      * @return "class" or "interface", depending on the ACC_INTERFACE flag
      */
     public static final String classOrInterface( int access_flags ) {
@@ -116,7 +116,7 @@ public abstract class Utility {
 
 
     /**
-     * Disassemble a byte array of JVM byte codes starting from code line 
+     * Disassemble a byte array of JVM byte codes starting from code line
      * `index' and return the disassembled string representation. Decode only
      * `num' opcodes (including their operands), use -1 if you want to
      * decompile everything.
@@ -161,7 +161,7 @@ public abstract class Utility {
      * @param  constant_pool Array of constants
      * @param  verbose be verbose, e.g. print constant pool index
      * @return String representation of byte code
-     * 
+     *
      * @throws IOException if a failure from reading from the bytes argument occurs
      */
     public static final String codeToString( ByteSequence bytes, ConstantPool constant_pool,
@@ -409,7 +409,7 @@ public abstract class Utility {
 
 
     /**
-     * Shorten long class names, <em>java/lang/String</em> becomes 
+     * Shorten long class names, <em>java/lang/String</em> becomes
      * <em>String</em>.
      *
      * @param str The long class name
@@ -445,7 +445,7 @@ public abstract class Utility {
 
 
     /**
-     * Shorten long class names, <em>java/lang/String</em> becomes 
+     * Shorten long class names, <em>java/lang/String</em> becomes
      * <em>java.lang.String</em>,
      * e.g.. If <em>chopit</em> is <em>true</em> the prefix <em>java.lang</em>
      * is also removed.
@@ -476,7 +476,7 @@ public abstract class Utility {
      * <arguments_signature>::= <argument_signature>*
      *
      * This method converts such a string into a Java type declaration like
-     * `void main(String[])' and throws a `ClassFormatException' when the parsed 
+     * `void main(String[])' and throws a `ClassFormatException' when the parsed
      * type is invalid.
      *
      * @param  signature    Method signature
@@ -485,7 +485,7 @@ public abstract class Utility {
      * @param chopit
      * @param vars
      * @return Java type declaration
-     * @throws  ClassFormatException  
+     * @throws  ClassFormatException
      */
     public static final String methodSignatureToString( String signature, String name,
             String access, boolean chopit, LocalVariableTable vars ) throws ClassFormatException {
@@ -581,8 +581,8 @@ public abstract class Utility {
 
 
     /**
-     * The field signature represents the value of an argument to a function or 
-     * the value of a variable. It is a series of bytes generated by the 
+     * The field signature represents the value of an argument to a function or
+     * the value of a variable. It is a series of bytes generated by the
      * following grammar:
      *
      * <PRE>
@@ -606,7 +606,7 @@ public abstract class Utility {
      * </PRE>
      *
      * This method converts this string into a Java type declaration such as
-     * `String[]' and throws a `ClassFormatException' when the parsed type is 
+     * `String[]' and throws a `ClassFormatException' when the parsed type is
      * invalid.
      *
      * @param  signature  Class signature
@@ -685,7 +685,7 @@ public abstract class Utility {
     /** Convert bytes into hexadecimal string
      *
      * @param bytes an array of bytes to convert to hexadecimal
-     * 
+     *
      * @return bytes as hexadecimal string, e.g. 00 FA 12 ...
      */
     public static final String toHexString( byte[] bytes ) {

==================================================
ByteSequence.java
index 2d68865c57..ff5d5054ef 100644
--- a/java/org/apache/tomcat/util/bcel/util/BCELComparator.java
+++ b/java/org/apache/tomcat/util/bcel/util/BCELComparator.java
@@ -19,7 +19,7 @@ package org.apache.tomcat.util.bcel.util;
 
 /**
  * Used for BCEL comparison strategy
- * 
+ *
  * @author <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
  * @version $Id$
  * @since 5.2
@@ -28,7 +28,7 @@ public interface BCELComparator {
 
     /**
      * Compare two objects and return what THIS.equals(THAT) should return
-     * 
+     *
      * @param THIS
      * @param THAT
      * @return true if and only if THIS equals THAT
@@ -38,7 +38,7 @@ public interface BCELComparator {
 
     /**
      * Return hashcode for THIS.hashCode()
-     * 
+     *
      * @param THIS
      * @return hashcode for THIS.hashCode()
      */

==================================================
AbstractObjectCreationFactory.java
index e0da4da20a..5d55efc3fe 100644
--- a/java/org/apache/tomcat/util/buf/package.html
+++ b/java/org/apache/tomcat/util/buf/package.html
@@ -18,21 +18,21 @@
 <H1>Buffers and Encodings</h1>
 
 This package contains buffers and utils to perform encoding/decoding of buffers. That includes byte to char
-conversions, URL encodings, etc. 
+conversions, URL encodings, etc.
 
 <p>
-Encoding is a critical operation for performance. There are few tricks in this package - the C2B and 
-B2C converters are caching a ISReader/OSWriter and keep everything allocated to do the conversions 
+Encoding is a critical operation for performance. There are few tricks in this package - the C2B and
+B2C converters are caching a ISReader/OSWriter and keep everything allocated to do the conversions
 in any VM without any garbage.
 
 <p>
-This package must accomodate future extensions and additional converters ( most imporant: the nio.charset, 
-which should be detected and used if available ). Also, we do have one hand-written UTF8Decoder, and 
+This package must accomodate future extensions and additional converters ( most imporant: the nio.charset,
+which should be detected and used if available ). Also, we do have one hand-written UTF8Decoder, and
 other tuned encoders could be added.
 
 <p>
 My benchmarks ( I'm costin :-) show only small differences between C2B, B2C and hand-written codders/decoders,
-so UTF8Decoder may be disabled. 
+so UTF8Decoder may be disabled.
 
 <p>
 </body></html>

==================================================
ArrayStack.java
index 78ed8457cc..d315669dd9 100644
--- a/java/org/apache/tomcat/util/digester/AbstractObjectCreationFactory.java
+++ b/java/org/apache/tomcat/util/digester/AbstractObjectCreationFactory.java
@@ -5,15 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
+ */
 package org.apache.tomcat.util.digester;
 
 

==================================================
CallMethodRule.java
index 221bae9219..d0fdaa693e 100644
--- a/java/org/apache/tomcat/util/digester/ArrayStack.java
+++ b/java/org/apache/tomcat/util/digester/ArrayStack.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -43,7 +43,7 @@ import java.util.EmptyStackException;
  */
 public class ArrayStack<E> extends ArrayList<E> {
 
-    /** Ensure serialization compatibility */    
+    /** Ensure serialization compatibility */
     private static final long serialVersionUID = 2130079159931574599L;
 
     /**
@@ -56,7 +56,7 @@ public class ArrayStack<E> extends ArrayList<E> {
 
     /**
      * Constructs a new empty <code>ArrayStack</code> with an initial size.
-     * 
+     *
      * @param initialSize  the initial size to use
      * @throws IllegalArgumentException  if the specified initial size
      *  is negative
@@ -70,7 +70,7 @@ public class ArrayStack<E> extends ArrayList<E> {
      * <p>
      * This method exists for compatibility with <code>java.util.Stack</code>.
      * New users of this class should use <code>isEmpty</code> instead.
-     * 
+     *
      * @return true if the stack is currently empty
      */
     public boolean empty() {

==================================================
CallParamRule.java
index 42123daddf..4bfdec1843 100644
--- a/java/org/apache/tomcat/util/digester/CallMethodRule.java
+++ b/java/org/apache/tomcat/util/digester/CallMethodRule.java
@@ -5,15 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
+ */
 
 
 package org.apache.tomcat.util.digester;
@@ -25,15 +25,15 @@ import org.xml.sax.Attributes;
 
 /**
  * <p>Rule implementation that calls a method on an object on the stack
- * (normally the top/parent object), passing arguments collected from 
+ * (normally the top/parent object), passing arguments collected from
  * subsequent <code>CallParamRule</code> rules or from the body of this
  * element. </p>
  *
- * <p>By using {@link #CallMethodRule(String methodName)} 
+ * <p>By using {@link #CallMethodRule(String methodName)}
  * a method call can be made to a method which accepts no
  * arguments.</p>
  *
- * <p>Incompatible method parameter types are converted 
+ * <p>Incompatible method parameter types are converted
  * using <code>org.apache.commons.beanutils.ConvertUtils</code>.
  * </p>
  *
@@ -43,16 +43,16 @@ import org.xml.sax.Attributes;
  * </a> by default.
  * This increases the kinds of methods successfully and allows primitives
  * to be matched by passing in wrapper classes.
- * There are rare cases when org.apache.commons.beanutils.MethodUtils#invokeExactMethod 
+ * There are rare cases when org.apache.commons.beanutils.MethodUtils#invokeExactMethod
  * (the old default) is required.
  * This method is much stricter in its reflection.
- * Setting the <code>UseExactMatch</code> to true reverts to the use of this 
+ * Setting the <code>UseExactMatch</code> to true reverts to the use of this
  * method.</p>
  *
  * <p>Note that the target method is invoked when the  <i>end</i> of
  * the tag the CallMethodRule fired on is encountered, <i>not</i> when the
  * last parameter becomes available. This implies that rules which fire on
- * tags nested within the one associated with the CallMethodRule will 
+ * tags nested within the one associated with the CallMethodRule will
  * fire before the CallMethodRule invokes the target method. This behaviour is
  * not configurable. </p>
  *
@@ -86,7 +86,7 @@ public class CallMethodRule extends Rule {
      * parameter types (if any) default to java.lang.String.
      *
      * @param targetOffset location of the target object. Positive numbers are
-     * relative to the top of the digester object stack. Negative numbers 
+     * relative to the top of the digester object stack. Negative numbers
      * are relative to the bottom of the stack. Zero implies the top
      * object on the stack.
      * @param methodName Method name of the parent method to call
@@ -99,7 +99,7 @@ public class CallMethodRule extends Rule {
 
         this.targetOffset = targetOffset;
         this.methodName = methodName;
-        this.paramCount = paramCount;        
+        this.paramCount = paramCount;
         if (paramCount == 0) {
             this.paramTypes = new Class[] { String.class };
         } else {
@@ -112,34 +112,34 @@ public class CallMethodRule extends Rule {
     }
 
     /**
-     * Construct a "call method" rule with the specified method name.  
+     * Construct a "call method" rule with the specified method name.
      * The method should accept no parameters.
      *
      * @param methodName Method name of the parent method to call
      */
     public CallMethodRule(String methodName) {
-    
+
         this(0, methodName, 0, (Class[]) null);
-    
+
     }
-    
+
 
     /**
-     * Construct a "call method" rule with the specified method name.  
+     * Construct a "call method" rule with the specified method name.
      * The method should accept no parameters.
      *
      * @param targetOffset location of the target object. Positive numbers are
-     * relative to the top of the digester object stack. Negative numbers 
+     * relative to the top of the digester object stack. Negative numbers
      * are relative to the bottom of the stack. Zero implies the top
      * object on the stack.
      * @param methodName Method name of the parent method to call
      */
     public CallMethodRule(int targetOffset, String methodName) {
-    
+
         this(targetOffset, methodName, 0, (Class[]) null);
-    
+
     }
-    
+
 
     /**
      * Construct a "call method" rule with the specified method name and
@@ -158,7 +158,7 @@ public class CallMethodRule extends Rule {
      */
     public CallMethodRule(
                             String methodName,
-                            int paramCount, 
+                            int paramCount,
                             String paramTypes[]) {
         this(0, methodName, paramCount, paramTypes);
     }
@@ -171,7 +171,7 @@ public class CallMethodRule extends Rule {
      * case the rule will call the specified method with no arguments.
      *
      * @param targetOffset location of the target object. Positive numbers are
-     * relative to the top of the digester object stack. Negative numbers 
+     * relative to the top of the digester object stack. Negative numbers
      * are relative to the bottom of the stack. Zero implies the top
      * object on the stack.
      * @param methodName Method name of the parent method to call
@@ -184,7 +184,7 @@ public class CallMethodRule extends Rule {
      */
     public CallMethodRule(  int targetOffset,
                             String methodName,
-                            int paramCount, 
+                            int paramCount,
                             String paramTypes[]) {
 
         this.targetOffset = targetOffset;
@@ -197,7 +197,7 @@ public class CallMethodRule extends Rule {
             }
         } else {
             // copy the parameter class names into an array
-            // the classes will be loaded when the digester is set 
+            // the classes will be loaded when the digester is set
             this.paramClassNames = new String[paramTypes.length];
             for (int i = 0; i < this.paramClassNames.length; i++) {
                 this.paramClassNames[i] = paramTypes[i];
@@ -225,7 +225,7 @@ public class CallMethodRule extends Rule {
      */
     public CallMethodRule(
                             String methodName,
-                            int paramCount, 
+                            int paramCount,
                             Class<?> paramTypes[]) {
         this(0, methodName, paramCount, paramTypes);
     }
@@ -238,7 +238,7 @@ public class CallMethodRule extends Rule {
      * case the rule will call the specified method with no arguments.
      *
      * @param targetOffset location of the target object. Positive numbers are
-     * relative to the top of the digester object stack. Negative numbers 
+     * relative to the top of the digester object stack. Negative numbers
      * are relative to the bottom of the stack. Zero implies the top
      * object on the stack.
      * @param methodName Method name of the parent method to call
@@ -252,7 +252,7 @@ public class CallMethodRule extends Rule {
      */
     public CallMethodRule(  int targetOffset,
                             String methodName,
-                            int paramCount, 
+                            int paramCount,
                             Class<?> paramTypes[]) {
 
         this.targetOffset = targetOffset;
@@ -282,7 +282,7 @@ public class CallMethodRule extends Rule {
     protected String bodyText = null;
 
 
-    /** 
+    /**
      * location of the target object for the call, relative to the
      * top of the digester object stack. The default value of zero
      * means the target object is the one on top of the stack.
@@ -313,14 +313,14 @@ public class CallMethodRule extends Rule {
      * This attribute allows creation of the classes to be postponed until the digester is set.
      */
     protected String paramClassNames[] = null;
-    
+
     /**
      * Should <code>MethodUtils.invokeExactMethod</code> be used for reflection.
      */
     protected boolean useExactMatch = false;
-    
+
     // --------------------------------------------------------- Public Methods
-    
+
     /**
      * Should <code>MethodUtils.invokeExactMethod</code>
      * be used for the reflection.
@@ -328,13 +328,13 @@ public class CallMethodRule extends Rule {
     public boolean getUseExactMatch() {
         return useExactMatch;
     }
-    
+
     /**
      * Set whether <code>MethodUtils.invokeExactMethod</code>
      * should be used for the reflection.
-     */    
+     */
     public void setUseExactMatch(boolean useExactMatch)
-    { 
+    {
         this.useExactMatch = useExactMatch;
     }
 
@@ -366,10 +366,10 @@ public class CallMethodRule extends Rule {
     /**
      * Process the start of this element.
      *
-     * @param namespace the namespace URI of the matching element, or an 
+     * @param namespace the namespace URI of the matching element, or an
      *   empty string if the parser is not namespace aware or the element has
      *   no namespace
-     * @param name the local name if the parser is namespace aware, or just 
+     * @param name the local name if the parser is namespace aware, or just
      *   the element name otherwise
      * @param attributes The attribute list for this element
      */
@@ -392,10 +392,10 @@ public class CallMethodRule extends Rule {
     /**
      * Process the body text of this element.
      *
-     * @param namespace the namespace URI of the matching element, or an 
+     * @param namespace the namespace URI of the matching element, or an
      *   empty string if the parser is not namespace aware or the element has
      *   no namespace
-     * @param name the local name if the parser is namespace aware, or just 
+     * @param name the local name if the parser is namespace aware, or just
      *   the element name otherwise
      * @param bodyText The body text of this element
      */
@@ -412,11 +412,11 @@ public class CallMethodRule extends Rule {
 
     /**
      * Process the end of this element.
-     * 
-     * @param namespace the namespace URI of the matching element, or an 
+     *
+     * @param namespace the namespace URI of the matching element, or an
      *   empty string if the parser is not namespace aware or the element has
      *   no namespace
-     * @param name the local name if the parser is namespace aware, or just 
+     * @param name the local name if the parser is namespace aware, or just
      *   the element name otherwise
      */
     @Override
@@ -427,13 +427,13 @@ public class CallMethodRule extends Rule {
         if (paramCount > 0) {
 
             parameters = (Object[]) digester.popParams();
-            
+
             if (digester.log.isTraceEnabled()) {
                 for (int i=0,size=parameters.length;i<size;i++) {
                     digester.log.trace("[CallMethodRule](" + i + ")" + parameters[i]) ;
                 }
             }
-            
+
             // In the case where the parameter for the method
             // is taken from an attribute, and that attribute
             // isn't actually defined in the source XML file,
@@ -463,16 +463,16 @@ public class CallMethodRule extends Rule {
 
         // Construct the parameter values array we will need
         // We only do the conversion if the param value is a String and
-        // the specified paramType is not String. 
+        // the specified paramType is not String.
         Object paramValues[] = new Object[paramTypes.length];
         for (int i = 0; i < paramTypes.length; i++) {
-            // convert nulls and convert stringy parameters 
+            // convert nulls and convert stringy parameters
             // for non-stringy param types
             if(
                 parameters[i] == null ||
-                 (parameters[i] instanceof String && 
+                 (parameters[i] instanceof String &&
                    !String.class.isAssignableFrom(paramTypes[i]))) {
-                
+
                 paramValues[i] =
                         IntrospectionUtils.convert((String) parameters[i], paramTypes[i]);
             } else {
@@ -487,7 +487,7 @@ public class CallMethodRule extends Rule {
         } else {
             target = digester.peek( digester.getCount() + targetOffset );
         }
-        
+
         if (target == null) {
             StringBuilder sb = new StringBuilder();
             sb.append("[CallMethodRule]{");
@@ -500,7 +500,7 @@ public class CallMethodRule extends Rule {
             sb.append(")");
             throw new org.xml.sax.SAXException(sb.toString());
         }
-        
+
         // Invoke the required method on the top object
         if (digester.log.isDebugEnabled()) {
             StringBuilder sb = new StringBuilder("[CallMethodRule]{");
@@ -530,7 +530,7 @@ public class CallMethodRule extends Rule {
             digester.log.debug(sb.toString());
         }
         Object result = IntrospectionUtils.callMethodN(target, methodName,
-                paramValues, paramTypes);   
+                paramValues, paramTypes);
         processMethodCallResult(result);
     }
 
@@ -546,7 +546,7 @@ public class CallMethodRule extends Rule {
     }
 
     /**
-     * Subclasses may override this method to perform additional processing of the 
+     * Subclasses may override this method to perform additional processing of the
      * invoked method's result.
      *
      * @param result the Object returned by the method invoked, possibly null

==================================================
Digester.java
index ec19fd1867..90c9cba268 100644
--- a/java/org/apache/tomcat/util/digester/CallParamRule.java
+++ b/java/org/apache/tomcat/util/digester/CallParamRule.java
@@ -5,15 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
+ */
 
 
 package org.apache.tomcat.util.digester;
@@ -23,7 +23,7 @@ import org.xml.sax.Attributes;
 
 
 /**
- * <p>Rule implementation that saves a parameter for use by a surrounding 
+ * <p>Rule implementation that saves a parameter for use by a surrounding
  * <code>CallMethodRule<code>.</p>
  *
  * <p>This parameter may be:
@@ -32,9 +32,9 @@ import org.xml.sax.Attributes;
  * See {@link #CallParamRule(int paramIndex, String attributeName)}
  * <li>from current the element body
  * See {@link #CallParamRule(int paramIndex)}
- * <li>from the top object on the stack. 
+ * <li>from the top object on the stack.
  * See {@link #CallParamRule(int paramIndex, boolean fromStack)}
- * <li>the current path being processed (separate <code>Rule</code>). 
+ * <li>the current path being processed (separate <code>Rule</code>).
  * See {@link PathCallParamRule}
  * </ul>
  * </p>
@@ -78,29 +78,29 @@ public class CallParamRule extends Rule {
      *
      * @param paramIndex The zero-relative parameter number
      * @param fromStack should this parameter be taken from the top of the stack?
-     */    
+     */
     public CallParamRule(int paramIndex, boolean fromStack) {
-    
-        this.paramIndex = paramIndex;  
+
+        this.paramIndex = paramIndex;
         this.fromStack = fromStack;
 
     }
-    
+
     /**
      * Constructs a "call parameter" rule which sets a parameter from the stack.
      * If the stack contains too few objects, then the parameter will be set to null.
      *
      * @param paramIndex The zero-relative parameter number
-     * @param stackIndex the index of the object which will be passed as a parameter. 
+     * @param stackIndex the index of the object which will be passed as a parameter.
      * The zeroth object is the top of the stack, 1 is the next object down and so on.
-     */    
+     */
     public CallParamRule(int paramIndex, int stackIndex) {
-    
-        this.paramIndex = paramIndex;  
+
+        this.paramIndex = paramIndex;
         this.fromStack = true;
         this.stackIndex = stackIndex;
     }
- 
+
     // ----------------------------------------------------- Instance Variables
 
 
@@ -120,13 +120,13 @@ public class CallParamRule extends Rule {
      * Is the parameter to be set from the stack?
      */
     protected boolean fromStack = false;
-    
+
     /**
      * The position of the object from the top of the stack
      */
     protected int stackIndex = 0;
 
-    /** 
+    /**
      * Stack is used to allow nested body text to be processed.
      * Lazy creation.
      */
@@ -138,10 +138,10 @@ public class CallParamRule extends Rule {
     /**
      * Process the start of this element.
      *
-     * @param namespace the namespace URI of the matching element, or an 
+     * @param namespace the namespace URI of the matching element, or an
      *   empty string if the parser is not namespace aware or the element has
      *   no namespace
-     * @param name the local name if the parser is namespace aware, or just 
+     * @param name the local name if the parser is namespace aware, or just
      *   the element name otherwise
      * @param attributes The attribute list for this element
      */
@@ -150,31 +150,31 @@ public class CallParamRule extends Rule {
             throws Exception {
 
         Object param = null;
-        
+
         if (attributeName != null) {
-        
+
             param = attributes.getValue(attributeName);
-            
+
         } else if(fromStack) {
-        
+
             param = digester.peek(stackIndex);
-            
+
             if (digester.log.isDebugEnabled()) {
-            
+
                 StringBuilder sb = new StringBuilder("[CallParamRule]{");
                 sb.append(digester.match);
                 sb.append("} Save from stack; from stack?").append(fromStack);
                 sb.append("; object=").append(param);
                 digester.log.debug(sb.toString());
-            }   
+            }
         }
-        
+
         // Have to save the param object to the param stack frame here.
         // Can't wait until end(). Otherwise, the object will be lost.
-        // We can't save the object as instance variables, as 
+        // We can't save the object as instance variables, as
         // the instance variables will be overwritten
         // if this CallParamRule is reused in subsequent nesting.
-        
+
         if(param != null) {
             Object parameters[] = (Object[]) digester.peekParams();
             parameters[paramIndex] = param;
@@ -185,10 +185,10 @@ public class CallParamRule extends Rule {
     /**
      * Process the body text of this element.
      *
-     * @param namespace the namespace URI of the matching element, or an 
+     * @param namespace the namespace URI of the matching element, or an
      *   empty string if the parser is not namespace aware or the element has
      *   no namespace
-     * @param name the local name if the parser is namespace aware, or just 
+     * @param name the local name if the parser is namespace aware, or just
      *   the element name otherwise
      * @param bodyText The body text of this element
      */
@@ -207,7 +207,7 @@ public class CallParamRule extends Rule {
         }
 
     }
-    
+
     /**
      * Process any body texts now.
      */

==================================================
FactoryCreateRule.java
index 6576e3de3d..66d6b0bd71 100644
--- a/java/org/apache/tomcat/util/digester/Digester.java
+++ b/java/org/apache/tomcat/util/digester/Digester.java
@@ -5,15 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
+ */
 
 package org.apache.tomcat.util.digester;
 
@@ -74,9 +74,9 @@ import org.xml.sax.helpers.DefaultHandler;
 
 public class Digester extends DefaultHandler {
 
-    
-    // ---------------------------------------------------------- Static Fields    
-    private static class SystemPropertySource 
+
+    // ---------------------------------------------------------- Static Fields
+    private static class SystemPropertySource
         implements IntrospectionUtils.PropertySource {
         @Override
         public String getProperty( String key ) {
@@ -84,9 +84,9 @@ public class Digester extends DefaultHandler {
         }
     }
 
-    protected static IntrospectionUtils.PropertySource source[] = 
+    protected static IntrospectionUtils.PropertySource source[] =
         new IntrospectionUtils.PropertySource[] { new SystemPropertySource() };
-    
+
     static {
         String className = System.getProperty("org.apache.tomcat.util.digester.PROPERTY_SOURCE");
         if (className!=null) {
@@ -178,12 +178,12 @@ public class Digester extends DefaultHandler {
      * in the input is entered, the matching rules are pushed onto this
      * stack. After the end tag is reached, the matches are popped again.
      * The depth of is stack is therefore exactly the same as the current
-     * "nesting" level of the input xml. 
+     * "nesting" level of the input xml.
      *
      * @since 1.6
      */
     protected ArrayStack<List<Rule>> matches = new ArrayStack<List<Rule>>(10);
-    
+
     /**
      * The class loader to use for instantiating application objects.
      * If not specified, the context class loader, or the class loader
@@ -203,7 +203,7 @@ public class Digester extends DefaultHandler {
      * The EntityResolver used by the SAX parser. By default it use this class
      */
     protected EntityResolver entityResolver;
-    
+
     /**
      * The URLs of entityValidator that have been registered, keyed by the public
      * identifier that corresponds.
@@ -319,7 +319,7 @@ public class Digester extends DefaultHandler {
      */
     protected boolean rulesValidation = false;
 
-    
+
     /**
      * Fake attributes map (attributes are often used for object creation).
      */
@@ -338,12 +338,12 @@ public class Digester extends DefaultHandler {
      */
     protected Log saxLog =
         LogFactory.getLog("org.apache.tomcat.util.digester.Digester.sax");
-    
-        
+
+
     /** Stacks used for interrule communication, indexed by name String */
     private HashMap<String,ArrayStack<Object>> stacksByName =
         new HashMap<String,ArrayStack<Object>>();
-    
+
     // ------------------------------------------------------------- Properties
 
     /**
@@ -354,7 +354,7 @@ public class Digester extends DefaultHandler {
      * @param prefix Prefix to look up
      */
     public String findNamespaceURI(String prefix) {
-        
+
         ArrayStack<String> stack = namespaces.get(prefix);
         if (stack == null) {
             return (null);
@@ -458,9 +458,9 @@ public class Digester extends DefaultHandler {
 
     /**
      * Return the SAXParserFactory we will use, creating one if necessary.
-     * @throws ParserConfigurationException 
-     * @throws SAXNotSupportedException 
-     * @throws SAXNotRecognizedException 
+     * @throws ParserConfigurationException
+     * @throws SAXNotSupportedException
+     * @throws SAXNotRecognizedException
      */
     public SAXParserFactory getFactory()
     throws SAXNotRecognizedException, SAXNotSupportedException,
@@ -566,10 +566,10 @@ public class Digester extends DefaultHandler {
      * @since 1.6
      */
     public Log getSAXLogger() {
-        
+
         return saxLog;
     }
-    
+
 
     /**
      * Sets the logger used for logging SAX-related information.
@@ -577,9 +577,9 @@ public class Digester extends DefaultHandler {
      * @param saxLog Log, not null
      *
      * @since 1.6
-     */    
+     */
     public void setSAXLogger(Log saxLog) {
-    
+
         this.saxLog = saxLog;
     }
 
@@ -614,7 +614,7 @@ public class Digester extends DefaultHandler {
 
     }
 
-    
+
     /**
      * Set the public id of the current file being parse.
      * @param publicId the DTD/Schema public's id.
@@ -622,8 +622,8 @@ public class Digester extends DefaultHandler {
     public void setPublicId(String publicId){
         this.publicId = publicId;
     }
-    
-    
+
+
     /**
      * Return the public identifier of the DTD we are currently
      * parsing under, if any.
@@ -745,7 +745,7 @@ public class Digester extends DefaultHandler {
 
     }
 
-    
+
     /**
      * Set the <code>Rules</code> implementation object containing our
      * rules collection and associated matching policy.
@@ -878,24 +878,24 @@ public class Digester extends DefaultHandler {
     /**
      * Return the XMLReader to be used for parsing the input document.
      *
-     * FIX ME: there is a bug in JAXP/XERCES that prevent the use of a 
+     * FIX ME: there is a bug in JAXP/XERCES that prevent the use of a
      * parser that contains a schema with a DTD.
      * @exception SAXException if no XMLReader can be instantiated
      */
     public XMLReader getXMLReader() throws SAXException {
         if (reader == null){
             reader = getParser().getXMLReader();
-        }        
-                               
-        reader.setDTDHandler(this);           
-        reader.setContentHandler(this);        
-        
+        }
+
+        reader.setDTDHandler(this);
+        reader.setContentHandler(this);
+
         if (entityResolver == null){
             reader.setEntityResolver(this);
         } else {
-            reader.setEntityResolver(entityResolver);           
+            reader.setEntityResolver(entityResolver);
         }
-        
+
         reader.setErrorHandler(this);
         return reader;
     }
@@ -998,7 +998,7 @@ public class Digester extends DefaultHandler {
         // Parse system properties
         bodyText = updateBodyText(bodyText);
 
-        // the actual element name is either in localName or qName, depending 
+        // the actual element name is either in localName or qName, depending
         // on whether the parser is namespace aware
         String name = localName;
         if ((name == null) || (name.length() < 1)) {
@@ -1204,7 +1204,7 @@ public class Digester extends DefaultHandler {
             saxLog.debug("startDocument()");
         }
 
-        // ensure that the digester is properly configured, as 
+        // ensure that the digester is properly configured, as
         // the digester could be used as a SAX ContentHandler
         // rather than via the parse() methods.
         configure();
@@ -1221,7 +1221,7 @@ public class Digester extends DefaultHandler {
      * @param qName The qualified name (with prefix), or the empty
      *   string if qualified names are not available.\
      * @param list The attributes attached to the element. If there are
-     *   no attributes, it shall be an empty Attributes object. 
+     *   no attributes, it shall be an empty Attributes object.
      * @exception SAXException if a parsing error is to be reported
      */
     @Override
@@ -1229,15 +1229,15 @@ public class Digester extends DefaultHandler {
                              String qName, Attributes list)
             throws SAXException {
         boolean debug = log.isDebugEnabled();
-        
+
         if (saxLog.isDebugEnabled()) {
             saxLog.debug("startElement(" + namespaceURI + "," + localName + "," +
                     qName + ")");
         }
-        
+
         // Parse system properties
         list = updateAttributes(list);
-        
+
         // Save the body text accumulated for our surrounding element
         bodyTexts.push(bodyText);
         if (debug) {
@@ -1245,7 +1245,7 @@ public class Digester extends DefaultHandler {
         }
         bodyText = new StringBuilder();
 
-        // the actual element name is either in localName or qName, depending 
+        // the actual element name is either in localName or qName, depending
         // on whether the parser is namespace aware
         String name = localName;
         if ((name == null) || (name.length() < 1)) {
@@ -1370,8 +1370,8 @@ public class Digester extends DefaultHandler {
     public void setEntityResolver(EntityResolver entityResolver){
         this.entityResolver = entityResolver;
     }
-    
-    
+
+
     /**
      * Return the Entity Resolver used by the SAX parser.
      * @return Return the Entity Resolver used by the SAX parser.
@@ -1387,47 +1387,47 @@ public class Digester extends DefaultHandler {
      * @param systemId The system identifier of the entity being referenced
      *
      * @exception SAXException if a parsing exception occurs
-     * 
+     *
      */
     @Override
     public InputSource resolveEntity(String publicId, String systemId)
-            throws SAXException {     
-                
+            throws SAXException {
+
         if (saxLog.isDebugEnabled()) {
             saxLog.debug("resolveEntity('" + publicId + "', '" + systemId + "')");
         }
-        
+
         if (publicId != null)
             this.publicId = publicId;
-                                       
+
         // Has this system identifier been registered?
         String entityURL = null;
         if (publicId != null) {
             entityURL = entityValidator.get(publicId);
         }
-         
-        if (entityURL == null) { 
+
+        if (entityURL == null) {
             if (systemId == null) {
                 // cannot resolve
                 if (log.isDebugEnabled()) {
                     log.debug(" Cannot resolve entity: '" + publicId + "'");
                 }
                 return (null);
-                
+
             } else {
                 // try to resolve using system ID
                 if (log.isDebugEnabled()) {
                     log.debug(" Trying to resolve using system ID '" + systemId + "'");
-                } 
+                }
                 entityURL = systemId;
             }
         }
-        
+
         // Return an input source to our alternative URL
         if (log.isDebugEnabled()) {
             log.debug(" Resolving to alternate DTD '" + entityURL + "'");
-        }  
-        
+        }
+
         try {
             return (new InputSource(entityURL));
         } catch (Exception e) {
@@ -1495,7 +1495,7 @@ public class Digester extends DefaultHandler {
             log.warn("Parse Warning Error at line " + exception.getLineNumber() +
                 " column " + exception.getColumnNumber() + ": " +
                 exception.getMessage(), exception);
-            
+
             errorHandler.warning(exception);
         }
 
@@ -1521,7 +1521,7 @@ public class Digester extends DefaultHandler {
         getXMLReader().parse(input);
         return (root);
 
-    }   
+    }
     /**
      * Parse the content of the specified input source using this Digester.
      * Returns the root element from the object stack (if any).
@@ -1532,7 +1532,7 @@ public class Digester extends DefaultHandler {
      * @exception SAXException if a parsing exception occurs
      */
     public Object parse(InputSource input) throws IOException, SAXException {
- 
+
         configure();
         getXMLReader().parse(input);
         return (root);
@@ -1602,18 +1602,18 @@ public class Digester extends DefaultHandler {
      * This must be called before the first call to <code>parse()</code>.
      * </p><p>
      * <code>Digester</code> contains an internal <code>EntityResolver</code>
-     * implementation. This maps <code>PUBLICID</code>'s to URLs 
+     * implementation. This maps <code>PUBLICID</code>'s to URLs
      * (from which the resource will be loaded). A common use case for this
-     * method is to register local URLs (possibly computed at runtime by a 
+     * method is to register local URLs (possibly computed at runtime by a
      * classloader) for DTDs. This allows the performance advantage of using
      * a local version without having to ensure every <code>SYSTEM</code>
      * URI on every processed xml document is local. This implementation provides
      * only basic functionality. If more sophisticated features are required,
      * using {@link #setEntityResolver} to set a custom resolver is recommended.
      * </p><p>
-     * <strong>Note:</strong> This method will have no effect when a custom 
-     * <code>EntityResolver</code> has been set. (Setting a custom 
-     * <code>EntityResolver</code> overrides the internal implementation.) 
+     * <strong>Note:</strong> This method will have no effect when a custom
+     * <code>EntityResolver</code> has been set. (Setting a custom
+     * <code>EntityResolver</code> overrides the internal implementation.)
      * </p>
      * @param publicId Public identifier of the DTD to be resolved
      * @param entityURL The URL to use for reading this DTD
@@ -1726,7 +1726,7 @@ public class Digester extends DefaultHandler {
         addRule(pattern,
                 new CallMethodRule(
                                     methodName,
-                                    paramCount, 
+                                    paramCount,
                                     paramTypes));
 
     }
@@ -1755,7 +1755,7 @@ public class Digester extends DefaultHandler {
         addRule(pattern,
                 new CallMethodRule(
                                     methodName,
-                                    paramCount, 
+                                    paramCount,
                                     paramTypes));
 
     }
@@ -1798,18 +1798,18 @@ public class Digester extends DefaultHandler {
 
     /**
      * Add a "call parameter" rule.
-     * This will either take a parameter from the stack 
-     * or from the current element body text. 
+     * This will either take a parameter from the stack
+     * or from the current element body text.
      *
      * @param paramIndex The zero-relative parameter number
      * @param fromStack Should the call parameter be taken from the top of the stack?
      * @see CallParamRule
-     */    
+     */
     public void addCallParam(String pattern, int paramIndex, boolean fromStack) {
-    
+
         addRule(pattern,
                 new CallParamRule(paramIndex, fromStack));
-      
+
     }
 
     /**
@@ -1820,16 +1820,16 @@ public class Digester extends DefaultHandler {
      * @param stackIndex set the call parameter to the stackIndex'th object down the stack,
      * where 0 is the top of the stack, 1 the next element down and so on
      * @see CallMethodRule
-     */    
+     */
     public void addCallParam(String pattern, int paramIndex, int stackIndex) {
-    
+
         addRule(pattern,
                 new CallParamRule(paramIndex, stackIndex));
-      
+
     }
-    
+
     /**
-     * Add a "call parameter" rule that sets a parameter from the current 
+     * Add a "call parameter" rule that sets a parameter from the current
      * <code>Digester</code> matching path.
      * This is sometimes useful when using rules that support wildcards.
      *
@@ -1840,9 +1840,9 @@ public class Digester extends DefaultHandler {
     public void addCallParamPath(String pattern,int paramIndex) {
         addRule(pattern, new PathCallParamRule(paramIndex));
     }
-    
+
     /**
-     * Add a "call parameter" rule that sets a parameter from a 
+     * Add a "call parameter" rule that sets a parameter from a
      * caller-provided object. This can be used to pass constants such as
      * strings to methods; it can also be used to pass mutable objects,
      * providing ways for objects to do things like "register" themselves
@@ -1860,15 +1860,15 @@ public class Digester extends DefaultHandler {
      * @see CallMethodRule
      *
      * @since 1.6
-     */    
-    public void addObjectParam(String pattern, int paramIndex, 
+     */
+    public void addObjectParam(String pattern, int paramIndex,
                                Object paramObj) {
-    
+
         addRule(pattern,
                 new ObjectParamRule(paramIndex, paramObj));
-      
+
     }
-    
+
     /**
      * Add a "factory create" rule for the specified parameters.
      * Exceptions thrown during the object creation process will be propagated.
@@ -1961,7 +1961,7 @@ public class Digester extends DefaultHandler {
      * @see FactoryCreateRule
      */
     public void addFactoryCreate(
-                                    String pattern, 
+                                    String pattern,
                                     String className,
                                     boolean ignoreCreateExceptions) {
 
@@ -1982,7 +1982,7 @@ public class Digester extends DefaultHandler {
      * @see FactoryCreateRule
      */
     public void addFactoryCreate(
-                                    String pattern, 
+                                    String pattern,
                                     Class<?> clazz,
                                     boolean ignoreCreateExceptions) {
 
@@ -2005,7 +2005,7 @@ public class Digester extends DefaultHandler {
      * @see FactoryCreateRule
      */
     public void addFactoryCreate(
-                                String pattern, 
+                                String pattern,
                                 String className,
                                 String attributeName,
                                 boolean ignoreCreateExceptions) {
@@ -2029,7 +2029,7 @@ public class Digester extends DefaultHandler {
      * @see FactoryCreateRule
      */
     public void addFactoryCreate(
-                                    String pattern, 
+                                    String pattern,
                                     Class<?> clazz,
                                     String attributeName,
                                     boolean ignoreCreateExceptions) {
@@ -2216,7 +2216,7 @@ public class Digester extends DefaultHandler {
      * @see SetPropertiesRule
      */
     public void addSetProperties(
-                                String pattern, 
+                                String pattern,
                                 String attributeName,
                                 String propertyName) {
 
@@ -2235,7 +2235,7 @@ public class Digester extends DefaultHandler {
      * @see SetPropertiesRule
      */
     public void addSetProperties(
-                                String pattern, 
+                                String pattern,
                                 String [] attributeNames,
                                 String [] propertyNames) {
 
@@ -2303,7 +2303,7 @@ public class Digester extends DefaultHandler {
      * Clear the current contents of the object stack.
      * <p>
      * Calling this method <i>might</i> allow another document of the same type
-     * to be correctly parsed. However this method was not intended for this 
+     * to be correctly parsed. However this method was not intended for this
      * purpose. In general, a separate Digester object should be created for
      * each document to be parsed.
      */
@@ -2317,10 +2317,10 @@ public class Digester extends DefaultHandler {
         log = null;
         saxLog = null;
         configured = false;
-        
+
     }
 
-    
+
     public void reset() {
         root = null;
         setErrorHandler(null);
@@ -2397,7 +2397,7 @@ public class Digester extends DefaultHandler {
     /**
      * Pushes the given object onto the stack with the given name.
      * If no stack already exists with the given name then one will be created.
-     * 
+     *
      * @param stackName the name of the stack onto which the object should be pushed
      * @param value the Object to be pushed onto the named stack.
      *
@@ -2417,9 +2417,9 @@ public class Digester extends DefaultHandler {
      *
      * <p><strong>Note:</strong> a stack is considered empty
      * if no objects have been pushed onto it yet.</p>
-     * 
+     *
      * @param stackName the name of the stack from which the top value is to be popped
-     * @return the top <code>Object</code> on the stack or or null if the stack is either 
+     * @return the top <code>Object</code> on the stack or or null if the stack is either
      * empty or has not been created yet
      * @throws EmptyStackException if the named stack is empty
      *
@@ -2433,14 +2433,14 @@ public class Digester extends DefaultHandler {
                 log.debug("Stack '" + stackName + "' is empty");
             }
             throw new EmptyStackException();
-            
+
         } else {
-        
+
             result = namedStack.pop();
         }
         return result;
     }
-    
+
     /**
      * <p>Gets the top object from the stack with the given name.
      * This method does not remove the object from the stack.
@@ -2449,9 +2449,9 @@ public class Digester extends DefaultHandler {
      * if no objects have been pushed onto it yet.</p>
      *
      * @param stackName the name of the stack to be peeked
-     * @return the top <code>Object</code> on the stack or null if the stack is either 
+     * @return the top <code>Object</code> on the stack or null if the stack is either
      * empty or has not been created yet
-     * @throws EmptyStackException if the named stack is empty 
+     * @throws EmptyStackException if the named stack is empty
      *
      * @since 1.6
      */
@@ -2461,11 +2461,11 @@ public class Digester extends DefaultHandler {
         if (namedStack == null ) {
             if (log.isDebugEnabled()) {
                 log.debug("Stack '" + stackName + "' is empty");
-            }        
+            }
             throw new EmptyStackException();
-        
+
         } else {
-        
+
             result = namedStack.peek();
         }
         return result;
@@ -2475,9 +2475,9 @@ public class Digester extends DefaultHandler {
      * <p>Is the stack with the given name empty?</p>
      * <p><strong>Note:</strong> a stack is considered empty
      * if no objects have been pushed onto it yet.</p>
-     * @param stackName the name of the stack whose emptiness 
+     * @param stackName the name of the stack whose emptiness
      * should be evaluated
-     * @return true if the given stack if empty 
+     * @return true if the given stack if empty
      *
      * @since 1.6
      */
@@ -2489,19 +2489,19 @@ public class Digester extends DefaultHandler {
         }
         return result;
     }
-    
+
     /**
-     * When the Digester is being used as a SAXContentHandler, 
+     * When the Digester is being used as a SAXContentHandler,
      * this method allows you to access the root object that has been
      * created after parsing.
-     * 
+     *
      * @return the root object that has been created after parsing
      *  or null if the digester has not parsed any XML yet.
      */
     public Object getRoot() {
         return root;
     }
-    
+
 
     // ------------------------------------------------ Parameter Stack Methods
 
@@ -2519,7 +2519,7 @@ public class Digester extends DefaultHandler {
      * <p>
      * <strong>Note</strong> This method may be called more than once.
      * Once only initialization code should be placed in {@link #initialize}
-     * or the code should take responsibility by checking and setting the 
+     * or the code should take responsibility by checking and setting the
      * {@link #configured} flag.
      * </p>
      */
@@ -2541,19 +2541,19 @@ public class Digester extends DefaultHandler {
         configured = true;
 
     }
-    
+
     /**
      * <p>
      * Provides a hook for lazy initialization of this <code>Digester</code>
-     * instance.  
+     * instance.
      * The default implementation does nothing, but subclasses
      * can override as needed.
      * Digester (by default) only calls this method once.
      * </p>
      *
      * <p>
-     * <strong>Note</strong> This method will be called by {@link #configure} 
-     * only when the {@link #configured} flag is false. 
+     * <strong>Note</strong> This method will be called by {@link #configure}
+     * only when the {@link #configured} flag is false.
      * Subclasses that override <code>configure</code> or who set <code>configured</code>
      * may find that this method may be called more than once.
      * </p>
@@ -2565,7 +2565,7 @@ public class Digester extends DefaultHandler {
         // Perform lazy initialization as needed
         // Nothing required by default
 
-    }    
+    }
 
     // -------------------------------------------------------- Package Methods
 
@@ -2584,7 +2584,7 @@ public class Digester extends DefaultHandler {
      * <p>Return the top object on the parameters stack without removing it.  If there are
      * no objects on the stack, return <code>null</code>.</p>
      *
-     * <p>The parameters stack is used to store <code>CallMethodRule</code> parameters. 
+     * <p>The parameters stack is used to store <code>CallMethodRule</code> parameters.
      * See {@link #params}.</p>
      */
     public Object peekParams() {
@@ -2604,7 +2604,7 @@ public class Digester extends DefaultHandler {
      * and [getCount()-1] is the bottom element.  If the specified index
      * is out of range, return <code>null</code>.</p>
      *
-     * <p>The parameters stack is used to store <code>CallMethodRule</code> parameters. 
+     * <p>The parameters stack is used to store <code>CallMethodRule</code> parameters.
      * See {@link #params}.</p>
      *
      * @param n Index of the desired element, where 0 is the top of the stack,
@@ -2626,7 +2626,7 @@ public class Digester extends DefaultHandler {
      * <p>Pop the top object off of the parameters stack, and return it.  If there are
      * no objects on the stack, return <code>null</code>.</p>
      *
-     * <p>The parameters stack is used to store <code>CallMethodRule</code> parameters. 
+     * <p>The parameters stack is used to store <code>CallMethodRule</code> parameters.
      * See {@link #params}.</p>
      */
     public Object popParams() {
@@ -2647,7 +2647,7 @@ public class Digester extends DefaultHandler {
     /**
      * <p>Push a new object onto the top of the parameters stack.</p>
      *
-     * <p>The parameters stack is used to store <code>CallMethodRule</code> parameters. 
+     * <p>The parameters stack is used to store <code>CallMethodRule</code> parameters.
      * See {@link #params}.</p>
      *
      * @param object The new object
@@ -2716,7 +2716,7 @@ public class Digester extends DefaultHandler {
     public SAXException createSAXException(String message) {
         return createSAXException(message, null);
     }
-    
+
 
     // ------------------------------------------------------- Private Methods
 
@@ -2731,13 +2731,13 @@ public class Digester extends DefaultHandler {
         if (list.getLength() == 0) {
             return list;
         }
-        
+
         AttributesImpl newAttrs = new AttributesImpl(list);
         int nAttributes = newAttrs.getLength();
         for (int i = 0; i < nAttributes; ++i) {
             String value = newAttrs.getValue(i);
             try {
-                String newValue = 
+                String newValue =
                     IntrospectionUtils.replaceProperties(value, null, source);
                 if (value != newValue) {
                     newAttrs.setValue(i, newValue);

==================================================
GenericParser.java
index cb9c66d7ac..389ca2948c 100644
--- a/java/org/apache/tomcat/util/digester/FactoryCreateRule.java
+++ b/java/org/apache/tomcat/util/digester/FactoryCreateRule.java
@@ -5,15 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
+ */
 
 
 package org.apache.tomcat.util.digester;
@@ -35,7 +35,7 @@ import org.xml.sax.Attributes;
 public class FactoryCreateRule extends Rule {
 
     // ----------------------------------------------------------- Fields
-    
+
     /** Should exceptions thrown by the factory be ignored? */
     private boolean ignoreCreateExceptions;
     /** Stock to manage */
@@ -127,7 +127,7 @@ public class FactoryCreateRule extends Rule {
         this(creationFactory, false);
 
     }
-    
+
     /**
      * Construct a factory create rule that will use the specified
      * class name to create an {@link ObjectCreationFactory} which will
@@ -175,7 +175,7 @@ public class FactoryCreateRule extends Rule {
      *  creation factory will be ignored.
      */
     public FactoryCreateRule(
-                                String className, 
+                                String className,
                                 String attributeName,
                                 boolean ignoreCreateExceptions) {
 
@@ -199,7 +199,7 @@ public class FactoryCreateRule extends Rule {
      *  creation factory will be ignored.
      */
     public FactoryCreateRule(
-                                Class<?> clazz, 
+                                Class<?> clazz,
                                 String attributeName,
                                 boolean ignoreCreateExceptions) {
 
@@ -217,7 +217,7 @@ public class FactoryCreateRule extends Rule {
      *  creation factory will be ignored.
      */
     public FactoryCreateRule(
-                            ObjectCreationFactory creationFactory, 
+                            ObjectCreationFactory creationFactory,
                             boolean ignoreCreateExceptions) {
 
         this.creationFactory = creationFactory;
@@ -258,23 +258,23 @@ public class FactoryCreateRule extends Rule {
      */
     @Override
     public void begin(String namespace, String name, Attributes attributes) throws Exception {
-        
+
         if (ignoreCreateExceptions) {
-        
+
             if (exceptionIgnoredStack == null) {
                 exceptionIgnoredStack = new ArrayStack<Boolean>();
             }
-            
+
             try {
                 Object instance = getFactory(attributes).createObject(attributes);
-                
+
                 if (digester.log.isDebugEnabled()) {
                     digester.log.debug("[FactoryCreateRule]{" + digester.match +
                             "} New " + instance.getClass().getName());
                 }
                 digester.push(instance);
                 exceptionIgnoredStack.push(Boolean.FALSE);
-                
+
             } catch (Exception e) {
                 // log message and error
                 if (digester.log.isInfoEnabled()) {
@@ -286,10 +286,10 @@ public class FactoryCreateRule extends Rule {
                 }
                 exceptionIgnoredStack.push(Boolean.TRUE);
             }
-            
+
         } else {
             Object instance = getFactory(attributes).createObject(attributes);
-            
+
             if (digester.log.isDebugEnabled()) {
                 digester.log.debug("[FactoryCreateRule]{" + digester.match +
                         "} New " + instance.getClass().getName());
@@ -304,14 +304,14 @@ public class FactoryCreateRule extends Rule {
      */
     @Override
     public void end(String namespace, String name) throws Exception {
-        
-        // check if object was created 
+
+        // check if object was created
         // this only happens if an exception was thrown and we're ignoring them
         if (
                 ignoreCreateExceptions &&
                 exceptionIgnoredStack != null &&
                 !(exceptionIgnoredStack.empty())) {
-                
+
             if ((exceptionIgnoredStack.pop()).booleanValue()) {
                 // creation exception was ignored
                 // nothing was put onto the stack
@@ -320,7 +320,7 @@ public class FactoryCreateRule extends Rule {
                 }
                 return;
             }
-        } 
+        }
 
         Object top = digester.pop();
         if (digester.log.isDebugEnabled()) {
@@ -398,5 +398,5 @@ public class FactoryCreateRule extends Rule {
         }
         return (creationFactory);
 
-    }    
+    }
 }

==================================================
NodeCreateRule.java
index 02e41a4bed..7fe2126fb2 100644
--- a/java/org/apache/tomcat/util/digester/GenericParser.java
+++ b/java/org/apache/tomcat/util/digester/GenericParser.java
@@ -5,15 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
+ */
 
 
 package org.apache.tomcat.util.digester;
@@ -61,11 +61,11 @@ public class GenericParser{
      * @return an XML Schema/DTD enabled <code>SAXParser</code>
      */
     public static SAXParser newSAXParser(Properties properties)
-            throws ParserConfigurationException, 
+            throws ParserConfigurationException,
                    SAXException,
-                   SAXNotRecognizedException{ 
+                   SAXNotRecognizedException{
 
-        SAXParserFactory factory = 
+        SAXParserFactory factory =
                         (SAXParserFactory)properties.get("SAXParserFactory");
         SAXParser parser = factory.newSAXParser();
         String schemaLocation = (String)properties.get("schemaLocation");
@@ -77,8 +77,8 @@ public class GenericParser{
                 parser.setProperty(JAXP_SCHEMA_SOURCE, schemaLocation);
             }
         } catch (SAXNotRecognizedException e){
-            log.info(parser.getClass().getName() + ": "  
-                                        + e.getMessage() + " not supported."); 
+            log.info(parser.getClass().getName() + ": "
+                                        + e.getMessage() + " not supported.");
         }
         return parser;
     }

==================================================
ObjectCreateRule.java
index c6dd072838..56f3b321ea 100644
--- a/java/org/apache/tomcat/util/digester/NodeCreateRule.java
+++ b/java/org/apache/tomcat/util/digester/NodeCreateRule.java
@@ -5,15 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
+ */
 
 
 package org.apache.tomcat.util.digester;
@@ -47,11 +47,11 @@ import org.xml.sax.helpers.DefaultHandler;
  *   {@link org.w3c.dom.DocumentFragment DocumentFragment}, which will contain
  *   only the XML content under the element the rule was triggered on.</li>
  * </ul>
- * The created node will be normalized, meaning it will not contain text nodes 
+ * The created node will be normalized, meaning it will not contain text nodes
  * that only contain white space characters.
- * 
+ *
 
- * 
+ *
  * <p>The created <code>Node</code> will be pushed on Digester's object stack
  * when done. To use it in the context of another DOM
  * {@link org.w3c.dom.Document Document}, it must be imported first, using the
@@ -60,12 +60,12 @@ import org.xml.sax.helpers.DefaultHandler;
  * </p>
  *
  * <p><strong>Important Note:</strong> This is implemented by replacing the SAX
- * {@link org.xml.sax.ContentHandler ContentHandler} in the parser used by 
- * Digester, and resetting it when the matched element is closed. As a side 
- * effect, rules that would match XML nodes under the element that matches 
- * a <code>NodeCreateRule</code> will never be triggered by Digester, which 
+ * {@link org.xml.sax.ContentHandler ContentHandler} in the parser used by
+ * Digester, and resetting it when the matched element is closed. As a side
+ * effect, rules that would match XML nodes under the element that matches
+ * a <code>NodeCreateRule</code> will never be triggered by Digester, which
  * usually is the behavior one would expect.</p>
- * 
+ *
  * <p><strong>Note</strong> that the current implementation does not set the namespace prefixes
  * in the exported nodes. The (usually more important) namespace URIs are set,
  * of course.</p>
@@ -80,7 +80,7 @@ public class NodeCreateRule extends Rule {
 
 
     /**
-     * The SAX content handler that does all the actual work of assembling the 
+     * The SAX content handler that does all the actual work of assembling the
      * DOM node tree from the SAX events.
      */
     private class NodeBuilder
@@ -92,16 +92,16 @@ public class NodeCreateRule extends Rule {
 
         /**
          * Constructor.
-         * 
-         * <p>Stores the content handler currently used by Digester so it can 
-         * be reset when done, and initializes the DOM objects needed to 
+         *
+         * <p>Stores the content handler currently used by Digester so it can
+         * be reset when done, and initializes the DOM objects needed to
          * build the node.</p>
-         * 
+         *
          * @param doc the document to use to create nodes
          * @param root the root node
-         * @throws ParserConfigurationException if the DocumentBuilderFactory 
+         * @throws ParserConfigurationException if the DocumentBuilderFactory
          *   could not be instantiated
-         * @throws SAXException if the XMLReader could not be instantiated by 
+         * @throws SAXException if the XMLReader could not be instantiated by
          *   Digester (should not happen)
          */
         public NodeBuilder(Document doc, Node root)
@@ -110,7 +110,7 @@ public class NodeCreateRule extends Rule {
             this.doc = doc;
             this.root = root;
             this.top = root;
-            
+
             oldContentHandler = digester.getXMLReader().getContentHandler();
 
         }
@@ -120,7 +120,7 @@ public class NodeCreateRule extends Rule {
 
 
         /**
-         * The content handler used by Digester before it was set to this 
+         * The content handler used by Digester before it was set to this
          * content handler.
          */
         protected ContentHandler oldContentHandler = null;
@@ -156,7 +156,7 @@ public class NodeCreateRule extends Rule {
 
         /**
          * Appends a {@link org.w3c.dom.Text Text} node to the current node.
-         * 
+         *
          * @param ch the characters from the XML document
          * @param start the start position in the array
          * @param length the number of characters to read from the array
@@ -168,7 +168,7 @@ public class NodeCreateRule extends Rule {
 
             try {
                 String str = new String(ch, start, length);
-                if (str.trim().length() > 0) { 
+                if (str.trim().length() > 0) {
                     top.appendChild(doc.createTextNode(str));
                 }
             } catch (DOMException e) {
@@ -180,7 +180,7 @@ public class NodeCreateRule extends Rule {
 
         /**
          * Checks whether control needs to be returned to Digester.
-         * 
+         *
          * @param namespaceURI the namespace URI
          * @param localName the local name
          * @param qName the qualified (prefixed) name
@@ -190,7 +190,7 @@ public class NodeCreateRule extends Rule {
         public void endElement(String namespaceURI, String localName,
                                String qName)
             throws SAXException {
-            
+
             try {
                 if (depth == 0) {
                     getDigester().getXMLReader().setContentHandler(
@@ -198,7 +198,7 @@ public class NodeCreateRule extends Rule {
                     getDigester().push(root);
                     getDigester().endElement(namespaceURI, localName, qName);
                 }
-    
+
                 top = top.getParentNode();
                 depth--;
             } catch (DOMException e) {
@@ -210,18 +210,18 @@ public class NodeCreateRule extends Rule {
 
         /**
          * Adds a new
-         * {@link org.w3c.dom.ProcessingInstruction ProcessingInstruction} to 
+         * {@link org.w3c.dom.ProcessingInstruction ProcessingInstruction} to
          * the current node.
-         * 
+         *
          * @param target the processing instruction target
-         * @param data the processing instruction data, or null if none was 
+         * @param data the processing instruction data, or null if none was
          *   supplied
          * @throws SAXException if the DOM implementation throws an exception
          */
         @Override
         public void processingInstruction(String target, String data)
             throws SAXException {
-            
+
             try {
                 top.appendChild(doc.createProcessingInstruction(target, data));
             } catch (DOMException e) {
@@ -234,7 +234,7 @@ public class NodeCreateRule extends Rule {
         /**
          * Adds a new child {@link org.w3c.dom.Element Element} to the current
          * node.
-         * 
+         *
          * @param namespaceURI the namespace URI
          * @param localName the local name
          * @param qName the qualified (prefixed) name
@@ -248,7 +248,7 @@ public class NodeCreateRule extends Rule {
 
             try {
                 Node previousTop = top;
-                if ((localName == null) || (localName.length() == 0)) { 
+                if ((localName == null) || (localName.length() == 0)) {
                     top = doc.createElement(qName);
                 } else {
                     top = doc.createElementNS(namespaceURI, localName);
@@ -294,10 +294,10 @@ public class NodeCreateRule extends Rule {
 
     /**
      * Constructor. Creates an instance of this rule that will create a DOM
-     * {@link org.w3c.dom.Element Element}, but lets you specify the JAXP 
+     * {@link org.w3c.dom.Element Element}, but lets you specify the JAXP
      * <code>DocumentBuilder</code> that should be used when constructing the
      * node tree.
-     * 
+     *
      * @param documentBuilder the JAXP <code>DocumentBuilder</code> to use
      */
     public NodeCreateRule(DocumentBuilder documentBuilder) {
@@ -308,13 +308,13 @@ public class NodeCreateRule extends Rule {
 
 
     /**
-     * Constructor. Creates an instance of this rule that will create either a 
-     * DOM {@link org.w3c.dom.Element Element} or a DOM 
+     * Constructor. Creates an instance of this rule that will create either a
+     * DOM {@link org.w3c.dom.Element Element} or a DOM
      * {@link org.w3c.dom.DocumentFragment DocumentFragment}, depending on the
      * value of the <code>nodeType</code> parameter.
-     * 
+     *
      * @param nodeType the type of node to create, which can be either
-     *   {@link org.w3c.dom.Node#ELEMENT_NODE Node.ELEMENT_NODE} or 
+     *   {@link org.w3c.dom.Node#ELEMENT_NODE Node.ELEMENT_NODE} or
      *   {@link org.w3c.dom.Node#DOCUMENT_FRAGMENT_NODE Node.DOCUMENT_FRAGMENT_NODE}
      * @throws IllegalArgumentException if the node type is not supported
      */
@@ -327,15 +327,15 @@ public class NodeCreateRule extends Rule {
 
 
     /**
-     * Constructor. Creates an instance of this rule that will create either a 
-     * DOM {@link org.w3c.dom.Element Element} or a DOM 
+     * Constructor. Creates an instance of this rule that will create either a
+     * DOM {@link org.w3c.dom.Element Element} or a DOM
      * {@link org.w3c.dom.DocumentFragment DocumentFragment}, depending on the
      * value of the <code>nodeType</code> parameter. This constructor lets you
      * specify the JAXP <code>DocumentBuilder</code> that should be used when
      * constructing the node tree.
-     * 
+     *
      * @param nodeType the type of node to create, which can be either
-     *   {@link org.w3c.dom.Node#ELEMENT_NODE Node.ELEMENT_NODE} or 
+     *   {@link org.w3c.dom.Node#ELEMENT_NODE Node.ELEMENT_NODE} or
      *   {@link org.w3c.dom.Node#DOCUMENT_FRAGMENT_NODE Node.DOCUMENT_FRAGMENT_NODE}
      * @param documentBuilder the JAXP <code>DocumentBuilder</code> to use
      * @throws IllegalArgumentException if the node type is not supported
@@ -365,7 +365,7 @@ public class NodeCreateRule extends Rule {
     /**
      * The type of the node that should be created. Must be one of the
      * constants defined in {@link org.w3c.dom.Node Node}, but currently only
-     * {@link org.w3c.dom.Node#ELEMENT_NODE Node.ELEMENT_NODE} and 
+     * {@link org.w3c.dom.Node#ELEMENT_NODE Node.ELEMENT_NODE} and
      * {@link org.w3c.dom.Node#DOCUMENT_FRAGMENT_NODE Node.DOCUMENT_FRAGMENT_NODE}
      * are allowed values.
      */
@@ -376,13 +376,13 @@ public class NodeCreateRule extends Rule {
 
 
     /**
-     * Implemented to replace the content handler currently in use by a 
+     * Implemented to replace the content handler currently in use by a
      * NodeBuilder.
-     * 
-     * @param namespaceURI the namespace URI of the matching element, or an 
+     *
+     * @param namespaceURI the namespace URI of the matching element, or an
      *   empty string if the parser is not namespace aware or the element has
      *   no namespace
-     * @param name the local name if the parser is namespace aware, or just 
+     * @param name the local name if the parser is namespace aware, or just
      *   the element name otherwise
      * @param attributes The attribute list of this element
      * @throws Exception indicates a JAXP configuration problem
@@ -422,11 +422,11 @@ public class NodeCreateRule extends Rule {
 
     /**
      * Pop the Node off the top of the stack.
-     * 
-     * @param namespace the namespace URI of the matching element, or an 
+     *
+     * @param namespace the namespace URI of the matching element, or an
      *   empty string if the parser is not namespace aware or the element has
      *   no namespace
-     * @param name the local name if the parser is namespace aware, or just 
+     * @param name the local name if the parser is namespace aware, or just
      *   the element name otherwise
      */
     @Override

==================================================
ObjectCreationFactory.java
index a745b76b6e..ba9d2defab 100644
--- a/java/org/apache/tomcat/util/digester/ObjectCreateRule.java
+++ b/java/org/apache/tomcat/util/digester/ObjectCreateRule.java
@@ -5,15 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
+ */
 
 
 package org.apache.tomcat.util.digester;
@@ -111,10 +111,10 @@ public class ObjectCreateRule extends Rule {
     /**
      * Process the beginning of this element.
      *
-     * @param namespace the namespace URI of the matching element, or an 
+     * @param namespace the namespace URI of the matching element, or an
      *   empty string if the parser is not namespace aware or the element has
      *   no namespace
-     * @param name the local name if the parser is namespace aware, or just 
+     * @param name the local name if the parser is namespace aware, or just
      *   the element name otherwise
      * @param attributes The attribute list for this element
      */
@@ -149,11 +149,11 @@ public class ObjectCreateRule extends Rule {
 
     /**
      * Process the end of this element.
-     * 
-     * @param namespace the namespace URI of the matching element, or an 
+     *
+     * @param namespace the namespace URI of the matching element, or an
      *   empty string if the parser is not namespace aware or the element has
      *   no namespace
-     * @param name the local name if the parser is namespace aware, or just 
+     * @param name the local name if the parser is namespace aware, or just
      *   the element name otherwise
      */
     @Override

==================================================
ObjectParamRule.java
index 72c84be3fa..ab6856b46e 100644
--- a/java/org/apache/tomcat/util/digester/ObjectCreationFactory.java
+++ b/java/org/apache/tomcat/util/digester/ObjectCreationFactory.java
@@ -5,15 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
+ */
 
 package org.apache.tomcat.util.digester;
 

==================================================
ParserFeatureSetterFactory.java
index 81e6924139..4dda7553a7 100644
--- a/java/org/apache/tomcat/util/digester/ObjectParamRule.java
+++ b/java/org/apache/tomcat/util/digester/ObjectParamRule.java
@@ -5,15 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
+ */
 
 
 package org.apache.tomcat.util.digester;

==================================================
PathCallParamRule.java
index 0084cc295a..d8d99334ce 100644
--- a/java/org/apache/tomcat/util/digester/ParserFeatureSetterFactory.java
+++ b/java/org/apache/tomcat/util/digester/ParserFeatureSetterFactory.java
@@ -5,15 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
+ */
 
 
 package org.apache.tomcat.util.digester;
@@ -39,7 +39,7 @@ public class ParserFeatureSetterFactory{
     /**
      * <code>true</code> is Xerces is used.
      */
-    private static boolean isXercesUsed; 
+    private static boolean isXercesUsed;
 
     static {
         try{
@@ -58,9 +58,9 @@ public class ParserFeatureSetterFactory{
      * parser implementation.
      */
     public static SAXParser newSAXParser(Properties properties)
-            throws ParserConfigurationException, 
+            throws ParserConfigurationException,
                    SAXException,
-                   SAXNotRecognizedException, 
+                   SAXNotRecognizedException,
                    SAXNotSupportedException {
 
         if (isXercesUsed){

==================================================
Rule.java
index 30fb5b379e..e02c5ab254 100644
--- a/java/org/apache/tomcat/util/digester/PathCallParamRule.java
+++ b/java/org/apache/tomcat/util/digester/PathCallParamRule.java
@@ -5,15 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
+ */
 
 
 package org.apache.tomcat.util.digester;
@@ -22,9 +22,9 @@ package org.apache.tomcat.util.digester;
 import org.xml.sax.Attributes;
 
 /**
- * <p>Rule implementation that saves a parameter containing the 
- * <code>Digester</code> matching path for use by a surrounding 
- * <code>CallMethodRule</code>. This Rule is most useful when making 
+ * <p>Rule implementation that saves a parameter containing the
+ * <code>Digester</code> matching path for use by a surrounding
+ * <code>CallMethodRule</code>. This Rule is most useful when making
  * extensive use of wildcards in rule patterns.</p>
  *
  * @since 1.6
@@ -45,7 +45,7 @@ public class PathCallParamRule extends Rule {
         this.paramIndex = paramIndex;
 
     }
- 
+
     // ----------------------------------------------------- Instance Variables
 
     /**
@@ -59,10 +59,10 @@ public class PathCallParamRule extends Rule {
     /**
      * Process the start of this element.
      *
-     * @param namespace the namespace URI of the matching element, or an 
+     * @param namespace the namespace URI of the matching element, or an
      *   empty string if the parser is not namespace aware or the element has
      *   no namespace
-     * @param name the local name if the parser is namespace aware, or just 
+     * @param name the local name if the parser is namespace aware, or just
      *   the element name otherwise
      * @param attributes The attribute list for this element
 
@@ -71,12 +71,12 @@ public class PathCallParamRule extends Rule {
     public void begin(String namespace, String name, Attributes attributes) throws Exception {
 
         String param = getDigester().getMatch();
-        
+
         if(param != null) {
             Object parameters[] = (Object[]) digester.peekParams();
             parameters[paramIndex] = param;
         }
-        
+
     }
 
     /**

==================================================
RuleSet.java
index 5daef56f85..fa1ea0d383 100644
--- a/java/org/apache/tomcat/util/digester/Rule.java
+++ b/java/org/apache/tomcat/util/digester/Rule.java
@@ -5,15 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
+ */
 
 
 package org.apache.tomcat.util.digester;
@@ -66,14 +66,14 @@ public abstract class Rule {
         return (this.digester);
 
     }
-    
+
     /**
      * Set the <code>Digester</code> with which this <code>Rule</code> is associated.
      */
     public void setDigester(Digester digester) {
-        
+
         this.digester = digester;
-        
+
     }
 
     /**
@@ -120,14 +120,14 @@ public abstract class Rule {
     /**
      * This method is called when the beginning of a matching XML element
      * is encountered. The default implementation delegates to the deprecated
-     * method {@link #begin(Attributes) begin} without the 
-     * <code>namespace</code> and <code>name</code> parameters, to retain 
+     * method {@link #begin(Attributes) begin} without the
+     * <code>namespace</code> and <code>name</code> parameters, to retain
      * backwards compatibility.
      *
-     * @param namespace the namespace URI of the matching element, or an 
+     * @param namespace the namespace URI of the matching element, or an
      *   empty string if the parser is not namespace aware or the element has
      *   no namespace
-     * @param name the local name if the parser is namespace aware, or just 
+     * @param name the local name if the parser is namespace aware, or just
      *   the element name otherwise
      * @param attributes The attribute list of this element
      * @since Digester 1.4
@@ -157,16 +157,16 @@ public abstract class Rule {
 
 
     /**
-     * This method is called when the body of a matching XML element is 
-     * encountered.  If the element has no body, this method is not called at 
-     * all. The default implementation delegates to the deprecated method 
+     * This method is called when the body of a matching XML element is
+     * encountered.  If the element has no body, this method is not called at
+     * all. The default implementation delegates to the deprecated method
      * {@link #body(String) body} without the <code>namespace</code> and
      * <code>name</code> parameters, to retain backwards compatibility.
      *
-     * @param namespace the namespace URI of the matching element, or an 
+     * @param namespace the namespace URI of the matching element, or an
      *   empty string if the parser is not namespace aware or the element has
      *   no namespace
-     * @param name the local name if the parser is namespace aware, or just 
+     * @param name the local name if the parser is namespace aware, or just
      *   the element name otherwise
      * @param text The text of the body of this element
      * @since Digester 1.4
@@ -182,8 +182,8 @@ public abstract class Rule {
     /**
      * This method is called when the end of a matching XML element
      * is encountered.
-     * 
-     * @deprecated Use the {@link #end(String,String) end} method with 
+     *
+     * @deprecated Use the {@link #end(String,String) end} method with
      *   <code>namespace</code> and <code>name</code> parameters instead.
      */
     @Deprecated
@@ -195,14 +195,14 @@ public abstract class Rule {
     /**
      * This method is called when the end of a matching XML element
      * is encountered. The default implementation delegates to the deprecated
-     * method {@link #end end} without the 
-     * <code>namespace</code> and <code>name</code> parameters, to retain 
+     * method {@link #end end} without the
+     * <code>namespace</code> and <code>name</code> parameters, to retain
      * backwards compatibility.
      *
-     * @param namespace the namespace URI of the matching element, or an 
+     * @param namespace the namespace URI of the matching element, or an
      *   empty string if the parser is not namespace aware or the element has
      *   no namespace
-     * @param name the local name if the parser is namespace aware, or just 
+     * @param name the local name if the parser is namespace aware, or just
      *   the element name otherwise
      * @since Digester 1.4
      */

==================================================
RuleSetBase.java
index e987ea43f9..deb8cbe76c 100644
--- a/java/org/apache/tomcat/util/digester/RuleSet.java
+++ b/java/org/apache/tomcat/util/digester/RuleSet.java
@@ -5,15 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
+ */
 
 package org.apache.tomcat.util.digester;
 

==================================================
Rules.java
index 93ebffd1c4..b917540267 100644
--- a/java/org/apache/tomcat/util/digester/RuleSetBase.java
+++ b/java/org/apache/tomcat/util/digester/RuleSetBase.java
@@ -5,15 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
+ */
 
 
 package org.apache.tomcat.util.digester;

==================================================
RulesBase.java
index 0f4f4e24fa..490906f379 100644
--- a/java/org/apache/tomcat/util/digester/Rules.java
+++ b/java/org/apache/tomcat/util/digester/Rules.java
@@ -5,15 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
+ */
 
 
 package org.apache.tomcat.util.digester;

==================================================
SetNextRule.java
index 5cc047b11c..95268f6f61 100644
--- a/java/org/apache/tomcat/util/digester/RulesBase.java
+++ b/java/org/apache/tomcat/util/digester/RulesBase.java
@@ -5,15 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
+ */
 
 
 package org.apache.tomcat.util.digester;
@@ -155,8 +155,8 @@ public class RulesBase implements Rules {
         if (patternLength>1 && pattern.endsWith("/")) {
             pattern = pattern.substring(0, patternLength-1);
         }
-        
-        
+
+
         List<Rule> list = cache.get(pattern);
         if (list == null) {
             list = new ArrayList<Rule>();

==================================================
SetPropertiesRule.java
index a743415847..d4c8e2f5ec 100644
--- a/java/org/apache/tomcat/util/digester/SetNextRule.java
+++ b/java/org/apache/tomcat/util/digester/SetNextRule.java
@@ -5,15 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
+ */
 
 
 package org.apache.tomcat.util.digester;
@@ -27,9 +27,9 @@ import org.apache.tomcat.util.IntrospectionUtils;
  * commonly used to establish parent-child relationships.</p>
  *
  * <p>This rule now supports more flexible method matching by default.
- * It is possible that this may break (some) code 
+ * It is possible that this may break (some) code
  * written against release 1.1.1 or earlier.
- * See {@link #isExactMatch()} for more details.</p> 
+ * See {@link #isExactMatch()} for more details.</p>
  */
 
 public class SetNextRule extends Rule {
@@ -46,7 +46,7 @@ public class SetNextRule extends Rule {
      * @param digester The associated Digester
      * @param methodName Method name of the parent method to call
      *
-     * @deprecated The digester instance is now set in the {@link Digester#addRule} method. 
+     * @deprecated The digester instance is now set in the {@link Digester#addRule} method.
      * Use {@link #SetNextRule(String methodName)} instead.
      */
     @Deprecated
@@ -67,7 +67,7 @@ public class SetNextRule extends Rule {
      *  Java wrapper class instead, such as <code>java.lang.Boolean</code>
      *  for a <code>boolean</code> parameter)
      *
-     * @deprecated The digester instance is now set in the {@link Digester#addRule} method. 
+     * @deprecated The digester instance is now set in the {@link Digester#addRule} method.
      * Use {@link #SetNextRule(String methodName,String paramType)} instead.
      */
     @Deprecated
@@ -135,15 +135,15 @@ public class SetNextRule extends Rule {
     /**
      * <p>Is exact matching being used.</p>
      *
-     * <p>This rule uses <code>org.apache.commons.beanutils.MethodUtils</code> 
+     * <p>This rule uses <code>org.apache.commons.beanutils.MethodUtils</code>
      * to introspect the relevant objects so that the right method can be called.
      * Originally, <code>MethodUtils.invokeExactMethod</code> was used.
-     * This matches methods very strictly 
+     * This matches methods very strictly
      * and so may not find a matching method when one exists.
      * This is still the behaviour when exact matching is enabled.</p>
      *
      * <p>When exact matching is disabled, <code>MethodUtils.invokeMethod</code> is used.
-     * This method finds more methods but is less precise when there are several methods 
+     * This method finds more methods but is less precise when there are several methods
      * with correct signatures.
      * So, if you want to choose an exact signature you might need to enable this property.</p>
      *
@@ -153,10 +153,10 @@ public class SetNextRule extends Rule {
      * @since Digester Release 1.1.1
      */
     public boolean isExactMatch() {
-    
+
         return useExactMatch;
     }
-    
+
     /**
      * <p>Set whether exact matching is enabled.</p>
      *
@@ -164,7 +164,7 @@ public class SetNextRule extends Rule {
      *
      * @param useExactMatch should this rule use exact method matching
      * @since Digester Release 1.1.1
-     */    
+     */
     public void setExactMatch(boolean useExactMatch) {
 
         this.useExactMatch = useExactMatch;
@@ -172,11 +172,11 @@ public class SetNextRule extends Rule {
 
     /**
      * Process the end of this element.
-     * 
-     * @param namespace the namespace URI of the matching element, or an 
+     *
+     * @param namespace the namespace URI of the matching element, or an
      *   empty string if the parser is not namespace aware or the element has
      *   no namespace
-     * @param name the local name if the parser is namespace aware, or just 
+     * @param name the local name if the parser is namespace aware, or just
      *   the element name otherwise
      */
     @Override
@@ -200,7 +200,7 @@ public class SetNextRule extends Rule {
         // Call the specified method
         IntrospectionUtils.callMethod1(parent, methodName,
                 child, paramType, digester.getClassLoader());
-                
+
     }
 
 

==================================================
SetPropertyRule.java
index 0664f79868..013b33652c 100644
--- a/java/org/apache/tomcat/util/digester/SetPropertiesRule.java
+++ b/java/org/apache/tomcat/util/digester/SetPropertiesRule.java
@@ -5,15 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
+ */
 
 
 package org.apache.tomcat.util.digester;
@@ -28,7 +28,7 @@ import org.xml.sax.Attributes;
  * stack, based on attributes with corresponding names.</p>
  *
  * <p>This rule supports custom mapping of attribute names to property names.
- * The default mapping for particular attributes can be overridden by using 
+ * The default mapping for particular attributes can be overridden by using
  * {@link #SetPropertiesRule(String[] attributeNames, String[] propertyNames)}.
  * This allows attributes to be mapped to properties with different names.
  * Certain attributes can also be marked to be ignored.</p>
@@ -45,7 +45,7 @@ public class SetPropertiesRule extends Rule {
      *
      * @param digester The digester with which this rule is associated
      *
-     * @deprecated The digester instance is now set in the {@link Digester#addRule} method. 
+     * @deprecated The digester instance is now set in the {@link Digester#addRule} method.
      * Use {@link #SetPropertiesRule()} instead.
      */
     @Deprecated
@@ -54,38 +54,38 @@ public class SetPropertiesRule extends Rule {
         this();
 
     }
-    
+
 
     /**
      * Base constructor.
      */
     public SetPropertiesRule() {
 
-        // nothing to set up 
+        // nothing to set up
 
     }
-    
-    /** 
+
+    /**
      * <p>Convenience constructor overrides the mapping for just one property.</p>
      *
      * <p>For details about how this works, see
      * {@link #SetPropertiesRule(String[] attributeNames, String[] propertyNames)}.</p>
      *
-     * @param attributeName map this attribute 
+     * @param attributeName map this attribute
      * @param propertyName to a property with this name
      */
     public SetPropertiesRule(String attributeName, String propertyName) {
-        
+
         attributeNames = new String[1];
         attributeNames[0] = attributeName;
         propertyNames = new String[1];
         propertyNames[0] = propertyName;
     }
-    
-    /** 
+
+    /**
      * <p>Constructor allows attribute->property mapping to be overridden.</p>
      *
-     * <p>Two arrays are passed in. 
+     * <p>Two arrays are passed in.
      * One contains the attribute names and the other the property names.
      * The attribute name / property name pairs are match by position
      * In order words, the first string in the attribute name list matches
@@ -93,15 +93,15 @@ public class SetPropertiesRule extends Rule {
      *
      * <p>If a property name is null or the attribute name has no matching
      * property name, then this indicates that the attribute should be ignored.</p>
-     * 
+     *
      * <h5>Example One</h5>
      * <p> The following constructs a rule that maps the <code>alt-city</code>
      * attribute to the <code>city</code> property and the <code>alt-state</code>
-     * to the <code>state</code> property. 
+     * to the <code>state</code> property.
      * All other attributes are mapped as usual using exact name matching.
      * <code><pre>
      *      SetPropertiesRule(
-     *                new String[] {"alt-city", "alt-state"}, 
+     *                new String[] {"alt-city", "alt-state"},
      *                new String[] {"city", "state"});
      * </pre></code>
      *
@@ -112,7 +112,7 @@ public class SetPropertiesRule extends Rule {
      * All other attributes are mapped as usual using exact name matching.
      * <code><pre>
      *      SetPropertiesRule(
-     *                new String[] {"class", "ignore-me"}, 
+     *                new String[] {"class", "ignore-me"},
      *                new String[] {"className"});
      * </pre></code>
      *
@@ -125,22 +125,22 @@ public class SetPropertiesRule extends Rule {
         for (int i=0, size=attributeNames.length; i<size; i++) {
             this.attributeNames[i] = attributeNames[i];
         }
-        
+
         this.propertyNames = new String[propertyNames.length];
         for (int i=0, size=propertyNames.length; i<size; i++) {
             this.propertyNames[i] = propertyNames[i];
-        } 
+        }
     }
-        
+
     // ----------------------------------------------------- Instance Variables
-    
-    /** 
+
+    /**
      * Attribute names used to override natural attribute->property mapping
      */
     private String [] attributeNames;
-    /** 
+    /**
      * Property names used to override natural attribute->property mapping
-     */    
+     */
     private String [] propertyNames;
 
 
@@ -150,17 +150,17 @@ public class SetPropertiesRule extends Rule {
     /**
      * Process the beginning of this element.
      *
-     * @param namespace the namespace URI of the matching element, or an 
+     * @param namespace the namespace URI of the matching element, or an
      *   empty string if the parser is not namespace aware or the element has
      *   no namespace
-     * @param theName the local name if the parser is namespace aware, or just 
+     * @param theName the local name if the parser is namespace aware, or just
      *   the element name otherwise
      * @param attributes The attribute list for this element
      */
     @Override
     public void begin(String namespace, String theName, Attributes attributes)
             throws Exception {
-        
+
         // Populate the corresponding properties of the top object
         Object top = digester.peek();
         if (digester.log.isDebugEnabled()) {
@@ -173,7 +173,7 @@ public class SetPropertiesRule extends Rule {
                                    "} Set NULL properties");
             }
         }
-        
+
         // set up variables for custom names mappings
         int attNamesLength = 0;
         if (attributeNames != null) {
@@ -183,21 +183,21 @@ public class SetPropertiesRule extends Rule {
         if (propertyNames != null) {
             propNamesLength = propertyNames.length;
         }
-        
+
         for (int i = 0; i < attributes.getLength(); i++) {
             String name = attributes.getLocalName(i);
             if ("".equals(name)) {
                 name = attributes.getQName(i);
             }
             String value = attributes.getValue(i);
-            
+
             // we'll now check for custom mappings
             for (int n = 0; n<attNamesLength; n++) {
                 if (name.equals(attributeNames[n])) {
                     if (n < propNamesLength) {
                         // set this to value from list
                         name = propertyNames[n];
-                    
+
                     } else {
                         // set name to null
                         // we'll check for this later
@@ -205,15 +205,15 @@ public class SetPropertiesRule extends Rule {
                     }
                     break;
                 }
-            } 
-            
+            }
+
             if (digester.log.isDebugEnabled()) {
                 digester.log.debug("[SetPropertiesRule]{" + digester.match +
                         "} Setting property '" + name + "' to '" +
                         value + "'");
             }
-            if (!digester.isFakeAttribute(top, name) 
-                    && !IntrospectionUtils.setProperty(top, name, value) 
+            if (!digester.isFakeAttribute(top, name)
+                    && !IntrospectionUtils.setProperty(top, name, value)
                     && digester.getRulesValidation()) {
                 digester.log.warn("[SetPropertiesRule]{" + digester.match +
                         "} Setting property '" + name + "' to '" +
@@ -229,17 +229,17 @@ public class SetPropertiesRule extends Rule {
      * This is intended to be used from the xml rules.
      */
     public void addAlias(String attributeName, String propertyName) {
-        
+
         // this is a bit tricky.
         // we'll need to resize the array.
         // probably should be synchronized but digester's not thread safe anyway
         if (attributeNames == null) {
-            
+
             attributeNames = new String[1];
             attributeNames[0] = attributeName;
             propertyNames = new String[1];
-            propertyNames[0] = propertyName;        
-            
+            propertyNames[0] = propertyName;
+
         } else {
             int length = attributeNames.length;
             String [] tempAttributes = new String[length + 1];
@@ -247,18 +247,18 @@ public class SetPropertiesRule extends Rule {
                 tempAttributes[i] = attributeNames[i];
             }
             tempAttributes[length] = attributeName;
-            
+
             String [] tempProperties = new String[length + 1];
             for (int i=0; i<length && i< propertyNames.length; i++) {
                 tempProperties[i] = propertyNames[i];
             }
             tempProperties[length] = propertyName;
-            
+
             propertyNames = tempProperties;
             attributeNames = tempAttributes;
-        }        
+        }
     }
-  
+
 
     /**
      * Render a printable version of this Rule.

==================================================
SetRootRule.java
index 1393205fa6..bee1d0a0de 100644
--- a/java/org/apache/tomcat/util/digester/SetPropertyRule.java
+++ b/java/org/apache/tomcat/util/digester/SetPropertyRule.java
@@ -5,15 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
+ */
 
 
 package org.apache.tomcat.util.digester;
@@ -44,7 +44,7 @@ public class SetPropertyRule extends Rule {
      * @param value Name of the attribute that will contain the value to which
      *  the property should be set
      *
-     * @deprecated The digester instance is now set in the {@link Digester#addRule} method. 
+     * @deprecated The digester instance is now set in the {@link Digester#addRule} method.
      * Use {@link #SetPropertyRule(String name, String value)} instead.
      */
     @Deprecated
@@ -91,13 +91,13 @@ public class SetPropertyRule extends Rule {
     /**
      * Process the beginning of this element.
      *
-     * @param namespace the namespace URI of the matching element, or an 
+     * @param namespace the namespace URI of the matching element, or an
      *   empty string if the parser is not namespace aware or the element has
      *   no namespace
-     * @param theName the local name if the parser is namespace aware, or just 
+     * @param theName the local name if the parser is namespace aware, or just
      *   the element name otherwise
      * @param attributes The attribute list for this element
-     * 
+     *
      * @exception NoSuchMethodException if the bean does not
      *  have a writable property of the specified name
      */
@@ -132,8 +132,8 @@ public class SetPropertyRule extends Rule {
         }
 
         // Set the property (with conversion as necessary)
-        if (!digester.isFakeAttribute(top, actualName) 
-                && !IntrospectionUtils.setProperty(top, actualName, actualValue) 
+        if (!digester.isFakeAttribute(top, actualName)
+                && !IntrospectionUtils.setProperty(top, actualName, actualValue)
                 && digester.getRulesValidation()) {
             digester.log.warn("[SetPropertyRule]{" + digester.match +
                     "} Setting property '" + name + "' to '" +

==================================================
SetTopRule.java
index 423de8a097..722121677a 100644
--- a/java/org/apache/tomcat/util/digester/SetRootRule.java
+++ b/java/org/apache/tomcat/util/digester/SetRootRule.java
@@ -5,15 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
+ */
 
 
 package org.apache.tomcat.util.digester;
@@ -27,7 +27,7 @@ import org.apache.tomcat.util.IntrospectionUtils;
  * It is important to remember that this rule acts on <code>end</code>.</p>
  *
  * <p>This rule now supports more flexible method matching by default.
- * It is possible that this may break (some) code 
+ * It is possible that this may break (some) code
  * written against release 1.1.1 or earlier.
  * See {@link #isExactMatch()} for more details.</p>
  */
@@ -46,7 +46,7 @@ public class SetRootRule extends Rule {
      * @param digester The associated Digester
      * @param methodName Method name of the parent method to call
      *
-     * @deprecated The digester instance is now set in the {@link Digester#addRule} method. 
+     * @deprecated The digester instance is now set in the {@link Digester#addRule} method.
      * Use {@link #SetRootRule(String methodName)} instead.
      */
     @Deprecated
@@ -67,7 +67,7 @@ public class SetRootRule extends Rule {
      *  Java wrapper class instead, such as <code>java.lang.Boolean</code>
      *  for a <code>boolean</code> parameter)
      *
-     * @deprecated The digester instance is now set in the {@link Digester#addRule} method. 
+     * @deprecated The digester instance is now set in the {@link Digester#addRule} method.
      * Use {@link #SetRootRule(String methodName,String paramType)} instead.
      */
     @Deprecated
@@ -122,7 +122,7 @@ public class SetRootRule extends Rule {
      * The Java class name of the parameter type expected by the method.
      */
     protected String paramType = null;
-    
+
     /**
      * Should we use exact matching. Default is no.
      */
@@ -135,15 +135,15 @@ public class SetRootRule extends Rule {
     /**
      * <p>Is exact matching being used.</p>
      *
-     * <p>This rule uses <code>org.apache.commons.beanutils.MethodUtils</code> 
+     * <p>This rule uses <code>org.apache.commons.beanutils.MethodUtils</code>
      * to introspect the relevant objects so that the right method can be called.
      * Originally, <code>MethodUtils.invokeExactMethod</code> was used.
-     * This matches methods very strictly 
+     * This matches methods very strictly
      * and so may not find a matching method when one exists.
      * This is still the behaviour when exact matching is enabled.</p>
      *
      * <p>When exact matching is disabled, <code>MethodUtils.invokeMethod</code> is used.
-     * This method finds more methods but is less precise when there are several methods 
+     * This method finds more methods but is less precise when there are several methods
      * with correct signatures.
      * So, if you want to choose an exact signature you might need to enable this property.</p>
      *
@@ -153,11 +153,11 @@ public class SetRootRule extends Rule {
      * @since Digester Release 1.1.1
      */
     public boolean isExactMatch() {
-    
+
         return useExactMatch;
     }
-    
-    
+
+
     /**
      * <p>Set whether exact matching is enabled.</p>
      *
@@ -173,11 +173,11 @@ public class SetRootRule extends Rule {
 
     /**
      * Process the end of this element.
-     * 
-     * @param namespace the namespace URI of the matching element, or an 
+     *
+     * @param namespace the namespace URI of the matching element, or an
      *   empty string if the parser is not namespace aware or the element has
      *   no namespace
-     * @param name the local name if the parser is namespace aware, or just 
+     * @param name the local name if the parser is namespace aware, or just
      *   the element name otherwise
      */
     @Override

==================================================
WithDefaultsRulesWrapper.java
index ce53a7fa32..ae9178b2ee 100644
--- a/java/org/apache/tomcat/util/digester/SetTopRule.java
+++ b/java/org/apache/tomcat/util/digester/SetTopRule.java
@@ -5,15 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
+ */
 
 
 package org.apache.tomcat.util.digester;
@@ -27,7 +27,7 @@ import org.apache.tomcat.util.IntrospectionUtils;
  * object, passing the (top-1) (parent) object as an argument.</p>
  *
  * <p>This rule now supports more flexible method matching by default.
- * It is possible that this may break (some) code 
+ * It is possible that this may break (some) code
  * written against release 1.1.1 or earlier.
  * See {@link #isExactMatch()} for more details.</p>
  */
@@ -46,7 +46,7 @@ public class SetTopRule extends Rule {
      * @param digester The associated Digester
      * @param methodName Method name of the "set parent" method to call
      *
-     * @deprecated The digester instance is now set in the {@link Digester#addRule} method. 
+     * @deprecated The digester instance is now set in the {@link Digester#addRule} method.
      * Use {@link #SetTopRule(String methodName)} instead.
      */
     @Deprecated
@@ -67,7 +67,7 @@ public class SetTopRule extends Rule {
      *  Java wrapper class instead, such as <code>java.lang.Boolean</code>
      *  for a <code>boolean</code> parameter)
      *
-     * @deprecated The digester instance is now set in the {@link Digester#addRule} method. 
+     * @deprecated The digester instance is now set in the {@link Digester#addRule} method.
      * Use {@link #SetTopRule(String methodName, String paramType)} instead.
      */
     @Deprecated
@@ -123,7 +123,7 @@ public class SetTopRule extends Rule {
      * The Java class name of the parameter type expected by the method.
      */
     protected String paramType = null;
-    
+
     /**
      * Should we use exact matching. Default is no.
      */
@@ -135,15 +135,15 @@ public class SetTopRule extends Rule {
     /**
      * <p>Is exact matching being used.</p>
      *
-     * <p>This rule uses <code>org.apache.commons.beanutils.MethodUtils</code> 
+     * <p>This rule uses <code>org.apache.commons.beanutils.MethodUtils</code>
      * to introspect the relevant objects so that the right method can be called.
      * Originally, <code>MethodUtils.invokeExactMethod</code> was used.
-     * This matches methods very strictly 
+     * This matches methods very strictly
      * and so may not find a matching method when one exists.
      * This is still the behaviour when exact matching is enabled.</p>
      *
      * <p>When exact matching is disabled, <code>MethodUtils.invokeMethod</code> is used.
-     * This method finds more methods but is less precise when there are several methods 
+     * This method finds more methods but is less precise when there are several methods
      * with correct signatures.
      * So, if you want to choose an exact signature you might need to enable this property.</p>
      *
@@ -153,10 +153,10 @@ public class SetTopRule extends Rule {
      * @since Digester Release 1.1.1
      */
     public boolean isExactMatch() {
-    
+
         return useExactMatch;
     }
-    
+
     /**
      * <p>Set whether exact matching is enabled.</p>
      *
@@ -169,14 +169,14 @@ public class SetTopRule extends Rule {
 
         this.useExactMatch = useExactMatch;
     }
-    
+
     /**
      * Process the end of this element.
-     * 
-     * @param namespace the namespace URI of the matching element, or an 
+     *
+     * @param namespace the namespace URI of the matching element, or an
      *   empty string if the parser is not namespace aware or the element has
      *   no namespace
-     * @param name the local name if the parser is namespace aware, or just 
+     * @param name the local name if the parser is namespace aware, or just
      *   the element name otherwise
      */
     @Override
@@ -185,7 +185,7 @@ public class SetTopRule extends Rule {
         // Identify the objects to be used
         Object child = digester.peek(0);
         Object parent = digester.peek(1);
-        
+
         if (digester.log.isDebugEnabled()) {
             if (child == null) {
                 digester.log.debug("[SetTopRule]{" + digester.match +

==================================================
XercesParser.java
index f42d14c41e..ae75d3fa92 100644
--- a/java/org/apache/tomcat/util/digester/WithDefaultsRulesWrapper.java
+++ b/java/org/apache/tomcat/util/digester/WithDefaultsRulesWrapper.java
@@ -5,15 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
+ */
 
 package org.apache.tomcat.util.digester;
 
@@ -22,12 +22,12 @@ import java.util.Iterator;
 import java.util.List;
 
 /**
- * <p><code>Rules</code> <em>Decorator</em> that returns default rules 
+ * <p><code>Rules</code> <em>Decorator</em> that returns default rules
  * when no matches are returned by the wrapped implementation.</p>
  *
- * <p>This allows default <code>Rule</code> instances to be added to any 
- * existing <code>Rules</code> implementation. These default <code>Rule</code> 
- * instances will be returned for any match for which the wrapped 
+ * <p>This allows default <code>Rule</code> instances to be added to any
+ * existing <code>Rules</code> implementation. These default <code>Rule</code>
+ * instances will be returned for any match for which the wrapped
  * implementation does not return any matches.</p>
  * <p> For example,
  * <pre>
@@ -49,17 +49,17 @@ import java.util.List;
 public class WithDefaultsRulesWrapper implements Rules {
 
     // --------------------------------------------------------- Fields
-    
+
     /** The Rules implementation that this class wraps. */
     private Rules wrappedRules;
     /** Rules to be fired when the wrapped implementations returns none. */
     private List<Rule> defaultRules = new ArrayList<Rule>();
     /** All rules (preserves order in which they were originally added) */
     private List<Rule> allRules = new ArrayList<Rule>();
-    
+
     // --------------------------------------------------------- Constructor
-    
-    /** 
+
+    /**
      * Base constructor.
      *
      * @param wrappedRules the wrapped <code>Rules</code> implementation, not null
@@ -73,13 +73,13 @@ public class WithDefaultsRulesWrapper implements Rules {
     }
 
     // --------------------------------------------------------- Properties
-    
+
     /** Gets digester using these Rules */
     @Override
     public Digester getDigester() {
         return wrappedRules.getDigester();
     }
-    
+
     /** Sets digester using these Rules */
     @Override
     public void setDigester(Digester digester) {
@@ -90,26 +90,26 @@ public class WithDefaultsRulesWrapper implements Rules {
             rule.setDigester(digester);
         }
     }
-    
+
     /** Gets namespace to apply to Rule's added */
     @Override
     public String getNamespaceURI() {
         return wrappedRules.getNamespaceURI();
     }
-    
+
     /** Sets namespace to apply to Rule's added subsequently */
     @Override
     public void setNamespaceURI(String namespaceURI) {
         wrappedRules.setNamespaceURI(namespaceURI);
     }
-    
+
     /** Gets Rule's which will be fired when the wrapped implementation returns no matches */
     public List<Rule> getDefaults() {
         return defaultRules;
     }
-    
+
     // --------------------------------------------------------- Public Methods
-    
+
     /**
      * Return list of rules matching given pattern.
      * If wrapped implementation returns any matches return those.
@@ -125,28 +125,28 @@ public class WithDefaultsRulesWrapper implements Rules {
         // otherwise
         return matches;
     }
-    
+
     /** Adds a rule to be fired when wrapped implementation returns no matches */
     public void addDefault(Rule rule) {
         // set up rule
         if (wrappedRules.getDigester() != null) {
             rule.setDigester(wrappedRules.getDigester());
         }
-        
+
         if (wrappedRules.getNamespaceURI() != null) {
             rule.setNamespaceURI(wrappedRules.getNamespaceURI());
         }
-        
+
         defaultRules.add(rule);
         allRules.add(rule);
     }
-    
+
     /** Gets all rules */
     @Override
     public List<Rule> rules() {
         return allRules;
     }
-    
+
     /** Clears all Rule's */
     @Override
     public void clear() {
@@ -154,8 +154,8 @@ public class WithDefaultsRulesWrapper implements Rules {
         allRules.clear();
         defaultRules.clear();
     }
-    
-    /** 
+
+    /**
      * Adds a Rule to be fired on given pattern.
      * Pattern matching is delegated to wrapped implementation.
      */

==================================================
Constants.java
index 922a7cb227..293bd9eb23 100644
--- a/java/org/apache/tomcat/util/digester/package.html
+++ b/java/org/apache/tomcat/util/digester/package.html
@@ -81,7 +81,7 @@ the developer to focus on the processing to be performed.</p>
     the processing rules.</li>
 </ul>
 
-<p>For example code, see <a href="#doc.Usage"> the usage 
+<p>For example code, see <a href="#doc.Usage"> the usage
 examples</a>, and <a href="#doc.FAQ.Examples"> the FAQ </a>. </p>
 
 <a name="doc.Properties"></a>
@@ -307,10 +307,10 @@ the pattern for more than one registered processing rule will be matched
 matching pattern, or because one more more exact pattern matches and wildcard
 pattern matches are satisfied by the same element.</p>
 
-<p>When this occurs, the corresponding processing rules will all be fired in order. 
-<code>begin</code> (and <code>body</code>) method calls are executed in the 
-order that the <code>Rules</code> where initially registered with the 
-<code>Digester</code>, whilst <code>end</code> method calls are execute in 
+<p>When this occurs, the corresponding processing rules will all be fired in order.
+<code>begin</code> (and <code>body</code>) method calls are executed in the
+order that the <code>Rules</code> where initially registered with the
+<code>Digester</code>, whilst <code>end</code> method calls are execute in
 reverse order. In other words - the order is first in, last out.</p>
 
 <a name="doc.Rules"></a>
@@ -732,8 +732,8 @@ behavior of <code>Digester</code>, as described above, is generally sufficient.
 However, if the document you are processing uses namespaces, it is often
 convenient to have sets of <code>Rule</code> instances that are <em>only</em>
 matched on elements that use the prefix of a particular namespace.  This
-approach, for example, makes it possible to deal with element names that are 
-the same in different namespaces, but where you want to perform different 
+approach, for example, makes it possible to deal with element names that are
+the same in different namespaces, but where you want to perform different
 processing for each namespace. </p>
 
 <p>Digester does not provide full support for namespaces, but does provide
@@ -796,9 +796,9 @@ with a particular namespace, in more than one application context.</p>
 
 <h4>Using Namespace Prefixes In Pattern Matching</h4>
 
-<p>Using rules with namespaces is very useful when you have orthogonal rulesets. 
+<p>Using rules with namespaces is very useful when you have orthogonal rulesets.
 One ruleset applies to a namespace and is independent of other rulesets applying
-to other namespaces. However, if your rule logic requires mixed namespaces, then 
+to other namespaces. However, if your rule logic requires mixed namespaces, then
 matching namespace prefix patterns might be a better strategy.</p>
 
 <p>When you set the <code>NamespaceAware</code> property to false, digester uses
@@ -809,7 +809,7 @@ create namespace-aware rules, create pattern matches including the namespace
 prefixes.</p>
 
 <p>For example, (with <code>NamespaceAware</code> false), the pattern <code>
-'foo:bar'</code> will match a top level element named <code>'bar'</code> in the 
+'foo:bar'</code> will match a top level element named <code>'bar'</code> in the
 namespace with (local) prefix <code>'foo'</code>.</p>
 
 <h4>Limitations of Digester Namespace support</h4>
@@ -862,10 +862,10 @@ following as part of your Digester initialization:</p>
 </pre>
 
 <h4>RegexRules</h4>
-<p><a href="RegexRules.html">RegexRules</a> is an advanced <code>Rules</code> 
+<p><a href="RegexRules.html">RegexRules</a> is an advanced <code>Rules</code>
 implementation which does not build on the default pattern matching rules.
-It uses a pluggable <a href="RegexMatcher.html">RegexMatcher</a> implementation to test 
-if a path matches the pattern for a Rule. All matching rules are returned 
+It uses a pluggable <a href="RegexMatcher.html">RegexMatcher</a> implementation to test
+if a path matches the pattern for a Rule. All matching rules are returned
 (note that this behaviour differs from longest matching rule of the default
  pattern matching rules). See the Java Docs for more details.
 </p>
@@ -886,11 +886,11 @@ implementation: <a href='SimpleRegexMatcher.html'>SimpleRegexMatcher</a>.
 This implementation is unsophisticated and lacks many good features
 lacking in more power Regex libraries. There are some good reasons
 why this approach was adopted. The first is that <code>SimpleRegexMatcher</code>
-is simple, it is easy to write and runs quickly. The second has to do with 
+is simple, it is easy to write and runs quickly. The second has to do with
 the way that <code>RegexRules</code> is intended to be used.
 </p>
 <p>
-There are many good regex libraries available. (For example 
+There are many good regex libraries available. (For example
 <a href='http://jakarta.apache.org/oro/index.html'>Jakarta ORO</a>,
 <a href='http://jakarta.apache.org/regexp/index.html'>Jakarta Regex</a>,
 <a href='http://www.cacas.org/java/gnu/regexp/'>GNU Regex</a> and
@@ -911,11 +911,11 @@ to be kept to a minimum).
 
 <h4>WithDefaultsRulesWrapper</h4>
 <p>
-<a href="WithDefaultsRulesWrapper.html"> WithDefaultsRulesWrapper</a> allows 
-default <code>Rule</code> instances to be added to any existing 
-<code>Rules</code> implementation. These default <code>Rule</code> instances 
-will be returned for any match for which the wrapped implementation does not 
-return any matches. 
+<a href="WithDefaultsRulesWrapper.html"> WithDefaultsRulesWrapper</a> allows
+default <code>Rule</code> instances to be added to any existing
+<code>Rules</code> implementation. These default <code>Rule</code> instances
+will be returned for any match for which the wrapped implementation does not
+return any matches.
 </p>
 <p>
 For example,
@@ -1004,29 +1004,29 @@ public class MyRuleSet extends RuleSetBase {
 <a name="doc.NamedStacks"></a>
 <h3>Using Named Stacks For Inter-Rule Communication</h3>
 <p>
-<code>Digester</code> is based on <code>Rule</code> instances working together 
-to process xml. For anything other than the most trival processing, 
+<code>Digester</code> is based on <code>Rule</code> instances working together
+to process xml. For anything other than the most trival processing,
 communication between <code>Rule</code> instances is necessary. Since <code>Rule</code>
-instances are processed in sequence, this usually means storing an Object 
+instances are processed in sequence, this usually means storing an Object
 somewhere where later instances can retrieve it.
 </p>
 <p>
-<code>Digester</code> is based on SAX. The most natural data structure to use with 
+<code>Digester</code> is based on SAX. The most natural data structure to use with
 SAX based xml processing is the stack. This allows more powerful processes to be
-specified more simply since the pushing and popping of objects can mimic the 
-nested structure of the xml. 
+specified more simply since the pushing and popping of objects can mimic the
+nested structure of the xml.
 </p>
 <p>
-<code>Digester</code> uses two basic stacks: one for the main beans and the other 
-for parameters for method calls. These are inadequate for complex processing 
-where many different <code>Rule</code> instances need to communicate through 
+<code>Digester</code> uses two basic stacks: one for the main beans and the other
+for parameters for method calls. These are inadequate for complex processing
+where many different <code>Rule</code> instances need to communicate through
 different channels.
 </p>
 <p>
 In this case, it is recommended that named stacks are used. In addition to the
 two basic stacks, <code>Digester</code> allows rules to use an unlimited number
 of other stacks referred two by an identifying string (the name). (That's where
-the term <em>named stack</em> comes from.) These stacks are 
+the term <em>named stack</em> comes from.) These stacks are
 accessed through calls to:
 </p>
 <ul>
@@ -1057,12 +1057,12 @@ with other <code>Rule</code> implementations.
 The <code><em>system-identifier</em></code> is an URI from which the resource can be obtained
 (either directly or indirectly). Many valid URIs may identify the same resource.
 The <code><em>public-identifier</em></code> is an additional free identifier which may be used
-(by the parser) to locate the resource. 
+(by the parser) to locate the resource.
 </p>
 <p>
 In practice, the weakness with a <code><em>system-identifier</em></code> is that most parsers
 will attempt to interprete this URI as an URL, try to download the resource directly
-from the URL and stop the parsing if this download fails. So, this means that 
+from the URL and stop the parsing if this download fails. So, this means that
 almost always the URI will have to be an URL from which the declaration
 can be downloaded.
 </p>
@@ -1073,26 +1073,26 @@ to allow the xml to be parsed). This is usually unsatisfactory and so a universa
 accessable URL is preferred. This usually means an internet URL.
 </p>
 <p>
-To recap, in practice the <code><em>system-identifier</em></code> will (most likely) be an 
+To recap, in practice the <code><em>system-identifier</em></code> will (most likely) be an
 internet URL. Unfortunately downloading from an internet URL is not only slow
-but unreliable (since successfully downloading a document from the internet 
+but unreliable (since successfully downloading a document from the internet
 relies on the client being connect to the internet and the server being
 able to satisfy the request).
 </p>
 <p>
-The <code><em>public-identifier</em></code> is a freely defined name but (in practice) it is 
+The <code><em>public-identifier</em></code> is a freely defined name but (in practice) it is
 strongly recommended that a unique, readable and open format is used (for reasons
 that should become clear later). A Formal Public Identifier (FPI) is a very
 common choice. This public identifier is often used to provide a unique and location
-independent key which can be used to subsistute local resources for remote ones 
+independent key which can be used to subsistute local resources for remote ones
 (hint: this is why ;).
 </p>
 <p>
 By using the second (<code>PUBLIC</code>) form combined with some form of local
 catalog (which matches <code><em>public-identifiers</em></code> to local resources) and where
-the <code><em>public-identifier</em></code> is a unique name and the <code><em>system-identifier</em></code> 
-is an internet URL, the practical disadvantages of specifying just a 
-<code><em>system-identifier</em></code> can be avoided. Those external entities which have been 
+the <code><em>public-identifier</em></code> is a unique name and the <code><em>system-identifier</em></code>
+is an internet URL, the practical disadvantages of specifying just a
+<code><em>system-identifier</em></code> can be avoided. Those external entities which have been
 store locally (on the machine parsing the document) can be identified and used.
 Only when no local copy exists is it necessary to download the document
 from the internet URL. This naming scheme is recommended when using <code>Digester</code>.
@@ -1101,22 +1101,22 @@ from the internet URL. This naming scheme is recommended when using <code>Digest
 <h4>External Entity Resolution Using Digester</h4>
 <p>
 SAX factors out the resolution of external entities into an <code>EntityResolver</code>.
-<code>Digester</code> supports the use of custom <code>EntityResolver</code> 
+<code>Digester</code> supports the use of custom <code>EntityResolver</code>
 but ships with a simple internal implementation. This implementation allows local URLs
-to be easily associated with <code><em>public-identifiers</em></code>. 
+to be easily associated with <code><em>public-identifiers</em></code>.
 </p>
 <p>For example:</p>
 <code><pre>
     digester.register("-//Example Dot Com //DTD Sample Example//EN", "assets/sample.dtd");
 </pre></code>
 <p>
-will make digester return the relative file path <code>assets/sample.dtd</code> 
-whenever an external entity with public id 
+will make digester return the relative file path <code>assets/sample.dtd</code>
+whenever an external entity with public id
 <code>-//Example Dot Com //DTD Sample Example//EN</code> is needed.
 </p>
-<p><strong>Note:</strong> This is a simple (but useful) implementation. 
+<p><strong>Note:</strong> This is a simple (but useful) implementation.
 Greater sophistication requires a custom <code>EntityResolver</code>.</p>
-    
+
 <a name="doc.troubleshooting"></a>
 <h3>Troubleshooting</h3>
 <h4>Debugging Exceptions</h4>
@@ -1131,8 +1131,8 @@ Digestion throws two kinds of <code>Exception</code>:
 <p>
 The first is rarely thrown and indicates the kind of fundemental IO exception
 that developers know all about. The second is thrown by SAX parsers when the processing
-of the XML cannot be completed. So, to diagnose the cause a certain familiarity with 
-the way that SAX error handling works is very useful. 
+of the XML cannot be completed. So, to diagnose the cause a certain familiarity with
+the way that SAX error handling works is very useful.
 </p>
 <h5>Diagnosing SAX Exceptions</h5>
 <p>
@@ -1140,8 +1140,8 @@ This is a short, potted guide to SAX error handling strategies. It's not intende
 proper guide to error handling in SAX.
 </p>
 <p>
-When a SAX parser encounters a problem with the xml (well, ok - sometime after it 
-encounters a problem) it will throw a 
+When a SAX parser encounters a problem with the xml (well, ok - sometime after it
+encounters a problem) it will throw a
 <a href='http://www.saxproject.org/apidoc/org/xml/sax/SAXParseException.html'>
 SAXParseException</a>. This is a subclass of <code>SAXException</code> and contains
 a bit of extra information about what exactly when wrong - and more importantly,
@@ -1153,7 +1153,7 @@ to help with diagnosing the reason for the failure.
 <p>
 General <a href='http://www.saxproject.org/apidoc/org/xml/sax/SAXException.html'>
 SAXException</a> instances may wrap a causal exception. When exceptions are
-throw by <code>Digester</code> each of these will be wrapped into a 
+throw by <code>Digester</code> each of these will be wrapped into a
 <code>SAXException</code> and rethrown. So, catch these and examine the wrapped
 exception to diagnose what went wrong.
 </p>
@@ -1180,21 +1180,21 @@ but it's not infallible.
 You might need to grab an instance, configure it and pass it to Digester.
 </p>
 <p>
-If you want to support more than one parser in a portable manner, 
-then you'll probably want to take a look at the 
+If you want to support more than one parser in a portable manner,
+then you'll probably want to take a look at the
 <code>org.apache.commons.digester.parsers</code> package
 and add a new class to support the particular parser that's causing problems.
 </p>
 </li>
-<li><strong>Help! 
+<li><strong>Help!
 I'm Validating Against Schema But Digester Ignores Errors!</strong>
 <p>
 Digester is based on <a href='http://www.saxproject.org'>SAX</a>. The convention for
-SAX parsers is that all errors are reported (to any registered 
-<code>ErrorHandler</code>) but processing continues. Digester (by default) 
-registers its own <code>ErrorHandler</code> implementation. This logs details 
-but does not stop the processing (following the usual convention for SAX 
-based processors). 
+SAX parsers is that all errors are reported (to any registered
+<code>ErrorHandler</code>) but processing continues. Digester (by default)
+registers its own <code>ErrorHandler</code> implementation. This logs details
+but does not stop the processing (following the usual convention for SAX
+based processors).
 </p>
 <p>
 This means that the errors reported by the validation of the schema will appear in the
@@ -1204,16 +1204,16 @@ Digester logs but the processing will continue. To change this behaviour, call
 
 <li><strong>Where Can I Find Example Code?</strong>
 <a name="doc.FAQ.Examples">
-<p>Digester ships with a sample application: a mapping for the <em>Rich Site 
-Summary</em> format used by many newsfeeds. Download the source distribution 
+<p>Digester ships with a sample application: a mapping for the <em>Rich Site
+Summary</em> format used by many newsfeeds. Download the source distribution
 to see how it works.</p>
-<p>Digester also ships with a set of examples demonstrating most of the 
-features described in this document. See the "src/examples" subdirectory 
+<p>Digester also ships with a set of examples demonstrating most of the
+features described in this document. See the "src/examples" subdirectory
 of the source distribution.</p>
 </li>
 <li><strong>When Are You Going To Support <em>Rich Site Summary</em> Version x.y.z?</strong>
 <p>
-The <em>Rich Site Summary</em> application is intended to be a sample application. 
+The <em>Rich Site Summary</em> application is intended to be a sample application.
 It works but we have no plans to add support for other versions of the format.
 </p>
 <p>
@@ -1231,14 +1231,14 @@ commons dev mailing list</a>
 Reflection locates these methods fine and correctly assigns them as public.
 However, an <code>IllegalAccessException</code> is thrown if the method is invoked.</p>
 
-<p><code>MethodUtils</code> contains a workaround for this situation. 
+<p><code>MethodUtils</code> contains a workaround for this situation.
 It will attempt to call <code>setAccessible</code> on this method.
 If this call succeeds, then the method can be invoked as normal.
-This call will only succeed when the application has sufficient security privilages. 
+This call will only succeed when the application has sufficient security privilages.
 If this call fails then a warning will be logged and the method may fail.</p>
 
 <p><code>Digester</code> uses <code>MethodUtils</code> and so there may be an issue accessing methods
-of this kind from a high security environment. If you think that you might be experiencing this 
+of this kind from a high security environment. If you think that you might be experiencing this
 problem, please ask on the mailing list.</p>
 </body>
 </html>

==================================================
Matcher.java
index a056e6c607..58ed21d00c 100644
--- a/java/org/apache/tomcat/util/file/Constants.java
+++ b/java/org/apache/tomcat/util/file/Constants.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
ByteArrayOutputStream.java
index 2f9265b34e..5aa378c07e 100644
--- a/java/org/apache/tomcat/util/file/Matcher.java
+++ b/java/org/apache/tomcat/util/file/Matcher.java
@@ -58,11 +58,11 @@ public final class Matcher {
     /**
      * Tests whether or not a given path matches any pattern in the given set.
      *
-     * If you need to call this method multiple times with the same 
+     * If you need to call this method multiple times with the same
      * pattern you should rather pre parse the pattern using tokenizePathAsArray.
      *
      * @see #tokenizePathAsArray
-     * 
+     *
      * @param patternSet The pattern set to match against. Must not be
      *                <code>null</code>.
      * @param str     The path to match, as a String. Must not be
@@ -83,11 +83,11 @@ public final class Matcher {
     /**
      * Tests whether or not a given path matches a given pattern.
      *
-     * If you need to call this method multiple times with the same 
+     * If you need to call this method multiple times with the same
      * pattern you should rather pre parse the pattern using tokenizePathAsArray.
      *
      * @see #tokenizePathAsArray
-     * 
+     *
      * @param pattern The pattern to match against. Must not be
      *                <code>null</code>.
      * @param str     The path to match, as a String. Must not be
@@ -103,12 +103,12 @@ public final class Matcher {
 
     /**
      * Tests whether or not a given path matches a given pattern.
-     * 
-     * If you need to call this method multiple times with the same 
+     *
+     * If you need to call this method multiple times with the same
      * pattern you should rather pre parse the pattern using tokenizePathAsArray.
      *
      * @see #tokenizePathAsArray
-     * 
+     *
      * @param pattern The pattern to match against. Must not be
      *                <code>null</code>.
      * @param str     The path to match, as a String. Must not be

==================================================
DeferredFileOutputStream.java
index 9a1908bb79..8554fadbbc 100644
--- a/java/org/apache/tomcat/util/http/fileupload/ByteArrayOutputStream.java
+++ b/java/org/apache/tomcat/util/http/fileupload/ByteArrayOutputStream.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -15,7 +15,7 @@
  * limitations under the License.
  */
 package org.apache.tomcat.util.http.fileupload;
- 
+
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -24,10 +24,10 @@ import java.util.ArrayList;
 import java.util.List;
 
 /**
- * This class implements an output stream in which the data is 
- * written into a byte array. The buffer automatically grows as data 
+ * This class implements an output stream in which the data is
+ * written into a byte array. The buffer automatically grows as data
  * is written to it.
- * <p> 
+ * <p>
  * The data can be retrieved using <code>toByteArray()</code> and
  * <code>toString()</code>.
  * <p>
@@ -43,7 +43,7 @@ import java.util.List;
  * the contents don't have to be copied to the new buffer. This class is
  * designed to behave exactly like the original. The only exception is the
  * deprecated toString(int) method that has been ignored.
- * 
+ *
  * @author <a href="mailto:jeremias@apache.org">Jeremias Maerki</a>
  * @author Holger Hoffstatte
  * @version $Id$
@@ -65,16 +65,16 @@ public class ByteArrayOutputStream extends OutputStream {
     private int count;
 
     /**
-     * Creates a new byte array output stream. The buffer capacity is 
-     * initially 1024 bytes, though its size increases if necessary. 
+     * Creates a new byte array output stream. The buffer capacity is
+     * initially 1024 bytes, though its size increases if necessary.
      */
     public ByteArrayOutputStream() {
         this(1024);
     }
 
     /**
-     * Creates a new byte array output stream, with a buffer capacity of 
-     * the specified size, in bytes. 
+     * Creates a new byte array output stream, with a buffer capacity of
+     * the specified size, in bytes.
      *
      * @param size  the initial size
      * @throws IllegalArgumentException if size is negative
@@ -88,7 +88,7 @@ public class ByteArrayOutputStream extends OutputStream {
     }
 
     /**
-     * Return the appropriate <code>byte[]</code> buffer 
+     * Return the appropriate <code>byte[]</code> buffer
      * specified by index.
      *
      * @param index  the index of the buffer required
@@ -108,7 +108,7 @@ public class ByteArrayOutputStream extends OutputStream {
         if (currentBufferIndex < buffers.size() - 1) {
             //Recycling old buffer
             filledBufferSum += currentBuffer.length;
-            
+
             currentBufferIndex++;
             currentBuffer = getBuffer(currentBufferIndex);
         } else {
@@ -119,11 +119,11 @@ public class ByteArrayOutputStream extends OutputStream {
                 filledBufferSum = 0;
             } else {
                 newBufferSize = Math.max(
-                    currentBuffer.length << 1, 
+                    currentBuffer.length << 1,
                     newcount - filledBufferSum);
                 filledBufferSum += currentBuffer.length;
             }
-            
+
             currentBufferIndex++;
             currentBuffer = new byte[newBufferSize];
             buffers.add(currentBuffer);
@@ -138,10 +138,10 @@ public class ByteArrayOutputStream extends OutputStream {
      */
     @Override
     public void write(byte[] b, int off, int len) {
-        if ((off < 0) 
-                || (off > b.length) 
-                || (len < 0) 
-                || ((off + len) > b.length) 
+        if ((off < 0)
+                || (off > b.length)
+                || (len < 0)
+                || ((off + len) > b.length)
                 || ((off + len) < 0)) {
             throw new IndexOutOfBoundsException();
         } else if (len == 0) {
@@ -269,7 +269,7 @@ public class ByteArrayOutputStream extends OutputStream {
     public synchronized byte[] toByteArray() {
         int remaining = count;
         if (remaining == 0) {
-            return EMPTY_BYTE_ARRAY; 
+            return EMPTY_BYTE_ARRAY;
         }
         byte newbuf[] = new byte[remaining];
         int pos = 0;

==================================================
FileCleaningTracker.java
index 201af865c1..752d5b11a4 100644
--- a/java/org/apache/tomcat/util/http/fileupload/DeferredFileOutputStream.java
+++ b/java/org/apache/tomcat/util/http/fileupload/DeferredFileOutputStream.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -81,7 +81,7 @@ public class DeferredFileOutputStream
      */
     private File directory;
 
-    
+
     /**
      * True when close() has been called successfully.
      */
@@ -221,8 +221,8 @@ public class DeferredFileOutputStream
     {
         return outputFile;
     }
-    
-        
+
+
     /**
      * Closes underlying output stream, and mark this as closed
      *
@@ -234,8 +234,8 @@ public class DeferredFileOutputStream
         super.close();
         closed = true;
     }
-    
-    
+
+
     /**
      * Writes the data from this output stream to the specified output stream,
      * after it has been closed.
@@ -243,7 +243,7 @@ public class DeferredFileOutputStream
      * @param out output stream to write to.
      * @exception IOException if this stream is not yet closed or an error occurs.
      */
-    public void writeTo(OutputStream out) throws IOException 
+    public void writeTo(OutputStream out) throws IOException
     {
         // we may only need to check if this is closed if we are working with a file
         // but we should force the habit of closing wether we are working with
@@ -252,7 +252,7 @@ public class DeferredFileOutputStream
         {
             throw new IOException("Stream not closed");
         }
-        
+
         if(isInMemory())
         {
             memoryOutputStream.writeTo(out);

==================================================
FileDeleteStrategy.java
index df16f2ad19..aa20291fe8 100644
--- a/java/org/apache/tomcat/util/http/fileupload/FileCleaningTracker.java
+++ b/java/org/apache/tomcat/util/http/fileupload/FileCleaningTracker.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -121,7 +121,7 @@ public class FileCleaningTracker {
 
     /**
      * Adds a tracker to the list of trackers.
-     * 
+     *
      * @param path  the full path to the file to be tracked, not null
      * @param marker  the marker object used to track the file, not null
      * @param deleteStrategy  the strategy to delete the file, null means normal

==================================================
FileUtils.java
index 2c379aec63..dcc71966ae 100644
--- a/java/org/apache/tomcat/util/http/fileupload/FileDeleteStrategy.java
+++ b/java/org/apache/tomcat/util/http/fileupload/FileDeleteStrategy.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
IOUtils.java
index 4609421901..0071b88061 100644
--- a/java/org/apache/tomcat/util/http/fileupload/FileUtils.java
+++ b/java/org/apache/tomcat/util/http/fileupload/FileUtils.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -67,7 +67,7 @@ public class FileUtils {
 
     //-----------------------------------------------------------------------
     /**
-     * Deletes a directory recursively. 
+     * Deletes a directory recursively.
      *
      * @param directory  directory to delete
      * @throws IOException in case deletion is unsuccessful
@@ -122,8 +122,8 @@ public class FileUtils {
             throw exception;
         }
     }
-    
-    
+
+
     //-----------------------------------------------------------------------
     /**
      * Deletes a file. If file is a directory, delete it and all sub-directories.

==================================================
ThresholdingOutputStream.java
index efdd0fdc1d..d8eace505d 100644
--- a/java/org/apache/tomcat/util/http/fileupload/IOUtils.java
+++ b/java/org/apache/tomcat/util/http/fileupload/IOUtils.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -111,7 +111,7 @@ public class IOUtils {
      * <code>-1</code> after the copy has completed since the correct
      * number of bytes cannot be returned as an int. For large streams
      * use the <code>copyLarge(InputStream, OutputStream)</code> method.
-     * 
+     *
      * @param input  the <code>InputStream</code> to read from
      * @param output  the <code>OutputStream</code> to write to
      * @return the number of bytes copied
@@ -134,7 +134,7 @@ public class IOUtils {
      * <p>
      * This method buffers the input internally, so there is no need to use a
      * <code>BufferedInputStream</code>.
-     * 
+     *
      * @param input  the <code>InputStream</code> to read from
      * @param output  the <code>OutputStream</code> to write to
      * @return the number of bytes copied

==================================================
Mapper.java
index 31e6414e69..8fa6677101 100644
--- a/java/org/apache/tomcat/util/http/fileupload/package.html
+++ b/java/org/apache/tomcat/util/http/fileupload/package.html
@@ -38,7 +38,7 @@
       involves one of the provided extensions of
       {@link org.apache.tomcat.util.http.fileupload.FileUpload FileUpload} such as
       {@link org.apache.tomcat.util.http.fileupload.servlet.ServletFileUpload ServletFileUpload}
-      together with a factory for 
+      together with a factory for
       {@link org.apache.tomcat.util.http.fileupload.FileItem FileItem} instances,
       such as
       {@link org.apache.tomcat.util.http.fileupload.disk.DiskFileItemFactory DiskFileItemFactory}.

==================================================
SystemLogHandler.java
index 4621e26654..4add564a8c 100644
--- a/java/org/apache/tomcat/util/http/mapper/Mapper.java
+++ b/java/org/apache/tomcat/util/http/mapper/Mapper.java
@@ -36,7 +36,7 @@ public final class Mapper {
 
     private static final org.apache.juli.logging.Log log =
         org.apache.juli.logging.LogFactory.getLog(Mapper.class);
-    
+
     protected static final StringManager sm =
         StringManager.getManager(Mapper.class.getPackage().getName());
 
@@ -142,7 +142,7 @@ public final class Mapper {
             return;
         }
         Host realHost = hosts[pos];
-        
+
         Host[] newHosts = new Host[hosts.length + 1];
         Host newHost = new Host();
         newHost.name = alias;
@@ -229,9 +229,9 @@ public final class Mapper {
                     }
                     pos2 = find(newContexts, path);
                 }
-                
+
                 Context mappedContext = mappedHost.contextList.contexts[pos2];
-                
+
                 ContextVersion[] contextVersions = mappedContext.versions;
                 ContextVersion[] newContextVersions =
                     new ContextVersion[contextVersions.length + 1];
@@ -271,19 +271,19 @@ public final class Mapper {
                 if (contexts.length == 0 ){
                     return;
                 }
-                
+
                 int pos2 = find(contexts, path);
                 if (pos2 < 0 || !path.equals(contexts[pos2].name)) {
                     return;
                 }
                 Context context = contexts[pos2];
-                
+
                 ContextVersion[] contextVersions = context.versions;
                 ContextVersion[] newContextVersions =
                     new ContextVersion[contextVersions.length - 1];
                 if (removeMap(contextVersions, newContextVersions, version)) {
                     context.versions = newContextVersions;
-                    
+
                     if (context.versions.length == 0) {
                         // Remove the context
                         Context[] newContexts = new Context[contexts.length -1];
@@ -452,7 +452,7 @@ public final class Mapper {
     }
 
     protected void removeWrapper(ContextVersion context, String path) {
-        
+
         if (log.isDebugEnabled()) {
             log.debug(sm.getString("mapper.removeWrapper", context.name, path));
         }
@@ -512,7 +512,7 @@ public final class Mapper {
 
     /**
      * Add a welcome file to the given context.
-     * 
+     *
      * @param hostName
      * @param contextPath
      * @param welcomeFile
@@ -553,11 +553,11 @@ public final class Mapper {
             }
         }
     }
-    
-    
+
+
     /**
      * Remove a welcome file from the given context.
-     * 
+     *
      * @param hostName
      * @param contextPath
      * @param welcomeFile
@@ -610,11 +610,11 @@ public final class Mapper {
             }
         }
     }
-    
-    
+
+
     /**
      * Clear the welcome files for the given context.
-     * 
+     *
      * @param hostName
      * @param contextPath
      */
@@ -649,8 +649,8 @@ public final class Mapper {
             }
         }
     }
-    
-    
+
+
     /**
      * Map the specified host name and URI, mutating the given mapping data.
      *
@@ -707,7 +707,7 @@ public final class Mapper {
         Context[] contexts = null;
         Context context = null;
         ContextVersion contextVersion = null;
-        
+
         int nesting = 0;
 
         // Virtual host mapping
@@ -787,7 +787,7 @@ public final class Mapper {
                 }
                 mappingData.contexts = contextObjects;
             }
-            
+
             if (version == null) {
                 // Return the latest version
                 contextVersion = contextVersions[versionCount - 1];
@@ -845,7 +845,7 @@ public final class Mapper {
         boolean checkJspWelcomeFiles = false;
         Wrapper[] wildcardWrappers = contextVersion.wildcardWrappers;
         if (mappingData.wrapper == null) {
-            internalMapWildcardWrapper(wildcardWrappers, contextVersion.nesting, 
+            internalMapWildcardWrapper(wildcardWrappers, contextVersion.nesting,
                                        path, mappingData);
             if (mappingData.wrapper != null && mappingData.jspWildCard) {
                 char[] buf = path.getBuffer();
@@ -857,7 +857,7 @@ public final class Mapper {
                      * Force the context's welcome files, which are interpreted
                      * as JSP files (since they match the url-pattern), to be
                      * considered. See Bugzilla 27664.
-                     */ 
+                     */
                     mappingData.wrapper = null;
                     checkJspWelcomeFiles = true;
                 } else {
@@ -906,7 +906,7 @@ public final class Mapper {
                     // Rule 4b -- Welcome resources processing for prefix match
                     if (mappingData.wrapper == null) {
                         internalMapWildcardWrapper
-                            (wildcardWrappers, contextVersion.nesting, 
+                            (wildcardWrappers, contextVersion.nesting,
                              path, mappingData);
                     }
 
@@ -929,10 +929,10 @@ public final class Mapper {
                                 mappingData.wrapper =
                                     contextVersion.defaultWrapper.object;
                                 mappingData.requestPath.setChars
-                                    (path.getBuffer(), path.getStart(), 
+                                    (path.getBuffer(), path.getStart(),
                                      path.getLength());
                                 mappingData.wrapperPath.setChars
-                                    (path.getBuffer(), path.getStart(), 
+                                    (path.getBuffer(), path.getStart(),
                                      path.getLength());
                                 mappingData.requestPath.setString(pathStr);
                                 mappingData.wrapperPath.setString(pathStr);
@@ -944,13 +944,13 @@ public final class Mapper {
                 path.setOffset(servletPath);
                 path.setEnd(pathEnd);
             }
-                                        
+
         }
 
         /* welcome file processing - take 2
          * Now that we have looked for welcome files with a physical
          * backing, now look for an extension mapping listed
-         * but may not have a physical backing to it. This is for 
+         * but may not have a physical backing to it. This is for
          * the case of index.jsf, index.do, etc.
          * A watered down version of rule 4
          */
@@ -998,8 +998,8 @@ public final class Mapper {
                     // Swallow, since someone else handles the 404
                 }
                 if (file != null && file instanceof DirContext) {
-                    // Note: this mutates the path: do not do any processing 
-                    // after this (since we set the redirectPath, there 
+                    // Note: this mutates the path: do not do any processing
+                    // after this (since we set the redirectPath, there
                     // shouldn't be any)
                     path.setOffset(pathOffset);
                     path.append('/');
@@ -1036,7 +1036,7 @@ public final class Mapper {
      * Wildcard mapping.
      */
     private final void internalMapWildcardWrapper
-        (Wrapper[] wrappers, int nesting, CharChunk path, 
+        (Wrapper[] wrappers, int nesting, CharChunk path,
          MappingData mappingData) {
 
         int pathEnd = path.getEnd();
@@ -1085,7 +1085,7 @@ public final class Mapper {
 
     /**
      * Extension mappings.
-     * 
+     *
      * @param wrappers          Set of wrappers to check for matches
      * @param path              Path to map
      * @param mappingData       Mapping data for result
@@ -1155,10 +1155,10 @@ public final class Mapper {
         if (b == -1) {
             return -1;
         }
-        
+
         if (compare(name, start, end, map[0].name) < 0 ) {
             return -1;
-        }         
+        }
         if (b == 0) {
             return 0;
         }
@@ -1213,7 +1213,7 @@ public final class Mapper {
         }
         if (compareIgnoreCase(name, start, end, map[0].name) < 0 ) {
             return -1;
-        }         
+        }
         if (b == 0) {
             return 0;
         }
@@ -1256,10 +1256,10 @@ public final class Mapper {
         if (b == -1) {
             return -1;
         }
-        
+
         if (name.compareTo(map[0].name) < 0) {
             return -1;
-        } 
+        }
         if (b == 0) {
             return 0;
         }

==================================================
AttributeInfo.java
index 1549c526a8..cc41d08c58 100644
--- a/java/org/apache/tomcat/util/log/SystemLogHandler.java
+++ b/java/org/apache/tomcat/util/log/SystemLogHandler.java
@@ -23,9 +23,9 @@ import java.util.EmptyStackException;
 import java.util.Stack;
 
 /**
- * This helper class may be used to do sophisticated redirection of 
+ * This helper class may be used to do sophisticated redirection of
  * System.out and System.err on a per Thread basis.
- * 
+ *
  * A stack is implemented per Thread so that nested startCapture
  * and stopCapture can be used.
  *

==================================================
BaseAttributeFilter.java
index 21d65d9f1c..89586d29bb 100644
--- a/java/org/apache/tomcat/util/modeler/AttributeInfo.java
+++ b/java/org/apache/tomcat/util/modeler/AttributeInfo.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -38,7 +38,7 @@ public class AttributeInfo extends FeatureInfo {
     protected boolean readable = true;
     protected boolean writeable = true;
     protected boolean is = false;
-    
+
     // ------------------------------------------------------------- Properties
 
     /**
@@ -56,7 +56,7 @@ public class AttributeInfo extends FeatureInfo {
      * The name of the property getter method, if non-standard.
      */
     public String getGetMethod() {
-        if(getMethod == null) 
+        if(getMethod == null)
             getMethod = getMethodName(getName(), true, isIs());
         return (this.getMethod);
     }

==================================================
BaseModelMBean.java
index 2405638829..f5601d7e55 100644
--- a/java/org/apache/tomcat/util/modeler/BaseAttributeFilter.java
+++ b/java/org/apache/tomcat/util/modeler/BaseAttributeFilter.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
BaseNotificationBroadcaster.java
index 7d5145b1db..c2b08f2537 100644
--- a/java/org/apache/tomcat/util/modeler/BaseModelMBean.java
+++ b/java/org/apache/tomcat/util/modeler/BaseModelMBean.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -51,7 +51,7 @@ import org.apache.juli.logging.LogFactory;
 
 /*
  * Changes from commons.modeler:
- * 
+ *
  *  - use DynamicMBean
  *  - remove methods not used in tomcat and redundant/not very generic
  *  - must be created from the ManagedBean - I don't think there were any direct
@@ -59,14 +59,14 @@ import org.apache.juli.logging.LogFactory;
  *  - some of the gratuitous flexibility removed - instead this is more predictive and
  *    strict with the use cases.
  *  - all Method and metadata is stored in ManagedBean. BaseModelBMean and ManagedBean act
- *    like Object and Class. 
+ *    like Object and Class.
  *  - setModelMBean is no longer called on resources ( not used in tomcat )
- *  - no caching of Methods for now - operations and setters are not called repeatedly in most 
+ *  - no caching of Methods for now - operations and setters are not called repeatedly in most
  *  management use cases. Getters should't be called very frequently either - and even if they
  *  are, the overhead of getting the method should be small compared with other JMX costs ( RMI, etc ).
  *  We can add getter cache if needed.
  *  - removed unused constructor, fields
- *  
+ *
  *  TODO:
  *   - clean up catalina.mbeans, stop using weird inheritance
  */
@@ -76,7 +76,7 @@ import org.apache.juli.logging.LogFactory;
  * supports the minimal requirements of the interface contract.</p>
  *
  * <p>This can be used directly to wrap an existing java bean, or inside
- * an mlet or anywhere an MBean would be used. 
+ * an mlet or anywhere an MBean would be used.
  *
  * Limitations:
  * <ul>
@@ -131,7 +131,7 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration, ModelMBe
      * Notification broadcaster for general notifications.
      */
     protected BaseNotificationBroadcaster generalBroadcaster = null;
-    
+
     /** Metadata for the mbean instance.
      */
     protected ManagedBean managedBean = null;
@@ -145,7 +145,7 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration, ModelMBe
     // TODO: move to ManagedBean
     static final Object[] NO_ARGS_PARAM = new Object[0];
     static final Class<?>[] NO_ARGS_PARAM_SIG = new Class[0];
-    
+
     protected String resourceType = null;
 
     // key: operation val: invoke method
@@ -173,11 +173,11 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration, ModelMBe
                 (new IllegalArgumentException("Attribute name is null"),
                  "Attribute name is null");
 
-        if( (resource instanceof DynamicMBean) && 
+        if( (resource instanceof DynamicMBean) &&
              ! ( resource instanceof BaseModelMBean )) {
             return ((DynamicMBean)resource).getAttribute(name);
         }
-        
+
         Method m=managedBean.getGetter(name, this, resource);
         Object result = null;
         try {
@@ -275,13 +275,13 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration, ModelMBe
      */
     @Override
     public Object invoke(String name, Object params[], String signature[])
-        throws MBeanException, ReflectionException 
+        throws MBeanException, ReflectionException
     {
-        if( (resource instanceof DynamicMBean) && 
+        if( (resource instanceof DynamicMBean) &&
              ! ( resource instanceof BaseModelMBean )) {
             return ((DynamicMBean)resource).invoke(name, params, signature);
         }
-    
+
         // Validate the input parameters
         if (name == null)
             throw new RuntimeOperationsException
@@ -291,7 +291,7 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration, ModelMBe
         if( log.isDebugEnabled()) log.debug("Invoke " + name);
 
         Method method= managedBean.getInvoke(name, params, signature, this, resource);
-        
+
         // Invoke the selected method on the appropriate object
         Object result = null;
         try {
@@ -349,7 +349,7 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration, ModelMBe
             try {
                 ClassLoader cl=Thread.currentThread().getContextClassLoader();
                 if( cl!=null )
-                    return cl.loadClass(signature); 
+                    return cl.loadClass(signature);
             } catch( ClassNotFoundException e ) {
             }
             try {
@@ -382,16 +382,16 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration, ModelMBe
         if( log.isDebugEnabled() )
             log.debug("Setting attribute " + this + " " + attribute );
 
-        if( (resource instanceof DynamicMBean) && 
+        if( (resource instanceof DynamicMBean) &&
              ! ( resource instanceof BaseModelMBean )) {
             try {
                 ((DynamicMBean)resource).setAttribute(attribute);
             } catch (InvalidAttributeValueException e) {
-                throw new MBeanException(e);                
+                throw new MBeanException(e);
             }
             return;
         }
-        
+
         // Validate the input parameters
         if (attribute == null)
             throw new RuntimeOperationsException
@@ -451,7 +451,7 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration, ModelMBe
 
     @Override
     public String toString() {
-        if( resource==null ) 
+        if( resource==null )
             return "BaseModelMbean[" + resourceType + "]";
         return resource.toString();
     }
@@ -470,7 +470,7 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration, ModelMBe
         // Validate the input parameters
         if (attributes == null)
             return response;
-        
+
         // Prepare and return our response, eating all exceptions
         String names[] = new String[attributes.size()];
         int n = 0;
@@ -546,7 +546,7 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration, ModelMBe
      *  resource type is <code>null</code> or invalid
      */
     public void setManagedResource(Object resource, String type)
-        throws InstanceNotFoundException, 
+        throws InstanceNotFoundException,
         MBeanException, RuntimeOperationsException
     {
         if (resource == null)
@@ -559,7 +559,7 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration, ModelMBe
 
         this.resource = resource;
         this.resourceType = resource.getClass().getName();
-        
+
 //        // Make the resource aware of the model mbean.
 //        try {
 //            Method m=resource.getClass().getMethod("setModelMBean",
@@ -1028,7 +1028,7 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration, ModelMBe
 //
 //            // The class c doesn't need to exist
 //            ManagedBean descriptor=getRegistry().findManagedBean(c, type);
-//            if( descriptor==null ) 
+//            if( descriptor==null )
 //                return;
 //            this.setModelMBeanInfo(descriptor.createMBeanInfo());
 //        } catch( Throwable ex) {

==================================================
ConstructorInfo.java
index 08d2d1882d..65f7a4bfd5 100644
--- a/java/org/apache/tomcat/util/modeler/BaseNotificationBroadcaster.java
+++ b/java/org/apache/tomcat/util/modeler/BaseNotificationBroadcaster.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
FeatureInfo.java
index 9cb27149ed..c793fb44df 100644
--- a/java/org/apache/tomcat/util/modeler/ConstructorInfo.java
+++ b/java/org/apache/tomcat/util/modeler/ConstructorInfo.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -44,7 +44,7 @@ public class ConstructorInfo extends OperationInfo {
     public MBeanConstructorInfo createConstructorInfo() {
         // Return our cached information (if any)
         if (info == null) {
-            info = new MBeanConstructorInfo(getName(), getDescription(), 
+            info = new MBeanConstructorInfo(getName(), getDescription(),
                     getMBeanParameterInfo());
         }
         return (MBeanConstructorInfo)info;

==================================================
FixedNotificationFilter.java
index cd01476a29..2262e7ebd6 100644
--- a/java/org/apache/tomcat/util/modeler/FeatureInfo.java
+++ b/java/org/apache/tomcat/util/modeler/FeatureInfo.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -36,15 +36,15 @@ import javax.management.MBeanFeatureInfo;
 
 public class FeatureInfo implements Serializable {
     static final long serialVersionUID = -911529176124712296L;
-    
+
     protected String description = null;
     protected String name = null;
     protected MBeanFeatureInfo info = null;
-    
+
     // all have type except Constructor
     protected String type = null;
 
-    
+
     // ------------------------------------------------------------- Properties
 
     /**

==================================================
ManagedBean.java
index 0757356872..624cfef035 100644
--- a/java/org/apache/tomcat/util/modeler/FixedNotificationFilter.java
+++ b/java/org/apache/tomcat/util/modeler/FixedNotificationFilter.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
NotificationInfo.java
index 177c266b4d..8160e86017 100644
--- a/java/org/apache/tomcat/util/modeler/ManagedBean.java
+++ b/java/org/apache/tomcat/util/modeler/ManagedBean.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -48,7 +48,7 @@ import javax.management.ServiceNotFoundException;
 public class ManagedBean implements java.io.Serializable {
 
     private static final long serialVersionUID = 1L;
-    
+
     private static final String BASE_MBEAN = "org.apache.tomcat.util.modeler.BaseModelMBean";
     // ----------------------------------------------------- Instance Variables
     static final Object[] NO_ARGS_PARAM = new Object[0];
@@ -66,7 +66,7 @@ public class ManagedBean implements java.io.Serializable {
 
     private Map<String,OperationInfo> operations =
         new HashMap<String,OperationInfo>();
-    
+
     protected String className = BASE_MBEAN;
     //protected ConstructorInfo constructors[] = new ConstructorInfo[0];
     protected String description = null;
@@ -78,9 +78,9 @@ public class ManagedBean implements java.io.Serializable {
     protected NotificationInfo notifications[] = new NotificationInfo[0];
     protected String type = null;
 
-    /** Constructor. Will add default attributes. 
-     *  
-     */ 
+    /** Constructor. Will add default attributes.
+     *
+     */
     public ManagedBean() {
         AttributeInfo ai=new AttributeInfo();
         ai.setName("modelerType");
@@ -89,7 +89,7 @@ public class ManagedBean implements java.io.Serializable {
         ai.setWriteable(false);
         addAttribute(ai);
     }
-    
+
     // ------------------------------------------------------------- Properties
 
 
@@ -356,8 +356,8 @@ public class ManagedBean implements java.io.Serializable {
                 clazz = Class.forName(getClassName());
             } catch (Exception e) {
             }
-          
-            if( clazz==null ) {  
+
+            if( clazz==null ) {
                 try {
                     ClassLoader cl= Thread.currentThread().getContextClassLoader();
                     if ( cl != null)
@@ -366,8 +366,8 @@ public class ManagedBean implements java.io.Serializable {
                     ex=e;
                 }
             }
-    
-            if( clazz==null) { 
+
+            if( clazz==null) {
                 throw new MBeanException
                     (ex, "Cannot load ModelMBean class " + getClassName());
             }
@@ -382,9 +382,9 @@ public class ManagedBean implements java.io.Serializable {
                      getClassName());
             }
         }
-        
+
         mbean.setManagedBean(this);
-        
+
         // Set the managed resource (if any)
         try {
             if (instance != null)
@@ -426,20 +426,20 @@ public class ManagedBean implements java.io.Serializable {
 //            new ModelMBeanConstructorInfo[consts.length];
 //        for (int i = 0; i < consts.length; i++)
 //            constructors[i] = consts[i].createConstructorInfo();
-        
+
         NotificationInfo notifs[] = getNotifications();
         MBeanNotificationInfo notifications[] =
             new MBeanNotificationInfo[notifs.length];
         for (int i = 0; i < notifs.length; i++)
             notifications[i] = notifs[i].createNotificationInfo();
 
-        
+
         // Construct and return a new ModelMBeanInfo object
-        info = new MBeanInfo(getClassName(), 
+        info = new MBeanInfo(getClassName(),
                              getDescription(),
-                             attributes, 
-                             new MBeanConstructorInfo[] {}, 
-                             operations, 
+                             attributes,
+                             new MBeanConstructorInfo[] {},
+                             operations,
                              notifications);
 //        try {
 //            Descriptor descriptor = info.getMBeanDescriptor();
@@ -482,7 +482,7 @@ public class ManagedBean implements java.io.Serializable {
 
     }
 
-    Method getGetter(String aname, BaseModelMBean mbean, Object resource) 
+    Method getGetter(String aname, BaseModelMBean mbean, Object resource)
             throws AttributeNotFoundException, ReflectionException {
 
         Method m = null;
@@ -491,7 +491,7 @@ public class ManagedBean implements java.io.Serializable {
         // Look up the actual operation to be used
         if (attrInfo == null)
             throw new AttributeNotFoundException(" Cannot find attribute " + aname + " for " + resource);
-        
+
         String getMethod = attrInfo.getGetMethod();
         if (getMethod == null)
             throw new AttributeNotFoundException("Cannot find attribute " + aname + " get method name");
@@ -520,7 +520,7 @@ public class ManagedBean implements java.io.Serializable {
         return m;
     }
 
-    public Method getSetter(String aname, BaseModelMBean bean, Object resource) 
+    public Method getSetter(String aname, BaseModelMBean bean, Object resource)
             throws AttributeNotFoundException, ReflectionException {
 
         Method m = null;
@@ -564,11 +564,11 @@ public class ManagedBean implements java.io.Serializable {
         return m;
     }
 
-    public Method getInvoke(String aname, Object[] params, String[] signature, BaseModelMBean bean, Object resource) 
+    public Method getInvoke(String aname, Object[] params, String[] signature, BaseModelMBean bean, Object resource)
             throws MBeanException, ReflectionException {
 
         Method method = null;
-        
+
         if (params == null)
             params = new Object[0];
         if (signature == null)

==================================================
OperationInfo.java
index ea4368d071..0b30b662f9 100644
--- a/java/org/apache/tomcat/util/modeler/NotificationInfo.java
+++ b/java/org/apache/tomcat/util/modeler/NotificationInfo.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
ParameterInfo.java
index 3796471f35..e6958b0f73 100644
--- a/java/org/apache/tomcat/util/modeler/OperationInfo.java
+++ b/java/org/apache/tomcat/util/modeler/OperationInfo.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -44,7 +44,7 @@ public class OperationInfo extends FeatureInfo {
         super();
 
     }
-   
+
     // ----------------------------------------------------- Instance Variables
 
     protected String impact = "UNKNOWN";
@@ -142,8 +142,8 @@ public class OperationInfo extends FeatureInfo {
                 impact = MBeanOperationInfo.ACTION_INFO;
             else if ("INFO".equals(getImpact()))
                 impact = MBeanOperationInfo.INFO;
-    
-            info = new MBeanOperationInfo(getName(), getDescription(), 
+
+            info = new MBeanOperationInfo(getName(), getDescription(),
                                           getMBeanParameterInfo(),
                                           getReturnType(), impact);
         }

==================================================
Registry.java
index 13fcefd689..58b2f70aec 100644
--- a/java/org/apache/tomcat/util/modeler/ParameterInfo.java
+++ b/java/org/apache/tomcat/util/modeler/ParameterInfo.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
RegistryMBean.java
index 2af6c2d917..b52076e349 100644
--- a/java/org/apache/tomcat/util/modeler/Registry.java
+++ b/java/org/apache/tomcat/util/modeler/Registry.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -47,15 +47,15 @@ import org.apache.tomcat.util.modeler.modules.ModelerSource;
 /*
    Issues:
    - exceptions - too many "throws Exception"
-   - double check the interfaces 
+   - double check the interfaces
    - start removing the use of the experimental methods in tomcat, then remove
      the methods ( before 1.1 final )
    - is the security enough to prevent Registry beeing used to avoid the permission
     checks in the mbean server ?
-*/ 
+*/
 
 /**
- * Registry for modeler MBeans. 
+ * Registry for modeler MBeans.
  *
  * This is the main entry point into modeler. It provides methods to create
  * and manipulate model mbeans and simplify their use.
@@ -63,12 +63,12 @@ import org.apache.tomcat.util.modeler.modules.ModelerSource;
  * Starting with version 1.1, this is no longer a singleton and the static
  * methods are strongly deprecated. In a container environment we can expect
  * different applications to use different registries.
- * 
+ *
  * This class is itself an mbean.
- * 
- * IMPORTANT: public methods not marked with @since x.x are experimental or 
- * internal. Should not be used.  
- * 
+ *
+ * IMPORTANT: public methods not marked with @since x.x are experimental or
+ * internal. Should not be used.
+ *
  * @author Craig R. McClanahan
  * @author Costin Manolache
  */
@@ -79,7 +79,7 @@ public class Registry implements RegistryMBean, MBeanRegistration  {
     private static final Log log = LogFactory.getLog(Registry.class);
 
     // Support for the factory methods
-    
+
     /** Will be used to isolate different apps and enhance security.
      */
     private static HashMap<Object,Registry> perLoaderRegistries = null;
@@ -91,7 +91,7 @@ public class Registry implements RegistryMBean, MBeanRegistration  {
     private static Registry registry = null;
 
     // Per registy fields
-    
+
     /**
      * The <code>MBeanServer</code> instance that we will use to register
      * management beans.
@@ -110,9 +110,9 @@ public class Registry implements RegistryMBean, MBeanRegistration  {
     private HashMap<String,ManagedBean> descriptorsByClass =
         new HashMap<String,ManagedBean>();
 
-    // map to avoid duplicated searching or loading descriptors 
+    // map to avoid duplicated searching or loading descriptors
     private HashMap<String,URL> searchedPaths=new HashMap<String,URL>();
-    
+
     private Object guard;
 
     // Id - small ints to use array access. No reset on stop()
@@ -121,7 +121,7 @@ public class Registry implements RegistryMBean, MBeanRegistration  {
         new Hashtable<String,Hashtable<String,Integer>>();
     private Hashtable<String,int[]> ids = new Hashtable<String,int[]>();
 
-    
+
     // ----------------------------------------------------------- Constructors
 
     /**
@@ -132,7 +132,7 @@ public class Registry implements RegistryMBean, MBeanRegistration  {
 
     // -------------------- Static methods  --------------------
     // Factories
-    
+
     /**
      * Factory method to create (if necessary) and return our
      * <code>Registry</code> instance.
@@ -142,10 +142,10 @@ public class Registry implements RegistryMBean, MBeanRegistration  {
      *
      * The current version uses a static - future versions could use
      * the thread class loader.
-     * 
+     *
      * @param key Support for application isolation. If null, the context class
-     * loader will be used ( if setUseContextClassLoader is called ) or the 
-     * default registry is returned. 
+     * loader will be used ( if setUseContextClassLoader is called ) or the
+     * default registry is returned.
      * @param guard Prevent access to the registry by untrusted components
      *
      * @since 1.1
@@ -153,7 +153,7 @@ public class Registry implements RegistryMBean, MBeanRegistration  {
     public static synchronized Registry getRegistry(Object key, Object guard) {
         Registry localRegistry;
         if( perLoaderRegistries!=null ) {
-            if( key==null ) 
+            if( key==null )
                 key=Thread.currentThread().getContextClassLoader();
             if( key != null ) {
                 localRegistry = perLoaderRegistries.get(key);
@@ -166,13 +166,13 @@ public class Registry implements RegistryMBean, MBeanRegistration  {
                 }
                 if( localRegistry.guard != null &&
                         localRegistry.guard != guard ) {
-                    return null; // XXX Should I throw a permission ex ? 
+                    return null; // XXX Should I throw a permission ex ?
                 }
                 return localRegistry;
             }
         }
 
-        // static 
+        // static
         if (registry == null) {
             registry = new Registry();
         }
@@ -182,12 +182,12 @@ public class Registry implements RegistryMBean, MBeanRegistration  {
         }
         return (registry);
     }
-    
-    /** 
+
+    /**
      * Allow containers to isolate apps. Can be called only once.
      * It  is highly recommended you call this method if using Registry in
      * a container environment. The default is false for backward compatibility
-     * 
+     *
      * @param enable
      * @since 1.1
      */
@@ -196,26 +196,26 @@ public class Registry implements RegistryMBean, MBeanRegistration  {
             perLoaderRegistries = new HashMap<Object,Registry>();
         }
     }
-    
+
     // -------------------- Generic methods  --------------------
 
     /** Lifecycle method - clean up the registry metadata.
      *  Called from resetMetadata().
-     * 
+     *
      * @since 1.1
-     */ 
+     */
     @Override
     public void stop() {
         descriptorsByClass = new HashMap<String,ManagedBean>();
         descriptors = new HashMap<String,ManagedBean>();
         searchedPaths=new HashMap<String,URL>();
     }
-    
-    /** 
+
+    /**
      * Load an extended mlet file. The source can be an URL, File or
-     * InputStream. 
-     * 
-     * All mbeans will be instantiated, registered and the attributes will be 
+     * InputStream.
+     *
+     * All mbeans will be instantiated, registered and the attributes will be
      * set. The result is a list of ObjectNames.
      *
      * @param source InputStream or URL of the file
@@ -223,35 +223,35 @@ public class Registry implements RegistryMBean, MBeanRegistration  {
      *        default JMX mechanism ( i.e. all registered loaders )
      * @return List of ObjectName for the loaded mbeans
      * @throws Exception
-     * 
+     *
      * @since 1.1
-     */ 
+     */
     @Override
     public List<ObjectName> loadMBeans( Object source, ClassLoader cl )
             throws Exception
     {
         return load("MbeansSource", source, null );
-    }    
+    }
 
 
-    /** Load descriptors. The source can be a File or URL or InputStream for the 
+    /** Load descriptors. The source can be a File or URL or InputStream for the
      * descriptors file. In the case of File and URL, if the extension is ".ser"
-     * a serialized version will be loaded. 
-     * 
+     * a serialized version will be loaded.
+     *
      * This method should be used to explicitly load metadata - but this is not
      * required in most cases. The registerComponent() method will find metadata
      * in the same package.
-     * 
+     *
      * @param source
-     */ 
+     */
     @Override
     public void loadMetadata(Object source ) throws Exception {
         loadDescriptors( null, source, null );
     }
 
-    /** Register a bean by creating a modeler mbean and adding it to the 
+    /** Register a bean by creating a modeler mbean and adding it to the
      * MBeanServer.
-     * 
+     *
      * If metadata is not loaded, we'll look up and read a file named
      * "mbeans-descriptors.ser" or "mbeans-descriptors.xml" in the same package
      * or parent.
@@ -260,15 +260,15 @@ public class Registry implements RegistryMBean, MBeanRegistration  {
      * to a model mbean and we'll wrap it - so modeler services will be supported
      *
      * If the metadata is still not found, introspection will be used to extract
-     * it automatically. 
-     * 
+     * it automatically.
+     *
      * If an mbean is already registered under this name, it'll be first
      * unregistered.
-     * 
+     *
      * If the component implements MBeanRegistration, the methods will be called.
      * If the method has a method "setRegistry" that takes a RegistryMBean as
      * parameter, it'll be called with the current registry.
-     * 
+     *
      *
      * @param bean Object to be registered
      * @param oname Name used for registration
@@ -277,21 +277,21 @@ public class Registry implements RegistryMBean, MBeanRegistration  {
      * by subclasses.
      *
      * @since 1.1
-     */ 
+     */
     @Override
     public void registerComponent(Object bean, String oname, String type)
            throws Exception
     {
-        registerComponent(bean, new ObjectName(oname), type);        
-    }    
+        registerComponent(bean, new ObjectName(oname), type);
+    }
 
     /** Unregister a component. We'll first check if it is registered,
      * and mask all errors. This is mostly a helper.
-     * 
+     *
      * @param oname
-     * 
+     *
      * @since 1.1
-     */ 
+     */
     @Override
     public void unregisterComponent( String oname ) {
         try {
@@ -299,8 +299,8 @@ public class Registry implements RegistryMBean, MBeanRegistration  {
         } catch (MalformedObjectNameException e) {
             log.info("Error creating object name " + e );
         }
-    }    
-    
+    }
+
 
     /** Invoke a operation on a list of mbeans. Can be used to implement
      * lifecycle operations.
@@ -340,9 +340,9 @@ public class Registry implements RegistryMBean, MBeanRegistration  {
     // -------------------- ID registry --------------------
 
     /** Return an int ID for faster access. Will be used for notifications
-     * and for other operations we want to optimize. 
+     * and for other operations we want to optimize.
      *
-     * @param domain Namespace 
+     * @param domain Namespace
      * @param name  Type of the notification
      * @return  An unique id for the domain:name combination
      * @since 1.1
@@ -355,13 +355,13 @@ public class Registry implements RegistryMBean, MBeanRegistration  {
         Hashtable<String,Integer> domainTable = idDomains.get(domain);
         if( domainTable == null ) {
             domainTable = new Hashtable<String,Integer>();
-            idDomains.put( domain, domainTable); 
+            idDomains.put( domain, domainTable);
         }
         if( name==null ) {
             name="";
         }
         Integer i = domainTable.get(name);
-        
+
         if( i!= null ) {
             return i.intValue();
         }
@@ -369,13 +369,13 @@ public class Registry implements RegistryMBean, MBeanRegistration  {
         int id[] = ids.get(domain);
         if( id == null ) {
             id=new int[1];
-            ids.put( domain, id); 
+            ids.put( domain, id);
         }
         int code=id[0]++;
         domainTable.put( name, new Integer( code ));
         return code;
     }
-    
+
     // -------------------- Metadata   --------------------
     // methods from 1.0
 
@@ -410,7 +410,7 @@ public class Registry implements RegistryMBean, MBeanRegistration  {
             mb = descriptorsByClass.get(name);
         return mb;
     }
-    
+
     /**
      * Return the set of bean names for all managed beans known to
      * this registry.
@@ -493,11 +493,11 @@ public class Registry implements RegistryMBean, MBeanRegistration  {
     }
 
     /** Find the operation info for a method
-     * 
+     *
      * @param oname
      * @param opName
      * @return the operation info for the specified operation
-     */ 
+     */
     public MBeanOperationInfo getMethodInfo( ObjectName oname, String opName )
     {
         MBeanInfo info=null;
@@ -555,18 +555,18 @@ public class Registry implements RegistryMBean, MBeanRegistration  {
         return (server);
     }
 
-    /** Find or load metadata. 
-     */ 
+    /** Find or load metadata.
+     */
     public ManagedBean findManagedBean(Object bean, Class<?> beanClass,
             String type) throws Exception {
         if( bean!=null && beanClass==null ) {
             beanClass=bean.getClass();
         }
-        
+
         if( type==null ) {
             type=beanClass.getName();
         }
-        
+
         // first look for existing descriptor
         ManagedBean managed = findManagedBean(type);
 
@@ -580,7 +580,7 @@ public class Registry implements RegistryMBean, MBeanRegistration  {
 
             managed=findManagedBean(type);
         }
-        
+
         if( bean instanceof DynamicMBean ) {
             if( log.isDebugEnabled() ) {
                 log.debug( "Dynamic mbean support ");
@@ -612,20 +612,20 @@ public class Registry implements RegistryMBean, MBeanRegistration  {
         }
         return managed;
     }
-    
+
 
     /** EXPERIMENTAL Convert a string to object, based on type. Used by several
      * components. We could provide some pluggability. It is here to keep
-     * things consistent and avoid duplication in other tasks 
-     * 
+     * things consistent and avoid duplication in other tasks
+     *
      * @param type Fully qualified class name of the resulting value
      * @param value String value to be converted
      * @return Converted value
-     */ 
+     */
     public Object convertValue(String type, String value)
     {
         Object objValue=value;
-        
+
         if( type==null || "java.lang.String".equals( type )) {
             // string is default
             objValue=value;
@@ -648,7 +648,7 @@ public class Registry implements RegistryMBean, MBeanRegistration  {
         }
         return objValue;
     }
-    
+
     /** Experimental.
      *
      * @param sourceType
@@ -679,7 +679,7 @@ public class Registry implements RegistryMBean, MBeanRegistration  {
             }
         } else if( source instanceof File ) {
             location=((File)source).getAbsolutePath();
-            inputsource=new FileInputStream((File)source);            
+            inputsource=new FileInputStream((File)source);
             type=param;
             if( sourceType == null ) {
                 sourceType = sourceTypeFromExt(location);
@@ -695,7 +695,7 @@ public class Registry implements RegistryMBean, MBeanRegistration  {
                 sourceType="MbeansDescriptorsIntrospectionSource";
             }
         }
-        
+
         if( sourceType==null ) {
             sourceType="MbeansDescriptorsDigesterSource";
         }
@@ -716,14 +716,14 @@ public class Registry implements RegistryMBean, MBeanRegistration  {
         return null;
     }
 
-    /** Register a component 
-     * XXX make it private 
-     * 
+    /** Register a component
+     * XXX make it private
+     *
      * @param bean
      * @param oname
      * @param type
      * @throws Exception
-     */ 
+     */
     public void registerComponent(Object bean, ObjectName oname, String type)
            throws Exception
     {
@@ -834,7 +834,7 @@ public class Registry implements RegistryMBean, MBeanRegistration  {
         if( classLoader==null ) {
             classLoader=this.getClass().getClassLoader();
         }
-        
+
         String className=type;
         String pkg=className;
         while( pkg.indexOf( ".") > 0 ) {
@@ -864,10 +864,10 @@ public class Registry implements RegistryMBean, MBeanRegistration  {
 
 
     // -------------------- Registration  --------------------
-    
+
     @Override
     public ObjectName preRegister(MBeanServer server,
-                                  ObjectName name) throws Exception 
+                                  ObjectName name) throws Exception
     {
         this.server=server;
         return name;
@@ -887,15 +887,15 @@ public class Registry implements RegistryMBean, MBeanRegistration  {
 
 
     // -------------------- DEPRECATED METHODS  --------------------
-    // May still be used in tomcat 
+    // May still be used in tomcat
     // Never part of an official release
-    
+
     public ManagedBean findManagedBean(Class<?> beanClass, String type)
         throws Exception
     {
-        return findManagedBean(null, beanClass, type);        
+        return findManagedBean(null, beanClass, type);
     }
-    
+
     /**
      * Set the <code>MBeanServer</code> to be utilized for our
      * registered management beans.

==================================================
MbeansDescriptorsDOMSource.java
index 37e74eb365..ae256e79fc 100644
--- a/java/org/apache/tomcat/util/modeler/RegistryMBean.java
+++ b/java/org/apache/tomcat/util/modeler/RegistryMBean.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -25,26 +25,26 @@ import javax.management.ObjectName;
 
 /**
  * Interface for modeler MBeans.
- * 
+ *
  * This is the main entry point into modeler. It provides methods to create
  * and manipulate model mbeans and simplify their use.
  *
  * Starting with version 1.1, this is no longer a singleton and the static
  * methods are strongly deprecated. In a container environment we can expect
  * different applications to use different registries.
- * 
+ *
  * @author Craig R. McClanahan
  * @author Costin Manolache
- * 
+ *
  * @since 1.1
  */
 public interface RegistryMBean {
 
-    /** 
+    /**
      * Load an extended mlet file. The source can be an URL, File or
-     * InputStream. 
-     * 
-     * All mbeans will be instantiated, registered and the attributes will be 
+     * InputStream.
+     *
+     * All mbeans will be instantiated, registered and the attributes will be
      * set. The result is a list of ObjectNames.
      *
      * @param source InputStream or URL of the file
@@ -52,26 +52,26 @@ public interface RegistryMBean {
      *        default JMX mechanism ( i.e. all registered loaders )
      * @return List of ObjectName for the loaded mbeans
      * @throws Exception
-     * 
+     *
      * @since 1.1
-     */ 
+     */
     public List<ObjectName> loadMBeans( Object source, ClassLoader cl )
             throws Exception;
 
-    /** Invoke an operation on a set of mbeans. 
-     * 
+    /** Invoke an operation on a set of mbeans.
+     *
      * @param mbeans List of ObjectNames
      * @param operation Operation to perform. Typically "init" "start" "stop" or "destroy"
      * @param failFirst Behavior in case of exceptions - if false we'll ignore
      *      errors
      * @throws Exception
-     */ 
+     */
     public void invoke( List<ObjectName> mbeans, String operation, boolean failFirst )
             throws Exception;
 
-    /** Register a bean by creating a modeler mbean and adding it to the 
+    /** Register a bean by creating a modeler mbean and adding it to the
      * MBeanServer.
-     * 
+     *
      * If metadata is not loaded, we'll look up and read a file named
      * "mbeans-descriptors.ser" or "mbeans-descriptors.xml" in the same package
      * or parent.
@@ -80,15 +80,15 @@ public interface RegistryMBean {
      * to a model mbean and we'll wrap it - so modeler services will be supported
      *
      * If the metadata is still not found, introspection will be used to extract
-     * it automatically. 
-     * 
+     * it automatically.
+     *
      * If an mbean is already registered under this name, it'll be first
      * unregistered.
-     * 
+     *
      * If the component implements MBeanRegistration, the methods will be called.
      * If the method has a method "setRegistry" that takes a RegistryMBean as
      * parameter, it'll be called with the current registry.
-     * 
+     *
      *
      * @param bean Object to be registered
      * @param oname Name used for registration
@@ -97,24 +97,24 @@ public interface RegistryMBean {
      * by subclasses.
      *
      * @since 1.1
-     */ 
+     */
     public void registerComponent(Object bean, String oname, String type)
            throws Exception;
 
     /** Unregister a component. We'll first check if it is registered,
      * and mask all errors. This is mostly a helper.
-     * 
+     *
      * @param oname
-     * 
+     *
      * @since 1.1
-     */ 
+     */
     public void unregisterComponent( String oname );
 
 
      /** Return an int ID for faster access. Will be used for notifications
-      * and for other operations we want to optimize. 
+      * and for other operations we want to optimize.
       *
-      * @param domain Namespace 
+      * @param domain Namespace
       * @param name  Type of the notification
       * @return  An unique id for the domain:name combination
       * @since 1.1
@@ -122,21 +122,21 @@ public interface RegistryMBean {
     public int getId( String domain, String name);
 
 
-    /** Reset all metadata cached by this registry. Should be called 
+    /** Reset all metadata cached by this registry. Should be called
      * to support reloading. Existing mbeans will not be affected or modified.
-     * 
+     *
      * It will be called automatically if the Registry is unregistered.
      * @since 1.1
-     */ 
+     */
     public void stop();
 
     /** Load descriptors. The source can be a File, URL pointing to an
      * mbeans-descriptors.xml.
-     * 
+     *
      * Also ( experimental for now ) a ClassLoader - in which case META-INF/ will
      * be used.
-     * 
+     *
      * @param source
-     */ 
+     */
     public void loadMetadata(Object source ) throws Exception;
 }

==================================================
MbeansDescriptorsDigesterSource.java
index 69878e765b..ee928011c3 100644
--- a/java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsDOMSource.java
+++ b/java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsDOMSource.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
MbeansDescriptorsIntrospectionSource.java
index dd4d00ee03..0215e0a5a8 100644
--- a/java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsDigesterSource.java
+++ b/java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsDigesterSource.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -43,7 +43,7 @@ public class MbeansDescriptorsDigesterSource extends ModelerSource
     Object source;
     List<ObjectName> mbeans = new ArrayList<ObjectName>();
     protected static volatile Digester digester = null;
-    
+
     protected static Digester createDigester() {
 
         Digester digester = new Digester();
@@ -54,7 +54,7 @@ public class MbeansDescriptorsDigesterSource extends ModelerSource
         digester.register
             ("-//Apache Software Foundation//DTD Model MBeans Configuration File",
                 url.toString());
-        
+
         // Configure the parsing rules
         digester.addObjectCreate
             ("mbeans-descriptors/mbean",
@@ -65,7 +65,7 @@ public class MbeansDescriptorsDigesterSource extends ModelerSource
             ("mbeans-descriptors/mbean",
                 "add",
             "java.lang.Object");
-        
+
         digester.addObjectCreate
             ("mbeans-descriptors/mbean/attribute",
             "org.apache.tomcat.util.modeler.AttributeInfo");
@@ -75,7 +75,7 @@ public class MbeansDescriptorsDigesterSource extends ModelerSource
             ("mbeans-descriptors/mbean/attribute",
                 "addAttribute",
             "org.apache.tomcat.util.modeler.AttributeInfo");
-        
+
         /*digester.addObjectCreate
             ("mbeans-descriptors/mbean/attribute/descriptor/field",
             "org.apache.tomcat.util.modeler.FieldInfo");
@@ -85,7 +85,7 @@ public class MbeansDescriptorsDigesterSource extends ModelerSource
             ("mbeans-descriptors/mbean/attribute/descriptor/field",
                 "addField",
             "org.apache.tomcat.util.modeler.FieldInfo");
-        
+
         digester.addObjectCreate
             ("mbeans-descriptors/mbean/constructor",
             "org.apache.tomcat.util.modeler.ConstructorInfo");
@@ -95,7 +95,7 @@ public class MbeansDescriptorsDigesterSource extends ModelerSource
             ("mbeans-descriptors/mbean/constructor",
                 "addConstructor",
             "org.apache.tomcat.util.modeler.ConstructorInfo");
-        
+
         digester.addObjectCreate
             ("mbeans-descriptors/mbean/constructor/descriptor/field",
             "org.apache.tomcat.util.modeler.FieldInfo");
@@ -105,7 +105,7 @@ public class MbeansDescriptorsDigesterSource extends ModelerSource
             ("mbeans-descriptors/mbean/constructor/descriptor/field",
                 "addField",
             "org.apache.tomcat.util.modeler.FieldInfo");
-        
+
         digester.addObjectCreate
             ("mbeans-descriptors/mbean/constructor/parameter",
             "org.apache.tomcat.util.modeler.ParameterInfo");
@@ -115,7 +115,7 @@ public class MbeansDescriptorsDigesterSource extends ModelerSource
             ("mbeans-descriptors/mbean/constructor/parameter",
                 "addParameter",
             "org.apache.tomcat.util.modeler.ParameterInfo");
-        
+
         digester.addObjectCreate
             ("mbeans-descriptors/mbean/descriptor/field",
             "org.apache.tomcat.util.modeler.FieldInfo");
@@ -135,7 +135,7 @@ public class MbeansDescriptorsDigesterSource extends ModelerSource
             ("mbeans-descriptors/mbean/notification",
                 "addNotification",
             "org.apache.tomcat.util.modeler.NotificationInfo");
-        
+
         digester.addObjectCreate
             ("mbeans-descriptors/mbean/notification/descriptor/field",
             "org.apache.tomcat.util.modeler.FieldInfo");
@@ -145,11 +145,11 @@ public class MbeansDescriptorsDigesterSource extends ModelerSource
             ("mbeans-descriptors/mbean/notification/descriptor/field",
                 "addField",
             "org.apache.tomcat.util.modeler.FieldInfo");
-        
+
         digester.addCallMethod
             ("mbeans-descriptors/mbean/notification/notification-type",
                 "addNotifType", 0);
-        
+
         digester.addObjectCreate
             ("mbeans-descriptors/mbean/operation",
             "org.apache.tomcat.util.modeler.OperationInfo");
@@ -159,7 +159,7 @@ public class MbeansDescriptorsDigesterSource extends ModelerSource
             ("mbeans-descriptors/mbean/operation",
                 "addOperation",
             "org.apache.tomcat.util.modeler.OperationInfo");
-        
+
         digester.addObjectCreate
             ("mbeans-descriptors/mbean/operation/descriptor/field",
             "org.apache.tomcat.util.modeler.FieldInfo");
@@ -169,7 +169,7 @@ public class MbeansDescriptorsDigesterSource extends ModelerSource
             ("mbeans-descriptors/mbean/operation/descriptor/field",
                 "addField",
             "org.apache.tomcat.util.modeler.FieldInfo");
-        
+
         digester.addObjectCreate
             ("mbeans-descriptors/mbean/operation/parameter",
             "org.apache.tomcat.util.modeler.ParameterInfo");
@@ -179,11 +179,11 @@ public class MbeansDescriptorsDigesterSource extends ModelerSource
             ("mbeans-descriptors/mbean/operation/parameter",
                 "addParameter",
             "org.apache.tomcat.util.modeler.ParameterInfo");
-        
+
         return digester;
-        
+
     }
-    
+
     public void setRegistry(Registry reg) {
         this.registry=reg;
     }
@@ -226,9 +226,9 @@ public class MbeansDescriptorsDigesterSource extends ModelerSource
             digester = createDigester();
         }
         ArrayList<ManagedBean> loadedMbeans = new ArrayList<ManagedBean>();
-        
+
         synchronized (digester) {
-            
+
             // Process the input file to configure our registry
             try {
                 // Push our registry object onto the stack
@@ -240,7 +240,7 @@ public class MbeansDescriptorsDigesterSource extends ModelerSource
             } finally {
                 digester.reset();
             }
-        
+
         }
         Iterator<ManagedBean> iter = loadedMbeans.iterator();
         while (iter.hasNext()) {

==================================================
MbeansSource.java
index aba5607f37..e9cfd8fc4c 100644
--- a/java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsIntrospectionSource.java
+++ b/java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsIntrospectionSource.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -120,7 +120,7 @@ public class MbeansDescriptorsIntrospectionSource extends ModelerSource
         Integer.TYPE,
         Long.class,
         Long.TYPE,
-        Float.class, 
+        Float.class,
         Float.TYPE,
         Double.class,
         Double.TYPE,
@@ -132,14 +132,14 @@ public class MbeansDescriptorsIntrospectionSource extends ModelerSource
         objNameArray.getClass(),
         java.io.File.class,
     };
-    
+
     /**
      * Check if this class is one of the supported types.
      * If the class is supported, returns true.  Otherwise,
      * returns false.
      * @param ret The class to check
      * @return boolean True if class is supported
-     */ 
+     */
     private boolean supportedType(Class<?> ret) {
         for (int i = 0; i < supportedTypes.length; i++) {
             if (ret == supportedTypes[i]) {
@@ -167,7 +167,7 @@ public class MbeansDescriptorsIntrospectionSource extends ModelerSource
 
         // Anything in the java or javax package that
         // does not have a defined mapping is excluded.
-        if (javaType.getName().startsWith("java.") || 
+        if (javaType.getName().startsWith("java.") ||
             javaType.getName().startsWith("javax.")) {
             return false;
         }
@@ -180,9 +180,9 @@ public class MbeansDescriptorsIntrospectionSource extends ModelerSource
 
         // Make sure superclass is compatible
         Class<?> superClass = javaType.getSuperclass();
-        if (superClass != null && 
-            superClass != java.lang.Object.class && 
-            superClass != java.lang.Exception.class && 
+        if (superClass != null &&
+            superClass != java.lang.Object.class &&
+            superClass != java.lang.Exception.class &&
             superClass != java.lang.Throwable.class) {
             if (!isBeanCompatible(superClass)) {
                 return false;
@@ -190,8 +190,8 @@ public class MbeansDescriptorsIntrospectionSource extends ModelerSource
         }
         return true;
     }
-    
-    /** 
+
+    /**
      * Process the methods and extract 'attributes', methods, etc
      *
      * @param realClass The class to process
@@ -386,7 +386,7 @@ public class MbeansDescriptorsIntrospectionSource extends ModelerSource
                 mbean.addConstructor(info);
             }
             */
-            
+
             if( log.isDebugEnabled())
                 log.debug("Setting name: " + type );
             mbean.setName( type );

==================================================
MbeansSourceMBean.java
index a9e4a0aea5..a626101054 100644
--- a/java/org/apache/tomcat/util/modeler/modules/MbeansSource.java
+++ b/java/org/apache/tomcat/util/modeler/modules/MbeansSource.java
@@ -44,10 +44,10 @@ import org.w3c.dom.Node;
 /** This will create mbeans based on a config file.
  *  The format is an extended version of MLET.
  *
- * Classloading. We don't support any explicit classloader tag. 
+ * Classloading. We don't support any explicit classloader tag.
  * A ClassLoader is just an mbean ( it can be the standard MLetMBean or
- * a custom one ). 
- * 
+ * a custom one ).
+ *
  * XXX add a special attribute to reference the loader mbean,
  * XXX figure out how to deal with private loaders
  */
@@ -70,7 +70,7 @@ public class MbeansSource extends ModelerSource implements MbeansSourceMBean
 
     public void setRegistry(Registry reg) {
         this.registry=reg;
-    }          
+    }
 
     public void setLocation( String loc ) {
         this.location=loc;
@@ -97,7 +97,7 @@ public class MbeansSource extends ModelerSource implements MbeansSourceMBean
     public String getLocation() {
         return location;
     }
-    
+
     /** Return the list of mbeans created by this source.
      *  It can be used to implement runtime services.
      */
@@ -116,27 +116,27 @@ public class MbeansSource extends ModelerSource implements MbeansSourceMBean
         execute();
         return mbeans;
     }
-    
+
     public void start() throws Exception {
-        registry.invoke(mbeans, "start", false);        
+        registry.invoke(mbeans, "start", false);
     }
 
     public void stop() throws Exception {
-        registry.invoke(mbeans, "stop", false);        
+        registry.invoke(mbeans, "stop", false);
     }
-    
+
     @Override
     public void init() throws Exception {
         if( mbeans==null) execute();
         if( registry==null ) registry=Registry.getRegistry(null, null);
-        
+
         registry.invoke(mbeans, "init", false);
     }
-    
+
     public void destroy() throws Exception {
-        registry.invoke(mbeans, "destroy", false);                
+        registry.invoke(mbeans, "destroy", false);
     }
-    
+
     @Override
     public void load() throws Exception {
         execute(); // backward compat
@@ -178,7 +178,7 @@ public class MbeansSource extends ModelerSource implements MbeansSourceMBean
                 server.registerMBean(mlet, defaultLoader);
                 loaderLoaded=true;
             }
-        
+
             // Process nodes
             for (Node mbeanN = firstMbeanN; mbeanN != null;
                  mbeanN= DomUtil.getNext(mbeanN, null, Node.ELEMENT_NODE))
@@ -193,7 +193,7 @@ public class MbeansSource extends ModelerSource implements MbeansSourceMBean
                     if( objectName==null ) {
                         objectName=DomUtil.getAttribute( mbeanN, "name" );
                     }
-                    
+
                     if( log.isDebugEnabled())
                         log.debug( "Processing mbean objectName=" + objectName +
                                 " code=" + code);
@@ -209,11 +209,11 @@ public class MbeansSource extends ModelerSource implements MbeansSourceMBean
                         if( ! server.isRegistered( oname )) {
                             // We wrap everything in a model mbean.
                             // XXX need to support "StandardMBeanDescriptorsSource"
-                            String modelMBean=BaseModelMBean.class.getName();                            
+                            String modelMBean=BaseModelMBean.class.getName();
                             server.createMBean(modelMBean, oname,
                                     new Object[] { code, this},
                                     new String[] { String.class.getName(),
-                                                  ModelerSource.class.getName() } 
+                                                  ModelerSource.class.getName() }
                                     );
                             mbeans.add(oname);
                         }
@@ -272,9 +272,9 @@ public class MbeansSource extends ModelerSource implements MbeansSourceMBean
             log.error( "Error reading mbeans ", ex);
         }
     }
-    
+
     @Override
-    public void updateField( ObjectName oname, String name, 
+    public void updateField( ObjectName oname, String name,
                              Object value )
     {
         if( loading ) return;
@@ -291,7 +291,7 @@ public class MbeansSource extends ModelerSource implements MbeansSourceMBean
             attNode=n.getOwnerDocument().createElement("attribute");
             DomUtil.setAttribute(attNode, "name", name);
             n.appendChild(attNode);
-        } 
+        }
         String oldValue=DomUtil.getAttribute(attNode, "value");
         if( oldValue != null ) {
             // we'll convert all values to text content
@@ -301,14 +301,14 @@ public class MbeansSource extends ModelerSource implements MbeansSourceMBean
 
         //store();
     }
-    
-    /** Store the mbeans. 
-     * XXX add a background thread to store it periodically 
-     */ 
+
+    /** Store the mbeans.
+     * XXX add a background thread to store it periodically
+     */
     @Override
     public void save() {
         // XXX customize no often than ( based on standard descriptor ), etc.
-        // It doesn't work very well if we call this on each set att - 
+        // It doesn't work very well if we call this on each set att -
         // the triger will work for the first att, but all others will be delayed
         long time=System.currentTimeMillis();
         if( location!=null &&

==================================================
ModelerSource.java
index 5f4fd81f54..5fe18f959c 100644
--- a/java/org/apache/tomcat/util/modeler/modules/MbeansSourceMBean.java
+++ b/java/org/apache/tomcat/util/modeler/modules/MbeansSourceMBean.java
@@ -24,37 +24,37 @@ import javax.management.ObjectName;
 /**
  * This mbean will load an extended mlet file ( similar in syntax with jboss ).
  * It'll keep track of all attribute changes and update the file when attributes
- * change. 
+ * change.
  */
-public interface MbeansSourceMBean 
+public interface MbeansSourceMBean
 {
     /** Set the source to be used to load the mbeans
-     * 
+     *
      * @param source File or URL
-     */ 
+     */
     public void setSource( Object source );
-    
+
     public Object getSource();
-    
+
     /** Return the list of loaded mbeans names
-     * 
+     *
      * @return List of ObjectName
-     */ 
+     */
     public List<ObjectName> getMBeans();
 
-    /** Load the mbeans from the source. Called automatically on init() 
-     * 
+    /** Load the mbeans from the source. Called automatically on init()
+     *
      * @throws Exception
-     */ 
+     */
     public void load() throws Exception;
-    
+
     /** Call the init method on all mbeans. Will call load if not done already
-     * 
+     *
      * @throws Exception
-     */ 
+     */
     public void init() throws Exception;
 
     /** Save the file.
-     */ 
+     */
     public void save();
 }

==================================================
AbstractEndpoint.java
index d2acf346b3..eca1acfdf2 100644
--- a/java/org/apache/tomcat/util/modeler/package.html
+++ b/java/org/apache/tomcat/util/modeler/package.html
@@ -217,7 +217,7 @@ and sufficient.</p>
 
 <p>Modeler will also look for a mbeans-descriptors.xml in the same package
 with the class beeing registered and in its parent. If no metadata is found,
-modeler will use a number of simple patterns, similar with the ones used by 
+modeler will use a number of simple patterns, similar with the ones used by
 ant, to determine a reasonable metadata</p>
 
 <p>In a future version we should also support xdoclet-based generation of the

==================================================
AprEndpoint.java
index 27ef98be12..0038589ba3 100644
--- a/java/org/apache/tomcat/util/net/AbstractEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AbstractEndpoint.java
@@ -56,14 +56,14 @@ public abstract class AbstractEndpoint {
             //      ASYNC_END (if possible)
             OPEN, CLOSED, LONG, ASYNC_END, SENDFILE
         }
-        
+
 
         /**
          * Obtain the GlobalRequestProcessor associated with the handler.
          */
         public Object getGlobal();
-        
-        
+
+
         /**
          * Recycle resources associated with the handler.
          */
@@ -162,7 +162,7 @@ public abstract class AbstractEndpoint {
      * Controls when the Endpoint binds the port. <code>true</code>, the default
      * binds the port on {@link #init()} and unbinds it on {@link #destroy()}.
      * If set to <code>false</code> the port is bound on {@link #start()} and
-     * unbound on {@link #stop()}.  
+     * unbound on {@link #stop()}.
      */
     private boolean bindOnInit = true;
     public boolean getBindOnInit() { return bindOnInit; }
@@ -306,7 +306,7 @@ public abstract class AbstractEndpoint {
      */
     protected HashMap<String, Object> attributes =
         new HashMap<String, Object>();
-    /** 
+    /**
      * Generic property setter called when a property for which a specific
      * setter already exists within the
      * {@link org.apache.coyote.ProtocolHandler} needs to be made available to
@@ -351,7 +351,7 @@ public abstract class AbstractEndpoint {
     public String getProperty(String name) {
         return (String) getAttribute(name);
     }
-    
+
     /**
      * Return the amount of threads that are managed by the pool.
      *
@@ -499,7 +499,7 @@ public abstract class AbstractEndpoint {
             bindState = BindState.BOUND_ON_INIT;
         }
     }
-    
+
     public final void start() throws Exception {
         if (bindState == BindState.UNBOUND) {
             bind();
@@ -571,25 +571,25 @@ public abstract class AbstractEndpoint {
     public abstract boolean getUseComet();
     public abstract boolean getUseCometTimeout();
     public abstract boolean getUsePolling();
-    
+
     protected LimitLatch initializeConnectionLatch() {
         if (connectionLimitLatch==null) {
             connectionLimitLatch = new LimitLatch(getMaxConnections());
         }
         return connectionLimitLatch;
     }
-    
+
     protected void releaseConnectionLatch() {
         LimitLatch latch = connectionLimitLatch;
         if (latch!=null) latch.releaseAll();
         connectionLimitLatch = null;
     }
-    
+
     protected void countUpOrAwaitConnection() throws InterruptedException {
         LimitLatch latch = connectionLimitLatch;
         if (latch!=null) latch.countUpOrAwait();
     }
-    
+
     protected long countDownConnection() {
         LimitLatch latch = connectionLimitLatch;
         if (latch!=null) {
@@ -600,14 +600,14 @@ public abstract class AbstractEndpoint {
             return result;
         } else return -1;
     }
-    
+
     /**
      * Provides a common approach for sub-classes to handle exceptions where a
      * delay is required to prevent a Thread from entering a tight loop which
      * will consume CPU and may also trigger large amounts of logging. For
      * example, this can happen with the Acceptor thread if the ulimit for open
      * files is reached.
-     * 
+     *
      * @param currentErrorDelay The current delay beign applied on failure
      * @return  The delay to apply on the next failure
      */
@@ -620,7 +620,7 @@ public abstract class AbstractEndpoint {
                 // Ignore
             }
         }
-        
+
         // On subsequent exceptions, start the delay at 50ms, doubling the delay
         // on every subsequent exception until the delay reaches 1.6 seconds.
         if (currentErrorDelay == 0) {

==================================================
DefaultServerSocketFactory.java
index c0b279dce4..bcf500463f 100644
--- a/java/org/apache/tomcat/util/net/AprEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AprEndpoint.java
@@ -581,7 +581,7 @@ public class AprEndpoint extends AbstractEndpoint {
             if (getExecutor() == null) {
                 createExecutor();
             }
-            
+
             initializeConnectionLatch();
 
             // Start poller threads
@@ -988,7 +988,7 @@ public class AprEndpoint extends AbstractEndpoint {
                 try {
                     //if we have reached max connections, wait
                     countUpOrAwaitConnection();
-                    
+
                     long socket = 0;
                     try {
                         // Accept the next incoming connection from the server
@@ -1107,7 +1107,7 @@ public class AprEndpoint extends AbstractEndpoint {
 
         private long[] addSocket;
         private boolean[] addSocketKeepAlive;
-        
+
         private volatile int addCount = 0;
 
         private boolean comet = true;

==================================================
JIoEndpoint.java
index 5d995daf43..06856bd86b 100644
--- a/java/org/apache/tomcat/util/net/DefaultServerSocketFactory.java
+++ b/java/org/apache/tomcat/util/net/DefaultServerSocketFactory.java
@@ -32,7 +32,7 @@ import java.net.Socket;
 public class DefaultServerSocketFactory implements ServerSocketFactory {
 
     /**
-     * 
+     *
      * @param endpoint  Unused in this implementation.
      */
     public DefaultServerSocketFactory(AbstractEndpoint endpoint) {

==================================================
NioBlockingSelector.java
index fc3bbefd2b..4ec9ee4fbb 100644
--- a/java/org/apache/tomcat/util/net/JIoEndpoint.java
+++ b/java/org/apache/tomcat/util/net/JIoEndpoint.java
@@ -63,7 +63,7 @@ public class JIoEndpoint extends AbstractEndpoint {
      * Associated server socket.
      */
     protected ServerSocket serverSocket = null;
-    
+
 
     // ------------------------------------------------------------ Constructor
 
@@ -81,7 +81,7 @@ public class JIoEndpoint extends AbstractEndpoint {
     protected int acceptorThreadCount = 0;
     public void setAcceptorThreadCount(int acceptorThreadCount) { this.acceptorThreadCount = acceptorThreadCount; }
     public int getAcceptorThreadCount() { return acceptorThreadCount; }
-    
+
     /**
      * Handling of accepted sockets.
      */
@@ -122,7 +122,7 @@ public class JIoEndpoint extends AbstractEndpoint {
     public interface Handler extends AbstractEndpoint.Handler {
         public SocketState process(SocketWrapper<Socket> socket,
                 SocketStatus status);
-        public SSLImplementation getSslImplementation(); 
+        public SSLImplementation getSslImplementation();
     }
 
 
@@ -155,7 +155,7 @@ public class JIoEndpoint extends AbstractEndpoint {
                         processSocketAsync(socket,SocketStatus.TIMEOUT);
                     }
                 }
-                
+
                 // Loop if endpoint is paused
                 while (paused && running) {
                     try {
@@ -164,12 +164,12 @@ public class JIoEndpoint extends AbstractEndpoint {
                         // Ignore
                     }
                 }
-                
+
             }
         }
     }
 
-    
+
     // --------------------------------------------------- Acceptor Inner Class
     /**
      * Server socket acceptor thread.
@@ -204,7 +204,7 @@ public class JIoEndpoint extends AbstractEndpoint {
                 try {
                     //if we have reached max connections, wait
                     countUpOrAwaitConnection();
-                    
+
                     Socket socket = null;
                     try {
                         // Accept the next incoming connection from the server
@@ -264,10 +264,10 @@ public class JIoEndpoint extends AbstractEndpoint {
      * external Executor thread pool.
      */
     protected class SocketProcessor implements Runnable {
-        
+
         protected SocketWrapper<Socket> socket = null;
         protected SocketStatus status = null;
-        
+
         public SocketProcessor(SocketWrapper<Socket> socket) {
             if (socket==null) throw new NullPointerException();
             this.socket = socket;
@@ -296,7 +296,7 @@ public class JIoEndpoint extends AbstractEndpoint {
                         // Tell to close the socket
                         state = SocketState.CLOSED;
                     }
-                        
+
                     if ((state != SocketState.CLOSED)) {
                         if (status == null) {
                             state = handler.process(socket, SocketStatus.OPEN);
@@ -339,7 +339,7 @@ public class JIoEndpoint extends AbstractEndpoint {
             socket = null;
             // Finish up this request
         }
-        
+
     }
 
 
@@ -388,9 +388,9 @@ public class JIoEndpoint extends AbstractEndpoint {
                 throw be;
             }
         }
-        
+
     }
-    
+
     @Override
     public void startInternal() throws Exception {
 
@@ -402,7 +402,7 @@ public class JIoEndpoint extends AbstractEndpoint {
             if (getExecutor() == null) {
                 createExecutor();
             }
-            
+
             initializeConnectionLatch();
 
             // Start acceptor threads
@@ -413,7 +413,7 @@ public class JIoEndpoint extends AbstractEndpoint {
                 acceptorThread.setDaemon(getDaemon());
                 acceptorThread.start();
             }
-            
+
             // Start async timeout thread
             Thread timeoutThread = new Thread(new AsyncTimeout(),
                     getName() + "-AsyncTimeout");
@@ -480,14 +480,14 @@ public class JIoEndpoint extends AbstractEndpoint {
         return true;
     }
 
-    
+
     /**
      * Process a new connection from a new client. Wraps the socket so
      * keep-alive and other attributes can be tracked and then passes the socket
      * to the executor for processing.
-     * 
+     *
      * @param socket    The socket associated with the client.
-     * 
+     *
      * @return          <code>true</code> if the socket is passed to the
      *                  executor, <code>false</code> if something went wrong or
      *                  if the endpoint is shutting down. Returning
@@ -516,12 +516,12 @@ public class JIoEndpoint extends AbstractEndpoint {
         }
         return true;
     }
-    
-    
+
+
     /**
      * Process an existing async connection. If processing is required, passes
      * the wrapped socket to an executor for processing.
-     * 
+     *
      * @param socket    The socket associated with the client.
      * @param status    Only OPEN and TIMEOUT are used. The others are used for
      *                  Comet requests that are not supported by the BIO (JIO)
@@ -595,5 +595,5 @@ public class JIoEndpoint extends AbstractEndpoint {
             return null;
         }
     }
-    
+
 }

==================================================
NioChannel.java
index 21a856823d..eb2268aacb 100644
--- a/java/org/apache/tomcat/util/net/NioBlockingSelector.java
+++ b/java/org/apache/tomcat/util/net/NioBlockingSelector.java
@@ -38,18 +38,18 @@ import org.apache.tomcat.util.MutableInteger;
 import org.apache.tomcat.util.net.NioEndpoint.KeyAttachment;
 
 public class NioBlockingSelector {
-    
+
     private static final Log log = LogFactory.getLog(NioBlockingSelector.class);
-    
+
     private static int threadCounter = 0;
-    
+
     protected Selector sharedSelector;
-    
+
     protected BlockPoller poller;
     public NioBlockingSelector() {
-        
+
     }
-    
+
     public void open(Selector selector) {
         sharedSelector = selector;
         poller = new BlockPoller();
@@ -58,7 +58,7 @@ public class NioBlockingSelector {
         poller.setName("NioBlockingSelector.BlockPoller-"+(++threadCounter));
         poller.start();
     }
-    
+
     public void close() {
         if (poller!=null) {
             poller.disable();
@@ -120,7 +120,7 @@ public class NioBlockingSelector {
                 if (writeTimeout > 0 && (keycount == 0))
                     timedout = (System.currentTimeMillis() - time) >= writeTimeout;
             } //while
-            if (timedout) 
+            if (timedout)
                 throw new SocketTimeoutException();
         } finally {
             poller.remove(att,SelectionKey.OP_WRITE);
@@ -197,7 +197,7 @@ public class NioBlockingSelector {
         return read;
     }
 
-    
+
     protected static class BlockPoller extends Thread {
         protected volatile boolean run = true;
         protected Selector selector = null;
@@ -227,7 +227,7 @@ public class NioBlockingSelector {
                 if (SelectionKey.OP_READ==(ops&SelectionKey.OP_READ))countDown(key.getReadLatch());
             }
         }
-        
+
         public void add(final KeyAttachment key, final int ops, final KeyReference ref) {
             Runnable r = new Runnable() {
                 @Override
@@ -257,7 +257,7 @@ public class NioBlockingSelector {
             events.offer(r);
             wakeup();
         }
-        
+
         public void remove(final KeyAttachment key, final int ops) {
             Runnable r = new Runnable() {
                 @Override
@@ -318,7 +318,7 @@ public class NioBlockingSelector {
                     int keyCount = 0;
                     try {
                         int i = wakeupCounter.get();
-                        if (i>0) 
+                        if (i>0)
                             keyCount = selector.selectNow();
                         else {
                             wakeupCounter.set(-1);
@@ -380,16 +380,16 @@ public class NioBlockingSelector {
                 if (log.isDebugEnabled())log.debug("",ignore);
             }
         }
-        
+
         public void countDown(CountDownLatch latch) {
             if ( latch == null ) return;
             latch.countDown();
         }
     }
-    
+
     public static class KeyReference {
         SelectionKey key = null;
-        
+
         @Override
         public void finalize() {
             if (key!=null && key.isValid()) {

==================================================
NioEndpoint.java
index acdc9d9067..493f29f2f0 100644
--- a/java/org/apache/tomcat/util/net/NioChannel.java
+++ b/java/org/apache/tomcat/util/net/NioChannel.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -30,11 +30,11 @@ import org.apache.tomcat.util.net.NioEndpoint.Poller;
 import org.apache.tomcat.util.net.SecureNioChannel.ApplicationBufferHandler;
 
 /**
- * 
+ *
  * Base class for a SocketChannel wrapper used by the endpoint.
  * This way, logic for a SSL socket channel remains the same as for
  * a non SSL, making sure we don't need to code for any exception cases.
- * 
+ *
  * @author Filip Hanik
  * @version 1.0
  */
@@ -47,7 +47,7 @@ public class NioChannel implements ByteChannel{
     protected ApplicationBufferHandler bufHandler;
 
     protected Poller poller;
-    
+
     protected boolean sendFile = false;
 
     public NioChannel(SocketChannel channel, ApplicationBufferHandler bufHandler) throws IOException {
@@ -60,7 +60,7 @@ public class NioChannel implements ByteChannel{
         bufHandler.getWriteBuffer().clear();
         this.sendFile = false;
     }
-    
+
     public int getBufferSize() {
         if ( bufHandler == null ) return 0;
         int size = 0;
@@ -70,7 +70,7 @@ public class NioChannel implements ByteChannel{
     }
 
     /**
-     * returns true if the network buffer has 
+     * returns true if the network buffer has
      * been flushed out and is empty
      * @return boolean
      */
@@ -198,11 +198,11 @@ public class NioChannel implements ByteChannel{
     public String toString() {
         return super.toString()+":"+this.sc.toString();
     }
-    
+
     public int getOutboundRemaining() {
         return 0;
     }
-    
+
     /**
      * Return true if the buffer wrote data
      * @throws IOException
@@ -210,14 +210,14 @@ public class NioChannel implements ByteChannel{
     public boolean flushOutbound() throws IOException {
         return false;
     }
-    
+
     public boolean isSendFile() {
         return sendFile;
     }
-    
+
     public void setSendFile(boolean s) {
         this.sendFile = s;
     }
-    
+
 
 }

==================================================
NioSelectorPool.java
index 6138ba6d6b..91fcd677ff 100644
--- a/java/org/apache/tomcat/util/net/NioEndpoint.java
+++ b/java/org/apache/tomcat/util/net/NioEndpoint.java
@@ -80,48 +80,48 @@ public class NioEndpoint extends AbstractEndpoint {
 
     public static final int OP_REGISTER = 0x100; //register interest op
     public static final int OP_CALLBACK = 0x200; //callback interest op
-    
+
     // ----------------------------------------------------------------- Fields
 
     protected NioSelectorPool selectorPool = new NioSelectorPool();
-    
+
     /**
      * Server socket "pointer".
      */
     protected ServerSocketChannel serverSock = null;
-    
+
     /**
      * use send file
      */
     protected boolean useSendfile = true;
-    
+
     /**
      * The size of the OOM parachute.
      */
     protected int oomParachute = 1024*1024;
     /**
-     * The oom parachute, when an OOM error happens, 
-     * will release the data, giving the JVM instantly 
+     * The oom parachute, when an OOM error happens,
+     * will release the data, giving the JVM instantly
      * a chunk of data to be able to recover with.
      */
     protected byte[] oomParachuteData = null;
-    
+
     /**
      * Make sure this string has already been allocated
      */
-    protected static final String oomParachuteMsg = 
+    protected static final String oomParachuteMsg =
         "SEVERE:Memory usage is low, parachute is non existent, your system may start failing.";
-    
+
     /**
      * Keep track of OOM warning messages.
      */
     long lastParachuteCheck = System.currentTimeMillis();
-    
+
     /**
-     * 
+     *
      */
     protected volatile CountDownLatch stopLatch = null;
-    
+
     /**
      * Cache for SocketProcessor objects
      */
@@ -142,7 +142,7 @@ public class NioEndpoint extends AbstractEndpoint {
             }
             else return false;
         }
-        
+
         @Override
         public SocketProcessor poll() {
             SocketProcessor result = super.poll();
@@ -151,7 +151,7 @@ public class NioEndpoint extends AbstractEndpoint {
             }
             return result;
         }
-        
+
         @Override
         public void clear() {
             super.clear();
@@ -197,7 +197,7 @@ public class NioEndpoint extends AbstractEndpoint {
         }
     };
 
-    
+
     /**
      * Cache for poller events
      */
@@ -258,7 +258,7 @@ public class NioEndpoint extends AbstractEndpoint {
             }
             else return false;
         }
-        
+
         @Override
         public NioChannel poll() {
             NioChannel result = super.poll();
@@ -268,7 +268,7 @@ public class NioEndpoint extends AbstractEndpoint {
             }
             return result;
         }
-        
+
         @Override
         public void clear() {
             super.clear();
@@ -290,7 +290,7 @@ public class NioEndpoint extends AbstractEndpoint {
         try {
             if (name.startsWith(selectorPoolName)) {
                 return IntrospectionUtils.setProperty(selectorPool, name.substring(selectorPoolName.length()), value);
-            } else { 
+            } else {
                 return super.setProperty(name, value);
             }
         }catch ( Exception x ) {
@@ -401,7 +401,7 @@ public class NioEndpoint extends AbstractEndpoint {
     protected SSLContext sslContext = null;
     public SSLContext getSSLContext() { return sslContext;}
     public void setSSLContext(SSLContext c) { sslContext = c;}
-    
+
     // --------------------------------------------------------- OOM Parachute Methods
 
     protected void checkParachute() {
@@ -416,22 +416,22 @@ public class NioEndpoint extends AbstractEndpoint {
             lastParachuteCheck = System.currentTimeMillis();
         }
     }
-    
+
     protected boolean reclaimParachute(boolean force) {
         if ( oomParachuteData != null ) return true;
-        if ( oomParachute > 0 && ( force || (Runtime.getRuntime().freeMemory() > (oomParachute*2))) )  
+        if ( oomParachute > 0 && ( force || (Runtime.getRuntime().freeMemory() > (oomParachute*2))) )
             oomParachuteData = new byte[oomParachute];
         return oomParachuteData != null;
     }
-    
+
     protected void releaseCaches() {
         this.keyCache.clear();
         this.nioChannels.clear();
         this.processorCache.clear();
         if ( handler != null ) handler.recycle();
-        
+
     }
-    
+
     // --------------------------------------------------------- Public Methods
     /**
      * Number of keepalive sockets.
@@ -461,7 +461,7 @@ public class NioEndpoint extends AbstractEndpoint {
         serverSock = ServerSocketChannel.open();
         socketProperties.setProperties(serverSock.socket());
         InetSocketAddress addr = (getAddress()!=null?new InetSocketAddress(getAddress(),getPort()):new InetSocketAddress(getPort()));
-        serverSock.socket().bind(addr,getBacklog()); 
+        serverSock.socket().bind(addr,getBacklog());
         serverSock.configureBlocking(true); //mimic APR behavior
         serverSock.socket().setSoTimeout(getSocketProperties().getSoTimeout());
 
@@ -490,11 +490,11 @@ public class NioEndpoint extends AbstractEndpoint {
                 sslUtil.configureSessionContext(sessionContext);
             }
         }
-        
+
         if (oomParachute>0) reclaimParachute(true);
         selectorPool.open();
     }
-    
+
     public KeyManager[] wrap(KeyManager[] managers) {
         if (managers==null) return null;
         KeyManager[] result = new KeyManager[managers.length];
@@ -518,14 +518,14 @@ public class NioEndpoint extends AbstractEndpoint {
         if (!running) {
             running = true;
             paused = false;
-             
+
             // Create worker collection
             if ( getExecutor() == null ) {
                 createExecutor();
             }
 
             initializeConnectionLatch();
-            
+
             // Start poller threads
             pollers = new Poller[getPollerThreadCount()];
             for (int i=0; i<pollers.length; i++) {
@@ -571,7 +571,7 @@ public class NioEndpoint extends AbstractEndpoint {
         nioChannels.clear();
         processorCache.clear();
         shutdownExecutor();
-        
+
     }
 
 
@@ -657,7 +657,7 @@ public class NioEndpoint extends AbstractEndpoint {
 
                     channel = new NioChannel(socket, bufhandler);
                 }
-            } else {                
+            } else {
                 channel.setIOChannel(socket);
                 if ( channel instanceof SecureNioChannel ) {
                     SSLEngine engine = createSSLEngine();
@@ -693,7 +693,7 @@ public class NioEndpoint extends AbstractEndpoint {
         engine.setUseClientMode(false);
         if ( getCiphersArray().length > 0 ) engine.setEnabledCipherSuites(getCiphersArray());
         if ( getSslEnabledProtocolsArray().length > 0 ) engine.setEnabledProtocols(getSslEnabledProtocolsArray());
-        
+
         return engine;
     }
 
@@ -751,7 +751,7 @@ public class NioEndpoint extends AbstractEndpoint {
 
             // Loop until we receive a shutdown command
             while (running) {
-                
+
                 // Loop if endpoint is paused
                 while (paused && running) {
                     try {
@@ -767,7 +767,7 @@ public class NioEndpoint extends AbstractEndpoint {
                 try {
                     //if we have reached max connections, wait
                     countUpOrAwaitConnection();
-                    
+
                     SocketChannel socket = null;
                     try {
                         // Accept the next incoming connection from the server
@@ -833,28 +833,28 @@ public class NioEndpoint extends AbstractEndpoint {
     // ----------------------------------------------------- Poller Inner Classes
 
     /**
-     * 
+     *
      * PollerEvent, cacheable object for poller events to avoid GC
      */
     public static class PollerEvent implements Runnable {
-        
+
         protected NioChannel socket;
         protected int interestOps;
         protected KeyAttachment key;
         public PollerEvent(NioChannel ch, KeyAttachment k, int intOps) {
             reset(ch, k, intOps);
         }
-    
+
         public void reset(NioChannel ch, KeyAttachment k, int intOps) {
             socket = ch;
             interestOps = intOps;
             key = k;
         }
-    
+
         public void reset() {
             reset(null, null, 0);
         }
-    
+
         @Override
         public void run() {
             if ( interestOps == OP_REGISTER ) {
@@ -896,13 +896,13 @@ public class NioEndpoint extends AbstractEndpoint {
                 }
             }//end if
         }//run
-        
+
         @Override
         public String toString() {
             return super.toString()+"[intOps="+this.interestOps+"]";
         }
     }
-    
+
     /**
      * Poller class.
      */
@@ -910,20 +910,20 @@ public class NioEndpoint extends AbstractEndpoint {
 
         protected Selector selector;
         protected ConcurrentLinkedQueue<Runnable> events = new ConcurrentLinkedQueue<Runnable>();
-        
+
         protected volatile boolean close = false;
         protected long nextExpiration = 0;//optimize expiration handling
-        
+
         protected AtomicLong wakeupCounter = new AtomicLong(0l);
-        
+
         protected volatile int keyCount = 0;
 
         public Poller() throws IOException {
             this.selector = Selector.open();
         }
-        
+
         public int getKeyCount() { return keyCount; }
-        
+
         public Selector getSelector() { return selector;}
 
         /**
@@ -937,12 +937,12 @@ public class NioEndpoint extends AbstractEndpoint {
             events.clear();
             selector.wakeup();
         }
-        
+
         public void addEvent(Runnable event) {
             events.offer(event);
             if ( wakeupCounter.incrementAndGet() == 0 ) selector.wakeup();
         }
-        
+
         public void cometInterest(NioChannel socket) {
             KeyAttachment att = (KeyAttachment)socket.getAttachment(false);
             add(socket,att.getCometOps());
@@ -951,7 +951,7 @@ public class NioEndpoint extends AbstractEndpoint {
                 selector.wakeup();
             }
         }
-        
+
         /**
          * Add specified socket and associated pool to the poller. The socket will
          * be added to a temporary array, and polled first after a maximum amount
@@ -963,7 +963,7 @@ public class NioEndpoint extends AbstractEndpoint {
         public void add(final NioChannel socket) {
             add(socket,SelectionKey.OP_READ);
         }
-        
+
         public void add(final NioChannel socket, final int interestOps) {
             PollerEvent r = eventCache.poll();
             if ( r==null) r = new PollerEvent(socket,null,interestOps);
@@ -973,7 +973,7 @@ public class NioEndpoint extends AbstractEndpoint {
 
         /**
          * Processes events in the event queue of the Poller.
-         * 
+         *
          * @return <code>true</code> if some events were processed,
          *   <code>false</code> if queue was empty
          */
@@ -996,7 +996,7 @@ public class NioEndpoint extends AbstractEndpoint {
 
             return result;
         }
-        
+
         public void register(final NioChannel socket)
         {
             socket.setPoller(this);
@@ -1024,7 +1024,7 @@ public class NioEndpoint extends AbstractEndpoint {
                         }
                     } else {
                         processSocket(ka.getChannel(), status, false); //don't dispatch if the lines below are cancelling the key
-                    }                    
+                    }
                 }
                 key.attach(null);
                 if (ka!=null) handler.release(ka);
@@ -1053,7 +1053,7 @@ public class NioEndpoint extends AbstractEndpoint {
                 try {if (ka!=null && ka.getSendfileData()!=null && ka.getSendfileData().fchannel!=null && ka.getSendfileData().fchannel.isOpen()) ka.getSendfileData().fchannel.close();}catch (Exception ignore){}
                 if (ka!=null) {
                     ka.reset();
-                    countDownConnection(); 
+                    countDownConnection();
                 }
             } catch (Throwable e) {
                 ExceptionUtils.handleThrowable(e);
@@ -1098,8 +1098,8 @@ public class NioEndpoint extends AbstractEndpoint {
                         }
                         if (close) {
                             timeout(0, false);
-                            selector.close(); 
-                            break; 
+                            selector.close();
+                            break;
                         }
                     } catch ( NullPointerException x ) {
                         //sun bug 5076772 on windows JDK 1.5
@@ -1161,7 +1161,7 @@ public class NioEndpoint extends AbstractEndpoint {
             stopLatch.countDown();
 
         }
-        
+
         protected boolean processKey(SelectionKey sk, KeyAttachment attachment) {
             boolean result = true;
             try {
@@ -1205,7 +1205,7 @@ public class NioEndpoint extends AbstractEndpoint {
                                 result = false;
                             }
                         }
-                    } 
+                    }
                 } else {
                     //invalid key
                     cancelledKey(sk, SocketStatus.ERROR,false);
@@ -1218,7 +1218,7 @@ public class NioEndpoint extends AbstractEndpoint {
             }
             return result;
         }
-        
+
         public boolean processSendfile(SelectionKey sk, KeyAttachment attachment, boolean reg, boolean event) {
             NioChannel sc = null;
             try {
@@ -1235,7 +1235,7 @@ public class NioEndpoint extends AbstractEndpoint {
                 sc = attachment.getChannel();
                 sc.setSendFile(true);
                 WritableByteChannel wc = ((sc instanceof SecureNioChannel)?sc:sc.getIOChannel());
-                
+
                 if (sc.getOutboundRemaining()>0) {
                     if (sc.flushOutbound()) {
                         attachment.access();
@@ -1307,9 +1307,9 @@ public class NioEndpoint extends AbstractEndpoint {
             //this is a must, so that we don't have multiple threads messing with the socket
             reg(sk,attachment,sk.interestOps()& (~readyOps));
         }
-        
+
         protected void reg(SelectionKey sk, KeyAttachment attachment, int intops) {
-            sk.interestOps(intops); 
+            sk.interestOps(intops);
             attachment.interestOps(intops);
             attachment.setCometOps(intops);
         }
@@ -1347,11 +1347,11 @@ public class NioEndpoint extends AbstractEndpoint {
                         long timeout = ka.getTimeout();
                         boolean isTimedout = timeout > 0 && delta > timeout;
                         if ( close ) {
-                            key.interestOps(0); 
+                            key.interestOps(0);
                             ka.interestOps(0); //avoid duplicate stop calls
                             processKey(key,ka);
                         } else if (isTimedout) {
-                            key.interestOps(0); 
+                            key.interestOps(0);
                             ka.interestOps(0); //avoid duplicate timeout calls
                             cancelledKey(key, SocketStatus.TIMEOUT,true);
                         } else if (timeout > -1) {
@@ -1381,13 +1381,13 @@ public class NioEndpoint extends AbstractEndpoint {
         }
     }
 
-// ----------------------------------------------------- Key Attachment Class   
+// ----------------------------------------------------- Key Attachment Class
     public static class KeyAttachment extends SocketWrapper<NioChannel> {
-        
+
         public KeyAttachment(NioChannel channel) {
             super(channel);
         }
-        
+
         public void reset(Poller poller, NioChannel channel, long soTimeout) {
             this.socket = channel;
             this.poller = poller;
@@ -1407,11 +1407,11 @@ public class NioEndpoint extends AbstractEndpoint {
             keepAliveLeft = 100;
             async = false;
         }
-        
+
         public void reset() {
             reset(null,null,-1);
         }
-        
+
         public Poller getPoller() { return poller;}
         public void setPoller(Poller poller){this.poller = poller;}
         public void setComet(boolean comet) { this.comet = comet; }
@@ -1434,8 +1434,8 @@ public class NioEndpoint extends AbstractEndpoint {
         }
         public void resetReadLatch() { readLatch = resetLatch(readLatch); }
         public void resetWriteLatch() { writeLatch = resetLatch(writeLatch); }
-        
-        protected CountDownLatch startLatch(CountDownLatch latch, int cnt) { 
+
+        protected CountDownLatch startLatch(CountDownLatch latch, int cnt) {
             if ( latch == null || latch.getCount() == 0 ) {
                 return new CountDownLatch(cnt);
             }
@@ -1443,34 +1443,34 @@ public class NioEndpoint extends AbstractEndpoint {
         }
         public void startReadLatch(int cnt) { readLatch = startLatch(readLatch,cnt);}
         public void startWriteLatch(int cnt) { writeLatch = startLatch(writeLatch,cnt);}
-        
+
         protected void awaitLatch(CountDownLatch latch, long timeout, TimeUnit unit) throws InterruptedException {
             if ( latch == null ) throw new IllegalStateException("Latch cannot be null");
             latch.await(timeout,unit);
         }
         public void awaitReadLatch(long timeout, TimeUnit unit) throws InterruptedException { awaitLatch(readLatch,timeout,unit);}
         public void awaitWriteLatch(long timeout, TimeUnit unit) throws InterruptedException { awaitLatch(writeLatch,timeout,unit);}
-        
+
         public long getLastRegistered() { return lastRegistered; }
         public void setLastRegistered(long reg) { lastRegistered = reg; }
-        
+
         public void setSendfileData(SendfileData sf) { this.sendfileData = sf;}
         public SendfileData getSendfileData() { return this.sendfileData;}
-        
+
         protected boolean comet = false;
         protected int cometOps = SelectionKey.OP_READ;
         protected boolean cometNotify = false;
         protected CountDownLatch readLatch = null;
         protected CountDownLatch writeLatch = null;
         protected SendfileData sendfileData = null;
-        
+
     }
 
     // ------------------------------------------------ Application Buffer Handler
     public static class NioBufferHandler implements ApplicationBufferHandler {
         protected ByteBuffer readbuf = null;
         protected ByteBuffer writebuf = null;
-        
+
         public NioBufferHandler(int readsize, int writesize, boolean direct) {
             if ( direct ) {
                 readbuf = ByteBuffer.allocateDirect(readsize);
@@ -1480,7 +1480,7 @@ public class NioEndpoint extends AbstractEndpoint {
                 writebuf = ByteBuffer.allocate(writesize);
             }
         }
-        
+
         @Override
         public ByteBuffer expand(ByteBuffer buffer, int remaining) {return buffer;}
         @Override
@@ -1515,17 +1515,17 @@ public class NioEndpoint extends AbstractEndpoint {
     protected class SocketProcessor implements Runnable {
 
         protected NioChannel socket = null;
-        protected SocketStatus status = null; 
+        protected SocketStatus status = null;
 
         public SocketProcessor(NioChannel socket, SocketStatus status) {
             reset(socket,status);
         }
-        
+
         public void reset(NioChannel socket, SocketStatus status) {
             this.socket = socket;
             this.status = status;
         }
-         
+
         @Override
         public void run() {
             boolean launch = false;
@@ -1534,7 +1534,7 @@ public class NioEndpoint extends AbstractEndpoint {
                 try {
                     key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());
                     int handshake = -1;
-                    
+
                     try {
                         if (key!=null) handshake = socket.handshake(key.isReadable(), key.isWritable());
                     }catch ( IOException x ) {
@@ -1555,7 +1555,7 @@ public class NioEndpoint extends AbstractEndpoint {
                                     (KeyAttachment) key.attachment(),
                                     status);
                         }
-    
+
                         if (state == SocketState.CLOSED) {
                             // Close socket and pool
                             try {

==================================================
SSLSessionManager.java
index 1ff87e8a64..81b90b3828 100644
--- a/java/org/apache/tomcat/util/net/NioSelectorPool.java
+++ b/java/org/apache/tomcat/util/net/NioSelectorPool.java
@@ -39,19 +39,19 @@ import org.apache.tomcat.util.MutableInteger;
  */
 
 public class NioSelectorPool {
-    
+
     public NioSelectorPool() {
     }
-    
+
     private static final Log log = LogFactory.getLog(NioSelectorPool.class);
 
     protected static final boolean SHARED =
         Boolean.valueOf(System.getProperty("org.apache.tomcat.util.net.NioSelectorShared", "true")).booleanValue();
-    
+
     protected NioBlockingSelector blockingSelector;
-    
+
     protected volatile Selector SHARED_SELECTOR;
-    
+
     protected int maxSelectors = 200;
     protected long sharedSelectorTimeout = 30000;
     protected int maxSpareSelectors = -1;
@@ -148,8 +148,8 @@ public class NioSelectorPool {
     public int write(ByteBuffer buf, NioChannel socket, Selector selector, long writeTimeout) throws IOException {
         return write(buf,socket,selector,writeTimeout,true,null);
     }
-    
-    public int write(ByteBuffer buf, NioChannel socket, Selector selector, 
+
+    public int write(ByteBuffer buf, NioChannel socket, Selector selector,
                      long writeTimeout, boolean block,MutableInteger lastWrite) throws IOException {
         if ( SHARED && block ) {
             return blockingSelector.write(buf,socket,writeTimeout,lastWrite);
@@ -166,7 +166,7 @@ public class NioSelectorPool {
                     cnt = socket.write(buf); //write the data
                     if (lastWrite!=null) lastWrite.set(cnt);
                     if (cnt == -1) throw new EOFException();
-                    
+
                     written += cnt;
                     if (cnt > 0) {
                         time = System.currentTimeMillis(); //reset our timeout timer
@@ -209,7 +209,7 @@ public class NioSelectorPool {
         return read(buf,socket,selector,readTimeout,true);
     }
     /**
-     * Performs a read using the bytebuffer for data to be read and a selector to register for events should 
+     * Performs a read using the bytebuffer for data to be read and a selector to register for events should
      * you have the block=true.
      * If the <code>selector</code> parameter is null, then it will perform a busy read that could
      * take up a lot of CPU cycles.
@@ -241,7 +241,7 @@ public class NioSelectorPool {
                     read += cnt;
                     if (cnt > 0) continue; //read some more
                     if (cnt==0 && (read>0 || (!block) ) ) break; //we are done reading
-                } 
+                }
                 if ( selector != null ) {//perform a blocking read
                     //register OP_WRITE to the selector
                     if (key==null) key = socket.getIOChannel().register(selector, SelectionKey.OP_READ);

==================================================
SSLSupport.java
index fe93109042..7f6bc4dc05 100644
--- a/java/org/apache/tomcat/util/net/SSLSessionManager.java
+++ b/java/org/apache/tomcat/util/net/SSLSessionManager.java
@@ -20,7 +20,7 @@ package org.apache.tomcat.util.net;
 /**
  * Defines an interface used to manage SSL sessions. The manager operates on a
  * single session.
- * 
+ *
  * $Id$
  */
 public interface SSLSessionManager {

==================================================
SSLUtil.java
index f28db6833a..061c0a2c8d 100644
--- a/java/org/apache/tomcat/util/net/SSLSupport.java
+++ b/java/org/apache/tomcat/util/net/SSLSupport.java
@@ -54,7 +54,7 @@ public interface SSLSupport {
     public static final String SESSION_MGR =
             "javax.servlet.request.ssl_session_mgr";
 
-    
+
     /**
      * A mapping table to determine the number of effective bits in the key
      * when using a cipher suite containing the specified cipher name.  The
@@ -86,7 +86,7 @@ public interface SSLSupport {
 
     /**
      * The client certificate chain (if any).
-     * @param force If <code>true</code>, then re-negotiate the 
+     * @param force If <code>true</code>, then re-negotiate the
      *              connection if necessary.
      */
     public Object[] getPeerCertificateChain(boolean force)
@@ -119,19 +119,19 @@ public interface SSLSupport {
      * corresponding effective key size.  The specified phrase must appear in the
      * name of the cipher suite to be recognized.
      */
-    
+
     final class CipherData {
-    
+
         public String phrase = null;
-    
+
         public int keySize = 0;
-    
+
         public CipherData(String phrase, int keySize) {
             this.phrase = phrase;
             this.keySize = keySize;
         }
-    
+
     }
-    
+
 }
 

==================================================
SecureNioChannel.java
index 01fca48f11..064477956f 100644
--- a/java/org/apache/tomcat/util/net/SSLUtil.java
+++ b/java/org/apache/tomcat/util/net/SSLUtil.java
@@ -23,11 +23,11 @@ import javax.net.ssl.TrustManager;
 
 public interface SSLUtil {
 
-    public SSLContext createSSLContext() throws Exception; 
+    public SSLContext createSSLContext() throws Exception;
 
     public KeyManager[] getKeyManagers() throws Exception;
-    
+
     public TrustManager[] getTrustManagers() throws Exception;
-    
+
     public void configureSessionContext(SSLSessionContext sslSessionContext);
 }

==================================================
ServerSocketFactory.java
index 4a688548f0..4606aeaac6 100644
--- a/java/org/apache/tomcat/util/net/SecureNioChannel.java
+++ b/java/org/apache/tomcat/util/net/SecureNioChannel.java
@@ -32,28 +32,28 @@ import javax.net.ssl.SSLEngineResult.Status;
 import org.apache.tomcat.util.MutableInteger;
 
 /**
- * 
+ *
  * Implementation of a secure socket channel
  * @author Filip Hanik
  * @version 1.0
  */
 
 public class SecureNioChannel extends NioChannel  {
-    
+
     protected ByteBuffer netInBuffer;
     protected ByteBuffer netOutBuffer;
-    
+
     protected SSLEngine sslEngine;
-    
+
     protected boolean handshakeComplete = false;
     protected HandshakeStatus handshakeStatus; //gets set by handshake
-    
+
     protected boolean closed = false;
     protected boolean closing = false;
-    
+
     protected NioSelectorPool pool;
-    
-    public SecureNioChannel(SocketChannel channel, SSLEngine engine, 
+
+    public SecureNioChannel(SocketChannel channel, SSLEngine engine,
                             ApplicationBufferHandler bufHandler, NioSelectorPool pool) throws IOException {
         super(channel,bufHandler);
         this.sslEngine = engine;
@@ -62,17 +62,17 @@ public class SecureNioChannel extends NioChannel  {
         //allocate network buffers - TODO, add in optional direct non-direct buffers
         if ( netInBuffer == null ) netInBuffer = ByteBuffer.allocateDirect(netBufSize);
         if ( netOutBuffer == null ) netOutBuffer = ByteBuffer.allocateDirect(netBufSize);
-        
+
         //selector pool for blocking operations
         this.pool = pool;
-        
+
         //ensure that the application has a large enough read/write buffers
         //by doing this, we should not encounter any buffer overflow errors
         bufHandler.expand(bufHandler.getReadBuffer(), appBufSize);
         bufHandler.expand(bufHandler.getWriteBuffer(), appBufSize);
         reset();
     }
-    
+
     public void reset(SSLEngine engine) throws IOException {
         this.sslEngine = engine;
         reset();
@@ -91,7 +91,7 @@ public class SecureNioChannel extends NioChannel  {
         sslEngine.beginHandshake();
         handshakeStatus = sslEngine.getHandshakeStatus();
     }
-    
+
     @Override
     public int getBufferSize() {
         int size = super.getBufferSize();
@@ -100,12 +100,12 @@ public class SecureNioChannel extends NioChannel  {
         return size;
     }
 
-    
-//===========================================================================================    
+
+//===========================================================================================
 //                  NIO SSL METHODS
 //===========================================================================================
     /**
-     * returns true if the network buffer has 
+     * returns true if the network buffer has
      * been flushed out and is empty
      * @return boolean
      */
@@ -118,7 +118,7 @@ public class SecureNioChannel extends NioChannel  {
         }
         return !netOutBuffer.hasRemaining();
     }
-    
+
     /**
      * Flushes the buffer to the network, non blocking
      * @param buf ByteBuffer
@@ -134,7 +134,7 @@ public class SecureNioChannel extends NioChannel  {
             return true;
         }
     }
-    
+
     /**
      * Performs SSL handshake, non blocking, but performs NEED_TASK on the same thread.<br>
      * Hence, you should never call this method using your Acceptor thread, as you would slow down
@@ -149,11 +149,11 @@ public class SecureNioChannel extends NioChannel  {
     @Override
     public int handshake(boolean read, boolean write) throws IOException {
         if ( handshakeComplete ) return 0; //we have done our initial handshake
-        
+
         if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; //we still have data to write
-        
+
         SSLEngineResult handshake = null;
-        
+
         while (!handshakeComplete) {
             switch ( handshakeStatus ) {
                 case NOT_HANDSHAKING: {
@@ -164,13 +164,13 @@ public class SecureNioChannel extends NioChannel  {
                     //we are complete if we have delivered the last package
                     handshakeComplete = !netOutBuffer.hasRemaining();
                     //return 0 if we are complete, otherwise we still have data to write
-                    return handshakeComplete?0:SelectionKey.OP_WRITE; 
+                    return handshakeComplete?0:SelectionKey.OP_WRITE;
                 }
                 case NEED_WRAP: {
                     //perform the wrap function
                     handshake = handshakeWrap(write);
                     if ( handshake.getStatus() == Status.OK ){
-                        if (handshakeStatus == HandshakeStatus.NEED_TASK) 
+                        if (handshakeStatus == HandshakeStatus.NEED_TASK)
                             handshakeStatus = tasks();
                     } else {
                         //wrap should always work with our buffers
@@ -180,7 +180,7 @@ public class SecureNioChannel extends NioChannel  {
                         //should actually return OP_READ if we have NEED_UNWRAP
                         return SelectionKey.OP_WRITE;
                     }
-                    //fall down to NEED_UNWRAP on the same call, will result in a 
+                    //fall down to NEED_UNWRAP on the same call, will result in a
                     //BUFFER_UNDERFLOW if it needs data
                 }
                 //$FALL-THROUGH$
@@ -188,7 +188,7 @@ public class SecureNioChannel extends NioChannel  {
                     //perform the unwrap function
                     handshake = handshakeUnwrap(read);
                     if ( handshake.getStatus() == Status.OK ) {
-                        if (handshakeStatus == HandshakeStatus.NEED_TASK) 
+                        if (handshakeStatus == HandshakeStatus.NEED_TASK)
                             handshakeStatus = tasks();
                     } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){
                         //read more data, reregister for OP_READ
@@ -204,15 +204,15 @@ public class SecureNioChannel extends NioChannel  {
                 }
                 default: throw new IllegalStateException("Invalid handshake status:"+handshakeStatus);
             }//switch
-        }//while      
-        //return 0 if we are complete, otherwise reregister for any activity that 
+        }//while
+        //return 0 if we are complete, otherwise reregister for any activity that
         //would cause this method to be called again.
         return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);
     }
-    
+
     /**
      * Force a blocking handshake to take place for this key.
-     * This requires that both network and application buffers have been emptied out prior to this call taking place, or a 
+     * This requires that both network and application buffers have been emptied out prior to this call taking place, or a
      * IOException will be thrown.
      * @param timeout - timeout in milliseconds for each socket operation
      * @throws IOException - if an IO exception occurs or if application or network buffers contain data
@@ -263,9 +263,9 @@ public class SecureNioChannel extends NioChannel  {
             if (selector!=null) try {selector.close();} catch (Exception ignore) {}
         }
     }
-    
-    
-    
+
+
+
     /**
      * Executes all the tasks needed on the same thread.
      * @return HandshakeStatus
@@ -298,7 +298,7 @@ public class SecureNioChannel extends NioChannel  {
         if ( doWrite ) flush(netOutBuffer);
         return result;
     }
-    
+
     /**
      * Perform handshake unwrap
      * @param doread boolean
@@ -306,7 +306,7 @@ public class SecureNioChannel extends NioChannel  {
      * @throws IOException
      */
     protected SSLEngineResult handshakeUnwrap(boolean doread) throws IOException {
-        
+
         if (netInBuffer.position() == netInBuffer.limit()) {
             //clear the buffer if we have emptied it out on data
             netInBuffer.clear();
@@ -315,7 +315,7 @@ public class SecureNioChannel extends NioChannel  {
             //if we have data to read, read it
             int read = sc.read(netInBuffer);
             if (read == -1) throw new IOException("EOF encountered during handshake.");
-        }        
+        }
         SSLEngineResult result;
         boolean cont = false;
         //loop while we can perform pure SSLEngine data
@@ -339,7 +339,7 @@ public class SecureNioChannel extends NioChannel  {
         }while ( cont );
         return result;
     }
-    
+
     /**
      * Sends a SSL close message, will not physically close the connection here.<br>
      * To close the connection, you could do something like
@@ -418,7 +418,7 @@ public class SecureNioChannel extends NioChannel  {
         int netread = sc.read(netInBuffer);
         //did we reach EOF? if so send EOF up one layer.
         if (netread == -1) return -1;
-        
+
         //the data read
         int read = 0;
         //the SSL engine result
@@ -430,7 +430,7 @@ public class SecureNioChannel extends NioChannel  {
             unwrap = sslEngine.unwrap(netInBuffer, dst);
             //compact the buffer
             netInBuffer.compact();
-            
+
             if ( unwrap.getStatus()==Status.OK || unwrap.getStatus()==Status.BUFFER_UNDERFLOW ) {
                 //we did receive some data, add it to our total
                 read += unwrap.bytesProduced();
@@ -439,7 +439,7 @@ public class SecureNioChannel extends NioChannel  {
                 //if we need more network data, then bail out for now.
                 if ( unwrap.getStatus() == Status.BUFFER_UNDERFLOW ) break;
             }else if ( unwrap.getStatus()==Status.BUFFER_OVERFLOW && read>0 ) {
-                //buffer overflow can happen, if we have read data, then 
+                //buffer overflow can happen, if we have read data, then
                 //empty out the dst buffer before we do another read
                 break;
             }else {
@@ -494,7 +494,7 @@ public class SecureNioChannel extends NioChannel  {
                 if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) tasks();
             } else {
                 throw new IOException("Unable to wrap data, invalid engine state: " +result.getStatus());
-            }        
+            }
 
             //force a flush
             flush(netOutBuffer);
@@ -502,12 +502,12 @@ public class SecureNioChannel extends NioChannel  {
             return written;
         }
     }
-    
+
     @Override
     public int getOutboundRemaining() {
         return netOutBuffer.remaining();
     }
-    
+
     @Override
     public boolean flushOutbound() throws IOException {
         int remaining = netOutBuffer.remaining();
@@ -516,7 +516,7 @@ public class SecureNioChannel extends NioChannel  {
         return remaining2 < remaining;
     }
 
-    
+
     /**
      * Callback interface to be able to expand buffers
      * when buffer overflow exceptions happen
@@ -553,7 +553,7 @@ public class SecureNioChannel extends NioChannel  {
     public void setBufHandler(ApplicationBufferHandler bufHandler) {
         this.bufHandler = bufHandler;
     }
-    
+
     @Override
     public SocketChannel getIOChannel() {
         return sc;

==================================================
SocketProperties.java
index 5d77925558..1265bb190b 100644
--- a/java/org/apache/tomcat/util/net/ServerSocketFactory.java
+++ b/java/org/apache/tomcat/util/net/ServerSocketFactory.java
@@ -23,7 +23,7 @@ import java.net.Socket;
 
 /**
  * The common interface through which the {@link JIoEndpoint} interacts with
- * both non-SSL and SSL sockets. 
+ * both non-SSL and SSL sockets.
  */
 public interface ServerSocketFactory {
 
@@ -31,7 +31,7 @@ public interface ServerSocketFactory {
      * Returns a server socket which uses all network interfaces on the host,
      * and is bound to a the specified port. The socket is configured with the
      * socket options (such as accept timeout) given to this factory.
-     * 
+     *
      * @param port
      *            the port to listen to
      * @exception IOException
@@ -47,7 +47,7 @@ public interface ServerSocketFactory {
      * bound to a the specified port, and uses the specified connection backlog.
      * The socket is configured with the socket options (such as accept timeout)
      * given to this factory.
-     * 
+     *
      * @param port
      *            the port to listen to
      * @param backlog
@@ -65,7 +65,7 @@ public interface ServerSocketFactory {
      * on the local host, is bound to a the specified port, and uses the
      * specified connection backlog. The socket is configured with the socket
      * options (such as accept timeout) given to this factory.
-     * 
+     *
      * @param port
      *            the port to listen to
      * @param backlog
@@ -83,14 +83,14 @@ public interface ServerSocketFactory {
     /**
      * Wrapper function for accept(). This allows us to trap and translate
      * exceptions if necessary.
-     * 
+     *
      * @exception IOException
      */
     Socket acceptSocket(ServerSocket socket) throws IOException;
 
     /**
      * Triggers the SSL handshake. This will be a no-op for non-SSL sockets.
-     * 
+     *
      * @exception IOException
      */
     void handshake(Socket sock) throws IOException;

==================================================
SocketStatus.java
index b4363804f2..3d1d8bedd6 100644
--- a/java/org/apache/tomcat/util/net/SocketProperties.java
+++ b/java/org/apache/tomcat/util/net/SocketProperties.java
@@ -36,7 +36,7 @@ public class SocketProperties {
      * 0 is disabled
      */
     protected int keyCache = 500;
-    
+
     /**
      * Enable/disable socket processor cache, this bounded cache stores
      * SocketProcessor objects to reduce GC
@@ -49,7 +49,7 @@ public class SocketProperties {
     /**
      * Enable/disable poller event cache, this bounded cache stores
      * PollerEvent objects to reduce GC for the poller
-     * Default is 500 
+     * Default is 500
      * -1 is unlimited
      * 0 is disabled
      * >0 the max number of objects to keep in cache.
@@ -171,13 +171,13 @@ public class SocketProperties {
      * used.
      */
     protected Integer performanceBandwidth = null;
-    
+
     /**
      * The minimum frequency of the timeout interval to avoid excess load from
      * the poller during high traffic
      */
     protected long timeoutInterval = 1000;
-    
+
     /**
      * Timeout in milliseconds for an unlock to take place.
      */
@@ -226,7 +226,7 @@ public class SocketProperties {
             socket.setSoTimeout(soTimeout.intValue());
     }
 
-    
+
     public boolean getDirectBuffer() {
         return directBuffer;
     }

==================================================
SocketWrapper.java
index 58ee7f11f4..bf53c2bd08 100644
--- a/java/org/apache/tomcat/util/net/SocketStatus.java
+++ b/java/org/apache/tomcat/util/net/SocketStatus.java
@@ -18,8 +18,8 @@
 package org.apache.tomcat.util.net;
 
 /**
- * Someone, please change the enum name. 
- * 
+ * Someone, please change the enum name.
+ *
  * @author remm
  */
 public enum SocketStatus {

==================================================
URL.java
index 6a3c689212..b1946703da 100644
--- a/java/org/apache/tomcat/util/net/SocketWrapper.java
+++ b/java/org/apache/tomcat/util/net/SocketWrapper.java
@@ -17,9 +17,9 @@
 package org.apache.tomcat.util.net;
 
 public class SocketWrapper<E> {
-    
+
     protected volatile E socket;
-    
+
     protected volatile long lastAccess = -1;
     protected long timeout = -1;
     protected boolean error = false;
@@ -27,15 +27,15 @@ public class SocketWrapper<E> {
     protected volatile int keepAliveLeft = 100;
     protected boolean async = false;
     protected boolean keptAlive = false;
-    
+
     public SocketWrapper(E socket) {
         this.socket = socket;
     }
-    
+
     public E getSocket() {
         return socket;
     }
-    
+
     public boolean isAsync() { return async; }
     public void setAsync(boolean async) { this.async = async; }
     public long getLastAccess() { return lastAccess; }

==================================================
JSSEImplementation.java
index d9a58ea7e4..774bbb7139 100644
--- a/java/org/apache/tomcat/util/net/URL.java
+++ b/java/org/apache/tomcat/util/net/URL.java
@@ -49,7 +49,7 @@ public final class URL implements Serializable {
 
     private static final long serialVersionUID = 1L;
 
-    
+
     // ----------------------------------------------------------- Constructors
 
     /**
@@ -109,7 +109,7 @@ public final class URL implements Serializable {
             }
 
             // Parse out the new protocol
-            for (i = start; !aRef && (i < limit) ; i++) { 
+            for (i = start; !aRef && (i < limit) ; i++) {
                 c = spec.charAt(i);
                 if (c == ':') {
                     String s = spec.substring(start, i).toLowerCase(Locale.ENGLISH);
@@ -684,7 +684,7 @@ public final class URL implements Serializable {
                         at = ipv6-1;
                     }
                 }
-                                                        
+
                 int colon = authority.indexOf(':', at+1);
                 if (colon >= 0) {
                     try {

==================================================
JSSEKeyManager.java
index be2a5de907..6b957c78bf 100644
--- a/java/org/apache/tomcat/util/net/jsse/JSSEImplementation.java
+++ b/java/org/apache/tomcat/util/net/jsse/JSSEImplementation.java
@@ -34,18 +34,18 @@ import org.apache.tomcat.util.net.ServerSocketFactory;
 
    @author EKR
 */
-        
+
 public class JSSEImplementation extends SSLImplementation {
 
     @Override
     public String getImplementationName(){
         return "JSSE";
     }
-      
+
     @Override
     public ServerSocketFactory getServerSocketFactory(AbstractEndpoint endpoint)  {
         return new JSSESocketFactory(endpoint);
-    } 
+    }
 
     @Override
     public SSLSupport getSSLSupport(Socket s) {

==================================================
JSSESocketFactory.java
index bebacba0e8..5759944e6b 100644
--- a/java/org/apache/tomcat/util/net/jsse/JSSEKeyManager.java
+++ b/java/org/apache/tomcat/util/net/jsse/JSSEKeyManager.java
@@ -100,7 +100,7 @@ public final class JSSEKeyManager extends X509ExtendedKeyManager {
      */
     @Override
     public X509Certificate[] getCertificateChain(String alias) {
-        return delegate.getCertificateChain(alias); 
+        return delegate.getCertificateChain(alias);
     }
 
     /**

==================================================
JSSESupport.java
index 4454093005..3a98775a42 100644
--- a/java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java
+++ b/java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java
@@ -70,7 +70,7 @@ import org.apache.tomcat.util.res.StringManager;
  * JSSE.<br/>
  * keytool -genkey -alias tomcat -keyalg RSA</br>
  * Use "changeit" as password (this is the default we use).
- * 
+ *
  * @author Harish Prabandham
  * @author Costin Manolache
  * @author Stefan Freyr Stefansson
@@ -96,7 +96,7 @@ public class JSSESocketFactory implements ServerSocketFactory, SSLUtil {
     private static final int defaultSessionTimeout = 86400;
     private static final String ALLOW_ALL_SUPPORTED_CIPHERS = "ALL";
     public static final String DEFAULT_KEY_PASS = "changeit";
-    
+
     static {
         boolean result = false;
         SSLContext context;
@@ -150,7 +150,7 @@ public class JSSESocketFactory implements ServerSocketFactory, SSLUtil {
         initServerSocket(socket);
         return socket;
     }
-    
+
     @Override
     public ServerSocket createSocket (int port, int backlog)
         throws IOException
@@ -160,19 +160,19 @@ public class JSSESocketFactory implements ServerSocketFactory, SSLUtil {
         initServerSocket(socket);
         return socket;
     }
-    
+
     @Override
     public ServerSocket createSocket (int port, int backlog,
                                       InetAddress ifAddress)
         throws IOException
-    {   
+    {
         init();
         ServerSocket socket = sslProxy.createServerSocket(port, backlog,
                                                           ifAddress);
         initServerSocket(socket);
         return socket;
     }
-    
+
     @Override
     public Socket acceptSocket(ServerSocket socket)
         throws IOException
@@ -185,7 +185,7 @@ public class JSSESocketFactory implements ServerSocketFactory, SSLUtil {
         }
         return asock;
     }
-    
+
     @Override
     public void handshake(Socket sock) throws IOException {
         // We do getSession instead of startHandshake() so we can call this multiple times
@@ -266,7 +266,7 @@ public class JSSESocketFactory implements ServerSocketFactory, SSLUtil {
                         }
                     }
                 }
-            }           
+            }
 
             if (vec != null) {
                 result = new String[vec.size()];
@@ -278,7 +278,7 @@ public class JSSESocketFactory implements ServerSocketFactory, SSLUtil {
 
         return result;
     }
-     
+
     /*
      * Gets the SSL server's keystore password.
      */
@@ -399,10 +399,10 @@ public class JSSESocketFactory implements ServerSocketFactory, SSLUtil {
                 }
                 istream = new FileInputStream(keyStoreFile);
             }
-            
+
             char[] storePass = null;
             if (pass != null && !"".equals(pass)) {
-                storePass = pass.toCharArray(); 
+                storePass = pass.toCharArray();
             }
             ks.load(istream, storePass);
         } catch (FileNotFoundException fnfe) {
@@ -465,7 +465,7 @@ public class JSSESocketFactory implements ServerSocketFactory, SSLUtil {
 
             allowUnsafeLegacyRenegotiation = "true".equals(
                     endpoint.getAllowUnsafeLegacyRenegotiation());
-            
+
             // Check the SSL config is OK
             checkConfig();
 
@@ -485,11 +485,11 @@ public class JSSESocketFactory implements ServerSocketFactory, SSLUtil {
             protocol = defaultProtocol;
         }
 
-        SSLContext context = SSLContext.getInstance(protocol); 
+        SSLContext context = SSLContext.getInstance(protocol);
 
         return context;
     }
-    
+
     @Override
     public KeyManager[] getKeyManagers() throws Exception {
         String keystoreType = endpoint.getKeystoreType();
@@ -518,7 +518,7 @@ public class JSSESocketFactory implements ServerSocketFactory, SSLUtil {
         if (truststoreType == null) {
             truststoreType = defaultKeystoreType;
         }
-        
+
         String algorithm = endpoint.getTruststoreAlgorithm();
         if (algorithm == null) {
             algorithm = TrustManagerFactory.getDefaultAlgorithm();
@@ -537,7 +537,7 @@ public class JSSESocketFactory implements ServerSocketFactory, SSLUtil {
         } else {
             sessionCacheSize = defaultSessionCacheSize;
         }
-        
+
         int sessionTimeout;
         if (endpoint.getSessionTimeout() != null) {
             sessionTimeout = Integer.parseInt(endpoint.getSessionTimeout());
@@ -596,7 +596,7 @@ public class JSSESocketFactory implements ServerSocketFactory, SSLUtil {
             String keystoreProvider, String algorithm)
         throws Exception {
         String crlf = endpoint.getCrlFile();
-        
+
         String className = endpoint.getTrustManagerClassName();
         if(className != null && className.length() > 0) {
              ClassLoader classLoader = getClass().getClassLoader();
@@ -608,10 +608,10 @@ public class JSSESocketFactory implements ServerSocketFactory, SSLUtil {
              Object trustManagerObject = clazz.newInstance();
              TrustManager trustManager = (TrustManager) trustManagerObject;
              return new TrustManager[]{ trustManager };
-        }    
+        }
 
         TrustManager[] tms = null;
-        
+
         KeyStore trustStore = getTrustStore(keystoreType, keystoreProvider);
         if (trustStore != null || endpoint.getTrustManagerClassName() != null) {
             if (crlf == null) {
@@ -630,21 +630,21 @@ public class JSSESocketFactory implements ServerSocketFactory, SSLUtil {
                 tms = tmf.getTrustManagers();
             }
         }
-        
+
         return tms;
     }
 
     /**
      * Return the initialization parameters for the TrustManager.
      * Currently, only the default <code>PKIX</code> is supported.
-     * 
+     *
      * @param algorithm The algorithm to get parameters for.
      * @param crlf The path to the CRL file.
      * @param trustStore The configured TrustStore.
      * @return The parameters including the CRLs and TrustStore.
      */
-    protected CertPathParameters getParameters(String algorithm, 
-                                                String crlf, 
+    protected CertPathParameters getParameters(String algorithm,
+                                                String crlf,
                                                 KeyStore trustStore)
         throws Exception {
         CertPathParameters params = null;
@@ -675,9 +675,9 @@ public class JSSESocketFactory implements ServerSocketFactory, SSLUtil {
 
     /**
      * Load the collection of CRLs.
-     * 
+     *
      */
-    protected Collection<? extends CRL> getCRLs(String crlf) 
+    protected Collection<? extends CRL> getCRLs(String crlf)
         throws IOException, CRLException, CertificateException {
 
         File crlFile = new File(crlf);
@@ -697,7 +697,7 @@ public class JSSESocketFactory implements ServerSocketFactory, SSLUtil {
             throw crle;
         } catch(CertificateException ce) {
             throw ce;
-        } finally { 
+        } finally {
             if(is != null) {
                 try{
                     is.close();
@@ -792,7 +792,7 @@ public class JSSESocketFactory implements ServerSocketFactory, SSLUtil {
         }
 
         String[] requestedProtocols = endpoint.getSslEnabledProtocolsArray();
-        setEnabledProtocols(socket, getEnabledProtocols(socket, 
+        setEnabledProtocols(socket, getEnabledProtocols(socket,
                                                          requestedProtocols));
 
         // we don't know if client auth is needed -
@@ -812,7 +812,7 @@ public class JSSESocketFactory implements ServerSocketFactory, SSLUtil {
 
         try {
             // Set the timeout to 1ms as all we care about is if it throws an
-            // SSLException on accept. 
+            // SSLException on accept.
             socket.setSoTimeout(1);
 
             socket.accept();
@@ -840,6 +840,6 @@ public class JSSESocketFactory implements ServerSocketFactory, SSLUtil {
                 socket.close();
             }
         }
-        
+
     }
 }

==================================================
NioX509KeyManager.java
index f0fcfd9c3e..402ad95293 100644
--- a/java/org/apache/tomcat/util/net/jsse/JSSESupport.java
+++ b/java/org/apache/tomcat/util/net/jsse/JSSESupport.java
@@ -48,15 +48,15 @@ import org.apache.tomcat.util.res.StringManager;
    @author EKR
    @author Craig R. McClanahan
    @author Filip Hanik
-   Parts cribbed from JSSECertCompat       
+   Parts cribbed from JSSECertCompat
    Parts cribbed from CertificatesValve
 */
 
 class JSSESupport implements SSLSupport, SSLSessionManager {
-    
+
     private static final org.apache.juli.logging.Log log =
         org.apache.juli.logging.LogFactory.getLog(JSSESupport.class);
-    
+
     private static final StringManager sm =
         StringManager.getManager("org.apache.tomcat.util.net.jsse.res");
 
@@ -73,7 +73,7 @@ class JSSESupport implements SSLSupport, SSLSessionManager {
         session = sock.getSession();
         sock.addHandshakeCompletedListener(listener);
     }
-    
+
     JSSESupport(SSLSession session) {
         this.session = session;
     }
@@ -87,7 +87,7 @@ class JSSESupport implements SSLSupport, SSLSessionManager {
     }
 
     @Override
-    public Object[] getPeerCertificateChain() 
+    public Object[] getPeerCertificateChain()
         throws IOException {
         return getPeerCertificateChain(false);
     }
@@ -102,8 +102,8 @@ class JSSESupport implements SSLSupport, SSLSessionManager {
             return null;
         }
         if( certs==null ) return null;
-        
-        java.security.cert.X509Certificate [] x509Certs = 
+
+        java.security.cert.X509Certificate [] x509Certs =
             new java.security.cert.X509Certificate[certs.length];
         for(int i=0; i < certs.length; i++) {
             if (certs[i] instanceof java.security.cert.X509Certificate ) {
@@ -118,7 +118,7 @@ class JSSESupport implements SSLSupport, SSLSessionManager {
                         new ByteArrayInputStream(buffer);
                     x509Certs[i] = (java.security.cert.X509Certificate)
                             cf.generateCertificate(stream);
-                } catch(Exception ex) { 
+                } catch(Exception ex) {
                     log.info(sm.getString(
                             "jseeSupport.certTranslationError", certs[i]), ex);
                     return null;
@@ -212,18 +212,18 @@ class JSSESupport implements SSLSupport, SSLSessionManager {
      * Copied from <code>org.apache.catalina.valves.CertificateValve</code>
      */
     @Override
-    public Integer getKeySize() 
+    public Integer getKeySize()
         throws IOException {
         // Look up the current SSLSession
         SSLSupport.CipherData c_aux[]=ciphers;
         if (session == null)
             return null;
-        
+
         Integer keySize = null;
         synchronized(keySizeCache) {
             keySize = keySizeCache.get(session);
         }
-        
+
         if (keySize == null) {
             int size = 0;
             String cipherSuite = session.getCipherSuite();
@@ -249,7 +249,7 @@ class JSSESupport implements SSLSupport, SSLSessionManager {
             return null;
         // Expose ssl_session (getId)
         byte [] ssl_session = session.getId();
-        if ( ssl_session == null) 
+        if ( ssl_session == null)
             return null;
         StringBuilder buf=new StringBuilder();
         for(int x=0; x<ssl_session.length; x++) {

==================================================
StringManager.java
index 6e7f8131f0..cdf93f23b0 100644
--- a/java/org/apache/tomcat/util/net/jsse/res/LocalStrings_es.properties
+++ b/java/org/apache/tomcat/util/net/jsse/res/LocalStrings_es.properties
@@ -16,4 +16,4 @@ jsse.alias_no_key_entry = El nombre de Alias {0} no identifica una entrada de cl
 jsse.keystore_load_failed = No pude cargar almac\u00E9n de claves de tipo {0} con ruta {1} debido a {2}
 jsse.invalid_ssl_conf = La configuraci\u00F3n SSL no es v\u00E1lida debido a {0}
 jsse.invalid_truststore_password = La clave del almac\u00E9n de confianza suministrada no se pudo usar para desbloquear y/o validar el almac\u00E9n de confianza. Reintentando acceder el almac\u00E9n de confianza con una clave nula que se saltar\u00E1 la validaci\u00F3n.
-jsse.invalidTrustManagerClassName = El trustManagerClassName suministrado [{0}] no implementa  javax.net.ssl.TrustManager 
+jsse.invalidTrustManagerClassName = El trustManagerClassName suministrado [{0}] no implementa  javax.net.ssl.TrustManager

==================================================
Constants.java
index 5dbc410914..016f8d2041 100644
--- a/java/org/apache/tomcat/util/res/StringManager.java
+++ b/java/org/apache/tomcat/util/res/StringManager.java
@@ -97,11 +97,11 @@ public class StringManager {
     /**
         Get a string from the underlying resource bundle or return
         null if the String is not found.
-     
+
         @param key to desired resource String
         @return resource String matching <i>key</i> from underlying
                 bundle or null if not found.
-        @throws IllegalArgumentException if <i>key</i> is null.        
+        @throws IllegalArgumentException if <i>key</i> is null.
      */
     public String getString(String key) {
         if(key == null){
@@ -195,7 +195,7 @@ public class StringManager {
             map = new Hashtable<Locale, StringManager>();
             managers.put(packageName, map);
         }
-        
+
         StringManager mgr = map.get(locale);
         if (mgr == null) {
             mgr = new StringManager(packageName, locale);

==================================================
FileUrlJar.java
index b84517d293..05f4d52ba8 100644
--- a/java/org/apache/tomcat/util/scan/Constants.java
+++ b/java/org/apache/tomcat/util/scan/Constants.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
Jar.java
index dc90107cd6..2fbb30a641 100644
--- a/java/org/apache/tomcat/util/scan/FileUrlJar.java
+++ b/java/org/apache/tomcat/util/scan/FileUrlJar.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
JarFactory.java
index ffd841a8bb..70eba1adf2 100644
--- a/java/org/apache/tomcat/util/scan/Jar.java
+++ b/java/org/apache/tomcat/util/scan/Jar.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -32,18 +32,18 @@ public interface Jar {
 
     /**
      * Determines if a specific entry exists within the JAR.
-     * 
+     *
      * @param name  Entry to look for
      * @return      <code>true</code> if the specified entry exists else
      *               <code>false</code>
      */
     boolean entryExists(String name) throws IOException;
-    
-    
+
+
     /**
      * Obtain an {@link InputStream} for a given entry in a JAR. The caller is
      * responsible for closing the stream.
-     * 
+     *
      * @param name  Entry to obtain an {@link InputStream} for
      * @return      An {@link InputStream} for the specified entry or null if
      *              the entry does not exist
@@ -54,31 +54,31 @@ public interface Jar {
      * Close any resources associated with this JAR.
      */
     void close();
-    
+
     /**
      * Moves the internal pointer to the next entry in the JAR.
      */
     void nextEntry();
-    
+
     /**
      * Obtains the name of the current entry.
-     * 
+     *
      * @return  The entry name
      */
     String getEntryName();
-    
+
     /**
      * Obtains the input stream for the current entry.
-     * 
+     *
      * @return  The input stream
      * @throws IOException  If the stream cannot be obtained
      */
     InputStream getEntryInputStream() throws IOException;
-    
+
     /**
      * Resets the internal pointer used to track JAR entries to the beginning of
      * the JAR.
-     * 
+     *
      * @throws IOException  If the pointer cannot be reset
      */
     void reset() throws IOException;

==================================================
NonClosingJarInputStream.java
index 5a36abe187..998d1e2432 100644
--- a/java/org/apache/tomcat/util/scan/JarFactory.java
+++ b/java/org/apache/tomcat/util/scan/JarFactory.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
StandardJarScanner.java
index 4c8bb27009..1488624067 100644
--- a/java/org/apache/tomcat/util/scan/NonClosingJarInputStream.java
+++ b/java/org/apache/tomcat/util/scan/NonClosingJarInputStream.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -24,7 +24,7 @@ import java.util.jar.JarInputStream;
  * When using a {@link JarInputStream} with an XML parser, the stream will be
  * closed by the parser. This causes problems if multiple entries from the JAR
  * need to be parsed. This implementation makes {{@link #close()} a NO-OP and
- * adds {@link #reallyClose()} that will close the stream. 
+ * adds {@link #reallyClose()} that will close the stream.
  */
 public class NonClosingJarInputStream extends JarInputStream {
 

==================================================
UrlJar.java
index 4374190026..7efc51d84f 100644
--- a/java/org/apache/tomcat/util/scan/StandardJarScanner.java
+++ b/java/org/apache/tomcat/util/scan/StandardJarScanner.java
@@ -57,7 +57,7 @@ public class StandardJarScanner implements JarScanner {
     private static final Log log = LogFactory.getLog(StandardJarScanner.class);
 
     private static final Set<String> defaultJarsToSkip = new HashSet<String>();
-    
+
     /**
      * The string resources for this package.
      */
@@ -111,7 +111,7 @@ public class StandardJarScanner implements JarScanner {
     /**
      * Scan the provided ServletContext and classloader for JAR files. Each JAR
      * file found will be passed to the callback handler to be processed.
-     *  
+     *
      * @param context       The ServletContext - used to locate and access
      *                      WEB-INF/lib
      * @param classloader   The classloader - used to access JARs not in
@@ -119,7 +119,7 @@ public class StandardJarScanner implements JarScanner {
      * @param callback      The handler to process any JARs found
      * @param jarsToSkip    List of JARs to ignore. If this list is null, a
      *                      default list will be read from the system property
-     *                      defined by {@link Constants#SKIP_JARS_PROPERTY} 
+     *                      defined by {@link Constants#SKIP_JARS_PROPERTY}
      */
     @Override
     public void scan(ServletContext context, ClassLoader classloader,
@@ -174,23 +174,23 @@ public class StandardJarScanner implements JarScanner {
                 }
             }
         }
-        
+
         // Scan the classpath
         if (scanClassPath) {
             if (log.isTraceEnabled()) {
                 log.trace(sm.getString("jarScan.classloaderStart"));
             }
 
-            ClassLoader loader = 
+            ClassLoader loader =
                 Thread.currentThread().getContextClassLoader();
-            
+
             while (loader != null) {
                 if (loader instanceof URLClassLoader) {
                     URL[] urls = ((URLClassLoader) loader).getURLs();
                     for (int i=0; i<urls.length; i++) {
                         // Extract the jarName if there is one to be found
                         String jarName = getJarName(urls[i]);
-                        
+
                         // Skip JARs known not to be interesting and JARs
                         // in WEB-INF/lib we have already scanned
                         if (jarName != null &&
@@ -263,16 +263,16 @@ public class StandardJarScanner implements JarScanner {
                 }
             }
         }
-        
+
     }
 
     /*
      * Extract the JAR name, if present, from a URL
      */
     private String getJarName(URL url) {
-        
+
         String name = null;
-        
+
         String path = url.getPath();
         int end = path.indexOf(Constants.JAR_EXT);
         if (end != -1) {
@@ -282,7 +282,7 @@ public class StandardJarScanner implements JarScanner {
             int start = path.lastIndexOf('/');
             name = path.substring(start + 1);
         }
-        
+
         return name;
     }
 

==================================================
Constants.java
index af612c7222..58bef365a2 100644
--- a/java/org/apache/tomcat/util/scan/UrlJar.java
+++ b/java/org/apache/tomcat/util/scan/UrlJar.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -47,7 +47,7 @@ public class UrlJar implements Jar {
             }
             entry = jarInputStream.getNextJarEntry();
         }
-        
+
         return entry != null;
     }
 
@@ -60,7 +60,7 @@ public class UrlJar implements Jar {
             }
             entry = jarInputStream.getNextJarEntry();
         }
-        
+
         if (entry == null) {
             return null;
         } else {

==================================================
DedicatedThreadExecutor.java
index 9578ac22d8..5c225e472b 100644
--- a/java/org/apache/tomcat/util/threads/Constants.java
+++ b/java/org/apache/tomcat/util/threads/Constants.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
LimitLatch.java
index 43e4411589..83ee8bab49 100644
--- a/java/org/apache/tomcat/util/threads/DedicatedThreadExecutor.java
+++ b/java/org/apache/tomcat/util/threads/DedicatedThreadExecutor.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -40,7 +40,7 @@ public class DedicatedThreadExecutor {
     /**
      * Executes the given {@link Callable} with the thread spawned for the
      * current {@link DedicatedThreadExecutor} instance, and returns its result.
-     * 
+     *
      * @param <V>
      *            the type of the returned value
      * @param callable
@@ -96,7 +96,7 @@ public class DedicatedThreadExecutor {
     /**
      * Executes the given {@link Callable} in a new thread and returns the
      * result after the thread is stopped.
-     * 
+     *
      * @param <V>
      * @param callable
      * @return the completed result

==================================================
ResizableExecutor.java
index c2687de1c2..f64535be0a 100644
--- a/java/org/apache/tomcat/util/threads/LimitLatch.java
+++ b/java/org/apache/tomcat/util/threads/LimitLatch.java
@@ -56,7 +56,7 @@ public class LimitLatch {
     private final AtomicLong count;
     private volatile long limit;
     private volatile boolean released = false;
-    
+
     /**
      * Instantiates a LimitLatch object with an initial limit.
      * @param limit - maximum number of concurrent acquisitions of this latch
@@ -83,7 +83,7 @@ public class LimitLatch {
      * the new limit. If the limit is increased, threads currently in the queue
      * may not be issued one of the newly available shares until the next
      * request is made for a latch.
-     * 
+     *
      * @param limit The new limit
      */
     public void setLimit(long limit) {
@@ -107,7 +107,7 @@ public class LimitLatch {
         sync.releaseShared(0);
         return count.get();
     }
-    
+
     /**
      * Releases all waiting threads and causes the {@link #limit} to be ignored
      * until {@link #reset()} is called.
@@ -116,7 +116,7 @@ public class LimitLatch {
         released = true;
         return sync.releaseShared(0);
     }
-    
+
     /**
      * Resets the latch and initializes the shared acquisition counter to zero.
      * @see #releaseAll()
@@ -125,7 +125,7 @@ public class LimitLatch {
         this.count.set(0);
         released = false;
     }
-    
+
     /**
      * Returns <code>true</code> if there is at least one thread waiting to
      * acquire the shared lock, otherwise returns <code>false</code>.

==================================================
TaskQueue.java
index 0e8f0d2947..f111b36302 100644
--- a/java/org/apache/tomcat/util/threads/ResizableExecutor.java
+++ b/java/org/apache/tomcat/util/threads/ResizableExecutor.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -26,7 +26,7 @@ public interface ResizableExecutor extends Executor {
      * @return the number of threads
      */
     public int getPoolSize();
-    
+
     public int getMaxThreads();
 
     /**
@@ -36,9 +36,9 @@ public interface ResizableExecutor extends Executor {
      * @return the number of threads
      */
     public int getActiveCount();
-    
+
     public boolean resizePool(int corePoolSize, int maximumPoolSize);
-    
+
     public boolean resizeQueue(int capacity);
-    
+
 }

==================================================
TaskThread.java
index eb606f4f23..b7e16ab8df 100644
--- a/java/org/apache/tomcat/util/threads/TaskQueue.java
+++ b/java/org/apache/tomcat/util/threads/TaskQueue.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -23,9 +23,9 @@ import java.util.concurrent.TimeUnit;
 
 /**
  * As task queue specifically designed to run with a thread pool executor.
- * The task queue is optimised to properly utilize threads within 
+ * The task queue is optimised to properly utilize threads within
  * a thread pool executor. If you use a normal queue, the executor will spawn threads
- * when there are idle threads and you wont be able to force items unto the queue itself 
+ * when there are idle threads and you wont be able to force items unto the queue itself
  * @author fhanik
  *
  */
@@ -34,7 +34,7 @@ public class TaskQueue extends LinkedBlockingQueue<Runnable> {
     private static final long serialVersionUID = 1L;
 
     private ThreadPoolExecutor parent = null;
-    
+
     // no need to be volatile, the one times when we change and read it occur in
     // a single thread (the one that did stop a context and fired listeners)
     private Integer forcedRemainingCapacity = null;
@@ -54,7 +54,7 @@ public class TaskQueue extends LinkedBlockingQueue<Runnable> {
     public void setParent(ThreadPoolExecutor tp) {
         parent = tp;
     }
-    
+
     public boolean force(Runnable o) {
         if ( parent.isShutdown() ) throw new RejectedExecutionException("Executor not running, can't force a command into the queue");
         return super.offer(o); //forces the item onto the queue, to be used if the task is rejected

==================================================
TaskThreadFactory.java
index 6038d9df47..c7fb265e1d 100644
--- a/java/org/apache/tomcat/util/threads/TaskThread.java
+++ b/java/org/apache/tomcat/util/threads/TaskThread.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -18,7 +18,7 @@ package org.apache.tomcat.util.threads;
 
 /**
  * A Thread implementation that records the time at which it was created.
- * 
+ *
  */
 public class TaskThread extends Thread {
 

==================================================
ThreadPoolExecutor.java
index 59b87eec87..af63f11860 100644
--- a/java/org/apache/tomcat/util/threads/TaskThreadFactory.java
+++ b/java/org/apache/tomcat/util/threads/TaskThreadFactory.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
