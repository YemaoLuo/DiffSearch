09df57fb62779e99709960d62ff10734525f00f1
==================================================
Fix some immediate Eclipse/Checkstyle issues
==================================================
Mark Emlyn
==================================================
Mon Jan 21 20:28:28 2013 +0000
==================================================
Resolver.java
Fix some immediate Eclipse/Checkstyle issues
- add missing license header
- remove stray author tag
- remove trailing whitespace
- add @Override
- Java 7 <> operator

Still a few to investigate including the deprecation as I removed the class level suppression to look at the individual issues more closely

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1436593 13f79535-47bb-0310-9956-ffa450edef68



==================================================
ResolverImpl.java
index 5da0c6ed2c..97f471a11d 100644
--- a/java/org/apache/catalina/valves/rewrite/Resolver.java
+++ b/java/org/apache/catalina/valves/rewrite/Resolver.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -18,21 +18,19 @@
 package org.apache.catalina.valves.rewrite;
 
 /**
- * Resolver abstract class. 
- * @author Remy Maucherat
+ * Resolver abstract class.
  */
 public abstract class Resolver {
 
     public abstract String resolve(String key);
-    
+
     public String resolveEnv(String key) {
         return System.getProperty(key);
     }
-    
+
     public abstract String resolveSsl(String key);
-    
+
     public abstract String resolveHttp(String key);
 
     public abstract boolean resolveResource(int type, String name);
-
 }

==================================================
RewriteCond.java
index 4acf24a1c7..872a66f76e 100644
--- a/java/org/apache/catalina/valves/rewrite/ResolverImpl.java
+++ b/java/org/apache/catalina/valves/rewrite/ResolverImpl.java
@@ -5,16 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package org.apache.catalina.valves.rewrite;
 
 import java.util.Calendar;
@@ -25,21 +24,21 @@ import org.apache.catalina.connector.Request;
 
 import org.apache.tomcat.util.http.FastHttpDateFormat;
 
-@SuppressWarnings("deprecation")
 public class ResolverImpl extends Resolver {
 
     protected Request request = null;
-    
+
     public ResolverImpl(Request request) {
         this.request = request;
     }
-    
+
     /**
      * The following are not implemented:
      * - SERVER_ADMIN
      * - API_VERSION
      * - IS_SUBREQ
      */
+    @Override
     public String resolve(String key) {
         if (key.equals("HTTP_USER_AGENT")) {
             return request.getHeader("user-agent");
@@ -98,7 +97,7 @@ public class ResolverImpl extends Resolver {
         } else if (key.equals("SERVER_SOFTWARE")) {
             return "tomcat";
         } else if (key.equals("THE_REQUEST")) {
-            return request.getMethod() + " " + request.getRequestURI() 
+            return request.getMethod() + " " + request.getRequestURI()
             + " " + request.getProtocol();
         } else if (key.equals("REQUEST_URI")) {
             return request.getRequestURI();
@@ -126,20 +125,24 @@ public class ResolverImpl extends Resolver {
         return null;
     }
 
+    @Override
     public String resolveEnv(String key) {
         Object result = request.getAttribute(key);
         return (result != null) ? result.toString() : System.getProperty(key);
     }
-    
+
+    @Override
     public String resolveSsl(String key) {
         // FIXME: Implement SSL environment variables
         return null;
     }
 
+    @Override
     public String resolveHttp(String key) {
         return request.getHeader(key);
     }
-    
+
+    @Override
     public boolean resolveResource(int type, String name) {
         WebResourceRoot resources = request.getContext().getResources();
         WebResource resource = resources.getResource(name);
@@ -166,5 +169,4 @@ public class ResolverImpl extends Resolver {
             return value;
         }
     }
-
 }

==================================================
RewriteMap.java
index 3c67e66c86..42fe0d5f05 100644
--- a/java/org/apache/catalina/valves/rewrite/RewriteCond.java
+++ b/java/org/apache/catalina/valves/rewrite/RewriteCond.java
@@ -5,16 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package org.apache.catalina.valves.rewrite;
 
 import java.util.Locale;
@@ -27,10 +26,12 @@ public class RewriteCond {
     public abstract class Condition {
         public abstract boolean evaluate(String value, Resolver resolver);
     }
-    
+
     public class PatternCondition extends Condition {
         public Pattern pattern;
         public Matcher matcher = null;
+
+        @Override
         public boolean evaluate(String value, Resolver resolver) {
             Matcher m = pattern.matcher(value);
             if (m.matches()) {
@@ -41,7 +42,7 @@ public class RewriteCond {
             }
         }
     }
-    
+
     public class LexicalCondition extends Condition {
         /**
          * -1: <
@@ -50,6 +51,8 @@ public class RewriteCond {
          */
         public int type = 0;
         public String condition;
+
+        @Override
         public boolean evaluate(String value, Resolver resolver) {
             int result = value.compareTo(condition);
             switch (type) {
@@ -62,10 +65,10 @@ public class RewriteCond {
             default:
                 return false;
             }
-                
+
         }
     }
-    
+
     public class ResourceCondition extends Condition {
         /**
          * 0: -d (is directory ?)
@@ -73,14 +76,16 @@ public class RewriteCond {
          * 2: -s (is regular file with size ?)
          */
         public int type = 0;
+
+        @Override
         public boolean evaluate(String value, Resolver resolver) {
             return resolver.resolveResource(type, value);
         }
     }
-    
+
     protected String testString = null;
     protected String condPattern = null;
-    
+
     public String getCondPattern() {
         return condPattern;
     }
@@ -135,38 +140,39 @@ public class RewriteCond {
             condition.pattern = Pattern.compile(condPattern, flags);
         }
     }
-    
+
     public Matcher getMatcher() {
         Object condition = this.condition.get();
         if (condition instanceof PatternCondition) {
-            return ((PatternCondition) condition).matcher; 
+            return ((PatternCondition) condition).matcher;
         }
         return null;
     }
-    
+
     /**
      * String representation.
      */
+    @Override
     public String toString() {
         // FIXME: Add flags if possible
         return "RewriteCond " + testString + " " + condPattern;
     }
-    
-    
+
+
     protected boolean positive = true;
-    
+
     protected Substitution test = null;
 
-    protected ThreadLocal<Condition> condition = new ThreadLocal<Condition>();
-    
+    protected ThreadLocal<Condition> condition = new ThreadLocal<>();
+
     /**
-     * This makes the test case-insensitive, i.e., there is no difference between 
-     * 'A-Z' and 'a-z' both in the expanded TestString and the CondPattern. This 
-     * flag is effective only for comparisons between TestString and CondPattern. 
+     * This makes the test case-insensitive, i.e., there is no difference between
+     * 'A-Z' and 'a-z' both in the expanded TestString and the CondPattern. This
+     * flag is effective only for comparisons between TestString and CondPattern.
      * It has no effect on filesystem and subrequest checks.
      */
     public boolean nocase = false;
-    
+
     /**
      * Use this to combine rule conditions with a local OR instead of the implicit AND.
      */
@@ -174,10 +180,9 @@ public class RewriteCond {
 
     /**
      * Evaluate the condition based on the context
-     * 
+     *
      * @param rule corresponding matched rule
      * @param cond last matched condition
-     * @return
      */
     public boolean evaluate(Matcher rule, Matcher cond, Resolver resolver) {
         String value = test.evaluate(rule, cond, resolver);
@@ -230,7 +235,7 @@ public class RewriteCond {
             return !condition.evaluate(value, resolver);
         }
     }
-        
+
     public boolean isNocase() {
         return nocase;
     }
@@ -254,5 +259,4 @@ public class RewriteCond {
     public void setPositive(boolean positive) {
         this.positive = positive;
     }
-
 }

==================================================
RewriteRule.java
index d558c1f4d4..428588caf4 100644
--- a/java/org/apache/catalina/valves/rewrite/RewriteMap.java
+++ b/java/org/apache/catalina/valves/rewrite/RewriteMap.java
@@ -5,22 +5,20 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package org.apache.catalina.valves.rewrite;
 
 public interface RewriteMap {
 
     public String setParameters(String params);
-    
+
     public String lookup(String key);
-    
 }

==================================================
RewriteValve.java
index 4f561102d9..4b92bbf27f 100644
--- a/java/org/apache/catalina/valves/rewrite/RewriteRule.java
+++ b/java/org/apache/catalina/valves/rewrite/RewriteRule.java
@@ -5,16 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package org.apache.catalina.valves.rewrite;
 
 import java.util.ArrayList;
@@ -23,15 +22,15 @@ import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
 public class RewriteRule {
-    
+
     protected RewriteCond[] conditions = new RewriteCond[0];
-    
-    protected ThreadLocal<Pattern> pattern = new ThreadLocal<Pattern>();
+
+    protected ThreadLocal<Pattern> pattern = new ThreadLocal<>();
     protected Substitution substitution = null;
-    
+
     protected String patternString = null;
     protected String substitutionString = null;
-    
+
     public void parse(Map<String, RewriteMap> maps) {
         // Parse the substitution
         if (!"-".equals(substitutionString)) {
@@ -65,7 +64,7 @@ public class RewriteRule {
             cookieSubstitution.parse(maps);
         }
     }
-    
+
     public void addCondition(RewriteCond condition) {
         RewriteCond[] conditions = new RewriteCond[this.conditions.length + 1];
         for (int i = 0; i < this.conditions.length; i++) {
@@ -74,10 +73,10 @@ public class RewriteRule {
         conditions[this.conditions.length] = condition;
         this.conditions = conditions;
     }
-    
+
     /**
      * Evaluate the rule based on the context
-     * 
+     *
      * @return null if no rewrite took place
      */
     public CharSequence evaluate(CharSequence url, Resolver resolver) {
@@ -140,32 +139,33 @@ public class RewriteRule {
         }
     }
 
-    
+
     /**
      * String representation.
      */
+    @Override
     public String toString() {
         // FIXME: Add flags if possible
         return "RewriteRule " + patternString + " " + substitutionString;
     }
-    
-    
+
+
     /**
-     *  This flag chains the current rule with the next rule (which itself 
-     *  can be chained with the following rule, etc.). This has the following 
-     *  effect: if a rule matches, then processing continues as usual, i.e., 
-     *  the flag has no effect. If the rule does not match, then all following 
-     *  chained rules are skipped. For instance, use it to remove the ``.www'' 
-     *  part inside a per-directory rule set when you let an external redirect 
+     *  This flag chains the current rule with the next rule (which itself
+     *  can be chained with the following rule, etc.). This has the following
+     *  effect: if a rule matches, then processing continues as usual, i.e.,
+     *  the flag has no effect. If the rule does not match, then all following
+     *  chained rules are skipped. For instance, use it to remove the ``.www''
+     *  part inside a per-directory rule set when you let an external redirect
      *  happen (where the ``.www'' part should not to occur!).
      */
     protected boolean chain = false;
-    
+
     /**
-     *  This sets a cookie on the client's browser. The cookie's name is 
-     *  specified by NAME and the value is VAL. The domain field is the domain 
-     *  of the cookie, such as '.apache.org',the optional lifetime 
-     *  is the lifetime of the cookie in minutes, and the optional path is the 
+     *  This sets a cookie on the client's browser. The cookie's name is
+     *  specified by NAME and the value is VAL. The domain field is the domain
+     *  of the cookie, such as '.apache.org',the optional lifetime
+     *  is the lifetime of the cookie in minutes, and the optional path is the
      *  path of the cookie
      */
     protected boolean cookie = false;
@@ -177,100 +177,100 @@ public class RewriteRule {
     protected boolean cookieSecure = false;
     protected boolean cookieHttpOnly = false;
     protected Substitution cookieSubstitution = null;
-    protected ThreadLocal<String> cookieResult = new ThreadLocal<String>();
-    
+    protected ThreadLocal<String> cookieResult = new ThreadLocal<>();
+
     /**
-     *  This forces a request attribute named VAR to be set to the value VAL, 
-     *  where VAL can contain regexp back references $N and %N which will be 
+     *  This forces a request attribute named VAR to be set to the value VAL,
+     *  where VAL can contain regexp back references $N and %N which will be
      *  expanded. Multiple env flags are allowed.
      */
     protected boolean env = false;
-    protected ArrayList<String> envName = new ArrayList<String>();
-    protected ArrayList<String> envValue = new ArrayList<String>();
-    protected ArrayList<Substitution> envSubstitution = new ArrayList<Substitution>();
-    protected ArrayList<ThreadLocal<String>> envResult = new ArrayList<ThreadLocal<String>>();
-    
+    protected ArrayList<String> envName = new ArrayList<>();
+    protected ArrayList<String> envValue = new ArrayList<>();
+    protected ArrayList<Substitution> envSubstitution = new ArrayList<>();
+    protected ArrayList<ThreadLocal<String>> envResult = new ArrayList<>();
+
     /**
-     *  This forces the current URL to be forbidden, i.e., it immediately sends 
-     *  back a HTTP response of 403 (FORBIDDEN). Use this flag in conjunction 
+     *  This forces the current URL to be forbidden, i.e., it immediately sends
+     *  back a HTTP response of 403 (FORBIDDEN). Use this flag in conjunction
      *  with appropriate RewriteConds to conditionally block some URLs.
      */
     protected boolean forbidden = false;
-    
+
     /**
-     *  This forces the current URL to be gone, i.e., it immediately sends 
-     *  back a HTTP response of 410 (GONE). Use this flag to mark pages which 
+     *  This forces the current URL to be gone, i.e., it immediately sends
+     *  back a HTTP response of 410 (GONE). Use this flag to mark pages which
      *  no longer exist as gone.
      */
     protected boolean gone = false;
-    
+
     /**
      * Host. This means this rule and its associated conditions will apply to
      * host, allowing host rewriting (ex: redirecting internally *.foo.com to
      * bar.foo.com).
      */
-    protected boolean host = false; 
-    
+    protected boolean host = false;
+
     /**
-     *  Stop the rewriting process here and don't apply any more rewriting 
-     *  rules. This corresponds to the Perl last command or the break command 
-     *  from the C language. Use this flag to prevent the currently rewritten 
-     *  URL from being rewritten further by following rules. For example, use 
+     *  Stop the rewriting process here and don't apply any more rewriting
+     *  rules. This corresponds to the Perl last command or the break command
+     *  from the C language. Use this flag to prevent the currently rewritten
+     *  URL from being rewritten further by following rules. For example, use
      *  it to rewrite the root-path URL ('/') to a real one, e.g., '/e/www/'.
      */
     protected boolean last = false;
-    
+
     /**
-     *  Re-run the rewriting process (starting again with the first rewriting 
-     *  rule). Here the URL to match is again not the original URL but the URL 
-     *  from the last rewriting rule. This corresponds to the Perl next 
-     *  command or the continue command from the C language. Use this flag to 
-     *  restart the rewriting process, i.e., to immediately go to the top of 
+     *  Re-run the rewriting process (starting again with the first rewriting
+     *  rule). Here the URL to match is again not the original URL but the URL
+     *  from the last rewriting rule. This corresponds to the Perl next
+     *  command or the continue command from the C language. Use this flag to
+     *  restart the rewriting process, i.e., to immediately go to the top of
      *  the loop. But be careful not to create an infinite loop!
      */
     protected boolean next = false;
-    
+
     /**
-     *  This makes the Pattern case-insensitive, i.e., there is no difference 
-     *  between 'A-Z' and 'a-z' when Pattern is matched against the current 
+     *  This makes the Pattern case-insensitive, i.e., there is no difference
+     *  between 'A-Z' and 'a-z' when Pattern is matched against the current
      *  URL.
      */
     protected boolean nocase = false;
-    
+
     /**
-     *  This flag keeps mod_rewrite from applying the usual URI escaping rules 
-     *  to the result of a rewrite. Ordinarily, special characters (such as 
-     *  '%', '$', ';', and so on) will be escaped into their hexcode 
-     *  equivalents ('%25', '%24', and '%3B', respectively); this flag 
-     *  prevents this from being done. This allows percent symbols to appear 
-     *  in the output, as in 
-     *    RewriteRule /foo/(.*) /bar?arg=P1\%3d$1 [R,NE] 
+     *  This flag keeps mod_rewrite from applying the usual URI escaping rules
+     *  to the result of a rewrite. Ordinarily, special characters (such as
+     *  '%', '$', ';', and so on) will be escaped into their hexcode
+     *  equivalents ('%25', '%24', and '%3B', respectively); this flag
+     *  prevents this from being done. This allows percent symbols to appear
+     *  in the output, as in
+     *    RewriteRule /foo/(.*) /bar?arg=P1\%3d$1 [R,NE]
      *    which would turn '/foo/zed' into a safe request for '/bar?arg=P1=zed'.
      */
     protected boolean noescape = false;
-    
+
     /**
-     *  This flag forces the rewriting engine to skip a rewriting rule if the 
-     *  current request is an internal sub-request. For instance, sub-requests 
-     *  occur internally in Apache when mod_include tries to find out 
-     *  information about possible directory default files (index.xxx). On 
-     *  sub-requests it is not always useful and even sometimes causes a 
-     *  failure to if the complete set of rules are applied. Use this flag to 
-     *  exclude some rules. Use the following rule for your decision: whenever 
-     *  you prefix some URLs with CGI-scripts to force them to be processed by 
-     *  the CGI-script, the chance is high that you will run into problems (or 
+     *  This flag forces the rewriting engine to skip a rewriting rule if the
+     *  current request is an internal sub-request. For instance, sub-requests
+     *  occur internally in Apache when mod_include tries to find out
+     *  information about possible directory default files (index.xxx). On
+     *  sub-requests it is not always useful and even sometimes causes a
+     *  failure to if the complete set of rules are applied. Use this flag to
+     *  exclude some rules. Use the following rule for your decision: whenever
+     *  you prefix some URLs with CGI-scripts to force them to be processed by
+     *  the CGI-script, the chance is high that you will run into problems (or
      *  even overhead) on sub-requests. In these cases, use this flag.
      */
     protected boolean nosubreq = false;
-    
+
     /**
-     *  This flag forces the substitution part to be internally forced as a proxy 
-     *  request and immediately (i.e., rewriting rule processing stops here) put 
-     *  through the proxy module. You have to make sure that the substitution string 
-     *  is a valid URI (e.g., typically starting with http://hostname) which can be 
-     *  handled by the Apache proxy module. If not you get an error from the proxy 
-     *  module. Use this flag to achieve a more powerful implementation of the 
-     *  ProxyPass directive, to map some remote stuff into the namespace of 
+     *  This flag forces the substitution part to be internally forced as a proxy
+     *  request and immediately (i.e., rewriting rule processing stops here) put
+     *  through the proxy module. You have to make sure that the substitution string
+     *  is a valid URI (e.g., typically starting with http://hostname) which can be
+     *  handled by the Apache proxy module. If not you get an error from the proxy
+     *  module. Use this flag to achieve a more powerful implementation of the
+     *  ProxyPass directive, to map some remote stuff into the namespace of
      *  the local server.
      *  Note: No proxy
      */
@@ -278,49 +278,49 @@ public class RewriteRule {
     /**
      * Note: No passthrough
      */
-    
+
     /**
-     *  This flag forces the rewriting engine to append a query string part in 
-     *  the substitution string to the existing one instead of replacing it. 
-     *  Use this when you want to add more data to the query string via 
+     *  This flag forces the rewriting engine to append a query string part in
+     *  the substitution string to the existing one instead of replacing it.
+     *  Use this when you want to add more data to the query string via
      *  a rewrite rule.
      */
-    protected boolean qsappend = false; 
-    
+    protected boolean qsappend = false;
+
     /**
-     *  Prefix Substitution with http://thishost[:thisport]/ (which makes the 
-     *  new URL a URI) to force a external redirection. If no code is given 
-     *  a HTTP response of 302 (MOVED TEMPORARILY) is used. If you want to 
-     *  use other response codes in the range 300-400 just specify them as 
-     *  a number or use one of the following symbolic names: temp (default), 
-     *  permanent, seeother. Use it for rules which should canonicalize the 
-     *  URL and give it back to the client, e.g., translate ``/~'' into ``/u/'' 
-     *  or always append a slash to /u/user, etc. Note: When you use this flag, 
-     *  make sure that the substitution field is a valid URL! If not, you are 
-     *  redirecting to an invalid location! And remember that this flag itself 
-     *  only prefixes the URL with http://thishost[:thisport]/, rewriting 
-     *  continues. Usually you also want to stop and do the redirection 
-     *  immediately. To stop the rewriting you also have to provide the 
+     *  Prefix Substitution with http://thishost[:thisport]/ (which makes the
+     *  new URL a URI) to force a external redirection. If no code is given
+     *  a HTTP response of 302 (MOVED TEMPORARILY) is used. If you want to
+     *  use other response codes in the range 300-400 just specify them as
+     *  a number or use one of the following symbolic names: temp (default),
+     *  permanent, seeother. Use it for rules which should canonicalize the
+     *  URL and give it back to the client, e.g., translate ``/~'' into ``/u/''
+     *  or always append a slash to /u/user, etc. Note: When you use this flag,
+     *  make sure that the substitution field is a valid URL! If not, you are
+     *  redirecting to an invalid location! And remember that this flag itself
+     *  only prefixes the URL with http://thishost[:thisport]/, rewriting
+     *  continues. Usually you also want to stop and do the redirection
+     *  immediately. To stop the rewriting you also have to provide the
      *  'L' flag.
      */
     protected boolean redirect = false;
     protected int redirectCode = 0;
-    
+
     /**
-     *  This flag forces the rewriting engine to skip the next num rules in 
-     *  sequence when the current rule matches. Use this to make pseudo 
-     *  if-then-else constructs: The last rule of the then-clause becomes 
-     *  skip=N where N is the number of rules in the else-clause. 
+     *  This flag forces the rewriting engine to skip the next num rules in
+     *  sequence when the current rule matches. Use this to make pseudo
+     *  if-then-else constructs: The last rule of the then-clause becomes
+     *  skip=N where N is the number of rules in the else-clause.
      *  (This is not the same as the 'chain|C' flag!)
      */
     protected int skip = 0;
-    
+
     /**
-     *  Force the MIME-type of the target file to be MIME-type. For instance, 
-     *  this can be used to setup the content-type based on some conditions. 
-     *  For example, the following snippet allows .php files to be displayed 
-     *  by mod_php if they are called with the .phps extension: 
-     *  RewriteRule ^(.+\.php)s$ $1 [T=application/x-httpd-php-source] 
+     *  Force the MIME-type of the target file to be MIME-type. For instance,
+     *  this can be used to setup the content-type based on some conditions.
+     *  For example, the following snippet allows .php files to be displayed
+     *  by mod_php if they are called with the .phps extension:
+     *  RewriteRule ^(.+\.php)s$ $1 [T=application/x-httpd-php-source]
      */
     protected boolean type = false;
     protected String typeValue = null;
@@ -529,5 +529,4 @@ public class RewriteRule {
     public void setCookieHttpOnly(boolean cookieHttpOnly) {
         this.cookieHttpOnly = cookieHttpOnly;
     }
-    
 }

==================================================
Substitution.java
index 82bb3ed2c3..44aca7bffa 100644
--- a/java/org/apache/catalina/valves/rewrite/RewriteValve.java
+++ b/java/org/apache/catalina/valves/rewrite/RewriteValve.java
@@ -5,16 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package org.apache.catalina.valves.rewrite;
 
 import java.io.BufferedReader;
@@ -50,27 +49,26 @@ import org.apache.tomcat.util.buf.CharChunk;
 import org.apache.tomcat.util.buf.MessageBytes;
 import org.apache.tomcat.util.net.URL;
 
-public class RewriteValve extends ValveBase
-    implements Lifecycle {
+public class RewriteValve extends ValveBase {
 
     /**
      * The lifecycle event support for this component.
      */
     protected LifecycleSupport lifecycle = new LifecycleSupport(this);
 
-    
+
     /**
      * The rewrite rules that the valve will use.
      */
     protected RewriteRule[] rules = null;
-    
-    
+
+
     /**
      * If rewriting occurs, the whole request will be processed again.
      */
-    protected ThreadLocal<Boolean> invoked = new ThreadLocal<Boolean>();
-    
-    
+    protected ThreadLocal<Boolean> invoked = new ThreadLocal<>();
+
+
     /**
      * Relative path to the configuration file.
      * Note: If the valve's container is a context, this will be relative to
@@ -78,13 +76,13 @@ public class RewriteValve extends ValveBase
      */
     protected String resourcePath = "rewrite.config";
 
-    
+
     /**
      * Will be set to true if the valve is associated with a context.
      */
     protected boolean context = false;
-    
-    
+
+
     /**
      * enabled this component
      */
@@ -93,9 +91,9 @@ public class RewriteValve extends ValveBase
     /**
      * Maps to be used by the rules.
      */
-    protected Map<String, RewriteMap> maps = new Hashtable<String, RewriteMap>();
-    
-    
+    protected Map<String, RewriteMap> maps = new Hashtable<>();
+
+
     public boolean getEnabled() {
         return enabled;
     }
@@ -104,18 +102,22 @@ public class RewriteValve extends ValveBase
         this.enabled = enabled;
     }
 
+    @Override
     public void addLifecycleListener(LifecycleListener listener) {
         lifecycle.addLifecycleListener(listener);
     }
 
+    @Override
     public LifecycleListener[] findLifecycleListeners() {
         return lifecycle.findLifecycleListeners();
     }
 
+    @Override
     public void removeLifecycleListener(LifecycleListener listener) {
         lifecycle.removeLifecycleListener(listener);
     }
 
+    @Override
     protected synchronized void startInternal() throws LifecycleException {
 
         super.startInternal();
@@ -154,19 +156,19 @@ public class RewriteValve extends ValveBase
                     is = new FileInputStream(file);
                 }
                 if ((is == null) && (container.getLogger().isDebugEnabled())) {
-                    container.getLogger().debug("No configuration resource found: " + resourceName + 
+                    container.getLogger().debug("No configuration resource found: " + resourceName +
                             " in " + getConfigBase() + " or in the classloader");
                 }
             } catch (Exception e) {
                 container.getLogger().error("Error opening configuration", e);
             }
         }
-        
+
         if (is == null) {
             // Will use management operations to configure the valve dynamically
             return;
         }
-        
+
         BufferedReader reader = new BufferedReader(new InputStreamReader(is, B2CConverter.UTF_8));
 
         try {
@@ -193,7 +195,7 @@ public class RewriteValve extends ValveBase
         maps.clear();
         parse(new BufferedReader(new StringReader(configuration)));
     }
-    
+
     public String getConfiguration() {
         StringBuffer buffer = new StringBuffer();
         // FIXME: Output maps if possible
@@ -205,10 +207,10 @@ public class RewriteValve extends ValveBase
         }
         return buffer.toString();
     }
-    
+
     protected void parse(BufferedReader reader) throws LifecycleException {
-        ArrayList<RewriteRule> rules = new ArrayList<RewriteRule>();
-        ArrayList<RewriteCond> conditions = new ArrayList<RewriteCond>();
+        ArrayList<RewriteRule> rules = new ArrayList<>();
+        ArrayList<RewriteCond> conditions = new ArrayList<>();
         while (true) {
             try {
                 String line = reader.readLine();
@@ -230,9 +232,9 @@ public class RewriteValve extends ValveBase
                     for (int i = 0; i < conditions.size(); i++) {
                         if (container.getLogger().isDebugEnabled()) {
                             RewriteCond cond = conditions.get(i);
-                            container.getLogger().debug("Add condition " + cond.getCondPattern() 
-                                    + " test " + cond.getTestString() + " to rule with pattern " 
-                                    + rule.getPatternString() + " and substitution " 
+                            container.getLogger().debug("Add condition " + cond.getCondPattern()
+                                    + " test " + cond.getTestString() + " to rule with pattern "
+                                    + rule.getPatternString() + " and substitution "
                                     + rule.getSubstitutionString() + (cond.isOrnext() ? " [OR]" : "")
                                     + (cond.isNocase() ? " [NC]" : ""));
                         }
@@ -254,14 +256,15 @@ public class RewriteValve extends ValveBase
                 container.getLogger().error("Error reading configuration", e);
             }
         }
-        this.rules = (RewriteRule[]) rules.toArray(new RewriteRule[0]);
-        
+        this.rules = rules.toArray(new RewriteRule[0]);
+
         // Finish parsing the rules
         for (int i = 0; i < this.rules.length; i++) {
             this.rules[i].parse(maps);
         }
     }
 
+    @Override
     protected synchronized void stopInternal() throws LifecycleException {
         super.stopInternal();
         Iterator<RewriteMap> values = maps.values().iterator();
@@ -276,6 +279,7 @@ public class RewriteValve extends ValveBase
     }
 
 
+    @Override
     public void invoke(Request request, Response response)
         throws IOException, ServletException {
 
@@ -283,7 +287,7 @@ public class RewriteValve extends ValveBase
             getNext().invoke(request, response);
             return;
         }
-        
+
         if (invoked.get() == Boolean.TRUE) {
             try {
                 getNext().invoke(request, response);
@@ -292,7 +296,7 @@ public class RewriteValve extends ValveBase
             }
             return;
         }
-        
+
         try {
 
             Resolver resolver = new ResolverImpl(request);
@@ -378,7 +382,7 @@ public class RewriteValve extends ValveBase
 
                 // - cookie
                 if (rule.isCookie() && newtest != null) {
-                    Cookie cookie = new Cookie(rule.getCookieName(), 
+                    Cookie cookie = new Cookie(rule.getCookieName(),
                             rule.getCookieResult());
                     cookie.setDomain(rule.getCookieDomain());
                     cookie.setMaxAge(rule.getCookieLifetime());
@@ -485,28 +489,28 @@ public class RewriteValve extends ValveBase
         } finally {
             invoked.set(null);
         }
-        
+
     }
-    
-    
+
+
     /**
      * Get config base.
      */
     protected File getConfigBase() {
-        File configBase = 
+        File configBase =
             new File(System.getProperty("catalina.base"), "conf");
         if (!configBase.exists()) {
             return null;
         } else {
             return configBase;
         }
-    }  
+    }
+
 
-    
     /**
      * Find the configuration path where the rewrite configuration file
      * will be stored.
-     * 
+     *
      * @param resourceName
      * @return
      */
@@ -532,15 +536,14 @@ public class RewriteValve extends ValveBase
         return result.toString();
     }
 
-    
+
     /**
      * This factory method will parse a line formed like:
-     *  
+     *
      * Example:
      *  RewriteCond %{REMOTE_HOST}  ^host1.*  [OR]
-     * 
+     *
      * @param line
-     * @return
      */
     public static Object parse(String line) {
         StringTokenizer tokenizer = new StringTokenizer(line);
@@ -591,7 +594,7 @@ public class RewriteValve extends ValveBase
                 }
                 String name = tokenizer.nextToken();
                 String rewriteMapClassName = tokenizer.nextToken();
-                RewriteMap map = null; 
+                RewriteMap map = null;
                 try {
                     map = (RewriteMap) (Class.forName(rewriteMapClassName).newInstance());
                 } catch (Exception e) {
@@ -612,11 +615,11 @@ public class RewriteValve extends ValveBase
         }
         return null;
     }
-    
-    
+
+
     /**
      * Parser for RewriteCond flags.
-     * 
+     *
      * @param condition
      * @param flag
      */
@@ -629,11 +632,11 @@ public class RewriteValve extends ValveBase
             throw new IllegalArgumentException("Invalid flag in: " + line + " flags: " + flag);
         }
     }
-    
-    
+
+
     /**
      * Parser for ReweriteRule flags.
-     * 
+     *
      * @param rule
      * @param flag
      */
@@ -736,7 +739,7 @@ public class RewriteValve extends ValveBase
             throw new IllegalArgumentException("Invalid flag in: " + line + " flag: " + flag);
         }
     }
-    
+
 
     /**
      * Determine if a URI string has a <code>scheme</code> component.
@@ -753,5 +756,4 @@ public class RewriteValve extends ValveBase
         }
         return false;
     }
-
 }

==================================================
