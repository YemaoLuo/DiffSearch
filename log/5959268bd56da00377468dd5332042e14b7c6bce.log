5959268bd56da00377468dd5332042e14b7c6bce
==================================================
- Remove pre 1.5 compatibility code, which is not used anymore as the new APIs require and use 
==================================================
Remy Maucherat
==================================================
Fri Apr 21 11:04:05 2006 +0000
==================================================
Response.java
- Remove pre 1.5 compatibility code, which is not used anymore as the new APIs require and use 
  JDK 1.5+. I hope I didn't make any mistake merging the SSL code.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/tc6.0.x/trunk@395849 13f79535-47bb-0310-9956-ffa450edef68



==================================================
StandardContext.java
index 167ef0d948..bab272970a 100644
--- a/java/org/apache/catalina/connector/Response.java
+++ b/java/org/apache/catalina/connector/Response.java
@@ -40,17 +40,16 @@ import javax.servlet.http.HttpServletResponse;
 import org.apache.catalina.Context;
 import org.apache.catalina.Session;
 import org.apache.catalina.Wrapper;
+import org.apache.catalina.security.SecurityUtil;
 import org.apache.catalina.util.CharsetMapper;
 import org.apache.catalina.util.DateTool;
 import org.apache.catalina.util.StringManager;
-import org.apache.catalina.security.SecurityUtil;
 import org.apache.tomcat.util.buf.CharChunk;
 import org.apache.tomcat.util.buf.UEncoder;
 import org.apache.tomcat.util.http.FastHttpDateFormat;
 import org.apache.tomcat.util.http.MimeHeaders;
 import org.apache.tomcat.util.http.ServerCookie;
 import org.apache.tomcat.util.net.URL;
-import org.apache.tomcat.util.compat.JdkCompat;
 
 /**
  * Wrapper object for the Coyote response.
@@ -79,12 +78,6 @@ public class Response
     // ----------------------------------------------------- Class Variables
 
 
-    /**
-     * JDK compatibility support
-     */
-    private static final JdkCompat jdkCompat = JdkCompat.getJdkCompat();
-
-
     /**
      * Descriptive information about this Response implementation.
      */
@@ -1477,7 +1470,7 @@ public class Response
                         } catch (PrivilegedActionException pae){
                             IllegalArgumentException iae =
                                 new IllegalArgumentException(location);
-                            jdkCompat.chainException(iae, pae.getException());
+                            iae.initCause(pae.getException());
                             throw iae;
                         }
                     } else {
@@ -1490,7 +1483,7 @@ public class Response
             } catch (IOException e) {
                 IllegalArgumentException iae =
                     new IllegalArgumentException(location);
-                jdkCompat.chainException(iae, e);
+                iae.initCause(e);
                 throw iae;
             }
 

==================================================
WebappClassLoader.java
index c487ddcadd..30f74d9246 100644
--- a/java/org/apache/catalina/core/StandardContext.java
+++ b/java/org/apache/catalina/core/StandardContext.java
@@ -97,7 +97,6 @@ import org.apache.naming.resources.DirContextURLStreamHandler;
 import org.apache.naming.resources.FileDirContext;
 import org.apache.naming.resources.ProxyDirContext;
 import org.apache.naming.resources.WARDirContext;
-import org.apache.tomcat.util.compat.JdkCompat;
 import org.apache.tomcat.util.modeler.Registry;
 
 /**
@@ -142,12 +141,6 @@ public class StandardContext
         "org.apache.catalina.core.StandardContext/1.0";
 
 
-    /**
-     * JDK compatibility support
-     */
-    private static final JdkCompat jdkCompat = JdkCompat.getJdkCompat();
-
-
     /**
      * Array containing the safe characters set.
      */

==================================================
DefaultContextMBean.java
index 2f24552961..e4b52da0b6 100644
--- a/java/org/apache/catalina/loader/WebappClassLoader.java
+++ b/java/org/apache/catalina/loader/WebappClassLoader.java
@@ -62,7 +62,6 @@ import org.apache.naming.JndiPermission;
 import org.apache.naming.resources.Resource;
 import org.apache.naming.resources.ResourceAttributes;
 import org.apache.tomcat.util.IntrospectionUtils;
-import org.apache.tomcat.util.compat.JdkCompat;
 
 /**
  * Specialized web application class loader.
@@ -142,11 +141,6 @@ public class WebappClassLoader
         "javax.servlet.Servlet"                     // Servlet API
     };
 
-    /** 
-     * Jdk Compatibility Support.
-     */
-    protected static JdkCompat jdkCompat = JdkCompat.getJdkCompat();
-
     /**
      * Set of package names which are not allowed to be loaded from a webapp
      * class loader without delegating first.
@@ -548,7 +542,7 @@ public class WebappClassLoader
         } catch (MalformedURLException e) {
             IllegalArgumentException iae = new IllegalArgumentException
                 ("Invalid repository: " + repository); 
-            jdkCompat.chainException(iae, e);
+            iae.initCause(e);
             throw iae;
         }
 
@@ -2300,7 +2294,14 @@ public class WebappClassLoader
     protected URL getURI(File file)
         throws MalformedURLException {
 
-        return jdkCompat.getURI(file);
+        File realFile = file;
+        try {
+            realFile = realFile.getCanonicalFile();
+        } catch (IOException e) {
+            // Ignore
+        }
+
+        return realFile.toURI().toURL();
 
     }
 

==================================================
GroupMBean.java
index 767c526649..8743b4bed3 100644
--- a/java/org/apache/catalina/mbeans/DefaultContextMBean.java
+++ b/java/org/apache/catalina/mbeans/DefaultContextMBean.java
@@ -28,7 +28,6 @@ import org.apache.catalina.deploy.ContextEnvironment;
 import org.apache.catalina.deploy.ContextResource;
 import org.apache.catalina.deploy.ContextResourceLink;
 import org.apache.catalina.deploy.NamingResources;
-import org.apache.tomcat.util.compat.JdkCompat;
 import org.apache.tomcat.util.modeler.BaseModelMBean;
 import org.apache.tomcat.util.modeler.ManagedBean;
 import org.apache.tomcat.util.modeler.Registry;
@@ -64,15 +63,6 @@ public class DefaultContextMBean extends BaseModelMBean {
     }
     
 
-    // ----------------------------------------------------- Class Variables
-
-
-    /**
-     * JDK compatibility support
-     */
-    private static final JdkCompat jdkCompat = JdkCompat.getJdkCompat();
-
-
     // ----------------------------------------------------- Instance Variables
     
     
@@ -116,7 +106,7 @@ public class DefaultContextMBean extends BaseModelMBean {
             } catch (MalformedObjectNameException e) {
                 IllegalArgumentException iae = new IllegalArgumentException
                     ("Cannot create object name for environment " + envs[i]);
-                jdkCompat.chainException(iae, e);
+                iae.initCause(e);
                 throw iae;
             }
         }
@@ -141,7 +131,7 @@ public class DefaultContextMBean extends BaseModelMBean {
             } catch (MalformedObjectNameException e) {
                 IllegalArgumentException iae = new IllegalArgumentException
                     ("Cannot create object name for resource " + resources[i]);
-                jdkCompat.chainException(iae, e);
+                iae.initCause(e);
                 throw iae;
             }
         }
@@ -166,7 +156,7 @@ public class DefaultContextMBean extends BaseModelMBean {
             } catch (MalformedObjectNameException e) {
                 IllegalArgumentException iae = new IllegalArgumentException
                     ("Cannot create object name for resource " + links[i]);
-                jdkCompat.chainException(iae, e);
+                iae.initCause(e);
                 throw iae;
             }
         }

==================================================
MemoryUserDatabaseMBean.java
index 15b28efeec..1697171f73 100644
--- a/java/org/apache/catalina/mbeans/GroupMBean.java
+++ b/java/org/apache/catalina/mbeans/GroupMBean.java
@@ -29,7 +29,6 @@ import javax.management.RuntimeOperationsException;
 import org.apache.catalina.Group;
 import org.apache.catalina.Role;
 import org.apache.catalina.User;
-import org.apache.tomcat.util.compat.JdkCompat;
 import org.apache.tomcat.util.modeler.BaseModelMBean;
 import org.apache.tomcat.util.modeler.ManagedBean;
 import org.apache.tomcat.util.modeler.Registry;
@@ -65,15 +64,6 @@ public class GroupMBean extends BaseModelMBean {
     }
 
 
-    // ----------------------------------------------------- Class Variables
-
-
-    /**
-     * JDK compatibility support
-     */
-    private static final JdkCompat jdkCompat = JdkCompat.getJdkCompat();
-
-
     // ----------------------------------------------------- Instance Variables
 
 
@@ -117,7 +107,7 @@ public class GroupMBean extends BaseModelMBean {
             } catch (MalformedObjectNameException e) {
                 IllegalArgumentException iae = new IllegalArgumentException
                     ("Cannot create object name for role " + role);
-                jdkCompat.chainException(iae, e);
+                iae.initCause(e);
                 throw iae;
             }
         }
@@ -144,7 +134,7 @@ public class GroupMBean extends BaseModelMBean {
             } catch (MalformedObjectNameException e) {
                 IllegalArgumentException iae = new IllegalArgumentException
                     ("Cannot create object name for user " + user);
-                jdkCompat.chainException(iae, e);
+                iae.initCause(e);
                 throw iae;
             }
         }

==================================================
NamingResourcesMBean.java
index ce2ab05011..c4a2e1a678 100644
--- a/java/org/apache/catalina/mbeans/MemoryUserDatabaseMBean.java
+++ b/java/org/apache/catalina/mbeans/MemoryUserDatabaseMBean.java
@@ -19,16 +19,17 @@ package org.apache.catalina.mbeans;
 
 import java.util.ArrayList;
 import java.util.Iterator;
-import javax.management.MalformedObjectNameException;
+
 import javax.management.MBeanException;
 import javax.management.MBeanServer;
+import javax.management.MalformedObjectNameException;
 import javax.management.ObjectName;
 import javax.management.RuntimeOperationsException;
+
 import org.apache.catalina.Group;
 import org.apache.catalina.Role;
 import org.apache.catalina.User;
 import org.apache.catalina.UserDatabase;
-import org.apache.tomcat.util.compat.JdkCompat;
 import org.apache.tomcat.util.modeler.BaseModelMBean;
 import org.apache.tomcat.util.modeler.ManagedBean;
 import org.apache.tomcat.util.modeler.Registry;
@@ -64,15 +65,6 @@ public class MemoryUserDatabaseMBean extends BaseModelMBean {
     }
 
 
-    // ----------------------------------------------------- Class Variables
-
-
-    /**
-     * JDK compatibility support
-     */
-    private static final JdkCompat jdkCompat = JdkCompat.getJdkCompat();
-
-
     // ----------------------------------------------------- Instance Variables
 
 
@@ -188,7 +180,7 @@ public class MemoryUserDatabaseMBean extends BaseModelMBean {
         } catch (Exception e) {
             IllegalArgumentException iae = new IllegalArgumentException
                 ("Exception creating group " + group + " MBean");
-            jdkCompat.chainException(iae, e);
+            iae.initCause(e);
             throw iae;
         }
         return (findGroup(groupname));
@@ -211,7 +203,7 @@ public class MemoryUserDatabaseMBean extends BaseModelMBean {
         } catch (Exception e) {
             IllegalArgumentException iae = new IllegalArgumentException
                 ("Exception creating role " + role + " MBean");
-            jdkCompat.chainException(iae, e);
+            iae.initCause(e);
             throw iae;
         }
         return (findRole(rolename));
@@ -236,7 +228,7 @@ public class MemoryUserDatabaseMBean extends BaseModelMBean {
         } catch (Exception e) {
             IllegalArgumentException iae = new IllegalArgumentException
                 ("Exception creating user " + user + " MBean");
-            jdkCompat.chainException(iae, e);
+            iae.initCause(e);
             throw iae;
         }
         return (findUser(username));
@@ -264,7 +256,7 @@ public class MemoryUserDatabaseMBean extends BaseModelMBean {
         } catch (MalformedObjectNameException e) {
             IllegalArgumentException iae = new IllegalArgumentException
                 ("Cannot create object name for group " + group);
-            jdkCompat.chainException(iae, e);
+            iae.initCause(e);
             throw iae;
         }
 
@@ -291,7 +283,7 @@ public class MemoryUserDatabaseMBean extends BaseModelMBean {
         } catch (MalformedObjectNameException e) {
             IllegalArgumentException iae = new IllegalArgumentException
                 ("Cannot create object name for role " + role);
-            jdkCompat.chainException(iae, e);
+            iae.initCause(e);
             throw iae;
         }
 
@@ -318,7 +310,7 @@ public class MemoryUserDatabaseMBean extends BaseModelMBean {
         } catch (MalformedObjectNameException e) {
             IllegalArgumentException iae = new IllegalArgumentException
                 ("Cannot create object name for user " + user);
-            jdkCompat.chainException(iae, e);
+            iae.initCause(e);
             throw iae;
         }
 
@@ -343,7 +335,7 @@ public class MemoryUserDatabaseMBean extends BaseModelMBean {
         } catch (Exception e) {
             IllegalArgumentException iae = new IllegalArgumentException
                 ("Exception destroying group " + group + " MBean");
-            jdkCompat.chainException(iae, e);
+            iae.initCause(e);
             throw iae;
         }
 
@@ -368,7 +360,7 @@ public class MemoryUserDatabaseMBean extends BaseModelMBean {
         } catch (Exception e) {
             IllegalArgumentException iae = new IllegalArgumentException
                 ("Exception destroying role " + role + " MBean");
-            jdkCompat.chainException(iae, e);
+            iae.initCause(e);
             throw iae;
         }
 
@@ -393,7 +385,7 @@ public class MemoryUserDatabaseMBean extends BaseModelMBean {
         } catch (Exception e) {
             IllegalArgumentException iae = new IllegalArgumentException
                 ("Exception destroying user " + user + " MBean");
-            jdkCompat.chainException(iae, e);
+            iae.initCause(e);
             throw iae;
         }
 

==================================================
StandardContextMBean.java
index 2020509669..7a3bb10c83 100644
--- a/java/org/apache/catalina/mbeans/NamingResourcesMBean.java
+++ b/java/org/apache/catalina/mbeans/NamingResourcesMBean.java
@@ -27,7 +27,6 @@ import org.apache.catalina.deploy.ContextEnvironment;
 import org.apache.catalina.deploy.ContextResource;
 import org.apache.catalina.deploy.ContextResourceLink;
 import org.apache.catalina.deploy.NamingResources;
-import org.apache.tomcat.util.compat.JdkCompat;
 import org.apache.tomcat.util.modeler.BaseModelMBean;
 import org.apache.tomcat.util.modeler.ManagedBean;
 import org.apache.tomcat.util.modeler.Registry;
@@ -63,15 +62,6 @@ public class NamingResourcesMBean extends BaseModelMBean {
     }
 
 
-    // ----------------------------------------------------- Class Variables
-
-
-    /**
-     * JDK compatibility support
-     */
-    private static final JdkCompat jdkCompat = JdkCompat.getJdkCompat();
-
-
     // ----------------------------------------------------- Instance Variables
     
     /**
@@ -105,7 +95,7 @@ public class NamingResourcesMBean extends BaseModelMBean {
             } catch (MalformedObjectNameException e) {
                 IllegalArgumentException iae = new IllegalArgumentException
                     ("Cannot create object name for environment " + envs[i]);
-                jdkCompat.chainException(iae, e);
+                iae.initCause(e);
                 throw iae;
             }
         }
@@ -131,7 +121,7 @@ public class NamingResourcesMBean extends BaseModelMBean {
             } catch (MalformedObjectNameException e) {
                 IllegalArgumentException iae = new IllegalArgumentException
                     ("Cannot create object name for resource " + resources[i]);
-                jdkCompat.chainException(iae, e);
+                iae.initCause(e);
                 throw iae;
             }
         }
@@ -157,7 +147,7 @@ public class NamingResourcesMBean extends BaseModelMBean {
             } catch (MalformedObjectNameException e) {
                 IllegalArgumentException iae = new IllegalArgumentException
                     ("Cannot create object name for resource " + resourceLinks[i]);
-                jdkCompat.chainException(iae, e);
+                iae.initCause(e);
                 throw iae;
             }
         }

==================================================
UserMBean.java
index a4c414709f..adbedc114e 100644
--- a/java/org/apache/catalina/mbeans/StandardContextMBean.java
+++ b/java/org/apache/catalina/mbeans/StandardContextMBean.java
@@ -28,7 +28,6 @@ import org.apache.catalina.deploy.ContextEnvironment;
 import org.apache.catalina.deploy.ContextResource;
 import org.apache.catalina.deploy.ContextResourceLink;
 import org.apache.catalina.deploy.NamingResources;
-import org.apache.tomcat.util.compat.JdkCompat;
 import org.apache.tomcat.util.modeler.BaseModelMBean;
 import org.apache.tomcat.util.modeler.ManagedBean;
 import org.apache.tomcat.util.modeler.Registry;
@@ -64,15 +63,6 @@ public class StandardContextMBean extends BaseModelMBean {
     }
     
 
-    // ----------------------------------------------------- Class Variables
-
-
-    /**
-     * JDK compatibility support
-     */
-    private static final JdkCompat jdkCompat = JdkCompat.getJdkCompat();
-
-
     // ----------------------------------------------------- Instance Variables
     
     
@@ -125,7 +115,7 @@ public class StandardContextMBean extends BaseModelMBean {
             } catch (MalformedObjectNameException e) {
                 IllegalArgumentException iae = new IllegalArgumentException
                     ("Cannot create object name for environment " + envs[i]);
-                jdkCompat.chainException(iae, e);
+                iae.initCause(e);
                 throw iae;
             }
         }
@@ -150,7 +140,7 @@ public class StandardContextMBean extends BaseModelMBean {
             } catch (MalformedObjectNameException e) {
                 IllegalArgumentException iae = new IllegalArgumentException
                     ("Cannot create object name for resource " + resources[i]);
-                jdkCompat.chainException(iae, e);
+                iae.initCause(e);
                 throw iae;
             }
         }
@@ -175,7 +165,7 @@ public class StandardContextMBean extends BaseModelMBean {
             } catch (MalformedObjectNameException e) {
                 IllegalArgumentException iae = new IllegalArgumentException
                     ("Cannot create object name for resource " + links[i]);
-                jdkCompat.chainException(iae, e);
+                iae.initCause(e);
                 throw iae;
             }
         }

==================================================
ErrorReportValve.java
index ee315f74a6..05dc484099 100644
--- a/java/org/apache/catalina/mbeans/UserMBean.java
+++ b/java/org/apache/catalina/mbeans/UserMBean.java
@@ -29,7 +29,6 @@ import javax.management.RuntimeOperationsException;
 import org.apache.catalina.Group;
 import org.apache.catalina.Role;
 import org.apache.catalina.User;
-import org.apache.tomcat.util.compat.JdkCompat;
 import org.apache.tomcat.util.modeler.BaseModelMBean;
 import org.apache.tomcat.util.modeler.ManagedBean;
 import org.apache.tomcat.util.modeler.Registry;
@@ -65,15 +64,6 @@ public class UserMBean extends BaseModelMBean {
     }
 
 
-    // ----------------------------------------------------- Class Variables
-
-
-    /**
-     * JDK compatibility support
-     */
-    private static final JdkCompat jdkCompat = JdkCompat.getJdkCompat();
-
-
     // ----------------------------------------------------- Instance Variables
 
 
@@ -117,7 +107,7 @@ public class UserMBean extends BaseModelMBean {
             } catch (MalformedObjectNameException e) {
                 IllegalArgumentException iae = new IllegalArgumentException
                     ("Cannot create object name for group " + group);
-                jdkCompat.chainException(iae, e);
+                iae.initCause(e);
                 throw iae;
             }
         }
@@ -144,7 +134,7 @@ public class UserMBean extends BaseModelMBean {
             } catch (MalformedObjectNameException e) {
                 IllegalArgumentException iae = new IllegalArgumentException
                     ("Cannot create object name for role " + role);
-                jdkCompat.chainException(iae, e);
+                iae.initCause(e);
                 throw iae;
             }
         }

==================================================
RequestFilterValve.java
index ade583d05f..0e8b0dbf7a 100644
--- a/java/org/apache/catalina/valves/ErrorReportValve.java
+++ b/java/org/apache/catalina/valves/ErrorReportValve.java
@@ -33,7 +33,6 @@ import org.apache.catalina.util.RequestUtil;
 import org.apache.catalina.util.ServerInfo;
 import org.apache.catalina.util.StringManager;
 import org.apache.tomcat.util.IntrospectionUtils;
-import org.apache.tomcat.util.compat.JdkCompat;
 
 /**
  * <p>Implementation of a Valve that outputs HTML error pages.</p>
@@ -220,8 +219,7 @@ public class ErrorReportValve
 
         if (throwable != null) {
 
-            String stackTrace = JdkCompat.getJdkCompat()
-                .getPartialServletStackTrace(throwable);
+            String stackTrace = getPartialServletStackTrace(throwable);
             sb.append("<p><b>");
             sb.append(sm.getString("errorReportValve.exception"));
             sb.append("</b> <pre>");
@@ -229,8 +227,7 @@ public class ErrorReportValve
             sb.append("</pre></p>");
 
             while (rootCause != null) {
-                stackTrace = JdkCompat.getJdkCompat()
-                    .getPartialServletStackTrace(rootCause);
+                stackTrace = getPartialServletStackTrace(rootCause);
                 sb.append("<p><b>");
                 sb.append(sm.getString("errorReportValve.rootCause"));
                 sb.append("</b> <pre>");
@@ -281,4 +278,29 @@ public class ErrorReportValve
     }
 
 
+    /**
+     * Print out a partial servlet stack trace (truncating at the last 
+     * occurrence of javax.servlet.).
+     */
+    protected String getPartialServletStackTrace(Throwable t) {
+        StringBuffer trace = new StringBuffer();
+        trace.append(t.toString()).append('\n');
+        StackTraceElement[] elements = t.getStackTrace();
+        int pos = elements.length;
+        for (int i = 0; i < elements.length; i++) {
+            if ((elements[i].getClassName().startsWith
+                 ("org.apache.catalina.core.ApplicationFilterChain"))
+                && (elements[i].getMethodName().equals("internalDoFilter"))) {
+                pos = i;
+            }
+        }
+        for (int i = 0; i < pos; i++) {
+            if (!(elements[i].getClassName().startsWith
+                  ("org.apache.catalina.core."))) {
+                trace.append('\t').append(elements[i].toString()).append('\n');
+            }
+        }
+        return trace.toString();
+    }
+
 }

==================================================
Jdk14Compat.java
index e1177b524b..c34fb9f56c 100644
--- a/java/org/apache/catalina/valves/RequestFilterValve.java
+++ b/java/org/apache/catalina/valves/RequestFilterValve.java
@@ -29,7 +29,6 @@ import javax.servlet.http.HttpServletResponse;
 import org.apache.catalina.connector.Request;
 import org.apache.catalina.connector.Response;
 import org.apache.catalina.util.StringManager;
-import org.apache.tomcat.util.compat.JdkCompat;
 
 /**
  * Implementation of a Valve that performs filtering based on comparing the
@@ -72,12 +71,6 @@ public abstract class RequestFilterValve
     // ----------------------------------------------------- Class Variables
 
 
-    /**
-     * JDK compatibility support
-     */
-    private static final JdkCompat jdkCompat = JdkCompat.getJdkCompat();
-
-
     /**
      * The descriptive information related to this implementation.
      */
@@ -234,7 +227,7 @@ public abstract class RequestFilterValve
             } catch (PatternSyntaxException e) {
                 IllegalArgumentException iae = new IllegalArgumentException
                     (sm.getString("requestFilterValve.syntax", pattern));
-                jdkCompat.chainException(iae, e);
+                iae.initCause(e);
                 throw iae;
             }
             list = list.substring(comma + 1);

==================================================
JdkCompat.java
deleted file mode 100644
index db92730312..0000000000
--- a/java/org/apache/tomcat/util/compat/Jdk14Compat.java
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.util.compat;
-
-import java.io.File;
-import java.io.IOException;
-import java.net.MalformedURLException;
-import java.net.URL;
-
-//import org.apache.commons.logging.Log;
-//import org.apache.commons.logging.LogFactory;
-
-
-/**
- *  See JdkCompat. This is an extension of that class for Jdk1.4 support.
- *
- * @author Tim Funk
- * @author Remy Maucherat
- */
-public class Jdk14Compat extends JdkCompat {
-    // -------------------------------------------------------------- Constants
-
-    // ------------------------------------------------------- Static Variables
-    //static Log logger = LogFactory.getLog(Jdk14Compat.class);
-
-    // ----------------------------------------------------------- Constructors
-    /**
-     *  Default no-arg constructor
-     */
-    protected Jdk14Compat() {
-    }
-
-
-    // --------------------------------------------------------- Public Methods
-
-    /**
-     *  Return the URI for the given file. Originally created for
-     *  o.a.c.loader.WebappClassLoader
-     *
-     * @param file The file to wrap into URI
-     * @return A URI as a URL
-     * @throws MalformedURLException Doh ;)
-     */
-    public URL getURI(File file)
-        throws MalformedURLException {
-
-        File realFile = file;
-        try {
-            realFile = realFile.getCanonicalFile();
-        } catch (IOException e) {
-            // Ignore
-        }
-
-        return realFile.toURI().toURL();
-    }
-
-
-    /**
-     *  Return the maximum amount of memory the JVM will attempt to use.
-     */
-    public long getMaxMemory() {
-        return Runtime.getRuntime().maxMemory();
-    }
-
-
-    /**
-     * Print out a partial servlet stack trace (truncating at the last 
-     * occurrence of javax.servlet.).
-     */
-    public String getPartialServletStackTrace(Throwable t) {
-        StringBuffer trace = new StringBuffer();
-        trace.append(t.toString()).append('\n');
-        StackTraceElement[] elements = t.getStackTrace();
-        int pos = elements.length;
-        for (int i = 0; i < elements.length; i++) {
-            if ((elements[i].getClassName().startsWith
-                 ("org.apache.catalina.core.ApplicationFilterChain"))
-                && (elements[i].getMethodName().equals("internalDoFilter"))) {
-                pos = i;
-            }
-        }
-        for (int i = 0; i < pos; i++) {
-            if (!(elements[i].getClassName().startsWith
-                  ("org.apache.catalina.core."))) {
-                trace.append('\t').append(elements[i].toString()).append('\n');
-            }
-        }
-        return trace.toString();
-    }
-
-    public  String [] split(String path, String pat) {
-        return path.split(pat);
-    }
-
-
-    /**
-     * Chains the <tt>wrapped</tt> throwable to the <tt>wrapper</tt> throwable.
-     *
-     * @param wrapper The wrapper throwable 
-     * @param wrapped The throwable to be wrapped
-     */
-    public void chainException(Throwable wrapper, Throwable wrapped) {
-        wrapper.initCause(wrapped);
-    }
-
- }

==================================================
JSSE13Factory.java
deleted file mode 100644
index 7659ee50a2..0000000000
--- a/java/org/apache/tomcat/util/compat/JdkCompat.java
+++ /dev/null
@@ -1,221 +0,0 @@
-/*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.util.compat;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.util.Vector;
-
-
-/**
- *  General-purpose utility to provide backward-compatibility and JDK
- *  independence. This allow use of JDK1.3 ( or higher ) facilities if
- *  available, while maintaining the code compatible with older VMs.
- *
- *  The goal is to make backward-compatiblity reasonably easy.
- *
- *  The base class supports JDK1.3 behavior.
- *
- *  @author Tim Funk
- */
-public class JdkCompat {
-
-    // ------------------------------------------------------- Static Variables
-
-    /**
-     * class providing java2 support
-     */
-    static final String JAVA14_SUPPORT =
-        "org.apache.tomcat.util.compat.Jdk14Compat";
-
-    /** Return java version as a string
-     */
-    public static String getJavaVersion() {
-        return javaVersion;
-    }
-
-    public static boolean isJava2() {
-        return java2;
-    } 
-   
-    public static boolean isJava14() {
-        return java14;
-    }
-
-    public static boolean isJava15() {
-        return java15;
-    }
-
-    // -------------------- Implementation --------------------
-    
-    // from ant
-    public static final String JAVA_1_0 = "1.0";
-    public static final String JAVA_1_1 = "1.1";
-    public static final String JAVA_1_2 = "1.2";
-    public static final String JAVA_1_3 = "1.3";
-    public static final String JAVA_1_4 = "1.4";
-    public static final String JAVA_1_5 = "1.5";
-
-    static String javaVersion;
-    static boolean java2=false;
-    static boolean java14=false;
-    static boolean java15=false;
-    static JdkCompat jdkCompat;
-    
-    static {
-        init();
-    }
-
-    private static void init() {
-        try {
-            javaVersion = JAVA_1_0;
-            Class.forName("java.lang.Void");
-            javaVersion = JAVA_1_1;
-            Class.forName("java.lang.ThreadLocal");
-            java2=true;
-            javaVersion = JAVA_1_2;
-            Class.forName("java.lang.StrictMath");
-            javaVersion = JAVA_1_3;
-            Class.forName("java.lang.CharSequence");
-            javaVersion = JAVA_1_4;
-            java14=true;
-            Class.forName("java.lang.Appendable");
-            javaVersion = JAVA_1_5;
-            java15=true;
-        } catch (ClassNotFoundException cnfe) {
-            // swallow as we've hit the max class version that we have
-        }
-        if( java14 ) {
-            try {
-                Class c=Class.forName(JAVA14_SUPPORT);
-                jdkCompat=(JdkCompat)c.newInstance();
-            } catch( Exception ex ) {
-                jdkCompat=new JdkCompat();
-            }
-        } else {
-            jdkCompat=new JdkCompat();
-            // Install jar handler if none installed
-        }
-    }
-
-    // ----------------------------------------------------------- Constructors
-    /**
-     *  Default no-arg constructor
-     */
-    protected JdkCompat() {
-    }
-
-
-    // --------------------------------------------------------- Public Methods
-    /**
-     * Get a compatibiliy helper class.
-     */
-    public static JdkCompat getJdkCompat() {
-        return jdkCompat;
-    }
-
-    /**
-     *  Return the URI for the given file. Originally created for
-     *  o.a.c.loader.WebappClassLoader
-     *
-     * @param file The file to wrap into URI
-     * @return A URI as a URL
-     * @throws MalformedURLException Doh ;)
-     */
-    public URL getURI(File file)
-        throws MalformedURLException {
-
-        File realFile = file;
-        try {
-            realFile = realFile.getCanonicalFile();
-        } catch (IOException e) {
-            // Ignore
-        }
-
-        return realFile.toURL();
-    }
-
-
-    /**
-     *  Return the maximum amount of memory the JVM will attempt to use.
-     */
-    public long getMaxMemory() {
-        return (-1L);
-    }
-
-
-    /**
-     * Print out a partial servlet stack trace (truncating at the last 
-     * occurrence of javax.servlet.).
-     */
-    public String getPartialServletStackTrace(Throwable t) {
-        StringWriter stackTrace = new StringWriter();
-        t.printStackTrace(new PrintWriter(stackTrace));
-        String st = stackTrace.toString();
-        int i = st.lastIndexOf
-            ("org.apache.catalina.core.ApplicationFilterChain.internalDoFilter");
-        if (i > -1) {
-            return st.substring(0, i - 4);
-        } else {
-            return st;
-        }
-    }
-
-    /**
-     * Splits a string into it's components.
-     * @param path String to split
-     * @param pat Pattern to split at
-     * @return the components of the path
-     */
-    public  String [] split(String path, String pat) {
-        Vector comps = new Vector();
-        int pos = path.indexOf(pat);
-        int start = 0;
-        while( pos >= 0 ) {
-            if(pos > start ) {
-                String comp = path.substring(start,pos);
-                comps.add(comp);
-            }
-            start = pos + pat.length();
-            pos = path.indexOf(pat,start);
-        }
-        if( start < path.length()) {
-            comps.add(path.substring(start));
-        }
-        String [] result = new String[comps.size()];
-        for(int i=0; i < comps.size(); i++) {
-            result[i] = (String)comps.elementAt(i);
-        }
-        return result;
-    }
-
-
-    /**
-     * Chains the <tt>wrapped</tt> throwable to the <tt>wrapper</tt> throwable.
-     *
-     * @param wrapper The wrapper throwable 
-     * @param wrapped The throwable to be wrapped
-     */
-    public void chainException(Throwable wrapper, Throwable wrapped) {
-        // do nothing
-    }
-
- }

==================================================
JSSE13SocketFactory.java
deleted file mode 100644
index ae22fe34f3..0000000000
--- a/java/org/apache/tomcat/util/net/jsse/JSSE13Factory.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.util.net.jsse;
-
-import java.net.Socket;
-import javax.net.ssl.SSLSocket;
-import org.apache.tomcat.util.net.SSLSupport;
-import org.apache.tomcat.util.net.ServerSocketFactory;
-
-/**
- * Implementation class for JSSEFactory for JSSE 1.0.x (that is an extension
- * to the 1.3 JVM).
- *
- * @author Bill Barker
- */
-
-class JSSE13Factory implements JSSEFactory {
-
-    JSSE13Factory() {
-    }
-
-    public ServerSocketFactory getSocketFactory() {
-        return new JSSE13SocketFactory();
-    }
-
-    public SSLSupport getSSLSupport(Socket socket) {
-        return new JSSESupport((SSLSocket)socket);
-    }
-}

==================================================
JSSE14Factory.java
deleted file mode 100644
index 89c813fc7d..0000000000
--- a/java/org/apache/tomcat/util/net/jsse/JSSE13SocketFactory.java
+++ /dev/null
@@ -1,156 +0,0 @@
-/*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.util.net.jsse;
-
-import java.io.IOException;
-import java.security.KeyStore;
-import java.security.SecureRandom;
-import java.security.Security;
-import java.security.Provider;
-
-import javax.net.ssl.SSLServerSocket;
-import javax.net.ssl.SSLSocket;
-
-/*
-  1. Make the JSSE's jars available, either as an installed
-     extension (copy them into jre/lib/ext) or by adding
-     them to the Tomcat classpath.
-  2. keytool -genkey -alias tomcat -keyalg RSA
-     Use "changeit" as password ( this is the default we use )
- */
-
-/**
- * SSL server socket factory. It _requires_ a valid RSA key and
- * JSSE. 
- *
- * @author Harish Prabandham
- * @author Costin Manolache
- * @author Stefan Freyr Stefansson
- * @author EKR -- renamed to JSSESocketFactory
- * @author Bill Barker
- */
-public class JSSE13SocketFactory extends JSSESocketFactory
-{
-    /**
-     * Flag for client authentication
-     */
-    protected boolean clientAuth = false;
-
-    public JSSE13SocketFactory () {
-        super();
-    }
-
-    /**
-     * Reads the keystore and initializes the SSL socket factory.
-     *
-     * NOTE: This method is identical in functionality to the method of the
-     * same name in JSSE14SocketFactory, except that this method is used with
-     * JSSE 1.0.x (which is an extension to the 1.3 JVM), whereas the other is
-     * used with JSSE 1.1.x (which ships with the 1.4 JVM). Therefore, this
-     * method uses classes in com.sun.net.ssl, which have since moved to
-     * javax.net.ssl, and explicitly registers the required security providers,
-     * which come standard in a 1.4 JVM.
-     */
-     void init() throws IOException {
-        try {
-            try {
-                Class ssps = Class.forName("sun.security.provider.Sun");
-                Security.addProvider ((Provider)ssps.newInstance());
-            }catch(Exception cnfe) {
-                //Ignore, since this is a non-Sun JVM
-            }
-            Security.addProvider (new com.sun.net.ssl.internal.ssl.Provider());
-
-            String clientAuthStr = (String)attributes.get("clientauth");
-            if("true".equalsIgnoreCase(clientAuthStr) || 
-               "yes".equalsIgnoreCase(clientAuthStr)  ||
-               "want".equalsIgnoreCase(clientAuthStr)) {
-                clientAuth = true;
-            }
-            
-            // SSL protocol variant (e.g., TLS, SSL v3, etc.)
-            String protocol = (String)attributes.get("protocol");
-            if (protocol == null) protocol = defaultProtocol;
-            
-            // Certificate encoding algorithm (e.g., SunX509)
-            String algorithm = (String)attributes.get("algorithm");
-            if (algorithm == null) algorithm = defaultAlgorithm;
-
-            // Set up KeyManager, which will extract server key
-            com.sun.net.ssl.KeyManagerFactory kmf = 
-                com.sun.net.ssl.KeyManagerFactory.getInstance(algorithm);
-            String keystoreType = (String)attributes.get("keystoreType");
-            if (keystoreType == null) {
-                keystoreType = defaultKeystoreType;
-            }
-            String keystorePass = getKeystorePassword();
-            kmf.init(getKeystore(keystoreType, keystorePass),
-                     keystorePass.toCharArray());
-
-            // Set up TrustManager
-            com.sun.net.ssl.TrustManager[] tm = null;
-            String truststoreType = (String)attributes.get("truststoreType");
-            if(truststoreType == null) {
-                truststoreType = keystoreType;
-            }
-            KeyStore trustStore = getTrustStore(truststoreType);
-            if (trustStore != null) {
-                com.sun.net.ssl.TrustManagerFactory tmf =
-                    com.sun.net.ssl.TrustManagerFactory.getInstance("SunX509");
-                tmf.init(trustStore);
-                tm = tmf.getTrustManagers();
-            }
-
-            // Create and init SSLContext
-            com.sun.net.ssl.SSLContext context = 
-                com.sun.net.ssl.SSLContext.getInstance(protocol); 
-            context.init(kmf.getKeyManagers(), tm, new SecureRandom());
-
-            // Create proxy
-            sslProxy = context.getServerSocketFactory();
-
-            // Determine which cipher suites to enable
-            String requestedCiphers = (String)attributes.get("ciphers");
-            enabledCiphers = getEnabledCiphers(requestedCiphers,
-                     sslProxy.getSupportedCipherSuites());
-
-        } catch(Exception e) {
-            if( e instanceof IOException )
-                throw (IOException)e;
-            throw new IOException(e.getMessage());
-        }
-    }
-    protected String[] getEnabledProtocols(SSLServerSocket socket,
-                                           String requestedProtocols){
-        return null;
-    }
-    protected void setEnabledProtocols(SSLServerSocket socket, 
-                                             String [] protocols){
-    }
-
-    protected void configureClientAuth(SSLServerSocket socket){
-        socket.setNeedClientAuth(clientAuth);
-    }
-
-    protected void configureClientAuth(SSLSocket socket){
-        // In JSSE 1.0.2 docs it does not explicitly
-        // state whether SSLSockets returned from 
-        // SSLServerSocket.accept() inherit this setting.
-        socket.setNeedClientAuth(clientAuth);
-    }
-
-}

==================================================
JSSE14SocketFactory.java
deleted file mode 100644
index 83cc2af5bc..0000000000
--- a/java/org/apache/tomcat/util/net/jsse/JSSE14Factory.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.util.net.jsse;
-
-import java.net.Socket;
-import javax.net.ssl.SSLSocket;
-import org.apache.tomcat.util.net.SSLSupport;
-import org.apache.tomcat.util.net.ServerSocketFactory;
-
-/**
- * Implementation class for JSSEFactory for JSSE 1.1.x (that ships with the
- * 1.4 JVM).
- *
- * @author Bill Barker
- */
-
-class JSSE14Factory implements JSSEFactory {
-
-    JSSE14Factory() {
-    }
-
-    public ServerSocketFactory getSocketFactory() {
-	return new JSSE14SocketFactory();
-    }
-
-    public SSLSupport getSSLSupport(Socket socket) {
-	return new JSSE14Support((SSLSocket)socket);
-    }
-}

==================================================
JSSE14Support.java
deleted file mode 100644
index 4e69cf95a6..0000000000
--- a/java/org/apache/tomcat/util/net/jsse/JSSE14SocketFactory.java
+++ /dev/null
@@ -1,267 +0,0 @@
-/*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.util.net.jsse;
-
-import java.io.IOException;
-import java.security.KeyStore;
-import java.security.SecureRandom;
-import java.util.Vector;
-
-import javax.net.ssl.KeyManager;
-import javax.net.ssl.KeyManagerFactory;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLServerSocket;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.TrustManagerFactory;
-import javax.net.ssl.X509KeyManager;
-
-import org.apache.tomcat.util.res.StringManager;
-
-/*
-  1. Make the JSSE's jars available, either as an installed
-     extension (copy them into jre/lib/ext) or by adding
-     them to the Tomcat classpath.
-  2. keytool -genkey -alias tomcat -keyalg RSA
-     Use "changeit" as password ( this is the default we use )
- */
-
-/**
- * SSL server socket factory. It _requires_ a valid RSA key and
- * JSSE. 
- *
- * @author Harish Prabandham
- * @author Costin Manolache
- * @author Stefan Freyr Stefansson
- * @author EKR -- renamed to JSSESocketFactory
- * @author Jan Luehe
- */
-public class JSSE14SocketFactory  extends JSSESocketFactory {
-
-    private static StringManager sm =
-        StringManager.getManager("org.apache.tomcat.util.net.jsse.res");
-
-    /**
-     * Flag to state that we require client authentication.
-     */
-    protected boolean requireClientAuth = false;
-
-    /**
-     * Flag to state that we would like client authentication.
-     */
-    protected boolean wantClientAuth    = false;
-
-    public JSSE14SocketFactory () {
-        super();
-    }
-
-    /**
-     * Reads the keystore and initializes the SSL socket factory.
-     */
-    void init() throws IOException {
-        try {
-
-            String clientAuthStr = (String) attributes.get("clientauth");
-            if("true".equalsIgnoreCase(clientAuthStr) ||
-               "yes".equalsIgnoreCase(clientAuthStr)) {
-                requireClientAuth = true;
-            } else if("want".equalsIgnoreCase(clientAuthStr)) {
-                wantClientAuth = true;
-            }
-
-            // SSL protocol variant (e.g., TLS, SSL v3, etc.)
-            String protocol = (String) attributes.get("protocol");
-            if (protocol == null) {
-                protocol = defaultProtocol;
-            }
-
-            // Certificate encoding algorithm (e.g., SunX509)
-            String algorithm = (String) attributes.get("algorithm");
-            if (algorithm == null) {
-                algorithm = defaultAlgorithm;
-            }
-
-            String keystoreType = (String) attributes.get("keystoreType");
-            if (keystoreType == null) {
-                keystoreType = defaultKeystoreType;
-            }
-
-	    String trustAlgorithm = (String)attributes.get("truststoreAlgorithm");
-	    if( trustAlgorithm == null ) {
-		trustAlgorithm = algorithm;
-	    }
-            // Create and init SSLContext
-            SSLContext context = SSLContext.getInstance(protocol); 
-            context.init(getKeyManagers(keystoreType, algorithm,
-                                        (String) attributes.get("keyAlias")),
-                         getTrustManagers(keystoreType, trustAlgorithm),
-                         new SecureRandom());
-
-            // create proxy
-            sslProxy = context.getServerSocketFactory();
-
-            // Determine which cipher suites to enable
-            String requestedCiphers = (String)attributes.get("ciphers");
-            enabledCiphers = getEnabledCiphers(requestedCiphers,
-                                               sslProxy.getSupportedCipherSuites());
-
-        } catch(Exception e) {
-            if( e instanceof IOException )
-                throw (IOException)e;
-            throw new IOException(e.getMessage());
-        }
-    }
-
-    /**
-     * Gets the initialized key managers.
-     */
-    protected KeyManager[] getKeyManagers(String keystoreType,
-                                          String algorithm,
-                                          String keyAlias)
-                throws Exception {
-
-        KeyManager[] kms = null;
-
-        String keystorePass = getKeystorePassword();
-
-        KeyStore ks = getKeystore(keystoreType, keystorePass);
-        if (keyAlias != null && !ks.isKeyEntry(keyAlias)) {
-            throw new IOException(sm.getString("jsse.alias_no_key_entry", keyAlias));
-        }
-
-        KeyManagerFactory kmf = KeyManagerFactory.getInstance(algorithm);
-        kmf.init(ks, keystorePass.toCharArray());
-
-        kms = kmf.getKeyManagers();
-        if (keyAlias != null) {
-            if (JSSESocketFactory.defaultKeystoreType.equals(keystoreType)) {
-                keyAlias = keyAlias.toLowerCase();
-            }
-            for(int i=0; i<kms.length; i++) {
-                kms[i] = new JSSEKeyManager((X509KeyManager)kms[i], keyAlias);
-            }
-        }
-
-        return kms;
-    }
-
-    /**
-     * Gets the intialized trust managers.
-     */
-    protected TrustManager[] getTrustManagers(String keystoreType, String algorithm)
-                throws Exception {
-
-        TrustManager[] tms = null;
-
-        String truststoreType = (String)attributes.get("truststoreType");
-        if(truststoreType == null) {
-            truststoreType = keystoreType;
-        }
-        KeyStore trustStore = getTrustStore(truststoreType);
-        if (trustStore != null) {
-            TrustManagerFactory tmf = TrustManagerFactory.getInstance(algorithm);
-            tmf.init(trustStore);
-            tms = tmf.getTrustManagers();
-        }
-
-        return tms;
-    }
-    protected void setEnabledProtocols(SSLServerSocket socket, String []protocols){
-        if (protocols != null) {
-            socket.setEnabledProtocols(protocols);
-        }
-    }
-
-    protected String[] getEnabledProtocols(SSLServerSocket socket,
-                                           String requestedProtocols){
-        String[] supportedProtocols = socket.getSupportedProtocols();
-
-        String[] enabledProtocols = null;
-
-        if (requestedProtocols != null) {
-            Vector vec = null;
-            String protocol = requestedProtocols;
-            int index = requestedProtocols.indexOf(',');
-            if (index != -1) {
-                int fromIndex = 0;
-                while (index != -1) {
-                    protocol = requestedProtocols.substring(fromIndex, index).trim();
-                    if (protocol.length() > 0) {
-                        /*
-                         * Check to see if the requested protocol is among the
-                         * supported protocols, i.e., may be enabled
-                         */
-                        for (int i=0; supportedProtocols != null
-                                     && i<supportedProtocols.length; i++) {
-                            if (supportedProtocols[i].equals(protocol)) {
-                                if (vec == null) {
-                                    vec = new Vector();
-                                }
-                                vec.addElement(protocol);
-                                break;
-                            }
-                        }
-                    }
-                    fromIndex = index+1;
-                    index = requestedProtocols.indexOf(',', fromIndex);
-                } // while
-                protocol = requestedProtocols.substring(fromIndex);
-            }
-
-            if (protocol != null) {
-                protocol = protocol.trim();
-                if (protocol.length() > 0) {
-                    /*
-                     * Check to see if the requested protocol is among the
-                     * supported protocols, i.e., may be enabled
-                     */
-                    for (int i=0; supportedProtocols != null
-                                 && i<supportedProtocols.length; i++) {
-                        if (supportedProtocols[i].equals(protocol)) {
-                            if (vec == null) {
-                                vec = new Vector();
-                            }
-                            vec.addElement(protocol);
-                            break;
-                        }
-                    }
-                }
-            }           
-
-            if (vec != null) {
-                enabledProtocols = new String[vec.size()];
-                vec.copyInto(enabledProtocols);
-            }
-        }
-
-        return enabledProtocols;
-    }
-
-    protected void configureClientAuth(SSLServerSocket socket){
-        if (wantClientAuth){
-            socket.setWantClientAuth(wantClientAuth);
-        } else {
-            socket.setNeedClientAuth(requireClientAuth);
-        }
-    }
-
-    protected void configureClientAuth(SSLSocket socket){
-        // Per JavaDocs: SSLSockets returned from 
-        // SSLServerSocket.accept() inherit this setting.
-    }
-    
-}

==================================================
JSSE15Factory.java
deleted file mode 100644
index 1bc164bf27..0000000000
--- a/java/org/apache/tomcat/util/net/jsse/JSSE14Support.java
+++ /dev/null
@@ -1,158 +0,0 @@
-/*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.util.net.jsse;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.SocketException;
-import java.security.cert.Certificate;
-import java.security.cert.CertificateFactory;
-import java.security.cert.X509Certificate;
-
-import javax.net.ssl.HandshakeCompletedEvent;
-import javax.net.ssl.HandshakeCompletedListener;
-import javax.net.ssl.SSLException;
-import javax.net.ssl.SSLSession;
-import javax.net.ssl.SSLSocket;
-
-
-/* JSSESupport
-
-   Concrete implementation class for JSSE
-   Support classes.
-
-   This will only work with JDK 1.2 and up since it
-   depends on JDK 1.2's certificate support
-
-   @author EKR
-   @author Craig R. McClanahan
-   Parts cribbed from JSSECertCompat       
-   Parts cribbed from CertificatesValve
-*/
-
-class JSSE14Support extends JSSESupport {
-
-    private static org.apache.commons.logging.Log logger =
-        org.apache.commons.logging.LogFactory.getLog(JSSE14Support.class);
-
-    Listener listener = new Listener();
-
-    public JSSE14Support(SSLSocket sock){
-        super(sock);
-        sock.addHandshakeCompletedListener(listener);
-    }
-
-    protected void handShake() throws IOException {
-        if( ssl.getWantClientAuth() ) {
-            logger.debug("No client cert sent for want");
-        } else {
-            ssl.setNeedClientAuth(true);
-        }
-        synchronousHandshake(ssl);
-    }
-
-    /**
-     * JSSE in JDK 1.4 has an issue/feature that requires us to do a
-     * read() to get the client-cert.  As suggested by Andreas
-     * Sterbenz
-     */
-    private  void synchronousHandshake(SSLSocket socket) 
-        throws IOException {
-        InputStream in = socket.getInputStream();
-        int oldTimeout = socket.getSoTimeout();
-        socket.setSoTimeout(1000);
-        byte[] b = new byte[0];
-        listener.reset();
-        socket.startHandshake();
-        int maxTries = 60; // 60 * 1000 = example 1 minute time out
-        for (int i = 0; i < maxTries; i++) {
-	    if(logger.isTraceEnabled())
-		logger.trace("Reading for try #" +i);
-            try {
-                int x = in.read(b);
-            } catch(SSLException sslex) {
-                logger.info("SSL Error getting client Certs",sslex);
-                throw sslex;
-            } catch (IOException e) {
-                // ignore - presumably the timeout
-            }
-            if (listener.completed) {
-                break;
-            }
-        }
-        socket.setSoTimeout(oldTimeout);
-        if (listener.completed == false) {
-            throw new SocketException("SSL Cert handshake timeout");
-        }
-    }
-
-    /** Return the X509certificates or null if we can't get them.
-     *  XXX We should allow unverified certificates 
-     */ 
-    protected X509Certificate [] getX509Certificates(SSLSession session) 
-	throws IOException 
-    {
-        Certificate [] certs=null;
-        try {
-	    certs = session.getPeerCertificates();
-        } catch( Throwable t ) {
-            logger.debug("Error getting client certs",t);
-            return null;
-        }
-        if( certs==null ) return null;
-        
-        X509Certificate [] x509Certs = new X509Certificate[certs.length];
-	for(int i=0; i < certs.length; i++) {
-	    if( certs[i] instanceof X509Certificate ) {
-		// always currently true with the JSSE 1.1.x
-		x509Certs[i] = (X509Certificate)certs[i];
-	    } else {
-		try {
-		    byte [] buffer = certs[i].getEncoded();
-		    CertificateFactory cf =
-			CertificateFactory.getInstance("X.509");
-		    ByteArrayInputStream stream =
-			new ByteArrayInputStream(buffer);
-		    x509Certs[i] = (X509Certificate)
-			cf.generateCertificate(stream);
-		} catch(Exception ex) { 
-		    logger.info("Error translating cert " + certs[i], ex);
-		    return null;
-		}
-	    }
-	    if(logger.isTraceEnabled())
-		logger.trace("Cert #" + i + " = " + x509Certs[i]);
-	}
-	if(x509Certs.length < 1)
-	    return null;
-	return x509Certs;
-    }
-
-
-    private static class Listener implements HandshakeCompletedListener {
-        volatile boolean completed = false;
-        public void handshakeCompleted(HandshakeCompletedEvent event) {
-            completed = true;
-        }
-        void reset() {
-            completed = false;
-        }
-    }
-
-}
-

==================================================
JSSE15SocketFactory.java
deleted file mode 100644
index bf4fc57f9b..0000000000
--- a/java/org/apache/tomcat/util/net/jsse/JSSE15Factory.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.util.net.jsse;
-
-import java.net.Socket;
-import javax.net.ssl.SSLSocket;
-import org.apache.tomcat.util.net.SSLSupport;
-import org.apache.tomcat.util.net.ServerSocketFactory;
-
-/**
- * Implementation class for JSSEFactory for JSSE 1.1.x (that ships with the
- * 1.5 JVM).
- *
- * @author Bill Barker
- */
-
-class JSSE15Factory extends JSSE14Factory {
-
-    JSSE15Factory() {
-        super();
-    }
-
-    public ServerSocketFactory getSocketFactory() {
-        return new JSSE15SocketFactory();
-    }
-
-}

==================================================
JSSEFactory.java
deleted file mode 100644
index ef24a41ae4..0000000000
--- a/java/org/apache/tomcat/util/net/jsse/JSSE15SocketFactory.java
+++ /dev/null
@@ -1,163 +0,0 @@
-/*
- *  Copyright 1999-2004 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.util.net.jsse;
-
-import java.io.IOException;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.InputStream;
-import java.util.Collection;
-import java.security.KeyStore;
-import java.security.cert.PKIXBuilderParameters;
-import java.security.cert.X509CertSelector;
-import java.security.cert.CRL;
-import java.security.cert.CollectionCertStoreParameters;
-import java.security.cert.CertStoreParameters;
-import java.security.cert.CertPathParameters;
-import java.security.cert.CertStore;
-import java.security.cert.CertificateFactory;
-import java.security.cert.CRLException;
-import java.security.cert.CertificateException;
-
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.TrustManagerFactory;
-import javax.net.ssl.X509KeyManager;
-import javax.net.ssl.ManagerFactoryParameters;
-import javax.net.ssl.CertPathTrustManagerParameters;
-
-/**
- * SSL Socket Factory for JDK 1.5
- *
- * @author Bill Barker
- */
-public class JSSE15SocketFactory  extends JSSE14SocketFactory {
-
-    private static org.apache.commons.logging.Log log =
-        org.apache.commons.logging.LogFactory.getLog(JSSE15SocketFactory.class);
-
-    public JSSE15SocketFactory() {
-        super();
-    }
-
-
-    /**
-     * Gets the intialized trust managers.
-     */
-    protected TrustManager[] getTrustManagers(String keystoreType, String algorithm)
-        throws Exception {
-        if(attributes.get("truststoreAlgorithm") == null) {
-            // in 1.5, the Trust default isn't the same as the Key default.
-            algorithm = TrustManagerFactory.getDefaultAlgorithm();
-        }
-        String crlf = (String)attributes.get("crlFile");
-        if(crlf == null) {
-            return super.getTrustManagers(keystoreType, algorithm);
-        }
-
-        TrustManager[] tms = null;
-
-        String truststoreType = (String)attributes.get("truststoreType");
-        if(truststoreType == null) {
-            truststoreType = keystoreType;
-        }
-        KeyStore trustStore = getTrustStore(truststoreType);
-        if (trustStore != null) {
-            TrustManagerFactory tmf = TrustManagerFactory.getInstance(algorithm);
-            CertPathParameters params = getParameters(algorithm, crlf, trustStore);
-            ManagerFactoryParameters mfp = new CertPathTrustManagerParameters(params);
-            tmf.init(mfp);
-            tms = tmf.getTrustManagers();
-        }
-
-        return tms;
-    }
-
-
-    /**
-     * Return the initialization parameters for the TrustManager.
-     * Currently, only the default <code>PKIX</code> is supported.
-     * 
-     * @param algorithm The algorithm to get parameters for.
-     * @param crlf The path to the CRL file.
-     * @param trustStore The configured TrustStore.
-     * @return The parameters including the CRLs and TrustStore.
-     */
-    protected CertPathParameters getParameters(String algorithm, 
-                                                String crlf, 
-                                                KeyStore trustStore)
-        throws Exception {
-        CertPathParameters params = null;
-        if("PKIX".equalsIgnoreCase(algorithm)) {
-            PKIXBuilderParameters xparams = new PKIXBuilderParameters(trustStore, 
-                                                                     new X509CertSelector());
-            Collection crls = getCRLs(crlf);
-            CertStoreParameters csp = new CollectionCertStoreParameters(crls);
-            CertStore store = CertStore.getInstance("Collection", csp);
-            xparams.addCertStore(store);
-            xparams.setRevocationEnabled(true);
-            String trustLength = (String)attributes.get("trustMaxCertLength");
-            if(trustLength != null) {
-                try {
-                    xparams.setMaxPathLength(Integer.parseInt(trustLength));
-                } catch(Exception ex) {
-                    log.warn("Bad maxCertLength: "+trustLength);
-                }
-            }
-
-            params = xparams;
-        } else {
-            throw new CRLException("CRLs not supported for type: "+algorithm);
-        }
-        return params;
-    }
-
-
-    /**
-     * Load the collection of CRLs.
-     * 
-     */
-    protected Collection<? extends CRL> getCRLs(String crlf) 
-        throws IOException, CRLException, CertificateException {
-
-        File crlFile = new File(crlf);
-        if( !crlFile.isAbsolute() ) {
-            crlFile = new File(System.getProperty("catalina.base"), crlf);
-        }
-        Collection<? extends CRL> crls = null;
-        InputStream is = null;
-        try {
-            CertificateFactory cf = CertificateFactory.getInstance("X.509");
-            is = new FileInputStream(crlFile);
-            crls = cf.generateCRLs(is);
-        } catch(IOException iex) {
-            throw iex;
-        } catch(CRLException crle) {
-            throw crle;
-        } catch(CertificateException ce) {
-            throw ce;
-        } finally { 
-            if(is != null) {
-                try{
-                    is.close();
-                } catch(Exception ex) {
-                }
-            }
-        }
-        return crls;
-    }
-
-}

==================================================
JSSEImplementation.java
index e19f6231b1..1d8aaf778c 100644
--- a/java/org/apache/tomcat/util/net/jsse/JSSEFactory.java
+++ b/java/org/apache/tomcat/util/net/jsse/JSSEFactory.java
@@ -17,6 +17,9 @@
 package org.apache.tomcat.util.net.jsse;
 
 import java.net.Socket;
+
+import javax.net.ssl.SSLSocket;
+
 import org.apache.tomcat.util.net.SSLSupport;
 import org.apache.tomcat.util.net.ServerSocketFactory;
 
@@ -27,16 +30,20 @@ import org.apache.tomcat.util.net.ServerSocketFactory;
  * @author Bill Barker
  */
 
-interface JSSEFactory {
+public class JSSEFactory {
 
     /**
      * Returns the ServerSocketFactory to use.
      */
-    public ServerSocketFactory getSocketFactory();
+    public ServerSocketFactory getSocketFactory() {
+        return new JSSESocketFactory();
+    }
 
     /**
      * returns the SSLSupport attached to this socket.
      */
-    public SSLSupport getSSLSupport(Socket socket);
+    public SSLSupport getSSLSupport(Socket socket) {
+        return new JSSESupport((SSLSocket)socket);
+    }
 
 };

==================================================
JSSESocketFactory.java
index 9ee643d723..1102ab4a51 100644
--- a/java/org/apache/tomcat/util/net/jsse/JSSEImplementation.java
+++ b/java/org/apache/tomcat/util/net/jsse/JSSEImplementation.java
@@ -18,7 +18,6 @@ package org.apache.tomcat.util.net.jsse;
 
 import java.net.Socket;
 
-import org.apache.tomcat.util.compat.JdkCompat;
 import org.apache.tomcat.util.net.SSLImplementation;
 import org.apache.tomcat.util.net.SSLSupport;
 import org.apache.tomcat.util.net.ServerSocketFactory;
@@ -32,12 +31,6 @@ import org.apache.tomcat.util.net.ServerSocketFactory;
         
 public class JSSEImplementation extends SSLImplementation
 {
-    static final String JSSE15Factory =
-	"org.apache.tomcat.util.net.jsse.JSSE15Factory";
-    static final String JSSE14Factory = 
-        "org.apache.tomcat.util.net.jsse.JSSE14Factory";
-    static final String JSSE13Factory = 
-        "org.apache.tomcat.util.net.jsse.JSSE13Support";
     static final String SSLSocketClass = "javax.net.ssl.SSLSocket";
 
     static org.apache.commons.logging.Log logger = 
@@ -48,27 +41,7 @@ public class JSSEImplementation extends SSLImplementation
     public JSSEImplementation() throws ClassNotFoundException {
         // Check to see if JSSE is floating around somewhere
         Class.forName(SSLSocketClass);
-        if( JdkCompat.isJava15() ) {
-            try {
-                Class factcl = Class.forName(JSSE15Factory);
-                factory = (JSSEFactory)factcl.newInstance();
-            } catch(Exception ex) {
-                if(logger.isDebugEnabled())
-                    logger.debug("Error getting factory: " + JSSE15Factory, ex);
-            }
-        }
-        if(factory == null && JdkCompat.isJava14() ) {
-            try {
-                Class factcl = Class.forName(JSSE14Factory);
-                factory = (JSSEFactory)factcl.newInstance();
-            } catch(Exception ex) {
-                if(logger.isDebugEnabled()) {
-                    logger.debug("Error getting factory: " + JSSE14Factory, ex);
-                }
-            }
-        } if(factory == null) {
-            factory = new JSSE13Factory();
-        }
+        factory = new JSSEFactory();
     }
 
 

==================================================
JSSESupport.java
index 8bef00f945..0d317df113 100644
--- a/java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java
+++ b/java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java
@@ -26,12 +26,34 @@ import java.net.ServerSocket;
 import java.net.Socket;
 import java.net.SocketException;
 import java.security.KeyStore;
+import java.security.SecureRandom;
+import java.security.cert.CRL;
+import java.security.cert.CRLException;
+import java.security.cert.CertPathParameters;
+import java.security.cert.CertStore;
+import java.security.cert.CertStoreParameters;
+import java.security.cert.CertificateException;
+import java.security.cert.CertificateFactory;
+import java.security.cert.CollectionCertStoreParameters;
+import java.security.cert.PKIXBuilderParameters;
+import java.security.cert.X509CertSelector;
+import java.util.Collection;
 import java.util.Vector;
 
+import javax.net.ssl.CertPathTrustManagerParameters;
+import javax.net.ssl.KeyManager;
+import javax.net.ssl.KeyManagerFactory;
+import javax.net.ssl.ManagerFactoryParameters;
+import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLException;
 import javax.net.ssl.SSLServerSocket;
 import javax.net.ssl.SSLServerSocketFactory;
 import javax.net.ssl.SSLSocket;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509KeyManager;
+
+import org.apache.tomcat.util.res.StringManager;
 
 /*
   1. Make the JSSE's jars available, either as an installed
@@ -49,10 +71,15 @@ import javax.net.ssl.SSLSocket;
  * @author Costin Manolache
  * @author Stefan Freyr Stefansson
  * @author EKR -- renamed to JSSESocketFactory
+ * @author Jan Luehe
+ * @author Bill Barker
  */
-public abstract class JSSESocketFactory
-    extends org.apache.tomcat.util.net.ServerSocketFactory
-{
+public class JSSESocketFactory
+    extends org.apache.tomcat.util.net.ServerSocketFactory {
+
+    private static StringManager sm =
+        StringManager.getManager("org.apache.tomcat.util.net.jsse.res");
+
     // defaults
     static String defaultProtocol = "TLS";
     static String defaultAlgorithm = "SunX509";
@@ -68,7 +95,17 @@ public abstract class JSSESocketFactory
     protected String clientAuth = "false";
     protected SSLServerSocketFactory sslProxy = null;
     protected String[] enabledCiphers;
-   
+
+    /**
+     * Flag to state that we require client authentication.
+     */
+    protected boolean requireClientAuth = false;
+
+    /**
+     * Flag to state that we would like client authentication.
+     */
+    protected boolean wantClientAuth    = false;
+
 
     public JSSESocketFactory () {
     }
@@ -303,12 +340,214 @@ public abstract class JSSESocketFactory
 
     /**
      * Reads the keystore and initializes the SSL socket factory.
-     *
-     * Place holder method to initialize the KeyStore, etc.
      */
-    abstract void init() throws IOException ;
+    void init() throws IOException {
+        try {
 
-    /*
+            String clientAuthStr = (String) attributes.get("clientauth");
+            if("true".equalsIgnoreCase(clientAuthStr) ||
+               "yes".equalsIgnoreCase(clientAuthStr)) {
+                requireClientAuth = true;
+            } else if("want".equalsIgnoreCase(clientAuthStr)) {
+                wantClientAuth = true;
+            }
+
+            // SSL protocol variant (e.g., TLS, SSL v3, etc.)
+            String protocol = (String) attributes.get("protocol");
+            if (protocol == null) {
+                protocol = defaultProtocol;
+            }
+
+            // Certificate encoding algorithm (e.g., SunX509)
+            String algorithm = (String) attributes.get("algorithm");
+            if (algorithm == null) {
+                algorithm = defaultAlgorithm;
+            }
+
+            String keystoreType = (String) attributes.get("keystoreType");
+            if (keystoreType == null) {
+                keystoreType = defaultKeystoreType;
+            }
+
+        String trustAlgorithm = (String)attributes.get("truststoreAlgorithm");
+        if( trustAlgorithm == null ) {
+        trustAlgorithm = algorithm;
+        }
+            // Create and init SSLContext
+            SSLContext context = SSLContext.getInstance(protocol); 
+            context.init(getKeyManagers(keystoreType, algorithm,
+                                        (String) attributes.get("keyAlias")),
+                         getTrustManagers(keystoreType, trustAlgorithm),
+                         new SecureRandom());
+
+            // create proxy
+            sslProxy = context.getServerSocketFactory();
+
+            // Determine which cipher suites to enable
+            String requestedCiphers = (String)attributes.get("ciphers");
+            enabledCiphers = getEnabledCiphers(requestedCiphers,
+                                               sslProxy.getSupportedCipherSuites());
+
+        } catch(Exception e) {
+            if( e instanceof IOException )
+                throw (IOException)e;
+            throw new IOException(e.getMessage());
+        }
+    }
+
+    /**
+     * Gets the initialized key managers.
+     */
+    protected KeyManager[] getKeyManagers(String keystoreType,
+                                          String algorithm,
+                                          String keyAlias)
+                throws Exception {
+
+        KeyManager[] kms = null;
+
+        String keystorePass = getKeystorePassword();
+
+        KeyStore ks = getKeystore(keystoreType, keystorePass);
+        if (keyAlias != null && !ks.isKeyEntry(keyAlias)) {
+            throw new IOException(sm.getString("jsse.alias_no_key_entry", keyAlias));
+        }
+
+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(algorithm);
+        kmf.init(ks, keystorePass.toCharArray());
+
+        kms = kmf.getKeyManagers();
+        if (keyAlias != null) {
+            if (JSSESocketFactory.defaultKeystoreType.equals(keystoreType)) {
+                keyAlias = keyAlias.toLowerCase();
+            }
+            for(int i=0; i<kms.length; i++) {
+                kms[i] = new JSSEKeyManager((X509KeyManager)kms[i], keyAlias);
+            }
+        }
+
+        return kms;
+    }
+
+    /**
+     * Gets the intialized trust managers.
+     */
+    protected TrustManager[] getTrustManagers(String keystoreType, String algorithm)
+        throws Exception {
+        if (attributes.get("truststoreAlgorithm") == null) {
+            // in 1.5, the Trust default isn't the same as the Key default.
+            algorithm = TrustManagerFactory.getDefaultAlgorithm();
+        }
+        String crlf = (String) attributes.get("crlFile");
+        
+        TrustManager[] tms = null;
+        
+        String truststoreType = (String) attributes.get("truststoreType");
+        if (truststoreType == null) {
+            truststoreType = keystoreType;
+        }
+        KeyStore trustStore = getTrustStore(truststoreType);
+        if (trustStore != null) {
+            if (crlf == null) {
+                TrustManagerFactory tmf = TrustManagerFactory.getInstance(algorithm);
+                tmf.init(trustStore);
+                tms = tmf.getTrustManagers();
+            } else {
+                TrustManagerFactory tmf = TrustManagerFactory.getInstance(algorithm);
+                CertPathParameters params = getParameters(algorithm, crlf, trustStore);
+                ManagerFactoryParameters mfp = new CertPathTrustManagerParameters(params);
+                tmf.init(mfp);
+                tms = tmf.getTrustManagers();
+            }
+        }
+        
+        return tms;
+    }
+    
+    /**
+     * Return the initialization parameters for the TrustManager.
+     * Currently, only the default <code>PKIX</code> is supported.
+     * 
+     * @param algorithm The algorithm to get parameters for.
+     * @param crlf The path to the CRL file.
+     * @param trustStore The configured TrustStore.
+     * @return The parameters including the CRLs and TrustStore.
+     */
+    protected CertPathParameters getParameters(String algorithm, 
+                                                String crlf, 
+                                                KeyStore trustStore)
+        throws Exception {
+        CertPathParameters params = null;
+        if("PKIX".equalsIgnoreCase(algorithm)) {
+            PKIXBuilderParameters xparams = new PKIXBuilderParameters(trustStore, 
+                                                                     new X509CertSelector());
+            Collection crls = getCRLs(crlf);
+            CertStoreParameters csp = new CollectionCertStoreParameters(crls);
+            CertStore store = CertStore.getInstance("Collection", csp);
+            xparams.addCertStore(store);
+            xparams.setRevocationEnabled(true);
+            String trustLength = (String)attributes.get("trustMaxCertLength");
+            if(trustLength != null) {
+                try {
+                    xparams.setMaxPathLength(Integer.parseInt(trustLength));
+                } catch(Exception ex) {
+                    log.warn("Bad maxCertLength: "+trustLength);
+                }
+            }
+
+            params = xparams;
+        } else {
+            throw new CRLException("CRLs not supported for type: "+algorithm);
+        }
+        return params;
+    }
+
+
+    /**
+     * Load the collection of CRLs.
+     * 
+     */
+    protected Collection<? extends CRL> getCRLs(String crlf) 
+        throws IOException, CRLException, CertificateException {
+
+        File crlFile = new File(crlf);
+        if( !crlFile.isAbsolute() ) {
+            crlFile = new File(System.getProperty("catalina.base"), crlf);
+        }
+        Collection<? extends CRL> crls = null;
+        InputStream is = null;
+        try {
+            CertificateFactory cf = CertificateFactory.getInstance("X.509");
+            is = new FileInputStream(crlFile);
+            crls = cf.generateCRLs(is);
+        } catch(IOException iex) {
+            throw iex;
+        } catch(CRLException crle) {
+            throw crle;
+        } catch(CertificateException ce) {
+            throw ce;
+        } finally { 
+            if(is != null) {
+                try{
+                    is.close();
+                } catch(Exception ex) {
+                }
+            }
+        }
+        return crls;
+    }
+
+    /**
+     * Set the SSL protocol variants to be enabled.
+     * @param socket the SSLServerSocket.
+     * @param protocols the protocols to use.
+     */
+    protected void setEnabledProtocols(SSLServerSocket socket, String []protocols){
+        if (protocols != null) {
+            socket.setEnabledProtocols(protocols);
+        }
+    }
+
+    /**
      * Determines the SSL protocol variants to be enabled.
      *
      * @param socket The socket to get supported list from.
@@ -318,16 +557,70 @@ public abstract class JSSESocketFactory
      * @return Array of SSL protocol variants to be enabled, or null if none of
      * the requested protocol variants are supported
      */
-    abstract protected String[] getEnabledProtocols(SSLServerSocket socket,
-                                                    String requestedProtocols);
+    protected String[] getEnabledProtocols(SSLServerSocket socket,
+                                           String requestedProtocols){
+        String[] supportedProtocols = socket.getSupportedProtocols();
 
-    /**
-     * Set the SSL protocol variants to be enabled.
-     * @param socket the SSLServerSocket.
-     * @param protocols the protocols to use.
-     */
-    abstract protected void setEnabledProtocols(SSLServerSocket socket, 
-                                            String [] protocols);
+        String[] enabledProtocols = null;
+
+        if (requestedProtocols != null) {
+            Vector vec = null;
+            String protocol = requestedProtocols;
+            int index = requestedProtocols.indexOf(',');
+            if (index != -1) {
+                int fromIndex = 0;
+                while (index != -1) {
+                    protocol = requestedProtocols.substring(fromIndex, index).trim();
+                    if (protocol.length() > 0) {
+                        /*
+                         * Check to see if the requested protocol is among the
+                         * supported protocols, i.e., may be enabled
+                         */
+                        for (int i=0; supportedProtocols != null
+                                     && i<supportedProtocols.length; i++) {
+                            if (supportedProtocols[i].equals(protocol)) {
+                                if (vec == null) {
+                                    vec = new Vector();
+                                }
+                                vec.addElement(protocol);
+                                break;
+                            }
+                        }
+                    }
+                    fromIndex = index+1;
+                    index = requestedProtocols.indexOf(',', fromIndex);
+                } // while
+                protocol = requestedProtocols.substring(fromIndex);
+            }
+
+            if (protocol != null) {
+                protocol = protocol.trim();
+                if (protocol.length() > 0) {
+                    /*
+                     * Check to see if the requested protocol is among the
+                     * supported protocols, i.e., may be enabled
+                     */
+                    for (int i=0; supportedProtocols != null
+                                 && i<supportedProtocols.length; i++) {
+                        if (supportedProtocols[i].equals(protocol)) {
+                            if (vec == null) {
+                                vec = new Vector();
+                            }
+                            vec.addElement(protocol);
+                            break;
+                        }
+                    }
+                }
+            }           
+
+            if (vec != null) {
+                enabledProtocols = new String[vec.size()];
+                vec.copyInto(enabledProtocols);
+            }
+        }
+
+        return enabledProtocols;
+    }
 
     /**
      * Configure Client authentication for this version of JSSE.  The
@@ -335,7 +628,13 @@ public abstract class JSSESocketFactory
      * versions of JSSE will treat 'want' as 'false'.
      * @param socket the SSLServerSocket
      */
-    abstract protected void configureClientAuth(SSLServerSocket socket);
+    protected void configureClientAuth(SSLServerSocket socket){
+        if (wantClientAuth){
+            socket.setWantClientAuth(wantClientAuth);
+        } else {
+            socket.setNeedClientAuth(requireClientAuth);
+        }
+    }
 
     /**
      * Configure Client authentication for this version of JSSE.  The
@@ -343,7 +642,10 @@ public abstract class JSSESocketFactory
      * versions of JSSE will treat 'want' as 'false'.
      * @param socket the SSLSocket
      */
-    abstract protected void configureClientAuth(SSLSocket socket);
+    protected void configureClientAuth(SSLSocket socket){
+        // Per JavaDocs: SSLSockets returned from 
+        // SSLServerSocket.accept() inherit this setting.
+    }
     
     /**
      * Configures the given SSL server socket with the requested cipher suites,

==================================================
