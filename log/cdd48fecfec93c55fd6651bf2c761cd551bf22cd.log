cdd48fecfec93c55fd6651bf2c761cd551bf22cd
==================================================
Refactor connections as upgraded connections will need to support multiple threads processing the same connection
==================================================
Mark Emlyn
==================================================
Mon Dec 24 11:03:06 2012 +0000
==================================================
AbstractProtocol.java
Refactor connections as upgraded connections will need to support multiple threads processing the same connection

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1425628 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AbstractAjpProtocol.java
index 77d4dace5a..d7a2bbbaa1 100644
--- a/java/org/apache/coyote/AbstractProtocol.java
+++ b/java/org/apache/coyote/AbstractProtocol.java
@@ -581,7 +581,7 @@ public abstract class AbstractProtocol implements ProtocolHandler,
 
         public SocketState process(SocketWrapper<S> socket,
                 SocketStatus status) {
-            Processor<S> processor = connections.remove(socket.getSocket());
+            Processor<S> processor = connections.get(socket.getSocket());
 
             if (status == SocketStatus.DISCONNECT && processor == null) {
                 //nothing more to be done endpoint requested a close
@@ -645,22 +645,27 @@ public abstract class AbstractProtocol implements ProtocolHandler,
                     // In the middle of processing a request/response. Keep the
                     // socket associated with the processor. Exact requirements
                     // depend on type of long poll
+                    connections.put(socket.getSocket(), processor);
                     longPoll(socket, processor);
                 } else if (state == SocketState.OPEN) {
                     // In keep-alive but between requests. OK to recycle
                     // processor. Continue to poll for the next request.
+                    connections.remove(processor);
                     release(socket, processor, false, true);
                 } else if (state == SocketState.SENDFILE) {
                     // Sendfile in progress. If it fails, the socket will be
                     // closed. If it works, the socket will be re-added to the
                     // poller
+                    connections.remove(processor);
                     release(socket, processor, false, false);
                 } else if (state == SocketState.UPGRADED) {
                     // Need to keep the connection associated with the processor
+                    connections.put(socket.getSocket(), processor);
                     longPoll(socket, processor);
                 } else {
                     // Connection closed. OK to recycle the processor. Upgrade
                     // processors are not recycled.
+                    connections.remove(processor);
                     if (!processor.isUpgrade()) {
                         release(socket, processor, true, false);
                     }

==================================================
Http11AprProtocol.java
index e7b3bbf38e..b912d935c0 100644
--- a/java/org/apache/coyote/ajp/AbstractAjpProtocol.java
+++ b/java/org/apache/coyote/ajp/AbstractAjpProtocol.java
@@ -87,7 +87,6 @@ public abstract class AbstractAjpProtocol extends AbstractProtocol {
         protected void longPoll(SocketWrapper<S> socket,
                 Processor<S> processor) {
             // Same requirements for all AJP connectors
-            connections.put(socket.getSocket(), processor);
             socket.setAsync(true);
         }
 

==================================================
Http11NioProtocol.java
index 682873a585..3725623c0d 100644
--- a/java/org/apache/coyote/http11/Http11AprProtocol.java
+++ b/java/org/apache/coyote/http11/Http11AprProtocol.java
@@ -288,7 +288,6 @@ public class Http11AprProtocol extends AbstractHttp11Protocol<Long> {
         @Override
         protected void longPoll(SocketWrapper<Long> socket,
                 Processor<Long> processor) {
-            connections.put(socket.getSocket(), processor);
 
             if (processor.isAsync()) {
                 // Async

==================================================
Http11Protocol.java
index 1d33d85ac4..61c929d536 100644
--- a/java/org/apache/coyote/http11/Http11NioProtocol.java
+++ b/java/org/apache/coyote/http11/Http11NioProtocol.java
@@ -264,7 +264,6 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol<NioChannel> {
         @Override
         protected void longPoll(SocketWrapper<NioChannel> socket,
                 Processor<NioChannel> processor) {
-            connections.put(socket.getSocket(), processor);
 
             if (processor.isAsync()) {
                 socket.setAsync(true);

==================================================
