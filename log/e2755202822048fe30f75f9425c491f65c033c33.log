e2755202822048fe30f75f9425c491f65c033c33
==================================================
Fix trigger of the read event (so registerForEvent is actually useful).
==================================================
Remy Maucherat
==================================================
Fri Apr 4 20:48:55 2014 +0000
==================================================
Http11Nio2Processor.java
Fix trigger of the read event (so registerForEvent is actually useful).

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1584904 13f79535-47bb-0310-9956-ffa450edef68



==================================================
InternalNio2InputBuffer.java
index be40fe1530..4a76d19970 100644
--- a/java/org/apache/coyote/http11/Http11Nio2Processor.java
+++ b/java/org/apache/coyote/http11/Http11Nio2Processor.java
@@ -144,8 +144,12 @@ public class Http11Nio2Processor extends AbstractHttp11Processor<Nio2Channel> {
 
     @Override
     protected void registerForEvent(boolean read, boolean write) {
-        // Nothing to do here, the appropriate operations should
-        // already be pending
+        if (read) {
+            ((InternalNio2InputBuffer) inputBuffer).registerReadInterest();
+        }
+        if (write) {
+            ((InternalNio2OutputBuffer) outputBuffer).registerWriteInterest();
+        }
     }
 
 

==================================================
InternalNio2OutputBuffer.java
index 2ae7277db9..2bde3103d3 100644
--- a/java/org/apache/coyote/http11/InternalNio2InputBuffer.java
+++ b/java/org/apache/coyote/http11/InternalNio2InputBuffer.java
@@ -152,6 +152,11 @@ public class InternalNio2InputBuffer extends AbstractInputBuffer<Nio2Channel> {
      */
     private int socketReadBufferSize;
 
+    /**
+     * Track write interest
+     */
+    protected volatile boolean interest = false;
+
     /**
      * The completion handler used for asynchronous read operations
      */
@@ -202,6 +207,7 @@ public class InternalNio2InputBuffer extends AbstractInputBuffer<Nio2Channel> {
         headerData.recycle();
         readPending = false;
         flipped = false;
+        interest = false;
         e = null;
     }
 
@@ -222,6 +228,7 @@ public class InternalNio2InputBuffer extends AbstractInputBuffer<Nio2Channel> {
         parsingRequestLineStart = 0;
         parsingRequestLineQPos = -1;
         headerData.recycle();
+        interest = false;
     }
 
     /**
@@ -757,7 +764,8 @@ public class InternalNio2InputBuffer extends AbstractInputBuffer<Nio2Channel> {
                         failed(new EOFException(sm.getString("iib.eof.error")), attachment);
                     } else {
                         readPending = false;
-                        if (!Nio2Endpoint.isInline()) {
+                        if ((request.getReadListener() == null || interest) && !Nio2Endpoint.isInline()) {
+                            interest = false;
                             notify = true;
                         }
                     }
@@ -892,6 +900,18 @@ public class InternalNio2InputBuffer extends AbstractInputBuffer<Nio2Channel> {
     }
 
 
+    public void registerReadInterest() {
+        synchronized (completionHandler) {
+            if (readPending) {
+                interest = true;
+            } else {
+                // If no write is pending, notify
+                endpoint.processSocket(socket, SocketStatus.OPEN_READ, true);
+            }
+        }
+    }
+
+
     // ------------------------------------- InputStreamInputBuffer Inner Class
 
 

==================================================
