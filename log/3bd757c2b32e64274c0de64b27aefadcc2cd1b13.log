3bd757c2b32e64274c0de64b27aefadcc2cd1b13
==================================================
Switch to SynchronizedQueue for the event queues
==================================================
Mark Emlyn
==================================================
Wed Sep 26 20:09:35 2012 +0000
==================================================
AbstractProtocol.java
Switch to SynchronizedQueue for the event queues
Switch to SynchronizedStack for the Processor cache
These changes together reduce object allocation during my load test by ~22% compared to prior to these changes

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1390714 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AjpAprProtocol.java
index 7da24f9a4a..cb7c03f19f 100644
--- a/java/org/apache/coyote/AbstractProtocol.java
+++ b/java/org/apache/coyote/AbstractProtocol.java
@@ -19,7 +19,6 @@ package org.apache.coyote;
 import java.io.IOException;
 import java.net.InetAddress;
 import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
@@ -35,6 +34,7 @@ import org.apache.coyote.http11.upgrade.UpgradeInbound;
 import org.apache.coyote.http11.upgrade.UpgradeProcessor;
 import org.apache.juli.logging.Log;
 import org.apache.tomcat.util.ExceptionUtils;
+import org.apache.tomcat.util.collections.SynchronizedStack;
 import org.apache.tomcat.util.modeler.Registry;
 import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler;
@@ -595,7 +595,7 @@ public abstract class AbstractProtocol implements ProtocolHandler,
 
             try {
                 if (processor == null) {
-                    processor = recycledProcessors.poll();
+                    processor = recycledProcessors.pop();
                 }
                 if (processor == null) {
                     processor = createProcessor();
@@ -750,9 +750,8 @@ public abstract class AbstractProtocol implements ProtocolHandler,
     }
 
     protected static class RecycledProcessors<P extends Processor<S>, S>
-            extends ConcurrentLinkedQueue<Processor<S>> {
+            extends SynchronizedStack<Processor<S>> {
 
-        private static final long serialVersionUID = 1L;
         private final transient AbstractConnectionHandler<S,P> handler;
         protected final AtomicInteger size = new AtomicInteger(0);
 
@@ -761,13 +760,13 @@ public abstract class AbstractProtocol implements ProtocolHandler,
         }
 
         @Override
-        public boolean offer(Processor<S> processor) {
+        public boolean push(Processor<S> processor) {
             int cacheSize = handler.getProtocol().getProcessorCache();
             boolean offer = cacheSize == -1 ? true : size.get() < cacheSize;
             //avoid over growing our cache or add after we have stopped
             boolean result = false;
             if (offer) {
-                result = super.offer(processor);
+                result = super.push(processor);
                 if (result) {
                     size.incrementAndGet();
                 }
@@ -777,8 +776,8 @@ public abstract class AbstractProtocol implements ProtocolHandler,
         }
 
         @Override
-        public Processor<S> poll() {
-            Processor<S> result = super.poll();
+        public Processor<S> pop() {
+            Processor<S> result = super.pop();
             if (result != null) {
                 size.decrementAndGet();
             }
@@ -787,10 +786,10 @@ public abstract class AbstractProtocol implements ProtocolHandler,
 
         @Override
         public void clear() {
-            Processor<S> next = poll();
+            Processor<S> next = pop();
             while (next != null) {
                 handler.unregister(next);
-                next = poll();
+                next = pop();
             }
             super.clear();
             size.set(0);

==================================================
AjpNioProtocol.java
index 14a1dec6ba..8dfa39c31d 100644
--- a/java/org/apache/coyote/ajp/AjpAprProtocol.java
+++ b/java/org/apache/coyote/ajp/AjpAprProtocol.java
@@ -131,7 +131,7 @@ public class AjpAprProtocol extends AbstractAjpProtocol {
                 Processor<Long> processor, boolean isSocketClosing,
                 boolean addToPoller) {
             processor.recycle(isSocketClosing);
-            recycledProcessors.offer(processor);
+            recycledProcessors.push(processor);
             if (addToPoller) {
                 ((AprEndpoint)proto.endpoint).getPoller().add(
                         socket.getSocket().longValue(),

==================================================
AjpProtocol.java
index 897c51bd9c..5f273cca1e 100644
--- a/java/org/apache/coyote/ajp/AjpNioProtocol.java
+++ b/java/org/apache/coyote/ajp/AjpNioProtocol.java
@@ -149,7 +149,7 @@ public class AjpNioProtocol extends AbstractAjpProtocol {
             Processor<NioChannel> processor = connections.remove(socket);
             if (processor != null) {
                 processor.recycle(true);
-                recycledProcessors.offer(processor);
+                recycledProcessors.push(processor);
             }
         }
 
@@ -162,7 +162,7 @@ public class AjpNioProtocol extends AbstractAjpProtocol {
                 Processor<NioChannel> processor, boolean isSocketClosing,
                 boolean addToPoller) {
             processor.recycle(isSocketClosing);
-            recycledProcessors.offer(processor);
+            recycledProcessors.push(processor);
             if (addToPoller) {
                 socket.getSocket().getPoller().add(socket.getSocket());
             }

==================================================
Http11AprProtocol.java
index c4ef0e62ed..c7aa38f65b 100644
--- a/java/org/apache/coyote/ajp/AjpProtocol.java
+++ b/java/org/apache/coyote/ajp/AjpProtocol.java
@@ -125,7 +125,7 @@ public class AjpProtocol extends AbstractAjpProtocol {
                 Processor<Socket> processor, boolean isSocketClosing,
                 boolean addToPoller) {
             processor.recycle(isSocketClosing);
-            recycledProcessors.offer(processor);
+            recycledProcessors.push(processor);
         }
 
 

==================================================
Http11NioProtocol.java
index 62841bcd3b..1df1c6d76b 100644
--- a/java/org/apache/coyote/http11/Http11AprProtocol.java
+++ b/java/org/apache/coyote/http11/Http11AprProtocol.java
@@ -247,7 +247,7 @@ public class Http11AprProtocol extends AbstractHttp11Protocol<Long> {
                 Processor<Long> processor, boolean isSocketClosing,
                 boolean addToPoller) {
             processor.recycle(isSocketClosing);
-            recycledProcessors.offer(processor);
+            recycledProcessors.push(processor);
             if (addToPoller && proto.endpoint.isRunning()) {
                 ((AprEndpoint)proto.endpoint).getPoller().add(
                         socket.getSocket().longValue(),

==================================================
Http11Protocol.java
index 6fe35ddcf8..d93390554d 100644
--- a/java/org/apache/coyote/http11/Http11NioProtocol.java
+++ b/java/org/apache/coyote/http11/Http11NioProtocol.java
@@ -207,7 +207,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol<NioChannel> {
                 connections.remove(socket.getSocket());
             if (processor != null) {
                 processor.recycle(true);
-                recycledProcessors.offer(processor);
+                recycledProcessors.push(processor);
             }
         }
 
@@ -238,7 +238,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol<NioChannel> {
                 Processor<NioChannel> processor, boolean isSocketClosing,
                 boolean addToPoller) {
             processor.recycle(isSocketClosing);
-            recycledProcessors.offer(processor);
+            recycledProcessors.push(processor);
             if (addToPoller) {
                 socket.getSocket().getPoller().add(socket.getSocket());
             }

==================================================
SynchronizedStack.java
index 402ece2ebe..e95557217a 100644
--- a/java/org/apache/coyote/http11/Http11Protocol.java
+++ b/java/org/apache/coyote/http11/Http11Protocol.java
@@ -159,7 +159,7 @@ public class Http11Protocol extends AbstractHttp11JsseProtocol<Socket> {
                 Processor<Socket> processor, boolean isSocketClosing,
                 boolean addToPoller) {
             processor.recycle(isSocketClosing);
-            recycledProcessors.offer(processor);
+            recycledProcessors.push(processor);
         }
 
         @Override

==================================================
NioBlockingSelector.java
index 7c602038cb..5a6e73473e 100644
--- a/java/org/apache/tomcat/util/collections/SynchronizedStack.java
+++ b/java/org/apache/tomcat/util/collections/SynchronizedStack.java
@@ -50,17 +50,18 @@ public class SynchronizedStack<T> {
     }
 
 
-    public synchronized void push(T obj) {
+    public synchronized boolean push(T obj) {
         index++;
         if (index == size) {
             if (limit == -1 || size < limit) {
                 expand();
             } else {
                 index--;
-                return;
+                return false;
             }
         }
         stack[index] = obj;
+        return true;
     }
 
     @SuppressWarnings("unchecked")

==================================================
NioEndpoint.java
index c5bd22a3ef..4a654c158b 100644
--- a/java/org/apache/tomcat/util/net/NioBlockingSelector.java
+++ b/java/org/apache/tomcat/util/net/NioBlockingSelector.java
@@ -26,7 +26,6 @@ import java.nio.channels.SelectionKey;
 import java.nio.channels.Selector;
 import java.nio.channels.SocketChannel;
 import java.util.Iterator;
-import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -34,6 +33,7 @@ import java.util.concurrent.atomic.AtomicInteger;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.ExceptionUtils;
+import org.apache.tomcat.util.collections.SynchronizedQueue;
 import org.apache.tomcat.util.collections.SynchronizedStack;
 import org.apache.tomcat.util.net.NioEndpoint.KeyAttachment;
 
@@ -215,8 +215,8 @@ public class NioBlockingSelector {
     protected static class BlockPoller extends Thread {
         protected volatile boolean run = true;
         protected Selector selector = null;
-        protected final ConcurrentLinkedQueue<Runnable> events =
-                new ConcurrentLinkedQueue<>();
+        protected final SynchronizedQueue<Runnable> events =
+                new SynchronizedQueue<>();
         public void disable() { run = false; selector.wakeup();}
         protected final AtomicInteger wakeupCounter = new AtomicInteger(0);
         public void cancelKey(final SelectionKey key) {
@@ -414,5 +414,4 @@ public class NioBlockingSelector {
             key = null;
         }
     }
-
 }

==================================================
