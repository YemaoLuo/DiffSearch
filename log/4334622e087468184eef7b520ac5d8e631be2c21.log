4334622e087468184eef7b520ac5d8e631be2c21
==================================================
Fix BZ 66076. Non-blocking flush with TLS+NIO must flush network buffer
==================================================
Mark Thomas
==================================================
Mon May 23 10:17:02 2022 +0100
==================================================
NioEndpoint.java
Fix BZ 66076. Non-blocking flush with TLS+NIO must flush network buffer

https://bz.apache.org/bugzilla/show_bug.cgi?id=66076



==================================================
SocketWrapperBase.java
index e8348e90f0..d074153bbc 100644
--- a/java/org/apache/tomcat/util/net/NioEndpoint.java
+++ b/java/org/apache/tomcat/util/net/NioEndpoint.java
@@ -1295,20 +1295,20 @@ public class NioEndpoint extends AbstractJsseEndpoint<NioChannel,SocketChannel>
 
         @Override
         protected boolean flushNonBlocking() throws IOException {
-            boolean dataLeft = !socketBufferHandler.isWriteBufferEmpty();
+            boolean dataLeft = socketOrNetworkBufferHasDataLeft();
 
             // Write to the socket, if there is anything to write
             if (dataLeft) {
                 doWrite(false);
-                dataLeft = !socketBufferHandler.isWriteBufferEmpty();
+                dataLeft = socketOrNetworkBufferHasDataLeft();
             }
 
             if (!dataLeft && !nonBlockingWriteBuffer.isEmpty()) {
                 dataLeft = nonBlockingWriteBuffer.write(this, false);
 
-                if (!dataLeft && !socketBufferHandler.isWriteBufferEmpty()) {
+                if (!dataLeft && socketOrNetworkBufferHasDataLeft()) {
                     doWrite(false);
-                    dataLeft = !socketBufferHandler.isWriteBufferEmpty();
+                    dataLeft = socketOrNetworkBufferHasDataLeft();
                 }
             }
 
@@ -1316,6 +1316,22 @@ public class NioEndpoint extends AbstractJsseEndpoint<NioChannel,SocketChannel>
         }
 
 
+        /*
+         * https://bz.apache.org/bugzilla/show_bug.cgi?id=66076
+         *
+         * When using TLS an additional buffer is used for the encrypted data
+         * before it is written to the network. It is possible for this network
+         * output buffer to contain data while the socket write buffer is empty.
+         *
+         * For NIO with non-blocking I/O, this case is handling by ensuring that
+         * flush only returns false (i.e. no data left to flush) if all buffers
+         * are empty.
+         */
+        private boolean socketOrNetworkBufferHasDataLeft() {
+            return !socketBufferHandler.isWriteBufferEmpty() || getSocket().getOutboundRemaining() > 0;
+        }
+
+
         @Override
         protected void doWrite(boolean block, ByteBuffer buffer) throws IOException {
             int n = 0;
@@ -1556,6 +1572,11 @@ public class NioEndpoint extends AbstractJsseEndpoint<NioChannel,SocketChannel>
                 return inline;
             }
 
+            @Override
+            protected boolean hasOutboundRemaining() {
+                return getSocket().getOutboundRemaining() > 0;
+            }
+
             @Override
             public void run() {
                 // Perform the IO operation
@@ -1588,13 +1609,13 @@ public class NioEndpoint extends AbstractJsseEndpoint<NioChannel,SocketChannel>
                             } else {
                                 boolean doWrite = true;
                                 // Write from main buffer first
-                                if (!socketBufferHandler.isWriteBufferEmpty()) {
+                                if (socketOrNetworkBufferHasDataLeft()) {
                                     // There is still data inside the main write buffer, it needs to be written first
                                     socketBufferHandler.configureWriteBufferForRead();
                                     do {
                                         nBytes = getSocket().write(socketBufferHandler.getWriteBuffer());
-                                    } while (!socketBufferHandler.isWriteBufferEmpty() && nBytes > 0);
-                                    if (!socketBufferHandler.isWriteBufferEmpty()) {
+                                    } while (socketOrNetworkBufferHasDataLeft() && nBytes > 0);
+                                    if (socketOrNetworkBufferHasDataLeft()) {
                                         doWrite = false;
                                     }
                                     // Preserve a negative value since it is an error
@@ -1615,7 +1636,8 @@ public class NioEndpoint extends AbstractJsseEndpoint<NioChannel,SocketChannel>
                                     updateLastWrite();
                                 }
                             }
-                            if (nBytes != 0 || !buffersArrayHasRemaining(buffers, offset, length)) {
+                            if (nBytes != 0 || (!buffersArrayHasRemaining(buffers, offset, length) &&
+                                    !socketOrNetworkBufferHasDataLeft())) {
                                 completionDone = false;
                             }
                         }
@@ -1623,7 +1645,8 @@ public class NioEndpoint extends AbstractJsseEndpoint<NioChannel,SocketChannel>
                         setError(e);
                     }
                 }
-                if (nBytes > 0 || (nBytes == 0 && !buffersArrayHasRemaining(buffers, offset, length))) {
+                if (nBytes > 0 || (nBytes == 0 && !buffersArrayHasRemaining(buffers, offset, length) &&
+                        !socketOrNetworkBufferHasDataLeft())) {
                     // The bytes processed are only updated in the completion handler
                     completion.completed(Long.valueOf(nBytes), this);
                 } else if (nBytes < 0 || getError() != null) {
@@ -1642,9 +1665,7 @@ public class NioEndpoint extends AbstractJsseEndpoint<NioChannel,SocketChannel>
                     }
                 }
             }
-
         }
-
     }
 
 

==================================================
