274045ff1ceca9b76198bf6249070c42a0dc2f7c
==================================================
Take into account that executors can be provided, standard and non standard thread pool executors through config or programmatically.
==================================================
Filip Hanik
==================================================
Tue Jun 9 18:58:25 2009 +0000
==================================================
AprEndpoint.java
Take into account that executors can be provided, standard and non standard thread pool executors through config or programmatically.
Hence we want to expose the correct values for curThread and curThreadBusy



git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@783095 13f79535-47bb-0310-9956-ffa450edef68



==================================================
JIoEndpoint.java
index e79b9b2364..3191ae10e1 100644
--- a/java/org/apache/tomcat/util/net/AprEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AprEndpoint.java
@@ -17,10 +17,12 @@
 
 package org.apache.tomcat.util.net;
 
+import java.lang.reflect.Method;
 import java.net.InetAddress;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.concurrent.Executor;
+import java.util.concurrent.ThreadPoolExecutor;
 
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
@@ -36,6 +38,7 @@ import org.apache.tomcat.jni.SSLContext;
 import org.apache.tomcat.jni.SSLSocket;
 import org.apache.tomcat.jni.Socket;
 import org.apache.tomcat.jni.Status;
+import org.apache.tomcat.util.IntrospectionUtils;
 import org.apache.tomcat.util.res.StringManager;
 
 /**
@@ -538,27 +541,62 @@ public class AprEndpoint {
         }
     }
 
-
     /**
      * Return the amount of threads that are managed by the pool.
      *
      * @return the amount of threads that are managed by the pool
      */
     public int getCurrentThreadCount() {
-        return curThreads;
+        if (executor!=null) {
+            if (executor instanceof ThreadPoolExecutor) {
+                return ((ThreadPoolExecutor)executor).getPoolSize();
+            } else {
+                try {
+                    Method m = IntrospectionUtils.findMethod(executor.getClass(), "getPoolSize", new Class[] {}); 
+                    if (m!=null) {
+                        return ((Integer)m.invoke(executor, null)).intValue();
+                    } else {
+                        return -1;
+                    }
+                }catch (Exception ignore) {
+                    if (log.isDebugEnabled()) 
+                        log.debug("Unable to invoke getPoolSize",ignore);
+                    return -2;
+                }
+            }
+        } else {
+            return curThreads;
+        }
     }
 
-
     /**
-     * Return the amount of threads currently busy.
+     * Return the amount of threads that are in use 
      *
-     * @return the amount of threads currently busy
+     * @return the amount of threads that are in use
      */
     public int getCurrentThreadsBusy() {
-        return curThreadsBusy;
+        if (executor!=null) {
+            if (executor instanceof ThreadPoolExecutor) {
+                return ((ThreadPoolExecutor)executor).getActiveCount();
+            } else {
+                try {
+                    Method m = IntrospectionUtils.findMethod(executor.getClass(), "getActiveCount", new Class[] {}); 
+                    if (m!=null) {
+                        return ((Integer)m.invoke(executor, null)).intValue();
+                    } else {
+                        return -1;
+                    }
+                }catch (Exception ignore) {
+                    if (log.isDebugEnabled()) 
+                        log.debug("Unable to invoke getActiveCount",ignore);
+                    return -2;
+                }
+            }
+        } else {
+            return workers!=null?curThreads - workers.size():0;
+        }
     }
-
-
+    
     /**
      * Return the state of the endpoint.
      *

==================================================
NioEndpoint.java
index 0f37289190..349a172e90 100644
--- a/java/org/apache/tomcat/util/net/JIoEndpoint.java
+++ b/java/org/apache/tomcat/util/net/JIoEndpoint.java
@@ -18,11 +18,13 @@
 package org.apache.tomcat.util.net;
 
 import java.io.IOException;
+import java.lang.reflect.Method;
 import java.net.BindException;
 import java.net.InetAddress;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.util.concurrent.Executor;
+import java.util.concurrent.ThreadPoolExecutor;
 
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
@@ -297,12 +299,60 @@ public class JIoEndpoint {
         return paused;
     }
     
+    /**
+     * Return the amount of threads that are managed by the pool.
+     *
+     * @return the amount of threads that are managed by the pool
+     */
     public int getCurrentThreadCount() {
-        return curThreads;
+        if (executor!=null) {
+            if (executor instanceof ThreadPoolExecutor) {
+                return ((ThreadPoolExecutor)executor).getPoolSize();
+            } else {
+                try {
+                    Method m = IntrospectionUtils.findMethod(executor.getClass(), "getPoolSize", new Class[] {}); 
+                    if (m!=null) {
+                        return ((Integer)m.invoke(executor, null)).intValue();
+                    } else {
+                        return -1;
+                    }
+                }catch (Exception ignore) {
+                    if (log.isDebugEnabled()) 
+                        log.debug("Unable to invoke getPoolSize",ignore);
+                    return -2;
+                }
+            }
+        } else {
+            return curThreads;
+        }
     }
-    
+
+    /**
+     * Return the amount of threads that are in use 
+     *
+     * @return the amount of threads that are in use
+     */
     public int getCurrentThreadsBusy() {
-        return workers!=null?curThreads - workers.size():0;
+        if (executor!=null) {
+            if (executor instanceof ThreadPoolExecutor) {
+                return ((ThreadPoolExecutor)executor).getActiveCount();
+            } else {
+                try {
+                    Method m = IntrospectionUtils.findMethod(executor.getClass(), "getActiveCount", new Class[] {}); 
+                    if (m!=null) {
+                        return ((Integer)m.invoke(executor, null)).intValue();
+                    } else {
+                        return -1;
+                    }
+                }catch (Exception ignore) {
+                    if (log.isDebugEnabled()) 
+                        log.debug("Unable to invoke getActiveCount",ignore);
+                    return -2;
+                }
+            }
+        } else {
+            return workers!=null?curThreads - workers.size():0;
+        }
     }
     
 

==================================================
