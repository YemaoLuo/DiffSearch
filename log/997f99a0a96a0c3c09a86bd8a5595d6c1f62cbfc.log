997f99a0a96a0c3c09a86bd8a5595d6c1f62cbfc
==================================================
Additional fix for BZ 64192.
==================================================
Mark Thomas
==================================================
Wed Mar 4 15:05:00 2020 +0000
==================================================
SecureNio2Channel.java
Additional fix for BZ 64192.

https://bz.apache.org/bugzilla/show_bug.cgi?id=64192
It was noted during investigation of BZ 64192 that inconsistent values
were being returned for the number of bytes read.


==================================================
SecureNioChannel.java
index 54d9e0302d..d3a0b732ea 100644
--- a/java/org/apache/tomcat/util/net/SecureNio2Channel.java
+++ b/java/org/apache/tomcat/util/net/SecureNio2Channel.java
@@ -1011,13 +1011,11 @@ public class SecureNio2Channel extends Nio2Channel  {
                         SSLEngineResult unwrap;
                         ByteBuffer[] dsts2 = dsts;
                         int length2 = length;
-                        boolean processOverflow = false;
+                        OverflowState overflowState = OverflowState.NONE;
                         do {
-                            boolean useOverflow = false;
-                            if (processOverflow) {
-                                useOverflow = true;
+                            if (overflowState == OverflowState.PROCESSING) {
+                                overflowState = OverflowState.DONE;
                             }
-                            processOverflow = false;
                             //prepare the buffer
                             netInBuffer.flip();
                             //unwrap the data
@@ -1027,7 +1025,7 @@ public class SecureNio2Channel extends Nio2Channel  {
                             if (unwrap.getStatus() == Status.OK || unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {
                                 //we did receive some data, add it to our total
                                 read += unwrap.bytesProduced();
-                                if (useOverflow) {
+                                if (overflowState == OverflowState.DONE) {
                                     // Remove the data read into the overflow buffer
                                     read -= getBufHandler().getReadBuffer().position();
                                 }
@@ -1091,14 +1089,15 @@ public class SecureNio2Channel extends Nio2Channel  {
                                     }
                                     length2 = length + 1;
                                     getBufHandler().configureReadBufferForWrite();
-                                    processOverflow = true;
+                                    overflowState = OverflowState.PROCESSING;
                                 }
                             } else if (unwrap.getStatus() == Status.CLOSED) {
                                 break;
                             } else {
                                 throw new IOException(sm.getString("channel.nio.ssl.unwrapFail", unwrap.getStatus()));
                             }
-                        } while ((netInBuffer.position() != 0) || processOverflow); //continue to unwrapping as long as the input buffer has stuff
+                        } while ((netInBuffer.position() != 0 || overflowState == OverflowState.PROCESSING) &&
+                                overflowState != OverflowState.DONE);
                         int capacity = 0;
                         final int endOffset = offset + length;
                         for (int i = offset; i < endOffset; i++) {
@@ -1248,4 +1247,11 @@ public class SecureNio2Channel extends Nio2Channel  {
     public ByteBuffer getEmptyBuf() {
         return emptyBuf;
     }
+
+
+    private enum OverflowState {
+        NONE,
+        PROCESSING,
+        DONE;
+    }
 }
\ No newline at end of file

==================================================
