b608043427b3c7defd25403b38c8c922d0520080
==================================================
Extend the fix for large headers to push requests.
==================================================
Mark Thomas
==================================================
Wed May 3 17:30:06 2017 +0000
==================================================
Http2AsyncUpgradeHandler.java
Extend the fix for large headers to push requests.
Align the header writing implementations a little, with a view to refactoring

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1793682 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Http2UpgradeHandler.java
index ba3a3e09ce..125c63b139 100644
--- a/java/org/apache/coyote/http2/Http2AsyncUpgradeHandler.java
+++ b/java/org/apache/coyote/http2/Http2AsyncUpgradeHandler.java
@@ -193,34 +193,39 @@ public class Http2AsyncUpgradeHandler extends Http2UpgradeHandler {
             log.debug(sm.getString("upgradeHandler.writePushHeaders", connectionId,
                     stream.getIdentifier(), Integer.toString(pushedStreamId)));
         }
-        // This ensures the Stream processing thread has control of the socket.
+
         boolean first = true;
         State state = null;
         ArrayList<ByteBuffer> bufs = new ArrayList<>();
         byte[] pushedStreamIdBytes = new byte[4];
         ByteUtil.set31Bits(pushedStreamIdBytes, 0, pushedStreamId);
+        // This ensures the Stream processing thread has control of the socket.
         while (state != State.COMPLETE) {
             byte[] header = new byte[9];
             ByteBuffer target = ByteBuffer.allocate(payloadSize);
             target.put(pushedStreamIdBytes);
             state = getHpackEncoder().encode(coyoteRequest.getMimeHeaders(), target);
             target.flip();
-            ByteUtil.setThreeBytes(header, 0, target.limit());
-            if (first) {
-                first = false;
-                header[3] = FrameType.PUSH_PROMISE.getIdByte();
-            } else {
-                header[3] = FrameType.CONTINUATION.getIdByte();
-            }
-            if (state == State.COMPLETE) {
-                header[4] += FLAG_END_OF_HEADERS;
-            }
-            if (log.isDebugEnabled()) {
-                log.debug(target.limit() + " bytes");
+            if (state == State.COMPLETE || target.limit() > 0) {
+                ByteUtil.setThreeBytes(header, 0, target.limit());
+                if (first) {
+                    first = false;
+                    header[3] = FrameType.PUSH_PROMISE.getIdByte();
+                } else {
+                    header[3] = FrameType.CONTINUATION.getIdByte();
+                }
+                if (state == State.COMPLETE) {
+                    header[4] += FLAG_END_OF_HEADERS;
+                }
+                if (log.isDebugEnabled()) {
+                    log.debug(target.limit() + " bytes");
+                }
+                ByteUtil.set31Bits(header, 5, stream.getIdentifier().intValue());
+                bufs.add(ByteBuffer.wrap(header));
+                bufs.add(target);
+            } else if (state == State.UNDERFLOW) {
+                payloadSize = payloadSize * 2;
             }
-            ByteUtil.set31Bits(header, 5, stream.getIdentifier().intValue());
-            bufs.add(ByteBuffer.wrap(header));
-            bufs.add(target);
         }
         socketWrapper.write(BlockingMode.SEMI_BLOCK, getWriteTimeout(), TimeUnit.MILLISECONDS,
                 null, SocketWrapperBase.COMPLETE_WRITE, applicationErrorCompletion,

==================================================
