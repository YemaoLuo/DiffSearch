93f5911c0c80c081e5d080de14f02f35ae637592
==================================================
Refactored check for preemptive authentication
==================================================
Robert Rodewald
==================================================
Tue Aug 10 19:11:24 2021 +0200
==================================================
AuthenticatorBase.java
Refactored check for preemptive authentication

- new protected method isPreemptiveAuthPossible() in AuthenticatorBase
  which is overridden in some authenticators
- moved getRequestCertificates() from AuthenticatorBase to
  SSLAuthenticator
- Added more specific check for value of header "authorization"



==================================================
BasicAuthenticator.java
index d75158270f..4a26b51bdb 100644
--- a/java/org/apache/catalina/authenticator/AuthenticatorBase.java
+++ b/java/org/apache/catalina/authenticator/AuthenticatorBase.java
@@ -18,7 +18,6 @@ package org.apache.catalina.authenticator;
 
 import java.io.IOException;
 import java.security.Principal;
-import java.security.cert.X509Certificate;
 import java.util.Locale;
 import java.util.Map;
 import java.util.Optional;
@@ -62,7 +61,6 @@ import org.apache.catalina.util.SessionIdGeneratorBase;
 import org.apache.catalina.util.StandardSessionIdGenerator;
 import org.apache.catalina.valves.RemoteIpValve;
 import org.apache.catalina.valves.ValveBase;
-import org.apache.coyote.ActionCode;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.ExceptionUtils;
@@ -597,15 +595,9 @@ public abstract class AuthenticatorBase extends ValveBase
             authRequired = true;
         }
 
-        if (!authRequired && context.getPreemptiveAuthentication()) {
-            authRequired =
-                    request.getCoyoteRequest().getMimeHeaders().getValue("authorization") != null;
-        }
-
         if (!authRequired && context.getPreemptiveAuthentication() &&
-                HttpServletRequest.CLIENT_CERT_AUTH.equals(getAuthMethod())) {
-            X509Certificate[] certs = getRequestCertificates(request);
-            authRequired = certs != null && certs.length > 0;
+                isPreemptiveAuthPossible(request)) {
+            authRequired = true;
         }
 
         JaspicState jaspicState = null;
@@ -862,35 +854,6 @@ public abstract class AuthenticatorBase extends ValveBase
     }
 
 
-    /**
-     * Look for the X509 certificate chain in the Request under the key
-     * <code>jakarta.servlet.request.X509Certificate</code>. If not found, trigger
-     * extracting the certificate chain from the Coyote request.
-     *
-     * @param request
-     *            Request to be processed
-     *
-     * @return The X509 certificate chain if found, <code>null</code> otherwise.
-     */
-    protected X509Certificate[] getRequestCertificates(final Request request)
-            throws IllegalStateException {
-
-        X509Certificate certs[] =
-                (X509Certificate[]) request.getAttribute(Globals.CERTIFICATES_ATTR);
-
-        if ((certs == null) || (certs.length < 1)) {
-            try {
-                request.getCoyoteRequest().action(ActionCode.REQ_SSL_CERTIFICATE, null);
-                certs = (X509Certificate[]) request.getAttribute(Globals.CERTIFICATES_ATTR);
-            } catch (IllegalStateException ise) {
-                // Request body was too large for save buffer
-                // Return null which will trigger an auth failure
-            }
-        }
-
-        return certs;
-    }
-
     /**
      * Associate the specified single sign on identifier with the specified
      * Session.
@@ -1387,6 +1350,7 @@ public abstract class AuthenticatorBase extends ValveBase
         super.startInternal();
     }
 
+
     /**
      * Stop this component and implement the requirements of
      * {@link org.apache.catalina.util.LifecycleBase#stopInternal()}.
@@ -1404,6 +1368,20 @@ public abstract class AuthenticatorBase extends ValveBase
     }
 
 
+    /**
+     * Can the authenticator perform preemptive authentication for the given
+     * request?
+     *
+     * @param request
+     *
+     * @return {@code true} if preemptive authentication is possible, otherwise
+     *         {@code false}
+     */
+    protected boolean isPreemptiveAuthPossible(Request request) {
+        return false;
+    }
+
+
     private AuthConfigProvider getJaspicProvider() {
         Optional<AuthConfigProvider> provider = jaspicProvider;
         if (provider == null) {

==================================================
DigestAuthenticator.java
index 55a7b88f1d..a1f9c86af4 100644
--- a/java/org/apache/catalina/authenticator/BasicAuthenticator.java
+++ b/java/org/apache/catalina/authenticator/BasicAuthenticator.java
@@ -127,12 +127,20 @@ public class BasicAuthenticator extends AuthenticatorBase {
 
     }
 
+
     @Override
     protected String getAuthMethod() {
         return HttpServletRequest.BASIC_AUTH;
     }
 
 
+    @Override
+    protected boolean isPreemptiveAuthPossible(Request request) {
+        MessageBytes authorizationHeader = request.getCoyoteRequest().getMimeHeaders().getValue("authorization");
+        return authorizationHeader != null && authorizationHeader.startsWithIgnoreCase("basic ", 0);
+    }
+
+
     /**
      * Parser for an HTTP Authorization header for BASIC authentication
      * as per RFC 2617 section 2, and the Base64 encoded credentials as

==================================================
SSLAuthenticator.java
index a66b047422..b08a249866 100644
--- a/java/org/apache/catalina/authenticator/DigestAuthenticator.java
+++ b/java/org/apache/catalina/authenticator/DigestAuthenticator.java
@@ -31,6 +31,7 @@ import org.apache.catalina.Realm;
 import org.apache.catalina.connector.Request;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
+import org.apache.tomcat.util.buf.MessageBytes;
 import org.apache.tomcat.util.http.parser.Authorization;
 import org.apache.tomcat.util.security.ConcurrentMessageDigest;
 import org.apache.tomcat.util.security.MD5Encoder;
@@ -367,6 +368,13 @@ public class DigestAuthenticator extends AuthenticatorBase {
     }
 
 
+    @Override
+    protected boolean isPreemptiveAuthPossible(Request request) {
+        MessageBytes authorizationHeader = request.getCoyoteRequest().getMimeHeaders().getValue("authorization");
+        return authorizationHeader != null && authorizationHeader.startsWithIgnoreCase("digest ", 0);
+    }
+
+
     // ------------------------------------------------------- Lifecycle Methods
 
     @Override

==================================================
SpnegoAuthenticator.java
index 90142ccd35..bb5ffcd6fc 100644
--- a/java/org/apache/catalina/authenticator/SSLAuthenticator.java
+++ b/java/org/apache/catalina/authenticator/SSLAuthenticator.java
@@ -23,7 +23,9 @@ import java.security.cert.X509Certificate;
 import jakarta.servlet.http.HttpServletRequest;
 import jakarta.servlet.http.HttpServletResponse;
 
+import org.apache.catalina.Globals;
 import org.apache.catalina.connector.Request;
+import org.apache.coyote.ActionCode;
 
 /**
  * An <b>Authenticator</b> and <b>Valve</b> implementation of authentication
@@ -100,4 +102,41 @@ public class SSLAuthenticator extends AuthenticatorBase {
     protected String getAuthMethod() {
         return HttpServletRequest.CLIENT_CERT_AUTH;
     }
+
+
+    @Override
+    protected boolean isPreemptiveAuthPossible(Request request) {
+        X509Certificate[] certs = getRequestCertificates(request);
+        return certs != null && certs.length > 0;
+    }
+
+
+    /**
+     * Look for the X509 certificate chain in the Request under the key
+     * <code>jakarta.servlet.request.X509Certificate</code>. If not found, trigger
+     * extracting the certificate chain from the Coyote request.
+     *
+     * @param request
+     *            Request to be processed
+     *
+     * @return The X509 certificate chain if found, <code>null</code> otherwise.
+     */
+    protected X509Certificate[] getRequestCertificates(final Request request)
+            throws IllegalStateException {
+
+        X509Certificate certs[] =
+                (X509Certificate[]) request.getAttribute(Globals.CERTIFICATES_ATTR);
+
+        if ((certs == null) || (certs.length < 1)) {
+            try {
+                request.getCoyoteRequest().action(ActionCode.REQ_SSL_CERTIFICATE, null);
+                certs = (X509Certificate[]) request.getAttribute(Globals.CERTIFICATES_ATTR);
+            } catch (IllegalStateException ise) {
+                // Request body was too large for save buffer
+                // Return null which will trigger an auth failure
+            }
+        }
+
+        return certs;
+    }
 }

==================================================
