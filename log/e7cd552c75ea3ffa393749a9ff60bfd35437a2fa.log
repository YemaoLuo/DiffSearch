e7cd552c75ea3ffa393749a9ff60bfd35437a2fa
==================================================
Code clean-up. Reformatting. No functional change.
==================================================
Mark Thomas
==================================================
Wed Mar 22 17:36:02 2023 +0000
==================================================
FarmWarDeployer.java
Code clean-up. Reformatting. No functional change.


==================================================
FileChangeListener.java
index 90cb979243..0c07a8ac13 100644
--- a/java/org/apache/catalina/ha/deploy/FarmWarDeployer.java
+++ b/java/org/apache/catalina/ha/deploy/FarmWarDeployer.java
@@ -41,23 +41,19 @@ import org.apache.tomcat.util.res.StringManager;
 
 /**
  * <p>
- * A farm war deployer is a class that is able to deploy/undeploy web
- * applications in WAR from within the cluster.
+ * A farm war deployer is a class that is able to deploy/undeploy web applications in WAR from within the cluster.
  * </p>
  * Any host can act as the admin, and will have three directories
  * <ul>
  * <li>watchDir - the directory where we watch for changes</li>
  * <li>deployDir - the directory where we install applications</li>
- * <li>tempDir - a temporaryDirectory to store binary data when downloading a
- * war from the cluster</li>
+ * <li>tempDir - a temporaryDirectory to store binary data when downloading a war from the cluster</li>
  * </ul>
- * Currently we only support deployment of WAR files since they are easier to
- * send across the wire.
+ * Currently we only support deployment of WAR files since they are easier to send across the wire.
  *
  * @author Peter Rossbach
  */
-public class FarmWarDeployer extends ClusterListener
-        implements ClusterDeployer, FileChangeListener {
+public class FarmWarDeployer extends ClusterListener implements ClusterDeployer, FileChangeListener {
     /*--Static Variables----------------------------------------*/
     private static final Log log = LogFactory.getLog(FarmWarDeployer.class);
     private static final StringManager sm = StringManager.getManager(FarmWarDeployer.class);
@@ -65,8 +61,7 @@ public class FarmWarDeployer extends ClusterListener
     /*--Instance Variables--------------------------------------*/
     protected boolean started = false;
 
-    protected final HashMap<String, FileMessageFactory> fileFactories =
-        new HashMap<>();
+    protected final HashMap<String, FileMessageFactory> fileFactories = new HashMap<>();
 
     /**
      * Deployment directory.
@@ -96,9 +91,8 @@ public class FarmWarDeployer extends ClusterListener
     private int count = 0;
 
     /**
-     * Frequency of the Farm watchDir check. Cluster wide deployment will be
-     * done once for the specified amount of backgroundProcess calls (ie, the
-     * lower the amount, the most often the checks will occur).
+     * Frequency of the Farm watchDir check. Cluster wide deployment will be done once for the specified amount of
+     * backgroundProcess calls (ie, the lower the amount, the most often the checks will occur).
      */
     protected int processDeployFrequency = 2;
 
@@ -138,35 +132,31 @@ public class FarmWarDeployer extends ClusterListener
             return;
         }
         Container hcontainer = getCluster().getContainer();
-        if(!(hcontainer instanceof Host)) {
+        if (!(hcontainer instanceof Host)) {
             log.error(sm.getString("farmWarDeployer.hostOnly"));
-            return ;
+            return;
         }
         host = (Host) hcontainer;
 
         // Check to correct engine and host setup
         Container econtainer = host.getParent();
-        if(!(econtainer instanceof Engine)) {
-            log.error(sm.getString("farmWarDeployer.hostParentEngine",
-                    host.getName()));
-            return ;
+        if (!(econtainer instanceof Engine)) {
+            log.error(sm.getString("farmWarDeployer.hostParentEngine", host.getName()));
+            return;
         }
         Engine engine = (Engine) econtainer;
         String hostname = null;
         hostname = host.getName();
         try {
-            oname = new ObjectName(engine.getName() + ":type=Deployer,host="
-                    + hostname);
+            oname = new ObjectName(engine.getName() + ":type=Deployer,host=" + hostname);
         } catch (Exception e) {
-            log.error(sm.getString("farmWarDeployer.mbeanNameFail",
-                    engine.getName(), hostname),e);
+            log.error(sm.getString("farmWarDeployer.mbeanNameFail", engine.getName(), hostname), e);
             return;
         }
         if (watchEnabled) {
             watcher = new WarWatcher(this, getWatchDirFile());
             if (log.isInfoEnabled()) {
-                log.info(sm.getString(
-                        "farmWarDeployer.watchDir", getWatchDir()));
+                log.info(sm.getString("farmWarDeployer.watchDir", getWatchDir()));
             }
         }
 
@@ -206,11 +196,10 @@ public class FarmWarDeployer extends ClusterListener
     }
 
     /**
-     * Callback from the cluster, when a message is received, The cluster will
-     * broadcast it invoking the messageReceived on the receiver.
+     * Callback from the cluster, when a message is received, The cluster will broadcast it invoking the messageReceived
+     * on the receiver.
      *
-     * @param msg
-     *            ClusterMessage - the message received from the cluster
+     * @param msg ClusterMessage - the message received from the cluster
      */
     @Override
     public void messageReceived(ClusterMessage msg) {
@@ -218,13 +207,12 @@ public class FarmWarDeployer extends ClusterListener
             if (msg instanceof FileMessage) {
                 FileMessage fmsg = (FileMessage) msg;
                 if (log.isDebugEnabled()) {
-                    log.debug(sm.getString("farmWarDeployer.msgRxDeploy",
-                            fmsg.getContextName(), fmsg.getFileName()));
+                    log.debug(sm.getString("farmWarDeployer.msgRxDeploy", fmsg.getContextName(), fmsg.getFileName()));
                 }
                 FileMessageFactory factory = getFactory(fmsg);
                 // TODO correct second try after app is in service!
                 if (factory.writeMessage(fmsg)) {
-                    //last message received war file is completed
+                    // last message received war file is completed
                     String name = factory.getFile().getName();
                     if (!name.endsWith(".war")) {
                         name = name + ".war";
@@ -236,23 +224,18 @@ public class FarmWarDeployer extends ClusterListener
                             try {
                                 remove(contextName);
                                 if (!factory.getFile().renameTo(deployable)) {
-                                    log.error(sm.getString(
-                                            "farmWarDeployer.renameFail",
-                                            factory.getFile(), deployable));
+                                    log.error(
+                                            sm.getString("farmWarDeployer.renameFail", factory.getFile(), deployable));
                                 }
                             } finally {
                                 removeServiced(contextName);
                             }
                             check(contextName);
                             if (log.isDebugEnabled()) {
-                                log.debug(sm.getString(
-                                        "farmWarDeployer.deployEnd",
-                                        contextName));
+                                log.debug(sm.getString("farmWarDeployer.deployEnd", contextName));
                             }
                         } else {
-                            log.error(sm.getString(
-                                    "farmWarDeployer.servicingDeploy",
-                                    contextName, name));
+                            log.error(sm.getString("farmWarDeployer.servicingDeploy", contextName, name));
                         }
                     } catch (Exception ex) {
                         log.error(sm.getString("farmWarDeployer.fileMessageError"), ex);
@@ -265,8 +248,7 @@ public class FarmWarDeployer extends ClusterListener
                     UndeployMessage umsg = (UndeployMessage) msg;
                     String contextName = umsg.getContextName();
                     if (log.isDebugEnabled()) {
-                        log.debug(sm.getString("farmWarDeployer.msgRxUndeploy",
-                                contextName));
+                        log.debug(sm.getString("farmWarDeployer.msgRxUndeploy", contextName));
                     }
                     if (tryAddServiced(contextName)) {
                         try {
@@ -275,14 +257,10 @@ public class FarmWarDeployer extends ClusterListener
                             removeServiced(contextName);
                         }
                         if (log.isDebugEnabled()) {
-                            log.debug(sm.getString(
-                                    "farmWarDeployer.undeployEnd",
-                                    contextName));
+                            log.debug(sm.getString("farmWarDeployer.undeployEnd", contextName));
                         }
                     } else {
-                        log.error(sm.getString(
-                                "farmWarDeployer.servicingUndeploy",
-                                contextName));
+                        log.error(sm.getString("farmWarDeployer.servicingUndeploy", contextName));
                     }
                 } catch (Exception ex) {
                     log.error(sm.getString("farmWarDeployer.undeployMessageError"), ex);
@@ -297,9 +275,11 @@ public class FarmWarDeployer extends ClusterListener
      * Create factory for all transported war files
      *
      * @param msg The file
+     *
      * @return Factory for all app message (war files)
+     *
      * @throws java.io.FileNotFoundException Missing file error
-     * @throws java.io.IOException Other IO error
+     * @throws java.io.IOException           Other IO error
      */
     public synchronized FileMessageFactory getFactory(FileMessage msg)
             throws java.io.FileNotFoundException, java.io.IOException {
@@ -323,14 +303,13 @@ public class FarmWarDeployer extends ClusterListener
     }
 
     /**
-     * Before the cluster invokes messageReceived the cluster will ask the
-     * receiver to accept or decline the message, In the future, when messages
-     * get big, the accept method will only take a message header
+     * Before the cluster invokes messageReceived the cluster will ask the receiver to accept or decline the message, In
+     * the future, when messages get big, the accept method will only take a message header
      *
      * @param msg ClusterMessage
-     * @return boolean - returns true to indicate that messageReceived should be
-     *         invoked. If false is returned, the messageReceived method will
-     *         not be invoked.
+     *
+     * @return boolean - returns true to indicate that messageReceived should be invoked. If false is returned, the
+     *             messageReceived method will not be invoked.
      */
     @Override
     public boolean accept(ClusterMessage msg) {
@@ -338,28 +317,18 @@ public class FarmWarDeployer extends ClusterListener
     }
 
     /**
-     * Install a new web application, whose web application archive is at the
-     * specified URL, into this container and all the other members of the
-     * cluster with the specified context name.
+     * Install a new web application, whose web application archive is at the specified URL, into this container and all
+     * the other members of the cluster with the specified context name.
      * <p>
-     * If this application is successfully installed locally, a ContainerEvent
-     * of type <code>INSTALL_EVENT</code> will be sent to all registered
-     * listeners, with the newly created <code>Context</code> as an argument.
+     * If this application is successfully installed locally, a ContainerEvent of type <code>INSTALL_EVENT</code> will
+     * be sent to all registered listeners, with the newly created <code>Context</code> as an argument.
      *
-     * @param contextName
-     *            The context name to which this application should be installed
-     *            (must be unique)
-     * @param webapp
-     *            A WAR file or unpacked directory structure containing the web
-     *            application to be installed
+     * @param contextName The context name to which this application should be installed (must be unique)
+     * @param webapp      A WAR file or unpacked directory structure containing the web application to be installed
      *
-     * @exception IllegalArgumentException
-     *                if the specified context name is malformed
-     * @exception IllegalStateException
-     *                if the specified context name is already deployed
-     * @exception IOException
-     *                if an input/output error was encountered during
-     *                installation
+     * @exception IllegalArgumentException if the specified context name is malformed
+     * @exception IllegalStateException    if the specified context name is already deployed
+     * @exception IOException              if an input/output error was encountered during installation
      */
     @Override
     public void install(String contextName, File webapp) throws IOException {
@@ -369,63 +338,49 @@ public class FarmWarDeployer extends ClusterListener
         }
 
         Member localMember = getCluster().getLocalMember();
-        FileMessageFactory factory =
-            FileMessageFactory.getInstance(webapp, false);
-        FileMessage msg = new FileMessage(localMember, webapp.getName(),
-                contextName);
-        if(log.isDebugEnabled()) {
-            log.debug(sm.getString("farmWarDeployer.sendStart", contextName,
-                    webapp));
+        FileMessageFactory factory = FileMessageFactory.getInstance(webapp, false);
+        FileMessage msg = new FileMessage(localMember, webapp.getName(), contextName);
+        if (log.isDebugEnabled()) {
+            log.debug(sm.getString("farmWarDeployer.sendStart", contextName, webapp));
         }
         msg = factory.readMessage(msg);
         while (msg != null) {
             for (Member member : members) {
                 if (log.isDebugEnabled()) {
-                    log.debug(sm.getString("farmWarDeployer.sendFragment",
-                            contextName, webapp, member));
+                    log.debug(sm.getString("farmWarDeployer.sendFragment", contextName, webapp, member));
                 }
                 getCluster().send(msg, member);
             }
             msg = factory.readMessage(msg);
         }
-        if(log.isDebugEnabled()) {
-            log.debug(sm.getString(
-                    "farmWarDeployer.sendEnd", contextName, webapp));
+        if (log.isDebugEnabled()) {
+            log.debug(sm.getString("farmWarDeployer.sendEnd", contextName, webapp));
         }
     }
 
     /**
-     * Remove an existing web application, attached to the specified context
-     * name. If this application is successfully removed, a ContainerEvent of
-     * type <code>REMOVE_EVENT</code> will be sent to all registered
-     * listeners, with the removed <code>Context</code> as an argument.
-     * Deletes the web application war file and/or directory if they exist in
-     * the Host's appBase.
+     * Remove an existing web application, attached to the specified context name. If this application is successfully
+     * removed, a ContainerEvent of type <code>REMOVE_EVENT</code> will be sent to all registered listeners, with the
+     * removed <code>Context</code> as an argument. Deletes the web application war file and/or directory if they exist
+     * in the Host's appBase.
      *
-     * @param contextName
-     *            The context name of the application to be removed
-     * @param undeploy
-     *            boolean flag to remove web application from server
+     * @param contextName The context name of the application to be removed
+     * @param undeploy    boolean flag to remove web application from server
      *
-     * @exception IllegalArgumentException
-     *                if the specified context name is malformed
-     * @exception IllegalArgumentException
-     *                if the specified context name does not identify a
-     *                currently installed web application
-     * @exception IOException
-     *                if an input/output error occurs during removal
+     * @exception IllegalArgumentException if the specified context name is malformed
+     * @exception IllegalArgumentException if the specified context name does not identify a currently installed web
+     *                                         application
+     * @exception IOException              if an input/output error occurs during removal
      */
     @Override
-    public void remove(String contextName, boolean undeploy)
-            throws IOException {
+    public void remove(String contextName, boolean undeploy) throws IOException {
         if (getCluster().getMembers().length > 0) {
             if (log.isInfoEnabled()) {
                 log.info(sm.getString("farmWarDeployer.removeStart", contextName));
             }
             Member localMember = getCluster().getLocalMember();
-            UndeployMessage msg = new UndeployMessage(localMember, System
-                    .currentTimeMillis(), "Undeploy:" + contextName + ":"
-                    + System.currentTimeMillis(), contextName);
+            UndeployMessage msg = new UndeployMessage(localMember, System.currentTimeMillis(),
+                    "Undeploy:" + contextName + ":" + System.currentTimeMillis(), contextName);
             if (log.isDebugEnabled()) {
                 log.debug(sm.getString("farmWarDeployer.removeTxMsg", contextName));
             }
@@ -442,13 +397,11 @@ public class FarmWarDeployer extends ClusterListener
                     }
                     check(contextName);
                 } else {
-                    log.error(sm.getString("farmWarDeployer.removeFailRemote",
-                            contextName));
+                    log.error(sm.getString("farmWarDeployer.removeFailRemote", contextName));
                 }
 
             } catch (Exception ex) {
-                log.error(sm.getString("farmWarDeployer.removeFailLocal",
-                        contextName), ex);
+                log.error(sm.getString("farmWarDeployer.removeFailLocal", contextName), ex);
             }
         }
 
@@ -471,8 +424,7 @@ public class FarmWarDeployer extends ClusterListener
                 return;
             }
             if (log.isInfoEnabled()) {
-                log.info(sm.getString("farmWarDeployer.modInstall",
-                        cn.getName(), deployWar.getAbsolutePath()));
+                log.info(sm.getString("farmWarDeployer.modInstall", cn.getName(), deployWar.getAbsolutePath()));
             }
             // install local
             if (tryAddServiced(cn.getName())) {
@@ -483,8 +435,7 @@ public class FarmWarDeployer extends ClusterListener
                 }
                 check(cn.getName());
             } else {
-                log.error(sm.getString("farmWarDeployer.servicingDeploy",
-                        cn.getName(), deployWar.getName()));
+                log.error(sm.getString("farmWarDeployer.servicingDeploy", cn.getName(), deployWar.getName()));
             }
             install(cn.getName(), deployWar);
         } catch (Exception x) {
@@ -502,8 +453,7 @@ public class FarmWarDeployer extends ClusterListener
         try {
             ContextName cn = new ContextName(removeWar.getName(), true);
             if (log.isInfoEnabled()) {
-                log.info(sm.getString("farmWarDeployer.removeLocal",
-                        cn.getName()));
+                log.info(sm.getString("farmWarDeployer.removeLocal", cn.getName()));
             }
             remove(cn.getName(), true);
         } catch (Exception x) {
@@ -513,7 +463,9 @@ public class FarmWarDeployer extends ClusterListener
 
     /**
      * Invoke the remove method on the deployer.
+     *
      * @param contextName The context to remove
+     *
      * @throws Exception If an error occurs removing the context
      */
     protected void remove(String contextName) throws Exception {
@@ -521,9 +473,8 @@ public class FarmWarDeployer extends ClusterListener
         // Stop the context first to be nicer
         Context context = (Context) host.findChild(contextName);
         if (context != null) {
-            if(log.isDebugEnabled()) {
-                log.debug(sm.getString("farmWarDeployer.undeployLocal",
-                        contextName));
+            if (log.isDebugEnabled()) {
+                log.debug(sm.getString("farmWarDeployer.undeployLocal", contextName));
             }
             context.stop();
             String baseName = context.getBaseName();
@@ -545,11 +496,9 @@ public class FarmWarDeployer extends ClusterListener
     }
 
     /**
-     * Delete the specified directory, including all of its contents and
-     * subdirectories recursively.
+     * Delete the specified directory, including all of its contents and subdirectories recursively.
      *
-     * @param dir
-     *            File object representing the directory to be deleted
+     * @param dir File object representing the directory to be deleted
      */
     protected void undeployDir(File dir) {
 
@@ -595,7 +544,9 @@ public class FarmWarDeployer extends ClusterListener
 
     /**
      * Check a context for deployment operations.
+     *
      * @param name The context name
+     *
      * @throws Exception Error invoking the deployer
      */
     protected void check(String name) throws Exception {
@@ -606,9 +557,12 @@ public class FarmWarDeployer extends ClusterListener
 
     /**
      * Attempt to mark a context as being serviced
+     *
      * @param name The context name
-     * @return {@code true} if the application was marked as being serviced and
-     *         {@code false} if the application was already marked as being serviced
+     *
+     * @return {@code true} if the application was marked as being serviced and {@code false} if the application was
+     *             already marked as being serviced
+     *
      * @throws Exception Error invoking the deployer
      */
     protected boolean tryAddServiced(String name) throws Exception {
@@ -620,7 +574,9 @@ public class FarmWarDeployer extends ClusterListener
 
     /**
      * Mark a context as no longer being serviced.
+     *
      * @param name The context name
+     *
      * @throws Exception Error invoking the deployer
      */
     protected void removeServiced(String name) throws Exception {
@@ -716,8 +672,7 @@ public class FarmWarDeployer extends ClusterListener
     /**
      * Set the watcher checks frequency.
      *
-     * @param processExpiresFrequency
-     *            the new manager checks frequency
+     * @param processExpiresFrequency the new manager checks frequency
      */
     public void setProcessDeployFrequency(int processExpiresFrequency) {
 
@@ -737,8 +692,10 @@ public class FarmWarDeployer extends ClusterListener
 
     /**
      * Copy a file to the specified temp directory.
+     *
      * @param from copy from temp
      * @param to   to host appBase directory
+     *
      * @return true, copy successful
      */
     protected boolean copy(File from, File to) {
@@ -750,8 +707,7 @@ public class FarmWarDeployer extends ClusterListener
                 }
             }
         } catch (IOException e) {
-            log.error(sm.getString("farmWarDeployer.fileCopyFail",
-                    from, to), e);
+            log.error(sm.getString("farmWarDeployer.fileCopyFail", from, to), e);
             return false;
         }
 
@@ -766,8 +722,7 @@ public class FarmWarDeployer extends ClusterListener
                 os.write(buf, 0, len);
             }
         } catch (IOException e) {
-            log.error(sm.getString("farmWarDeployer.fileCopyFail",
-                    from, to), e);
+            log.error(sm.getString("farmWarDeployer.fileCopyFail", from, to), e);
             return false;
         }
         return true;
@@ -786,8 +741,7 @@ public class FarmWarDeployer extends ClusterListener
     private File getAbsolutePath(String path) {
         File dir = new File(path);
         if (!dir.isAbsolute()) {
-            dir = new File(getCluster().getContainer().getCatalinaBase(),
-                    dir.getPath());
+            dir = new File(getCluster().getContainer().getCatalinaBase(), dir.getPath());
         }
         try {
             dir = dir.getCanonicalFile();

==================================================
FileMessage.java
index ac43b5701a..5f2d5dd76e 100644
--- a/java/org/apache/catalina/ha/deploy/FileChangeListener.java
+++ b/java/org/apache/catalina/ha/deploy/FileChangeListener.java
@@ -15,9 +15,11 @@
  * limitations under the License.
  */
 package org.apache.catalina.ha.deploy;
+
 import java.io.File;
 
 public interface FileChangeListener {
     void fileModified(File f);
+
     void fileRemoved(File f);
 }

==================================================
FileMessageFactory.java
index 1f359f8c6c..bac4275131 100644
--- a/java/org/apache/catalina/ha/deploy/FileMessage.java
+++ b/java/org/apache/catalina/ha/deploy/FileMessage.java
@@ -20,8 +20,8 @@ import org.apache.catalina.ha.ClusterMessageBase;
 import org.apache.catalina.tribes.Member;
 
 /**
- * Contains the data for a file being transferred over TCP, this is
- * essentially a fragment of a file, read and written by the FileMessageFactory.
+ * Contains the data for a file being transferred over TCP, this is essentially a fragment of a file, read and written
+ * by the FileMessageFactory.
  */
 
 public class FileMessage extends ClusterMessageBase {
@@ -35,33 +35,37 @@ public class FileMessage extends ClusterMessageBase {
     private final String fileName;
     private final String contextName;
 
-    public FileMessage(Member source,
-                       String fileName,
-                       String contextName) {
-        this.address=source;
-        this.fileName=fileName;
-        this.contextName=contextName;
+    public FileMessage(Member source, String fileName, String contextName) {
+        this.address = source;
+        this.fileName = fileName;
+        this.contextName = contextName;
     }
 
     public int getMessageNumber() {
         return messageNumber;
     }
+
     public void setMessageNumber(int messageNumber) {
         this.messageNumber = messageNumber;
     }
+
     public long getTotalNrOfMsgs() {
         return totalNrOfMsgs;
     }
+
     public void setTotalNrOfMsgs(long totalNrOfMsgs) {
         this.totalNrOfMsgs = totalNrOfMsgs;
     }
+
     public byte[] getData() {
         return data;
     }
+
     public void setData(byte[] data, int length) {
         this.data = data;
         this.dataLength = length;
     }
+
     public int getDataLength() {
         return dataLength;
     }
@@ -80,6 +84,7 @@ public class FileMessage extends ClusterMessageBase {
     public String getFileName() {
         return fileName;
     }
+
     public String getContextName() {
         return contextName;
     }

==================================================
UndeployMessage.java
index 7a7048ad1e..979f13d37c 100644
--- a/java/org/apache/catalina/ha/deploy/FileMessageFactory.java
+++ b/java/org/apache/catalina/ha/deploy/FileMessageFactory.java
@@ -31,13 +31,10 @@ import org.apache.tomcat.util.buf.HexUtils;
 import org.apache.tomcat.util.res.StringManager;
 
 /**
- * This factory is used to read files and write files by splitting them up into
- * smaller messages. So that entire files don't have to be read into memory.
- * <BR>
- * The factory can be used as a reader or writer but not both at the same time.
- * When done reading or writing the factory will close the input or output
- * streams and mark the factory as closed. It is not possible to use it after
- * that. <BR>
+ * This factory is used to read files and write files by splitting them up into smaller messages. So that entire files
+ * don't have to be read into memory. <BR>
+ * The factory can be used as a reader or writer but not both at the same time. When done reading or writing the factory
+ * will close the input or output streams and mark the factory as closed. It is not possible to use it after that. <BR>
  * To force a cleanup, call cleanup() from the calling object. <BR>
  * This class is not thread safe.
  */
@@ -49,7 +46,7 @@ public class FileMessageFactory {
     /**
      * The number of bytes that we read from file
      */
-    public static final int READ_SIZE = 1024 * 10; //10kb
+    public static final int READ_SIZE = 1024 * 10; // 10kb
 
     /**
      * The file that we are reading/writing
@@ -57,8 +54,7 @@ public class FileMessageFactory {
     protected final File file;
 
     /**
-     * True means that we are writing with this factory. False means that we are
-     * reading with this factory
+     * True means that we are writing with this factory. False means that we are reading with this factory
      */
     protected final boolean openForWrite;
 
@@ -98,9 +94,8 @@ public class FileMessageFactory {
     protected AtomicLong lastMessageProcessed = new AtomicLong(0);
 
     /**
-     * Messages received out of order are held in the buffer until required. If
-     * everything is worked as expected, messages will spend very little time in
-     * the buffer.
+     * Messages received out of order are held in the buffer until required. If everything is worked as expected,
+     * messages will spend very little time in the buffer.
      */
     protected final Map<Long, FileMessage> msgBuffer = new ConcurrentHashMap<>();
 
@@ -110,8 +105,7 @@ public class FileMessageFactory {
     protected byte[] data = new byte[READ_SIZE];
 
     /**
-     * Flag that indicates if a thread is writing messages to disk. Access to
-     * this flag must be synchronised.
+     * Flag that indicates if a thread is writing messages to disk. Access to this flag must be synchronised.
      */
     protected boolean isWriting = false;
 
@@ -127,24 +121,17 @@ public class FileMessageFactory {
 
     /**
      * Private constructor, either instantiates a factory to read or write. <BR>
-     * When openForWrite==true, then a the file, f, will be created and an
-     * output stream is opened to write to it. <BR>
-     * When openForWrite==false, an input stream is opened, the file has to
-     * exist.
+     * When openForWrite==true, then a the file, f, will be created and an output stream is opened to write to it. <BR>
+     * When openForWrite==false, an input stream is opened, the file has to exist.
      *
-     * @param f
-     *            File - the file to be read/written
-     * @param openForWrite
-     *            boolean - true means we are writing to the file, false means
-     *            we are reading from the file
-     * @throws FileNotFoundException -
-     *             if the file to be read doesn't exist
-     * @throws IOException -
-     *             if the system fails to open input/output streams to the file
-     *             or if it fails to create the file to be written to.
+     * @param f            File - the file to be read/written
+     * @param openForWrite boolean - true means we are writing to the file, false means we are reading from the file
+     *
+     * @throws FileNotFoundException - if the file to be read doesn't exist
+     * @throws IOException           - if the system fails to open input/output streams to the file or if it fails to
+     *                                   create the file to be written to.
      */
-    private FileMessageFactory(File f, boolean openForWrite)
-            throws FileNotFoundException, IOException {
+    private FileMessageFactory(File f, boolean openForWrite) throws FileNotFoundException, IOException {
         this.file = f;
         this.openForWrite = openForWrite;
         if (log.isDebugEnabled()) {
@@ -161,24 +148,20 @@ public class FileMessageFactory {
             size = file.length();
             totalNrOfMessages = (size / READ_SIZE) + 1;
             in = new FileInputStream(f);
-        }//end if
+        } // end if
         creationTime = System.currentTimeMillis();
     }
 
     /**
-     * Creates a factory to read or write from a file. When opening for read,
-     * the readMessage can be invoked, and when opening for write the
-     * writeMessage can be invoked.
+     * Creates a factory to read or write from a file. When opening for read, the readMessage can be invoked, and when
+     * opening for write the writeMessage can be invoked.
+     *
+     * @param f            File - the file to be read or written
+     * @param openForWrite boolean - true, means we are writing to the file, false means we are reading from it
+     *
+     * @throws FileNotFoundException - if the file to be read doesn't exist
+     * @throws IOException           - if it fails to create the file that is to be written
      *
-     * @param f
-     *            File - the file to be read or written
-     * @param openForWrite
-     *            boolean - true, means we are writing to the file, false means
-     *            we are reading from it
-     * @throws FileNotFoundException -
-     *             if the file to be read doesn't exist
-     * @throws IOException -
-     *             if it fails to create the file that is to be written
      * @return FileMessageFactory
      */
     public static FileMessageFactory getInstance(File f, boolean openForWrite)
@@ -187,25 +170,19 @@ public class FileMessageFactory {
     }
 
     /**
-     * Reads file data into the file message and sets the size, totalLength,
-     * totalNrOfMsgs and the message number <BR>
-     * If EOF is reached, the factory returns null, and closes itself, otherwise
-     * the same message is returned as was passed in. This makes sure that not
-     * more memory is ever used. To remember, neither the file message or the
-     * factory are thread safe. Don't hand off the message to one thread and
-     * read the same with another.
+     * Reads file data into the file message and sets the size, totalLength, totalNrOfMsgs and the message number <BR>
+     * If EOF is reached, the factory returns null, and closes itself, otherwise the same message is returned as was
+     * passed in. This makes sure that not more memory is ever used. To remember, neither the file message or the
+     * factory are thread safe. Don't hand off the message to one thread and read the same with another.
+     *
+     * @param f FileMessage - the message to be populated with file data
      *
-     * @param f
-     *            FileMessage - the message to be populated with file data
-     * @throws IllegalArgumentException -
-     *             if the factory is for writing or is closed
-     * @throws IOException -
-     *             if a file read exception occurs
-     * @return FileMessage - returns the same message passed in as a parameter,
-     *         or null if EOF
+     * @throws IllegalArgumentException - if the factory is for writing or is closed
+     * @throws IOException              - if a file read exception occurs
+     *
+     * @return FileMessage - returns the same message passed in as a parameter, or null if EOF
      */
-    public FileMessage readMessage(FileMessage f)
-            throws IllegalArgumentException, IOException {
+    public FileMessage readMessage(FileMessage f) throws IllegalArgumentException, IOException {
         checkState(false);
         int length = in.read(data);
         if (length == -1) {
@@ -216,30 +193,27 @@ public class FileMessageFactory {
             f.setTotalNrOfMsgs(totalNrOfMessages);
             f.setMessageNumber(++nrOfMessagesProcessed);
             return f;
-        }//end if
+        } // end if
     }
 
     /**
-     * Writes a message to file. If (msg.getMessageNumber() ==
-     * msg.getTotalNrOfMsgs()) the output stream will be closed after writing.
+     * Writes a message to file. If (msg.getMessageNumber() == msg.getTotalNrOfMsgs()) the output stream will be closed
+     * after writing.
+     *
+     * @param msg FileMessage - message containing data to be written
+     *
+     * @throws IllegalArgumentException - if the factory is opened for read or closed
+     * @throws IOException              - if a file write error occurs
      *
-     * @param msg
-     *            FileMessage - message containing data to be written
-     * @throws IllegalArgumentException -
-     *             if the factory is opened for read or closed
-     * @throws IOException -
-     *             if a file write error occurs
-     * @return returns true if the file is complete and outputstream is closed,
-     *         false otherwise.
+     * @return returns true if the file is complete and outputstream is closed, false otherwise.
      */
-    public boolean writeMessage(FileMessage msg)
-            throws IllegalArgumentException, IOException {
+    public boolean writeMessage(FileMessage msg) throws IllegalArgumentException, IOException {
         if (!openForWrite) {
             throw new IllegalArgumentException(sm.getString("fileMessageFactory.cannotWrite"));
         }
         if (log.isDebugEnabled()) {
-            log.debug("Message " + msg + " data " + HexUtils.toHexString(msg.getData())
-                    + " data length " + msg.getDataLength() + " out " + out);
+            log.debug("Message " + msg + " data " + HexUtils.toHexString(msg.getData()) + " data length " +
+                    msg.getDataLength() + " out " + out);
         }
 
         if (msg.getMessageNumber() <= lastMessageProcessed.get()) {
@@ -249,8 +223,7 @@ public class FileMessageFactory {
             return false;
         }
 
-        FileMessage previous =
-            msgBuffer.put(Long.valueOf(msg.getMessageNumber()), msg);
+        FileMessage previous = msgBuffer.put(Long.valueOf(msg.getMessageNumber()), msg);
         if (previous != null) {
             // Duplicate of message not yet processed
             log.warn(sm.getString("fileMessageFactory.duplicateMessage", msg.getContextName(), msg.getFileName(),
@@ -281,9 +254,8 @@ public class FileMessageFactory {
                 cleanup();
                 return true;
             }
-            synchronized(this) {
-                next =
-                    msgBuffer.get(Long.valueOf(lastMessageProcessed.get() + 1));
+            synchronized (this) {
+                next = msgBuffer.get(Long.valueOf(lastMessageProcessed.get() + 1));
                 if (next == null) {
                     isWriting = false;
                 }
@@ -291,7 +263,7 @@ public class FileMessageFactory {
         }
 
         return false;
-    }//writeMessage
+    }// writeMessage
 
     /**
      * Closes the factory, its streams and sets all its references to null
@@ -321,15 +293,14 @@ public class FileMessageFactory {
     }
 
     /**
-     * Check to make sure the factory is able to perform the function it is
-     * asked to do. Invoked by readMessage/writeMessage before those methods
-     * proceed.
+     * Check to make sure the factory is able to perform the function it is asked to do. Invoked by
+     * readMessage/writeMessage before those methods proceed.
      *
      * @param openForWrite The value to check
+     *
      * @throws IllegalArgumentException if the state is not the expected one
      */
-    protected void checkState(boolean openForWrite)
-            throws IllegalArgumentException {
+    protected void checkState(boolean openForWrite) throws IllegalArgumentException {
         if (this.openForWrite != openForWrite) {
             cleanup();
             if (openForWrite) {

==================================================
WarWatcher.java
index 066d61ffd6..63f22adb25 100644
--- a/java/org/apache/catalina/ha/deploy/UndeployMessage.java
+++ b/java/org/apache/catalina/ha/deploy/UndeployMessage.java
@@ -27,12 +27,9 @@ public class UndeployMessage implements ClusterMessage {
     private String uniqueId;
     private final String contextName;
 
-    public UndeployMessage(Member address,
-                           long timestamp,
-                           String uniqueId,
-                           String contextName) {
-        this.address  = address;
-        this.timestamp= timestamp;
+    public UndeployMessage(Member address, long timestamp, String uniqueId, String contextName) {
+        this.address = address;
+        this.timestamp = timestamp;
         this.uniqueId = uniqueId;
         this.contextName = contextName;
     }

==================================================
