7d6ddda53d43a7a9711399b0b3fd1e7a30a3fea9
==================================================
Fix https://bz.apache.org/bugzilla/show_bug.cgi?id=58751
==================================================
Mark Thomas
==================================================
Mon Jan 4 18:12:07 2016 +0000
==================================================
AsyncContextImpl.java
Fix https://bz.apache.org/bugzilla/show_bug.cgi?id=58751
Correctly handle the case where an AsyncListener dispatches to a Servlet on an asynchronous timeout and the Servlet uses <code>sendError()</code> to trigger an error page.
Test case based on code provided by Andy Wilkinson.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1722939 13f79535-47bb-0310-9956-ffa450edef68



==================================================
TestAsyncContextImpl.java
index cda3231c22..70b647fd47 100644
--- a/java/org/apache/catalina/core/AsyncContextImpl.java
+++ b/java/org/apache/catalina/core/AsyncContextImpl.java
@@ -97,6 +97,29 @@ public class AsyncContextImpl implements AsyncContext, AsyncContextCallback {
 
     @Override
     public void fireOnComplete() {
+        // Fire the listeners
+        doFireOnComplete();
+
+        // The application doesn't know it has to stop read and/or writing until
+        // it receives the complete event so the request and response have to be
+        // closed after firing the event.
+        try {
+            // First of all ensure that any data written to the response is
+            // written to the I/O layer.
+            request.getResponse().finishResponse();
+            // Close the request and the response.
+            request.getCoyoteRequest().action(ActionCode.END_REQUEST, null);
+        } catch (Throwable t) {
+            ExceptionUtils.handleThrowable(t);
+            // Catch this here and allow async context complete to continue
+            // normally so a dispatch takes place which ensures that  the
+            // request and response objects are correctly recycled.
+            log.debug(sm.getString("asyncContextImpl.finishResponseError"), t);
+        }
+    }
+
+
+    private void doFireOnComplete() {
         List<AsyncListenerWrapper> listenersCopy = new ArrayList<>();
         listenersCopy.addAll(listeners);
 
@@ -115,25 +138,9 @@ public class AsyncContextImpl implements AsyncContext, AsyncContextCallback {
             clearServletRequestResponse();
             context.unbind(Globals.IS_SECURITY_ENABLED, oldCL);
         }
-
-        // The application doesn't know it has to stop read and/or writing until
-        // it receives the complete event so the request and response have to be
-        // closed after firing the event.
-        try {
-            // First of all ensure that any data written to the response is
-            // written to the I/O layer.
-            request.getResponse().finishResponse();
-            // Close the request and the response.
-            request.getCoyoteRequest().action(ActionCode.END_REQUEST, null);
-        } catch (Throwable t) {
-            ExceptionUtils.handleThrowable(t);
-            // Catch this here and allow async context complete to continue
-            // normally so a dispatch takes place which ensures that  the
-            // request and response objects are correctly recycled.
-            log.debug(sm.getString("asyncContextImpl.finishResponseError"), t);
-        }
     }
 
+
     public boolean timeout() {
         AtomicBoolean result = new AtomicBoolean();
         request.getCoyoteRequest().action(ActionCode.ASYNC_TIMEOUT, result);
@@ -383,7 +390,9 @@ public class AsyncContextImpl implements AsyncContext, AsyncContextCallback {
             dispatch = null;
             runnable.run();
             if (!request.isAsync()) {
-                fireOnComplete();
+                // Uses internal method since we don't want the request/response
+                // to be closed. That will be handled in the adapter.
+                doFireOnComplete();
             }
         } catch (RuntimeException x) {
             // doInternalComplete(true);

==================================================
