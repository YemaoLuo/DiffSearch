d26ed64766e590af902588177b0d89456016d121
==================================================
Fix https://bz.apache.org/bugzilla/show_bug.cgi?id=62273
==================================================
Mark Thomas
==================================================
Wed Apr 25 15:31:48 2018 +0000
==================================================
AbstractHttp11Protocol.java
Fix https://bz.apache.org/bugzilla/show_bug.cgi?id=62273
Implement configuration options to work-around specification non-compliant user agents (including all the major browsers) that do not correctly %nn encode URI paths and query strings as required by RFC 7230 and RFC 3986.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1830087 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Http11InputBuffer.java
index 3b2d494c01..e5ab885e5d 100644
--- a/java/org/apache/coyote/http11/AbstractHttp11Protocol.java
+++ b/java/org/apache/coyote/http11/AbstractHttp11Protocol.java
@@ -95,6 +95,24 @@ public abstract class AbstractHttp11Protocol<S> extends AbstractProtocol<S> {
     // ------------------------------------------------ HTTP specific properties
     // ------------------------------------------ managed in the ProtocolHandler
 
+    private String relaxedPathChars = null;
+    public String getRelaxedPathChars() {
+        return relaxedPathChars;
+    }
+    public void setRelaxedPathChars(String relaxedPathChars) {
+        this.relaxedPathChars = relaxedPathChars;
+    }
+
+
+    private String relaxedQueryChars = null;
+    public String getRelaxedQueryChars() {
+        return relaxedQueryChars;
+    }
+    public void setRelaxedQueryChars(String relaxedQueryChars) {
+        this.relaxedQueryChars = relaxedQueryChars;
+    }
+
+
     private boolean allowHostHeaderMismatch = false;
     /**
      * Will Tomcat accept an HTTP 1.1 request where the host header does not

==================================================
Http11Processor.java
index 3c57766ac9..f89183a426 100644
--- a/java/org/apache/coyote/http11/Http11InputBuffer.java
+++ b/java/org/apache/coyote/http11/Http11InputBuffer.java
@@ -133,6 +133,7 @@ public class Http11InputBuffer implements InputBuffer, ApplicationBufferHandler
     private int parsingRequestLineQPos = -1;
     private HeaderParsePosition headerParsePos;
     private final HeaderParseData headerData = new HeaderParseData();
+    private final HttpParser httpParser;
 
     /**
      * Maximum allowed size of the HTTP request line plus headers plus any
@@ -149,13 +150,14 @@ public class Http11InputBuffer implements InputBuffer, ApplicationBufferHandler
     // ----------------------------------------------------------- Constructors
 
     public Http11InputBuffer(Request request, int headerBufferSize,
-            boolean rejectIllegalHeaderName) {
+            boolean rejectIllegalHeaderName, HttpParser httpParser) {
 
         this.request = request;
         headers = request.getMimeHeaders();
 
         this.headerBufferSize = headerBufferSize;
         this.rejectIllegalHeaderName = rejectIllegalHeaderName;
+        this.httpParser = httpParser;
 
         filterLibrary = new InputFilter[0];
         activeFilters = new InputFilter[0];
@@ -456,10 +458,10 @@ public class Http11InputBuffer implements InputBuffer, ApplicationBufferHandler
                     end = pos;
                 } else if (chr == Constants.QUESTION && parsingRequestLineQPos == -1) {
                     parsingRequestLineQPos = pos;
-                } else if (parsingRequestLineQPos != -1 && !HttpParser.isQuery(chr)) {
+                } else if (parsingRequestLineQPos != -1 && !httpParser.isQueryRelaxed(chr)) {
                     // %nn decoding will be checked at the point of decoding
                     throw new IllegalArgumentException(sm.getString("iib.invalidRequestTarget"));
-                } else if (HttpParser.isNotRequestTarget(chr)) {
+                } else if (httpParser.isNotRequestTargetRelaxed(chr)) {
                     // This is a general check that aims to catch problems early
                     // Detailed checking of each part of the request target will
                     // happen in Http11Processor#prepareRequest()

==================================================
HttpParser.java
index fd0b0f2286..349239ac60 100644
--- a/java/org/apache/coyote/http11/Http11Processor.java
+++ b/java/org/apache/coyote/http11/Http11Processor.java
@@ -87,6 +87,9 @@ public class Http11Processor extends AbstractProcessor {
     private final Http11OutputBuffer outputBuffer;
 
 
+    private final HttpParser httpParser;
+
+
     /**
      * Tracks how many internal filters are in the filter library so they
      * are skipped when looking for pluggable filters.
@@ -150,8 +153,11 @@ public class Http11Processor extends AbstractProcessor {
 
         userDataHelper = new UserDataHelper(log);
 
+        httpParser = new HttpParser(protocol.getRelaxedPathChars(),
+                protocol.getRelaxedQueryChars());
+
         inputBuffer = new Http11InputBuffer(request, protocol.getMaxHttpHeaderSize(),
-                protocol.getRejectIllegalHeaderName());
+                protocol.getRejectIllegalHeaderName(), httpParser);
         request.setInputBuffer(inputBuffer);
 
         outputBuffer = new Http11OutputBuffer(response, protocol.getMaxHttpHeaderSize());
@@ -754,7 +760,7 @@ public class Http11Processor extends AbstractProcessor {
         // Validate the characters in the URI. %nn decoding will be checked at
         // the point of decoding.
         for (int i = uriBC.getStart(); i < uriBC.getEnd(); i++) {
-            if (!HttpParser.isAbsolutePath(uriB[i])) {
+            if (!httpParser.isAbsolutePathRelaxed(uriB[i])) {
                 response.setStatus(400);
                 setErrorState(ErrorState.CLOSE_CLEAN, null);
                 if (log.isDebugEnabled()) {

==================================================
