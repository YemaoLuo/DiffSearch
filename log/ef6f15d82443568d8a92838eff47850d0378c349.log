ef6f15d82443568d8a92838eff47850d0378c349
==================================================
Improve comments
==================================================
Mark Thomas
==================================================
Thu Jul 15 16:59:51 2021 +0100
==================================================
NioEndpoint.java
Improve comments


==================================================
SecureNioChannel.java
index c50c720c4f..ffdecc2c39 100644
--- a/java/org/apache/tomcat/util/net/NioEndpoint.java
+++ b/java/org/apache/tomcat/util/net/NioEndpoint.java
@@ -1315,7 +1315,7 @@ public class NioEndpoint extends AbstractJsseEndpoint<NioChannel,SocketChannel>
                      * write it as part of a subsequent write call.
                      *
                      * Because of the above, when a timeout is triggered we need
-                     * so skip subsequent attempts to write as otherwise it will
+                     * to skip subsequent attempts to write as otherwise it will
                      * appear to the client as if some data was dropped just
                      * before the connection is lost. It is better if the client
                      * just sees the dropped connection.
@@ -1363,10 +1363,6 @@ public class NioEndpoint extends AbstractJsseEndpoint<NioChannel,SocketChannel>
                         startNanos = 0;
                     }
                 } while (buffer.hasRemaining());
-                // If there is data left in the buffer the socket will be registered for
-                // write further up the stack. This is to ensure the socket is only
-                // registered for write once as both container and user code can trigger
-                // write registration.
             } else {
                 do {
                     n = getSocket().write(buffer);
@@ -1374,6 +1370,10 @@ public class NioEndpoint extends AbstractJsseEndpoint<NioChannel,SocketChannel>
                         throw new EOFException();
                     }
                 } while (n > 0 && buffer.hasRemaining());
+                // If there is data left in the buffer the socket will be registered for
+                // write further up the stack. This is to ensure the socket is only
+                // registered for write once as both container and user code can trigger
+                // write registration.
             }
             updateLastWrite();
         }

==================================================
