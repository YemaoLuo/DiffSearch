b7d9a0540a89d08f6f3682bdfa1de19584368186
==================================================
When using Servlet 3.1 non-blocking reads with an AJP connector, make the reads between the AJP body messages from the server non-blocking. Once any part of a message is read, the remainder of the message will be read using blocking IO.
==================================================
Mark Emlyn
==================================================
Tue Sep 3 20:26:59 2013 +0000
==================================================
AbstractProcessor.java
When using Servlet 3.1 non-blocking reads with an AJP connector, make the reads between the AJP body messages from the server non-blocking. Once any part of a message is read, the remainder of the message will be read using blocking IO.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1519838 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AbstractAjpProcessor.java
index 90400e76d8..2f21759557 100644
--- a/java/org/apache/coyote/AbstractProcessor.java
+++ b/java/org/apache/coyote/AbstractProcessor.java
@@ -173,4 +173,13 @@ public abstract class AbstractProcessor<S> implements ActionHook, Processor<S> {
 
     @Override
     public abstract HttpUpgradeHandler getHttpUpgradeHandler();
+
+
+    /**
+     * Register the socket for the specified events.
+     *
+     * @param read  Register the socket for read events
+     * @param write Register the socket for write events
+     */
+    protected abstract void registerForEvent(boolean read, boolean write);
 }

==================================================
AjpAprProcessor.java
index cc1e21fe64..6ae789504e 100644
--- a/java/org/apache/coyote/ajp/AbstractAjpProcessor.java
+++ b/java/org/apache/coyote/ajp/AbstractAjpProcessor.java
@@ -211,6 +211,13 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
     protected boolean first = true;
 
 
+    /**
+     * Indicates that a 'get body chunk' message has been sent but the body
+     * chunk has not yet been received.
+     */
+    private boolean waitingForBodyMessage = false;
+
+
     /**
      * Replay read.
      */
@@ -542,23 +549,34 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
                     sm.getString("ajpprocessor.comet.notsupported"));
 
         } else if (actionCode == ActionCode.AVAILABLE) {
-            // Web Server only sends data when asked so unless end of stream has
-            // been reached, there should be data available.
-            // TODO Figure out if a 'true' non-blocking approach is possible
-            //      for AJP and what changes would be required to support it.
             if (!endOfStream) {
-                request.setAvailable(1);
+                if (empty) {
+                    try {
+                        refillReadBuffer(false);
+                    } catch (IOException e) {
+                        error = true;
+                        return;
+                    }
+                }
+                if (empty) {
+                    request.setAvailable(0);
+                } else {
+                    request.setAvailable(1);
+                }
+            }
+
+        } else if (actionCode == ActionCode.NB_READ_INTEREST) {
+            if (!endOfStream) {
+                registerForEvent(true, false);
             }
 
         } else if (actionCode == ActionCode.NB_WRITE_INTEREST) {
+            // TODO
             // Until 'true' non-blocking IO is implemented, assume it is always
             // possible write data.
             AtomicBoolean isReady = (AtomicBoolean)param;
             isReady.set(true);
 
-        } else if (actionCode == ActionCode.NB_READ_INTEREST) {
-            // NO-OP. Not required until 'true' non-blocking IO is implemented.
-
         } else if (actionCode == ActionCode.REQUEST_BODY_FULLY_READ) {
             AtomicBoolean result = (AtomicBoolean) param;
             result.set(endOfStream);
@@ -814,6 +832,7 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
         // Recycle Request object
         first = true;
         endOfStream = false;
+        waitingForBodyMessage = false;
         empty = true;
         replay = false;
         finished = false;
@@ -866,16 +885,26 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
             throws IOException;
 
     // Methods used by SocketInputBuffer
-    /** Receive a chunk of data. Called to implement the
-     *  'special' packet in ajp13 and to receive the data
-     *  after we send a GET_BODY packet
+    /**
+     * Read an AJP body message. Used to read both the 'special' packet in ajp13
+     * and to receive the data after we send a GET_BODY packet.
+     *
+     * @param block If there is no data available to read when this method is
+     *              called, should this call block until data becomes available?
+     *
+     * @return <code>true</code> if at least one body byte was read, otherwise
+     *         <code>false</code>
      */
-    protected boolean receive() throws IOException {
+    protected boolean receive(boolean block) throws IOException {
 
-        first = false;
         bodyMessage.reset();
 
-        readMessage(bodyMessage, true);
+        if (!readMessage(bodyMessage, block)) {
+            return false;
+        }
+
+        waitingForBodyMessage = false;
+        first = false;
 
         // No data received.
         if (bodyMessage.getLen() == 0) {
@@ -960,7 +989,7 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
      *
      * @return true if there is more data, false if not.
      */
-    protected boolean refillReadBuffer() throws IOException {
+    protected boolean refillReadBuffer(boolean block) throws IOException {
         // If the server returns an empty packet, assume that that end of
         // the stream has been reached (yuck -- fix protocol??).
         // FORM support
@@ -972,10 +1001,13 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
         }
 
         // Request more data immediately
-        output(getBodyMessageArray, 0, getBodyMessageArray.length);
+        if (!first && !waitingForBodyMessage) {
+            output(getBodyMessageArray, 0, getBodyMessageArray.length);
+            waitingForBodyMessage = true;
+        }
 
-        boolean moreData = receive();
-        if( !moreData ) {
+        boolean moreData = receive(block);
+        if (!first && !waitingForBodyMessage && !moreData) {
             endOfStream = true;
         }
         return moreData;
@@ -1402,8 +1434,8 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
         finished = true;
 
         // Swallow the unread body packet if present
-        if (first && request.getContentLengthLong() > 0) {
-            receive();
+        if (first && request.getContentLengthLong() > 0 || waitingForBodyMessage) {
+            receive(true);
         }
 
         // Add the end message
@@ -1424,24 +1456,22 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
      */
     protected class SocketInputBuffer implements InputBuffer {
 
-
         /**
          * Read bytes into the specified chunk.
          */
         @Override
-        public int doRead(ByteChunk chunk, Request req)
-        throws IOException {
+        public int doRead(ByteChunk chunk, Request req) throws IOException {
 
             if (endOfStream) {
                 return -1;
             }
             if (first && req.getContentLengthLong() > 0) {
                 // Handle special first-body-chunk
-                if (!receive()) {
+                if (!receive(true)) {
                     return 0;
                 }
             } else if (empty) {
-                if (!refillReadBuffer()) {
+                if (!refillReadBuffer(true)) {
                     return -1;
                 }
             }
@@ -1449,9 +1479,7 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
             chunk.setBytes(bc.getBuffer(), bc.getStart(), bc.getLength());
             empty = true;
             return chunk.getLength();
-
         }
-
     }
 
 

==================================================
AjpNioProcessor.java
index c742045ffc..1dd64edb81 100644
--- a/java/org/apache/coyote/ajp/AjpAprProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpAprProcessor.java
@@ -72,6 +72,12 @@ public class AjpAprProcessor extends AbstractAjpProcessor<Long> {
     protected final ByteBuffer outputBuffer;
 
 
+    @Override
+    protected void registerForEvent(boolean read, boolean write) {
+        ((AprEndpoint) endpoint).getPoller().add(
+                socketWrapper.getSocket().longValue(), -1, read, write);
+    }
+
     @Override
     protected void resetTimeouts() {
         // NO-OP. The AJP APR/native connector only uses the timeout value on

==================================================
AjpProcessor.java
index c0fe378451..3df520af88 100644
--- a/java/org/apache/coyote/ajp/AjpNioProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpNioProcessor.java
@@ -19,6 +19,7 @@ package org.apache.coyote.ajp;
 import java.io.EOFException;
 import java.io.IOException;
 import java.nio.ByteBuffer;
+import java.nio.channels.SelectionKey;
 import java.nio.channels.Selector;
 
 import org.apache.juli.logging.Log;
@@ -56,6 +57,23 @@ public class AjpNioProcessor extends AbstractAjpProcessor<NioChannel> {
     protected final NioSelectorPool pool;
 
 
+    @Override
+    protected void registerForEvent(boolean read, boolean write) {
+        final NioEndpoint.KeyAttachment attach =
+                (NioEndpoint.KeyAttachment)socketWrapper.getSocket().getAttachment(
+                        false);
+        if (attach == null) {
+            return;
+        }
+        if (read) {
+            attach.interestOps(attach.interestOps() | SelectionKey.OP_READ);
+        }
+        if (write) {
+            attach.interestOps(attach.interestOps() | SelectionKey.OP_WRITE);
+        }
+    }
+
+
     @Override
     protected void resetTimeouts() {
         // The NIO connector uses the timeout configured on the wrapper in the

==================================================
AbstractHttp11Processor.java
index 87a941b32e..e67ae55b04 100644
--- a/java/org/apache/coyote/ajp/AjpProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpProcessor.java
@@ -69,6 +69,11 @@ public class AjpProcessor extends AbstractAjpProcessor<Socket> {
     }
 
 
+    @Override
+    protected void registerForEvent(boolean read, boolean write) {
+        // NO-OP for BIO
+    }
+
     @Override
     protected void resetTimeouts() {
         // NO-OP. The AJP BIO connector only uses the timeout value on the

==================================================
SpdyProcessor.java
index d261404b3c..ac35a55be3 100644
--- a/java/org/apache/coyote/http11/AbstractHttp11Processor.java
+++ b/java/org/apache/coyote/http11/AbstractHttp11Processor.java
@@ -1108,15 +1108,6 @@ public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
     }
 
 
-    /**
-     * Register the socket for the specified events.
-     *
-     * @param read  Register the socket for read events
-     * @param write Register the socket for write events
-     */
-    protected abstract void registerForEvent(boolean read, boolean write);
-
-
     /**
      * After reading the request headers, we have to setup the request filters.
      */

==================================================
TesterAjpNonBlockingClient.java
index 59b1f53a99..63ba7300ac 100644
--- a/java/org/apache/coyote/spdy/SpdyProcessor.java
+++ b/java/org/apache/coyote/spdy/SpdyProcessor.java
@@ -496,6 +496,11 @@ public class SpdyProcessor<S> extends AbstractProcessor<S> implements
         return null;
     }
 
+    @Override
+    protected void registerForEvent(boolean read, boolean write) {
+        // NO-OP
+    }
+
     public void onSynStream(SpdyStream str) throws IOException {
         this.spdyStream = str;
         SpdyFrame frame = str.reqFrame;

==================================================
