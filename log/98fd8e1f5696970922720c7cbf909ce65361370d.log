98fd8e1f5696970922720c7cbf909ce65361370d
==================================================
Fix BZ 64947. NPE on custom HTTP upgrade
==================================================
Mark Thomas
==================================================
Tue Dec 1 22:32:00 2020 +0000
==================================================
Request.java
Fix BZ 64947. NPE on custom HTTP upgrade

https://bz.apache.org/bugzilla/show_bug.cgi?id=64947
Don't assume that the Upgrade header has been set on the
HttpServletResponse before any call is made to
HttpServletRequest.upgrade()


==================================================
UpgradeProcessorInternal.java
index 2177a92648..e2dff97ae9 100644
--- a/java/org/apache/catalina/connector/Request.java
+++ b/java/org/apache/catalina/connector/Request.java
@@ -113,6 +113,7 @@ import org.apache.tomcat.util.http.fileupload.impl.SizeException;
 import org.apache.tomcat.util.http.fileupload.servlet.ServletFileUpload;
 import org.apache.tomcat.util.http.fileupload.servlet.ServletRequestContext;
 import org.apache.tomcat.util.http.parser.AcceptLanguage;
+import org.apache.tomcat.util.http.parser.Upgrade;
 import org.apache.tomcat.util.net.SSLSupport;
 import org.apache.tomcat.util.res.StringManager;
 import org.ietf.jgss.GSSCredential;
@@ -126,6 +127,8 @@ import org.ietf.jgss.GSSException;
  */
 public class Request implements HttpServletRequest {
 
+    private static final String HTTP_UPGRADE_HEADER_NAME = "upgrade";
+
     private static final Log log = LogFactory.getLog(Request.class);
 
     /**
@@ -2016,8 +2019,8 @@ public class Request implements HttpServletRequest {
                 SecurityException e) {
             throw new ServletException(e);
         }
-        UpgradeToken upgradeToken = new UpgradeToken(handler,
-                getContext(), instanceManager, response.getHeader("upgrade"));
+        UpgradeToken upgradeToken = new UpgradeToken(handler, getContext(), instanceManager,
+                getUpgradeProtocolName(httpUpgradeHandlerClass));
 
         coyoteRequest.action(ActionCode.UPGRADE, upgradeToken);
 
@@ -2028,6 +2031,29 @@ public class Request implements HttpServletRequest {
         return handler;
     }
 
+
+    private String getUpgradeProtocolName(Class<? extends HttpUpgradeHandler> httpUpgradeHandlerClass) {
+        // Ideal - the caller has already explicitly set the selected protocol
+        // on the response
+        String result = response.getHeader(HTTP_UPGRADE_HEADER_NAME);
+
+        if (result == null) {
+            // If the request's upgrade header contains a single protocol that
+            // is the protocol that must have been selected
+            List<Upgrade> upgradeProtocols = Upgrade.parse(getHeaders(HTTP_UPGRADE_HEADER_NAME));
+            if (upgradeProtocols != null && upgradeProtocols.size() == 1) {
+                result = upgradeProtocols.get(0).toString();
+            }
+        }
+
+        if (result == null) {
+            // Ugly but use the class name - it is better than nothing
+            result = httpUpgradeHandlerClass.getName();
+        }
+        return result;
+    }
+
+
     /**
      * Return the authentication type used for this Request.
      */

==================================================
Upgrade.java
index ddb5759b1f..99c850824f 100644
--- a/java/org/apache/coyote/http11/upgrade/UpgradeProcessorInternal.java
+++ b/java/org/apache/coyote/http11/upgrade/UpgradeProcessorInternal.java
@@ -46,6 +46,8 @@ public class UpgradeProcessorInternal extends UpgradeProcessorBase {
         wrapper.setWriteTimeout(INFINITE_TIMEOUT);
 
         internalHttpUpgradeHandler.setSocketWrapper(wrapper);
+
+        // HTTP/2 uses RequestInfo objects so does not provide upgradeInfo
         UpgradeInfo upgradeInfo = internalHttpUpgradeHandler.getUpgradeInfo();
         if (upgradeInfo != null && upgradeGroupInfo != null) {
             upgradeInfo.setGroupInfo(upgradeGroupInfo);

==================================================
TestUpgrade.java
new file mode 100644
index 0000000000..5e566a1e52
--- /dev/null
+++ b/java/org/apache/tomcat/util/http/parser/Upgrade.java
@@ -0,0 +1,106 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.util.http.parser;
+
+import java.io.IOException;
+import java.io.Reader;
+import java.io.StringReader;
+import java.util.ArrayList;
+import java.util.Enumeration;
+import java.util.List;
+
+public class Upgrade {
+
+    private final String protocolName;
+    private final String protocolVersion;
+
+
+    private Upgrade(String protocolName, String protocolVersion) {
+        this.protocolName = protocolName;
+        this.protocolVersion = protocolVersion;
+    }
+
+
+    public String getProtocolName() {
+        return protocolName;
+    }
+
+
+    public String getProtocolVersion() {
+        return protocolVersion;
+    }
+
+
+    @Override
+    public String toString() {
+        if (protocolVersion == null) {
+            return protocolName;
+        } else {
+            return protocolName + "/" + protocolVersion;
+        }
+    }
+
+
+    public static List<Upgrade> parse (Enumeration<String> headerValues) {
+        try {
+            List<Upgrade> result = new ArrayList<>();
+
+            while (headerValues.hasMoreElements()) {
+                String headerValue = headerValues.nextElement();
+                if (headerValue == null) {
+                    // Invalid
+                    return null;
+                }
+
+                Reader r = new StringReader(headerValue);
+                SkipResult skipComma;
+                do {
+                    // Skip any leading LWS
+                    HttpParser.skipLws(r);
+                    String protocolName = HttpParser.readToken(r);
+                    if (protocolName == null || protocolName.isEmpty()) {
+                        // Invalid
+                        return null;
+                    }
+                    String protocolVersion = null;
+                    if (HttpParser.skipConstant(r, "/") == SkipResult.FOUND) {
+                        protocolVersion = HttpParser.readToken(r);
+                        if (protocolVersion == null || protocolVersion.isEmpty()) {
+                            // Invalid
+                            return null;
+                        }
+                    }
+                    HttpParser.skipLws(r);
+
+                    skipComma = HttpParser.skipConstant(r, ",");
+                    if (skipComma == SkipResult.NOT_FOUND) {
+                        // Invalid
+                        return null;
+                    }
+
+                    result.add(new Upgrade(protocolName, protocolVersion));
+                    // SkipResult.EOF will exit this inner loop
+                } while (skipComma == SkipResult.FOUND);
+            }
+
+            return result;
+        } catch (IOException ioe) {
+            // Should never happen with Strings
+            return null;
+        }
+    }
+}

==================================================
